ulkDataExchangeSize = FIELD_OFFSET(SMB_WRITE_BULK_DATA_EXCHANGE,Buffer) +
                                HeaderMdlSize +
                                DataMdlSize +
                                TRANSPORT_HEADER_SIZE +
                                sizeof(SMB_HEADER) +
                                FIELD_OFFSET(REQ_WRITE_BULK_DATA,Buffer);

    pWriteBulkDataExchange = (PSMB_WRITE_BULK_DATA_EXCHANGE)
                             SmbMmAllocateVariableLengthExchange(
                                 WRITE_BULK_DATA_EXCHANGE,
                                 WriteBulkDataExchangeSize);

    if (pWriteBulkDataExchange != NULL) {
        pWriteBulkDataExchange->pHeaderMdl =
            (PMDL)((PBYTE)pWriteBulkDataExchange +
            FIELD_OFFSET(SMB_WRITE_BULK_DATA_EXCHANGE,Buffer));

        pWriteBulkDataExchange->pDataMdl =
            (PMDL)((PBYTE)pWriteBulkDataExchange->pHeaderMdl + HeaderMdlSize);

        pWriteBulkDataExchange->pHeader =
            (PSMB_HEADER)((PBYTE)pWriteBulkDataExchange->pDataMdl +
                          DataMdlSize + TRANSPORT_HEADER_SIZE);

        pWriteBulkDataExchange->pWriteBulkDataRequest =
            (PREQ_WRITE_BULK_DATA)(pWriteBulkDataExchange->pHeader + 1);

        pWriteBulkDataExchange->WriteBulkDataRequestLength =
            sizeof(SMB_HEADER) +
            FIELD_OFFSET(REQ_WRITE_BULK_DATA,Buffer) +
            DataSizeInBytes;

        RtlCopyMemory(
            pWriteBulkDataExchange->pHeader,
            pSmbHeader,
            sizeof(SMB_HEADER));

        RtlCopyMemory(
            pWriteBulkDataExchange->pWriteBulkDataRequest,
            pWriteBulkDataRequest,
            FIELD_OFFSET(REQ_WRITE_BULK_DATA,Buffer));

        RxInitializeHeaderMdl(
            pWriteBulkDataExchange->pHeaderMdl,
            pWriteBulkDataExchange->pHeader,
            sizeof(SMB_HEADER) + FIELD_OFFSET(REQ_WRITE_BULK_DATA,Buffer));

        RxBuildHeaderMdlForNonPagedPool(pWriteBulkDataExchange->pHeaderMdl);

        IoBuildPartialMdl(
            pDataMdl,
            pWriteBulkDataExchange->pDataMdl,
            (PBYTE)MmGetMdlVirtualAddress(pDataMdl) + DataOffsetInBytes,
            DataSizeInBytes);

        RxDbgTrace(
            0,
            Dbg,
            ("Bulk Data O: %lx, Partial %lx Offset %lx Size %lx\n",
             pDataMdl->MappedSystemVa,
             pWriteBulkDataExchange->pDataMdl->MappedSystemVa,
             DataOffsetInBytes,
             DataSizeInBytes));

        pWriteBulkDataExchange->pHeaderMdl->Next = pWriteBulkDataExchange->pDataMdl;
        pWriteBulkDataExchange->pDataMdl->Next = NULL;

        // Initialize the associated exchange.
        Status = SmbCeInitializeAssociatedExchange(
                     (PSMB_EXCHANGE *)&pWriteBulkDataExchange,
                     (PSMB_EXCHANGE)pWriteExchange,
                     WRITE_BULK_DATA_EXCHANGE,
                     &WriteBulkDataExchangeDispatchVector);

        if (Status == STATUS_SUCCESS) {
            pWriteBulkDataExchange->Mid = pWriteExchange->Mid;
            SetFlag(
                pWriteBulkDataExchange->SmbCeFlags,
                (SMBCE_EXCHANGE_MID_VALID | SMBCE_EXCHANGE_RETAIN_MID));

            *pWriteBulkDataExchangePointer = pWriteBulkDataExchange;
        } else {
            BOOLEAN PostRequest = FALSE;

            MRxSmbWriteBulkDataExchangeFinalize(
                (PSMB_EXCHANGE)pWriteBulkDataExchange,
                &PostRequest);
        }
    }

    return Status;
}

NTSTATUS
MRxSmbWriteBulkDataExchangeStart(
    IN struct _SMB_EXCHANGE *pExchange)
/*++

Routine Description:

    This routine initiates the wriet bulk data exchange operation

Arguments:

    pExchange - pointer to the bulk write data exchange instance.

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_WRITE_BULK_DATA_EXCHANGE pWriteBulkDataExchange;

    PAGED_CODE();

    pWriteBulkDataExchange = (PSMB_WRITE_BULK_DATA_EXCHANGE)pExchange;

    IF_DEBUG {
        ULONG Length = 0;
        PMDL  pTempMdl;

        pTempMdl = pWriteBulkDataExchange->pHeaderMdl;

        while (pTempMdl != NULL) {
            Length += pTempMdl->ByteCount;
            pTempMdl = pTempMdl->Next;
        }

        ASSERT(Length == pWriteBulkDataExchange->WriteBulkDataRequestLength);
    }

    Status = SmbCeSend(
                 pExchange,
                 0,
                 pWriteBulkDataExchange->pHeaderMdl,
                 pWriteBulkDataExchange->WriteBulkDataRequestLength);

    if ((Status != STATUS_PENDING) &&
        (Status != STATUS_SUCCESS)) {

        BOOLEAN PostRequest = FALSE;

        MRxSmbWriteBulkDataExchangeFinalize(
            (PSMB_EXCHANGE)pWriteBulkDataExchange,
            &PostRequest);
    }

    return Status;
}

NTSTATUS
MRxSmbWriteBulkDataExchangeSendCompletionHandler(
    IN struct _SMB_EXCHANGE   *pExchange,    // The exchange instance
    IN PMDL                   pDataBuffer,
    IN NTSTATUS               SendCompletionStatus
    )
/*++

Routine Description:

    This routine handles send completionsn for the write bulk data exchange
    operation

Arguments:

    pExchange - pointer to the bulk write data exchange instance.

    pDataBuffer - the buffer which was transmitted

    SendCompletionStatus - the completion status

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    RxDbgTrace(
        0,
        Dbg,
        ("send completion Associated Write Data Exchange %lx\n",
         pExchange));

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbWriteBulkDataExchangeFinalize(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostRequest)
/*++

Routine Description:

    This routine handles the finalization of the write bulk data exchange

Arguments:

    pExchange - pointer to the bulk write data exchange instance.

    pPostRequest - set to TRUE if the request is to be posted to a worker thread

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    PAGED_CODE();

    if (!RxShouldPostCompletion()) {
        PSMB_WRITE_BULK_DATA_EXCHANGE pWriteBulkDataExchange;

        pWriteBulkDataExchange = (PSMB_WRITE_BULK_DATA_EXCHANGE)pExchange;

        RxDbgTrace(
            0,
            Dbg,
            ("Finalizing Associated Write Data Exchange %lx\n",
             pWriteBulkDataExchange));

        MmPrepareMdlForReuse(
            pWriteBulkDataExchange->pHeaderMdl);

        MmPrepareMdlForReuse(
            pWriteBulkDataExchange->pDataMdl);

        ClearFlag(
            pWriteBulkDataExchange->SmbCeFlags,
            (SMBCE_EXCHANGE_MID_VALID | SMBCE_EXCHANGE_RETAIN_MID));

        SmbCeDiscardExchange(pExchange);

        *pPostRequest = FALSE;
    } else {
        *pPostRequest = TRUE;
    }

    return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
WriteBulkDataExchangeDispatchVector =
                        {
                            MRxSmbWriteBulkDataExchangeStart,
                            NULL,
                            NULL,
                            MRxSmbWriteBulkDataExchangeSendCompletionHandler,
                            MRxSmbWriteBulkDataExchangeFinalize,
                            NULL
                        };




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\bulkw.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bulkw.h

Abstract:

    This module contains the bulk write associated exchange definitions.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#ifndef _BULKW_H_
#define _BULKW_H_

typedef struct _SMB_WRITE_BULK_DATA_EXCHANGE_ {
    SMB_EXCHANGE;

    ULONG                   WriteBulkDataRequestLength;

    PMDL                    pHeaderMdl;
    PMDL                    pDataMdl;
    PSMB_HEADER             pHeader;
    PREQ_WRITE_BULK_DATA    pWriteBulkDataRequest;

    ULONG                   Buffer[];
} SMB_WRITE_BULK_DATA_EXCHANGE,
  *PSMB_WRITE_BULK_DATA_EXCHANGE;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\devfcb.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    stats.h

Abstract:

    This module implements all statistics gathering functionality in the mini redirector

Revision History:

    Balan Sethu Raman     [SethuR]    16-July-1995

Notes:


--*/

#ifndef _STATS_H_
#define _STATS_H_

//
// Macros to update various pieces of statistical information gathered in the
// mini redirector.
//


typedef REDIR_STATISTICS   MRX_SMB_STATISTICS;
typedef PREDIR_STATISTICS  PMRX_SMB_STATISTICS;

extern MRX_SMB_STATISTICS MRxSmbStatistics;

#endif _STATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\csc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Csc.h

Abstract:

    This module defines the clientside cacheing interface for the SMB mini rdr.

Author:

    Joe Linn [JoeLinn]    7-Mar-1995

Revision History:


--*/

#include "dfsfsctl.h"

#ifndef __INCLUDED__SMBMRX_CSC__
#define __INCLUDED__SMBMRX_CSC__

extern BOOLEAN MRxSmbIsCscEnabled;
extern BOOLEAN MRxSmbIsCscEnabledForDisconnected;
extern BOOLEAN MRxSmbCscTransitionEnabledByDefault;
extern BOOLEAN MRxSmbEnableDisconnectedRB;
extern BOOLEAN MRxSmbCscAutoDialEnabled;
extern LONG    vcntTransportsForCSC;

#define Shared_SmbFcbAcquire SmbFcb_HeldShared
#define Exclusive_SmbFcbAcquire SmbFcb_HeldExclusive
#define DroppingFcbLock_SmbFcbAcquire 0x80000000
#define FailImmediately_SmbFcbAcquire 0x40000000

//STATUS_DISCONNECTED is supposed to be server_internal but it's defined in privinc\status.h
//don't use it!!!!
#undef STATUS_DISCONNECTED
#define STATUSx_NOT_IMPLEMENTED_FOR_DISCONNECTED (STATUS_NOT_IMPLEMENTED)


#ifdef MRXSMB_BUILD_FOR_CSC

#define MRXSMB_CSC_SYMLINK_NAME L"\\??\\Shadow"

#define IF_NOT_MRXSMB_CSC_ENABLED if(FALSE)

extern LONG MRxSmbSpecialCopyChunkAllocationSizeMarker;

NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    PIRP Irp,
    PULONG pSessionId);

NTSTATUS
MRxSmbInitializeCSC (
    PUNICODE_STRING SmbMiniRedirectorName
    );

VOID
MRxSmbUninitializeCSC (
    void
    );


NTSTATUS
MRxSmbCscIoCtl (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCscAcquireSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN  ULONG TypeOfAcquirePlusFlags,
    OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

VOID
MRxSmbCscReleaseSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

NTSTATUS
MRxSmbCscReadPrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

VOID
MRxSmbCscReadEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

NTSTATUS
MRxSmbCscWritePrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

VOID
MRxSmbCscWriteEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

VOID
MRxSmbCscSetFileInfoEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

BOOLEAN
MRxSmbCscIsThisACopyChunkOpen (
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN *lpfAgentOpen
    );

NTSTATUS
MRxSmbCscPartOfCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_NET_ROOT NetRoot
    );

NTSTATUS
MRxSmbCscCreatePrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

VOID
MRxSmbCscCreateEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status,
    IN     SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

VOID
MRxSmbCscDeleteAfterCloseEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

VOID
MRxSmbCscRenameEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

VOID
MRxSmbCscCloseShadowHandle (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxSmbCscUpdateShadowFromClose (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

VOID
MRxSmbCscTearDownCscNetRoot (
    IN OUT PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    );

VOID
MRxSmbCscDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

VOID
MRxSmbCscAgentSynchronizationOnStart (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxSmbCscAgentSynchronizationOnStop (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxSmbCscSignalNetStatus(
    BOOLEAN NetPresent,
    BOOLEAN fFirstLast
    );

VOID
MRxSmbCscReleaseRxContextFromAgentWait (
    void
    );

VOID
MRxSmbCscReportFileOpens (
    void
    );

NTSTATUS
MRxSmbCscSetSecurityPrologue (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxSmbCscSetSecurityEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    );

BOOLEAN
CscIsServerOffline(
    PWCHAR ServerName);

NTSTATUS
CscTakeServerOffline(
    PWCHAR ServerName);

NTSTATUS
CscTransitionServerToOnline(
    ULONG hServer);

NTSTATUS
CscTransitionServerToOffline(
    ULONG   SessionId,
    ULONG   hServer,
    ULONG   TransitionStatus);

NTSTATUS
CscTransitionServerEntryForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PRX_CONTEXT             pRxContext,
    NTSTATUS                RemoteStatus,
    BOOLEAN                 fInvokeAutoDial
    );

VOID
CscPrepareServerEntryForOnlineOperationFull(
    PSMBCEDB_SERVER_ENTRY   pServerEntry);

VOID
CscPrepareServerEntryForOnlineOperationPartial(
    PSMBCEDB_SERVER_ENTRY   pServerEntry);

NTSTATUS
CscTransitionVNetRootForDisconnectedOperation(
    PRX_CONTEXT     RxContext,
    PMRX_V_NET_ROOT pVNetRoot,
    NTSTATUS        RemoteStatus);

BOOLEAN
CscPerformOperationInDisconnectedMode(
    PRX_CONTEXT RxContext);

BOOLEAN
CscGetServerNameWaitingToGoOffline(
    OUT     PWCHAR      ServerName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    );

BOOLEAN
CscShareIdToShareName(
    IN      ULONG       hShare,
    OUT     PWCHAR      ServerName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    );

NTSTATUS
CscPreProcessCreateIrp(
    PIRP   pIrp);

NTSTATUS
MRxSmbCscNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCscCleanupFobx(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCscInitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    );

VOID
MRxSmbCscUninitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    );


NTSTATUS
CscInitializeServerEntryDfsRoot(
    PRX_CONTEXT             pRxContext,
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    );

PDFS_NAME_CONTEXT
CscIsValidDfsNameContext(
    PVOID   pFsContext);

BOOL
CSCCheckLocalOpens(
      PRX_CONTEXT             pRxContext
      );

#else

#ifdef MRXSMB_BUILD_FOR_CSC_DCON
#error....no build-for-csc-dcon w/o build-for-csc
#undef MRXSMB_BUILD_FOR_CSC_DCON
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON

#define IF_MRXSMB_CSC_ENABLED if(FALSE)
#define IF_NOT_MRXSMB_CSC_ENABLED if(TRUE)

#define MRxSmbInitializeCSC(__name) (STATUS_SUCCESS)
#define MRxSmbUninitializeCSC() {NOTHING;}
#define MRxSmbCscIoCtl(__rxcontext) (STATUS_INVALID_DEVICE_REQUEST)
#define MRxSmbCscReleaseSmbFcb(__rxcontext,__holdstate) {NOTHING;}
#define MRxSmbCscAcquireSmbFcb(__rxcontext,__flags,__holdstate) (STATUS_SUCCESS)
#define MRxSmbCscReadPrologue(__rxcontext,__holdstate) (STATUS_MORE_PROCESSING_REQUIRED)
#define MRxSmbCscReadEpilogue(__rxcontext,__status) {NOTHING;}
#define MRxSmbCscWritePrologue(__rxcontext,__holdstate) (STATUS_MORE_PROCESSING_REQUIRED)
#define MRxSmbCscWriteEpilogue(__rxcontext,__status) {NOTHING;}
#define MRxSmbCscSetFileInfoEpilogue(__rxcontext,__status) {NOTHING;}
#define MRxSmbCscIsThisACopyChunkOpen(__rxcontext) (FALSE)
#define MRxSmbCscPartOfCreateVNetRoot(__rxcontext,__netroot) (STATUS_NOT_IMPLEMENTED)
#define MRxSmbCscCreatePrologue(__rxcontext,__holdstate) (STATUS_MORE_PROCESSING_REQUIRED)
#define MRxSmbCscCreateEpilogue(__rxcontext,__status,_holdstate) {NOTHING;}
#define MRxSmbCscDeleteAfterCloseEpilogue(__rxcontext,__status) {NOTHING;}
#define MRxSmbCscRenameEpilogue(__rxcontext,__status) {NOTHING;}
#define MRxSmbCscCloseShadowHandle(__rxcontext) {NOTHING;}
// this is interesting....altho there's 2 args to the function...it's
// only one in macro land.........
#define MRxSmbCscUpdateShadowFromClose(__SMBPSE_OE_ARGS) {NOTHING;}
#define MRxSmbCscTearDownCscNetRoot(__smbnetrootentry) {NOTHING;}
#define MRxSmbCscDeallocateForFcb(pFcb) {NOTHING;}


#define MRxSmbCscAgentSynchronizationOnStart(__rxc) {NOTHING;}
#define MRxSmbCscAgentSynchronizationOnStop(__rxc) {NOTHING;}
#define MRxSmbCscSignalNetStatus(__Flags) {NOTHING};

#define MRxSmbCscReleaseRxContextFromAgentWait(__unsetflags) {NOTHING;}
#define MRxSmbCscReportFileOpens() {NOTHING;}
#define CscTransitionServerEntryForDisconnectedOperation(__serverentry,__status) {NOTHING;}
#define CscTransitionNetRootEntryForDisconnectedOperation(__serverentry,__netrootentry,__status) {NOTHING;}
#define CscPerformOperationInDisconnectedMode(__rxcontext) FALSE
#define CscPreProcessCreateIrp(__Irp__) STATUS_SUCCESS
#endif //ifdef MRXSMB_BUILD_FOR_CSC




#ifdef MRXSMB_BUILD_FOR_CSC_DCON

#define IF_MRXSMB_BUILD_FOR_DISCONNECTED_CSC if(TRUE)
#define IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC if(FALSE)

NTSTATUS
MRxSmbCscNegotiateDisconnected(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    );
VOID
MRxSmbCscUninitForTranportSurrogate(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    );
VOID
MRxSmbCscInitForTranportSurrogate(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PNTSTATUS Status
    );
NTSTATUS
MRxSmbCscDisconnectedConnect (
    IN OUT PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange
    );

NTSTATUS
MRxSmbDCscExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxSmbDCscFlush (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbDCscQueryVolumeInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbDCscQueryDirectory (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbDCscQueryFileInfo (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbDCscSetFileInfo (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbDCscIsValidDirectory(
    IN OUT struct _RX_CONTEXT *RxContext,
    IN     PUNICODE_STRING    DirectoryName);

#else

#define SmbCscCeIsSpecialCscTransport(pServerEntry) (FALSE)

#define IF_MRXSMB_BUILD_FOR_DISCONNECTED_CSC if(FALSE)
#define IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC if(TRUE)

#define MRxSmbCscNegotiateDisconnected(__se) (STATUS_INVALID_HANDLE)
#define MRxSmbCscUninitForTranportSurrogate(__se) {NOTHING;}
#define MRxSmbCscInitForTranportSurrogate(__se,__status) {NOTHING;}
#define MRxSmbCscDisconnectedConnect(__cnrex) (STATUS_SUCCESS)

#define MRxSmbDCscExtendForCache(__rxcontext,__a,__b) ((STATUS_MORE_PROCESSING_REQUIRED))

#define MRxSmbDCscFlush(__rxcontext) ((STATUS_MORE_PROCESSING_REQUIRED))
#define MRxSmbDCscQueryVolumeInformation(__rxcontext) ((STATUS_MORE_PROCESSING_REQUIRED))
#define MRxSmbDCscQueryDirectory(__rxcontext) ((STATUS_MORE_PROCESSING_REQUIRED))
#define MRxSmbDCscQueryFileInfo(__rxcontext) ((STATUS_MORE_PROCESSING_REQUIRED))
#define MRxSmbDCscSetFileInfo(__rxcontext) ((STATUS_MORE_PROCESSING_REQUIRED))
#define MRxSmbDCscIsValidDirectory(__rxcontext, _directory_name) ((STATUS_MORE_PROCESSING_REQUIRED))

#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON

#endif //ifndef __INCLUDED__SMBMRX_CSC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\devfcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all the passthru stuff from the wrapper. currently
    there is only one such function:
         statistics


Revision History:

    Balan Sethu Raman     [SethuR]    16-July-1995

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"
#include "usrcnnct.h"
#include "remboot.h"
#include "rdrssp\secret.h"
#include "windns.h"

#ifdef MRXSMB_BUILD_FOR_CSC
#include "csc.h"
#endif //ifdef MRXSMB_BUILD_FOR_CSC


//
// Forward declarations.
//

NTSTATUS
MRxSmbInitializeRemoteBootParameters(
    PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbRemoteBootInitializeSecret(
    PRX_CONTEXT RxContext
    );

#if defined(REMOTE_BOOT)
NTSTATUS
MRxSmbRemoteBootCheckForNewPassword(
    PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbRemoteBootIsPasswordSettable(
    PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbRemoteBootSetNewPassword(
    PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbStartRbr(
    PRX_CONTEXT RxContext
    );

//
// This function is in ea.c.
//

VOID
MRxSmbInitializeExtraAceArray(
    VOID
    );
#endif // defined(REMOTE_BOOT)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetStatistics)
#pragma alloc_text(PAGE, MRxSmbDevFcbXXXControlFile)
#pragma alloc_text(PAGE, MRxSmbSetConfigurationInformation)
#pragma alloc_text(PAGE, MRxSmbGetConfigurationInformation)
#pragma alloc_text(PAGE, MRxSmbExternalStart)
#pragma alloc_text(PAGE, MRxSmbTestDevIoctl)
#pragma alloc_text(PAGE, MRxSmbInitializeRemoteBootParameters)
#pragma alloc_text(PAGE, MRxSmbRemoteBootInitializeSecret)
#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, MRxSmbRemoteBootCheckForNewPassword)
#pragma alloc_text(PAGE, MRxSmbRemoteBootIsPasswordSettable)
#pragma alloc_text(PAGE, MRxSmbRemoteBootSetNewPassword)
#pragma alloc_text(PAGE, MRxSmbStartRbr)
#endif // defined(REMOTE_BOOT)
#endif

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)

MRX_SMB_STATISTICS MRxSmbStatistics;

NTSTATUS
MRxSmbGetStatistics(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gathers the statistics from the mini redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error.

Notes:

--*/
{
   PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

   PMRX_SMB_STATISTICS pStatistics;
   ULONG BufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;

   PAGED_CODE();

   pStatistics = (PMRX_SMB_STATISTICS)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);

   if (BufferLength < sizeof(MRX_SMB_STATISTICS)) {
      return STATUS_INVALID_PARAMETER;
   }

   RxContext->InformationToReturn = sizeof(MRX_SMB_STATISTICS);
   MRxSmbStatistics.SmbsReceived.QuadPart++;

   //some stuff we have to copy from the device object......
   MRxSmbStatistics.PagingReadBytesRequested = MRxSmbDeviceObject->PagingReadBytesRequested;
   MRxSmbStatistics.NonPagingReadBytesRequested = MRxSmbDeviceObject->NonPagingReadBytesRequested;
   MRxSmbStatistics.CacheReadBytesRequested = MRxSmbDeviceObject->CacheReadBytesRequested;
   MRxSmbStatistics.NetworkReadBytesRequested = MRxSmbDeviceObject->NetworkReadBytesRequested;
   MRxSmbStatistics.PagingWriteBytesRequested = MRxSmbDeviceObject->PagingWriteBytesRequested;
   MRxSmbStatistics.NonPagingWriteBytesRequested = MRxSmbDeviceObject->NonPagingWriteBytesRequested;
   MRxSmbStatistics.CacheWriteBytesRequested = MRxSmbDeviceObject->CacheWriteBytesRequested;
   MRxSmbStatistics.NetworkWriteBytesRequested = MRxSmbDeviceObject->NetworkWriteBytesRequested;
   MRxSmbStatistics.ReadOperations = MRxSmbDeviceObject->ReadOperations;
   MRxSmbStatistics.RandomReadOperations = MRxSmbDeviceObject->RandomReadOperations;
   MRxSmbStatistics.WriteOperations = MRxSmbDeviceObject->WriteOperations;
   MRxSmbStatistics.RandomWriteOperations = MRxSmbDeviceObject->RandomWriteOperations;

   MRxSmbStatistics.LargeReadSmbs = MRxSmbStatistics.ReadSmbs - MRxSmbStatistics.SmallReadSmbs;
   MRxSmbStatistics.LargeWriteSmbs = MRxSmbStatistics.WriteSmbs - MRxSmbStatistics.SmallWriteSmbs;

   MRxSmbStatistics.CurrentCommands = SmbCeStartStopContext.ActiveExchanges;

   *pStatistics = MRxSmbStatistics;

   return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

Notes:

    There are some dependencies between the browser service and the redirector
    service that have implications regarding the sequence of actions for starting
    the mini redirector.

    The current LANMAN workstation service opens the LANMAN and BROWSER device
    objects, issues the LMR_START and LMDR_START IOCTL's and subsequently
    issues the BIND_TO_TRANSPORT IOCTL.

    In the multiple mini rdr/wrapper design for PNP the TDI registration is done
    at wrapper load time and the mini rdrs are notified of the existing transports
    at START time ( LMR_START ). Since there are no BIND_TO_TRANSPORT IOCTL in
    PNP the rdr is responsible for issuing the BIND_TO_TRANSPORT IOCTL to the \
    browser.

    This should be changed by having the BROWSER gave its own TDI registration
    but till then the invocatioon of RxStartMiniRdr routine must be deferred to
    FSCTL_LMR_BIND_TO_TRANSPORT so that the browser has been initialized correctly.

    The reason for this convoluted change is that there is a code freeze for checking
    in changes to the workstation  service/browser.

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    LUID ClientLogonID;
    LUID SystemLogonID = SYSTEM_LUID;
    BOOLEAN IsInServicesProcess = FALSE;
    SECURITY_SUBJECT_CONTEXT ClientContext;

    PAGED_CODE();
    
    SeCaptureSubjectContext(&ClientContext);
    SeLockSubjectContext(&ClientContext);
    
    Status = SeQueryAuthenticationIdToken(
                 SeQuerySubjectContextToken(&ClientContext), 
                 &ClientLogonID);

    if (Status == STATUS_SUCCESS) {
        IsInServicesProcess = RtlEqualLuid(&ClientLogonID,&SystemLogonID);
    }
    
    SeUnlockSubjectContext(&ClientContext);
    SeReleaseSubjectContext(&ClientContext);
    
    RxDbgTrace(+1, Dbg, ("MRxSmbDevFcb\n"));
    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
            case IRP_MN_USER_FS_REQUEST:
                switch (ControlCode) {

                case FSCTL_LMR_START:               // normal start from wkssvc
                case FSCTL_LMR_START | 0x80000000:  // remote boot start from ioinit
                    switch (MRxSmbState) {

                    case MRXSMB_STARTABLE:
                        // The correct sequence of start events issued by the workstation
                        // service would have avoided this. We can recover from this
                        // by actually invoking RxStartMiniRdr.
                        // Note that a start from ioinit for remote boot leaves the
                        // redirector in the STARTABLE state.
                        
                        if (capFobx) {
                            Status = STATUS_INVALID_DEVICE_REQUEST;
                            goto FINALLY;
                        }

                        if (ControlCode != FSCTL_LMR_START) {

                            //
                            // Set a flag indicating that we are doing a remote boot.
                            //

                            MRxSmbBootedRemotely = TRUE;
                        }

                        //
                        // Now is the time to read the registry to get the
                        // computer name. We need to know whether this is
                        // a remote boot before doing this in order to know
                        // whether to read the computer name from the
                        // ActiveComputerName key or the ComputerName key.
                        // See the comment in init.c\SmbCeGetComputerName().
                        //

                        if (SmbCeContext.ComputerName.Buffer == NULL) {
                            Status = SmbCeGetComputerName();
                        } else {
                            Status = STATUS_SUCCESS;
                        }

                        if (Status == STATUS_SUCCESS) {
                            Status = MRxSmbExternalStart( RxContext );
                        }

                        if (Status != STATUS_SUCCESS) {
                            return(Status);
                        }
                        //lack of break is intentional

                    case MRXSMB_START_IN_PROGRESS:
                        {
                            Status = RxStartMinirdr(RxContext,&RxContext->PostRequest);

                            if (Status == STATUS_REDIRECTOR_STARTED) {
                                Status = STATUS_SUCCESS;
                            }

                            //
                            // If we're initializing remote boot, store
                            // certain parameters now.
                            //

                            if ((Status == STATUS_SUCCESS) &&
                                (ControlCode != FSCTL_LMR_START)) {
                                Status = MRxSmbInitializeRemoteBootParameters(RxContext);
                            }

                            //
                            // If we are a remote boot client, and this start
                            // comes from the workstation service, now is the
                            // time to initialize the security package.
                            //

                            if (MRxSmbBootedRemotely &&
                                (Status == STATUS_SUCCESS) &&
                                (ControlCode == FSCTL_LMR_START)) {
                                Status = MRxSmbInitializeSecurity();
                            }

                        }
                        break;

                    case MRXSMB_STARTED:
                        Status = STATUS_SUCCESS;
                        break;

                    default:

                        break;
                    }

                    break;

                case FSCTL_LMR_STOP:
                    if (!IsInServicesProcess) {
                        Status = STATUS_ACCESS_DENIED;
                        goto FINALLY;
                    }

                    if (capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }
                    
                    IF_NOT_MRXSMB_CSC_ENABLED{
                        NOTHING;
                    } else {
                        if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP)) {
                            MRxSmbCscAgentSynchronizationOnStop(RxContext);
                        }
                    }

                    //
                    // The redirector cannot be stopped on a remote boot machine.
                    // Ignore (don't fail) the stop request.
                    //

                    if (!MRxSmbBootedRemotely) {
                        if (RxContext->RxDeviceObject->NumberOfActiveFcbs > 0) {
                            return STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
                        } else {
                            MRXSMB_STATE CurrentState;

                            CurrentState = (MRXSMB_STATE)
                                            InterlockedCompareExchange(
                                                (PLONG)&MRxSmbState,
                                                MRXSMB_STOPPED,
                                                MRXSMB_STARTED);

                            // Only allow mrxsmb to be unloaded from workstation services
                            MRxSmbDeviceObject->DriverObject->DriverUnload = MRxSmbUnload;
                            
                            //if (CurrentState == MRXSMB_STARTED) {
                                Status = RxStopMinirdr(
                                             RxContext,
                                             &RxContext->PostRequest );
                                             
                                if (Status == STATUS_SUCCESS)
                                {
                                    MRxSmbPreUnload();
                                }
                            //} else {
                            //    Status = STATUS_REDIRECTOR_NOT_STARTED;
                            //}
                        }
                    } else {
                        Status = STATUS_SUCCESS;
                    }
                    break;

                case FSCTL_LMR_BIND_TO_TRANSPORT:               // normal bind from wkssvc
                    Status = STATUS_SUCCESS;
                    break;

                case FSCTL_LMR_BIND_TO_TRANSPORT | 0x80000000:  // remote boot bind from ioinit
                    Status = MRxSmbRegisterForPnpNotifications();
                    break;

                case FSCTL_LMR_UNBIND_FROM_TRANSPORT:
                    Status = STATUS_SUCCESS;
                    break;

                case FSCTL_LMR_ENUMERATE_TRANSPORTS:
                    if (capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }
                    
                    Status = MRxEnumerateTransports(
                                 RxContext,
                                 &RxContext->PostRequest);
                    break;

                case FSCTL_LMR_ENUMERATE_CONNECTIONS:
                    if (capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }
                    
                    Status = MRxSmbEnumerateConnections(
                                 RxContext,
                                 &RxContext->PostRequest );
                    break;

                case FSCTL_LMR_GET_CONNECTION_INFO:
                    if (!capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }
                    
                    Status = MRxSmbGetConnectionInfo(
                                 RxContext,
                                 &RxContext->PostRequest );
                    break;

                case FSCTL_LMR_DELETE_CONNECTION:
                    if (!capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }
                    
                    Status = MRxSmbDeleteConnection(
                                 RxContext,
                                 &RxContext->PostRequest );

                    break;

                case FSCTL_LMR_GET_STATISTICS:
                    Status = MRxSmbGetStatistics(RxContext);
                    break;

                case FSCTL_LMR_GET_CONFIG_INFO:
                    if (!IsInServicesProcess) {
                        Status = STATUS_ACCESS_DENIED;
                        goto FINALLY;
                    }
                    
                    Status = MRxSmbGetConfigurationInformation(RxContext);
                    break;

                case FSCTL_LMR_SET_CONFIG_INFO:
                    if (!IsInServicesProcess) {
                        Status = STATUS_ACCESS_DENIED;
                        goto FINALLY;
                    }
                    
                    Status = MRxSmbSetConfigurationInformation(RxContext);
                    break;

                case FSCTL_LMR_SET_DOMAIN_NAME:
                    if (!IsInServicesProcess) {
                        Status = STATUS_ACCESS_DENIED;
                        goto FINALLY;
                    }

                    Status = MRxSmbSetDomainName(RxContext);
                    break;

#if 0
                case FSCTL_LMMR_STFFTEST:
                    Status = MRxSmbStufferDebug(RxContext);
                    break;
#endif //if 0

#if defined(REMOTE_BOOT)
                case FSCTL_LMR_START_RBR:
                    Status = MRxSmbStartRbr(RxContext);
                    break;
#endif // defined(REMOTE_BOOT)

                case FSCTL_LMMR_RI_INITIALIZE_SECRET:
                    Status = MRxSmbRemoteBootInitializeSecret(RxContext);
                    break;

#if defined(REMOTE_BOOT)
                case FSCTL_LMMR_RI_CHECK_FOR_NEW_PASSWORD:
                    Status = MRxSmbRemoteBootCheckForNewPassword(RxContext);
                    break;

                case FSCTL_LMMR_RI_IS_PASSWORD_SETTABLE:
                    Status = MRxSmbRemoteBootIsPasswordSettable(RxContext);
                    break;

                case FSCTL_LMMR_RI_SET_NEW_PASSWORD:
                    Status = MRxSmbRemoteBootSetNewPassword(RxContext);
                    break;
#endif // defined(REMOTE_BOOT)
        case FSCTL_LMR_SET_SERVER_GUID:
            Status = MRxSmbSetServerGuid(RxContext);
            break;
                case FSCTL_LMR_GET_VERSIONS:
                case FSCTL_LMR_GET_HINT_SIZE:
                case FSCTL_LMR_ENUMERATE_PRINT_INFO:
                case FSCTL_LMR_START_SMBTRACE:
                case FSCTL_LMR_END_SMBTRACE:
                    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBFsCtl -> unimplemented rdr1 fsctl\n"));
                    //lack of break intentional
                default:
                    Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

            default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            } // end of switch
        } // end of FSCTL case
        break;

    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {
#if DBG
            case IOCTL_LMMR_TEST:
                Status = MRxSmbTestDevIoctl(RxContext);
                break;
#endif //if DBG

            case IOCTL_LMMR_USEKERNELSEC:

                if (MRxSmbBootedRemotely) {
                    MRxSmbUseKernelModeSecurity = TRUE;
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                }
                break;
                
            default :
                Status = MRxSmbCscIoCtl(RxContext);

            } // end of switch
        } //end of IOCTL cases
        break;
    default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

FINALLY:    
    RxDbgTrace(
        -1,
        Dbg,
        ("MRxSmbDevFcb st,info=%08lx,%08lx\n",
         Status,
         RxContext->InformationToReturn));
    return(Status);

}

NTSTATUS
MRxSmbSetConfigurationInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine sets the configuration information associated with the
    redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PWKSTA_INFO_502  pWorkStationConfiguration = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG BufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxCommonDevFCBFsCtl -> FSCTL_LMR_GET_CONFIG_INFO\n"));
    if (BufferLength < sizeof(WKSTA_INFO_502)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RxContext->InformationToReturn = sizeof(WKSTA_INFO_502);

    // Initialize the configuration information .....
    MRxSmbConfiguration.NamedPipeDataCollectionTimeInterval
                = pWorkStationConfiguration->wki502_collection_time;
    MRxSmbConfiguration.NamedPipeDataCollectionSize
                = pWorkStationConfiguration->wki502_maximum_collection_count;
    MRxSmbConfiguration.MaximumNumberOfCommands
                = pWorkStationConfiguration->wki502_max_cmds;
    MRxSmbConfiguration.SessionTimeoutInterval
                = pWorkStationConfiguration->wki502_sess_timeout;
    MRxSmbConfiguration.LockQuota
                = pWorkStationConfiguration->wki502_lock_quota;
    MRxSmbConfiguration.LockIncrement
                = pWorkStationConfiguration->wki502_lock_increment;
    MRxSmbConfiguration.MaximumLock
                = pWorkStationConfiguration->wki502_lock_maximum;
    MRxSmbConfiguration.PipeIncrement
                = pWorkStationConfiguration->wki502_pipe_increment;
    MRxSmbConfiguration.PipeMaximum
                = pWorkStationConfiguration->wki502_pipe_maximum;
    MRxSmbConfiguration.CachedFileTimeout
                = pWorkStationConfiguration->wki502_cache_file_timeout;
    MRxSmbConfiguration.DormantFileLimit
                = pWorkStationConfiguration->wki502_dormant_file_limit;
    MRxSmbConfiguration.NumberOfMailslotBuffers
                = pWorkStationConfiguration->wki502_num_mailslot_buffers;

    MRxSmbConfiguration.UseOplocks
                = pWorkStationConfiguration->wki502_use_opportunistic_locking != FALSE;
    MRxSmbConfiguration.UseUnlocksBehind
                = pWorkStationConfiguration->wki502_use_unlock_behind != FALSE;
    MRxSmbConfiguration.UseCloseBehind
                = pWorkStationConfiguration->wki502_use_close_behind != FALSE;
    MRxSmbConfiguration.BufferNamedPipes
                = pWorkStationConfiguration->wki502_buf_named_pipes != FALSE;
    MRxSmbConfiguration.UseLockReadUnlock
                = pWorkStationConfiguration->wki502_use_lock_read_unlock != FALSE;
    MRxSmbConfiguration.UtilizeNtCaching
                = pWorkStationConfiguration->wki502_utilize_nt_caching != FALSE;
    MRxSmbConfiguration.UseRawRead
                = pWorkStationConfiguration->wki502_use_raw_read != FALSE;
    MRxSmbConfiguration.UseRawWrite
                = pWorkStationConfiguration->wki502_use_raw_write != FALSE;
    MRxSmbConfiguration.UseEncryption
                = pWorkStationConfiguration->wki502_use_encryption != FALSE;

    MRxSmbConfiguration.MaximumNumberOfThreads
                = pWorkStationConfiguration->wki502_max_threads;
    MRxSmbConfiguration.ConnectionTimeoutInterval
                = pWorkStationConfiguration->wki502_keep_conn;
    MRxSmbConfiguration.CharBufferSize
                = pWorkStationConfiguration->wki502_siz_char_buf;

#define printit(x) {DbgPrint("%s %x %x %d\n",#x,&x,x,x);}
    if (0) {
        printit(MRxSmbConfiguration.LockIncrement);
        printit(MRxSmbConfiguration.MaximumLock);
        printit(MRxSmbConfiguration.PipeIncrement);
        printit(MRxSmbConfiguration.PipeMaximum);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
MRxSmbGetConfigurationInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine retrieves the configuration information associated with the
    redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PWKSTA_INFO_502  pWorkStationConfiguration = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG BufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbGetConfigurationInformation\n"));
    if (BufferLength < sizeof(WKSTA_INFO_502)) {
       return STATUS_INVALID_PARAMETER;
    }

    RxContext->InformationToReturn = sizeof(WKSTA_INFO_502);

    // Initialize the configuration information .....
    pWorkStationConfiguration->wki502_collection_time
                = MRxSmbConfiguration.NamedPipeDataCollectionTimeInterval;
    pWorkStationConfiguration->wki502_maximum_collection_count
                = MRxSmbConfiguration.NamedPipeDataCollectionSize;
    pWorkStationConfiguration->wki502_max_cmds
                = MRxSmbConfiguration.MaximumNumberOfCommands;
    pWorkStationConfiguration->wki502_sess_timeout
                = MRxSmbConfiguration.SessionTimeoutInterval;
    pWorkStationConfiguration->wki502_lock_quota
                = MRxSmbConfiguration.LockQuota;
    pWorkStationConfiguration->wki502_lock_increment
                = MRxSmbConfiguration.LockIncrement;
    pWorkStationConfiguration->wki502_lock_maximum
                = MRxSmbConfiguration.MaximumLock;
    pWorkStationConfiguration->wki502_pipe_increment
                = MRxSmbConfiguration.PipeIncrement;
    pWorkStationConfiguration->wki502_pipe_maximum
                = MRxSmbConfiguration.PipeMaximum;
    pWorkStationConfiguration->wki502_cache_file_timeout
                = MRxSmbConfiguration.CachedFileTimeout;
    pWorkStationConfiguration->wki502_dormant_file_limit
                = MRxSmbConfiguration.DormantFileTimeout;
    pWorkStationConfiguration->wki502_num_mailslot_buffers
                = MRxSmbConfiguration.NumberOfMailslotBuffers;

    pWorkStationConfiguration->wki502_use_opportunistic_locking
                = MRxSmbConfiguration.UseOplocks;
    pWorkStationConfiguration->wki502_use_unlock_behind
                = MRxSmbConfiguration.UseUnlocksBehind;
    pWorkStationConfiguration->wki502_use_close_behind
                = MRxSmbConfiguration.UseCloseBehind;
    pWorkStationConfiguration->wki502_buf_named_pipes
                = MRxSmbConfiguration.BufferNamedPipes;
    pWorkStationConfiguration->wki502_use_lock_read_unlock
                = MRxSmbConfiguration.UseLockReadUnlock;
    pWorkStationConfiguration->wki502_utilize_nt_caching
                = MRxSmbConfiguration.UtilizeNtCaching;
    pWorkStationConfiguration->wki502_use_raw_read
                = MRxSmbConfiguration.UseRawRead;
    pWorkStationConfiguration->wki502_use_raw_write
                = MRxSmbConfiguration.UseRawWrite;
    pWorkStationConfiguration->wki502_use_encryption
                = MRxSmbConfiguration.UseEncryption;

    pWorkStationConfiguration->wki502_max_threads
                = MRxSmbConfiguration.MaximumNumberOfThreads;
    pWorkStationConfiguration->wki502_keep_conn
                = MRxSmbConfiguration.ConnectionTimeoutInterval;
    pWorkStationConfiguration->wki502_siz_char_buf
                = MRxSmbConfiguration.CharBufferSize;

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbExternalStart (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine starts up the smb minirdr if it hasn't been started already. It also fills in
    the initial configuration.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    BOOLEAN       InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);
    MRXSMB_STATE  State;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbExternalStart [Start] -> %08lx\n", 0));

    //
    // If this is a normal start (from the workstation service), change state from
    // STARTABLE to START_IN_PROGRESS. If this is a remote boot start (from ioinit),
    // don't change state. This is necessary to allow the workstation service to
    // initialize correctly when it finally comes up.
    //

    if ( RxContext->LowIoContext.ParamsFor.FsCtl.FsControlCode == FSCTL_LMR_START ) {
        State = (MRXSMB_STATE)InterlockedCompareExchange(
                                  (PLONG)&MRxSmbState,
                                  MRXSMB_START_IN_PROGRESS,
                                  MRXSMB_STARTABLE);
    } else {
        State = MRxSmbState;
    }

    if (State == MRXSMB_STARTABLE) {

        IF_NOT_MRXSMB_CSC_ENABLED{
            NOTHING;
        } else {
            if (InFSD) {
                MRxSmbCscAgentSynchronizationOnStart(RxContext);
            }
        }

       // Owing to the peculiarities associated with starting the browser and the
       // redirector in the workstation service the following call has been
       // moved to the routine for handling FSCTL's for binding to transports.
       // Status = RxStartMinirdr( RxContext, &RxContext->PostRequest );

        if (InFSD) {
            RxCaptureFobx;
            PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

            PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;

            if ( RxContext->LowIoContext.ParamsFor.FsCtl.FsControlCode == FSCTL_LMR_START ) {

                //
                // Now is the time to read the registry to get the OS version
                // and build number. The workstation service issued this request,
                // so we know that the software hive has been loaded (a long time
                // ago, actually).
                //

                Status = SmbCeGetOperatingSystemInformation();
                if (Status != STATUS_SUCCESS) {
                    return(Status);
                }
            }

            SmbCeContext.DomainName.Length = (USHORT)pLmrRequestBuffer->Parameters.Start.DomainNameLength;
            SmbCeContext.DomainName.MaximumLength = SmbCeContext.DomainName.Length;

            if (SmbCeContext.DomainName.Buffer != NULL) {
                RxFreePool(SmbCeContext.DomainName.Buffer);
                SmbCeContext.DomainName.Buffer = NULL;
            }

            if (SmbCeContext.DomainName.Length > 0) {
                SmbCeContext.DomainName.Buffer = RxAllocatePoolWithTag(
                                                     PagedPool,
                                                     SmbCeContext.DomainName.Length,
                                                     MRXSMB_MISC_POOLTAG);
                if (SmbCeContext.DomainName.Buffer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    // The computer name and the domain name are concatenated together in the
                    // request packet.

                    RtlCopyMemory(
                        SmbCeContext.DomainName.Buffer,
                        &(pLmrRequestBuffer->Parameters.Start.RedirectorName[
                                pLmrRequestBuffer->Parameters.Start.RedirectorNameLength / sizeof(WCHAR)]),
                        SmbCeContext.DomainName.Length);
                }
            }

            Status = MRxSmbSetConfigurationInformation(RxContext);
            if (Status!=STATUS_SUCCESS) {
                return(Status);
            }

            if (SmbCeContext.DomainName.Length > 0) {
               Status = RxSetDomainForMailslotBroadcast(&SmbCeContext.DomainName);
               if (Status != STATUS_SUCCESS) {
                   return(Status);
               }
            }
        }
    } else {
        Status = STATUS_REDIRECTOR_STARTED;
    }

    return Status;
}

#if DBG
NTSTATUS
MRxSmbTestDevIoctl(
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PSZ InputString = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PSZ OutputString = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG i;

    PAGED_CODE();

    RxDbgTrace(0, Dbg,("MRxSmbTestDevIoctl %s, obl = %08lx\n",InputString, OutputBufferLength));
    RxContext->InformationToReturn = (InputBufferLength-1)*(InputBufferLength-1);

    try {
        if (InputString != NULL && OutputString != NULL) {
            ProbeForRead(InputString,InputBufferLength,1);
            ProbeForWrite(OutputString,OutputBufferLength,1);

            for (i=0;i<InputBufferLength;i++) {
                UCHAR c = InputString[i];
                if (c==0) { break; }
                OutputString[i] = c;
                if ((i&3)==2) {
                    OutputString[i] = '@';
                }
            }
            if (OutputBufferLength > 0)
                OutputString[i] = 0;
        } else {
            Status = STATUS_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status=STATUS_INVALID_PARAMETER;
    }

    return(Status);
}
#endif //if DBG

#define SMBMRX_CONFIG_CONTROL \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"

#define SMBMRX_CONFIG_REMOTEBOOTROOT \
    L"RemoteBootRoot"

#define SMBMRX_CONFIG_REMOTEBOOTMACHINEDIRECTORY \
    L"RemoteBootMachineDirectory"

PWCHAR
SafeWcschr(
    PWCHAR String,
    WCHAR Char,
    PWCHAR End
    )
{
    while ( (String < End) && (*String != Char) && (*String != 0) ) {
        String++;
    }
    if ( (String < End) && (*String == Char) ) {
        return String;
    }
    return NULL;
}

NTSTATUS
MRxSmbInitializeRemoteBootParameters(
    PRX_CONTEXT RxContext
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE hRegistryKey;
    ULONG bytesRead;
    KEY_VALUE_PARTIAL_INFORMATION initialPartialInformationValue;
    ULONG allocationLength;
    PWCHAR pServer;
    PWCHAR pServerEnd;
    PWCHAR pPath;
    PWCHAR pPathEnd;
    PWCHAR pSetup;
    PWCHAR pSetupEnd;
    PWCHAR pEnd;
    RI_SECRET Secret;
    UCHAR Domain[RI_SECRET_DOMAIN_SIZE + 1];
    UCHAR User[RI_SECRET_USER_SIZE + 1];
    UCHAR LmOwfPassword1[LM_OWF_PASSWORD_SIZE];
    UCHAR NtOwfPassword1[NT_OWF_PASSWORD_SIZE];
#if defined(REMOTE_BOOT)
    UCHAR LmOwfPassword2[LM_OWF_PASSWORD_SIZE];
    UCHAR NtOwfPassword2[NT_OWF_PASSWORD_SIZE];
#endif // defined(REMOTE_BOOT)
    STRING DomainString, UserString, PasswordString;

    //
    // Read the RemoteBootRoot parameter from the registry. This tells us
    // the path to the boot server.
    //

    RtlInitUnicodeString( &unicodeString, SMBMRX_CONFIG_CONTROL );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,             // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL);                      // security descriptor

    status = ZwOpenKey( &hRegistryKey, KEY_READ, &objectAttributes );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    RtlInitUnicodeString( &unicodeString, SMBMRX_CONFIG_REMOTEBOOTROOT );
    status = ZwQueryValueKey(
                hRegistryKey,
                &unicodeString,
                KeyValuePartialInformation,
                &initialPartialInformationValue,
                sizeof(initialPartialInformationValue),
                &bytesRead);
    if (status != STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS(status)) {
            status = STATUS_INVALID_PARAMETER;
        }
        ZwClose( hRegistryKey );
        return status;
    }

    allocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                        initialPartialInformationValue.DataLength;

    MRxSmbRemoteBootRootValue = RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    allocationLength,
                                    MRXSMB_MISC_POOLTAG);
    if ( MRxSmbRemoteBootRootValue == NULL ) {
        ZwClose( hRegistryKey );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryValueKey(
                hRegistryKey,
                &unicodeString,
                KeyValuePartialInformation,
                MRxSmbRemoteBootRootValue,
                allocationLength,
                &bytesRead);

    if ( !NT_SUCCESS(status) ) {
        RxFreePool( MRxSmbRemoteBootRootValue );
        MRxSmbRemoteBootRootValue = NULL;
        ZwClose( hRegistryKey );
        return status;
    }
    if ( (MRxSmbRemoteBootRootValue->DataLength == 0) ||
         (MRxSmbRemoteBootRootValue->Type != REG_SZ)) {
        RxFreePool( MRxSmbRemoteBootRootValue );
        MRxSmbRemoteBootRootValue = NULL;
        ZwClose( hRegistryKey );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Read the RemoteBootMachineDirectory parameter from the registry. If
    // this value exists, then we are in textmode setup, and RemoteBootRoot
    // point to the setup source, while RemoteBootMachineDirectory points
    // to the client's machine directory. If RemoteBootMachineDirectory
    // doesn't exist, then RemoteBootRoot points to the machine directory.
    //

    RtlInitUnicodeString( &unicodeString, SMBMRX_CONFIG_REMOTEBOOTMACHINEDIRECTORY );
    status = ZwQueryValueKey(
                hRegistryKey,
                &unicodeString,
                KeyValuePartialInformation,
                &initialPartialInformationValue,
                sizeof(initialPartialInformationValue),
                &bytesRead);
    if (status == STATUS_BUFFER_OVERFLOW) {

        allocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                            initialPartialInformationValue.DataLength;

        MRxSmbRemoteBootMachineDirectoryValue = RxAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    allocationLength,
                                                    MRXSMB_MISC_POOLTAG);
        if ( MRxSmbRemoteBootMachineDirectoryValue == NULL ) {
            RxFreePool( MRxSmbRemoteBootRootValue );
            MRxSmbRemoteBootRootValue = NULL;
            ZwClose( hRegistryKey );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwQueryValueKey(
                    hRegistryKey,
                    &unicodeString,
                    KeyValuePartialInformation,
                    MRxSmbRemoteBootMachineDirectoryValue,
                    allocationLength,
                    &bytesRead);

        if ( !NT_SUCCESS(status) ) {
            RxFreePool( MRxSmbRemoteBootMachineDirectoryValue );
            MRxSmbRemoteBootMachineDirectoryValue = NULL;
            RxFreePool( MRxSmbRemoteBootRootValue );
            MRxSmbRemoteBootRootValue = NULL;
            ZwClose( hRegistryKey );
            return status;
        }
        if ( (MRxSmbRemoteBootMachineDirectoryValue->DataLength == 0) ||
             (MRxSmbRemoteBootMachineDirectoryValue->Type != REG_SZ)) {
            RxFreePool( MRxSmbRemoteBootMachineDirectoryValue );
            MRxSmbRemoteBootMachineDirectoryValue = NULL;
            RxFreePool( MRxSmbRemoteBootRootValue );
            MRxSmbRemoteBootRootValue = NULL;
            ZwClose( hRegistryKey );
            return STATUS_INVALID_PARAMETER;
        }
    }

    ZwClose( hRegistryKey );

    if ( MRxSmbRemoteBootMachineDirectoryValue != NULL) {

        //
        // Textmode setup. MachineDirectory gives the machine directory and
        // Root gives the setup source.
        //
        // The setup source path in the registry is of the form:
        //  \Device\LanmanRedirector\server\IMirror\Setup\English\MirroredOSes\build\i386
        //
        // We need to extract the \Setup\... part.
        //

        pSetup = (PWCHAR)MRxSmbRemoteBootRootValue->Data;
        pEnd = (PWCHAR)((PUCHAR)pSetup + MRxSmbRemoteBootRootValue->DataLength);

        pSetup = SafeWcschr( pSetup + 1, L'\\', pEnd );             // find \ before LanmanRedirector
        if ( pSetup != NULL ) {
            pSetup = SafeWcschr( pSetup + 1, L'\\', pEnd );         // find \ before server
            if ( pSetup != NULL ) {
                pSetup = SafeWcschr( pSetup + 1, L'\\', pEnd );     // find \ before IMirror
                if ( pSetup != NULL ) {
                    pSetup = SafeWcschr( pSetup + 1, L'\\', pEnd ); // find \ before Setup
                }
            }
        }

        if ( *(pEnd-1) == 0 ) {
            pEnd--;
        }
        if ( *(pEnd-1) == '\\' ) {
            pEnd--;
        }

        pSetupEnd = pEnd;

        //
        // The machine directory path in the registry is of the form:
        //  \Device\LanmanRedirector\server\IMirror\Clients\machine
        //

        pServer = (PWCHAR)MRxSmbRemoteBootMachineDirectoryValue->Data;
        pEnd = (PWCHAR)((PUCHAR)pServer + MRxSmbRemoteBootMachineDirectoryValue->DataLength);

    } else {

        //
        // Not textmode setup. Root gives the machine directory.
        //
        // The path in the registry is of the form:
        //  \Device\LanmanRedirector\server\IMirror\Clients\machine
        //

        pSetup = NULL;

        pServer = (PWCHAR)MRxSmbRemoteBootRootValue->Data;
        pEnd = (PWCHAR)((PUCHAR)pServer + MRxSmbRemoteBootRootValue->DataLength);
    }

    //
    // We need to extract the \server\Imirror part and the \Clients\machine part.
    //

    pServer = SafeWcschr( pServer + 1, L'\\', pEnd );                 // skip leading \, find next
    if ( pServer != NULL) {
        pServer = SafeWcschr( pServer + 1, L'\\', pEnd );             // find \ before server name
        if ( pServer != NULL ) {
            pPath = SafeWcschr( pServer + 1, L'\\', pEnd );           // find \ before IMirror
            if ( pPath != NULL ) {
                pPath = SafeWcschr( pPath + 1, L'\\', pEnd );         // find \ before Clients
            }
        }
    }

    if ( (pServer == NULL) || (pPath == NULL) ||
         ((MRxSmbRemoteBootMachineDirectoryValue != NULL) && (pSetup == NULL)) ) {
        if ( MRxSmbRemoteBootMachineDirectoryValue != NULL ) {
            RxFreePool( MRxSmbRemoteBootMachineDirectoryValue );
            MRxSmbRemoteBootMachineDirectoryValue = NULL;
        }
        RxFreePool( MRxSmbRemoteBootRootValue );
        MRxSmbRemoteBootRootValue = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    if ( *(pEnd-1) == 0 ) {
        pEnd--;
    }

    pServerEnd = pPath;
    pPathEnd = pEnd;

    //
    // Make strings for the various parts that we need to remember.
    //

    MRxSmbRemoteBootShare.Buffer = pServer;
    MRxSmbRemoteBootShare.Length = (USHORT)(pServerEnd - pServer) * sizeof(WCHAR);
    MRxSmbRemoteBootShare.MaximumLength = MRxSmbRemoteBootShare.Length;

    MRxSmbRemoteBootPath.Buffer = pPath;
    MRxSmbRemoteBootPath.Length = (USHORT)(pPathEnd - pPath) * sizeof(WCHAR);
    MRxSmbRemoteBootPath.MaximumLength = MRxSmbRemoteBootPath.Length;

    //
    // Use the secret that IO init passed in with the LMMR_RI_INITIALIZE_SECRET
    // FSCTL to set the user, domain, and password. If successful, we set
    // MRxSmbRemoteBootDoMachineLogon to TRUE.
    //

    RtlFreeUnicodeString(&MRxSmbRemoteBootMachineName);
    RtlFreeUnicodeString(&MRxSmbRemoteBootMachineDomain);
    RtlFreeUnicodeString(&MRxSmbRemoteBootMachinePassword);
    
#if defined(REMOTE_BOOT)
    MRxSmbRemoteBootDoMachineLogon = FALSE;

    if (MRxSmbRemoteBootSecretValid) {
#endif // defined(REMOTE_BOOT)

        RdrParseSecret(
            Domain,
            User,
            LmOwfPassword1,
            NtOwfPassword1,
#if defined(REMOTE_BOOT)
            LmOwfPassword2,
            NtOwfPassword2,
#endif // defined(REMOTE_BOOT)
            MRxSmbRemoteBootMachineSid,
            &MRxSmbRemoteBootSecret);

        //
        // Convert the ANSI user and domain name
        // to Unicode strings.
        //

        RtlInitAnsiString(&UserString, User);
        status = RtlAnsiStringToUnicodeString(&MRxSmbRemoteBootMachineName, &UserString, TRUE);
        if ( !NT_SUCCESS(status) ) {
            return status;
        }

        RtlInitAnsiString(&DomainString, Domain);
        status = RtlAnsiStringToUnicodeString(&MRxSmbRemoteBootMachineDomain, &DomainString, TRUE);
        if ( !NT_SUCCESS(status) ) {
            RtlFreeUnicodeString(&MRxSmbRemoteBootMachineName);
            return status;
        }

        //
        // Use the correct password based on the hint we were given.
        //
        // The "Unicode string" for the password is actually the
        // LM and NT OWF passwords concatenated together.
        //

        PasswordString.Buffer = ExAllocatePool(NonPagedPool, LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE);
        if (PasswordString.Buffer == NULL) {
            RtlFreeUnicodeString(&MRxSmbRemoteBootMachineDomain);
            RtlFreeUnicodeString(&MRxSmbRemoteBootMachineName);
            return STATUS_INSUFFICIENT_RESOURCES;
        } else {
#if defined(REMOTE_BOOT)
            if (MRxSmbRemoteBootUsePassword2) {
                RtlCopyMemory(PasswordString.Buffer, LmOwfPassword2, LM_OWF_PASSWORD_SIZE);
                RtlCopyMemory(PasswordString.Buffer + LM_OWF_PASSWORD_SIZE, NtOwfPassword2, NT_OWF_PASSWORD_SIZE);
            } else
#endif // defined(REMOTE_BOOT)
            {
                RtlCopyMemory(PasswordString.Buffer, LmOwfPassword1, LM_OWF_PASSWORD_SIZE);
                RtlCopyMemory(PasswordString.Buffer + LM_OWF_PASSWORD_SIZE, NtOwfPassword1, NT_OWF_PASSWORD_SIZE);
            }
            PasswordString.Length = LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE;
            PasswordString.MaximumLength = LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE;

            //
            // Copy the string as-is, it's really just
            // a buffer, not an ANSI string.
            //

            MRxSmbRemoteBootMachinePassword = *((PUNICODE_STRING)&PasswordString);
#if defined(REMOTE_BOOT)
            MRxSmbRemoteBootDoMachineLogon = TRUE;
#endif // defined(REMOTE_BOOT)
            KdPrint(("Redirector will log on to <%s><%s>\n", Domain, User));

        }

#if defined(REMOTE_BOOT)
    } else {

        KdPrint(("MRxSmbRemoteBootSecretValid is FALSE, will use NULL session\n", status));
    }
#endif // defined(REMOTE_BOOT)

    if ( pSetup != NULL) {
        MRxSmbRemoteSetupPath.Buffer = pSetup;
        MRxSmbRemoteSetupPath.Length = (USHORT)(pSetupEnd - pSetup) * sizeof(WCHAR);
        MRxSmbRemoteSetupPath.MaximumLength = MRxSmbRemoteSetupPath.Length;
    } else {
        RtlInitUnicodeString( &MRxSmbRemoteSetupPath, L"unused" );
    }

#if defined(REMOTE_BOOT)
    //
    // This calls prepares us for modifying ACLs on server files.
    //

    MRxSmbInitializeExtraAceArray();
#endif // defined(REMOTE_BOOT)

    return STATUS_SUCCESS;
}

#if defined(REMOTE_BOOT)
NTSTATUS
MRxSmbStartRbr(
    PRX_CONTEXT RxContext
    )
{
    NTSTATUS status;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG localBufferLength;
    PWCH localBuffer;

    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PSZ InputString = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    //
    // Set up for remote boot redirection (to the local disk).
    //
    // The NT name of the local disk partition is passed in to the FSCTL.
    // Allocate a buffer to allow us to append "\IntelliMirror Cache\RBR"
    // to that string.
    //

    localBufferLength = InputBufferLength +
                        (wcslen(REMOTE_BOOT_IMIRROR_PATH_W REMOTE_BOOT_RBR_SUBDIR_W) * sizeof(WCHAR));

    localBuffer = RxAllocatePoolWithTag(
                    NonPagedPool,
                    localBufferLength,
                    MRXSMB_MISC_POOLTAG);
    if ( localBuffer == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create a string descriptor for the NT partition name.
    //

    RtlCopyMemory( localBuffer, InputString, InputBufferLength );
    MRxSmbRemoteBootRedirectionPrefix.Buffer = localBuffer;
    MRxSmbRemoteBootRedirectionPrefix.Length = (USHORT)InputBufferLength;
    MRxSmbRemoteBootRedirectionPrefix.MaximumLength = (USHORT)localBufferLength;

    InitializeObjectAttributes(
        &objectAttributes,
        &MRxSmbRemoteBootRedirectionPrefix,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Append "\Intellimirror Cache" and create/open that directory.
    //

    RtlAppendUnicodeToString( &MRxSmbRemoteBootRedirectionPrefix, REMOTE_BOOT_IMIRROR_PATH_W );

    status = ZwCreateFile(
                &handle,
                FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE,
                NULL,
                0
                );
    if (!NT_SUCCESS(status)) {
        RxFreePool( localBuffer );
        MRxSmbRemoteBootRedirectionPrefix.Buffer = NULL;
        MRxSmbRemoteBootRedirectionPrefix.Length =  0;
        return status;
    }

    ZwClose(handle);

    //
    // Append \RBR and create/open that directory.
    //

    RtlAppendUnicodeToString( &MRxSmbRemoteBootRedirectionPrefix, REMOTE_BOOT_RBR_SUBDIR_W );

    status = ZwCreateFile(
                &handle,
                FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE,
                NULL,
                0
                );
    if (!NT_SUCCESS(status)) {
        RxFreePool( localBuffer );
        MRxSmbRemoteBootRedirectionPrefix.Buffer = NULL;
        MRxSmbRemoteBootRedirectionPrefix.Length =  0;
        return status;
    }

    ZwClose(handle);

    return STATUS_SUCCESS;
}
#endif // defined(REMOTE_BOOT)

NTSTATUS
MRxSmbRemoteBootInitializeSecret(
    PRX_CONTEXT RxContext
    )
{
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PLMMR_RI_INITIALIZE_SECRET InputBuffer = (PLMMR_RI_INITIALIZE_SECRET)(LowIoContext->ParamsFor.FsCtl.pInputBuffer);
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    //
    // Store the secret passed in from above.
    //

    if (InputBufferLength != sizeof(LMMR_RI_INITIALIZE_SECRET)) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&MRxSmbRemoteBootSecret, &(InputBuffer->Secret), sizeof(RI_SECRET));
#if defined(REMOTE_BOOT)
    MRxSmbRemoteBootSecretValid = TRUE;
    MRxSmbRemoteBootUsePassword2 = InputBuffer->UsePassword2;
#endif // defined(REMOTE_BOOT)

    return STATUS_SUCCESS;
}

#if defined(REMOTE_BOOT)
NTSTATUS
MRxSmbRemoteBootCheckForNewPassword(
    PRX_CONTEXT RxContext
    )
{
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PLMMR_RI_CHECK_FOR_NEW_PASSWORD OutputBuffer = (PLMMR_RI_CHECK_FOR_NEW_PASSWORD)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG SecretPasswordLength;

    //
    // If we are not a remote boot machine or were not given a secret
    // (which implies we are diskless), then we don't support this.
    //

    if (!MRxSmbBootedRemotely ||
        !MRxSmbRemoteBootSecretValid) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // See if we have a cleartext password in the secret.
    //

    SecretPasswordLength = *(UNALIGNED ULONG *)(MRxSmbRemoteBootSecret.Reserved);
    if (SecretPasswordLength == 0) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Make sure the output buffer is big enough.
    //

    if (OutputBufferLength < (sizeof(ULONG) + SecretPasswordLength)) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Copy the cleartext password.
    //

    OutputBuffer->Length = SecretPasswordLength;
    RtlCopyMemory(OutputBuffer->Data, MRxSmbRemoteBootSecret.Reserved + sizeof(ULONG), SecretPasswordLength);

    RxContext->InformationToReturn =
        SecretPasswordLength + FIELD_OFFSET(LMMR_RI_CHECK_FOR_NEW_PASSWORD, Data[0]);

#if DBG
    {
        ULONG i;
        KdPrint(("MRxSmbRemoteBootCheckForNewPassword: found one, length %d\n", SecretPasswordLength));
        for (i = 0; i < SecretPasswordLength; i++) {
            KdPrint(("%2.2x ", OutputBuffer->Data[i]));
        }
        KdPrint(("\n"));
    }
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbRemoteBootIsPasswordSettable(
    PRX_CONTEXT RxContext
    )
{
    NTSTATUS status;
    HANDLE RawDiskHandle;

    //
    // If we are not a remote boot machine, then we don't support this.
    //

    if (!MRxSmbBootedRemotely) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If we were not given a secret, then we are diskless, and we
    // can't write this either.
    //

    if (!MRxSmbRemoteBootSecretValid) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If we are not diskless, make sure that the redir can open
    // the raw disk -- it may be that the loader can but
    // we can't. In this case we need to fail with a different
    // error, since this is the case the caller probably cares
    // about most.
    //

    status = RdrOpenRawDisk(&RawDiskHandle);

    if (!NT_SUCCESS(status)) {
        KdPrint(("MRxSmbRemoteBootIsPasswordSettable: can't open disk, returning STATUS_UNSUCCESSFUL\n"));
        return STATUS_UNSUCCESSFUL;  // we can't support password set on this boot
    }

    RdrCloseRawDisk(RawDiskHandle);

    return STATUS_SUCCESS;

}

NTSTATUS
MRxSmbRemoteBootSetNewPassword(
    PRX_CONTEXT RxContext
    )
{
    NTSTATUS status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PLMMR_RI_SET_NEW_PASSWORD InputBuffer = (PLMMR_RI_SET_NEW_PASSWORD)(LowIoContext->ParamsFor.FsCtl.pInputBuffer);
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;
    RI_SECRET Secret;
    HANDLE RawDiskHandle;
    UCHAR LmOwf1[LM_OWF_PASSWORD_SIZE];
    UCHAR LmOwf2[LM_OWF_PASSWORD_SIZE];
    UCHAR NtOwf1[NT_OWF_PASSWORD_SIZE];
    UCHAR NtOwf2[NT_OWF_PASSWORD_SIZE];
    UNICODE_STRING PasswordString;

    //
    // If we are not a remote boot machine, then we don't support this.
    //

    if (!MRxSmbBootedRemotely) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If we were not given a secret, then we are diskless, and we
    // can't write this either.
    //

    if (!MRxSmbRemoteBootSecretValid) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Open the raw disk.
    //

    status = RdrOpenRawDisk(&RawDiskHandle);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // OWF the passwords.
    //

#if 0
    {
        ULONG i;
        KdPrint(("MRxSmbRemoteBootSetNewPassword: password 1 is length %d\n", InputBuffer->Length1));
        for (i = 0; i < InputBuffer->Length1; i++) {
            KdPrint(("%2.2x ", InputBuffer->Data[i]));
        }
        KdPrint(("\n"));
    }
#endif

    PasswordString.Buffer = (PWCHAR)InputBuffer->Data;
    PasswordString.Length = (USHORT)(InputBuffer->Length1);
    PasswordString.MaximumLength = (USHORT)(InputBuffer->Length1);

    RdrOwfPassword(
        &PasswordString,
        LmOwf1,
        NtOwf1);

    if (InputBuffer->Length2 != 0) {

#if 0
        {
            ULONG i;
            KdPrint(("MRxSmbRemoteBootSetNewPassword: password 2 is length %d\n", InputBuffer->Length2));
            for (i = 0; i < InputBuffer->Length2; i++) {
                KdPrint(("%2.2x ", InputBuffer->Data[i + InputBuffer->Length1]));
            }
            KdPrint(("\n"));
        }
#endif

        //
        // If password 2 is the same as password 1, then grab the
        // current password to store in password 2 (the current password
        // is the one we used to log on for this boot -- generally this
        // will be password 1 unless UsePassword2 is TRUE). This is
        // what happens during GUI-mode setup.
        //

        if ((InputBuffer->Length1 == InputBuffer->Length2) &&
            RtlEqualMemory(
               InputBuffer->Data,
               InputBuffer->Data + InputBuffer->Length1,
               InputBuffer->Length1)) {

            RtlCopyMemory(LmOwf2, MRxSmbRemoteBootMachinePassword.Buffer, LM_OWF_PASSWORD_SIZE);
            RtlCopyMemory(NtOwf2, MRxSmbRemoteBootMachinePassword.Buffer + LM_OWF_PASSWORD_SIZE, NT_OWF_PASSWORD_SIZE);

        } else {

            PasswordString.Buffer = (PWCHAR)(InputBuffer->Data + InputBuffer->Length1);
            PasswordString.Length = (USHORT)(InputBuffer->Length2);
            PasswordString.MaximumLength = (USHORT)(InputBuffer->Length2);

            RdrOwfPassword(
                &PasswordString,
                LmOwf2,
                NtOwf2);

        }

    } else {

        RtlZeroMemory(LmOwf2, LM_OWF_PASSWORD_SIZE);
        RtlZeroMemory(NtOwf2, NT_OWF_PASSWORD_SIZE);
    }

    //
    // Initialize the secret. The data except for the new passwords
    // comes from the current secret.
    //

    RdrInitializeSecret(
        MRxSmbRemoteBootSecret.Domain,
        MRxSmbRemoteBootSecret.User,
        LmOwf1,
        NtOwf1,
        LmOwf2,
        NtOwf2,
        MRxSmbRemoteBootSecret.Sid,
        &Secret);

    //
    // Write the secret.
    //

    status = RdrWriteSecret(RawDiskHandle, &Secret);
    if (!NT_SUCCESS(status)) {
        KdPrint(("MRxSmbRemoteBootSetNewPassword: RdrWriteSecret failed %lx\n", status));
        (PVOID)RdrCloseRawDisk(RawDiskHandle);
        return status;
    }

    //
    // Since we wrote it successfully, it is now the current one. Note
    // that this means any new cleartext password in the current secret
    // will be erased.
    //

    RtlCopyMemory(&MRxSmbRemoteBootSecret, &Secret, sizeof(RI_SECRET));

    //
    // Any future connections we do need to use the new password.
    //

    RtlCopyMemory(MRxSmbRemoteBootMachinePassword.Buffer, LmOwf1, LM_OWF_PASSWORD_SIZE);
    RtlCopyMemory(MRxSmbRemoteBootMachinePassword.Buffer + LM_OWF_PASSWORD_SIZE, NtOwf1, NT_OWF_PASSWORD_SIZE);
    MRxSmbRemoteBootUsePassword2 = FALSE;

    (PVOID)RdrCloseRawDisk(RawDiskHandle);
    return STATUS_SUCCESS;

}
#endif // defined(REMOTE_BOOT)

NTSTATUS
MRxSmbSetDomainName(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine sets the configuration information associated with the
    redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;

    try {
        if (pLmrRequestBuffer == NULL ||
            (USHORT)pLmrRequestBuffer->Parameters.Start.DomainNameLength > DNS_MAX_NAME_LENGTH) {
            return STATUS_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER ) {
          Status = STATUS_INVALID_PARAMETER;
    }
    
    SmbCeContext.DomainName.Length = (USHORT)pLmrRequestBuffer->Parameters.Start.DomainNameLength;
    SmbCeContext.DomainName.MaximumLength = SmbCeContext.DomainName.Length;

    if (SmbCeContext.DomainName.Buffer != NULL) {
        RxFreePool(SmbCeContext.DomainName.Buffer);
        SmbCeContext.DomainName.Buffer = NULL;
    }

    if (SmbCeContext.DomainName.Length > 0) {
        SmbCeContext.DomainName.Buffer = RxAllocatePoolWithTag(
                                             PagedPool,
                                             SmbCeContext.DomainName.Length,
                                             MRXSMB_MISC_POOLTAG);

        if (SmbCeContext.DomainName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            try {
                // The request packet only contains the domain name on this FSCTL call.
                RtlCopyMemory(
                    SmbCeContext.DomainName.Buffer,
                    &(pLmrRequestBuffer->Parameters.Start.RedirectorName[0]),
                    SmbCeContext.DomainName.Length);
            } except(EXCEPTION_EXECUTE_HANDLER ) {
                  Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = RxSetDomainForMailslotBroadcast(&SmbCeContext.DomainName);
    }

    return Status;
}

extern GUID CachedServerGuid;

NTSTATUS
MRxSmbSetServerGuid(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine sets the server GUID used in loopback detection

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the GUID was set correctly
    STATUS_INVALID_PARAMETER -- the GUID was not passed correctly 

--*/
{
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PVOID pInputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    if(InputBufferLength != sizeof(GUID)) {
    return STATUS_INVALID_PARAMETER;
    }

    try {
    RtlCopyMemory(&CachedServerGuid,pInputBuffer,sizeof(GUID));
    } except(EXCEPTION_EXECUTE_HANDLER ) {
      return STATUS_INVALID_PARAMETER;
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\downlvli.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

Author:

    JoeLinn      [JoeLi]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFabricateAttributesOnNetRoot)
#pragma alloc_text(PAGE, MRxSmbCoreInformation)
#pragma alloc_text(PAGE, MRxSmbLoadCoreFileSearchBuffer)
#pragma alloc_text(PAGE, MRxSmbCoreFileSearch)
#pragma alloc_text(PAGE, MrxSmbOemVolumeInfoToUnicode)
#pragma alloc_text(PAGE, MrxSmbCoreQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, SmbPseExchangeStart_CoreInfo)
#pragma alloc_text(PAGE, MRxSmbFinishSearch)
#pragma alloc_text(PAGE, MRxSmbFinishQueryDiskInfo)
#pragma alloc_text(PAGE, MRxSmbExtendForCache)
#pragma alloc_text(PAGE, MRxSmbExtendForNonCache)
#pragma alloc_text(PAGE, MRxSmbGetNtAllocationInfo)
#pragma alloc_text(PAGE, __MRxSmbSimpleSyncTransact2)
#pragma alloc_text(PAGE, MRxSmbFinishTransaction2)
#endif

#define Dbg        (DEBUG_TRACE_VOLINFO)

//#define FORCE_CORE_GETATTRIBUTES
#ifndef FORCE_CORE_GETATTRIBUTES
#define MRxSmbForceCoreGetAttributes FALSE
#else
BOOLEAN MRxSmbForceCoreGetAttributes = TRUE;
#endif

NTSTATUS
SmbPseExchangeStart_CoreInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

//these structures are used for t2_query_fs_info
typedef
struct _QFS_INFO {
    ULONG ulVSN;
    UCHAR cch;
    CHAR szVolLabel[12];   //not unicode
} QFS_INFO, *PQFS_INFO;
#define ACTUAL_QFS_INFO_LENGTH (FIELD_OFFSET(QFS_INFO,szVolLabel[12]))

typedef
struct _QFS_ALLOCATE {
    ULONG ulReserved;
    ULONG cSectorUnit;
    ULONG cUnit;
    ULONG cUnitAvail;
    USHORT cbSector;
} QFS_ALLOCATE, *PQFS_ALLOCATE;
#define ACTUAL_QFS_ALLOCATE_LENGTH (FIELD_OFFSET(QFS_ALLOCATE,cbSector)+sizeof(((PQFS_ALLOCATE)0)->cbSector))

//++
//
// VOID
// NAME_LENGTH(
//     OUT ULONG Length,
//     IN PUCHAR Ptr
//     )
//
// Routine Description:
//
//  Determines the length of a Core filename returned by search. This
//  is normally a NULL terminated string less than MAXIMUM_COMPONENT_CORE.
//  In some cases this is Non-null teminated and space filled.
//
// Arguments:
//
//     Length   -   Returns the string length
//     Ptr      -   The filename to be measured
//
// Return Value:
//
//     None.
//
//--
#define NAME_LENGTH( Length, Ptr, Max ) {                         \
    Length = 0;                                                   \
    while( ((PCHAR)Ptr)[Length] != '\0' ) {                       \
         Length++;                                                \
         if ( Length == Max ) {                                   \
             break;                                               \
         }                                                        \
    }                                                             \
    while( ((PCHAR)Ptr)[Length-1] == ' ' && Length ) {            \
        Length--;                                                 \
    }                                                             \
}
MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

typedef struct __NativeFs_Name_Entry {
    UCHAR Last;
    UCHAR MaximumComponentNameLength;
    UCHAR FileSystemAttributes;   //this may overflow someday.....
    UCHAR NameLength;
    PWCHAR  Name;
};
struct __NativeFs_Name_Entry NativeFsNameTable[] = {
    {0,12,0,sizeof(L"FAT")-sizeof(WCHAR),L"FAT"},
#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    {0,255,
       FILE_CASE_SENSITIVE_SEARCH |
                                   FILE_CASE_PRESERVED_NAMES |
                                   FILE_UNICODE_ON_DISK |
                                   // FILE_FILE_COMPRESSION |
                                   // FILE_SUPPORTS_REPARSE_POINTS |
                                   // FILE_SUPPORTS_SPARSE_FILES |
                                   FILE_PERSISTENT_ACLS,
       sizeof(L"*NT5CSC")-sizeof(WCHAR),L"*NT5CSC"},
#endif //#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    {0,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS")-sizeof(WCHAR),L"HPFS"},
    {1,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS386")-sizeof(WCHAR),L"HPFS386"}
    };

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT  PSMBCE_NET_ROOT psmbNetRoot,
    IN      PSMBCE_SERVER   pServer
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to hallucinate the attributes
   of the netroot. it may be that the ascii representation of the filesystem name has already been
   stored in the netroot. If so, expeand it out.....otherwise, it must be FAT.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS StringStatus;
    WCHAR FileSystemNameBuffer[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL+1]; //must leave room for the null
    UNICODE_STRING FileSystemNameU;
    OEM_STRING FileSystemNameA;
    UCHAR FileSystemNameALength;

    PAGED_CODE();

    // ASSERT (psmbNetRoot->MaximumComponentNameLength==0);

    FileSystemNameALength = psmbNetRoot->FileSystemNameALength;

    if (FileSystemNameALength == 0) {
        if (pServer->Dialect <= WFW10_DIALECT)
        {
            //must be Fat!
            FileSystemNameALength = 3;
            psmbNetRoot->FileSystemNameA[0] = 'F';
            psmbNetRoot->FileSystemNameA[1] = 'A';
            psmbNetRoot->FileSystemNameA[2] = 'T';
        }
        else
        {
            FileSystemNameALength = 7;
            psmbNetRoot->FileSystemNameA[0] = 'U';
            psmbNetRoot->FileSystemNameA[1] = 'N';
            psmbNetRoot->FileSystemNameA[2] = 'K';
            psmbNetRoot->FileSystemNameA[3] = 'N';
            psmbNetRoot->FileSystemNameA[4] = 'O';
            psmbNetRoot->FileSystemNameA[5] = 'W';
            psmbNetRoot->FileSystemNameA[6] = 'N';
        }
    }

    //now, translate the name to Unicode.......

    FileSystemNameA.Length = FileSystemNameALength;
    FileSystemNameA.MaximumLength = FileSystemNameALength;
    FileSystemNameA.Buffer = &psmbNetRoot->FileSystemNameA[0];
    FileSystemNameU.Length = 0;
    FileSystemNameU.MaximumLength = (USHORT)sizeof(FileSystemNameBuffer);
    FileSystemNameU.Buffer = &FileSystemNameBuffer[0];
    StringStatus = RtlOemStringToUnicodeString(&FileSystemNameU, &FileSystemNameA, FALSE);
    ASSERT(StringStatus==STATUS_SUCCESS);

    //copy back the name

    RtlCopyMemory(&psmbNetRoot->FileSystemName[0],FileSystemNameU.Buffer,FileSystemNameU.Length);
    psmbNetRoot->FileSystemNameLength = FileSystemNameU.Length;
    if (FALSE) DbgPrint("NativeFs in unicode %wZ (%d/%d) on netroot %08lx\n",
               &FileSystemNameU,FileSystemNameU.Length,FileSystemNameU.MaximumLength,psmbNetRoot);
    {   struct __NativeFs_Name_Entry *i;
       for (i=NativeFsNameTable;;i++) {
           UCHAR NameLength = i->NameLength;
           if (RtlCompareMemory(&FileSystemNameBuffer[0],
                                i->Name,
                                NameLength) == NameLength) {
              psmbNetRoot->MaximumComponentNameLength = i->MaximumComponentNameLength;
              psmbNetRoot->FileSystemAttributes = i->FileSystemAttributes;
              if (FALSE) {
                  UNICODE_STRING u;
                  u.Buffer = i->Name;
                  u.Length = i->NameLength;
                  DbgPrint("FoundNativeFsStrng %wZ len %d for %d %d\n",&u,i->NameLength,
                                       i->MaximumComponentNameLength,i->FileSystemAttributes);
              }
              break;
           }
           if (i->Last) {
               //ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
               psmbNetRoot->MaximumComponentNameLength = 255;
               psmbNetRoot->FileSystemAttributes = 0;
               break;
           }
       }
    }

    return(STATUS_SUCCESS); //could be a VOID routine.....
}

NTSTATUS
MRxSmbGetFsAttributesFromNetRoot(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to fill in a FILE
   FileFsAttributeInformation structure.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    ULONG FileSystemNameLength,LengthNeeded;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCE_NET_ROOT psmbNetRoot;
    //FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pBufferLength;

    //DbgPrint("yeppp!!\n");
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    if (pNetRootEntry == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    ASSERT(RxContext->MajorFunction==IRP_MJ_QUERY_VOLUME_INFORMATION);
    //FileInformationClass = RxContext->Info.FileInformationClass;
    ASSERT(RxContext->Info.FileInformationClass==FileFsAttributeInformation);
    pBuffer = RxContext->Info.Buffer;
    pBufferLength = &RxContext->Info.LengthRemaining;

    psmbNetRoot = &pNetRootEntry->NetRoot;

    if (psmbNetRoot->MaximumComponentNameLength==0) {
        MRxSmbFabricateAttributesOnNetRoot(psmbNetRoot, &pNetRootEntry->pServerEntry->Server);
    }

    FileSystemNameLength = psmbNetRoot->FileSystemNameLength;
    LengthNeeded = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)+FileSystemNameLength;

    if (*pBufferLength < LengthNeeded) {
        return (STATUS_BUFFER_OVERFLOW);
    }

    {
        PFILE_FS_ATTRIBUTE_INFORMATION pTypedBuffer = (PFILE_FS_ATTRIBUTE_INFORMATION)pBuffer;

        pTypedBuffer->MaximumComponentNameLength = psmbNetRoot->MaximumComponentNameLength;
        pTypedBuffer->FileSystemAttributes = psmbNetRoot->FileSystemAttributes;
        pTypedBuffer->FileSystemNameLength = FileSystemNameLength;

        RtlCopyMemory(pTypedBuffer->FileSystemName, psmbNetRoot->FileSystemName, FileSystemNameLength);
        *pBufferLength -= LengthNeeded;
    }
    return(STATUS_SUCCESS);
}
//CODE.IMPROVEMENT 3 args should NOT be passed

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      )
/*++

Routine Description:

   This routine does a core level getinfo (vol or fileinfo) a file across the network

Arguments:

    RxContext - the RDBSS context
    InformationClass - a class variable that is specific to the call. sometimes it's a SMB class; sometimes
                       an NT class. CODE.IMPROVEMENT.ASHAMED we should always use the NT guy OR we should define
                       some other enumeration that we like better. consideration of the latter has kept me from
                       proceeding here..........
    pBuffer - pointer to the user's buffer
    pBufferLength - a pointer to a ulong containing the bufferlength that is updated as we go;
                    if it's a setinfo then we deref and place the actual bufferlength in the OE.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbDownLevelQueryInformation\n", 0 ));  //0 instead of +1.....the general entrypoint already inc'd

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    //some stuff is early out............catch them here even before we initialize the stufferstate
    //CODE.IMPROVEMENT we should potentially find a way to flatten these switches....both here and in volinfo_start
    switch (EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
        case FileFsSizeInformation:
            break; //these are actually implemented on the wire
        case FileFsAttributeInformation: {
            Status = MRxSmbGetFsAttributesFromNetRoot(RxContext);
            goto FINALLY;
            }
            //no break needed because of gotofinally

        case FileFsDeviceInformation:
            ASSERT(!"this should have been turned away");
            //no break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        //notice that the designators are smb_query_info types
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
        case SMB_QUERY_FILE_STANDARD_INFO:
            // go thru to the wire or get it from file information cache
            break;
        case SMB_QUERY_FILE_EA_INFO:
            //downlevel guys have no EAs....turn this backright here
            ((PFILE_EA_INFORMATION)pBuffer)->EaSize = 0;
            *pBufferLength -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        //case SMB_QUERY_FILE_ALLOCATION_INFO:
        //case SMB_QUERY_FILE_END_OF_FILEINFO:
        //case SMB_QUERY_FILE_ALT_NAME_INFO:
        //case SMB_QUERY_FILE_STREAM_INFO:
        //case SMB_QUERY_FILE_COMPRESSION_INFO:
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
        case FileEndOfFileInformation:
            //these go thru to the wire
            break;
        case FileDispositionInformation:
            /*
            
            Send this through to the wire.  We used to delay the delete until close time, but then if the caller does not have the
            rights to delete they will never get an error.  This can result in various error cases.  (Like in explorer, delete will
            remove it from the view, but than the file will come back on the next refresh)
            
            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED) ||
                !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                // if it is a pseudo open, we send the delete file request to get the result;
                // otherwise, we delay the delete until close.
                goto FINALLY;
            }
            */
            break;
        case FileRenameInformation:
            Status = MRxSmbRename(RxContext);
            goto FINALLY;
        case FileAllocationInformation:
            Status = STATUS_SUCCESS;
            goto FINALLY;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        break;
    }

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          EntryPoint,
                                          SmbPseExchangeStart_CoreInfo,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    //this is redundant since this info is already stored in the rxcontext! CODE.IMPROVEMENT
    OrdinaryExchange->Info.Buffer = pBuffer;
    OrdinaryExchange->Info.pBufferLength = pBufferLength;
    OrdinaryExchange->Info.InfoClass = InformationClass;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING)); //async was turned away at the top level
                                         //NTRAID-455630-2/2/2000 yunlin Possible reconnect point

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownLevelQueryInformation  exit with status=%08lx\n", Status ));
    return(Status);
}

UNICODE_STRING MRxSmbAll8dot3Files = {sizeof(L"????????.???")-sizeof(WCHAR),sizeof(L"????????.???"),L"????????.???"};

#if DBG
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
VOID
MRxSmbDumpResumeKey(
    PSZ             text,
    PSMB_RESUME_KEY ResumeKey
    )
{
    PBYTE rk = (PBYTE)ResumeKey;
    CHAR Buffer[80];
    PCHAR b;
    ULONG i;

    PAGED_CODE();

    for (i=0,b=Buffer;i<sizeof(SMB_RESUME_KEY);i++,b+=2) {
        RxSprintf(b,"%02lx  ",rk[i]);
        if (i==0) b+=2;
        if (i==11) b+=2;
        if (i==16) b+=2;
    }

    RxDbgTrace(0, Dbg, ("%s  rk(%08lx)=%s\n", text, ResumeKey, Buffer));
}
#else
#define MRxSmbDumpResumeKey(x,y)
#endif


NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a CORE_SMB_SEARCH and leaves the result in the SMBbuf.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
#ifndef WIN9X
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_HEADER SmbHeader;

    //PUNICODE_STRING DirectoryName;
    //PUNICODE_STRING Template;
    BOOLEAN FindFirst;
    UNICODE_STRING FindFirstPattern;
    USHORT ResumeKeyLength;
    ULONG ReturnCount;
    BOOLEAN EndOfSearchReached;
    // SearchAttributes is hardcoded to the magic number 0x16     CODE.IMPROVEMENT.ASHAMED use a macro....
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);
    PULONG pCountRemainingInSmbbuf = &OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME(capFobx->pSrvOpen,capFcb);
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //this is the first time thru....the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            // we will need to have an upcased template for compares; we do this in place
            RtlUpcaseUnicodeString( Template, Template, FALSE );

            //CODE.IMPROVEMENT.ASHAMED we should see if we can translate the template; otherwise,
            //                         we beat the heck out of downlevel servers on an exe lookup
            //                         if we do that we should revisit the decision to get 10 entries
            //                         as an alternative....in addition, we could keep a sidebuffer the way
            //                         that we do for uplevel. don't know if this is worthwhile

            //CODE.IMPROVEMENT but we should specialcase *.* (altho the fsrtl routine also does it)
            Template = &MRxSmbAll8dot3Files; //we will have to filter on this side
        }
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            ASSERT(FALSE); //this should never happen
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        //*((PWCHAR)SmbFileName) = 0; SmbFileName+= sizeof(WCHAR); //trailing NULL;
        //CODE.IMPROVEMENT we should potentially 8.3ize the string here
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
        FindFirst = TRUE;
        ResumeKeyLength = 0;

    } else {

        RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
        FindFirstPattern.Buffer = NULL;
        if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS)) {
            Status = smbFobx->Enumeration.ErrorStatus;
            RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
            goto FINALLY;
        }
        FindFirst = FALSE;
        FindFirstPattern.Length = 0;
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        MRxSmbDumpResumeKey("FindNext:",smbFobx->Enumeration.CoreResumeKey);

    }

    //get the correct return count. there are three factors: countremaining from the OE,
    //     how many could fit the the user's buffer, and how many could fit in a negotiated buffer.
    //     we pick the smallest of the three except that we never go for less than 10 unless 10 won't
    //     fit in the smbbuf.
    ReturnCount = OrdinaryExchange->Info.CoreSearch.CountRemaining;

    { ULONG t = (*OrdinaryExchange->Info.pBufferLength) / smbFobx->Enumeration.FileNameOffset;
        if (t<ReturnCount) { ReturnCount = t; }
    }

    if (ReturnCount<10) { ReturnCount = 10; }

    {
        PSMBCE_SERVER         pServer;
        ULONG                 AvailableBufferSize,t;

        pServer = SmbCeGetExchangeServer(OrdinaryExchange);
        AvailableBufferSize = pServer->MaximumBufferSize -
                                      (sizeof(SMB_HEADER) +
                                         FIELD_OFFSET(RESP_SEARCH,Buffer[0])
                                         +sizeof(UCHAR)+sizeof(USHORT)       //bufferformat,datalength fields
                                      );
        t = AvailableBufferSize / sizeof(SMB_DIRECTORY_INFORMATION);
        if (t<ReturnCount) { ReturnCount = t; }
    }
    RxDbgTrace( 0, Dbg, ("-------->count=%08lx\n",ReturnCount));
    if (ReturnCount==0) {
        Status = (STATUS_MORE_PROCESSING_REQUIRED);
        RxDbgTrace(0, Dbg, ("-->Count==0 EARLY OUT\n"));
        goto FINALLY;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    ASSERT( StufferState );

    *pCountRemainingInSmbbuf = 0;
    OrdinaryExchange->Info.CoreSearch.NextDirInfo = NULL;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                          SMB_COM_SEARCH, SMB_REQUEST_SIZE(SEARCH),
                                          NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("core search command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               ReturnCount,         //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c         //UCHAR SearchStatus[];             //  Resume key
               ResumeKeyLength,smbFobx->Enumeration.CoreResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORESEARCH
                                    );

    if (!NT_SUCCESS(Status)) goto FINALLY;

    smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST|SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
    //if (Status==RxStatus(SUCCESS) && FilesReturned==0) {
    //     RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: no files returned...switch status\n"));
    //     EndOfSearchReached = TRUE;
    //     Status = RxStatus(NO_MORE_FILES);
    //}
    if (Status==(STATUS_SUCCESS) && *pCountRemainingInSmbbuf==0) {
         RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no files returned...switch status\n"));
         EndOfSearchReached = TRUE;
         Status = (STATUS_NO_MORE_FILES);
    } else {
        //CODE.IMPROVEMENT a possible improvement here is to know that the search is closed
        //                 based on a "smaller-than-normal" return; we would key this off of the
        //                 operatingsystem return string i guess. for NT systems, we don't do this
         EndOfSearchReached = FALSE;
    }
    if (EndOfSearchReached) {
        RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no longer in progress...EOS\n"));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = (STATUS_NO_MORE_FILES);
    }
    //we dont save a resume key here since each individual copy operation will have to do that


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }
    if (!NT_SUCCESS(Status)&&(Status!=(STATUS_MORE_PROCESSING_REQUIRED))) {
        RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
#endif
    return(Status);
}

#define ASSERT_SAME_FIELD(__field,__t1,__t2) { \
      ASSERT(FIELD_OFFSET(__t1,__field)==FIELD_OFFSET(__t2,__field)); \
      }

#define ASSERT_SAME_DIRINFO_FIELDS(__t1,__t2) {\
      ASSERT_SAME_FIELD(LastWriteTime,__t1,__t2); \
      ASSERT_SAME_FIELD(EndOfFile,__t1,__t2); \
      ASSERT_SAME_FIELD(AllocationSize,__t1,__t2); \
      ASSERT_SAME_FIELD(FileAttributes,__t1,__t2); \
      }
#if DBG
VOID MRxSmbCoreFileSeach_AssertFields(void){
    //just move this out of the main execution path so that we don't have to look at it while
    //we Uing the code
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_FULL_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_BOTH_DIR_INFORMATION);
}
#else
#define MRxSmbCoreFileSeach_AssertFields()
#endif

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
#ifndef WIN9X
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PBYTE pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pLengthRemaining = OrdinaryExchange->Info.pBufferLength;
    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;

    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG SuccessCount = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreFileSearch entering.......OE=%08lx\n",OrdinaryExchange));
    MRxSmbCoreFileSeach_AssertFields();

    OrdinaryExchange->Info.CoreSearch.CountRemaining =
              RxContext->QueryDirectory.ReturnSingleEntry?1:0x7ffffff;

    if ( (smbFobx->Enumeration.CoreResumeKey ==NULL )
             && ((smbFobx->Enumeration.CoreResumeKey = RxAllocatePoolWithTag(PagedPool,sizeof(SMB_RESUME_KEY),'rbms'))==NULL) ){
        RxDbgTrace(0, Dbg, ("...couldn't allocate resume key\n"));
        Status = (STATUS_INSUFFICIENT_RESOURCES);
        goto FINALLY;
    }
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

    for (;;) {
        BOOLEAN BufferOverflow = FALSE;
        PSMB_DIRECTORY_INFORMATION NextDirInfo;
        UNICODE_STRING FileNameU;
        OEM_STRING FileNameA;
        WCHAR FileNameU_buffer[14];
        ULONG NameLength;
        PBYTE NextFileName;
        BOOLEAN Match,BufferOverFlow;

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_FILES) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                }
            } else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                } else {
                    Status = (STATUS_BUFFER_OVERFLOW);
                }
            }

            goto FINALLY;
        }
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemaining>0 );
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf>0 );
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch looptopcheck counts=%08lx,%08lx\n",
                    OrdinaryExchange->Info.CoreSearch.CountRemaining,
                    OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf
                    ));

        //next issue: does the next dirinfo match the criteria?!?

        NextDirInfo = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
        NextFileName = &NextDirInfo->FileName[0];

        // According to colinw, some core servers do not remember to insert the null at the end of the name...
        // but the namelength macro handles this correctly. some servers (Xenix, apparently) pad the
        // names with spaces. again, the macro handles it....
        //

        NAME_LENGTH(NameLength, NextFileName,sizeof(NextDirInfo->FileName));

        FileNameA.Length = (USHORT)NameLength;
        FileNameA.MaximumLength = (USHORT)NameLength;
        FileNameA.Buffer = NextFileName;
        FileNameU.Length = sizeof(FileNameU_buffer);
        FileNameU.MaximumLength = sizeof(FileNameU_buffer);
        FileNameU.Buffer = &FileNameU_buffer[0];

        Status = RtlOemStringToUnicodeString(&FileNameU, &FileNameA, TRUE);
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch considering.......filename=%wZ, template=%wZ\n",
                                    &FileNameU,&capFobx->UnicodeQueryTemplate));

        ASSERT(Status==(STATUS_SUCCESS));

        // we deal with a conversion failure by skipping this guy
        Match = (Status==(STATUS_SUCCESS));
        if (Match && smbFobx->Enumeration.WildCardsFound ) {
            //DbgBreakPoint();
            try
            {
                Match = FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                      &FileNameU, TRUE, NULL );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                Match = 0;
            }

        }

        //next issue: will the next dirinfo fit in the user's buffer?!?
        if (Match) {
            ULONG SpaceNeeded;
            PBYTE pRememberBuffer = pBuffer;
            //QuadAlign!! pBuffer = (PBYTE)LongAlign(pBuffer); //assume that this will fit
            if (SuccessCount != 0) {
                pBuffer = (PBYTE)QuadAlignPtr(pBuffer); //assume that this will fit
            }
            SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileNameU.Length;
            if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {
                BufferOverflow = TRUE;
                pBuffer = pRememberBuffer; //rollback
            } else {
                PSMBCEDB_SERVER_ENTRY pServerEntry;
                PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;
                SMB_TIME Time;
                SMB_DATE Date;
                PSMBCE_SERVER Server;

                Server = SmbCeGetExchangeServer(Exchange);
                BufferOverflow = FALSE;
                if (pPreviousBuffer != NULL) {
                    pPreviousBuffer->NextEntryOffset =
                        (ULONG)(((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer));
                }
                pPreviousBuffer = pThisBuffer;
                RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
                RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset, FileNameU.Buffer,FileNameU.Length);
                *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileNameU.Length;
                //hallucinate the record based on specific return type
                switch (InformationClass) {
                case SMB_FIND_FILE_NAMES_INFO:
                    break;
                case SMB_FIND_FILE_DIRECTORY_INFO:
                case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
                    //just fill what we have...we do not go to a lot of trouble on allocinfo as rdr1 did.
                    //     actually, rdr1 didn't do that here...only on getfielinfo.......
                    SmbMoveTime (&Time, &NextDirInfo->LastWriteTime);
                    SmbMoveDate (&Date, &NextDirInfo->LastWriteDate);
                    pThisBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);
                    pThisBuffer->EndOfFile.LowPart = SmbGetUlong(&NextDirInfo->FileSize);
                    pThisBuffer->FileAttributes = MRxSmbMapSmbAttributes (NextDirInfo->FileAttributes);
                    break;
                default:
                   RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
                   ASSERT(!"this can't happen");
                   Status = STATUS_INVALID_PARAMETER;
                   goto FINALLY;
                }
                pBuffer += SpaceNeeded;
                *pLengthRemaining -= (ULONG)(pBuffer-pRememberBuffer);
                OrdinaryExchange->Info.CoreSearch.CountRemaining--;
                SuccessCount++;
            }
        }

        //
        // if no match or no overflow, move up in the buffer. this means not only juggling the
        // pointers but also saving the resume key

        if (!Match || !BufferOverflow) {
            MRxSmbDumpResumeKey("BufferKey:",&NextDirInfo->ResumeKey);
            *(smbFobx->Enumeration.CoreResumeKey) = NextDirInfo->ResumeKey;
            MRxSmbDumpResumeKey("SaveKey:  ",smbFobx->Enumeration.CoreResumeKey);
            OrdinaryExchange->Info.CoreSearch.NextDirInfo = NextDirInfo + 1;
            OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf--;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemaining==0) {
            Status = (STATUS_SUCCESS);
            goto FINALLY;
        }

        //should we jam these together by smashing the countrem to 0 on bufferoverflow??? CODE.IMPROVEMENT
        if (BufferOverflow) {
            Status = (SuccessCount==0)?(STATUS_BUFFER_OVERFLOW):(STATUS_SUCCESS);
            goto FINALLY;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf==0) {

            Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

        }

    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreFileSearch exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    //CODE.IMPROVEMENT if we're done with the resume key we could free it!
#endif
    return(Status);
}

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
    also VolumeLabelLengthReturned is the number of bytes of the label that were stored, if any.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING VolumeLabelU;
    OEM_STRING VolumeLabelA;
    SMB_DIRECTORY_INFORMATION Buffer;
    ULONG NameLength;
    ULONG BytesToCopy;
    PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

    PAGED_CODE();

    NAME_LENGTH(NameLength, VolumeLabel,
               sizeof(OrdinaryExchange->Info.QFSVolInfo.CoreLabel));

    VolumeLabelA.Length = (USHORT)NameLength;
    VolumeLabelA.MaximumLength = (USHORT)NameLength;
    VolumeLabelA.Buffer = VolumeLabel;

    //some core servers put a '.' in the labelname.....if it's there then remove it
    if ((NameLength>8)&& (VolumeLabel[8]=='.') ) {
        ULONG i;
        for (i=8;i<NameLength;i++) {
            VolumeLabel[i] = VolumeLabel[i+1];
        }
    }

    Status = RtlOemStringToUnicodeString(&VolumeLabelU, &VolumeLabelA, TRUE);

    if (NT_SUCCESS(Status)) {

        PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;
        PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
        ULONG BytesToCopy = min((ULONG)VolumeLabelU.Length, (*pBufferLength-sizeof(FILE_FS_VOLUME_INFORMATION)));

        RtlCopyMemory(&pBuffer->VolumeLabel[0],
                      VolumeLabelU.Buffer,
                      BytesToCopy);

        *VolumeLabelLengthReturned = BytesToCopy;
        pBuffer->VolumeLabelLength = VolumeLabelU.Length;
        IF_DEBUG {
            UNICODE_STRING FinalLabel;
            FinalLabel.Buffer = &pBuffer->VolumeLabel[0];
            FinalLabel.Length = (USHORT)BytesToCopy;
            RxDbgTrace(0, Dbg, ("MrxSmbOemVolumeInfoToUnicode vollabel=%wZ\n",&FinalLabel));
        }

        RtlFreeUnicodeString(&VolumeLabelU);
    }

    return(Status);
}




MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ searchvolumelabel before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    MRxSmbStuffSMB (StufferState,
         "0wwB4yw!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               1,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
                                    //  w         _USHORT( SearchAttributes );
               SMB_FILE_ATTRIBUTE_VOLUME,
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &MRxSmbAll8dot3Files,//  4         //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //           //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               0                    //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //            //UCHAR SearchStatus[];             //  Resume key
             );


    MRxSmbDumpStufferState (700,"SMB w/ searchvolumelabel after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYLABEL
                                    );

    //Status = RxStatus(NOT_IMPLEMENTED);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a downlevel getvolumeinfo/FS_VOLUME_INFORMATION.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER  pServer;
    BOOLEAN        UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    ULONG VolumeLabelLengthReturned = 0;

    PAGED_CODE();

    ASSERT(pBuffer!=NULL);
    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20);

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    pBuffer->SupportsObjects = FALSE;
    pBuffer->VolumeCreationTime.LowPart = 0;
    pBuffer->VolumeCreationTime.HighPart = 0;
    pBuffer->VolumeSerialNumber = 0;
    pBuffer->VolumeLabelLength = 0;

    OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label

    if (!UseTransactVersion) {
        Status =  MrxSmbCoreQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    } else {
        VolInfo.InformationLevel = SMB_INFO_VOLUME;

        Status = MRxSmbSimpleSyncTransact2(
                        SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
                        TRANS2_QUERY_FS_INFORMATION,
                        &VolInfo,sizeof(VolInfo),
                        NULL,0
                        );
    }

    ASSERT ( *pBufferLength>=sizeof(FILE_FS_VOLUME_INFORMATION));
    RxDbgTrace(0, Dbg, ("MrxSmbQueryFsVolumeInfo OEstatus=%08lx\n",Status));
    //DbgBreakPoint();

    if ( (Status==STATUS_SUCCESS) &&
         (OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] != 0) ) {

        Status = MrxSmbOemVolumeInfoToUnicode(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,&VolumeLabelLengthReturned);

    } else if ( (Status == STATUS_NO_SUCH_FILE)
                   || (Status == STATUS_NO_MORE_FILES) ) {
        //
        //  these statuses indicate that there's no volume label
        //  the remote volume.  Return success with no data.
        //

        Status = (STATUS_SUCCESS);

    }

    if (NT_SUCCESS(Status)) {
        *pBufferLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel);
        *pBufferLength -= VolumeLabelLengthReturned;
    }


    RxDbgTrace(-1, Dbg, ("MrxSmbQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION_DISK,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION_DISK),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("querydiskattribs command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ querydiskattribs before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
               SMB_WCT_CHECK(0) 0   //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

    MRxSmbDumpStufferState (700,"SMB w/ querydiskattribs after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES
                                    );
FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    NTRAID-455631-2/2/2000 yunlin NT transaction should be used

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER pServer;
    BOOLEAN UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20) &&
                         !MRxSmbForceCoreGetAttributes;
    if (!UseTransactVersion) {
        return MrxSmbCoreQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    }

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    VolInfo.InformationLevel = SMB_INFO_ALLOCATION;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
                    TRANS2_QUERY_FS_INFORMATION,
                    &VolInfo,sizeof(VolInfo),
                    NULL,0
                    );

    RxDbgTrace(-1, Dbg, ("MrxSmbQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for VOLINFO.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;
    PBYTE pBuffer = (PBYTE)OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CoreInfo\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
            Status = MrxSmbQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        case FileFsSizeInformation:
            Status = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
         ASSERT(!"shouldn't get here1");
         goto FINALLY;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) goto FINALLY;
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
            *((PFILE_BASIC_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Basic;
            *pBufferLength -= sizeof(FILE_BASIC_INFORMATION);
            goto FINALLY;
        case SMB_QUERY_FILE_STANDARD_INFO:
            *((PFILE_STANDARD_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Standard;
            *pBufferLength -= sizeof(FILE_STANDARD_INFORMATION);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
        ASSERT(!"shouldn't get here2");
        goto FINALLY;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
            {
                ULONG SmbAttributes = MRxSmbMapFileAttributes(((PFILE_BASIC_INFORMATION)pBuffer)->FileAttributes);
                PFILE_BASIC_INFORMATION BasicInfo = (PFILE_BASIC_INFORMATION)pBuffer;

                if (SmbAttributes != 0 ||
                    (BasicInfo->CreationTime.QuadPart == 0 &&
                     BasicInfo->LastWriteTime.QuadPart == 0 &&
                     BasicInfo->LastAccessTime.QuadPart == 0)) {
                    Status = MRxSmbSetFileAttributes(
                                SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                SmbAttributes);
                }

                if (BasicInfo->LastWriteTime.QuadPart == 0 &&
                    FlagOn(pServerEntry->Server.DialectFlags,DF_W95)) {
                    // Win9x server only takes last write time.
                    Status = STATUS_SUCCESS;
                    goto FINALLY;
                }

                if (BasicInfo->CreationTime.QuadPart != 0 ||
                    BasicInfo->LastWriteTime.QuadPart != 0 ||
                    BasicInfo->LastAccessTime.QuadPart != 0) {

                    Status = MRxSmbDeferredCreate(RxContext);

                    if (Status == STATUS_SUCCESS) {
                        Status = MRxSmbSetFileAttributes(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SmbAttributes);
                    }
                }

            }
            goto FINALLY;

        case FileEndOfFileInformation:
            if (((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.HighPart) {
                Status = (STATUS_INVALID_PARAMETER);
            } else {
                Status = MRxSmbCoreTruncate(
                                  SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                  smbSrvOpen->Fid,
                                  ((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.LowPart);
            }

            goto FINALLY;

        case FileDispositionInformation:
            OrdinaryExchange->pPathArgument1 = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY )));

            goto FINALLY;

        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
        }

        ASSERT(!"shouldn't get here3");
        goto FINALLY;

    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        Status = MRxSmbCoreFileSearch(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        goto FINALLY;

    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
        {
            PSMBCE_NET_ROOT psmbNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);
            PMRX_V_NET_ROOT pVNetRoot = SmbCeGetExchangeVNetRoot(OrdinaryExchange);
            PMRX_NET_ROOT pNetRoot = pVNetRoot->pNetRoot;
            PSMBCE_SERVER psmbServer = SmbCeGetExchangeServer(OrdinaryExchange);
            ULONG ClusterSize;
            PLARGE_INTEGER pFileSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.Buffer);
            PLARGE_INTEGER pAllocationSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.pBufferLength);

            //we will need the cluster size
            if (OrdinaryExchange->ServerVersion==pNetRoot->ParameterValidationStamp) {

                ClusterSize=pNetRoot->DiskParameters.ClusterSize;

            } else {

                RxSynchronizeBlockingOperations(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
                if (OrdinaryExchange->ServerVersion!=pNetRoot->ParameterValidationStamp) {

                    //
                    //here we have to go find out the clustersize

                    NTSTATUS LocalStatus;
                    FILE_FS_SIZE_INFORMATION UsersBuffer;
                    ULONG BufferLength = sizeof(FILE_FS_SIZE_INFORMATION);
                    //fill in the exchange params so that we can get the params we need
                    OrdinaryExchange->Info.Buffer = &UsersBuffer;
                    OrdinaryExchange->Info.pBufferLength = &BufferLength;
                    LocalStatus = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
                    if (LocalStatus == STATUS_SUCCESS) {
                        ClusterSize = UsersBuffer.BytesPerSector * UsersBuffer.SectorsPerAllocationUnit;
                        pNetRoot->ParameterValidationStamp =OrdinaryExchange->ServerVersion;
                    } else {
                        ClusterSize = 0;
                    }
                    if (ClusterSize==0) {
                        ClusterSize = 1;
                    }
                    pNetRoot->DiskParameters.ClusterSize = ClusterSize;
                    RxDbgTrace(0, Dbg, ("clustersize set to %08lx\n", ClusterSize ));
                    RxLog(("clustersize rx/n/cs %lx %lx %lx\n",
                              OrdinaryExchange->RxContext,pNetRoot,ClusterSize ));
                    SmbLog(LOG,
                           SmbPseExchangeStart_CoreInfo,
                           LOGPTR(OrdinaryExchange->RxContext)
                           LOGPTR(pNetRoot)
                           LOGULONG(ClusterSize));
                } else {

                    // someone else went and got the value while i was asleep...just use it

                    ClusterSize=pNetRoot->DiskParameters.ClusterSize;

                }

                RxResumeBlockedOperations_Serially(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
            }

            ASSERT (ClusterSize != 0);

            if (FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) {
                //i'm using this to identify a server that supports 64bit offsets
                //for these guys, we write a zero at the eof....since the filesystems
                //extend on writes this will be much better than a set-end-of-file
                LARGE_INTEGER ByteOffset,AllocationSize,ClusterSizeAsLI;
                ULONG Buffer = 0;
                UCHAR WriteCommand;
                PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);

                // We have to be smart about this. Ntfs sometimes gets configured
                // with cluster sizes around 32K.
                // There is no reason to believe that the
                // Allocation size has changed if the new File size is less than
                // previous Allocation size. So, skip the extend and the qfi for
                // Allocation size.

                ClusterSizeAsLI.QuadPart = ClusterSize;
                AllocationSize.QuadPart = (pFileSize->QuadPart+ ClusterSizeAsLI.QuadPart) &
                                          ~(ClusterSizeAsLI.QuadPart - 1);

                if ((AllocationSize.QuadPart <= capFcb->Header.AllocationSize.QuadPart) ||
                    ((capFcb->Header.AllocationSize.QuadPart == 0) && (pFileSize->QuadPart < 0x1000))) {

                    // Return the old value.

                    pAllocationSize->QuadPart = AllocationSize.QuadPart;
                    RxDbgTrace(0, Dbg, ("alocatedsiz222e set to %08lx\n", pAllocationSize->LowPart ));

                    // At this point, we know that the written data hasn't been
                    // flushed. This is ok, since the client would have requested
                    // a flush if the data need to be sunk into the server's disk.
                    // Server file size is different from the client file size
                    // at this point, but allocation size is the same. We extend
                    // to make sure the server has space, if we know the extend isn't
                    // going to question space constraint, we won't even try!!

                } else {
                    if (FlagOn(pServer->DialectFlags,DF_LARGE_FILES)) {
                        WriteCommand = SMB_COM_WRITE_ANDX;
                    } else {
                        WriteCommand = SMB_COM_WRITE;
                    }

                    ByteOffset.QuadPart = pFileSize->QuadPart - 1;

                    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                    COVERED_CALL(MRxSmbBuildWriteRequest(
                                        OrdinaryExchange,
                                        TRUE, // IsPagingIo
                                        WriteCommand,
                                        1,
                                        &ByteOffset,
                                        (PBYTE)&Buffer,
                                        NULL //BufferAsMdl,
                                        ));
                    COVERED_CALL(SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                SMBPSE_OETYPE_EXTEND_WRITE
                                                ));

                    //this is what you do if you can't do better
                    ClusterSizeAsLI.QuadPart = ClusterSize;
                    AllocationSize.QuadPart =
                        (pFileSize->QuadPart+ ClusterSizeAsLI.QuadPart)  &
                        ~(ClusterSizeAsLI.QuadPart - 1);

                    if (Status == STATUS_SUCCESS) {
                        Status = MRxSmbGetNtAllocationInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
                    }

                    if (NT_SUCCESS(Status)) {
                        pAllocationSize->QuadPart = OrdinaryExchange->Transact2.AllocationSize.QuadPart;
                        RxDbgTrace(0, Dbg, ("alocatedsiz222e set to %08lx\n", pAllocationSize->LowPart ));
                    }
                }
            }

            if ( (!FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) ||
                (!NT_SUCCESS(Status) && (Status != STATUS_DISK_FULL) && (Status != STATUS_RETRY)) ) {
                ULONG FileSize,AllocationSize;
                FileSize = pFileSize->LowPart;

                COVERED_CALL(MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            smbSrvOpen->Fid, FileSize
                                            ));

                //this is what you do if you can't do better
                AllocationSize = (FileSize+ClusterSize)&~(ClusterSize-1);
                pAllocationSize->QuadPart = AllocationSize; //64bit!
                RxDbgTrace(0, Dbg, ("alocatedsize set to %08lx\n", pAllocationSize->LowPart ));

                //if we care a lot about downlevel performance, we could do the same as ntgetallocation
                //except that we would use a 32bit smb.........like query_information2
            }


        }
        goto FINALLY;
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CoreInfo exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishSearch:");

    if (Response->WordCount != 1) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    if (OrdinaryExchange->OEType == SMBPSE_OETYPE_COREQUERYLABEL) {
        //here, all we do is to copy the label to wherever is pointed to by
        if (SmbGetUshort(&Response->Count)>0) {
            PBYTE smbDirInfotmp = &Response->Buffer[0]
                                        +sizeof(UCHAR) //bufferformat
                                        +sizeof(USHORT); //datalength
            PSMB_DIRECTORY_INFORMATION smbDirInfo = (PSMB_DIRECTORY_INFORMATION)smbDirInfotmp;
            RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch corelabl=%s,size=%d\n",
                                     smbDirInfo->FileName, sizeof(smbDirInfo->FileName) ));

            if (sizeof(smbDirInfo->FileName) != 13) { //straightfrom the spec
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto FINALLY;
            }


            RtlCopyMemory(OrdinaryExchange->Info.QFSVolInfo.CoreLabel,
                          smbDirInfo->FileName, sizeof(smbDirInfo->FileName)
                         );
        } else {
            OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label
        }
    } else if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY) {
        //here, we 're doing a search SMB to see if the directory is empty. we have to read thru the
        // entries returned (if successful). if we encounter ones that are neither '.' or '..',  set
        // resumekey to null since that will tell the guy above that the directory is nonempty
        ULONG Count = SmbGetUshort(&Response->Count);
        PSMB_DIRECTORY_INFORMATION NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));

        for (;Count>0;Count--,NextDirInfo++) {
            RxDbgTrace(0, Dbg, ("--->emptydirchk: file=%s\n",&NextDirInfo->FileName[0]));
            /*
            // Since the DOS Server returns the file name ".           " instead of ".", and so does the
            // "..          ", the following if {...} statements are always past through with no action.
            // But those statements make the RMDIR not working on OS2 Server  since  it  returns the "."
            // and ".." without following blanks.  After the if {...} statements were removed, the RMDIR
            // workes on OS2 Server and no impact has been found to access the DOS Server.
            if (NextDirInfo->FileName[0]=='.') {
                CHAR c1;
                if ((c1=NextDirInfo->FileName[1])==0) {
                    continue; //skip past "."
                } else if ((c1=='.')&&(NextDirInfo->FileName[2]==0)) {
                    continue; //skip past ".."
                } else {
                    NOTHING;
                }
            }
            */
            // here we have found a bad one...make sure there's no resume key and change the status
            Status = (STATUS_NO_MORE_FILES);
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey = NULL;
        }
        //if we get here with success, set up the resume key and buffer
        if (Status == (STATUS_SUCCESS)) {
            NextDirInfo--;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer =
                                    NextDirInfo->ResumeKey;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey =
                                    &OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer;
        }
    } else {
        //all that we do here is to setup the nextdirptr and the count in the OE
        ASSERT(OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCH);
        OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf = SmbGetUshort(&Response->Count);
        OrdinaryExchange->Info.CoreSearch.NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));
        IF_DEBUG {
            ULONG tcount = OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;
            PSMB_DIRECTORY_INFORMATION ndi = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
            RxDbgTrace(0, Dbg, ("--->coresearch: count/ndi=%08lx/%08lx\n",tcount,ndi));
            if (tcount) {
                //DbgBreakPoint();
                RxDbgTrace(0, Dbg, ("--->coresearch: firstfile=%s\n",&ndi->FileName[0]));
            }
        }
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishSearch   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
    PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishQueryDiskInfo\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishQueryDiskInfo:");

    //CODE.IMPROVEMENT this should be a macro.........
    IF_DEBUG{
        PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
        RxCaptureFobx;
        PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    }

    if (Response->WordCount != 5 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUshort(&Response->TotalUnits);
    UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUshort(&Response->FreeUnits);
    UsersBuffer->SectorsPerAllocationUnit = SmbGetUshort(&Response->BlocksPerUnit);
    UsersBuffer->BytesPerSector = SmbGetUshort(&Response->BlockSize);

    *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishQueryDiskInfo   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for cached IO. we just share the
   core_info skeleton.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    if (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) {
        //here, we just get out since disk reservations don't do us any good....
        pNewAllocationSize->QuadPart = (pNewFileSize->QuadPart)<<2;
        return(STATUS_SUCCESS);
    }

    if (capFcb->pNetRoot->Type == NET_ROOT_PRINT) {
        pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;

        // invalidate the name based file info cache since it is almost impossible
        // to know the last write time of the file on the server.
        MRxSmbInvalidateFileInfoCache(RxContext);

        return(STATUS_SUCCESS);
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbExtendForCache %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (FALSE) {
        DbgPrint("Extend top  %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart);
    }


    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (smbSrvOpen->hfShadow != 0){
            NTSTATUS ShadowExtendNtStatus;

            ShadowExtendNtStatus = MRxSmbDCscExtendForCache(RxContext,
                                                            pNewFileSize,
                                                            pNewAllocationSize);

            if (ShadowExtendNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(-1, Dbg,
                   ("MRxSmbExtendForCache returningDCON with status=%08lx\n",
                    ShadowExtendNtStatus ));

                return(ShadowExtendNtStatus);

            } else {

                RxDbgTrace(0, Dbg,
                  ("MRxSmbExtendForCache continueingDCON with status=%08lx\n",
                            ShadowExtendNtStatus ));
            }
        }
    }

    //we just pass in our info into MRxSmbCoreInformation thru the existing pointers....
    //we have two pointers.....the first two params are ptrs......
    do {
        Status = MRxSmbCoreInformation(RxContext,0,
                                       (PVOID)pNewFileSize,
                                       (PULONG)pNewAllocationSize,
                                       SMBPSE_OE_FROM_EXTENDFILEFORCACHEING
                                       );
    } while (Status == STATUS_RETRY);

    if (FALSE) {
        DbgPrint("Extend exit Status %lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                     Status,
                     capFcb->Header.FileSize.HighPart,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.HighPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->HighPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->HighPart,
                     pNewAllocationSize->LowPart);
    }

    // Only invalidate if Allocation Size changed.
    // Unless we close, the Last Access time or Last Written time is
    // not guaranteed to change for Ntfs (one file system).
    // If it is not guaranteed for one file system, we needn't guarantee for any.
    // So, Don't have to Invalidate our FileInfo Cache.

    if (capFcb->Header.AllocationSize.QuadPart < pNewAllocationSize->QuadPart) {
        MRxSmbInvalidateFileInfoCache(RxContext);
    }

    RxLog(("Extend exit %lx %lx %lx %lx %lx\n",
                     RxContext,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart));
    SmbLog(LOG,
           MRxSmbExtendForCache,
           LOGPTR(RxContext)
           LOGULONG(capFcb->Header.FileSize.LowPart)
           LOGULONG(capFcb->Header.AllocationSize.LowPart)
           LOGULONG(pNewFileSize->LowPart)
           LOGULONG(pNewAllocationSize->LowPart));

    RxDbgTrace(-1, Dbg, ("MRxSmbExtendForCache  exit with status=%08lx %08lx %08lx\n",
                          Status, pNewFileSize->LowPart, pNewAllocationSize->LowPart));
    return(Status);

}

NTSTATUS
MRxSmbExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for noncached IO. since the write
   itself will extend the file, we can pretty much just get out quickly.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //RxCaptureFcb; RxCaptureFobx;

    //PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    //PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;

    // invalidate the name based file info cache since it is almost impossible
    // to know the last write time of the file on the server.
    MRxSmbInvalidateFileInfoCache(RxContext);

    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   gets the nt allocation information by doing a simple transact........

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    REQ_QUERY_FILE_INFORMATION FileInfo;

    PAGED_CODE();

    FileInfo.Fid = smbSrvOpen->Fid;
    FileInfo.InformationLevel = SMB_QUERY_FILE_STANDARD_INFO;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
                    TRANS2_QUERY_FILE_INFORMATION,
                    &FileInfo,sizeof(FileInfo),
                    NULL,0
                    );

    return(Status);
}

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    )
/*++

Routine Description:

   This routine does a simple 1-in-1out transact2

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSimpleSyncTransact2 entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_TRANSACTION2,
                                SMB_REQUEST_SIZE(TRANSACTION),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ pseT2 before stuffing",StufferState);

    //the return sizes of 100 and 800 are chosen arbitrarily.

    MRxSmbStuffSMB (StufferState,
       "0wwwwdD",
                                    //  0         UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
           ParamsLength,            //  w         _USHORT( TotalParameterCount );     // Total parameter bytes being sent
           DataLength,              //  w         _USHORT( TotalDataCount );          // Total data bytes being sent
           100,                     //  w         _USHORT( MaxParameterCount );       // Max parameter bytes to return
           800,                     //  w         _USHORT( MaxDataCount );            // Max data bytes to return
           0,                       //  d   .     UCHAR MaxSetupCount;                // Max setup words to return
                                    //      .     UCHAR Reserved;
                                    //      .     _USHORT( Flags );                   // Additional information:
                                    //                                                //  bit 0 - also disconnect TID in Tid
                                    //                                                //  bit 1 - one-way transacion (no resp)
                                    //  D         _ULONG( Timeout );
          SMB_OFFSET_CHECK(TRANSACTION,Timeout) 0,
       STUFFER_CTL_NORMAL, "wwpwQyyw",
          0,                        //  w         _USHORT( Reserved2 );
          ParamsLength,             //  w         _USHORT( ParameterCount );          // Parameter bytes sent this buffer
                                    //  p         _USHORT( ParameterOffset );         // Offset (from header start) to params
          DataLength,               //  w         _USHORT( DataCount );               // Data bytes sent this buffer
                                    //  Q         _USHORT( DataOffset );              // Offset (from header start) to data
          SMB_OFFSET_CHECK(TRANSACTION,DataOffset)
          1,                        //  y         UCHAR SetupCount;                   // Count of setup words
          0,                        //  y         UCHAR Reserved3;                    // Reserved (pad above to word)
                                    //            UCHAR Buffer[1];                    // Buffer containing:
          TransactSetupCode,        //  w         //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
       STUFFER_CTL_NORMAL, "ByS6cS5c!",
           SMB_WCT_CHECK(15)        //  B         //USHORT ByteCount;                 //  Count of data bytes
           0,                       //  y         //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
                                    //  S         //UCHAR Pad[];                      //  Pad to SHORT or LONG
                                    //  6c        //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
           ParamsLength,Params,
           //CODE.IMPROVEMENT altho every server seems to take it, this should
           //                 be conditioned on datalength!=0
                                    //  S         //UCHAR Pad1[];                     //  Pad to SHORT or LONG
                                    //  5c        //UCHAR Data[];                     //  Data bytes (# = DataCount)
           DataLength,Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ pseT2 after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    if (FixupRoutine) {
        Status = FixupRoutine(OrdinaryExchange);
        if (Status!=STATUS_SUCCESS) {
            goto FINALLY;
        }
    }
    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    OEType
                                    );


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSimpleSyncTransact2 exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      )
/*++

Routine Description:

    This routine finishes a transact2. what it does depends on the OE_TYPE.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    PAGED_CODE();  //could actually be nonpaged

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishTransaction2\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishTransaction2:");

    switch (OrdinaryExchange->OEType) {
    case SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO:{
        PFILE_STANDARD_INFORMATION StandardInfo;
        if (   (Response->WordCount!=10)
            || (SmbGetUshort(&Response->TotalParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterDisplacement)!=0)
            || (SmbGetUshort(&Response->TotalDataCount)!=24)
            || (SmbGetUshort(&Response->DataCount)!=24)
            || (SmbGetUshort(&Response->DataDisplacement)!=0)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        StandardInfo = (PFILE_STANDARD_INFORMATION)
                          (StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));
        OrdinaryExchange->Transact2.AllocationSize.LowPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.LowPart);
        OrdinaryExchange->Transact2.AllocationSize.HighPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.HighPart);

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   nt allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;

    case SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO:{
        PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_ALLOCATE QfsInfo;

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->DataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalDataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {

            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        QfsInfo = (PQFS_ALLOCATE)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnit);
        UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnitAvail);
        UsersBuffer->SectorsPerAllocationUnit = SmbGetUlong(&QfsInfo->cSectorUnit);
        UsersBuffer->BytesPerSector = SmbGetUshort(&QfsInfo->cbSector);

        *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);    //CODE.IMPROVEMENT shouldn't this be done above??

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO:{
        PFILE_FS_VOLUME_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_INFO QfsInfo;
        ULONG LabelLength;
        PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {

            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        QfsInfo = (PQFS_INFO)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->VolumeSerialNumber = SmbGetUlong(&QfsInfo->ulVSN);

        //copy the volumelabel to the right place in the OE where it can UNICODE-ized by the routine above

        LabelLength  = min(QfsInfo->cch,12);
        RtlCopyMemory(VolumeLabel,&QfsInfo->szVolLabel[0],LabelLength);
        VolumeLabel[LabelLength] = 0;


        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   volinfo serialnum= %08lx\n",
                               UsersBuffer->VolumeSerialNumber ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL:{
        //do nothing here....everything is done back in the caller with the
        //whole buffer having been copied.....
        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   one file \n"));
        }break;
    default:
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishTransaction2   returning %08lx\n", Status ));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\downlvlo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DownLvlO.c

Abstract:

    This module implements downlevel opens.

Author:

    Joe Linn      [JoeLi]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreDeleteForSupercedeOrClose)
#pragma alloc_text(PAGE, MRxSmbCoreCheckPath)
#pragma alloc_text(PAGE, MRxSmbCoreOpen)
#pragma alloc_text(PAGE, MRxSmbSetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCloseAfterCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCoreTruncate)
#pragma alloc_text(PAGE, MRxSmbDownlevelCreate)
#pragma alloc_text(PAGE, MRxSmbFinishGFA)
#pragma alloc_text(PAGE, MRxSmbFinishCoreCreate)
#pragma alloc_text(PAGE, MRxSmbPopulateFileInfoInOE)
#pragma alloc_text(PAGE, MRxSmbFinishCoreOpen)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromFakeGFAResponse)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromGFAResponse)
#pragma alloc_text(PAGE, MRxSmbConvertSmbTimeToTime)
#pragma alloc_text(PAGE, MRxSmbConvertTimeToSmbTime)
#pragma alloc_text(PAGE, MRxSmbTimeToSecondsSince1970)
#pragma alloc_text(PAGE, MRxSmbSecondsSince1970ToTime)
#pragma alloc_text(PAGE, MRxSmbMapSmbAttributes)
#pragma alloc_text(PAGE, MRxSmbMapDisposition)
#pragma alloc_text(PAGE, MRxSmbUnmapDisposition)
#pragma alloc_text(PAGE, MRxSmbMapDesiredAccess)
#pragma alloc_text(PAGE, MRxSmbMapShareAccess)
#pragma alloc_text(PAGE, MRxSmbMapFileAttributes)
#endif

#define Dbg                              (DEBUG_TRACE_CREATE)

#pragma warning(error:4101)   // Unreferenced local variable

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

PVOID
MRxSmbPopulateFcbInitPacketForCore(void);


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );
NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );
NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );

//CODE.IMPROVEMENT all of these routines that do a single core operation are to
// be rolled up into a single routine......
// for this reason, we shouldn't worry about the commonality...the more the better!

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse. This routine also
   does the cache for the file information.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen    = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen = NULL;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSynchronousGetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    if (FsRtlDoesNameContainWildCards(RemainingName)) {
        Status = RX_MAP_STATUS(OBJECT_NAME_INVALID);
        goto FINALLY;
    }

    if (MRxSmbIsFileNotFoundCached(RxContext)) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto FINALLY;
    }

    // Try to find the cached file infomation
    if (MRxSmbIsFileInfoCacheFound(RxContext,
                                   &OrdinaryExchange->Create.FileInfo,
                                   &Status,
                                   NULL)){
        goto FINALLY;
    }

    // If the file has already been opened a QUERY_INFORMATION2 can be issued while
    // QUERY_INFORMATION can only be issued against pseudo opened and not yet
    // opened files.

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (pServerEntry->Server.Dialect > PCNET1_DIALECT &&
        (smbSrvOpen != NULL) &&
        (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
         !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN)   &&
         (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE))) {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION2,
                SMB_REQUEST_SIZE(QUERY_INFORMATION2),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        MRxSmbStuffSMB (
            StufferState,
            "0wB!",
                                        //  0         UCHAR WordCount;
            smbSrvOpen->Fid,            //  w         _USHORT(Fid);
            SMB_WCT_CHECK(1)  0         //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    } else {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION,
                SMB_REQUEST_SIZE(QUERY_INFORMATION),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
        //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
        MRxSmbStuffSMB (
            StufferState,
            "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
            SMB_WCT_CHECK(0)            //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    }

    Status = SmbPseOrdinaryExchange(
                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                 SMBPSE_OETYPE_GFA
                 );

    if (NT_SUCCESS(Status)) {
        MRxSmbCreateFileInfoCache(RxContext,
                                  &OrdinaryExchange->Create.FileInfo,
                                  pServerEntry,
                                  Status);
    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);
        }
    }

FINALLY:

    if (NT_SUCCESS(Status)) {
        OrdinaryExchange->Create.StorageTypeFromGFA =
            OrdinaryExchange->Create.FileInfo.Standard.Directory ?
            FileTypeDirectory : FileTypeFile;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSynchronousGetFileAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreDeleteForSupercede entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( OrdinaryExchange->pPathArgument1 != NULL );

    //
    if (!DeleteDirectory) {
        ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                    SMB_REQUEST_SIZE(DELETE),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ del before stuffing",StufferState);

        //CODE.IMPROVEMENT if this is truly core, we have to copy the name since it's in UNICODE
        //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
        //                 on the other hand, if it's NT<-->NT we don't do it here anyway
        MRxSmbStuffSMB (StufferState,
             "0wB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                    SearchAttributes,   //  w         _USHORT( SearchAttributes );
                    SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    } else {


        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE_DIRECTORY,
                                    SMB_REQUEST_SIZE(DELETE_DIRECTORY),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ rmdir before stuffing",StufferState);

        //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
        //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
        MRxSmbStuffSMB (StufferState,
             "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
                    SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    }


    MRxSmbDumpStufferState (700,"SMB w/ del/rmdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE
                                    );

    if (Status == STATUS_SUCCESS) {
        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);
        

        MRxSmbInvalidateInternalFileInfoCache(RxContext);
        MRxSmbCacheFileNotFound(RxContext);

        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
    } else {
        RxLog(("Delete File: %x %wZ\n",Status,OrdinaryExchange->pPathArgument1));
        SmbLog(LOG,
               MRxSmbCoreDeleteForSupercedeOrClose,
               LOGULONG(Status)
               LOGUSTR(*OrdinaryExchange->pPathArgument1));
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreDeleteForSupercede exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    FILE_BASIC_INFORMATION FileInfoBasic;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCheckPath entering.......OE=%08lx\n",
                                                            OrdinaryExchange));
    // Try to find the cached file infomation
    if (MRxSmbIsBasicFileInfoCacheFound(RxContext,
                                        &FileInfoBasic,
                                        &Status,
                                        OrdinaryExchange->pPathArgument1)){

        if (Status == STATUS_SUCCESS) {
            if (!(FileInfoBasic.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                Status = STATUS_NOT_A_DIRECTORY;
            }

            goto FINALLY;
        }
    }
    
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );


    COVERED_CALL(MRxSmbStartSMBCommand
                                (StufferState,SetInitialSMB_ForReuse,
                                SMB_COM_CHECK_DIRECTORY,
                                SMB_REQUEST_SIZE(CHECK_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),
                                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ chkdir before stuffing",StufferState);

    //CODE.IMPROVEMENT many of these single argument guys can be rooled up
    MRxSmbStuffSMB (StufferState,
         "0B4!",
         //         UCHAR WordCount;       // Count of parameter words = 0
         SMB_WCT_CHECK(0)
         //  B    _USHORT( ByteCount );    // Count of data bytes; min = 2
         //       UCHAR Buffer[1];         // Buffer containing:
         OrdinaryExchange->pPathArgument1
         //  4    UCHAR BufferFormat;      //  0x04 -- ASCII
         //       UCHAR FileName[];        //  File name
    );


    MRxSmbDumpStufferState (700,"SMB w/ chkdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECHECKDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg,
                ("MRxSmbCoreCheckPath exiting.......OE=%08lx, st=%08lx\n",
                 OrdinaryExchange,Status)
              );
    return(Status);
}

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    )
/*++

Routine Description:

   This routine does a core open.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreOpen entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_OPEN,
                                SMB_REQUEST_SIZE(OPEN),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
                OpenShareMode,      //  w         _USHORT( DesiredAccess );           // Mode - read/write/share
                Attribute,          //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(2)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ coreopen after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREOPEN
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreOpen exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN     SrvOpen     = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen  = NULL;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG LastWriteTime = 0;
    ULONG FileAttributes = 0;
    PLARGE_INTEGER pCreationTime = NULL;
    PLARGE_INTEGER pLastWriteTime = NULL;
    PLARGE_INTEGER pLastAccessTime = NULL;
    SMB_TIME SmbCreationTime;
    SMB_DATE SmbCreationDate;
    SMB_TIME SmbLastWriteTime;
    SMB_DATE SmbLastWriteDate;
    SMB_TIME SmbLastAccessTime;
    SMB_DATE SmbLastAccessDate;
    
    PSMBSTUFFER_BUFFER_STATE StufferState;
    BOOLEAN TimeSpecified = FALSE;
    
    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    SmbCreationTime.Ushort = 0;
    SmbCreationDate.Ushort = 0;
    SmbLastWriteTime.Ushort = 0;
    SmbLastWriteDate.Ushort = 0;
    SmbLastAccessTime.Ushort = 0;
    SmbLastAccessDate.Ushort = 0;

    if (RxContext->MajorFunction == IRP_MJ_SET_INFORMATION) {
        BOOLEAN GoodTime;
        
        FileAttributes = ((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->FileAttributes;
        pCreationTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->CreationTime;
        pLastWriteTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastWriteTime;
        pLastAccessTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastAccessTime;

        if (pLastWriteTime->QuadPart != 0) {
            GoodTime = MRxSmbTimeToSecondsSince1970(
                           pLastWriteTime,
                           SmbCeGetExchangeServer(OrdinaryExchange),
                           &LastWriteTime);

            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }

            GoodTime = MRxSmbConvertTimeToSmbTime(pLastWriteTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastWriteTime,
                                       &SmbLastWriteDate);
        
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
            
            TimeSpecified = TRUE;
        }
    
        if (pLastAccessTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pLastAccessTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastAccessTime,
                                       &SmbLastAccessDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
            
            TimeSpecified = TRUE;
        }
    
        if (pCreationTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pCreationTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbCreationTime,
                                       &SmbCreationDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
            
            TimeSpecified = TRUE;
        }

                
        if (!TimeSpecified && (FileAttributes == 0))
        {
            // caller didn't specify anything worth doing. Return success
            // 442486
        
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }
    }

    if (smbSrvOpen == NULL ||
        FileAttributes != 0 ||
        RxContext->MajorFunction != IRP_MJ_SET_INFORMATION ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN) ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ||
        (pLastWriteTime->QuadPart == 0 && pLastAccessTime->QuadPart == 0 && pCreationTime->QuadPart == 0)) {
        
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION,
                                    SMB_REQUEST_SIZE(SET_INFORMATION),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa before stuffing",StufferState);

        //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
        //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
        MRxSmbStuffSMB (StufferState,
             "0wdwwwwwB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 8
                    SmbAttributes,      //  w         _USHORT( FileAttributes );
                    LastWriteTime,      //  d         _ULONG( LastWriteTimeInSeconds );
                    0,0,0,0,0,          //  5*w       _USHORT( Reserved )[5];             // Reserved (must be 0)
                    SMB_WCT_CHECK(8)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );


        MRxSmbDumpStufferState (700,"SMB w/ sfa after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA);
    } else {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION2,
                                    SMB_REQUEST_SIZE(SET_INFORMATION2),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa 2 before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wwwwwwwB!",
                                               //  0         UCHAR WordCount;                    // Count of parameter words = 8
             smbSrvOpen->Fid,                  //  w         _USHORT( Fid );                     // File handle
             SmbCreationDate.Ushort,           //  w         SMB_TIME CreationDate;
             SmbCreationTime.Ushort,           //  w         SMB_TIME CreationTime;
             SmbLastAccessDate.Ushort,         //  w         SMB_TIME LastAccessDate;
             SmbLastAccessTime.Ushort,         //  w         SMB_TIME LastAccessTime;
             SmbLastWriteDate.Ushort,          //  w         SMB_TIME LastWriteDate;
             SmbLastWriteTime.Ushort,          //  w         SMB_TIME LastWriteTime;
             SMB_WCT_CHECK(7) 0                //            _USHORT( ByteCount );               // Count of data bytes; min = 0
                                               //            UCHAR Buffer[1];                    // Reserved buffer
             );


        MRxSmbDumpStufferState (700,"SMB w/ sfa 2 after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA2);
    }

    if (Status == STATUS_SUCCESS) {
        if (RxContext->MajorFunction != IRP_MJ_SET_INFORMATION) {
            FileAttributes = MRxSmbMapSmbAttributes((USHORT)SmbAttributes);
        }

        MRxSmbUpdateBasicFileInfoCache(RxContext,
                                       FileAttributes,
                                       pLastWriteTime);

        MRxSmbUpdateStandardFileInfoCache(RxContext,
                                          NULL,
                                          (BOOLEAN)(FileAttributes & FILE_ATTRIBUTE_DIRECTORY));

        MRxSmbInvalidateFileNotFoundCache(RxContext);
    

    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);
        }

        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);
    
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSFAAfterCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreateDirectory entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CREATE_DIRECTORY,
                                SMB_REQUEST_SIZE(CREATE_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ corecreatedir before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    MRxSmbStuffSMB (StufferState,
         "0B4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
                SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreatedir after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATEDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    )
/*++

Routine Description:

   This routine does a core create.....if the flag is set we use create new.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                (UCHAR)(CreateNew?SMB_COM_CREATE_NEW:SMB_COM_CREATE),
                                SMB_REQUEST_SIZE(CREATE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    MRxSmbStuffSMB (StufferState,
         "0wdB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                Attribute,          //  w         _USHORT( FileAttributes );          // New file attributes
                0,                  //  d         _ULONG( CreationTimeInSeconds );        // Creation time
                SMB_WCT_CHECK(3)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a close.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCloseAfterCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ closeaftercorecreate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                                    //  w         _USHORT( Fid );                     // File handle
             OrdinaryExchange->Create.FidReturnedFromCreate,
             0,                     //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );


    MRxSmbDumpStufferState (700,"SMB w/ closeaftercorecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CLOSEAFTERCORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCloseAfterCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    )
/*++

Routine Description:

   This routine does a truncate to implement FILE_OVERWRITE and FILE_OVERWRITE_IF.....
   it is also used in the "extend-for-cached-write" path.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreTruncate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_WRITE,
                                SMB_REQUEST_SIZE(WRITE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0  STUFFERTRACE(Dbg,'FC'))
                 )

    MRxSmbDumpStufferState (1100,"SMB w/ coretruncate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwdwByw!",
                                    //  0   UCHAR WordCount;                    // Count of parameter words = 5
             Fid,                   //  w   _USHORT( Fid );                     // File handle
             0,                     //  w   _USHORT( Count );                   // Number of bytes to be written
             FileTruncationPoint,   //  d   _ULONG( Offset );                   // Offset in file to begin write
             0,                     //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
             SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                    //      //UCHAR Buffer[1];                  // Buffer containing:
             0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
             0                      //  w     _USHORT( DataLength );            //  Length of data
                                    //        ULONG Buffer[1];                  //  Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ coretruncate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORETRUNCATE
                                    );

    if (Status == STATUS_SUCCESS) {
        LARGE_INTEGER FileSize;

        FileSize.HighPart = 0;
        FileSize.LowPart = FileTruncationPoint;

        MRxSmbUpdateFileInfoCacheFileSize(RxContext, &FileSize);
    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);

        }

        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);

    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreTruncate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine implements downlevel creates.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    For core, in particular, this is pretty painful because a different smb must be used
    for different dispositions. In addition, we cannot really open a directory.

    By in large, we will follow a strategy similar to rdr1. If the openmode maps into something that
    a downlevel server won't understand then we don't really open the file.....we just do a GFA to ensure
    that it's there and hope that we can do path-based ops for the duration.

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);

    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    ULONG CreateOptions = cp->CreateOptions;
    ULONG FileAttributes =  cp->FileAttributes;
    ACCESS_MASK   DesiredAccess = cp->DesiredAccess;
    USHORT        ShareAccess = (USHORT)(cp->ShareAccess);
    ULONG         Disposition = cp->Disposition;

    USHORT mappedDisposition = MRxSmbMapDisposition(Disposition);
    USHORT mappedSharingMode = MRxSmbMapShareAccess(ShareAccess);
    USHORT mappedAttributes  = MRxSmbMapFileAttributes(FileAttributes);
    USHORT mappedOpenMode    = MRxSmbMapDesiredAccess(DesiredAccess);

    LARGE_INTEGER AllocationSize = cp->AllocationSize;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    BOOLEAN MustBeAFile = (MustBeFile(CreateOptions)!=0);
    BOOLEAN MustBeADirectory = (MustBeDirectory(CreateOptions)!=0)
                                    || BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH);
    BOOLEAN ItsADirectory = FALSE;
    BOOLEAN ItsTheShareRoot = FALSE;

    PAGED_CODE();
    
    // Down level protocols don't have the execute mode.
    if (mappedOpenMode == (USHORT)SMB_DA_ACCESS_EXECUTE)
        mappedOpenMode = (USHORT)SMB_DA_ACCESS_READ;

    RxDbgTrace(+1, Dbg, ("MRxSmbDownlevelCreate entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, ("mapAtt,Shr,Disp,OM %04lx,%04lx,%04lx,%04lx\n",
                                  mappedAttributes,mappedSharingMode,mappedDisposition,mappedOpenMode));

    SmbPseOEAssertConsistentLinkageFromOE("Downlevel Create:");

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (OrdinaryExchange->Create.CreateWithEasSidsOrLongName) {
        Status = RX_MAP_STATUS(NOT_SUPPORTED);
        goto FINALLY;
    }

    if (AllocationSize.HighPart != 0) {
        //CODE.IMPROVEMENT why is the above a not-supported while this is a invalid-param??? joejoe
        Status = RX_MAP_STATUS(INVALID_PARAMETER);
        goto FINALLY;
    }


    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    OrdinaryExchange->Create.smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    OrdinaryExchange->pPathArgument1 = PathName;

    //
    // we know that the root a share exists and that it's a directory....the catch is that GetFileAttributes
    // will return a NO_SUCH_FILE error for the root if it's really a root on the server. record this and use it
    // to our advantage later.
    if ((PathName->Length == 0)
           || ((PathName->Length == sizeof(WCHAR)) && (PathName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR))  ) {
        //if must be a file, it's an error.........
        if (MustBeAFile) {
            Status = RX_MAP_STATUS(FILE_IS_A_DIRECTORY);
            goto FINALLY;
        }

        //
        //if it's the right kind of open, i can just finish up now. these opens are common for GetFSInfo

        if ((Disposition == FILE_OPEN) || (Disposition == FILE_OPEN_IF)) {
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            goto FINALLY;
        }
        MustBeADirectory = TRUE;   // we know it's a directory!
        ItsTheShareRoot = TRUE;
    }

    //// if all the user wants is attributes and it's a FILE_OPEN, don't do the open now....
    //// rather, we'll send pathbased ops later (or do a deferred open if necessary)...
    
    if (Disposition == FILE_OPEN && 
        (MustBeADirectory || 
         !(cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)))) {
        Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(OrdinaryExchange, MustBeADirectory?FileTypeDirectory:FileTypeFile);
        
        if (Status == STATUS_SUCCESS) {
            Status = MRxSmbQueryFileInformationFromPseudoOpen(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         FileBasicInformation);

            if (Status == STATUS_SUCCESS) {
                if (MustBeADirectory && 
                    !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_NOT_A_DIRECTORY;
                }

                if (MustBeAFile &&
                    OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                }
            }

            if (Status != STATUS_SUCCESS) {
                RxFreePool(smbSrvOpen->DeferredOpenContext);
                smbSrvOpen->DeferredOpenContext = NULL;
            }
        }

        goto FINALLY;
    }

    if ( (mappedOpenMode == ((USHORT)-1)) ||
         (Disposition == FILE_SUPERSEDE) ||
         (!MustBeAFile)
       ) {

        //
        // go find out what's there.......

        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

        if (Status == STATUS_SUCCESS && 
            MustBeADirectory &&
            !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
            Status = STATUS_NOT_A_DIRECTORY;
            goto FINALLY;
        }
        
        RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate GFAorCPstatus=%08lx\n",Status));

        if (NT_SUCCESS(Status)) {
            ULONG Attributes = SmbGetUshort(&OrdinaryExchange->Create.FileInfo.Basic.FileAttributes);
            ItsADirectory = BooleanFlagOn(Attributes,SMB_FILE_ATTRIBUTE_DIRECTORY);
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate attributes=%08lx\n",Attributes));
            if ((Disposition==FILE_CREATE)) {
                Status = STATUS_OBJECT_NAME_COLLISION;
                goto FINALLY;
            }
            if (MustBeADirectory && !ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_OBJECT_NAME_COLLISION;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            if (MustBeAFile && ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            //if (!MustBeAFile && ItsADirectory && (Disposition==FILE_OPEN)){
            if (Disposition==FILE_OPEN || Disposition==FILE_OPEN_IF){
                //we're done except to finish AND to set the flags in the srvopen
                MRxSmbPseudoOpenTailFromGFAResponse ( OrdinaryExchange );
                goto FINALLY;
            }
        } else if ( (Status!=STATUS_NO_SUCH_FILE)
                           && (Status!=STATUS_OBJECT_PATH_NOT_FOUND) ) {
            goto FINALLY;
        } else if ((Disposition==FILE_CREATE)
                     || (Disposition==FILE_OPEN_IF)
                     || (Disposition==FILE_OVERWRITE_IF)
                     || (Disposition==FILE_SUPERSEDE)) {
            //CODE.IMPROVEMENT doing this with four compares is ineficient; we should have a
            //                 table or something
            NOTHING;
        } else if (ItsTheShareRoot) {
            PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
            //here we have run into a true root....so we can't get attributes. fill in a fake
            //response and finish. also, flip the bit that says we can't gfa this guy.
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_CANT_GETATTRIBS;
            goto FINALLY;
        } else {
            goto FINALLY;
        }
    }


    SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!

    if (NT_SUCCESS(Status) &&(Disposition == FILE_SUPERSEDE)) {
        //
        //we have to get rid of the existing entity...using a delete or a rmdir as appropriate
        Status = MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      OrdinaryExchange->Create.FileInfo.Standard.Directory
                                                     );
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate could notsupersede st=%08lx\n",Status));
            goto FINALLY;
        }
        SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
                                                                   //CODE.IMPROVEMENT there should be some way
                                                                   //that is more automatic than this
    }

    if (MustBeADirectory || (ItsADirectory &&(Disposition == FILE_SUPERSEDE)) ) {

        ASSERT (Disposition!=FILE_OPEN);
        Status = MRxSmbCoreCreateDirectory(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't mkdir st=%08lx\n",Status));
            goto FINALLY;
        }

        if ((mappedAttributes &
             (SMB_FILE_ATTRIBUTE_READONLY |
              SMB_FILE_ATTRIBUTE_HIDDEN   |
              SMB_FILE_ATTRIBUTE_SYSTEM   |
              SMB_FILE_ATTRIBUTE_ARCHIVE)) != 0) {
            //
            //we have to set the attributes
            Status = MRxSmbSetFileAttributes(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         mappedAttributes);

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't sfa st=%08lx\n",Status));
            }
        }

        MRxSmbPseudoOpenTailFromCoreCreateDirectory( OrdinaryExchange, mappedAttributes );

        goto FINALLY;
    }


    //if ( (mappedOpenMode != -1) && !MustBeADirectory) {
    //no pseudoOpens yet
    if ( TRUE ) {

        ULONG workingDisposition = Disposition;
        ULONG iterationcount;
        BOOLEAN MayNeedATruncate = FALSE;

       //
       // we use the disposition as a state and case out.....some are hard and some are easy
       //     for example, if it's CREATE then we use the CREATE_NEW to create the file but
       //                  the resulting open is no good so we close it and open it again using the
       //                  open. for OPEN_IF  we assume that the file will be there
       //                  and drop into create if it's not.

       for (iterationcount=0;;iterationcount++) {
           switch (workingDisposition) {
           case FILE_OVERWRITE:
           case FILE_OVERWRITE_IF:
               MayNeedATruncate = TRUE;
               //lack of break intentional
           case FILE_OPEN_IF:
           case FILE_OPEN:
               Status = MRxSmbCoreOpen(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedOpenMode|mappedSharingMode,
                                           mappedAttributes);
               //if (Status==RxStatus(NO_SUCH_FILE)) {
               //    DbgPrint("%08lx %08lx %08lx\n",Status,workingDisposition,iterationcount);
               //    DbgBreakPoint();
               //}
               if (!((workingDisposition == FILE_OPEN_IF) || (workingDisposition == FILE_OVERWRITE_IF))
                    || (Status!=RX_MAP_STATUS(NO_SUCH_FILE))
                    || (iterationcount>6)
                    )break;
               SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
           case FILE_SUPERSEDE:
           case FILE_CREATE:
               Status = MRxSmbCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedAttributes,TRUE); //(workingDisposition==FILE_CREATE));
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......createnew failed st=%08lx\n",Status));
                    break;
               }

               //now, we have a network handle. BUT, it's a compatibility-mode open. since we don't want that we
               //     need to close and reopen with the parameters specified. there is a window here! what can i do??

               Status = MRxSmbCloseAfterCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......closeaftercreatenew failed st=%08lx\n",Status));
                    break;
               }

               workingDisposition = FILE_OPEN_IF;
               continue;     // this wraps back to the switch with a new disposition
               //break;
           //case FILE_SUPERSEDE:
           //    Status = RxStatus(NOT_SUPPORTED);
           //    break;
           default :
               ASSERT(!"Bad Disposition");
               Status = RX_MAP_STATUS(INVALID_PARAMETER);
           }
           break; //exit the loop
       }
       if (!NT_SUCCESS(Status))goto FINALLY;
       //we may need a truncate....this is different from rdr1.
       if (MayNeedATruncate
                 && !OrdinaryExchange->Create.FileWasCreated
                 && (OrdinaryExchange->Create.FileSizeReturnedFromOpen!=0)  ) {
           Status = MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                       OrdinaryExchange->Create.FidReturnedFromOpen,
                                       0
           );
       }
        
       goto FINALLY;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishGFA (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PBYTE                       Response
      )
/*++

Routine Description:

    This routine copies the response to the GetFileAttributes SMB. But, it must be called synchronously.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    what we do here is to put the data into the ordinary exchange...it's locked down do
    we could do this at DPC level

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    PSMB_PARAMS pSmbParams = (PSMB_PARAMS)Response;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishGFA\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishGFA:");

    if (pSmbParams->WordCount == 10) {
        PRESP_QUERY_INFORMATION pQueryInformationResponse;

        pQueryInformationResponse = (PRESP_QUERY_INFORMATION)Response;

        //what we do here is to put the data into the ordinary exchange...it's locked down do
        //we wcould do this at DPC level

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformationResponse->FileAttributes),
            SmbGetUlong(&pQueryInformationResponse->LastWriteTimeInSeconds),
            SmbGetUlong(&pQueryInformationResponse->FileSize)
            );

    } else if (pSmbParams->WordCount == 11) {
        PRESP_QUERY_INFORMATION2 pQueryInformation2Response;
        SMB_TIME                 LastWriteSmbTime;
        SMB_DATE                 LastWriteSmbDate;
        LARGE_INTEGER            LastWriteTime;
        ULONG                    LastWriteTimeInSeconds;

        pQueryInformation2Response = (PRESP_QUERY_INFORMATION2)Response;

        RtlCopyMemory(
            &LastWriteSmbTime,
            &pQueryInformation2Response->LastWriteTime,
            sizeof(SMB_TIME));

        RtlCopyMemory(
            &LastWriteSmbDate,
            &pQueryInformation2Response->LastWriteDate,
            sizeof(SMB_DATE));

        LastWriteTime = MRxSmbConvertSmbTimeToTime(NULL,LastWriteSmbTime,LastWriteSmbDate);

        MRxSmbTimeToSecondsSince1970(
            &LastWriteTime,
            NULL,
            &LastWriteTimeInSeconds);

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformation2Response->FileAttributes),
            LastWriteTimeInSeconds,
            SmbGetUlong(&pQueryInformation2Response->FileDataSize)
            );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishGFA   returning %08lx\n", Status ));
    return Status;
}

//CODE.IMPROVEMENT shouldn't this be in a .h file.....
NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    SMBFCB_HOLDING_STATE *SmbFcbHoldingState,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      )
/*++

Routine Description:

    This routine copies the fid from a core create response. it does not finish the fcb......if a compatibility
    mode open is acceptable then it could.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreate\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreate:");

    if (Response->WordCount != 1 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        OrdinaryExchange->Create.FidReturnedFromCreate = SmbGetUshort(&Response->Fid);
        OrdinaryExchange->Create.FileWasCreated = TRUE;
        //notice that we didn't finish here! we should IFF a compatibilty-mode open is okay
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreate   returning %08lx\n", Status ));
    return Status;
}

#define JUST_USE_THE_STUFF_IN_THE_OE (0xfbad)
VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    )
{
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    BasicInformation->FileAttributes = MRxSmbMapSmbAttributes(FileAttributes);
    StandardInformation->NumberOfLinks = 1;
    BasicInformation->CreationTime.QuadPart = 0;
    BasicInformation->LastAccessTime.QuadPart = 0;
    MRxSmbSecondsSince1970ToTime(LastWriteTimeInSeconds,
                                 SmbCeGetExchangeServer(OrdinaryExchange),
                                 &BasicInformation->LastWriteTime);
    BasicInformation->ChangeTime.QuadPart = 0;
    StandardInformation->AllocationSize.QuadPart = FileSize; //rdr1 actually rounds up based of svr disk attribs
    StandardInformation->EndOfFile.QuadPart = FileSize;
    StandardInformation->Directory = BooleanFlagOn(BasicInformation->FileAttributes,FILE_ATTRIBUTE_DIRECTORY);
}


NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      )
/*++

Routine Description:

    This routine finishes a core open.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    ULONG FileSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreOpen\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreOpen:");

    if (Response->WordCount != 7 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    StorageType = FileTypeFile;
    Fid = SmbGetUshort(&Response->Fid);
    OrdinaryExchange->Create.FidReturnedFromOpen = Fid;
    FileSize = OrdinaryExchange->Create.FileSizeReturnedFromOpen = SmbGetUlong(&Response->DataSize);

    CreateAction = (OrdinaryExchange->Create.FileWasCreated)?FILE_CREATED
                        : (OrdinaryExchange->Create.FileWasTruncated)?FILE_OVERWRITTEN
                        :FILE_OPENED;

    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        SmbGetUshort(&Response->FileAttributes),
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        FileSize
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = FALSE;

    //CODE.IMPROVEMENT we could save a bit of stack space by wrapping a struc around the args below....
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    &OrdinaryExchange->SmbFcbHoldingState,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

FINALLY:
    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreOpen   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      )
/*++

Routine Description:

    This routine finishes a core create directory. but, it is not called from the receive routine......

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreateDirectory\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreateDirectory:");

    StorageType = FileTypeDirectory;
    Fid = 0xbadd;

    CreateAction = FILE_CREATED;
    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        Attributes,
        0,
        0
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = TRUE;

    //CODE.IMPROVEMENT we could save a bit of stack space by wrapping a struc around the args below....
    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    &OrdinaryExchange->SmbFcbHoldingState,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreateDirectory   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from faked up information. Basically, we fill in
    the information that would have been obtained on a GET_FILE_ATTRIBUTES smb and then call
    the PseudoOpenFromGFA routine

Arguments:

    OrdinaryExchange - the exchange instance
    StorageType - the type of thing that this is supposed to be. If it's supposed to be
                  a directory then we set the attributes bit in the GFA info.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    USHORT Attributes = 0;

    PAGED_CODE();

    RtlZeroMemory(
        &OrdinaryExchange->Create.FileInfo,
        sizeof(OrdinaryExchange->Create.FileInfo));

    if (StorageType == FileTypeDirectory) {
        Attributes = SMB_FILE_ATTRIBUTE_DIRECTORY;
    }

    MRxSmbPopulateFileInfoInOE(OrdinaryExchange,Attributes,0,0);
    OrdinaryExchange->Create.StorageTypeFromGFA = StorageType;

    return( MRxSmbPseudoOpenTailFromGFAResponse (OrdinaryExchange) );
}


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from the information obtained on a
    GET_FILE_ATTRIBUTES smb.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishPseudoOpenFromGFAResponse:");

    Fid = 0xbadd;

    CreateAction = FILE_OPENED;

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = (OrdinaryExchange->Create.StorageTypeFromGFA == FileTypeDirectory);

    //CODE.IMPROVEMENT we could save a bit of stack space by wrapping a struc around the args below....
    //  it seems to me that everything but the fid coudl be done that way and the success tail routine
    //  moved to the wrapper
    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    &OrdinaryExchange->SmbFcbHoldingState,
                                    OrdinaryExchange->Create.StorageTypeFromGFA,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    if (smbSrvOpen->DeferredOpenContext == NULL) {
        // if it is a remote boot server file, it already has a deferred open context created
        // on MRxSmbCreateFileSuccessTail
        Status = MRxSmbConstructDeferredOpenContext(RxContext);
    } else {
        // The flag has been cleared when a deferred open context was created for a remote boot server file.
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
    }

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse construct dfo failed %08lx \n",Status));
    }

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    PAGED_CODE();

    //
    // This routine cannot be paged because it is called from both the
    // MRxSmbFileDiscardableSection and the MRxSmbVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

#ifndef WIN9X
        if (ARGUMENT_PRESENT(Server)) {
            OutputTime.QuadPart = OutputTime.QuadPart + Server->TimeZoneBias.QuadPart;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
#else
        OutputTime.HighPart = 0;
        OutputTime.LowPart = 0;
#endif

    }

    return OutputTime;

}

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an NT time structure to an SMB time.

Arguments:

    IN LARGE_INTEGER InputTime - Supplies the time to convert.
    OUT PSMB_TIME Time - Returns the converted time of day.
    OUT PSMB_DATE Date - Returns the converted day of the year.


Return Value:

    BOOLEAN - TRUE if input time could be converted.


--*/

{
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    if (InputTime->LowPart == 0 && InputTime->HighPart == 0) {
        Time->Ushort = Date->Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(InputTime, &LocalTime);

        if (ARGUMENT_PRESENT(Exchange)) {
            PSMBCE_SERVER Server = SmbCeGetExchangeServer(Exchange);
            LocalTime.QuadPart -= Server->TimeZoneBias.QuadPart;
        }

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        if (TimeFields.Year < 1980) {
            return FALSE;
        }

        Date->Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date->Struct.Month = TimeFields.Month;
        Date->Struct.Day = TimeFields.Day;

        Time->Struct.Hours = TimeFields.Hour;
        Time->Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time->Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    return TRUE;
}


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    )
/*++

Routine Description:

    This routine returns the CurrentTime in UTC and returns the
    equivalent current time in the servers timezone.


Arguments:

    IN PLARGE_INTEGER CurrentTime - Supplies the current system time in UTC.

    IN PSMBCE_SERVER Server       - Supplies the difference in timezones between
                                    the server and the workstation. If not supplied
                                    then the assumption is that they are in the
                                    same timezone.

    OUT PULONG SecondsSince1970   - Returns the # of seconds since 1970 in
                                    the servers timezone or MAXULONG if conversion
                                    fails.

Return Value:

    BOOLEAN - TRUE if the time could be converted.

--*/
{
    LARGE_INTEGER ServerTime;
    LARGE_INTEGER TempTime;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(Server) &&
        ((*CurrentTime).QuadPart != 0)) {

        TempTime.QuadPart = (*CurrentTime).QuadPart - Server->TimeZoneBias.QuadPart;

        ExSystemTimeToLocalTime(&TempTime, &ServerTime);
    } else {
        ExSystemTimeToLocalTime(CurrentTime, &ServerTime);
    }

    ReturnValue = RtlTimeToSecondsSince1970(&ServerTime, SecondsSince1970);

    if ( ReturnValue == FALSE ) {
        //
        //  We can't represent the time legally, peg it at
        //  the max legal time.
        //

        *SecondsSince1970 = MAXULONG;
    }

    return ReturnValue;
}

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    )
/*++

Routine Description:

    This routine returns the Local system time derived from a time
    in seconds in the servers timezone.


Arguments:

    IN ULONG SecondsSince1970 - Supplies the # of seconds since 1970 in
                                servers timezone.

    IN PSMB_EXCHANGE Exchange - Supplies the difference in timezones between
                                the server and the workstation. If not supplied
                                then the assumption is that they are in the
                                same timezone.

    OUT PLARGE_INTEGER CurrentTime - Returns the current system time in UTC.

Return Value:

    None.


--*/

{
    LARGE_INTEGER LocalTime;

    PAGED_CODE();

    RtlSecondsSince1970ToTime (SecondsSince1970, &LocalTime);

    ExLocalTimeToSystemTime(&LocalTime, CurrentTime);

    if (ARGUMENT_PRESENT(Server)) {
        (*CurrentTime).QuadPart = (*CurrentTime).QuadPart + Server->TimeZoneBias.QuadPart;
    }

    return;

}

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    )

/*++

Routine Description:

    This routine maps an SMB (DOS/OS2) file attribute into an NT
    file attribute.


Arguments:

    IN USHORT SmbAttribs - Supplies the SMB attribute to map.


Return Value:

    ULONG - NT Attribute mapping SMB attribute


--*/

{
    ULONG Attributes = 0;

    PAGED_CODE();

    if (SmbAttribs==0) {
        Attributes = FILE_ATTRIBUTE_NORMAL;
    } else {

        ASSERT (SMB_FILE_ATTRIBUTE_READONLY == FILE_ATTRIBUTE_READONLY);
        ASSERT (SMB_FILE_ATTRIBUTE_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
        ASSERT (SMB_FILE_ATTRIBUTE_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
        ASSERT (SMB_FILE_ATTRIBUTE_ARCHIVE == FILE_ATTRIBUTE_ARCHIVE);
        ASSERT (SMB_FILE_ATTRIBUTE_DIRECTORY == FILE_ATTRIBUTE_DIRECTORY);

        Attributes = SmbAttribs & FILE_ATTRIBUTE_VALID_FLAGS;
    }
    return Attributes;
}

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    )

/*++

Routine Description:

    This routine takes an NT disposition, and maps it into an OS/2
    CreateAction to be put into an SMB.


Arguments:

    IN ULONG Disposition - Supplies the NT disposition to map.


Return Value:

    USHORT - OS/2 Access mapping that maps NT access

--*/

{
    PAGED_CODE();

    switch (Disposition) {
    case FILE_OVERWRITE_IF:
    case FILE_SUPERSEDE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_CREATE:
        return SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_OVERWRITE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN_IF:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_CREATE;
        break;

    default:
        //InternalError(("Unknown disposition passed to MRxSmbMapDisposition"));
        //MRxSmbInternalError(EVENT_RDR_DISPOSITION);
        return 0;
        break;
    }
}


ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    ULONG     Disposition
    )

/*++

Routine Description:

    This routine takes an OS/2 disposition and maps it into an NT
    disposition.

Arguments:

    IN USHORT SmbDisposition - Supplies the OS/2 disposition to map.

Return Value:

    ULONG - NT disposition mapping OS/2 disposition

--*/

{
    ULONG MapDisposition;

    PAGED_CODE();

    //
    //  Mask off oplocked bit.
    //

    switch (SmbDisposition & 0x7fff) {

    case SMB_OACT_OPENED:
        MapDisposition = FILE_OPENED;
        break;

    case SMB_OACT_CREATED:
        MapDisposition = FILE_CREATED;
        break;

    case SMB_OACT_TRUNCATED:
        MapDisposition = FILE_OVERWRITTEN;
        break;

    default:
        MapDisposition = Disposition;
    }

    return MapDisposition;
}


USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    )

/*++

Routine Description:

    This routine takes an NT DesiredAccess value and converts it
    to an OS/2 access mode.


Arguments:

    IN ULONG DesiredAccess - Supplies the NT desired access to map.

Return Value:

    USHORT - The mapped OS/2 access mode that compares to the NT code
        specified.  If there is no mapping for the NT code, we return
        -1 as the access mode.

--*/

{
    PAGED_CODE();

    //
    //  If the user asked for both read and write access, return read/write.
    //

    if ((DesiredAccess & FILE_READ_DATA)&&(DesiredAccess & FILE_WRITE_DATA)) {
        return SMB_DA_ACCESS_READ_WRITE;
    }

    //
    //  If the user requested WRITE_DATA, return write.
    //

    if (DesiredAccess & FILE_WRITE_DATA) {
        return SMB_DA_ACCESS_WRITE;
    }

    //
    //  If the user requested READ_DATA, return read.
    //
    if (DesiredAccess & FILE_READ_DATA) {
        return SMB_DA_ACCESS_READ;
    }

    //
    //  If the user requested ONLY execute access, then request execute
    //  access.  Execute access is the "weakest" of the possible desired
    //  accesses, so it takes least precedence.
    //

    if (DesiredAccess & FILE_EXECUTE) {
        return  SMB_DA_ACCESS_EXECUTE;
    }

    //
    //  If we couldn't figure out what we were doing, return -1
    //
    //  Among the attributes that we do not map are:
    //
    //          FILE_READ_ATTRIBUTES
    //          FILE_WRITE_ATTRIBUTES
    //          FILE_READ_EAS
    //          FILE_WRITE_EAS
    //

//    dprintf(DPRT_ERROR, ("Could not map DesiredAccess of %08lx\n", DesiredAccess));

    return (USHORT)0;
}

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine takes an NT ShareAccess value and converts it to an
    OS/2 sharing mode.


Arguments:

    IN USHORT ShareAccess - Supplies the OS/2 share access to map.

Return Value:

    USHORT - The mapped OS/2 sharing mode that compares to the NT code
        specified

--*/

{
    USHORT ShareMode =  SMB_DA_SHARE_EXCLUSIVE;

    PAGED_CODE();

    if ((ShareAccess & (FILE_SHARE_READ | FILE_SHARE_WRITE)) ==
                       (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        ShareMode = SMB_DA_SHARE_DENY_NONE;
    } else if (ShareAccess & FILE_SHARE_READ) {
        ShareMode = SMB_DA_SHARE_DENY_WRITE;
    } else if (ShareAccess & FILE_SHARE_WRITE) {
        ShareMode = SMB_DA_SHARE_DENY_READ;
    }

//    else if (ShareAccess & FILE_SHARE_DELETE) {
//      InternalError(("Support for FILE_SHARE_DELETE NYI\n"));
//    }

    return ShareMode;

}

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    )

/*++

Routine Description:

    This routine takes an NT file attribute mapping and converts it into
    an OS/2 file attribute definition.


Arguments:

    IN ULONG FileAttributes - Supplies the file attributes to map.


Return Value:

USHORT

--*/

{
    USHORT ResultingAttributes = 0;

    PAGED_CODE();

    if (FileAttributes==FILE_ATTRIBUTE_NORMAL) {
        return ResultingAttributes;
    }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_READONLY;
    }

    if (FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_HIDDEN;
    }

    if (FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_SYSTEM;
    }
    if (FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_ARCHIVE;
    }
    return ResultingAttributes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the mini redirector call down routines pertaining to query/set ea/security.

Author:

    joelinn      [joelinn]      12-jul-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Forward declarations.
//

#if defined(REMOTE_BOOT)
VOID
MRxSmbInitializeExtraAceArray(
    VOID
    );

BOOLEAN
MRxSmbAclHasExtraAces(
    IN PACL Acl
    );

NTSTATUS
MRxSmbRemoveExtraAcesFromSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR OriginalSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
    OUT PBOOLEAN WereRemoved
    );

NTSTATUS
MRxSmbAddExtraAcesToSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR OriginalSecurityDescriptor,
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    );

NTSTATUS
MRxSmbCreateExtraAcesSelfRelativeSD(
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    );

NTSTATUS
MRxSmbSelfRelativeToAbsoluteSD(
    IN PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * AbsoluteSecurityDescriptor,
    OUT PACL * Dacl,
    OUT PACL * Sacl,
    OUT PSID * Owner,
    OUT PSID * Group
    );

NTSTATUS
MRxSmbAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR * SelfRelativeSecurityDescriptor
    );

//
// Definitions from ntrtl.h
//

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    PULONG BufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PULONG AbsoluteSecurityDescriptorSize,
    PACL Dacl,
    PULONG DaclSize,
    PACL Sacl,
    PULONG SaclSize,
    PSID Owner,
    PULONG OwnerSize,
    PSID PrimaryGroup,
    PULONG PrimaryGroupSize
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce (
    PACL Acl,
    ULONG AceRevision,
    ULONG StartingAceIndex,
    PVOID AceList,
    ULONG AceListLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce (
    PACL Acl,
    ULONG AceIndex
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce (
    PACL Acl,
    ULONG AceIndex,
    PVOID *Ace
    );
#endif // defined(REMOTE_BOOT)


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbQueryEaInformation)
#pragma alloc_text(PAGE, MRxSmbSetEaInformation)
#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, MRxSmbInitializeExtraAceArray)
#pragma alloc_text(PAGE, MRxSmbAclHasExtraAces)
#pragma alloc_text(PAGE, MRxSmbRemoveExtraAcesFromSelfRelativeSD)
#pragma alloc_text(PAGE, MRxSmbAddExtraAcesToSelfRelativeSD)
#pragma alloc_text(PAGE, MRxSmbSelfRelativeToAbsoluteSD)
#pragma alloc_text(PAGE, MRxSmbAbsoluteToSelfRelativeSD)
#endif // defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, MRxSmbQuerySecurityInformation)
#pragma alloc_text(PAGE, MRxSmbSetSecurityInformation)
#pragma alloc_text(PAGE, MRxSmbLoadEaList)
#pragma alloc_text(PAGE, MRxSmbNtGeaListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtGetEaToOs2)
#pragma alloc_text(PAGE, MRxSmbQueryEasFromServer)
#pragma alloc_text(PAGE, MRxSmbNtFullEaSizeToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullEaToOs2)
#pragma alloc_text(PAGE, MRxSmbSetEaList)
#endif

////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//this is the largest EAs that could ever be returned! oh my god!
//this is used to simulate the nt resumable queryEA using the downlevel call
//sigh!
#define EA_QUERY_SIZE 0x0000ffff

#if defined(REMOTE_BOOT)
//
// ACEs that are added to the front of server ACLs. The array is
// initialized by MRxSmbInitializeExtraAceArray.
//

typedef struct _EXTRA_ACE_INFO {
    UCHAR AceType;
    UCHAR AceFlags;
    USHORT AceSize;
    ACCESS_MASK Mask;
    PVOID Sid;
} EXTRA_ACE_INFO, *PEXTRA_ACE_INFO;

#define EXTRA_ACE_INFO_COUNT  4
EXTRA_ACE_INFO ExtraAceInfo[EXTRA_ACE_INFO_COUNT];
ULONG ExtraAceInfoCount;
#endif // defined(REMOTE_BOOT)


//for QueryEA
NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    );

NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    );

//for SetEA
NTSTATUS
MRxSmbSetEaList(
//    IN PICB Icb,
//    IN PIRP Irp,
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    );

VOID MRxSmbExtraEaRoutine(LONG i){
    RxDbgTrace( 0, Dbg, ("MRxSmbExtraEaRoutine i=%08lx\n", i ));
}

NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
    PUCHAR  UserEaList = RxContext->QueryEa.UserEaList;
    ULONG   UserEaListLength = RxContext->QueryEa.UserEaListLength;
    ULONG   UserEaIndex = RxContext->QueryEa.UserEaIndex;
    BOOLEAN RestartScan = RxContext->QueryEa.RestartScan;
    BOOLEAN ReturnSingleEntry = RxContext->QueryEa.ReturnSingleEntry;
    BOOLEAN IndexSpecified = RxContext->QueryEa.IndexSpecified;

    PFEALIST ServerEaList = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {
        return STATUS_ONLY_IF_CONNECTED;
    }


    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = MRxSmbLoadEaList( RxContext, UserEaList, UserEaListLength, &ServerEaList );

    if (( !NT_SUCCESS( Status ) )||
        ( ServerEaList == NULL )) {
        goto FINALLY;
    }

    if (IndexSpecified) {

        //CODE.IMPROVEMENT this name is poor....it owes back to the fastfat heritage and is not so meaningful
        //                 for a rdr
        capFobx->OffsetOfNextEaToReturn = UserEaIndex;
        Status = MRxSmbQueryEasFromServer(
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );

        //
        //  if there are no Ea's on the file, and the user supplied an EA
        //  index, we want to map the error to STATUS_NONEXISTANT_EA_ENTRY.
        //

        if ( Status == STATUS_NO_EAS_ON_FILE ) {
            Status = STATUS_NONEXISTENT_EA_ENTRY;
        }
    } else {

        if ( ( RestartScan == TRUE ) || (UserEaList != NULL) ){

            //
            // Ea Indices start at 1, not 0....
            //

            capFobx->OffsetOfNextEaToReturn = 1;
        }

        Status = MRxSmbQueryEasFromServer(  //it is offensive to have two identical calls but oh, well.....
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );
    }

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryEaInformation st=%08lx\n",Status));
    return Status;

}

NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    ULONG Length = RxContext->Info.Length;

    PFEALIST ServerEaList = NULL;
    ULONG Size;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {
        return     STATUS_ONLY_IF_CONNECTED;
    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    //
    //  Convert Nt format FEALIST to OS/2 format
    //
    Size = MRxSmbNtFullEaSizeToOs2 ( Buffer );
    if ( Size > 0x0000ffff ) {
        Status = STATUS_EA_TOO_LARGE;
        goto FINALLY;
    }

    //CODE.IMPROVEMENT since |os2eas|<=|nteas| we really don't need a maximum buffer
    ServerEaList = RxAllocatePool ( PagedPool, EA_QUERY_SIZE );
    if ( ServerEaList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    MRxSmbNtFullListToOs2 ( Buffer, ServerEaList );

    //
    //  Set EAs on the file/directory; if the error is EA_ERROR then SetEaList
    //     sets iostatus.information to the offset of the offender
    //

    Status = MRxSmbSetEaList( RxContext, ServerEaList);

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    if (Status == STATUS_SUCCESS) {
        // invalidate the name based file info cache since the attributes of the file on
        // the server have been changed
        MRxSmbInvalidateFileInfoCache(RxContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetEaInformation st=%08lx\n",Status));
    return Status;

}

#if DBG
VOID
MRxSmbDumpSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    PISECURITY_DESCRIPTOR sd = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
    ULONG sdLength = RtlLengthSecurityDescriptor(sd);
    PACL dacl;
    PACCESS_ALLOWED_ACE ace;
    ULONG i, j;
    PUCHAR p;
    PISID sid;
    BOOLEAN selfRelative;

    selfRelative = (BOOLEAN)((sd->Control & SE_SELF_RELATIVE) != 0);
    DbgPrint( "  SD:\n" );
    DbgPrint( "  Revision = %x, Control = %x\n", sd->Revision, sd->Control );
    DbgPrint( "  Owner = %x, Group = %x\n", sd->Owner, sd->Group );
    DbgPrint( "  Sacl = %x, Dacl = %x\n", sd->Sacl, sd->Dacl );
    if ( (sd->Control & SE_DACL_PRESENT) != 0 ) {
        dacl = sd->Dacl;
        if ( selfRelative ) {
            dacl = (PACL)((PUCHAR)sd + (ULONG_PTR)dacl);
        }
        DbgPrint( "  DACL:\n" );
        DbgPrint( "    AclRevision = %x, AclSize = %x, AceCount = %x\n",
                    dacl->AclRevision, dacl->AclSize, dacl->AceCount );
        ace = (PACCESS_ALLOWED_ACE)(dacl + 1);
        for ( i = 0; i < dacl->AceCount; i++ ) {
            DbgPrint( "    ACE %d:\n", i );
            DbgPrint( "      AceType = %x, AceFlags = %x, AceSize = %x\n",
                        ace->Header.AceType, ace->Header.AceFlags, ace->Header.AceSize );
            if ( ace->Header.AceType < ACCESS_MAX_MS_V2_ACE_TYPE ) {
                DbgPrint("      Mask = %08x, Sid = ", ace->Mask );
                for ( j = FIELD_OFFSET(ACCESS_ALLOWED_ACE,SidStart), p = (PUCHAR)&ace->SidStart;
                      j < ace->Header.AceSize;
                      j++, p++ ) {
                    DbgPrint( "%02x ", *p );
                }
                DbgPrint( "\n" );
            }
            ace = (PACCESS_ALLOWED_ACE)((PUCHAR)ace + ace->Header.AceSize );
        }
    }
    if ( sd->Owner != 0 ) {
        sid = sd->Owner;
        if ( selfRelative ) {
            sid = (PISID)((PUCHAR)sd + (ULONG_PTR)sid);
        }
        DbgPrint( "  Owner SID:\n" );
        DbgPrint( "    Revision = %x, SubAuthorityCount = %x\n",
                    sid->Revision, sid->SubAuthorityCount );
        DbgPrint( "    IdentifierAuthority = " );
        for ( j = 0; j < 6; j++ ) {
            DbgPrint( "%02x ", sid->IdentifierAuthority.Value[j] );
        }
        DbgPrint( "\n" );
        for ( i = 0; i < sid->SubAuthorityCount; i++ ) {
            DbgPrint("      SubAuthority %d = ", i );
            for ( j = 0, p = (PUCHAR)&sid->SubAuthority[i]; j < 4; j++, p++ ) {
                DbgPrint( "%02x ", *p );
            }
            DbgPrint( "\n" );
        }
    }
}
#endif

#if defined(REMOTE_BOOT)
VOID
MRxSmbInitializeExtraAceArray(
    VOID
    )
/*++

Routine Description:

    This routine initializes the array of extra ACEs that we add to
    the front of ACLs for files on the server. It must be called
    *after* SeEnableAccessToExports has been called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

    PAGED_CODE();

    //
    // Our code assumes the ACEs we use have the same structure.
    //

    ASSERT(FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) ==
           FIELD_OFFSET(ACCESS_DENIED_ACE, SidStart));

    ASSERT((sizeof(ExtraAceInfo) / sizeof(EXTRA_ACE_INFO)) == EXTRA_ACE_INFO_COUNT);
    ExtraAceInfoCount = EXTRA_ACE_INFO_COUNT;

    ExtraAceInfo[0].AceType = ACCESS_ALLOWED_ACE_TYPE;
    ExtraAceInfo[0].AceFlags = 0;
    ExtraAceInfo[0].Mask = FILE_ALL_ACCESS;
    ExtraAceInfo[0].Sid = MRxSmbRemoteBootMachineSid;

    ExtraAceInfo[1].AceType = ACCESS_ALLOWED_ACE_TYPE;
    ExtraAceInfo[1].AceFlags = 0;
    ExtraAceInfo[1].Mask = FILE_ALL_ACCESS;
    ExtraAceInfo[1].Sid = SeExports->SeLocalSystemSid;

    ExtraAceInfo[2].AceType = ACCESS_ALLOWED_ACE_TYPE;
    ExtraAceInfo[2].AceFlags = 0;
    ExtraAceInfo[2].Mask = FILE_ALL_ACCESS;
    ExtraAceInfo[2].Sid = SeExports->SeAliasAdminsSid;

    ExtraAceInfo[3].AceType = ACCESS_DENIED_ACE_TYPE;
    ExtraAceInfo[3].AceFlags = 0;
    ExtraAceInfo[3].Mask = FILE_ALL_ACCESS;
    ExtraAceInfo[3].Sid = SeExports->SeWorldSid;

    for (i = 0; i < ExtraAceInfoCount; i++) {
        ExtraAceInfo[i].AceSize = (USHORT)(FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) +
                                           RtlLengthSid((PSID)(ExtraAceInfo[i].Sid)));
    }

}

BOOLEAN
MRxSmbAclHasExtraAces(
    IN PACL Acl
    )
/*++

Routine Description:

    This routine determines if an ACL has the special ACEs that we
    put on the front for remote boot server files.

Arguments:

    Acl - The ACL to check.

Return Value:

    TRUE if the ACEs are there, FALSE otherwise (including if there
    are any errors while checking).

--*/
{
    PACCESS_ALLOWED_ACE Ace;
    ULONG KnownSidLength;
    ULONG i;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Make sure the first n ACEs in this ACL match those in our
    // array.
    //

    for (i = 0; i < ExtraAceInfoCount; i++) {

        Status = RtlGetAce(Acl, i, &Ace);

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        KnownSidLength = ExtraAceInfo[i].AceSize - FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart);

        //
        // Don't compare the flags to avoid worrying about inherited
        // flags.
        //

        if ((Ace->Header.AceType != ExtraAceInfo[i].AceType) ||
            // TMP: my server doesn't store 0x200 bit // (Ace->Mask != ExtraAceInfo[i].Mask) ||
            (RtlLengthSid((PSID)(&Ace->SidStart)) != KnownSidLength) ||
            (memcmp(&Ace->SidStart, ExtraAceInfo[i].Sid, KnownSidLength) != 0)) {

            return FALSE;
        }

    }

    //
    // Everything matched, so it does have the extra ACEs.
    //

    return TRUE;

}

NTSTATUS
MRxSmbSelfRelativeToAbsoluteSD(
    IN PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * AbsoluteSecurityDescriptor,
    OUT PACL * Dacl,
    OUT PACL * Sacl,
    OUT PSID * Owner,
    OUT PSID * Group
    )
/*++

Routine Description:

    This routine converts a self-relative security descriptor to
    absolute form, allocating all the entries needed.

Arguments:



Return Value:

    Status - Result of the operation.

--*/
{
    NTSTATUS Status;
    ULONG AbsoluteSecurityDescriptorSize = 0;
    ULONG GroupSize = 0;
    ULONG OwnerSize = 0;
    ULONG SaclSize = 0;
    ULONG DaclSize = 0;
    PUCHAR AllocatedBuffer;
    ULONG AllocatedBufferSize;

    PAGED_CODE();

    *AbsoluteSecurityDescriptor = NULL;
    *Owner = NULL;
    *Group = NULL;
    *Dacl = NULL;
    *Sacl = NULL;

    //
    // First determine how much storage is needed by the SD.
    //

    Status = RtlSelfRelativeToAbsoluteSD(
                 SelfRelativeSecurityDescriptor,
                 NULL,
                 &AbsoluteSecurityDescriptorSize,
                 NULL,
                 &DaclSize,
                 NULL,
                 &SaclSize,
                 NULL,
                 &OwnerSize,
                 NULL,
                 &GroupSize);

    //
    // We expect to get this error since at least the core of the SD
    // has some non-zero size.
    //

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        AllocatedBufferSize =
            AbsoluteSecurityDescriptorSize +
            OwnerSize +
            GroupSize +
            SaclSize +
            DaclSize;

        ASSERT(AllocatedBufferSize > 0);

        AllocatedBuffer = RxAllocatePoolWithTag(PagedPool, AllocatedBufferSize, MRXSMB_REMOTEBOOT_POOLTAG);

        if (AllocatedBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Walk through each piece of memory we need and take a chunk
        // of AllocatedBuffer. The caller assumes that AbsoluteSecurityDescriptor
        // will be the address of the buffer they need to free, so we always
        // set that even if the size needed is 0 (which should never happen!).
        // For the others we set them if the size needed is not NULL.
        //

        ASSERT(AbsoluteSecurityDescriptorSize > 0);

        *AbsoluteSecurityDescriptor = (PSECURITY_DESCRIPTOR)AllocatedBuffer;
        AllocatedBuffer += AbsoluteSecurityDescriptorSize;

        if (OwnerSize > 0) {
            *Owner = (PSID)AllocatedBuffer;
            AllocatedBuffer += OwnerSize;
        }

        if (GroupSize > 0) {
            *Group = (PSID)AllocatedBuffer;
            AllocatedBuffer += GroupSize;
        }

        if (SaclSize > 0) {
            *Sacl = (PACL)AllocatedBuffer;
            AllocatedBuffer += SaclSize;
        }

        if (DaclSize > 0) {
            *Dacl = (PACL)AllocatedBuffer;
        }

        //
        // Now make the call again to really do the conversion.
        //

        Status = RtlSelfRelativeToAbsoluteSD(
                     SelfRelativeSecurityDescriptor,
                     *AbsoluteSecurityDescriptor,
                     &AbsoluteSecurityDescriptorSize,
                     *Dacl,
                     &DaclSize,
                     *Sacl,
                     &SaclSize,
                     *Owner,
                     &OwnerSize,
                     *Group,
                     &GroupSize);

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

    if (!NT_SUCCESS(Status) && (*AbsoluteSecurityDescriptor != NULL)) {
        RxFreePool(*AbsoluteSecurityDescriptor);
        *AbsoluteSecurityDescriptor = NULL;
    }

    return Status;

}

NTSTATUS
MRxSmbAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR * SelfRelativeSecurityDescriptor
    )
/*++

Routine Description:

    This routine converts an absolute security descriptor to
    self-relative form, allocating all the entries needed.

Arguments:



Return Value:

    Status - Result of the operation.

--*/
{
    NTSTATUS Status;
    ULONG SelfRelativeSdSize = 0;

    PAGED_CODE();

    *SelfRelativeSecurityDescriptor = NULL;

    Status = RtlAbsoluteToSelfRelativeSD(
                 AbsoluteSecurityDescriptor,
                 NULL,
                 &SelfRelativeSdSize);

    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    *SelfRelativeSecurityDescriptor = RxAllocatePoolWithTag(NonPagedPool, SelfRelativeSdSize, MRXSMB_REMOTEBOOT_POOLTAG);
    if (*SelfRelativeSecurityDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now do the real conversion.
    //

    Status = RtlAbsoluteToSelfRelativeSD(
                 AbsoluteSecurityDescriptor,
                 *SelfRelativeSecurityDescriptor,
                 &SelfRelativeSdSize);

    if (!NT_SUCCESS(Status) && (*SelfRelativeSecurityDescriptor != NULL)) {
        RxFreePool(*SelfRelativeSecurityDescriptor);
        *SelfRelativeSecurityDescriptor = NULL;
    }

    return Status;
}

NTSTATUS
MRxSmbRemoveExtraAcesFromSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR OriginalSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
    OUT PBOOLEAN WereRemoved
    )
/*++

Routine Description:

    This routine takes an existing self-relative security descriptor
    and produces a new self-relative security descriptor with our
    extra ACEs removed. It returns S_FALSE if they did not need to
    be removed.

Arguments:



Return Value:

    Status - Result of the operation.

--*/
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PSID Owner;
    PSID Group;
    PACL Dacl;
    PACL Sacl;
    PACL NewDacl = NULL;
    ULONG NewDaclSize;
    BOOLEAN DaclPresent, DaclDefaulted;

    *NewSecurityDescriptor = NULL;
    *WereRemoved = FALSE;

    //
    // Check if we need to strip off any ACEs in the DACL
    // that SetSecurityInformation may have added.
    //

    Status = RtlGetDaclSecurityDescriptor(
                 OriginalSecurityDescriptor,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    if (DaclPresent &&
        (Dacl != NULL) &&
        MRxSmbAclHasExtraAces(Dacl)) {

        ULONG i;

        //
        // Need to strip the extra ACEs off.
        //
        // First convert the SD to absolute.
        //

        Status = MRxSmbSelfRelativeToAbsoluteSD(
                     OriginalSecurityDescriptor,
                     &AbsoluteSd,
                     &Dacl,
                     &Sacl,
                     &Owner,
                     &Group);

        if (!NT_SUCCESS(Status)) {
            goto CLEANUP;
        }

        //
        // Now modify the DACL. Each delete moves
        // the other ACEs down, so we just delete
        // ACE 0 as many times as needed.
        //

        for (i = 0; i < ExtraAceInfoCount; i++) {

            Status = RtlDeleteAce(
                         Dacl,
                         0);
            if (!NT_SUCCESS(Status)) {
                goto CLEANUP;
            }
        }

        //
        // If the resulting Dacl has no ACEs, then remove it
        // since a DACL with no ACEs implies no access. 
        //

        if (Dacl->AceCount == 0) {

            Status = RtlSetDaclSecurityDescriptor(
                         AbsoluteSd,
                         FALSE,
                         NULL,
                         FALSE);

        }

        //
        // Allocate and convert back to self-relative.
        //

        Status = MRxSmbAbsoluteToSelfRelativeSD(
                     AbsoluteSd,
                     NewSecurityDescriptor);

        if (!NT_SUCCESS(Status)) {
            goto CLEANUP;
        }

        *WereRemoved = TRUE;

    }

CLEANUP:

    if (AbsoluteSd != NULL) {
        RxFreePool(AbsoluteSd);
    }

    if (!NT_SUCCESS(Status) && (*NewSecurityDescriptor != NULL)) {
        RxFreePool(*NewSecurityDescriptor);
        *NewSecurityDescriptor = NULL;
    }

    return Status;

}

NTSTATUS
MRxSmbAddExtraAcesToSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR OriginalSecurityDescriptor,
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    )
/*++

Routine Description:

    This routine takes an existing self-relative security descriptor
    and produces a new self-relative security descriptor with our
    extra ACEs added.

Arguments:



Return Value:

    Status - Result of the operation.

--*/
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PSID Owner;
    PSID Group;
    PACL Dacl;
    PACL Sacl;
    PUCHAR NewAceList = NULL;
    PACL NewDacl = NULL;
    ULONG NewAceListSize;
    ULONG NewDaclSize;
    PACCESS_ALLOWED_ACE CurrentAce;
    ULONG i;

    *NewSecurityDescriptor = NULL;

    //
    // Allocate and convert the SD to absolute.
    //

    Status = MRxSmbSelfRelativeToAbsoluteSD(
                 OriginalSecurityDescriptor,
                 &AbsoluteSd,
                 &Dacl,
                 &Sacl,
                 &Owner,
                 &Group);

    //
    // If the SD is already absolute this call will have returned
    // STATUS_BAD_DESCRIPTOR_FORMAT -- we don't expect that.
    //

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // The server requires that the SD we pass to it has an owner -- so
    // set one if there isn't one.
    //

    if (Owner == NULL) {

        Status = RtlSetOwnerSecurityDescriptor(
                     AbsoluteSd,
                     MRxSmbRemoteBootMachineSid,
                     FALSE);

        if (!NT_SUCCESS(Status)) {
            goto CLEANUP;
        }
    }

    //
    // AbsoluteSd is now an absolute version of the passed-in
    // security descriptor. We replace the DACL with our
    // modified one.
    //

    //
    // First create the ACEs we want to add to the ACL.
    //

    NewAceListSize = 0;
    for (i = 0; i < ExtraAceInfoCount; i++) {
        NewAceListSize += ExtraAceInfo[i].AceSize;
    }

    NewAceList = RxAllocatePoolWithTag(PagedPool, NewAceListSize, MRXSMB_REMOTEBOOT_POOLTAG);
    if (NewAceList == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CLEANUP;
    }

    CurrentAce = (PACCESS_ALLOWED_ACE)NewAceList;

    for (i = 0; i < ExtraAceInfoCount; i++) {
        CurrentAce->Header.AceType = ExtraAceInfo[i].AceType;
        CurrentAce->Header.AceFlags = ExtraAceInfo[i].AceFlags;
        if (InheritableAces) {
            CurrentAce->Header.AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
        CurrentAce->Header.AceSize = ExtraAceInfo[i].AceSize;
        CurrentAce->Mask = ExtraAceInfo[i].Mask;
        RtlCopyMemory(&CurrentAce->SidStart,
                      ExtraAceInfo[i].Sid,
                      ExtraAceInfo[i].AceSize - FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart));
        CurrentAce = (PACCESS_ALLOWED_ACE)(((PUCHAR)CurrentAce) + ExtraAceInfo[i].AceSize);
    }

    //
    // Allocate the new DACL.
    //

    if (Dacl != NULL) {
        NewDaclSize = Dacl->AclSize + NewAceListSize;
    } else {
        NewDaclSize = sizeof(ACL) + NewAceListSize;
    }

    NewDacl = RxAllocatePoolWithTag(NonPagedPool, NewDaclSize, MRXSMB_REMOTEBOOT_POOLTAG);
    if (NewDacl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CLEANUP;
    }

    if (Dacl != NULL) {
        RtlCopyMemory(NewDacl, Dacl, Dacl->AclSize);
        NewDacl->AclSize = (USHORT)NewDaclSize;
    } else {
        Status = RtlCreateAcl(NewDacl, NewDaclSize, ACL_REVISION);
        if (!NT_SUCCESS(Status)) {
            goto CLEANUP;
        }
    }

    //
    // Put our ACEs in the front.
    //

    Status = RtlAddAce(
                 NewDacl,
                 ACL_REVISION,
                 0,        // StartingAceIndex
                 NewAceList,
                 NewAceListSize);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // Replace the existing DACL with ours.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 AbsoluteSd,
                 TRUE,
                 NewDacl,
                 FALSE);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // Allocate and convert back to self-relative.
    //

    Status = MRxSmbAbsoluteToSelfRelativeSD(
                 AbsoluteSd,
                 NewSecurityDescriptor);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

CLEANUP:

    //
    // Free the temporary things we allocated.
    //

    if (AbsoluteSd != NULL) {
        RxFreePool(AbsoluteSd);
    }

    if (NewAceList != NULL) {
        RxFreePool(NewAceList);
    }

    if (NewDacl != NULL) {
        RxFreePool(NewDacl);
    }

    if (!NT_SUCCESS(Status) && (*NewSecurityDescriptor != NULL)) {
        RxFreePool(*NewSecurityDescriptor);
        *NewSecurityDescriptor = NULL;
    }

    return Status;

}

NTSTATUS
MRxSmbCreateExtraAcesSelfRelativeSD(
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    )
/*++

Routine Description:

    This routine takes an existing self-relative security descriptor
    and produces a new self-relative security descriptor with our
    extra ACEs added.

Arguments:



Return Value:

    Status - Result of the operation.

--*/
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PUCHAR NewAceList = NULL;
    PACL NewDacl = NULL;
    ULONG NewAceListSize;
    ULONG NewDaclSize;
    PACCESS_ALLOWED_ACE CurrentAce;
    ULONG i;

    AbsoluteSd = RxAllocatePoolWithTag(PagedPool, SECURITY_DESCRIPTOR_MIN_LENGTH, MRXSMB_REMOTEBOOT_POOLTAG);

    if (AbsoluteSd == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CLEANUP;
    }

    Status = RtlCreateSecurityDescriptor(
                 AbsoluteSd,
                 SECURITY_DESCRIPTOR_REVISION);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // First create the ACEs we want to add to the ACL.
    //

    NewAceListSize = 0;
    for (i = 0; i < ExtraAceInfoCount; i++) {
        NewAceListSize += ExtraAceInfo[i].AceSize;
    }

    NewAceList = RxAllocatePoolWithTag(PagedPool, NewAceListSize, MRXSMB_REMOTEBOOT_POOLTAG);
    if (NewAceList == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CLEANUP;
    }

    CurrentAce = (PACCESS_ALLOWED_ACE)NewAceList;

    for (i = 0; i < ExtraAceInfoCount; i++) {
        CurrentAce->Header.AceType = ExtraAceInfo[i].AceType;
        CurrentAce->Header.AceFlags = ExtraAceInfo[i].AceFlags;
        if (InheritableAces) {
            CurrentAce->Header.AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
        CurrentAce->Header.AceSize = ExtraAceInfo[i].AceSize;
        CurrentAce->Mask = ExtraAceInfo[i].Mask;
        RtlCopyMemory(&CurrentAce->SidStart,
                      ExtraAceInfo[i].Sid,
                      ExtraAceInfo[i].AceSize - FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart));
        CurrentAce = (PACCESS_ALLOWED_ACE)(((PUCHAR)CurrentAce) + ExtraAceInfo[i].AceSize);
    }

    //
    // Allocate the new DACL.
    //

    NewDaclSize = sizeof(ACL) + NewAceListSize;

    NewDacl = RxAllocatePoolWithTag(NonPagedPool, NewDaclSize, MRXSMB_REMOTEBOOT_POOLTAG);
    if (NewDacl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CLEANUP;
    }

    RtlCreateAcl(NewDacl, NewDaclSize, ACL_REVISION);

    //
    // Put our ACEs in the front.
    //

    Status = RtlAddAce(
                 NewDacl,
                 ACL_REVISION,
                 0,        // StartingAceIndex
                 NewAceList,
                 NewAceListSize);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // Set the DACL on the SD.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 AbsoluteSd,
                 TRUE,
                 NewDacl,
                 FALSE);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // Set the owner on the SD.
    //

    Status = RtlSetOwnerSecurityDescriptor(
                 AbsoluteSd,
                 MRxSmbRemoteBootMachineSid,
                 FALSE);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

    //
    // Allocate and convert back to self-relative.
    //

    Status = MRxSmbAbsoluteToSelfRelativeSD(
                 AbsoluteSd,
                 NewSecurityDescriptor);

    if (!NT_SUCCESS(Status)) {
        goto CLEANUP;
    }

CLEANUP:

    if (AbsoluteSd != NULL) {
        RxFreePool(AbsoluteSd);
    }

    if (NewAceList != NULL) {
        RxFreePool(NewAceList);
    }

    if (NewDacl != NULL) {
        RxFreePool(NewDacl);
    }

    if (!NT_SUCCESS(Status) && (*NewSecurityDescriptor != NULL)) {
        RxFreePool(*NewSecurityDescriptor);
        *NewSecurityDescriptor = NULL;
    }

    return Status;

}
#endif // defined(REMOTE_BOOT)

NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine implements the NtQuerySecurityFile api.


Arguments:



Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFcb;
   RxCaptureFobx;
   PVOID Buffer = RxContext->Info.Buffer;
   PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
   PMRX_SMB_SRV_OPEN smbSrvOpen;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

#if defined(REMOTE_BOOT)
   PSECURITY_DESCRIPTOR SelfRelativeSd;
   BOOLEAN ConvertedAcl = FALSE;
#endif // defined(REMOTE_BOOT)

   NTSTATUS Status;

   REQ_QUERY_SECURITY_DESCRIPTOR QuerySecurityRequest;
   RESP_QUERY_SECURITY_DESCRIPTOR QuerySecurityResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbQuerySecurityInformation...\n"));

   // Turn away this call from those servers which do not support the NT SMBs

   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

   if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
       RxDbgTrace(-1, Dbg, ("QuerySecurityDescriptor not supported!\n"));
       return((STATUS_NOT_SUPPORTED));
   }

   if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {
       return     STATUS_ONLY_IF_CONNECTED;
   }

   Status = MRxSmbDeferredCreate(RxContext);
   if (Status!=STATUS_SUCCESS) {
       goto FINALLY;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
       //BOOLEAN printflag;

       TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_SECURITY_DESC;
       //TransactionOptions.Flags |= SMB_XACT_FLAGS_COPY_ON_ERROR;

       QuerySecurityRequest.Fid = smbSrvOpen->Fid;
       QuerySecurityRequest.Reserved = 0;
       QuerySecurityRequest.SecurityInformation = RxContext->QuerySecurity.SecurityInformation;

       QuerySecurityResponse.LengthNeeded = 0xbaadbaad;

       //printflag = RxDbgTraceDisableGlobally();//this is debug code anyway!
       //RxDbgTraceEnableGlobally(FALSE);

       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // output setup buffer
                     0,                            // output setup buffer length
                     &QuerySecurityRequest,        // Input Param Buffer
                     sizeof(QuerySecurityRequest), // Input param buffer length
                     &QuerySecurityResponse,       // Output param buffer
                     sizeof(QuerySecurityResponse),// output param buffer length
                     NULL,                         // Input data buffer
                     0,                            // Input data buffer length
                     Buffer,                       // output data buffer
                     *pLengthRemaining,            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //DbgPrint("QSR.len=%x\n", QuerySecurityResponse.LengthNeeded);


        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxContext->InformationToReturn = QuerySecurityResponse.LengthNeeded;
            RxDbgTrace(0, Dbg, ("MRxSmbQuerySecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_SECURITY_DESCRIPTOR));

            if (((LONG)(QuerySecurityResponse.LengthNeeded)) > *pLengthRemaining) {
                Status = STATUS_BUFFER_OVERFLOW;
            }

#if defined(REMOTE_BOOT)
            if (MRxSmbBootedRemotely &&
                MRxSmbRemoteBootDoMachineLogon) {

                PSMBCE_SESSION pSession;
                pSession = &SmbCeGetAssociatedVNetRootContext(
                                capFobx->pSrvOpen->pVNetRoot)->pSessionEntry->Session;

                if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

                    //
                    // if the user supplied a zero-length buffer, I.e. they were querying
                    // to see how big a buffer was needed, they will wind up with less 
                    // data than expected because on the subsequent call with a real buffer,
                    // we may remove the extra ACEs.
                    //

                    if (NT_SUCCESS(Status) && (Buffer != NULL) && (ReturnedDataCount > 0)) {

                        BOOLEAN DaclPresent, DaclDefaulted;

                        // DbgPrint( ">>> Querying SD on %wZ\n", &capFcb->AlreadyPrefixedName);

                        //
                        // Remove any any ACEs in the DACL
                        // that SetSecurityInformation may have added.
                        //

                        Status = MRxSmbRemoveExtraAcesFromSelfRelativeSD(
                                     (PSECURITY_DESCRIPTOR)Buffer,
                                     &SelfRelativeSd,
                                     &ConvertedAcl);

                        if (!NT_SUCCESS(Status)) {
                            goto FINALLY;
                        }

                        if (ConvertedAcl) {

                            //
                            // Copy the new security descriptor and
                            // modify the data length.
                            //

                            RtlCopyMemory(
                                Buffer,
                                SelfRelativeSd,
                                RtlLengthSecurityDescriptor(SelfRelativeSd));

                        }
                    }
                }
            }
#endif // defined(REMOTE_BOOT)

        }

        //RxDbgTraceEnableGlobally(printflag);
    }


FINALLY:

#if defined(REMOTE_BOOT)
    //
    // If we modified the security descriptor for a remote boot server,
    // clean it up.
    //

    if (ConvertedAcl) {

        //
        // Free the self-relative SD that was allocated.
        //

        if (SelfRelativeSd != NULL) {
            RxFreePool(SelfRelativeSd);
        }
    }
#endif // defined(REMOTE_BOOT)

    RxDbgTrace(-1, Dbg, ("MRxSmbQuerySecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;


}

NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN     smbSrvOpen;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    NTSTATUS Status;

    REQ_SET_SECURITY_DESCRIPTOR SetSecurityRequest;

#if defined(REMOTE_BOOT)
    PSECURITY_DESCRIPTOR OriginalSd;
    PSECURITY_DESCRIPTOR SelfRelativeSd;
    BOOLEAN DidRemoteBootProcessing = FALSE;
#endif // defined(REMOTE_BOOT)

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetSecurityInformation...\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        RxDbgTrace(-1, Dbg, ("Set Security Descriptor not supported!\n"));

        return((STATUS_NOT_SUPPORTED));

    } else if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {

        return STATUS_ONLY_IF_CONNECTED;

#if defined(REMOTE_BOOT)
    } else if (MRxSmbBootedRemotely) {

        PSMBCE_SESSION pSession;
        pSession = &SmbCeGetAssociatedVNetRootContext(
                        capFobx->pSrvOpen->pVNetRoot)->pSessionEntry->Session;

        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

            TYPE_OF_OPEN TypeOfOpen = NodeType(capFcb);

            //
            // Set this so we know to call the CSC epilogue, and can clean
            // up correctly.
            //

            DidRemoteBootProcessing = TRUE;
            SelfRelativeSd = NULL;

            // DbgPrint( ">>> setting SD on %wZ\n", &capFcb->AlreadyPrefixedName);

            //
            // First we need to set the security descriptor on the CSC
            // version of the file, if one exists.
            //

            Status = MRxSmbCscSetSecurityPrologue(RxContext);
            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }

            if (MRxSmbRemoteBootDoMachineLogon) {

                //
                // Add our ACEs to the security descriptor. This returns the
                // new security descriptor in SelfRelativeSd. If this is a
                // directory we add inheritable ACEs.
                //

                Status = MRxSmbAddExtraAcesToSelfRelativeSD(
                             RxContext->SetSecurity.SecurityDescriptor,
                             (BOOLEAN)(TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_DIRECTORY),
                             &SelfRelativeSd);

                if (!NT_SUCCESS(Status)) {
                    goto FINALLY;
                }

                //
                // Now replace the original SD with the new one.
                //

                OriginalSd = RxContext->SetSecurity.SecurityDescriptor;

                RxContext->SetSecurity.SecurityDescriptor = SelfRelativeSd;

            } else {

                //
                // If we logged on using the NULL session, then don't set ACLs
                // on the server file. Jump to the end so that the CSC epilogue
                // is called.
                //

                Status = STATUS_SUCCESS;
                goto FINALLY;

            }
        }
#endif // defined(REMOTE_BOOT)

    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        ULONG SdLength = RtlLengthSecurityDescriptor(RxContext->SetSecurity.SecurityDescriptor);

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_SECURITY_DESC;

        SetSecurityRequest.Fid = smbSrvOpen->Fid;
        SetSecurityRequest.Reserved = 0;
        SetSecurityRequest.SecurityInformation = RxContext->SetSecurity.SecurityInformation;

        Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the input setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetSecurityRequest,          // Input Param Buffer
                     sizeof(SetSecurityRequest),   // Input param buffer length
                     NULL,                         // Output param buffer
                     0,                            // output param buffer length
                     RxContext->SetSecurity.SecurityDescriptor,  // Input data buffer
                     SdLength,                     // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //the old rdr doesn't return any info...................
        //RxContext->InformationToReturn = SetSecurityResponse.LengthNeeded;

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbSetSecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == 0);
            ASSERT(ResumptionContext.SetupBytesReceived == 0);
            ASSERT(ResumptionContext.DataBytesReceived == 0);
        }
    }


FINALLY:

#if defined(REMOTE_BOOT)
    //
    // If we modified the security descriptor for a remote boot server,
    // clean it up.
    //

    if (DidRemoteBootProcessing) {

        if (SelfRelativeSd != NULL) {

            RxFreePool(SelfRelativeSd);

            //
            // If we successfully allocated SelfRelativeSd then we
            // also replaced the original passed-in SD, so we need
            // to put the old SD back.
            //

            RxContext->SetSecurity.SecurityDescriptor = OriginalSd;
        }

        MRxSmbCscSetSecurityEpilogue(RxContext, &Status);

    }
#endif // defined(REMOTE_BOOT)

    RxDbgTrace(-1, Dbg, ("MRxSmbSetSecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;
}


NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:


    IN PUCHAR  UserEaList;  - Supplies the Ea names required.
    IN ULONG   UserEaListLength;

    OUT PFEALIST *ServerEaList - Eas returned by the server. Caller is responsible for
                        freeing memory.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_QUERY_FILE_INFORMATION;

   REQ_QUERY_FILE_INFORMATION QueryFileInfoRequest;
   RESP_QUERY_FILE_INFORMATION QueryFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   CLONG OutDataCount = EA_QUERY_SIZE;

   CLONG OutSetupCount = 0;

   PFEALIST Buffer;

   PGEALIST ServerQueryEaList = NULL;
   CLONG InDataCount;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbLoadEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    //
    //  Convert the supplied UserEaList to a GEALIST. The server will return just the Eas
    //  requested by the application.
    //
    //
    //  If the application specified a subset of EaNames then convert to OS/2 1.2 format and
    //  pass that to the server. ie. Use the server to filter out the names.
    //

    //CODE.IMPROVEMENT if write-cacheing is enabled, then we could find out the size once and save it. in
    //                 this way we would at least avoid this everytime. the best way would be an NT-->NT api that
    //                 implements this in a reasonable fashion. (we can only do the above optimization if it's a full
    //                 query instead of a ealist!=NULL query.

    Buffer = RxAllocatePool ( PagedPool, OutDataCount );

    if ( Buffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    if ( UserEaList != NULL) {

        //
        //  OS/2 format is always a little less than or equal to the NT UserEaList size.
        //  This code relies on the I/O system verifying the EaList is valid.
        //

        ServerQueryEaList = RxAllocatePool ( PagedPool, UserEaListLength );
        if ( ServerQueryEaList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        };

        MRxSmbNtGeaListToOs2((PFILE_GET_EA_INFORMATION )UserEaList, UserEaListLength, ServerQueryEaList );
        InDataCount = (CLONG)ServerQueryEaList->cbList;

    } else {
        InDataCount = 0;
    }

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

       QueryFileInfoRequest.Fid = smbSrvOpen->Fid;

       if ( UserEaList != NULL) {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_EAS_FROM_LIST;
       } else {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_ALL_EAS;
       }

       // CODE.IMPROVEMENT it is unfortunate that this is defined so that a paramMDL cannot be passed
       // perhaps it should be passed in the options!
       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                       // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &QueryFileInfoRequest,        // Input Param Buffer
                     sizeof(QueryFileInfoRequest), // Input param buffer length
                     &QueryFileInfoResponse,       // Output param buffer
                     sizeof(QueryFileInfoResponse),// output param buffer length
                     ServerQueryEaList,            // Input data buffer
                     InDataCount,                  // Input data buffer length
                     Buffer,                       // output data buffer
                     OutDataCount,                 // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbLoadEaList...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_FILE_INFORMATION));

            if ( SmbGetUlong( &((PFEALIST)Buffer)->cbList) != ReturnedDataCount ){
                Status = STATUS_EA_CORRUPT_ERROR;
            }

            if ( ReturnedDataCount == 0 ) {
                Status = STATUS_NO_EAS_ON_FILE;
            }

        }
    }


FINALLY:
    if ( NT_SUCCESS(Status) ) {
        *ServerEaList = Buffer;
    } else {
        if (Buffer != NULL) {
            RxFreePool(Buffer);
        }
    }

    if ( ServerQueryEaList != NULL) {
        RxFreePool(ServerQueryEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadEaList...exit, st=%08lx\n",Status));
    return Status;

}


VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    )
/*++

Routine Description:

    Converts a single NT GET EA list to OS/2 GEALIST style.  The GEALIST
    need not have any particular alignment.

Arguments:

    NtGetEaList - An NT style get EA list to be converted to OS/2 format.

    GeaListLength - the maximum possible length of the GeaList.

    GeaList - Where to place the OS/2 1.2 style GEALIST.

Return Value:

    none.

--*/
{

    PGEA gea = GeaList->list;

    PFILE_GET_EA_INFORMATION ntGetEa = NtGetEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntGetEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the gea
        // pointer for the next iteration.
        //

        gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

        ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );

        ntGetEa = (PFILE_GET_EA_INFORMATION)((PCHAR)ntGetEa + ntGetEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

    ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );



    //
    // Set the number of bytes in the GEALIST.
    //

    SmbPutUlong(
        &GeaList->cbList,
        (ULONG)((PCHAR)gea - (PCHAR)GeaList)
        );

    UNREFERENCED_PARAMETER( GeaListLength );
}


PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    )

/*++

Routine Description:

    Converts a single NT Get EA entry to OS/2 GEA style.  The GEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Gea - a pointer to the location where the OS/2 GEA is to be written.

    NtGetEa - a pointer to the NT Get EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Gea->cbName = NtGetEa->EaNameLength;

    ptr = (PCHAR)(Gea) + 1;
    RtlCopyMemory( ptr, NtGetEa->EaName, NtGetEa->EaNameLength );

    ptr += NtGetEa->EaNameLength;
    *ptr++ = '\0';

    return ( (PGEA)ptr );

}


NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    )

/*++

Routine Description:

    This routine copies the required number of Eas from the ServerEaList
    starting from the offset indicated in the Icb. The Icb is also updated
    to show the last Ea returned.

Arguments:

    IN PFEALIST ServerEaList - Supplies the Ea List in OS/2 format.
    IN PVOID Buffer - Supplies where to put the NT format EAs
    IN OUT PULONG BufferLengthRemaining - Supplies the user buffer space.
    IN BOOLEAN ReturnSingleEntry
    IN BOOLEAN UserEaListSupplied - ServerEaList is a subset of the Eas


Return Value:

    NTSTATUS - The status for the Irp.

--*/

{
    RxCaptureFobx;
    ULONG EaIndex = capFobx->OffsetOfNextEaToReturn;
    ULONG Index = 1;
    ULONG Size;
    ULONG OriginalLengthRemaining = *BufferLengthRemaining;
    BOOLEAN Overflow = FALSE;
    PFEA LastFeaStartLocation;
    PFEA Fea = NULL;
    PFEA LastFea = NULL;
    PFILE_FULL_EA_INFORMATION NtFullEa = Buffer;
    PFILE_FULL_EA_INFORMATION LastNtFullEa = Buffer;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbQueryEasFromServer...EaIndex/Buffer/Remaining=%08lx/%08lx/%08lx\n",
                                       EaIndex,Buffer,((BufferLengthRemaining)?*BufferLengthRemaining:0xbadbad)
                       ));

    //
    //  If there are no Ea's present in the list, return the appropriate
    //  error.
    //
    //  Os/2 servers indicate that a list is null if cbList==4.
    //

    if ( SmbGetUlong(&ServerEaList->cbList) == FIELD_OFFSET(FEALIST, list) ) {
        return STATUS_NO_EAS_ON_FILE;
    }

    //
    //  Find the last location at which an FEA can start.
    //

    LastFeaStartLocation = (PFEA)( (PCHAR)ServerEaList +
                               SmbGetUlong( &ServerEaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    //  Go through the ServerEaList until we find the entry corresponding to EaIndex
    //

    for ( Fea = ServerEaList->list;
          (Fea <= LastFeaStartLocation) && (Index < EaIndex);
          Index+= 1,
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {
        NOTHING;
    }

    if ( Index != EaIndex ) {

        if ( Index == EaIndex+1 ) {
            return STATUS_NO_MORE_EAS;
        }

        //
        //  No such index
        //

        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    //
    // Go through the rest of the FEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an FEA can start.
    //

    for ( ;
          Fea <= LastFeaStartLocation;
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {

        PCHAR ptr;

        //
        //  Calculate the size of this Fea when converted to an NT EA structure.
        //
        //  The last field shouldn't be padded.
        //

        if ((PFEA)((PCHAR)Fea+sizeof(FEA)+Fea->cbName+1+SmbGetUshort(&Fea->cbValue)) < LastFeaStartLocation) {
            Size = SmbGetNtSizeOfFea( Fea );
        } else {
            Size = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    Fea->cbName + 1 + SmbGetUshort(&Fea->cbValue);
        }

        //
        //  Will the next Ea fit?
        //

        if ( *BufferLengthRemaining < Size ) {

            if ( LastNtFullEa != NtFullEa ) {

                if ( UserEaListSupplied == TRUE ) {
                    *BufferLengthRemaining = OriginalLengthRemaining;
                    return STATUS_BUFFER_OVERFLOW;
                }

                Overflow = TRUE;

                break;

            } else {

                //  Not even room for a single EA!

                return STATUS_BUFFER_OVERFLOW;
            }
        } else {
            *BufferLengthRemaining -= Size;
        }

        //
        //  We are comitted to copy the Os2 Fea to Nt format in the users buffer
        //

        LastNtFullEa = NtFullEa;
        LastFea = Fea;
        EaIndex++;

        //  Create new Nt Ea

        NtFullEa->Flags = Fea->fEA;
        NtFullEa->EaNameLength = Fea->cbName;
        NtFullEa->EaValueLength = SmbGetUshort( &Fea->cbValue );

        ptr = NtFullEa->EaName;
        RtlCopyMemory( ptr, (PCHAR)(Fea+1), Fea->cbName );

        ptr += NtFullEa->EaNameLength;
        *ptr++ = '\0';

        //
        // Copy the EA value to the NT full EA.
        //

        RtlCopyMemory(
            ptr,
            (PCHAR)(Fea+1) + NtFullEa->EaNameLength + 1,
            NtFullEa->EaValueLength
            );

        ptr += NtFullEa->EaValueLength;

        //
        // Longword-align ptr to determine the offset to the next location
        // for an NT full EA.
        //

        ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );

        NtFullEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtFullEa );

        NtFullEa = (PFILE_FULL_EA_INFORMATION)ptr;

        if ( ReturnSingleEntry == TRUE ) {
            break;
        }
    }

    //
    // Set the NextEntryOffset field of the last full EA to 0 to indicate
    // the end of the list.
    //

    LastNtFullEa->NextEntryOffset = 0;

    //
    //  Record position the default start position for the next query
    //

    capFobx->OffsetOfNextEaToReturn = EaIndex;

    if ( Overflow == FALSE ) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_BUFFER_OVERFLOW;
    }

}


ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    NT full EA list in OS/2 1.2 style.  This routine assumes that
    at least one EA is present in the buffer.

Arguments:

    NtFullEa - a pointer to the list of NT EAs.

Return Value:

    ULONG - number of bytes required to hold the EAs in OS/2 1.2 format.

--*/

{
    ULONG size;

    PAGED_CODE();

    //
    // Walk through the EAs, adding up the total size required to
    // hold them in OS/2 format.
    //

    for ( size = FIELD_OFFSET(FEALIST, list[0]);
          NtFullEa->NextEntryOffset != 0;
          NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                         (PCHAR)NtFullEa + NtFullEa->NextEntryOffset ) ) {

        size += SmbGetOs2SizeOfNtFullEa( NtFullEa );
    }

    size += SmbGetOs2SizeOfNtFullEa( NtFullEa );

    return size;

}


VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    )
/*++

Routine Description:

    Converts a single NT FULL EA list to OS/2 FEALIST style.  The FEALIST
    need not have any particular alignment.

    It is the callers responsibility to ensure that FeaList is large enough.

Arguments:

    NtEaList - An NT style get EA list to be converted to OS/2 format.

    FeaList - Where to place the OS/2 1.2 style FEALIST.

Return Value:

    none.

--*/
{

    PFEA fea = FeaList->list;

    PFILE_FULL_EA_INFORMATION ntFullEa = NtEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntFullEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the fea
        // pointer for the next iteration.
        //

        fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );

        ntFullEa = (PFILE_FULL_EA_INFORMATION)((PCHAR)ntFullEa + ntFullEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );


    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        (ULONG)((PCHAR)fea - (PCHAR)FeaList)
        );

}


PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Converts a single NT full EA to OS/2 FEA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Fea - a pointer to the location where the OS/2 FEA is to be written.

    NtFullEa - a pointer to the NT full EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Fea->fEA = (UCHAR)NtFullEa->Flags;
    Fea->cbName = NtFullEa->EaNameLength;
    SmbPutUshort( &Fea->cbValue, NtFullEa->EaValueLength );

    ptr = (PCHAR)(Fea + 1);
    RtlCopyMemory( ptr, NtFullEa->EaName, NtFullEa->EaNameLength );

    ptr += NtFullEa->EaNameLength;
    *ptr++ = '\0';

    RtlCopyMemory(
        ptr,
        NtFullEa->EaName + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    return (ptr + NtFullEa->EaValueLength);

}


NTSTATUS
MRxSmbSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:

    IN PFEALIST ServerEaList - Eas to be sent to the server.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_SET_FILE_INFORMATION;

   REQ_SET_FILE_INFORMATION SetFileInfoRequest;
   RESP_SET_FILE_INFORMATION SetFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbSetEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;
   SetFileInfoResponse.EaErrorOffset = 0;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
      PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
      SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

      //RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl: TransactionName %ws Length %ld\n",
      //                     TransactionName.Buffer,TransactionName.Length));

      SetFileInfoRequest.Fid = smbSrvOpen->Fid;
      SetFileInfoRequest.InformationLevel = SMB_INFO_SET_EAS;
      SetFileInfoRequest.Flags = 0;

      // CODE.IMPROVEMENT it is unfortunate that this is defined so that a dataMDL cannot be passed
      // perhaps it should be passed in the options!
      Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                        // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetFileInfoRequest,          // Input Param Buffer
                     sizeof(SetFileInfoRequest),   // Input param buffer length
                     &SetFileInfoResponse,         // Output param buffer
                     sizeof(SetFileInfoResponse),  // output param buffer length
                     ServerEaList,                 // Input data buffer
                     SmbGetUlong(&ServerEaList->cbList), // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

   }

   if (!NT_SUCCESS(Status)) {
      USHORT EaErrorOffset = SetFileInfoResponse.EaErrorOffset;
      RxDbgTrace( 0, Dbg, ("MRxSmbSetEaList: Failed .. returning %lx/%lx\n",Status,EaErrorOffset));
      RxContext->InformationToReturn = (EaErrorOffset);
   }
   else
   {
      // succeeded in setting EAs, reset this flag so that when this
      // srvopen is used again for getting the EAs we will succeed
      smbSrvOpen->FileStatusFlags &= ~SMB_FSF_NO_EAS;
   }

   RxDbgTrace(-1, Dbg, ("MRxSmbSetEaList...exit\n"));
   return Status;
}

NTSTATUS
MRxSmbQueryQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT   Setup = NT_TRANSACT_QUERY_QUOTA;

    PSID   StartSid;
    ULONG  StartSidLength;

    REQ_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoRequest;
    RESP_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoResponse;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

        StartSid       = RxContext->QueryQuota.StartSid;

        if (StartSid != NULL) {
            StartSidLength = RtlLengthRequiredSid(((PISID)StartSid)->SubAuthorityCount);
        } else {
            StartSidLength = 0;
        }

        QueryQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        QueryQuotaInfoRequest.ReturnSingleEntry = RxContext->QueryQuota.ReturnSingleEntry;
        QueryQuotaInfoRequest.RestartScan       = RxContext->QueryQuota.RestartScan;

        QueryQuotaInfoRequest.SidListLength = RxContext->QueryQuota.SidListLength;
        QueryQuotaInfoRequest.StartSidOffset =  ROUND_UP_COUNT(
                                                    RxContext->QueryQuota.SidListLength,
                                                    sizeof(ULONG));
        QueryQuotaInfoRequest.StartSidLength = StartSidLength;


        // The input data buffer to be supplied to the server consists of two pieces
        // of information the start sid and the sid list. Currently the I/O
        // subsystem allocates them in contigous memory. In such cases we avoid
        // another allocation by reusing the same buffer. If this condition is
        // not satisfied we allocate a buffer large enough for both the
        // components and copy them over.

        InputDataBufferLength = ROUND_UP_COUNT(
                                    RxContext->QueryQuota.SidListLength,
                                    sizeof(ULONG)) +
                                StartSidLength;

        QueryQuotaInfoRequest.StartSidLength = StartSidLength;

        if (((PBYTE)RxContext->QueryQuota.SidList +
             ROUND_UP_COUNT(RxContext->QueryQuota.SidListLength,sizeof(ULONG))) !=
            RxContext->QueryQuota.StartSid) {
            pInputDataBuffer = RxAllocatePoolWithTag(
                                   PagedPool,
                                   InputDataBufferLength,
                                   MRXSMB_MISC_POOLTAG);

            if (pInputDataBuffer != NULL) {
                RtlCopyMemory(
                    pInputDataBuffer ,
                    RxContext->QueryQuota.SidList,
                    RxContext->QueryQuota.SidListLength);

                RtlCopyMemory(
                    pInputDataBuffer + QueryQuotaInfoRequest.StartSidOffset,
                    StartSid,
                    StartSidLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            pInputDataBuffer = (PBYTE)RxContext->QueryQuota.SidList;
        }


        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
           SMB_TRANSACTION_OPTIONS            TransactionOptions = RxDefaultTransactionOptions;
           SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

           TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_QUOTA;

           pOutputDataBuffer      = RxContext->Info.Buffer;
           OutputDataBufferLength = RxContext->Info.LengthRemaining;

           Status = SmbCeTransact(
                        RxContext,                       // the RXContext for the transaction
                        &TransactionOptions,             // transaction options
                        &Setup,                          // the setup buffer
                        sizeof(Setup),                   // setup buffer length
                        NULL,                            // the output setup buffer
                        0,                               // output setup buffer length
                        &QueryQuotaInfoRequest,          // Input Param Buffer
                        sizeof(QueryQuotaInfoRequest),   // Input param buffer length
                        &QueryQuotaInfoResponse,         // Output param buffer
                        sizeof(QueryQuotaInfoResponse),  // output param buffer length
                        pInputDataBuffer,                // Input data buffer
                        InputDataBufferLength,           // Input data buffer length
                        pOutputDataBuffer,               // output data buffer
                        OutputDataBufferLength,          // output data buffer length
                        &ResumptionContext               // the resumption context
                        );
        }

        if ((pInputDataBuffer != NULL) &&
            (pInputDataBuffer != (PBYTE)RxContext->QueryQuota.SidList)) {
            RxFreePool(pInputDataBuffer);
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxContext->InformationToReturn = 0;
    } else {
        RxContext->InformationToReturn = QueryQuotaInfoResponse.Length;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryQuotaInformation...exit\n"));

    return Status;
}

NTSTATUS
MRxSmbSetQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{

    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT Setup = NT_TRANSACT_SET_QUOTA;

    REQ_NT_SET_FS_QUOTA_INFO  SetQuotaInfoRequest;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_QUOTA;

        SetQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        pInputDataBuffer      = RxContext->Info.Buffer;
        InputDataBufferLength = RxContext->Info.LengthRemaining;

        Status = SmbCeTransact(
                     RxContext,                       // the RXContext for the transaction
                     &TransactionOptions,             // transaction options
                     &Setup,                          // the setup buffer
                     sizeof(Setup),                   // setup buffer length
                     NULL,                            // the output setup buffer
                     0,                               // output setup buffer length
                     &SetQuotaInfoRequest,            // Input Param Buffer
                     sizeof(SetQuotaInfoRequest),     // Input param buffer length
                     pOutputParamBuffer,              // Output param buffer
                     OutputParamBufferLength,         // output param buffer length
                     pInputDataBuffer,                // Input data buffer
                     InputDataBufferLength,           // Input data buffer length
                     pOutputDataBuffer,               // output data buffer
                     OutputDataBufferLength,          // output data buffer length
                     &ResumptionContext               // the resumption context
                     );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetQuotaInformation...exit\n"));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\exsessup.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    exsessup.h

Abstract:

    This is the include file that defines all constants and types for
    the extended session setup SMB exchange implementation.

Author:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

--*/

#ifndef _EXSESSUP_H_
#define _EXSESSUP_H_


#include <smbxchng.h>

#include "security.h"

#define IsCredentialHandleValid(pCredHandle)    \
        (((pCredHandle)->dwLower != 0xffffffff) && ((pCredHandle)->dwUpper != 0xffffffff))

#define IsSecurityContextHandleValid(pContextHandle)    \
        (((pContextHandle)->dwLower != 0xffffffff) && ((pContextHandle)->dwUpper != 0xffffffff))

typedef struct _SMBCE_EXTENDED_SESSION_ {
    SMBCE_SESSION;

    PCHAR  pServerResponseBlob;
    ULONG  ServerResponseBlobLength;
} SMBCE_EXTENDED_SESSION, *PSMBCE_EXTENDED_SESSION;

typedef struct _SMB_EXTENDED_SESSION_SETUP_EXCHANGE {
    SMB_EXCHANGE;

    BOOLEAN  Reparse;
    BOOLEAN  FirstSessionSetup;   // It is not waiting for other session setup
    BOOLEAN  RequestPosted;
    PVOID    pActualBuffer;      // Originally allocated buffer
    PVOID    pBuffer;            // Start of header
    PMDL     pBufferAsMdl;
    ULONG    BufferLength;

    ULONG    ResponseLength;

    PVOID    pServerResponseBlob;
    ULONG    ServerResponseBlobOffset;
    ULONG    ServerResponseBlobLength;

    PSMBCE_RESUMPTION_CONTEXT pResumptionContext;
} SMB_EXTENDED_SESSION_SETUP_EXCHANGE, *PSMB_EXTENDED_SESSION_SETUP_EXCHANGE;

extern NTSTATUS
ValidateServerExtendedSessionSetupResponse(
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE   pExchange,
    PVOID pServerResponseBlob,
    ULONG ServerResponseBlobLength);

extern NTSTATUS
SmbExtSecuritySessionSetupExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize);

extern NTSTATUS
SmbCeInitializeExtendedSessionSetupExchange(
    PSMB_EXCHANGE*  pExchangePtr,
    PMRX_V_NET_ROOT pVNetRoot);

extern VOID
SmbCeDiscardExtendedSessionSetupExchange(
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExchange);

extern SMB_EXCHANGE_DISPATCH_VECTOR
ExtendedSessionSetupExchangeDispatch;

#endif // _EXSESSUP_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\exsessup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exsessup.c

Abstract:

    This module implements the routines for setting up a session using the
    the securitt negotiation mechanism ( post NT40 ).

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

Notes:

    The extended session setup is used in the new security negotiation scheme
    which involves multiple round trips to the server before the user can be
    successfully authenticated and a session established.

    In the modified scheme the negotiate returns a BLOB which is passed to the
    client side security package to initiate the session setup procedure. The
    BLOB returned by the server contains an encoding of the security packages
    supported by the server.

    The client side security package when presented with this BLOB chooses a
    security package and encodes the client credentials in the form of a
    BLOB which is shipped to the server using the EXTENDED_SESSION_SETUP_ANDX
    SMB.

    The server has one of three responses to an EXTENDED_SESSION_SETUP_ANDX
    SMB presented by the client.

        1) The server has enough information to establish the session.

        2) The server cannot proceed with the session setup because of an
           error in the information presented by the client or otherwise.

        3) The security package on the server needs an additional round trip
           before the session setup can be established. This is especially
           true of new security packages which support mutual authentication
           between the client and server.

    In the first two cases no further round trips are required. The action taken
    on the client side depends upon whether the server returned a BLOB. If the
    server returned a BLOB it must be presented to the client side security
    package to complete the session setup procedure.

    In the case of (3) the BLOB returned by the server must be presented to the
    client and the BLOB generated by the security package must be shipped back
    to the server.

    In the SMBCE_EXTENDED_SESSION_SETUP_EXCHANGE the following parameters support
    the protocol outlined above. A buffer with maximum server buffer size is allocated,
    locked and a MDL created as part of the exchange initialization. This buffer is 
    used to hold the server response BLOB. Notice that this avoids redundant copying 
    and handles all the known cases.

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeInitializeExtendedSessionSetupExchange)
#pragma alloc_text(PAGE, SmbCeDiscardExtendedSessionSetupExchange)
#pragma alloc_text(PAGE, SmbExtSecuritySessionSetupExchangeStart)
#pragma alloc_text(PAGE, SmbExtSecuritySessionSetupExchangeSendCompletionHandler)
#endif

// this string is used to test whether the server really supports security signature.
// if the server returns back the deferent string on SMB header security signature of the
// extended session setup response from the client sends out on the request, the server
// does support security signature.
CHAR InitialSecuritySignature[] = {"BSRSPYL "};

extern BOOLEAN MRxSmbSecuritySignaturesEnabled;

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

//
// Forward declarations ...
//

NTSTATUS
SmbCeInitializeExtendedSessionSetupExchange(
    PSMB_EXCHANGE*  pExchangePtr,
    PMRX_V_NET_ROOT pVNetRoot)
/*++

Routine Description:

    This routine initializes an instance of a session setup exchange.

Arguments:

    pExchange - the exchange instance

    pVNetRoot - the MRX_V_NET_ROOT instance associated with the exchange.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange;

    PAGED_CODE();

    ASSERT((pExchangePtr == NULL) ||
           ((*pExchangePtr)->Type == EXTENDED_SESSION_SETUP_EXCHANGE));

    Status = SmbCeInitializeExchange(
                 pExchangePtr,
                 NULL,
                 pVNetRoot,
                 EXTENDED_SESSION_SETUP_EXCHANGE,
                 &ExtendedSessionSetupExchangeDispatch);

    if (Status == STATUS_SUCCESS) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetExchangeServerEntry(*pExchangePtr);

        pExtSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)
                                   (*pExchangePtr);


        pExtSessionSetupExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;

        // Allocate the buffer to hold the server response.
        pExtSessionSetupExchange->BufferLength =
            pServerEntry->Server.MaximumBufferSize;

        pExtSessionSetupExchange->pActualBuffer = RxAllocatePoolWithTag(
                                         PagedPool,
              (pExtSessionSetupExchange->BufferLength + TRANSPORT_HEADER_SIZE),
                                         MRXSMB_KERBEROS_POOLTAG);

        pExtSessionSetupExchange->pServerResponseBlob = NULL;
        pExtSessionSetupExchange->ServerResponseBlobLength = 0;
        pExtSessionSetupExchange->Reparse = TRUE;

        if (pExtSessionSetupExchange->pActualBuffer != NULL) {
            (PCHAR) pExtSessionSetupExchange->pBuffer =
                (PCHAR) pExtSessionSetupExchange->pActualBuffer + TRANSPORT_HEADER_SIZE;

            RxAllocateHeaderMdl(
                pExtSessionSetupExchange->pBuffer,
                pExtSessionSetupExchange->BufferLength,
                pExtSessionSetupExchange->pBufferAsMdl
                );

            if (pExtSessionSetupExchange->pBufferAsMdl != NULL) {

                RxProbeAndLockHeaderPages(
                    pExtSessionSetupExchange->pBufferAsMdl,
                    KernelMode,
                    IoModifyAccess,
                    Status);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_SUCCESS) {
            if (pExtSessionSetupExchange->pBufferAsMdl != NULL) {
                IoFreeMdl(pExtSessionSetupExchange->pBufferAsMdl);
            }

            if (pExtSessionSetupExchange->pActualBuffer != NULL) {
                RxFreePool(pExtSessionSetupExchange->pActualBuffer);
            }

            SmbCePrepareExchangeForReuse(*pExchangePtr);
        }
    }

    return Status;
}

VOID
SmbCeDiscardExtendedSessionSetupExchange(
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange)
/*++

Routine Description:

    This routine discards an instance of a session setup exchange.

Arguments:

    pExchange - the exchange instance

--*/
{
    PAGED_CODE();

    if (pExtSessionSetupExchange->pBufferAsMdl != NULL) {
        RxUnlockHeaderPages(pExtSessionSetupExchange->pBufferAsMdl);
        IoFreeMdl(pExtSessionSetupExchange->pBufferAsMdl);
    }

    if (pExtSessionSetupExchange->pActualBuffer != NULL) {
        RxFreePool(pExtSessionSetupExchange->pActualBuffer);
    }

    if (pExtSessionSetupExchange->pServerResponseBlob != NULL) {
        RxFreePool(pExtSessionSetupExchange->pServerResponseBlob);
    }

    // Normally discrading the exchange results in the session state being
    // updated. In order to avoid race conditions between those exchanges
    // which are awaiting this construction and the updating of the session
    // state it is done locally. COnsequently the exchange state needs to be
    // updated so the the discard routine does not attempt it again.

    pExtSessionSetupExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;

    SmbCeDiscardExchange(
        (PSMB_EXCHANGE)pExtSessionSetupExchange);
}


NTSTATUS
SmbExtSecuritySessionSetupExchangeStart(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange;

    PSMB_HEADER                         pSmbHeader;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX pSessionSetupRequest;
    PGENERIC_ANDX                       pGenericAndX;

    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    ULONG       SmbBufferUnconsumed;
    USHORT      Flags2 = 0;

    PAGED_CODE();

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

    pExtSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;

    if (!pExtSessionSetupExchange->FirstSessionSetup) {
        if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_USER_SESSION_DELETED;
        }
    }

    ASSERT((pExtSessionSetupExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) &&
           (pExtSessionSetupExchange->pBuffer != NULL) &&
           (pExtSessionSetupExchange->pBufferAsMdl != NULL));

    SmbCeLog(("ExtSecSessSetup - %lx %lx\n",
              pExtSessionSetupExchange->pServerResponseBlob, pSessionEntry));
    SmbLog(LOG,
           SmbExtSecuritySessionSetupExchangeStart,
           LOGPTR(pExtSessionSetupExchange->pServerResponseBlob)
           LOGPTR(pSessionEntry));

    pSmbHeader = (PSMB_HEADER)(pExtSessionSetupExchange->pBuffer);

    // Fill in the buffer header
    pSessionSetupRequest = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)(pSmbHeader + 1);
    pGenericAndX         = (PGENERIC_ANDX)pSessionSetupRequest;

    SmbBufferUnconsumed = pExtSessionSetupExchange->BufferLength - sizeof(SMB_HEADER);

    Flags2 |= (SMB_FLAGS2_UNICODE |
               SMB_FLAGS2_KNOWS_EAS |
               SMB_FLAGS2_KNOWS_LONG_NAMES |
               SMB_FLAGS2_NT_STATUS |
               SMB_FLAGS2_EXTENDED_SECURITY);

    *((PULONG)&pSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    pSmbHeader->Flags      = (SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS);
    pSmbHeader->Flags2     = Flags2;
    pSmbHeader->Pid        = MRXSMB_PROCESS_ID;
    pSmbHeader->Uid        = pSessionEntry->Session.UserId;
    pSmbHeader->Tid        = 0;
    pSmbHeader->ErrorClass = 0;
    pSmbHeader->Reserved   = 0;
    pSmbHeader->Command    = SMB_COM_SESSION_SETUP_ANDX;
    SmbPutUshort(&pSmbHeader->Error,0);

    if (MRxSmbSecuritySignaturesEnabled) {
        pSmbHeader->Flags2 |= SMB_FLAGS2_SMB_SECURITY_SIGNATURE;
    }
    
    // Build the session setup and x.
    Status = SMBCE_SERVER_DIALECT_DISPATCH(
                 &pServerEntry->Server,
                 BuildSessionSetup,
                 (pExchange,
                  pGenericAndX,
                  &SmbBufferUnconsumed));

    if (Status == STATUS_SUCCESS) {
        // Update the buffer for the construction of the following SMB.
        SmbPutUshort(
            &pSessionSetupRequest->AndXOffset,
            (USHORT)(pExtSessionSetupExchange->BufferLength - SmbBufferUnconsumed));

        pSessionSetupRequest->AndXCommand  = SMB_COM_NO_ANDX_COMMAND;
        pSessionSetupRequest->AndXReserved = 0;

        if (pServerEntry->SecuritySignaturesEnabled &&
            !pServerEntry->SecuritySignaturesActive) {
            RtlCopyMemory(pSmbHeader->SecuritySignature,InitialSecuritySignature,SMB_SECURITY_SIGNATURE_LENGTH);
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeTranceive(
                     pExchange,
                     (RXCE_SEND_PARTIAL | RXCE_SEND_SYNCHRONOUS),
                     pExtSessionSetupExchange->pBufferAsMdl,
                     (pExtSessionSetupExchange->BufferLength -
                     SmbBufferUnconsumed));

        RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
    }


    return Status;
}

NTSTATUS
ParseExtSecuritySessionSetupResponse(
    IN PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    IN  PSMB_HEADER pSmbHeader)
/*++

Routine Description:

    This is the routine used to parse the extended session setup response from
    the server.

Arguments:

    pExtSessionSetupExchange -- the exchange instance

    BytesIndicated  -- the number of bytes indicated

    BytesAvailable  -- the total number of bytes sent by the server

    pSmbHeader      -- the SMB header ( beginning of the response)

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    ULONG    ResponseLength;
    PRESP_NT_EXTENDED_SESSION_SETUP_ANDX pSessionSetupResponse;

    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    if (BytesIndicated < sizeof(SMB_HEADER) + 1) {
        // Abort the exchange. No further processing can be done.
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    pSessionEntry = SmbCeGetExchangeSessionEntry(pExtSessionSetupExchange);

    pSessionSetupResponse = (PRESP_NT_EXTENDED_SESSION_SETUP_ANDX)(pSmbHeader + 1);

    if ((pSessionSetupResponse->WordCount != 4) &&
        (pSessionSetupResponse->WordCount != 0)) {
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    // Parse the header and extract the status. The status has special significance
    // for further processing. If the server returns a BLOB and
    // STATUS_MORE_PROCESSING_REQUIRED additional round trips are required.

    pExtSessionSetupExchange->Status = GetSmbResponseNtStatus(pSmbHeader,(PSMB_EXCHANGE)pExtSessionSetupExchange);

    // Mask the errors returned by the security packagte on the server
    if (pExtSessionSetupExchange->Status == STATUS_INVALID_HANDLE) {
        pExtSessionSetupExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    //if no blob came back.....just get out
    if (pSessionSetupResponse->WordCount == 0) {
        pExtSessionSetupExchange->ServerResponseBlobLength = 0;

        return STATUS_SUCCESS;
    }

    // Squirrel away the UID on the first response. This UID needs to be used in
    // subsequent trips to complete the session establishment as it identifies
    // the session to the server.

    pSessionEntry->Session.UserId = pSmbHeader->Uid;

    if (FlagOn(SmbGetUshort(&pSessionSetupResponse->Action), SMB_SETUP_GUEST)) {
        pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_GUEST_SESSION;
    }

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseExtSecuritySessionSetupResponse BytesIndicated %ld\n",BytesIndicated));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseExtSecuritySessionSetupResponse BytesAvailable %ld\n",BytesAvailable));

    // The bytes indicated should be atleast cover the SMB_HEADER and the
    // session setup response ( fixed portion )
    ResponseLength = sizeof(SMB_HEADER) +
                     FIELD_OFFSET(
                        RESP_NT_EXTENDED_SESSION_SETUP_ANDX,
                        Buffer);

    if (BytesIndicated > ResponseLength) {

        // Compute the extended session setup response length.
        pExtSessionSetupExchange->ResponseLength =
            ResponseLength +
            SmbGetUshort(
            &pSessionSetupResponse->ByteCount);

        RxDbgTrace(0,Dbg,("Kerberos session setup response length %ld\n",pExtSessionSetupExchange->ResponseLength));

        if (BytesIndicated < pExtSessionSetupExchange->ResponseLength) {
            // Set up the response for copying the data.
            if (pExtSessionSetupExchange->ResponseLength > pExtSessionSetupExchange->BufferLength) {
                Status = STATUS_BUFFER_OVERFLOW;
            } else {
                Status = pExtSessionSetupExchange->Reparse
                             ? STATUS_MORE_PROCESSING_REQUIRED
                             : STATUS_INVALID_NETWORK_RESPONSE;
            }

            pExtSessionSetupExchange->Status = Status;
        } else {
            // set up the offsets in the response.
            pExtSessionSetupExchange->ServerResponseBlobOffset =
                sizeof(SMB_HEADER) +
                FIELD_OFFSET(
                    RESP_NT_EXTENDED_SESSION_SETUP_ANDX,
                    Buffer);

            pExtSessionSetupExchange->ServerResponseBlobLength =
                pSessionSetupResponse->SecurityBlobLength;

            // Copy the response onto the buffer associated with the exchange.
            RtlCopyMemory(
                pExtSessionSetupExchange->pBuffer,
                pSmbHeader,
                pExtSessionSetupExchange->ResponseLength);

            Status = STATUS_SUCCESS;
        }
    } else {
        // Abort the exchange. No further processing can be done.
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        pExtSessionSetupExchange->Status = Status;
    }
    
    return Status;
}

NTSTATUS
SmbExtSecuritySessionSetupExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL  *pDataBufferPointer,
    OUT PULONG pDataSize,
    IN ULONG  ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status;

    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    ULONG    SessionSetupResponseLength = 0;

    pExtSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;

    if (pServerEntry->SecuritySignaturesEnabled &&
        !pServerEntry->SecuritySignaturesActive &&
        RtlCompareMemory(pSmbHeader->SecuritySignature,
                         InitialSecuritySignature,
                         SMB_SECURITY_SIGNATURE_LENGTH) != SMB_SECURITY_SIGNATURE_LENGTH) {
        pExtSessionSetupExchange->pResumptionContext->SecuritySignatureReturned = TRUE;
    }

    // Parse the response.
    Status = ParseExtSecuritySessionSetupResponse(
                 pExtSessionSetupExchange,
                 BytesIndicated,
                 BytesAvailable,
                 pSmbHeader);

    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
        *pBytesTaken = BytesAvailable;
        Status = STATUS_SUCCESS;
    } else {
        *pBytesTaken        = 0;
        *pDataBufferPointer = pExtSessionSetupExchange->pBufferAsMdl;
        *pDataSize          = pExtSessionSetupExchange->ResponseLength;
    }

    return Status;
}

NTSTATUS
SmbExtSecuritySessionSetupExchangeSendCompletionHandler(
    IN PSMB_EXCHANGE 	pExchange,    // The exchange instance
    IN PMDL       pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    return STATUS_SUCCESS;
}

NTSTATUS
SmbExtSecuritySessionSetupExchangeCopyDataHandler(
    IN PSMB_EXCHANGE 	pExchange,    // The exchange instance
    IN PMDL             pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange;
    PSMB_HEADER                      pSmbHeader;

    pExtSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;

    pSmbHeader        = (PSMB_HEADER)(pExtSessionSetupExchange->pBuffer);

    Status = ParseExtSecuritySessionSetupResponse(
                 pExtSessionSetupExchange,
                 DataSize,
                 DataSize,
                 pSmbHeader);

    // At this time the parse routine cannot return STATUS_MORE_PROCESSING_REQUIRED
    // as the entire response has been consumed.

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        DbgPrint("Mapping Incomplete Server Response to Invalid Response\n");
        SmbLogError(Status,
                    LOG,
                    SmbExtSecuritySessionSetupExchangeCopyDataHandler,
                    LOGPTR(pExtSessionSetupExchange));
        pExtSessionSetupExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbExtSecuritySessionSetupExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalkzes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange;
    PSMBCE_RESUMPTION_CONTEXT            pResumptionContext;

    pExtSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;

    if (!pExtSessionSetupExchange->RequestPosted) {
        pExtSessionSetupExchange->RequestPosted = TRUE;
        *pPostFinalize = TRUE;
        return STATUS_SUCCESS;
    } else {
        // reset the flag since the exchange will be reused
        pExtSessionSetupExchange->RequestPosted = FALSE;
        *pPostFinalize = FALSE;
    }

    // Determine if further processing is required. If not finalize the
    // session entry.
    RxDbgTrace(0,Dbg,
              ("SmbExtSecuritySessionSetupExchangeFinalize: pESSExchange->Status = %lx\n",pExtSessionSetupExchange->Status));

    // If the server returned STATUS_MORE_PROCESSING_REQUIRED and a BLOB was present
    // another trip to the server is required and we start all over again.

    if ((Status = pExtSessionSetupExchange->Status) != STATUS_MORE_PROCESSING_REQUIRED) {

        // The server returned an error other than STATUS_MORE_PROCESSING_REQUIRED
        // The session establishment can be completed based on whether the server
        // returned a BLOB. If a BLOB was returned it needs to be passed to the
        // local security package. This will enable the local security package to
        // either complete the session establishment successfully or to extract
        // extended error information from the BLOB. This can in turn be used to
        // propogate more meaningful errors to the client.

        if (Status == STATUS_SUCCESS &&
            pExtSessionSetupExchange->ServerResponseBlobLength != 0) {
            PVOID pServerResponseBlob;

            // If we are not going back to the server an additional copy of the
            // server response BLOB is not required.

            pServerResponseBlob =
                ((PBYTE)pExtSessionSetupExchange->pBuffer +
                 pExtSessionSetupExchange->ServerResponseBlobOffset);

            Status = ValidateServerExtendedSessionSetupResponse(
                         pExtSessionSetupExchange,
                         pServerResponseBlob,
                         pExtSessionSetupExchange->ServerResponseBlobLength);
        }
    } else {
        // Make a copy of the server response blob so that the new session setup SMB
        // can be constructed

        if (pExtSessionSetupExchange->ServerResponseBlobLength != 0) {
            if (pExtSessionSetupExchange->pServerResponseBlob != NULL) {
                RxFreePool(pExtSessionSetupExchange->pServerResponseBlob);
            }

            pExtSessionSetupExchange->pServerResponseBlob =
                RxAllocatePoolWithTag(
                    PagedPool,
                    pExtSessionSetupExchange->ServerResponseBlobLength,
                    MRXSMB_KERBEROS_POOLTAG);

            if (pExtSessionSetupExchange->pServerResponseBlob != NULL) {
                RtlCopyMemory(
                    pExtSessionSetupExchange->pServerResponseBlob,
                    ((PBYTE)pExtSessionSetupExchange->pBuffer +
                     pExtSessionSetupExchange->ServerResponseBlobOffset),
                    pExtSessionSetupExchange->ServerResponseBlobLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        PMRX_V_NET_ROOT pVNetRoot;
        USHORT          SmbCeFlags;
        PRX_CONTEXT     RxContext;

        pVNetRoot = pExtSessionSetupExchange->SmbCeContext.pVNetRoot;
        RxContext = pExtSessionSetupExchange->RxContext;

        // This is required so that the session state is not effected as the exchange
        // is prepared for reuse. This will enable us to avoid redundant initialization
        // as well as to carry over the state from one trip to another easily.

        ClearFlag(
            pExtSessionSetupExchange->SmbCeFlags,
            SMBCE_EXCHANGE_SESSION_CONSTRUCTOR);

        SmbCePrepareExchangeForReuse((PSMB_EXCHANGE)pExtSessionSetupExchange);

        // Note: By invoking SmbCeInitializeExchange as opposed to
        // SmbCeInitializeExtendedSessionSetupExchange only the connection engine
        // portion of the exchange is initialized. This will enable us to carry
        // over the state ( the server response BLOB ) from one trip to another
        // easily.

        Status = SmbCeInitializeExchange(
                    (PSMB_EXCHANGE *)&pExtSessionSetupExchange,
                    NULL,
                    pVNetRoot,
                    EXTENDED_SESSION_SETUP_EXCHANGE,
                    &ExtendedSessionSetupExchangeDispatch);

        if (Status == STATUS_SUCCESS) {
            pExtSessionSetupExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;
            pExtSessionSetupExchange->RxContext = RxContext;

            // Avoid duplicate counting during Exchange Initialization.
            SmbCeDecrementActiveExchangeCount();

            // Set the session echange state to SMBCE_EXCHANGE_SESSION_INITIALIZED
            // so that the connection engine does not queue up the request the normal
            // way. This will force the connection engine to initiate immediately.

            pExtSessionSetupExchange->SmbCeState = SMBCE_EXCHANGE_SESSION_INITIALIZED;

            Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pExtSessionSetupExchange);
        }
    }

    
    if (Status != STATUS_PENDING) {
        PSMBCEDB_SERVER_ENTRY  pServerEntry;
        PSMBCEDB_SESSION_ENTRY pSessionEntry;

        SMBCEDB_OBJECT_STATE   SessionState;

        RxDbgTrace(0,Dbg,("Kerberos Exchange Session Final Status(%lx)\n",Status));

        pServerEntry  = SmbCeGetExchangeServerEntry(pExtSessionSetupExchange);
        pSessionEntry = SmbCeGetExchangeSessionEntry(pExtSessionSetupExchange);

        pResumptionContext = pExtSessionSetupExchange->pResumptionContext;

        // Tear down the exchange instance ...
        SmbCeDiscardExtendedSessionSetupExchange(pExtSessionSetupExchange);

        if (pResumptionContext != NULL) {
            pResumptionContext->Status = Status;
            SmbCeResume(pResumptionContext);
        }
    }

    return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
ExtendedSessionSetupExchangeDispatch =
                                   {
                                       SmbExtSecuritySessionSetupExchangeStart,
                                       SmbExtSecuritySessionSetupExchangeReceive,
                                       SmbExtSecuritySessionSetupExchangeCopyDataHandler,
                                       NULL,
                                       SmbExtSecuritySessionSetupExchangeFinalize,
                                       NULL
                                   };


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\fsctl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file
    system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

    Joe Linn                [JoeLi] -- Implemented FSCTL's

--*/

#include "precomp.h"
#pragma hdrstop

#include <dfsfsctl.h>
#include <ntddrdr.h>
#include <wincred.h>
#include <secpkg.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFsCtl)
#pragma alloc_text(PAGE, MRxSmbNotifyChangeDirectory)
#pragma alloc_text(PAGE, MRxSmbNamedPipeFsControl)
#pragma alloc_text(PAGE, MRxSmbFsCtlUserTransact)
#pragma alloc_text(PAGE, MRxSmbMailSlotFsControl)
#pragma alloc_text(PAGE, MRxSmbFsControl)
#pragma alloc_text(PAGE, MRxSmbIoCtl)
#endif

//
//  The local debug trace level
//


RXDT_DefineCategory(FSCTRL);
#define Dbg (DEBUG_TRACE_FSCTRL)

extern
NTSTATUS
MRxSmbNamedPipeFsControl(IN OUT PRX_CONTEXT RxContext);

extern
NTSTATUS
MRxSmbMailSlotFsControl(IN OUT PRX_CONTEXT RxContext);

extern
NTSTATUS
MRxSmbDfsFsControl(IN OUT PRX_CONTEXT RxContext);

extern
NTSTATUS
MRxSmbFsControl(IN OUT PRX_CONTEXT RxContext);

extern
NTSTATUS
MRxSmbFsCtlUserTransact(IN OUT PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbGetPrintJobId(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbCoreIoCtl(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE);

NTSTATUS
MRxSmbQueryTargetInfo(
    PRX_CONTEXT RxContext
    );


NTSTATUS
MRxSmbFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    RxCaptureFobx;
    RxCaptureFcb;

    NTSTATUS Status = STATUS_SUCCESS;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFsCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbFsCtl = %08lx\n", FsControlCode));

    if (capFobx != NULL) {
        PMRX_V_NET_ROOT pVNetRoot;

        // Avoid device opens for which the FOBX is the VNET_ROOT instance

        pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

        if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
            PUNICODE_STRING AlreadyPrefixedName =
                        GET_ALREADY_PREFIXED_NAME(capFobx->pSrvOpen,capFcb);
            ULONG FcbAlreadyPrefixedNameLength = AlreadyPrefixedName->Length;
            ULONG NetRootInnerNamePrefixLength = capFcb->pNetRoot->InnerNamePrefix.Length;
            PWCHAR pName = AlreadyPrefixedName->Buffer;

            // If an FSCTL is being attempted against the root of a share.
            // The AlreadyPrefixedName associated with the FCB is the same as
            // the AlreadyPrefixedName length associated with the NET_ROOT instance
            // or atmost one character greater than it ( appending a \) try and
            // reestablish the connection before attempting the FSCTL.
            // This solves thorny issues regarding deletion/creation of shares
            // on the server sides, DFS referrals etc.

            if ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength) ||
                ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength + sizeof(WCHAR)) &&
                 (*((PCHAR)pName + FcbAlreadyPrefixedNameLength - sizeof(WCHAR)) ==
                     L'\\'))) {
                if (capFobx->pSrvOpen != NULL) {
                    Status = SmbCeReconnect(capFobx->pSrvOpen->pVNetRoot);
                }
            }
        }
    }

    if (Status == STATUS_SUCCESS) {
        switch (pLowIoContext->ParamsFor.FsCtl.MinorFunction) {
        case IRP_MN_USER_FS_REQUEST:
        case IRP_MN_TRACK_LINK     :
            switch (FsControlCode) {
            case FSCTL_PIPE_ASSIGN_EVENT         :
            case FSCTL_PIPE_DISCONNECT           :
            case FSCTL_PIPE_LISTEN               :
            case FSCTL_PIPE_PEEK                 :
            case FSCTL_PIPE_QUERY_EVENT          :
            case FSCTL_PIPE_TRANSCEIVE           :
            case FSCTL_PIPE_WAIT                 :
            case FSCTL_PIPE_IMPERSONATE          :
            case FSCTL_PIPE_SET_CLIENT_PROCESS   :
            case FSCTL_PIPE_QUERY_CLIENT_PROCESS :
                Status = MRxSmbNamedPipeFsControl(RxContext);
                break;
            case FSCTL_MAILSLOT_PEEK :
                Status = MRxSmbMailSlotFsControl(RxContext);
                break;
            case FSCTL_DFS_GET_REFERRALS:
            case FSCTL_DFS_REPORT_INCONSISTENCY:
                Status = MRxSmbDfsFsControl(RxContext);
                break;
            case FSCTL_LMR_TRANSACT :
                Status = MRxSmbFsCtlUserTransact(RxContext);
                break;

            case FSCTL_GET_PRINT_ID :
                Status = MRxSmbGetPrintJobId(RxContext);
                break;

            case FSCTL_LMR_QUERY_TARGET_INFO:
                Status = MRxSmbQueryTargetInfo(RxContext);
                break;

            case FSCTL_MOVE_FILE:
            case FSCTL_MARK_HANDLE:
            case FSCTL_QUERY_RETRIEVAL_POINTERS:
            case FSCTL_GET_VOLUME_BITMAP:
            case FSCTL_GET_NTFS_FILE_RECORD:
                Status = STATUS_NOT_SUPPORTED;
                break;


            case FSCTL_SET_REPARSE_POINT:
            {
                ULONG  InputBufferLength      = 0;  //  invalid value as we need an input buffer
                PREPARSE_DATA_BUFFER prdBuff = (&RxContext->LowIoContext)->ParamsFor.FsCtl.pInputBuffer;
                PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

                InputBufferLength = (&RxContext->LowIoContext)->ParamsFor.FsCtl.InputBufferLength;

                if ((prdBuff == NULL)||
                    (InputBufferLength < REPARSE_DATA_BUFFER_HEADER_SIZE)||
                    (InputBufferLength > MAXIMUM_REPARSE_DATA_BUFFER_SIZE))
                {
                    Status = STATUS_IO_REPARSE_DATA_INVALID;
                    break;
                }

                //
                //  Verify that the user buffer and the data length in its header are
                //  internally consistent. We need to have a REPARSE_DATA_BUFFER or a
                //  REPARSE_GUID_DATA_BUFFER.
                //

                if((InputBufferLength != (ULONG)(REPARSE_DATA_BUFFER_HEADER_SIZE + prdBuff->ReparseDataLength))
                   &&
                    (InputBufferLength != (ULONG)(REPARSE_GUID_DATA_BUFFER_HEADER_SIZE + prdBuff->ReparseDataLength)))
                {
                    Status = STATUS_IO_REPARSE_DATA_INVALID;
                    break;
                }
            }
            case FSCTL_GET_REPARSE_POINT:
            // absence of break intentional
            case FSCTL_MARK_AS_SYSTEM_HIVE :

                //
                // On a remote boot machine, we need to no-op the MARK_AS_SYSTEM_HIVE
                // FSCTL. Local filesystems use this to prevent a volume from being
                // dismounted.
                //

                if (MRxSmbBootedRemotely) {
                    break;
                }

            default:
                Status = MRxSmbFsControl(RxContext);
                break;
            }
            break;
        default :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFsCtl -> %08lx\n", Status ));
    return Status;
}

typedef struct _SMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT_ {
    LONG                                ReferenceCount;
    PRX_CONTEXT                         pRxContext;
    REQ_NOTIFY_CHANGE                   NotifyRequest;
    SMB_TRANSACTION_OPTIONS             Options;
    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
} SMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT, *PSMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT;


NTSTATUS
MRxSmbNotifyChangeDirectorySynchronousCompletion(
   PSMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext)
/*++

Routine Description:

   This routine is invoked when a directory change notification operation is
   completed

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine will always be called. This is true even if the change directory
    notification is cancelled. In such cases the memory allocated is freed without
    any interaction with the wrapper. In cases of successful directory change
    notification completion the appropriate completion routine is invoked and the
    RxContext modified to prevent any cancellation from proceeding further.

--*/
{
    NTSTATUS           Status = STATUS_PENDING;
    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PRX_CONTEXT        pRxContext;
    PSMB_EXCHANGE      pExchange = NULL;
    BOOLEAN            FinalizeNotificationContext = FALSE;

    SmbCeAcquireSpinLock();

    FinalizeNotificationContext =
        (InterlockedDecrement(&pNotificationContext->ReferenceCount) == 0);

    if (FinalizeNotificationContext) {
        pRxContext  = pNotificationContext->pRxContext;

        pMRxSmbContext    = MRxSmbGetMinirdrContext(pRxContext);
        pExchange         = pMRxSmbContext->pExchange;

        Status = pRxContext->StoredStatus;
    }

    SmbCeReleaseSpinLock();

    // Free the associated exchange.
    if (FinalizeNotificationContext) {
        if (pExchange != NULL) {
            SmbCeDereferenceAndDiscardExchange(pExchange);
        }

        // Free the notification context.
        RxFreePool(pNotificationContext);

        ASSERT(Status != STATUS_PENDING);
    }

    return Status;
}

VOID
MRxSmbNotifyChangeDirectoryCompletion(
   PSMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext)
/*++

Routine Description:

   This routine is invoked when a directory change notification operation is
   completed

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine will always be called. This is true even if the change directory
    notification is cancelled. In such cases the memory allocated is freed without
    any inteaction with the wrapper. In cases of successful directory change
    notification completion the appropriate completion routine is invoked and the
    RxContext modified to prevent any cancellation from proceeding further.

--*/
{
    NTSTATUS           Status;
    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PRX_CONTEXT        pRxContext;
    PSMB_EXCHANGE      pExchange = NULL;
    BOOLEAN            FinalizeNotificationContext = FALSE;

    SmbCeAcquireSpinLock();

    FinalizeNotificationContext =
        (InterlockedDecrement(&pNotificationContext->ReferenceCount) == 0);

    pRxContext  = pNotificationContext->pRxContext;

    if (pRxContext != NULL) {
        PSMB_TRANSACT_EXCHANGE pTransactExchange;

        pMRxSmbContext    = MRxSmbGetMinirdrContext(pRxContext);
        pExchange         = pMRxSmbContext->pExchange;

        if (pExchange != NULL) {
            PSMBCEDB_SERVER_ENTRY pServerEntry;

            pTransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

            pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

            if ((pNotificationContext->ResumptionContext.FinalStatusFromServer ==
                STATUS_NOT_SUPPORTED) ||
                (pNotificationContext->ResumptionContext.FinalStatusFromServer ==
                STATUS_NOT_IMPLEMENTED)) {
                pServerEntry->Server.ChangeNotifyNotSupported = TRUE;
            }

            pRxContext->InformationToReturn = pTransactExchange->ParamBytesReceived;
        } else {
            pRxContext->InformationToReturn = 0;
        }

        pRxContext->StoredStatus =
            pNotificationContext->ResumptionContext.FinalStatusFromServer;

        if( (pRxContext->InformationToReturn == 0) &&
            (pRxContext->StoredStatus == STATUS_SUCCESS) )
        {
            pRxContext->StoredStatus = STATUS_NOTIFY_ENUM_DIR;
        }

    }

    SmbCeReleaseSpinLock();

    if (FinalizeNotificationContext) {
        if (pRxContext != NULL) {
            RxLowIoCompletion(pRxContext);
        }

        // Free the associated exchange.
        if (pExchange != NULL) {
            SmbCeDereferenceAndDiscardExchange(pExchange);
        }

        // Free the notification context.
        RxFreePool(pNotificationContext);
    }
}

NTSTATUS
MRxSmbNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    A directory change notification opertaion is an asychronous operation. It
    consists of sending a SMB requesting change notification whose response is
    obtained when the desired change is affected on the server.

    Some important points to remember are as follows .....

      1) The SMB response is not obtained till the desired change is affected on
      the server. Therefore an additional MID needs to be reserved on those
      connections which permit multiple MID's so that a cancel SMB can be sent to
      the server when a change notification is active.

      2) The Change notification is typical of a long term ( response time
      dictated by factors beyond the servers control). Another example is
      the query FSCTL operation in CAIRO. For all these operations we initiate
      an asychronous transact exchange.

      3) The corresponding LowIo completion routine is invoked asynchronously.

      4) This is an example of an operation for which the MINI RDR has to
      register a context for handling cancellations initiated locally.

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    // if the server entry is in disconnected state, then let CSC do change notify
    // If successful, the CSC routine should return a STATUS_PENDING and
    // modify the rxcontext in way that is suitable to the underlying implementation

    // In the current incarnation, the CSC routine will
    // a) remove the irp from the rxconetxt and b) dereference the rxcontext

    if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)||
        SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        return MRxSmbCscNotifyChangeDirectory(RxContext);
    }
    else if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS) ||
             pServerEntry->Server.ChangeNotifyNotSupported) {
        return STATUS_NOT_SUPPORTED;
    }

#if defined(REMOTE_BOOT)
    //
    // Reject change notify on the remote boot share. This is necessary to
    // prevent overloading the server with long-term requests. (There are
    // LOTS of change notifies posted on the boot device!)
    //

    if (MRxSmbBootedRemotely) {
        PSMBCE_SESSION pSession;
        pSession = &SmbCeGetAssociatedVNetRootContext(capFobx->pSrvOpen->pVNetRoot)->pSessionEntry->Session;
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
            return STATUS_NOT_SUPPORTED;
        }
    }
#endif

    pNotificationContext =
        (PSMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT)
        RxAllocatePoolWithTag(
            NonPagedPool,
            sizeof(SMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT),
            MRXSMB_FSCTL_POOLTAG);

    if (pNotificationContext != NULL) {
        PREQ_NOTIFY_CHANGE                  pNotifyRequest;
        PSMB_TRANSACTION_OPTIONS            pTransactionOptions;
        PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext;
        PMRX_SMB_SRV_OPEN                   pSmbSrvOpen;

        BOOLEAN FcbAcquired = FALSE;

        RxCaptureFobx;
        ASSERT (capFobx != NULL);

        if (!RxIsFcbAcquiredExclusive(capFcb)) {
            // ASSERT(!RxIsFcbAcquiredShared(capFcb));
            Status = RxAcquireExclusiveFcbResourceInMRx( capFcb );

            FcbAcquired = (Status == STATUS_SUCCESS);
        }

        if (FcbAcquired) {
            if (FlagOn(capFobx->pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED) ||
               FlagOn(capFobx->pSrvOpen->Flags,SRVOPEN_FLAG_ORPHANED)) {
               Status = STATUS_FILE_CLOSED;
            } else {
               Status = MRxSmbDeferredCreate(RxContext);
            }

            RxReleaseFcbResourceInMRx( capFcb );
        }

        if (Status==STATUS_SUCCESS) {

            pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

            pNotificationContext->pRxContext = RxContext;
            // The reference count is set to 2. one for the async completion routine
            // and one for the tail completion routine
            pNotificationContext->ReferenceCount = 2;

            pNotifyRequest      = &(pNotificationContext->NotifyRequest);
            pTransactionOptions = &(pNotificationContext->Options);
            pResumptionContext  = &(pNotificationContext->ResumptionContext);

            pNotifyRequest->CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
            pNotifyRequest->Fid              = pSmbSrvOpen->Fid;
            pNotifyRequest->WatchTree        = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;
            pNotifyRequest->Reserved         = 0;

            OutputParamBufferLength  = pLowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength;
            pOutputParamBuffer       = pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer;

            *pTransactionOptions = RxDefaultTransactionOptions;
            pTransactionOptions->NtTransactFunction = NT_TRANSACT_NOTIFY_CHANGE;
            pTransactionOptions->TimeoutIntervalInMilliSeconds = SMBCE_TRANSACTION_TIMEOUT_NOT_USED;
            pTransactionOptions->Flags = SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE;

            SmbCeInitializeAsynchronousTransactionResumptionContext(
                pResumptionContext,
                MRxSmbNotifyChangeDirectoryCompletion,
                pNotificationContext);

            Status = SmbCeAsynchronousTransact(
                         RxContext,                    // the RXContext for the transaction
                         pTransactionOptions,          // transaction options
                         pNotifyRequest,               // the setup buffer
                         sizeof(REQ_NOTIFY_CHANGE),    // setup buffer length
                         NULL,
                         0,
                         pInputParamBuffer,            // Input Param Buffer
                         InputParamBufferLength,       // Input param buffer length
                         pOutputParamBuffer,           // Output param buffer
                         OutputParamBufferLength,      // output param buffer length
                         pInputDataBuffer,             // Input data buffer
                         InputDataBufferLength,        // Input data buffer length
                         pOutputDataBuffer,            // output data buffer
                         OutputDataBufferLength,       // output data buffer length
                         pResumptionContext            // the resumption context
                         );

            ASSERT(Status == STATUS_PENDING);

            Status = MRxSmbNotifyChangeDirectorySynchronousCompletion(
                         pNotificationContext);

        }  else {
            NOTHING; //just return the status from the deferred open call
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)||
        SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        return MRxSmbCscNotifyChangeDirectory(RxContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbNotifyChangeDirectory -> %08lx\n", Status ));
    return Status;
}

UNICODE_STRING s_NamedPipeTransactionName = { 12,12,L"\\PIPE\\" };
UNICODE_STRING s_MailSlotTransactionName  = {20,20,L"\\MAILSLOT\\" };

typedef struct _SMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT_ {
    LONG                                ReferenceCount;
    PRX_CONTEXT                         pRxContext;
    PWCHAR                              pTransactionNameBuffer;
    SMB_TRANSACTION_OPTIONS             Options;
    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
} SMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT,
  *PSMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT;

VOID
MRxSmbNamedPipeFsControlCompletion(
    PSMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT pFsCtlCompletionContext)
{
    PRX_CONTEXT   pRxContext = NULL;
    PSMB_EXCHANGE pExchange = NULL;
    BOOLEAN       FinalizeFsCtlCompletionContext = FALSE;

    SmbCeAcquireSpinLock();

    FinalizeFsCtlCompletionContext =
        (InterlockedDecrement(&pFsCtlCompletionContext->ReferenceCount) == 0);

    if (FinalizeFsCtlCompletionContext) {
        pRxContext  = pFsCtlCompletionContext->pRxContext;

        if (pRxContext != NULL) {
            PMRXSMB_RX_CONTEXT pMRxSmbContext;

            pMRxSmbContext    = MRxSmbGetMinirdrContext(pRxContext);
            pExchange         = pMRxSmbContext->pExchange;
        }
    }

    SmbCeReleaseSpinLock();

    if (FinalizeFsCtlCompletionContext) {
        if (pRxContext != NULL) {
            pRxContext->StoredStatus =
                pFsCtlCompletionContext->ResumptionContext.FinalStatusFromServer;

            if (pRxContext->StoredStatus == STATUS_INVALID_HANDLE) {
                pRxContext->StoredStatus = STATUS_INVALID_NETWORK_RESPONSE;
            }

            pRxContext->InformationToReturn =
                pFsCtlCompletionContext->ResumptionContext.DataBytesReceived;

            RxLowIoCompletion(pRxContext);
        }

        if (pExchange != NULL) {
            SmbCeDereferenceAndDiscardExchange(pExchange);
        }

        if (pFsCtlCompletionContext->pTransactionNameBuffer != NULL) {
            RxFreePool(pFsCtlCompletionContext->pTransactionNameBuffer);
        }

        RxFreePool(pFsCtlCompletionContext);
    }
}

NTSTATUS
MRxSmbNamedPipeFsControl(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine handles all named pipe related FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   RxCaptureFobx;
   RxCaptureFcb;

   PMRX_SMB_SRV_OPEN pSmbSrvOpen;

   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
   ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;
   UNICODE_STRING TransactionName;

   BOOLEAN        ReestablishConnectionIfRequired = FALSE, fTransactioNameBufferAllocated = FALSE;

   NTSTATUS Status;
   USHORT Setup[2];

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   ULONG  TimeoutIntervalInMilliSeconds;

   RESP_PEEK_NMPIPE PeekResponse;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbNamedPipeFsControl...\n", 0));

   TimeoutIntervalInMilliSeconds = SMBCE_TRANSACTION_TIMEOUT_NOT_USED;
   Status = STATUS_MORE_PROCESSING_REQUIRED;

   if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_FILE &&
       NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_UNKNOWN ||
       capFcb->pNetRoot == NULL ||
       capFcb->pNetRoot->Type != NET_ROOT_PIPE) {
       return STATUS_INVALID_DEVICE_REQUEST;
   }

   if (capFobx != NULL) {
      pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
   } else {
      pSmbSrvOpen = NULL;
   }

   // The following switch statement serves the dual purpose of validating the parameters
   // presented by the user as well as filling in the appropriate information if it is
   // available locally.
   // Currently there is no local caching strategy in place and consequently a network trip
   // is always undertaken.

   TransactionName = s_NamedPipeTransactionName;

   switch (FsControlCode) {
   case FSCTL_PIPE_PEEK :
      {
         Setup[0] = TRANS_PEEK_NMPIPE;
         Setup[1] = pSmbSrvOpen->Fid;

         pOutputParamBuffer     = (PBYTE)&PeekResponse;
         OutputParamBufferLength = sizeof(PeekResponse);

         pOutputDataBuffer = (PBYTE)pLowIoContext->ParamsFor.FsCtl.pOutputBuffer +
                             FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER,Data[0]);
         OutputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength -
                                  FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER,Data[0]);
      }
      break;
   case FSCTL_PIPE_TRANSCEIVE :
      {
         Setup[0] = TRANS_TRANSACT_NMPIPE;
         Setup[1] = pSmbSrvOpen->Fid;

         pInputDataBuffer = pLowIoContext->ParamsFor.FsCtl.pInputBuffer;
         InputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;

         pOutputDataBuffer = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
         OutputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;

         // CODE.IMPROVEMENT -- Currently the semantics of attempting a TRANSCEIVE
         // with zero bytes to be written is not very well defined. The Old Redirector
         // succeeds without issuing a TRANSACT request. This needs to be resolved and
         // till it is done the old semantics will be retained

         //if (InputDataBufferLength == 0) {
         //   Status = STATUS_SUCCESS;
         //}

      }
      break;
   case FSCTL_PIPE_WAIT :
        {

            PFILE_PIPE_WAIT_FOR_BUFFER  pWaitBuffer;
            ULONG NameLength;

            Setup[0] = TRANS_WAIT_NMPIPE;
            Setup[1] = 0;

            if ((pLowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL) ||
                (pLowIoContext->ParamsFor.FsCtl.InputBufferLength <
                  sizeof(FILE_PIPE_WAIT_FOR_BUFFER))) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                // Set up the transaction name to reflect the name of the pipe
                // on which the wait operation is being performed.
                pWaitBuffer = (PFILE_PIPE_WAIT_FOR_BUFFER)pLowIoContext->ParamsFor.FsCtl.pInputBuffer;

                if (pWaitBuffer->NameLength + s_NamedPipeTransactionName.Length > MAXUSHORT ||
                    pWaitBuffer->NameLength - sizeof(WCHAR) >
                    pLowIoContext->ParamsFor.FsCtl.InputBufferLength - sizeof(FILE_PIPE_WAIT_FOR_BUFFER)) {

                    // if the name is too long to be put on a UNICIDE string,
                    // or the name length doesn't match the buffer length
                    Status = STATUS_INVALID_PARAMETER;
                }
            }

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                // In the case of Wait FSCTL a reconnection attempt will be made
                // if required
                ReestablishConnectionIfRequired = TRUE;

                TransactionName.Length = (USHORT)(s_NamedPipeTransactionName.Length +
                                                  pWaitBuffer->NameLength);
                TransactionName.MaximumLength = TransactionName.Length;
                TransactionName.Buffer = (PWCHAR)RxAllocatePool(PagedPool,TransactionName.Length);
                if (TransactionName.Buffer != NULL) {
                   fTransactioNameBufferAllocated = TRUE;
                   RtlCopyMemory(TransactionName.Buffer,
                                 s_NamedPipeTransactionName.Buffer,
                                 s_NamedPipeTransactionName.Length);

                   RtlCopyMemory(
                           (PBYTE)TransactionName.Buffer + s_NamedPipeTransactionName.Length,
                           pWaitBuffer->Name,
                           pWaitBuffer->NameLength);
                } else {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (pWaitBuffer->TimeoutSpecified) {
                    LARGE_INTEGER TimeWorkspace;
                    LARGE_INTEGER WaitForever;

                    WaitForever.LowPart = 0;
                    WaitForever.HighPart =0x80000000;

                    //  Avoid negate of "WaitForever" since this generates an integer
                    //  overflow exception on some machines.

                    if (pWaitBuffer->Timeout.QuadPart != WaitForever.QuadPart) {
                        TimeWorkspace.QuadPart = -pWaitBuffer->Timeout.QuadPart / 10000;

                        if ( TimeWorkspace.HighPart) {
                            //  Tried to specify a larger timeout than we can select.
                            //  set it to the Maximum we can request
                            TimeoutIntervalInMilliSeconds = 0xfffffffe;
                        } else {
                            TimeoutIntervalInMilliSeconds = TimeWorkspace.LowPart;
                        }
                    }
                } else {
                    TimeoutIntervalInMilliSeconds = 0;
                }
            }
        }
        break;

    case FSCTL_PIPE_ASSIGN_EVENT :
    case FSCTL_PIPE_QUERY_EVENT  :
    case FSCTL_PIPE_IMPERSONATE  :
    case FSCTL_PIPE_SET_CLIENT_PROCESS :
    case FSCTL_PIPE_QUERY_CLIENT_PROCESS :
        // These FSCTL's have not been implemented so far in NT. They will be implemented
        // in a future release.
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl: Unimplemented FS control code\n"));
        break;

    case FSCTL_PIPE_DISCONNECT :
    case FSCTL_PIPE_LISTEN :
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl: Invalid FS control code for redirector\n"));
        break;

    default:
        RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl: Invalid FS control code\n"));
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        if (ReestablishConnectionIfRequired) {
            if (capFobx != NULL) {
                Status = SmbCeReconnect(capFobx->pSrvOpen->pVNetRoot);
            } else {
                Status = STATUS_SUCCESS;
            }
        } else {
            Status = STATUS_SUCCESS;
        }

        if (Status == STATUS_SUCCESS) {
            PSMB_TRANSACTION_OPTIONS                 pTransactionOptions;
            PSMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT pFsCtlCompletionContext;
            PSMB_TRANSACTION_RESUMPTION_CONTEXT      pResumptionContext;

            RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl: TransactionName %ws Length %ld\n",
                              TransactionName.Buffer,TransactionName.Length));

            pFsCtlCompletionContext =
                (PSMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT)
                RxAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(SMB_NAMED_PIPE_FSCTL_COMPLETION_CONTEXT),
                    MRXSMB_FSCTL_POOLTAG);

            if (pFsCtlCompletionContext != NULL) {
                pResumptionContext  = &pFsCtlCompletionContext->ResumptionContext;
                pTransactionOptions = &(pFsCtlCompletionContext->Options);

                if (FsControlCode != FSCTL_PIPE_PEEK) {
                    // The reference count is set to 2. one for the async
                    // completion routine and one for the tail completion routine
                    pFsCtlCompletionContext->pRxContext = RxContext;
                    pFsCtlCompletionContext->ReferenceCount = 2;

                    SmbCeInitializeAsynchronousTransactionResumptionContext(
                        pResumptionContext,
                        MRxSmbNamedPipeFsControlCompletion,
                        pFsCtlCompletionContext);
                } else {
                    // Currently PEEK operations are synchronous
                    pFsCtlCompletionContext->pRxContext = NULL;
                    pFsCtlCompletionContext->ReferenceCount = 1;
                }

                *pTransactionOptions = RxDefaultTransactionOptions;
                pTransactionOptions->NtTransactFunction = 0; // TRANSACT2/TRANSACT.
                pTransactionOptions->pTransactionName   = &TransactionName;
                pTransactionOptions->Flags              = SMB_XACT_FLAGS_FID_NOT_NEEDED;
                pTransactionOptions->TimeoutIntervalInMilliSeconds = TimeoutIntervalInMilliSeconds;

                if (TransactionName.Buffer != s_NamedPipeTransactionName.Buffer) {
                    pFsCtlCompletionContext->pTransactionNameBuffer =
                        TransactionName.Buffer;
                } else {
                    pFsCtlCompletionContext->pTransactionNameBuffer = NULL;
                }

                if (FsControlCode != FSCTL_PIPE_PEEK) {
                    Status = SmbCeAsynchronousTransact(
                                RxContext,                    // the RXContext for the transaction
                                pTransactionOptions,          // transaction options
                                Setup,                        // the setup buffer
                                sizeof(Setup),                // setup buffer length
                                NULL,
                                0,
                                pInputParamBuffer,            // Input Param Buffer
                                InputParamBufferLength,       // Input param buffer length
                                pOutputParamBuffer,           // Output param buffer
                                OutputParamBufferLength,      // output param buffer length
                                pInputDataBuffer,             // Input data buffer
                                InputDataBufferLength,        // Input data buffer length
                                pOutputDataBuffer,            // output data buffer
                                OutputDataBufferLength,       // output data buffer length
                                pResumptionContext            // the resumption context
                                );

                    if (Status != STATUS_PENDING) {
                        pFsCtlCompletionContext->ResumptionContext.FinalStatusFromServer
                            = Status;
                    }

                    MRxSmbNamedPipeFsControlCompletion(pFsCtlCompletionContext);
                    Status = STATUS_PENDING;
                } else {
                    Status = SmbCeTransact(
                                RxContext,                    // the RXContext for the transaction
                                pTransactionOptions,          // transaction options
                                Setup,                        // the setup buffer
                                sizeof(Setup),                // setup buffer length
                                NULL,
                                0,
                                pInputParamBuffer,            // Input Param Buffer
                                InputParamBufferLength,       // Input param buffer length
                                pOutputParamBuffer,           // Output param buffer
                                OutputParamBufferLength,      // output param buffer length
                                pInputDataBuffer,             // Input data buffer
                                InputDataBufferLength,        // Input data buffer length
                                pOutputDataBuffer,            // output data buffer
                                OutputDataBufferLength,       // output data buffer length
                                pResumptionContext            // the resumption context
                                );

                    switch (FsControlCode) {
                    case FSCTL_PIPE_PEEK:
                        {
                            // In the case of FSCTL_PIPE_PEEK post processing is required to package the
                            // results and also handle the idiosyncracies of the different servers.
                            // e.g.,
                            //  Os/2 servers will allow PeekNamedPipe on closed pipes to succeed
                            //  even if the server side of the pipe is closed.
                            //
                            //  If we get the status PIPE_STATE_CLOSING from the server, then
                            //  we need to return an error of STATUS_PIPE_DISCONNECTED, as this
                            //  is what NPFS will do.

                            if (NT_SUCCESS(Status) ||
                                (Status == RX_MAP_STATUS(BUFFER_OVERFLOW))) {
                                if (pResumptionContext->ParameterBytesReceived >= sizeof(RESP_PEEK_NMPIPE)) {
                                    if ((SmbGetAlignedUshort(&PeekResponse.NamedPipeState) & PIPE_STATE_CLOSING) &&
                                        (PeekResponse.ReadDataAvailable == 0)) {
                                        Status = STATUS_PIPE_DISCONNECTED;
                                    } else {
                                        PFILE_PIPE_PEEK_BUFFER pPeekBuffer;

                                        pPeekBuffer = (PFILE_PIPE_PEEK_BUFFER)pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;

                                        pPeekBuffer->NamedPipeState    = (ULONG)SmbGetAlignedUshort(&PeekResponse.NamedPipeState);
                                        pPeekBuffer->ReadDataAvailable = (ULONG)PeekResponse.ReadDataAvailable;
                                        pPeekBuffer->NumberOfMessages  = MAXULONG;
                                        pPeekBuffer->MessageLength     = (ULONG)PeekResponse.MessageLength;

                                        if (PeekResponse.MessageLength > OutputDataBufferLength) {
                                            Status = STATUS_BUFFER_OVERFLOW;
                                        }
                                    }
                                }

                                RxContext->InformationToReturn =
                                    FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]) +
                                    pResumptionContext->DataBytesReceived;
                            }
                        }
                        break;

                    default:
                        RxContext->InformationToReturn =
                            pResumptionContext->DataBytesReceived;
                        break;
                    }

                    MRxSmbNamedPipeFsControlCompletion(pFsCtlCompletionContext);
                }
            } else {

                if (fTransactioNameBufferAllocated)
                {
                    RxFreePool(TransactionName.Buffer);
                }

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_INVALID_HANDLE) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
        }

        RxDbgTrace( 0, Dbg, ("MRxSmbNamedPipeFsControl(%ld): Failed .. returning %lx\n",FsControlCode,Status));
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbNamedPipeFsControl exit...st=%08lx\n", Status));
    return Status;
}

#ifdef _WIN64
typedef struct _LMR_TRANSACTION_32 {
    ULONG       Type;                   // Type of structure
    ULONG       Size;                   // Size of fixed portion of structure
    ULONG       Version;                // Structure version.
    ULONG       NameLength;             // Number of bytes in name (in path
                                        // format, e.g., \server\pipe\netapi\4)
    ULONG       NameOffset;             // Offset of name in buffer.
    BOOLEAN     ResponseExpected;       // Should remote system respond?
    ULONG       Timeout;                // Timeout time in milliseconds.
    ULONG       SetupWords;             // Number of trans setup words (may be
                                        // 0).  (setup words are input/output.)
    ULONG       SetupOffset;            // Offset of setup (may be 0 for none).
    ULONG       MaxSetup;               // Size of setup word array (may be 0).
    ULONG       ParmLength;             // Input param area length (may be 0).
    void * POINTER_32 ParmPtr;          // Input parameter area (may be NULL).
    ULONG       MaxRetParmLength;       // Output param. area length (may be 0).
    ULONG       DataLength;             // Input data area length (may be 0).
    void * POINTER_32 DataPtr;          // Input data area (may be NULL).
    ULONG       MaxRetDataLength;       // Output data area length (may be 0).
    void * POINTER_32 RetDataPtr;       // Output data area (may be NULL).
} LMR_TRANSACTION_32, *PLMR_TRANSACTION_32;
#endif

NTSTATUS
MRxSmbFsCtlUserTransact(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine issues what is called a UserTransaction against the server that is serving the
    connection for this file. very strange.............

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureFobx;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

    UNICODE_STRING TransactionName;

    LMR_TRANSACTION  InputBuffer;
    ULONG            InputBufferLength = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;
    ULONG            SizeOfLmrTransaction = 0;

    NTSTATUS Status;

    PAGED_CODE();

    if( pLowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL )
    {
        return (Status = STATUS_INVALID_PARAMETER);
    }

    InputBuffer = *((PLMR_TRANSACTION)pLowIoContext->ParamsFor.FsCtl.pInputBuffer);

#ifdef _WIN64
    if (IoIs32bitProcess(RxContext->CurrentIrp)) {
        PLMR_TRANSACTION_32 InputBuffer32 = (PLMR_TRANSACTION_32)pLowIoContext->ParamsFor.FsCtl.pInputBuffer;

        InputBuffer.Type = InputBuffer32->Type;
        InputBuffer.Size = InputBuffer32->Size;
        InputBuffer.Version = InputBuffer32->Version;
        InputBuffer.NameLength = InputBuffer32->NameLength;
        InputBuffer.NameOffset = InputBuffer32->NameOffset;
        InputBuffer.ResponseExpected = InputBuffer32->ResponseExpected;
        InputBuffer.Timeout = InputBuffer32->Timeout;
        InputBuffer.SetupWords = InputBuffer32->SetupWords;
        InputBuffer.SetupOffset = InputBuffer32->SetupOffset;
        InputBuffer.MaxSetup = InputBuffer32->MaxSetup;
        InputBuffer.ParmLength = InputBuffer32->ParmLength;
        InputBuffer.ParmPtr = (PVOID)InputBuffer32->ParmPtr;
        InputBuffer.MaxRetParmLength = InputBuffer32->MaxRetParmLength;
        InputBuffer.DataLength = InputBuffer32->DataLength;
        InputBuffer.DataPtr = (PVOID)InputBuffer32->DataPtr;
        InputBuffer.MaxRetDataLength = InputBuffer32->MaxRetDataLength;
        InputBuffer.RetDataPtr = (PVOID)InputBuffer32->RetDataPtr;

        SizeOfLmrTransaction = sizeof(LMR_TRANSACTION_32);
    } else {
        SizeOfLmrTransaction = sizeof(LMR_TRANSACTION);
    }
#else
    SizeOfLmrTransaction = sizeof(LMR_TRANSACTION);
#endif

    RxDbgTrace(+1, Dbg, ("MRxSmbFsCtlUserTransact...\n"));

    if (InputBufferLength < SizeOfLmrTransaction) {
        return(Status = STATUS_INVALID_PARAMETER);
    }

    if (InputBufferLength -  SizeOfLmrTransaction < InputBuffer.NameLength) {
        return(Status = STATUS_BUFFER_TOO_SMALL);
    }

    if ((InputBuffer.Type != TRANSACTION_REQUEST) ||
        (InputBuffer.Version != TRANSACTION_VERSION)) {
        return(Status = STATUS_INVALID_PARAMETER);
    }

    if (InputBuffer.NameOffset + InputBuffer.NameLength > InputBufferLength) {
        return(Status = STATUS_INVALID_PARAMETER);
    }

    if (InputBuffer.SetupOffset + InputBuffer.SetupWords > InputBufferLength) {
        return(Status = STATUS_INVALID_PARAMETER);
    }

    if (capFobx != NULL) {
        PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

        if (NodeType(pVNetRoot) == RDBSS_NTC_V_NETROOT) {
            Status = SmbCeReconnect(pVNetRoot);
        } else {
            Status = SmbCeReconnect(capFobx->pSrvOpen->pVNetRoot);
        }

        if (Status != STATUS_SUCCESS) {
            return Status;
        }
    }

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    TransactionName.MaximumLength = (USHORT)InputBuffer.NameLength;
    TransactionName.Length = (USHORT)InputBuffer.NameLength;
    TransactionName.Buffer = (PWSTR)(((PUCHAR)pLowIoContext->ParamsFor.FsCtl.pInputBuffer)+InputBuffer.NameOffset);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
        SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

        PUCHAR SetupBuffer = NULL;

        RxDbgTrace( 0, Dbg, ("MRxSmbFsCtlUserTransact: TransactionName %ws Length %ld\n",
                           TransactionName.Buffer,TransactionName.Length));

        TransactionOptions.NtTransactFunction = 0; // TRANSACT2/TRANSACT.
        TransactionOptions.pTransactionName   = &TransactionName;
        TransactionOptions.Flags              = SMB_XACT_FLAGS_FID_NOT_NEEDED;

        if (!InputBuffer.ResponseExpected) {
            TransactionOptions.Flags              |= SMB_TRANSACTION_NO_RESPONSE;
        }
        TransactionOptions.TimeoutIntervalInMilliSeconds = InputBuffer.Timeout;
        SmbCeInitializeTransactionResumptionContext(&ResumptionContext);

        try {
            if (InputBuffer.SetupOffset){
                SetupBuffer = (PUCHAR)pLowIoContext->ParamsFor.FsCtl.pInputBuffer+InputBuffer.SetupOffset;
            }

            if (SetupBuffer) {
                ProbeForWrite(SetupBuffer,InputBuffer.MaxSetup,1);
            }

            if (InputBuffer.ParmPtr) {
                ProbeForWrite(InputBuffer.ParmPtr,InputBuffer.MaxRetParmLength,1);
            }

            if (InputBuffer.RetDataPtr) {
                ProbeForWrite(InputBuffer.RetDataPtr,InputBuffer.MaxRetDataLength,1);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }

        Status = SmbCeTransact(
                     RxContext,
                     &TransactionOptions,
                     SetupBuffer,
                     (USHORT)InputBuffer.SetupWords,
                     SetupBuffer,
                     InputBuffer.MaxSetup,
                     InputBuffer.ParmPtr,
                     InputBuffer.ParmLength,
                     InputBuffer.ParmPtr,         // the buffer for the param information
                     InputBuffer.MaxRetParmLength,// the length of the param buffer
                     InputBuffer.DataPtr,
                     InputBuffer.DataLength,
                     InputBuffer.RetDataPtr,      // the buffer for data
                     InputBuffer.MaxRetDataLength,// the length of the buffer
                     &ResumptionContext);

        if (NT_SUCCESS(Status)) {
            //LowIoContext->ParamsFor.FsCtl.OutputBufferLength = ResumptionContext.DataBytesReceived;
#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                PLMR_TRANSACTION_32 pInputBuffer = (PLMR_TRANSACTION_32)pLowIoContext->ParamsFor.FsCtl.pInputBuffer;

                pInputBuffer->MaxRetParmLength = ResumptionContext.ParameterBytesReceived;
                pInputBuffer->MaxRetDataLength = ResumptionContext.DataBytesReceived;
                pInputBuffer->MaxSetup = ResumptionContext.SetupBytesReceived;

                //this seems like a bad return value for iostatus.information
                RxContext->InformationToReturn = SizeOfLmrTransaction + pInputBuffer->SetupWords;
            } else {
                PLMR_TRANSACTION pInputBuffer = (PLMR_TRANSACTION)pLowIoContext->ParamsFor.FsCtl.pInputBuffer;

                pInputBuffer->MaxRetParmLength = ResumptionContext.ParameterBytesReceived;
                pInputBuffer->MaxRetDataLength = ResumptionContext.DataBytesReceived;
                pInputBuffer->MaxSetup = ResumptionContext.SetupBytesReceived;

                //this seems like a return value for iostatus.information
                RxContext->InformationToReturn = SizeOfLmrTransaction + pInputBuffer->SetupWords;
            }
#else
            {
            PLMR_TRANSACTION pInputBuffer = (PLMR_TRANSACTION)pLowIoContext->ParamsFor.FsCtl.pInputBuffer;

            pInputBuffer->MaxRetParmLength = ResumptionContext.ParameterBytesReceived;
            pInputBuffer->MaxRetDataLength = ResumptionContext.DataBytesReceived;
            pInputBuffer->MaxSetup = ResumptionContext.SetupBytesReceived;

            //this seems like a return value for iostatus.information
            RxContext->InformationToReturn = SizeOfLmrTransaction + pInputBuffer->SetupWords;
            }
#endif
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbFsCtlUserTransact: Failed .. returning %lx\n",Status));
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFsCtlUserTransact exit...st=%08lx\n", Status));
    return Status;
}

NTSTATUS
MRxSmbMailSlotFsControl(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine handles all named pipe related FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxSmbDfsFsControl(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine handles all DFS related FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   RxCaptureFobx;
   RxCaptureFcb;

   PMRX_SMB_SRV_OPEN pSmbSrvOpen;

   SMB_TRANSACTION_OPTIONS             TransactionOptions = DEFAULT_TRANSACTION_OPTIONS;
   SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
   ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

   NTSTATUS Status;
   USHORT Setup;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbDfsFsControl...\n", 0));

   if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
       // these FSCTLS are only su[pported from a kernel mode component
       // because of parameter validation issues
       return STATUS_INVALID_DEVICE_REQUEST;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   if (capFobx != NULL) {
      pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
   } else {
      pSmbSrvOpen = NULL;
   }

   pInputParamBuffer = pLowIoContext->ParamsFor.FsCtl.pInputBuffer;
   InputParamBufferLength = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;

   switch (FsControlCode) {
   case FSCTL_DFS_GET_REFERRALS:
      {
         pOutputDataBuffer = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
         OutputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;
      }
      break;
   case FSCTL_DFS_REPORT_INCONSISTENCY:
      {
         PWCHAR pDfsPathName;
         //
         // The input buffer from Dfs contains the path name with the inconsistency
         // followed by the DFS_REFERRAL_V1 that has the inconsistency. The
         // path name is sent in the Parameter section, and the DFS_REFERRAL_V1 is
         // passed in the Data section. So, parse these two things out.
         //

         for (pDfsPathName = (PWCHAR) pInputParamBuffer;
              *pDfsPathName != UNICODE_NULL;
              pDfsPathName++) {
             NOTHING;
         }

         pDfsPathName++; // Get past the NULL char

         InputParamBufferLength = (ULONG) (((PCHAR)pDfsPathName) - ((PCHAR)pInputParamBuffer));

         if (InputParamBufferLength >= pLowIoContext->ParamsFor.FsCtl.InputBufferLength) {
             Status = STATUS_INVALID_PARAMETER;
         } else {
            pInputDataBuffer = (PBYTE)pDfsPathName;
            InputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.InputBufferLength -
                                    InputParamBufferLength;
         }
      }
      break;
   default:
      ASSERT(!"Valid Dfs FSCTL");
   }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        Setup = TRANS2_GET_DFS_REFERRAL;

        TransactionOptions.NtTransactFunction = 0; // TRANSACT2/TRANSACT.
        TransactionOptions.pTransactionName   = NULL;
        TransactionOptions.TimeoutIntervalInMilliSeconds = SMBCE_TRANSACTION_TIMEOUT_NOT_USED;

        Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     &Setup,                       // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,
                     0,
                     pInputParamBuffer,            // Input Param Buffer
                     InputParamBufferLength,       // Input param buffer length
                     pOutputParamBuffer,           // Output param buffer
                     OutputParamBufferLength,      // output param buffer length
                     pInputDataBuffer,             // Input data buffer
                     InputDataBufferLength,        // Input data buffer length
                     pOutputDataBuffer,            // output data buffer
                     OutputDataBufferLength,       // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace( 0, Dbg, ("MRxSmbDfsFsControl(%ld): Failed .. returning %lx\n",FsControlCode,Status));
        } else {
            RxContext->InformationToReturn = ResumptionContext.DataBytesReceived;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbDfsFsControl exit...st=%08lx\n", Status));
    return Status;
}

NTSTATUS
MRxSmbFsControl(PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine handles all the FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Remoting of FSCTL's is permitted only to NT servers.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN pSmbSrvOpen;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PFILE_OBJECT pTargetFileObject = NULL;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    REQ_NT_IO_CONTROL FsCtlSetup;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;
#ifdef _WIN64
    PBYTE  pThunkedInputData       = NULL;
    ULONG  ThunkedInputDataLength  = 0;
#endif

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    USHORT FileOrTreeId;

    SMB_TRANSACTION_OPTIONS             TransactionOptions = DEFAULT_TRANSACTION_OPTIONS;
    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

    PAGED_CODE();

    if (NodeType(capFcb) == RDBSS_NTC_DEVICE_FCB) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ((FsControlCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION) &&
        (RxContext->MinorFunction != IRP_MN_TRACK_LINK)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (capFobx != NULL &&
        MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {
        return STATUS_NOT_IMPLEMENTED;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbFsControl...Entry FsControlCode(%lx)\n", FsControlCode));

    FsCtlSetup.IsFlags = 0;

    if (capFobx != NULL) {
        if (NodeType(capFobx) == RDBSS_NTC_V_NETROOT) {
            PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

            PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

            pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);

            // It is a root open the tree id needs to be sent to the server.
            FileOrTreeId = pVNetRootContext->TreeId;
        } else {
            if (FsControlCode != FSCTL_LMR_GET_CONNECTION_INFO)
            {
                pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

                if (FlagOn(pSmbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                    BOOLEAN FcbAcquired = FALSE;

                    if (!RxIsFcbAcquiredExclusive(capFcb)) {
                        // This assert does not take into account the fact that other threads may
                        // own the resource shared, in which case we DO want to block and wait for
                        // the resource.
                        //ASSERT(!RxIsFcbAcquiredShared(capFcb));
                        Status = RxAcquireExclusiveFcbResourceInMRx( capFcb );

                        FcbAcquired = (Status == STATUS_SUCCESS);
                    } else {
                        FcbAcquired = TRUE;
                    }

                    if (FcbAcquired) {

                        Status = MRxSmbDeferredCreate(RxContext);

                        RxReleaseFcbResourceInMRx( capFcb );
                    }

                    if (Status!=STATUS_SUCCESS) {
                        goto FINALLY;
                    }
                }

                FileOrTreeId = pSmbSrvOpen->Fid;
            }
            else {
                FileOrTreeId = 0;
            }
        }
    } else {
        FileOrTreeId = 0;
    }

    SmbPutAlignedUshort(&FsCtlSetup.Fid,FileOrTreeId);

    SmbPutAlignedUlong(&FsCtlSetup.FunctionCode,FsControlCode);
    FsCtlSetup.IsFsctl = TRUE;

    TransactionOptions.NtTransactFunction = NT_TRANSACT_IOCTL;
    TransactionOptions.pTransactionName   = NULL;

    Status = STATUS_SUCCESS;

    switch (FsControlCode & 3) {
    case METHOD_NEITHER:
        {
            ULONG Device;

//         pInputDataBuffer        = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
//         InputDataBufferLength   = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;

//         pInputParamBuffer       = pLowIoContext->ParamsFor.FsCtl.pInputBuffer;
//         InputParamBufferLength  = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;

//         pOutputDataBuffer       = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
//         OutputDataBufferLength  = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;

//         pOutputParamBuffer      = pLowIoContext->ParamsFor.FsCtl.pInputBuffer;
//         OutputParamBufferLength = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;

            Device = FsControlCode >> 16;

            if (Device != FILE_DEVICE_FILE_SYSTEM) {
                Status = STATUS_NOT_IMPLEMENTED;
                break;
            }
        }
        // fall thru.. for those FSContolcodes that belong to FILE_DEVICE_FILE_SYSTEM
        // for which METHOD_NEITHER is specified we treat them as METHOD_BUFFERED
        // Not Yet implemented

    case METHOD_BUFFERED:
    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:
        {
            pInputDataBuffer       = pLowIoContext->ParamsFor.FsCtl.pInputBuffer;
            InputDataBufferLength  = pLowIoContext->ParamsFor.FsCtl.InputBufferLength;

            pOutputDataBuffer      = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
            OutputDataBufferLength = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;
        }
        break;


    default:
        ASSERT(!"Valid Method for Fs Control");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

#ifdef _WIN64
    pThunkedInputData = pInputDataBuffer;
    ThunkedInputDataLength = InputDataBufferLength;
#endif

    // There is one FSCTL for which certain amount of preprocessing is required
    // This is because the I/O subsystem passes in the information as a file
    // object. The FID for the file object needs to be determined and the
    // appropriate FID passed to the server instead of the file object.

    if (FsControlCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION) {
        PREMOTE_LINK_TRACKING_INFORMATION pRemoteLinkInformation;

        PMRX_FOBX pMRxFobx;
        PMRX_SRV_OPEN pSrvOpen;
        PMRX_SMB_SRV_OPEN pSmbSrvOpen;

        try {
            pRemoteLinkInformation =
                (PREMOTE_LINK_TRACKING_INFORMATION)pInputDataBuffer;

            if (pRemoteLinkInformation != NULL) {
                pTargetFileObject = (PFILE_OBJECT)pRemoteLinkInformation->TargetFileObject;

                if (pTargetFileObject != NULL) {
                    // Deduce the FID and substitute it for the File Object before shipping
                    // the FSCTL to the server.

                    pMRxFobx = (PMRX_FOBX)pTargetFileObject->FsContext2;
                    pSrvOpen = pMRxFobx->pSrvOpen;

                    pSmbSrvOpen = MRxSmbGetSrvOpenExtension(pSrvOpen);

                    if (pSmbSrvOpen != NULL) {
                        pRemoteLinkInformation->TargetFileObject =
                            (PVOID)(pSmbSrvOpen->Fid);
                    } else {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                }

#ifdef _WIN64
                if( NT_SUCCESS(Status) )
                {
                    ThunkedInputDataLength = InputDataBufferLength;
                    pThunkedInputData = Smb64ThunkRemoteLinkTrackingInfo( pInputDataBuffer, &ThunkedInputDataLength, &Status );
                }
#endif
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status=STATUS_INVALID_PARAMETER;
        }
    }
    else if (FsControlCode == FSCTL_LMR_GET_CONNECTION_INFO)
    {
        PSMBCEDB_SERVER_ENTRY pServerEntry= SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        Status = STATUS_INVALID_PARAMETER;
        pOutputDataBuffer       = pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;
        OutputDataBufferLength  = pLowIoContext->ParamsFor.FsCtl.OutputBufferLength;
        if (pOutputDataBuffer && (OutputDataBufferLength==sizeof(LMR_CONNECTION_INFO_3)))
        {
            try
            {
                ProbeForWrite(
                    pOutputDataBuffer,
                    OutputDataBufferLength,
                    1);
                if (!memcmp(pOutputDataBuffer,EA_NAME_CSCAGENT,sizeof(EA_NAME_CSCAGENT)))
                {
                    MRxSmbGetConnectInfoLevel3Fields(
                        (PLMR_CONNECTION_INFO_3)(pOutputDataBuffer),
                        pServerEntry,
                        TRUE);
                    Status = STATUS_SUCCESS;
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status=STATUS_INVALID_PARAMETER;
            }
        }

        goto FINALLY;
    }

    if (NT_SUCCESS(Status)) {

#ifdef _WIN64
        ASSERT( !( (FsControlCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION) &&
                   (pThunkedInputData == NULL) ) );
#endif

        Status = SmbCeTransact(
                     RxContext,
                     &TransactionOptions,
                     &FsCtlSetup,
                     sizeof(FsCtlSetup),
                     &FsCtlSetup,
                     sizeof(FsCtlSetup),
                     pInputParamBuffer,
                     InputParamBufferLength,
                     pOutputParamBuffer,
                     OutputParamBufferLength,
#ifndef _WIN64
                     pInputDataBuffer,
                     InputDataBufferLength,
#else
                     pThunkedInputData,
                     ThunkedInputDataLength,
#endif
                     pOutputDataBuffer,
                     OutputDataBufferLength,
                     &ResumptionContext);

        RxContext->InformationToReturn = ResumptionContext.DataBytesReceived;

        if (NT_SUCCESS(Status)) {
            PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            // invalidate the name based file info cache since it could change the attribute
            // of the file on the server, i.e. FILE_ATTRIBUTE_COMPRESSED.
            MRxSmbInvalidateFileInfoCache(RxContext);

            // update the Fcb in case of reuse since the time stamp may have changed
            ClearFlag(capFcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET);

            if( RxContext->InformationToReturn > OutputDataBufferLength ) {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        if( !NT_SUCCESS( Status ) ) {
//            RxContext->InformationToReturn = 0;
            RxDbgTrace(0,Dbg,("MRxSmbFsControl: Transaction Request Completion Status %lx\n",Status));
        }
    }

FINALLY:

    if( FsControlCode == FSCTL_LMR_SET_LINK_TRACKING_INFORMATION )
    {
#ifdef _WIN64
        Smb64ReleaseThunkData( pThunkedInputData );
#endif

        if( pTargetFileObject != NULL )
        {
            PREMOTE_LINK_TRACKING_INFORMATION pRemoteLinkInformation;

            pRemoteLinkInformation =
                (PREMOTE_LINK_TRACKING_INFORMATION)pInputDataBuffer;

            pRemoteLinkInformation->TargetFileObject = pTargetFileObject;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFsControl...Exit\n"));
    return Status;
}

#if DBG
NTSTATUS
MRxSmbTestForLowIoIoctl(
    IN PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSZ Buffer = (PSZ)(LowIoContext->ParamsFor.IoCtl.pInputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    UNICODE_STRING u;
    PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME(capFobx->pSrvOpen,capFcb);
    ULONG ReturnLength;

    PAGED_CODE();

    ReturnLength = OutputBufferLength;
    if (ReturnLength > FileName->Length) {
        ReturnLength = FileName->Length;
    }

    RxDbgTrace(0, Dbg,
      ("Here in MRxSmbTestForLowIoIoctl %s, obl = %08lx, rl=%08lx\n", Buffer, OutputBufferLength, ReturnLength));

    // return an obvious string to make sure that darryl is copying the results out correctly
    // need to check the lengths i.e. need outputl<=inputl; also need to check that count and buffer
    // are aligned for wchar

    RtlCopyMemory(Buffer,FileName->Buffer,ReturnLength);
    u.Buffer = (PWCHAR)(Buffer);
    u.Length = u.MaximumLength = (USHORT)ReturnLength;
    RtlUpcaseUnicodeString(&u,&u,FALSE);

    RxContext->InformationToReturn =
    //LowIoContext->ParamsFor.IoCtl.OutputBufferLength =
            ReturnLength;

    return(Status);
}
#endif //if DBG

NTSTATUS
MRxSmbIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation. Currently, no calls are remoted; in
   fact, the only call accepted is for debugging.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          IoControlCode = pLowIoContext->ParamsFor.IoCtl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbIoCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbIoCtl = %08lx\n", IoControlCode));

    switch (IoControlCode) {
#if DBG
    case IOCTL_LMMR_TESTLOWIO:
        Status = MRxSmbTestForLowIoIoctl(RxContext);
        break;
#endif //if DBG
    default:
        break;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbIoCtl -> %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbGetPrintJobId(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    NTSTATUS Status;
    BOOLEAN FinalizationComplete;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxCaptureFobx;
    RxCaptureFcb;
    PIO_STACK_LOCATION IrpSp = RxContext->CurrentIrpSp;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbGetPrintJobId\n", 0 ));

    if (capFcb == NULL || capFobx == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (NodeType(capFcb) == RDBSS_NTC_DEVICE_FCB) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        Status = MRxSmbFsControl(RxContext);
        goto FINALLY;
    }

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(QUERY_PRINT_JOB_INFO) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto FINALLY;
    }

    Status= SmbPseCreateOrdinaryExchange(
                RxContext,
                capFobx->pSrvOpen->pVNetRoot,
                SMBPSE_OE_FROM_GETPRINTJOBID,
                MRxSmbCoreIoCtl,
                &OrdinaryExchange
                );

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    OrdinaryExchange->AssociatedStufferState.CurrentCommand = SMB_COM_NO_ANDX_COMMAND;

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    ASSERT(FinalizationComplete);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbIsValidDirectory  exit with status=%08lx\n", Status ));
    return(Status);
}

#define SPOOLER_DEVICE          0x53
#define GET_PRINTER_ID          0x60

typedef struct _SMB_RESP_PRINT_JOB_ID {
    USHORT  JobId;
    UCHAR   ServerName[LM20_CNLEN+1];
    UCHAR   QueueName[LM20_QNLEN+1];
    UCHAR   Padding;                    // Unknown what this padding is..
} SMB_RESP_PRINT_JOB_ID, *PSMB_RESP_PRINT_JOB_ID;

NTSTATUS
MRxSmbCoreIoCtl(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for SMB IOCTL. This initiates the construction of the
    appropriate SMB.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen  = MRxSmbGetSrvOpenExtension(SrvOpen);

    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    ULONG SmbLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreIoCtl\n", 0 ));

    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_GETPRINTJOBID:
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_IOCTL,
                SMB_REQUEST_SIZE(IOCTL),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
        //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
        MRxSmbStuffSMB (StufferState,
             "0wwwwwwwwwwwwwwB!",
                                               //  0         UCHAR WordCount;                    // Count of parameter words = 8
             smbSrvOpen->Fid,                  //  w         _USHORT( Fid );                     // File handle
             SPOOLER_DEVICE,                   //  w         _USHORT( Category);
             GET_PRINTER_ID,                   //  w         _USHORT( Function );                // Device function
             0,                                //  w         _USHORT( TotalParameterCount );     // Total parameter bytes being sent
             0,                                //  w         _USHORT( TotalDataCount );          // Total data bytes being sent
             0,                                //  w         _USHORT( MaxParameterCount );       // Max parameter bytes to return
             0,                                //  w         _USHORT( MaxDataCount );            // Max data bytes to return
             0,                                //  w         _ULONG ( Timeout );
             0,                                //  w         _USHORT( Reserved );
             0,                                //  w         _USHORT( ParameterCount );          // Parameter bytes sent this buffer
             0,                                //  w         _USHORT( ParameterOffset );         // Offset (from header start) to params
             0,                                //  w         _USHORT( DataCount );               // Data bytes sent this buffer
             0,                                //  w         _USHORT( DataOffset );              // Offset (from header start) to data
             0,                                //  w         _USHORT( ByteCount );               // Count of data bytes
             SMB_WCT_CHECK(14) 0                //            _USHORT( ByteCount );               // Count of data bytes; min = 0
                                               //            UCHAR Buffer[1];                    // Reserved buffer
             );

        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
    }

    if (Status == STATUS_SUCCESS) {
        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);

        Status = SmbPseOrdinaryExchange(
                     SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                     SMBPSE_OETYPE_IOCTL
                     );
    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSynchronousGetFileAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishCoreIoCtl(
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_IOCTL                 Response
      )
/*++

Routine Description:

    This routine copies the print job ID and server and queue name to the user buffer.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = RxContext->CurrentIrpSp;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreIoCtl\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreIoCtl:");

    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_GETPRINTJOBID:
        if (Response->WordCount != 8 ||
            SmbGetUshort(&Response->DataCount) != sizeof(SMB_RESP_PRINT_JOB_ID)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        } else {
            OEM_STRING OemString;
            UNICODE_STRING UnicodeString;
            PQUERY_PRINT_JOB_INFO OutputBuffer = Irp->UserBuffer;
            PSMB_RESP_PRINT_JOB_ID RespPrintJobId = (PSMB_RESP_PRINT_JOB_ID)((PUCHAR)Response+(Response->DataOffset-sizeof(SMB_HEADER)));

            OutputBuffer->JobId = RespPrintJobId->JobId;
            RtlInitAnsiString(&OemString, RespPrintJobId->ServerName);
            UnicodeString.Buffer = OutputBuffer->ServerName;
            UnicodeString.MaximumLength = sizeof(OutputBuffer->ServerName);

            Status = RtlOemStringToUnicodeString(&UnicodeString, &OemString, FALSE);

            if (Status == STATUS_SUCCESS) {
                RtlInitAnsiString(&OemString, RespPrintJobId->QueueName);
                UnicodeString.Buffer = OutputBuffer->QueueName;
                UnicodeString.MaximumLength = sizeof(OutputBuffer->QueueName);
                Status = RtlOemStringToUnicodeString(&UnicodeString, &OemString, FALSE);

                IrpSp->Parameters.FileSystemControl.InputBufferLength = sizeof(QUERY_PRINT_JOB_INFO);
            }
        }
        break;

    default:
        ASSERT(FALSE);
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreIoCtl   returning %08lx\n", Status ));
    return Status;
}

typedef struct _SecPkgContext_TargetInformation 
{
    unsigned long MarshalledTargetInfoLength;
    unsigned char SEC_FAR * MarshalledTargetInfo;
} SecPkgContext_TargetInformation, SEC_FAR * PSecPkgContext_TargetInformation;

NTSTATUS
MRxSmbQueryTargetInfo(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine performs a query target information operation against a connection

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation
    
Notes:

    RDR gets the target information based on the security context of the connection and
    returns the marshalled target information on the output buffer.

--*/
{
    PMRX_V_NET_ROOT pVNetRoot = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    NTSTATUS Status = STATUS_SUCCESS;
    SECURITY_STATUS SecStatus;

    SecPkgContext_TargetInformation SecTargetInfo;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PLMR_QUERY_TARGET_INFO LmrQueryTargetInfo = RxContext->CurrentIrp->UserBuffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryTargetInfo...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbQueryTargetInfo = %08lx\n", FsControlCode));

    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        // this FSCTLS is only supported from a kernel mode component
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (LmrQueryTargetInfo == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RxContext->pRelevantSrvOpen == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    pVNetRoot = (PMRX_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot;

    if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
        return STATUS_INVALID_PARAMETER;
    }

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    SecStatus = QueryContextAttributesW(
                    &pVNetRootContext->pSessionEntry->Session.SecurityContextHandle,
                    SECPKG_ATTR_TARGET_INFORMATION,
                    &SecTargetInfo);

    Status = MapSecurityError( SecStatus );

    if (Status == STATUS_SUCCESS) {
        if (SecTargetInfo.MarshalledTargetInfoLength+sizeof(LMR_QUERY_TARGET_INFO) > LmrQueryTargetInfo->BufferLength) {
            LmrQueryTargetInfo->BufferLength = SecTargetInfo.MarshalledTargetInfoLength + sizeof(LMR_QUERY_TARGET_INFO);
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            RtlCopyMemory(LmrQueryTargetInfo->TargetInfoMarshalled,
                          SecTargetInfo.MarshalledTargetInfo,
                          SecTargetInfo.MarshalledTargetInfoLength);

            LmrQueryTargetInfo->BufferLength = SecTargetInfo.MarshalledTargetInfoLength;
        }

        {
            SIZE_T MarshalledTargetInfoLength_SizeT;

            MarshalledTargetInfoLength_SizeT = SecTargetInfo.MarshalledTargetInfoLength;

            ZwFreeVirtualMemory(
                NtCurrentProcess(),
                &SecTargetInfo.MarshalledTargetInfo,
                &MarshalledTargetInfoLength_SizeT,
                MEM_RELEASE);

            ASSERT(MarshalledTargetInfoLength_SizeT <= MAXULONG);
            SecTargetInfo.MarshalledTargetInfoLength = (ULONG)MarshalledTargetInfoLength_SizeT;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

Author:

    Joe Linn      [JoeLi]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

RXDT_DefineCategory(DIRCTRL);
#define Dbg        (DEBUG_TRACE_DIRCTRL)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, __MRxSmbAllocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbDeallocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbTranslateLanManFindBuffer)
#pragma alloc_text(PAGE, MrxSmbUnalignedDirEntryCopyTail)
#pragma alloc_text(PAGE, MRxSmbQueryDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformationWithFullBuffer)
#pragma alloc_text(PAGE, MRxSmbSetVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformation)
#pragma alloc_text(PAGE, MRxSmbQueryNamedPipeInformation)
#pragma alloc_text(PAGE, MRxSmbSetNamedPipeInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformationAtCleanup)
#pragma alloc_text(PAGE, MRxSmbIsValidDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformationFromPseudoOpen)
#endif

#define MRxSmbForceCoreInfo FALSE
//#define FORCECOREINFO
#if DBG
#ifdef FORCECOREINFO
#undef MRxSmbForceCoreInfo
BOOLEAN MRxSmbForceCoreInfo = TRUE;
#endif
#endif

BOOLEAN MRxSmbBypassDownLevelRename = FALSE;
//BOOLEAN MRxSmbBypassDownLevelRename = TRUE;

ULONG UnalignedDirEntrySideBufferSize = 16384;

//
//  All T2Find requests to the remote server request the 32 bit resume key
//  so SMB_RFIND_BUFFER2 is used instead of SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER2_WITH_RESUME {
    _ULONG( ResumeKey );
    SMB_FIND_BUFFER2;
} SMB_FIND_BUFFER2_WITH_RESUME;
typedef SMB_FIND_BUFFER2_WITH_RESUME SMB_UNALIGNED *PSMB_FIND_BUFFER2_WITH_RESUME;

//CODE.IMPROVEMENT  we should have a nondebug version of this sidebuffer stuff
//    that basically just does a allocatepool/freepool

LIST_ENTRY MRxSmbSideBuffersList = {NULL,NULL};
ULONG MRxSmbSideBuffersSpinLock = 0;
ULONG MRxSmbSideBuffersCount = 0;
ULONG MRxSmbSideBuffersSerialNumber = 0;
BOOLEAN MRxSmbLoudSideBuffers = FALSE;

extern BOOLEAN UniqueFileNames;

typedef struct _SIDE_BUFFER {
    ULONG      Signature;
    LIST_ENTRY ListEntry;
    PMRX_FCB Fcb;
    PMRX_FOBX Fobx;
    PMRX_SMB_FOBX smbFobx;
    ULONG SerialNumber;
    BYTE Buffer;
} SIDE_BUFFER, *PSIDE_BUFFER;


#if DBG
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c,d)
#else
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c)
#endif


NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );


VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    )
{
    RxCaptureFcb;RxCaptureFobx;
    PSIDE_BUFFER SideBuffer;
    ULONG SideBufferSize = UnalignedDirEntrySideBufferSize+sizeof(SIDE_BUFFER);
    POOL_TYPE PoolType;

    PAGED_CODE();

    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);

#ifdef _WIN64

    //
    // NT64: When PagedPool is used here, we get memory corruption on
    //       some findfirst/findnext operations.  Find out why.
    //

    PoolType = NonPagedPool;
#else
    PoolType = PagedPool;
#endif
    SideBuffer = (PSIDE_BUFFER)RxAllocatePoolWithTag(
                                    PoolType,
                                    SideBufferSize,
                                    MRXSMB_DIRCTL_POOLTAG);
    if (SideBuffer==NULL) {
        return;
    }
    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);
    SideBuffer->Signature = 'JLBS';
    SideBuffer->smbFobx = smbFobx;
    SideBuffer->Fobx = capFobx;
    SideBuffer->Fcb = capFcb;
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = &SideBuffer->Buffer;
    RxLog(("Allocsidebuf %lx fo/f=%lx,%lx\n",
            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
            capFobx,capFcb));
    SmbLog(LOG,
           MRxSmbAllocateSideBuffer,
           LOGPTR(smbFobx->Enumeration.UnalignedDirEntrySideBuffer)
           LOGPTR(capFobx)
           LOGPTR(capFcb));
    smbFobx->Enumeration.SerialNumber = SideBuffer->SerialNumber = InterlockedIncrement(&MRxSmbSideBuffersSerialNumber);
    InterlockedIncrement(&MRxSmbSideBuffersCount);
    if (MRxSmbSideBuffersList.Flink==NULL) {
        InitializeListHead(&MRxSmbSideBuffersList);
    }
    ExAcquireFastMutex(&MRxSmbSerializationMutex);
    InsertTailList(&MRxSmbSideBuffersList,&SideBuffer->ListEntry);
    ExReleaseFastMutex(&MRxSmbSerializationMutex);
    if (!MRxSmbLoudSideBuffers) return;
    KdPrint(("Allocating side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s %wZ\n",
                     &SideBuffer->Buffer,
                     MRxSmbSideBuffersCount,
                     smbFobx,capFobx,capFobx->pSrvOpen,
                     GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                     (Setup == TRANS2_FIND_FIRST2)?"First":"Next",
                     smbtemplate
                     ));
}
VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    )
{
    PSIDE_BUFFER SideBuffer;

    RxCaptureFcb;RxCaptureFobx;

    PAGED_CODE();

    if( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL) return;
    SideBuffer = CONTAINING_RECORD(smbFobx->Enumeration.UnalignedDirEntrySideBuffer,SIDE_BUFFER,Buffer);
    if (MRxSmbLoudSideBuffers){
        DbgPrint("D--------- side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s\n",
                         &SideBuffer->Buffer,
                         MRxSmbSideBuffersCount,
                         smbFobx,capFobx,capFobx->pSrvOpen,
                         GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                         where
                         );
    }
    ASSERT(SideBuffer->Signature == 'JLBS');
    ASSERT(SideBuffer->Fobx == capFobx);
    ASSERT(SideBuffer->Fcb == capFcb);
    ASSERT(SideBuffer->smbFobx == smbFobx);
    ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);

    InterlockedDecrement(&MRxSmbSideBuffersCount);
    RemoveEntryList(&SideBuffer->ListEntry);

    ExReleaseFastMutex(&MRxSmbSerializationMutex);

    RxLog(("Deallocsidebuf %lx fo/f=%lx,%lx\n",
            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
            capFobx,capFcb));
    SmbLog(LOG,
           MRxSmbDeallocateSideBuffer,
           LOGPTR(smbFobx->Enumeration.UnalignedDirEntrySideBuffer)
           LOGPTR(capFobx)
           LOGPTR(capFcb));
    RxFreePool(SideBuffer);
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = NULL;
}

#if 0
//
//  The NtQueryDirectory response contains one of the following three structures.  We use this union
//  to reduce the amount of casting needed
//
typedef union _SMB_RFIND_BUFFER_NT {
        FILE_NAMES_INFORMATION Names;
        FILE_DIRECTORY_INFORMATION Dir;
        FILE_FULL_DIR_INFORMATION FullDir;
        FILE_BOTH_DIR_INFORMATION BothDir;
} SMB_RFIND_BUFFER_NT;
typedef SMB_RFIND_BUFFER_NT SMB_UNALIGNED *PSMB_RFIND_BUFFER_NT;
#endif

VOID
MRxSmbTranslateLanManFindBuffer(
    PRX_CONTEXT RxContext,
    PULONG PreviousReturnedEntry,
    PBYTE ThisEntryInBuffer
    )
{
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMBCE_SERVER Server;
    ULONG FileInformationClass = RxContext->Info.FileInformationClass;
    PFILE_FULL_DIR_INFORMATION NtBuffer = (PFILE_FULL_DIR_INFORMATION)PreviousReturnedEntry;
    PSMB_FIND_BUFFER2_WITH_RESUME SmbBuffer = (PSMB_FIND_BUFFER2_WITH_RESUME)ThisEntryInBuffer;
    SMB_TIME Time;
    SMB_DATE Date;

    PAGED_CODE();

    if (FileInformationClass==FileNamesInformation) { return; }
    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    //CODE.IMPROVEMENT we should cacheup the server somewhere....getting it everytime is uneficient
    Server = &pServerEntry->Server;

    SmbMoveTime (&Time, &SmbBuffer->CreationTime);
    SmbMoveDate (&Date, &SmbBuffer->CreationDate);
    NtBuffer->CreationTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastAccessTime);
    SmbMoveDate (&Date, &SmbBuffer->LastAccessDate);
    NtBuffer->LastAccessTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastWriteTime);
    SmbMoveDate (&Date, &SmbBuffer->LastWriteDate);
    NtBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    NtBuffer->ChangeTime.QuadPart = 0;
    NtBuffer->EndOfFile.QuadPart = SmbGetUlong(&SmbBuffer->DataSize);
    NtBuffer->AllocationSize.QuadPart = SmbGetUlong(&SmbBuffer->AllocationSize);

    NtBuffer->FileAttributes = MRxSmbMapSmbAttributes(SmbBuffer->Attributes);

    if ((FileInformationClass==FileFullDirectoryInformation)
            || (FileInformationClass==FileBothDirectoryInformation)) {
        NtBuffer->EaSize = SmbGetUlong(&SmbBuffer->EaSize);
    }
}

NTSTATUS
MrxSmbUnalignedDirEntryCopyTail(
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  pBuffer,
    IN OUT PULONG                 pLengthRemaining,
    IN OUT PMRX_SMB_FOBX          smbFobx
    )
/*++

Routine Description:

   This routine copies the data from the side buffer into the users buffer and adjusts the
   lengths remaining appropriately. this is called either if the server doesn't do unicode (w95) OR
   if the server does not promise to quadalign entries OR if the user's buffer is not quadaligned.

   CODE.IMPROVEMENT if the user's buffer isn't quadaligned we could still get by in most cases by reading the data
   into the moved up buffer and then just copying the first entry.

   this routine can be entered after a T2 finishes or to copy the last entries from a previous T2. in the second case, the
   pUnalignedDirEntrySideBuffer ptr will be null and it will go to acquire the correct pointer from the smbFobx.

   this routine has the responsibility to free the sidebufferptr when it is exhausted.

   //CODE.IMPROVEMENT.ASHAMED (joe) i apologize for this code.....it is so ugly....but it does
   handle nt, win95/samba, and lanman in the same routine. the transformation is nontrivial even
   tho it is straightforward to implement.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
     NTSTATUS Status = STATUS_SUCCESS;
     RxCaptureFcb;

     ULONG i,NameSizeInUnicode;

     LONG   LocalLengthRemaining;   //signed arithmetic makes it easier
     PULONG PreviousReturnedEntry = NULL;
     ULONG  FileNameLengthOffset = smbFobx->Enumeration.FileNameLengthOffset;
     ULONG  FileNameOffset = smbFobx->Enumeration.FileNameOffset;
     PBYTE  UnalignedDirEntrySideBuffer = smbFobx->Enumeration.UnalignedDirEntrySideBuffer;

     BOOLEAN IsUnicode = smbFobx->Enumeration.IsUnicode;
     BOOLEAN IsNonNtT2Find = smbFobx->Enumeration.IsNonNtT2Find;
     PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo = smbFobx->Enumeration.ResumeInfo;

     ULONG FilesReturned = smbFobx->Enumeration.FilesReturned;

     ULONG   EntryOffset = smbFobx->Enumeration.EntryOffset;
     ULONG   ReturnedEntryOffset = 0;// = smbFobx->Enumeration.ReturnedEntryOffset;  //CODE.IMPROVEMENT get rid of this variable.....
     BOOLEAN EndOfSearchReached = smbFobx->Enumeration.EndOfSearchReached;
     ULONG   TotalDataBytesReturned = smbFobx->Enumeration.TotalDataBytesReturned;

     BOOLEAN FilterFailure = FALSE;

     PAGED_CODE();

     LocalLengthRemaining = (LONG)(*pLengthRemaining);

     //
     // keep looping until we've filled in all we can or there're no more entries

     for (i=ReturnedEntryOffset=0;;) {
        ULONG FileNameLength,ThisEntrySize; PCHAR FileNameBuffer;
        UNICODE_STRING ReturnedFileName;
        OEM_STRING FileName;
        NTSTATUS StringStatus;
        BOOLEAN TwoExtraBytes = TRUE;
        ULONG resumekey,NextEntryOffsetinBuffer;
        PULONG PreviousPreviousReturnedEntry = NULL;
        PBYTE ThisEntryInBuffer = UnalignedDirEntrySideBuffer+EntryOffset;

        //
        // don't EVER let yourself get past the data returned...servers return funny stuff.......

        if (EntryOffset>=TotalDataBytesReturned){
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        //
        // find the name, the length, and the resume key based on whether it is a NT-T2find or a nonNT

        if (!IsNonNtT2Find) {

            //
            // NT, we use the offsets that we stored earlier.........

            FileNameLength = SmbGetUlong(ThisEntryInBuffer+FileNameLengthOffset);
            FileNameBuffer = ThisEntryInBuffer+FileNameOffset;
            resumekey =  SmbGetUlong(ThisEntryInBuffer
                                             +FIELD_OFFSET(FILE_FULL_DIR_INFORMATION,FileIndex));
            NextEntryOffsetinBuffer = SmbGetUlong(ThisEntryInBuffer);

        } else {

            //
            // for lanman, we always ask for stuff using the SMB_FIND_BUFFER2 to which
            // we have prepended a resume key. so, the name is always at a fixed offset.
            // Also, for nonNT we have read all the files and must filter out correctly; we
            // save where we are in the user's buffer so that we can roll back.


            FileNameLength = *(ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileNameLength));
            FileNameBuffer = ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0]);
            resumekey =  SmbGetUlong(ThisEntryInBuffer+
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,ResumeKey));
            NextEntryOffsetinBuffer = FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0])
                                              + FileNameLength + 1;  //the +1 is for the null..we could have said Filename{1]

            PreviousPreviousReturnedEntry = PreviousReturnedEntry; //save this for rollback on filterfail
        }

        // some servers lie about how many entries were returned and/or send partial entries
        // dont let them trick us..........

        if (EntryOffset+NextEntryOffsetinBuffer>TotalDataBytesReturned){
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        if (FileNameLength > 0xFFFF) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            break;
        }

        FileName.Buffer = FileNameBuffer;
        FileName.Length = (USHORT)FileNameLength;
        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: EO,REO=%08lx,%08lx\n",
                                 EntryOffset,ReturnedEntryOffset));
        
        //check to see if this entry will fit
        if (IsUnicode) {
            NameSizeInUnicode = FileNameLength;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %wZ\n",
                                 FileNameLength,NameSizeInUnicode,&FileName));
        } else {
            //CODE.IMPROVEMENT should i use RtlOemStringToUnicodeSize???
            NameSizeInUnicode = RtlxOemStringToUnicodeSize(&FileName)-sizeof(WCHAR);
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %.*s\n",
                                 FileNameLength,NameSizeInUnicode,FileNameLength,FileNameBuffer));
        }


        //
        // now that we know the size of the name and its location, we need to copy it
        // to the user's buffer

        ThisEntrySize = FileNameOffset+NameSizeInUnicode;
        
        if ((!IsNonNtT2Find ||
            smbFobx->Enumeration.WildCardsFound) &&
            ((LONG)ThisEntrySize)>LocalLengthRemaining) {
            break;
        }

        if (((LONG)ThisEntrySize)>LocalLengthRemaining-(LONG)sizeof(WCHAR)) {
            TwoExtraBytes = FALSE;
        }


        ThisEntrySize = LongAlign(ThisEntrySize);
        PreviousReturnedEntry = (PULONG)(((PBYTE)pBuffer)+ReturnedEntryOffset);

        //
        // next we compute where the next entry after this one will start. the definition is
        // that it must be 8-byte aligned. we know already that it's 4byte aligned.

        if (!IsPtrQuadAligned((PCHAR)(PreviousReturnedEntry)+ThisEntrySize) ){
            ThisEntrySize += sizeof(ULONG);
        }
        if (i!=0) {
            ASSERT(IsPtrQuadAligned(PreviousReturnedEntry));
        }

        //
        // if this is an NT find, we can copy in the data now. for lanman, we
        // copy in the data later........

        if (!IsNonNtT2Find) {

            //copy everything in the entry up to but not including the name info
            RtlCopyMemory(PreviousReturnedEntry,UnalignedDirEntrySideBuffer+EntryOffset,FileNameOffset);

        } else {
            // clear out all fields i cannot support.
            RtlZeroMemory(PreviousReturnedEntry,FileNameOffset);
        }

        // store the length of this entry and the size of the name...if this is the last
        // entry returned, then the offset field will be cleared later

        *PreviousReturnedEntry = ThisEntrySize;
        *((PULONG)(((PBYTE)PreviousReturnedEntry)+FileNameLengthOffset)) = NameSizeInUnicode;

        //copy in the name  .........this is made difficult by the oem-->unicode routine that
        //             requires space for a NULL!  CODE.IMPROVEMENT maybe we should have own routine that
        //             doesn't require space for the null

        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: REO/buf/pentry=%08lx/%08lx/%08lx\n",
                                 pBuffer,ReturnedEntryOffset,PreviousReturnedEntry));
        ReturnedFileName.Buffer = (PWCH)(((PBYTE)PreviousReturnedEntry)+FileNameOffset);

        if (!IsUnicode) {
            if (TwoExtraBytes) {
                ReturnedFileName.MaximumLength = sizeof(WCHAR)+(USHORT)NameSizeInUnicode;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
            } else {
                ReturnedFileName.MaximumLength = (USHORT)NameSizeInUnicode;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToCountedUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
                ASSERT(StringStatus==RX_MAP_STATUS(SUCCESS));
            }
            ASSERT(StringStatus==RX_MAP_STATUS(SUCCESS));

            // Win95 returns the shortname in ascii....spread it out

            if ((FileInformationClass == FileBothDirectoryInformation) && !IsNonNtT2Find) {
                PFILE_BOTH_DIR_INFORMATION BothInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousReturnedEntry;
                OEM_STRING     oemName;
                UNICODE_STRING UnicodeName;
                WCHAR          wcharBuffer[MAX_PATH];

                oemName.Buffer = (PBYTE)(&BothInfo->ShortName[0]);
                oemName.Length =
                oemName.MaximumLength = BothInfo->ShortNameLength;

                UnicodeName.Buffer = wcharBuffer;
                UnicodeName.Length = 0;
                UnicodeName.MaximumLength = MAX_PATH * sizeof(WCHAR);

                StringStatus = RtlOemStringToUnicodeString(&UnicodeName, &oemName, FALSE);
                ASSERT(StringStatus==RX_MAP_STATUS(SUCCESS));

                BothInfo->ShortNameLength = (CHAR)UnicodeName.Length;
                RtlCopyMemory(BothInfo->ShortName, UnicodeName.Buffer, UnicodeName.Length);

                IF_DEBUG {
                    UNICODE_STRING LastName;
                    LastName.Buffer = (PWCHAR)wcharBuffer;
                    LastName.Length = (USHORT)UnicodeName.Length;
                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodeshortnamename = %wZ\n", &LastName));
                }
            }
        } else {

            //here, it's already unicode.....just copy the bytes
            RtlCopyMemory(ReturnedFileName.Buffer,FileName.Buffer,FileName.Length);

        }

        IF_DEBUG {
            UNICODE_STRING LastName;
            LastName.Buffer = ReturnedFileName.Buffer;
            LastName.Length = (USHORT)NameSizeInUnicode;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodename = %wZ\n", &LastName));
        }

        //now...setup to resume based on this entry

        if (ResumeInfo != NULL) {
            PREQ_FIND_NEXT2 pFindNext2Request = &ResumeInfo->FindNext2_Request;
            //ULONG resumekey = ((PFILE_FULL_DIR_INFORMATION)PreviousReturnedEntry)->FileIndex;
            //CODE.IMPROVEMENT put asserts here that all of the levels have the fileindex in the same spot
            //                 for goodness sake.....use a macro. actually, this code should go up above
            //                 where (a) all the types are visible and (b) it will execute on the NT path as well

            pFindNext2Request->ResumeKey = resumekey;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: resumekey = %08lx\n", resumekey));

            RtlCopyMemory(&pFindNext2Request->Buffer[0],FileNameBuffer,FileNameLength);

            //buffer is a UCHAR...not WCHAR
            if (IsUnicode) {
               // In the case of UNICODE strings an additional NULL is required ( WCHAR NULL )
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated
               pFindNext2Request->Buffer[FileNameLength + 1] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+2] - (PBYTE)pFindNext2Request);
            } else {
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+1] - (PBYTE)pFindNext2Request);
            }

        }

        //ASSERT(!IsNonNtT2Find);

        //at this point, we have copied the name and the resume key. BUT, for nonnt we have to
        //filter the names so we still may have to roll back

        if (!IsNonNtT2Find) {

            //no need for filtering on NT
            FilterFailure = FALSE;

        } else {

            // here we have to filter out based on the template

            RxCaptureFobx;  //do this here so it's not on the NT path
            FilterFailure = FALSE;

            if (smbFobx->Enumeration.WildCardsFound ) {
                try
                {
                    FilterFailure = !FsRtlIsNameInExpression(
                                           &capFobx->UnicodeQueryTemplate,
                                           &ReturnedFileName,
                                           TRUE,
                                           NULL );
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    FilterFailure = TRUE;                    
                }
            } else {
                FilterFailure = !RtlEqualUnicodeString(
                                       &capFobx->UnicodeQueryTemplate,
                                       &ReturnedFileName,
                                       TRUE );   //case-insensitive
            }

            if (!FilterFailure) {
                if (((LONG)ThisEntrySize)>LocalLengthRemaining) {
                    break;
                }

                // since we didn't copy the data before, we have to copy it now...

                MRxSmbTranslateLanManFindBuffer(RxContext,PreviousReturnedEntry,ThisEntryInBuffer);

            } else {

                PreviousReturnedEntry = PreviousPreviousReturnedEntry; //rollback on filterfail

            }
        }

        if (!FilterFailure) {

            // filtering succeeded..... adjust returned sizes and counts
            LocalLengthRemaining -= ThisEntrySize;
            i++;
            ReturnedEntryOffset += ThisEntrySize;

        } else {

            FilesReturned--;  //we exit the loop if i passes filesreturned
        }


        //
        // complicated test to keep going.......

        //EntryOffset += SmbGetUlong(UnalignedDirEntrySideBuffer+EntryOffset);
        EntryOffset += NextEntryOffsetinBuffer;
        if ((i>=FilesReturned)
            ||(LocalLengthRemaining<0)
            || (RxContext->QueryDirectory.ReturnSingleEntry&&(i>0))  ) {
            //CODE.IMPROVEMENT we could be more agressive than 0 in the compare against
            //  locallengthremaining....it's actually whatever
            //  the minimum recordsize is..........probably FileNameOffset
            break;
        }
     }

     if (Status == STATUS_SUCCESS) {
         //
         // if we are not returning even one entry, either we didn't have space for even one entry
         // OR we're filtering and no guys passed the filter. return an appropriate error in each case

         if (i==0) {

             Status = FilterFailure?STATUS_MORE_PROCESSING_REQUIRED:STATUS_BUFFER_OVERFLOW;

         } else {

            *PreviousReturnedEntry = 0;   // this clears the "next" link for the last returned entry
         }

         //
         // send back the right size

         if (LocalLengthRemaining <= 0) {
             *pLengthRemaining = 0;
         } else {
             *pLengthRemaining = (ULONG)LocalLengthRemaining;
         }

         //
         // if we're finished with the sidebuffer, deallocate it.
         // otherwise setup to resume........

         if (i>=FilesReturned) {

             RxLog(("sidebufdealloc %lx %lx\n",RxContext,smbFobx));
             SmbLog(LOG,
                    MrxSmbUnalignedDirEntryCopyTail,
                    LOGPTR(RxContext)
                    LOGPTR(smbFobx));
             MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Tail");
             if (EndOfSearchReached) {
                 //smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN;
                 //we will close the search handle when the user's handle closes
                 smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
             }

         } else {

             //set up to resume here
             ASSERT(smbFobx->Enumeration.UnalignedDirEntrySideBuffer == UnalignedDirEntrySideBuffer);
             smbFobx->Enumeration.EntryOffset = EntryOffset;
             smbFobx->Enumeration.FilesReturned = FilesReturned - i;

         }
     } else {
         smbFobx->Enumeration.ErrorStatus = Status;
         RxLog(("sidebufdealloc %lx %lx\n",RxContext,smbFobx));
         SmbLog(LOG,
                MrxSmbUnalignedDirEntryCopyTail,
                LOGPTR(RxContext)
                LOGPTR(smbFobx));
         MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Tail");
     }

     return(Status);
}

NTSTATUS
MRxSmbQueryDirectoryFromCache (
      PRX_CONTEXT             RxContext,
      PSMBPSE_FILEINFO_BUNDLE FileInfo
      )
/*++

Routine Description:

   This routine copies the data from the file information cache into the users buffer and adjusts the
   lengths remaining appropriately. This will avoid to send the FindFirst and FindClose requests to
   the server.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the basic and standard file information

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PBYTE   pBuffer = RxContext->Info.Buffer;
    PULONG  pLengthRemaining = &RxContext->Info.LengthRemaining;
    FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;

    PUNICODE_STRING FileName = &capFobx->UnicodeQueryTemplate;
    ULONG SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileName->Length;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbQueryDirectoryFromCache entry(%08lx)...%08lx %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass,pBuffer,*pLengthRemaining,
            smbFobx->Enumeration.ResumeInfo ));

    if (SpaceNeeded > *pLengthRemaining) {
        Status = STATUS_BUFFER_OVERFLOW;
        goto FINALLY;
    }

    RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);

    switch (FileInformationClass) {
    case FileNamesInformation:
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto FINALLY;
        break;

    case FileBothDirectoryInformation: 
        if (!UniqueFileNames) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto FINALLY;
        }
        
        // lack of break is intentional
    case FileDirectoryInformation:
    case FileFullDirectoryInformation: {
        PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;

        pThisBuffer->FileAttributes = FileInfo->Basic.FileAttributes;
        pThisBuffer->CreationTime   = FileInfo->Basic.CreationTime;
        pThisBuffer->LastAccessTime = FileInfo->Basic.LastAccessTime;
        pThisBuffer->LastWriteTime  = FileInfo->Basic.LastWriteTime;
        pThisBuffer->EndOfFile      = FileInfo->Standard.EndOfFile;
        pThisBuffer->AllocationSize = FileInfo->Standard.AllocationSize;
        break;
        }

    default:
       RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
       ASSERT(!"this can't happen");
       Status = STATUS_INVALID_PARAMETER;
       goto FINALLY;
    }

    RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset,
                  FileName->Buffer,
                  FileName->Length);
    *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileName->Length;

    *pLengthRemaining -= SpaceNeeded;

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbQueryDirectoryFromCache exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

ULONG MRxSmbWin95Retries = 0;

NTSTATUS
MRxSmbQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    )
/*++

Routine Description:

   This routine does a directory query. Only the NT-->NT path is implemented.
   //CODE.IMPROVEMENT.ASHAMED this code is UGLY and has no reasonable modularity............


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);
    PSMBCE_SESSION pSession = &pVNetRootContext->pSessionEntry->Session;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID   Buffer;
    PULONG  pLengthRemaining;

    USHORT    SmbFileInfoLevel;
    ULONG     FilesReturned;
    ULONG     RetryCount = 0;

    USHORT Setup;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    //REQ_FIND_NEXT2 FindNext2Request;
    PREQ_FIND_FIRST2 pFindFirst2Request = NULL;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer;
    PBYTE UnalignedDirEntrySideBuffer;
    BOOLEAN DirEntriesAreUaligned = FALSE;
    BOOLEAN IsUnicode = TRUE;
    BOOLEAN IsNonNtT2Find;
    USHORT SearchFlags = SMB_FIND_CLOSE_AT_EOS|SMB_FIND_RETURN_RESUME_KEYS;
    USHORT NumEntries;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength;
    //CODE.IMPROVEMENT this should be overallocated and unioned
    RESP_FIND_FIRST2 FindFirst2Response;
    SMBPSE_FILEINFO_BUNDLE FileInfo;
    UNICODE_STRING FileName = {0,0,NULL};
 
    struct {
        RESP_FIND_NEXT2  FindNext2Response;
        ULONG Pad; //nonnt needs this
    } XX;
#if DBG
    UNICODE_STRING smbtemplate = {0,0,NULL};
#endif

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();
    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryDirectory: directory=<%wZ>\n",
                            GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)
                        ));


#define __GET_NAME_PARAMS_FOR_TYPE(___type___) { \
           smbFobx->Enumeration.FileNameOffset = (USHORT)FIELD_OFFSET(___type___,FileName[0]); \
           smbFobx->Enumeration.FileNameLengthOffset = (USHORT)FIELD_OFFSET(___type___,FileNameLength); \
           }

    switch (FileInformationClass) {
    case FileDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_DIRECTORY_INFORMATION);
        break;
    case FileFullDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_FULL_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_FULL_DIR_INFORMATION);
        break;
    case FileBothDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_BOTH_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_BOTH_DIR_INFORMATION);
        break;
    case FileNamesInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_NAMES_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_NAMES_INFORMATION);
        break;
    case FileIdFullDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_ID_FULL_DIR_INFORMATION);
    break;
    case FileIdBothDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_ID_BOTH_DIR_INFORMATION);
    break;
   default:
      RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Invalid FS information class\n"));
      Status = STATUS_INVALID_PARAMETER;
      goto FINALLY;
   }


    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (CscPerformOperationInDisconnectedMode(RxContext)){
            NTSTATUS DirCtrlNtStatus;

            DirCtrlNtStatus = MRxSmbDCscQueryDirectory(RxContext);

            if (DirCtrlNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(0, Dbg,
                   ("MRxSmbQueryVolumeInfo returningDCON with status=%08lx\n",
                    DirCtrlNtStatus ));

                Status = DirCtrlNtStatus;
                goto FINALLY;
            } else {
                NOTHING;
            }
        }
    }


#if DBG
   if (MRxSmbLoudSideBuffers) {
       SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE);
   }
#endif

   if( RxContext->QueryDirectory.RestartScan )
   {
       ClearFlag( smbFobx->Enumeration.Flags, SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST );
       MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Restart");
   }

   if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST) &&
       (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_NO_WILDCARD) ||
        FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE))) {
       // if the FindFirst has been satisfied basied on local file information cache,
       // we should fail the FindNext since the file has been found with the exact name.


       Status = RX_MAP_STATUS(NO_MORE_FILES);
       smbFobx->Enumeration.EndOfSearchReached = TRUE;
       smbFobx->Enumeration.ErrorStatus = RX_MAP_STATUS(NO_MORE_FILES);
       ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE);
       goto FINALLY;
   }

   if (capFobx->UnicodeQueryTemplate.Length != 0 &&
       !FsRtlDoesNameContainWildCards(&capFobx->UnicodeQueryTemplate) &&
       !FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {
       // if it is the FindFirst, we try to find the file on local file information cache.

       PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
       PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
       UNICODE_STRING  TargetName = {0,0,NULL};

       TargetName.Length = DirectoryName->Length + Template->Length + sizeof(WCHAR);
       TargetName.MaximumLength = TargetName.Length;
       TargetName.Buffer = (PWCHAR)RxAllocatePoolWithTag(PagedPool,
                                                         TargetName.Length,
                                                         MRXSMB_DIRCTL_POOLTAG);

       if (TargetName.Buffer == NULL) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto FINALLY;
       }

       RtlCopyMemory(TargetName.Buffer,
                     DirectoryName->Buffer,
                     DirectoryName->Length);

       TargetName.Buffer[DirectoryName->Length/sizeof(WCHAR)] = L'\\';

       RtlCopyMemory(&TargetName.Buffer[DirectoryName->Length/sizeof(WCHAR)+1],
                     Template->Buffer,
                     Template->Length);

       if (MRxSmbIsFileInfoCacheFound(RxContext,
                                      &FileInfo,
                                      &Status,
                                      &TargetName)) {
           // if the file has been found on the local cache, we satisfy the FindFirst
           // basied on the cache.


           if (Status == STATUS_SUCCESS) {
               Status = MRxSmbQueryDirectoryFromCache(RxContext, &FileInfo);

               if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                   SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE);
                   RxFreePool(TargetName.Buffer);
                   goto FINALLY;
               }
           }
       }

       RxFreePool(TargetName.Buffer);
       SearchFlags |= SMB_FIND_CLOSE_AFTER_REQUEST;
       SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_NO_WILDCARD);
   }

     

   if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN)) {
       BOOLEAN AcquireExclusive = RxIsFcbAcquiredExclusive(capFcb);
       BOOLEAN AcquireShare = RxIsFcbAcquiredShared(capFcb) > 0;

       if (AcquireExclusive || AcquireShare) {
           RxReleaseFcbResourceInMRx(capFcb );
       }

       // connection could have been timed out, try to reconnect.
       Status = SmbCeReconnect(SrvOpen->pVNetRoot);

       if (AcquireExclusive) {
           RxAcquireExclusiveFcbResourceInMRx( capFcb );
       } else if (AcquireShare) {
           RxAcquireExclusiveFcbResourceInMRx( capFcb );
       }

       if (Status != STATUS_SUCCESS) {
           // connection cannot be recovered.
           goto FINALLY;
       }
   }

    //RxPurgeRelatedFobxs((PNET_ROOT)(capFcb->pNetRoot), RxContext, FALSE);
    //RxScavengeFobxsForNetRoot((PNET_ROOT)(capFcb->pNetRoot));

    if (MRxSmbForceCoreInfo ||
        !(pServerEntry->Server.DialectFlags&(DF_NT_SMBS|DF_W95|DF_LANMAN20))) {
        return MRxSmbCoreInformation(RxContext,
                                     (ULONG)SmbFileInfoLevel,
                                     Buffer,
                                     pLengthRemaining,
                                     SMBPSE_OE_FROM_QUERYDIRECTORY
                                     );
    }

    if (smbFobx->Enumeration.UnalignedDirEntrySideBuffer != NULL){
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: win95 internal resume\n"));
        Status = MrxSmbUnalignedDirEntryCopyTail(RxContext,
                                                 FileInformationClass,
                                                 Buffer,
                                                 pLengthRemaining,  //CODE.IMPROVEMENT dont pass args 2-4
                                                 smbFobx);
        


        if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
            return(Status);
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    NumEntries = RxContext->QueryDirectory.ReturnSingleEntry?1:2000;
    IsUnicode = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE);
    IsNonNtT2Find = !(pServerEntry->Server.Dialect==NTLANMAN_DIALECT);
    //CODE.IMPROVEMENT.ASHAMED put in the quadaligned optimization
    if (TRUE || FlagOn(pServerEntry->Server.DialectFlags,DF_W95)){
        DirEntriesAreUaligned = TRUE;
        //SearchFlags = SMB_FIND_RETURN_RESUME_KEYS;
        //SearchFlags = SMB_FIND_CLOSE_AT_EOS;
        NumEntries = (USHORT)(1+ UnalignedDirEntrySideBufferSize
                                /(IsNonNtT2Find?FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME, FileName)
                                               :FIELD_OFFSET(FILE_NAMES_INFORMATION, FileName)));
    }

    if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)
           && FlagOn(capFobx->Flags,FOBX_FLAG_BACKUP_INTENT)){
        SearchFlags |= SMB_FIND_WITH_BACKUP_INTENT;
        //CODE.IMPROVEMENT turn this back on!
        //SearchFlags |= SMB_FIND_CLOSE_AT_EOS;
    }

    if (IsNonNtT2Find) {
        SearchFlags &= ~(SMB_FIND_CLOSE_AT_EOS | SMB_FIND_CLOSE_AFTER_REQUEST);
    }

RETRY_____:

    if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
        FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        if (smbFobx->Enumeration.Version != pServerEntry->Server.Version) {
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST);
        }
    }

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {
        //this is the first time thru
        PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        RxDbgTrace(0, Dbg, ("-->FINFDIRST\n"));
        smbFobx->Enumeration.ErrorStatus = RX_MAP_STATUS(SUCCESS);
        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            //we need an upcased template for
            RtlUpcaseUnicodeString( Template, Template, FALSE );
        }
        Setup = TRANS2_FIND_FIRST2;
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(REQ_FIND_FIRST2)   //NOTE: this buffer is bigger than w95 needs
                            +2*sizeof(WCHAR)
                            +DirectoryNameLength
                            +TemplateLength;

        //CODE.IMPROVEMENT this would be a good place to have the xact studcode working......
        pFindFirst2Request = (PREQ_FIND_FIRST2)RxAllocatePoolWithTag(
                                                      PagedPool,
                                                      AllocationLength,
                                                      MRXSMB_DIRCTL_POOLTAG);
        if (pFindFirst2Request==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the pFindFirst2Request!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = &pFindFirst2Request->Buffer[0];
        if (IsUnicode) {

            RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
            SmbFileName += DirectoryNameLength;
            if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
                *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
            }
            RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
            SmbFileName += TemplateLength;
            *((PWCHAR)SmbFileName) = 0; SmbFileName+= sizeof(WCHAR); //trailing NULL;

            IF_DEBUG {
                DbgDoit(smbtemplate.Buffer = (PWCHAR)&pFindFirst2Request->Buffer[0];);
                DbgDoit(smbtemplate.Length = (USHORT)(SmbFileName - (PBYTE)smbtemplate.Buffer););
                RxDbgTrace(0, Dbg, ("  --> smbtemplate <%wZ>!\n",&smbtemplate));
            }

        } else {

            ULONG BufSize = AllocationLength;
            PUNICODE_STRING FinalTemplate = Template;
            UNICODE_STRING AllFiles;

            SmbPutUnicodeStringAsOemString(&SmbFileName,DirectoryName,&AllocationLength);

            // append a backslash if it doesn't exist in the unicode version
            // NB !!! Don't compare with OEM string
            // it busts DBCS characters with 0x5c at the end

            if (!DirectoryName->Length || (DirectoryName->Buffer[(DirectoryName->Length/sizeof(USHORT))-1] != (USHORT)'\\'))
            {
                *(SmbFileName-1) = '\\';
            }
            else
            {
                // there is already a backslash, backup one character
                SmbFileName -= 1; AllocationLength += 1;
            }

            if (IsNonNtT2Find) {
                //we'll get them all and filter on out side
                //CODE.IMPROVEMENT don't do that...translate the pattern
                RtlInitUnicodeString(&AllFiles,  L"*.*");
                FinalTemplate = &AllFiles;
            }

            SmbPutUnicodeStringAsOemString(&SmbFileName,FinalTemplate,&AllocationLength);
            //already padded *SmbFileName = 0; SmbFileName+= sizeof(CHAR); //trailing NULL;

            IF_DEBUG {
                DbgDoit(smbtemplate.Buffer = (PWCHAR)&pFindFirst2Request->Buffer[0];);
                DbgDoit(smbtemplate.Length = (USHORT)(SmbFileName - (PBYTE)smbtemplate.Buffer););
                RxDbgTrace(0, Dbg, ("  --> smbtemplate <%s>!\n",&pFindFirst2Request->Buffer[0]));
            }

        }

        // SearchAttributes is hardcoded to the magic number 0x16
        pFindFirst2Request->SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);

        pFindFirst2Request->SearchCount = NumEntries;
        pFindFirst2Request->Flags = SearchFlags;
        pFindFirst2Request->InformationLevel = IsNonNtT2Find?SMB_INFO_QUERY_EA_SIZE:SmbFileInfoLevel;
        pFindFirst2Request->SearchStorageType = 0;
        SendParamsBuffer = (PBYTE)pFindFirst2Request;
        SendParamsBufferLength = (ULONG)(SmbFileName - SendParamsBuffer);
        ReceiveParamsBuffer = (PBYTE)&FindFirst2Response;
        ReceiveParamsBufferLength = sizeof(FindFirst2Response);

    } else {
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            PREQ_FIND_NEXT2 pFindNext2Request;

            RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
            if (smbFobx->Enumeration.ErrorStatus != RX_MAP_STATUS(SUCCESS)) {
                Status = smbFobx->Enumeration.ErrorStatus;
                RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
                goto FINALLY;
            }
            Setup = TRANS2_FIND_NEXT2;
            pFindNext2Request = &smbFobx->Enumeration.ResumeInfo->FindNext2_Request;
            pFindNext2Request->Sid = smbFobx->Enumeration.SearchHandle;
            pFindNext2Request->SearchCount = NumEntries;
            pFindNext2Request->InformationLevel = IsNonNtT2Find?SMB_INFO_QUERY_EA_SIZE:SmbFileInfoLevel;
            //pFindNext2Request->ResumeKey and pFindNext2Request->Buffer are setup by the previous pass
            pFindNext2Request->Flags = SearchFlags;

            SendParamsBuffer = (PBYTE)pFindNext2Request;
            SendParamsBufferLength = smbFobx->Enumeration.ResumeInfo->ParametersLength;
            ReceiveParamsBuffer = (PBYTE)&XX.FindNext2Response;
            ReceiveParamsBufferLength = sizeof(XX.FindNext2Response);
            if (IsNonNtT2Find) {
                //
                // The LMX server wants this to be 10 instead of 8, for some reason.
                // If you set it to 8, the server gets very confused. Also, warp.
                //
                ReceiveParamsBufferLength = 10; //....sigh
            }
        } else {
            // if the ResumeInfo buffer was not allocated, the end of the search has been reached.
            Status = RX_MAP_STATUS(NO_MORE_FILES);
            smbFobx->Enumeration.EndOfSearchReached = TRUE;
            smbFobx->Enumeration.ErrorStatus = RX_MAP_STATUS(NO_MORE_FILES);
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE);
            goto FINALLY;
        }
    }

    //NTRAID-455632-2/2/2000-yunlin A smaller buffer should be used
    if ((DirEntriesAreUaligned) &&
        (smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL)) {
        MRxSmbAllocateSideBuffer(RxContext,smbFobx,
                         Setup, &smbtemplate
                         );
        if (smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the win95 sidebuffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }
        UnalignedDirEntrySideBuffer = smbFobx->Enumeration.UnalignedDirEntrySideBuffer;
        smbFobx->Enumeration.IsUnicode = IsUnicode;
        smbFobx->Enumeration.IsNonNtT2Find = IsNonNtT2Find;
    }

    {
        PSIDE_BUFFER SideBuffer;

        SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                        smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                        SIDE_BUFFER,
                                        Buffer);


        ASSERT(SideBuffer->Signature == 'JLBS');
        ASSERT(SideBuffer->Fobx == capFobx);
        ASSERT(SideBuffer->Fcb == capFcb);
        ASSERT(SideBuffer->smbFobx == smbFobx);
        ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
    }

    Status = SmbCeTransact(
                 RxContext,
                 pTransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 NULL,
                 0,
                 DirEntriesAreUaligned?UnalignedDirEntrySideBuffer:Buffer,      // the buffer for data
                 DirEntriesAreUaligned?UnalignedDirEntrySideBufferSize:*pLengthRemaining, // the length of the buffer
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        BOOLEAN EndOfSearchReached;

        {
            PSIDE_BUFFER SideBuffer;

            SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                            SIDE_BUFFER,
                                            Buffer);


            ASSERT(SideBuffer->Signature == 'JLBS');
            ASSERT(SideBuffer->Fobx == capFobx);
            ASSERT(SideBuffer->Fcb == capFcb);
            ASSERT(SideBuffer->smbFobx == smbFobx);
            ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
        }

        if (NT_SUCCESS(Status)) {
            // a) need to set the length remaining correctly
            // b) need to setup for a resume and see if the search was closed
            ULONG LastNameOffset=0;
            PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo = NULL;
            ULONG OriginalBufferLength = *pLengthRemaining;
            IF_DEBUG { LastNameOffset = 0x40000000; }

            RetryCount = 0;

            smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST;
            smbFobx->Enumeration.TotalDataBytesReturned = ResumptionContext.DataBytesReceived;

            if (Setup == TRANS2_FIND_FIRST2) {
                smbFobx->Enumeration.SearchHandle = FindFirst2Response.Sid;
                smbFobx->Enumeration.Version = ResumptionContext.ServerVersion;
                smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN; //but look right below
                //CODE.IMPROVEMENT since the responses look so much alike we could coalesce this code....
                EndOfSearchReached = (BOOLEAN)FindFirst2Response.EndOfSearch;
                FilesReturned = FindFirst2Response.SearchCount;
                LastNameOffset = FindFirst2Response.LastNameOffset;
            } else {
                EndOfSearchReached = (BOOLEAN)XX.FindNext2Response.EndOfSearch;
                FilesReturned = XX.FindNext2Response.SearchCount;
                LastNameOffset = XX.FindNext2Response.LastNameOffset;
            }

            //
            //  Please note: LANMAN 2.x servers prematurely set the
            //  EndOfSearch flag, so we must ignore it on LM 2.x servers.
            //
            //  NT Returns the correct information, none of the LM varients
            //  appear to do so.
            //
            if (IsNonNtT2Find) {
                EndOfSearchReached = FALSE;
            }

            if (Status==RX_MAP_STATUS(SUCCESS) && FilesReturned==0) {
                 RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: no files returned...switch status\n"));
                 EndOfSearchReached = TRUE;
                 Status = RX_MAP_STATUS(NO_MORE_FILES);
            }

            if (!DirEntriesAreUaligned) {
                *pLengthRemaining -= ResumptionContext.DataBytesReceived;
                if (EndOfSearchReached) {
                    smbFobx->Enumeration.ErrorStatus = RX_MAP_STATUS(NO_MORE_FILES);
                }
            }

            if (EndOfSearchReached ||
                SearchFlags & SMB_FIND_CLOSE_AFTER_REQUEST) {
                ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
            }

            if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)) {
                //if the search handle is open, then we set up to resume
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: rinfo = %08lx\n", smbFobx->Enumeration.ResumeInfo));

                if (smbFobx->Enumeration.ResumeInfo==NULL) {
                    smbFobx->Enumeration.ResumeInfo =
                         (PMRX_SMB_DIRECTORY_RESUME_INFO)RxAllocatePoolWithTag(
                                                            PagedPool,
                                                            sizeof(MRX_SMB_DIRECTORY_RESUME_INFO),
                                                            MRXSMB_DIRCTL_POOLTAG);

                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: allocatedinfo = %08lx\n", ResumeInfo));

                    if (smbFobx->Enumeration.ResumeInfo == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto FINALLY;
                    }
                }

                ResumeInfo = smbFobx->Enumeration.ResumeInfo;
                ASSERT (ResumeInfo!=NULL);

                {
                    PSIDE_BUFFER SideBuffer;

                    SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                                    smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                                    SIDE_BUFFER,
                                                    Buffer);


                    ASSERT(SideBuffer->Signature == 'JLBS');
                    ASSERT(SideBuffer->Fobx == capFobx);
                    ASSERT(SideBuffer->Fcb == capFcb);
                    ASSERT(SideBuffer->smbFobx == smbFobx);
                    ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
                }

                RxLog(("MRxqdir: rinfo = %lx", smbFobx->Enumeration.ResumeInfo));
                RxLog(("MRxqdir2: olen = %lx, thisl = %lx",
                                              OriginalBufferLength, ResumptionContext.DataBytesReceived));
                SmbLog(LOG,
                       MRxSmbQueryDirectory,
                       LOGPTR(smbFobx->Enumeration.ResumeInfo)
                       LOGULONG(OriginalBufferLength)
                       LOGULONG(ResumptionContext.DataBytesReceived));
                if (!DirEntriesAreUaligned) {
                    PBYTE LastEntry = ((PBYTE)Buffer)+LastNameOffset;
                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: lastentry = %08lx\n", LastEntry));
                    //this is for NT....the data is already in the buffer.......just setup the resume info
                    if (SmbFileInfoLevel>=SMB_FIND_FILE_DIRECTORY_INFO) { //we may start sending nonNT levels...could be an assert

                       PREQ_FIND_NEXT2 pFindNext2Request = &ResumeInfo->FindNext2_Request;
                       ULONG resumekey = ((PFILE_FULL_DIR_INFORMATION)LastEntry)->FileIndex;
                       ULONG FileNameLength; PWCHAR FileNameBuffer;

                       pFindNext2Request->ResumeKey = resumekey;
                       RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: resumekey = %08lx\n", resumekey));

                       FileNameLength = *((PULONG)(LastEntry+smbFobx->Enumeration.FileNameLengthOffset));
                       FileNameBuffer = (PWCHAR)(LastEntry+smbFobx->Enumeration.FileNameOffset);
                       IF_DEBUG {
                           UNICODE_STRING LastName;
                           LastName.Buffer = FileNameBuffer;
                           LastName.Length = (USHORT)FileNameLength;
                           RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: resumename = %wZ\n", &LastName));
                       }

                       ASSERT (  (((PBYTE)FileNameBuffer)+FileNameLength)
                                         <=(((PBYTE)Buffer)+OriginalBufferLength) );
                       RtlCopyMemory(&pFindNext2Request->Buffer[0],FileNameBuffer,FileNameLength);

                       //buffer is a UCHAR...not WCHAR
                       pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated in unicode
                       pFindNext2Request->Buffer[FileNameLength+1] = 0; //nullterminated in unicode
                       smbFobx->Enumeration.ResumeInfo->ParametersLength
                             = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+2] - (PBYTE)pFindNext2Request);

                    } else {
                       ASSERT(!"don't know how to get resume key/name for nonNT");
                    }
                }
            }
            {
                PSIDE_BUFFER SideBuffer;

                SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                                smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                                SIDE_BUFFER,
                                                Buffer);


                ASSERT(SideBuffer->Signature == 'JLBS');
                ASSERT(SideBuffer->Fobx == capFobx);
                ASSERT(SideBuffer->Fcb == capFcb);
                ASSERT(SideBuffer->smbFobx == smbFobx);
                ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
            }

            //for NT we are finished. for win95 we have to go thru the side buffer and
            //    1) copy in the data transforming ascii->unicode on the names, and
            //    2) remember the resume key and the filename of the last guy that we process
            //       because win95 doesn't 8byte aling things and because of unicode, we could end up
            //       with more data in the sidebuffer than we can return. this is very unfortunate.
            //       what would be cool CODE.IMPROVEMENT, would be to implement buffering in the wrapper

            // the code is moved down because we want to do it after the unlock
        }

        if (DirEntriesAreUaligned && (Status == STATUS_SUCCESS)) {
            smbFobx->Enumeration.FilesReturned = FilesReturned;
            smbFobx->Enumeration.EntryOffset = 0;
            smbFobx->Enumeration.EndOfSearchReached = EndOfSearchReached;
            
            Status = MrxSmbUnalignedDirEntryCopyTail(RxContext,
                                                     FileInformationClass,
                                                     Buffer,
                                                     pLengthRemaining,
                                                     smbFobx);
        }
    } else {
        // CODE IMPROVEMENT we should cache the file not found for findfirst as well
    }

FINALLY:
    //for downlevel-T2, we will have to go back to the server for some more.....sigh.......
    if (Status==STATUS_MORE_PROCESSING_REQUIRED) {
        goto RETRY_____;
    }

    //
    // under stress, the win95 server returns this......
    if ( (Status == STATUS_UNEXPECTED_NETWORK_ERROR)
              && FlagOn(pServerEntry->Server.DialectFlags,DF_W95)
              && (RetryCount < 10) ) {

        RetryCount++;
        MRxSmbWin95Retries++;
        goto RETRY_____;

    }

    if (pFindFirst2Request) RxFreePool(pFindFirst2Request);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Failed .. returning %lx\n",Status));
        //smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"ErrOut");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

RXDT_DefineCategory(VOLINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_VOLINFO)

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      );
NTSTATUS
MRxSmbQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information. Since the NT server does not
   handle bufferoverflow gracefully on query-fs-info, we allocate a buffer here
   that is big enough to hold anything passed back; then we call the "real"
   queryvolinfo routine.

Arguments:

    pRxContext         - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PVOID OriginalBuffer;
    ULONG OriginalLength = RxContext->Info.LengthRemaining;
    ULONG ReturnedLength;
    BOOLEAN UsingSideBuffer = FALSE;

    struct {
        union {
            FILE_FS_LABEL_INFORMATION labelinfo;
            FILE_FS_VOLUME_INFORMATION volumeinfo;
            FILE_FS_SIZE_INFORMATION sizeinfo;
            FILE_FS_DEVICE_INFORMATION deviceinfo;
            FILE_FS_ATTRIBUTE_INFORMATION attributeinfo;
            FILE_FS_CONTROL_INFORMATION controlinfo;
        } Info;
        WCHAR VolumeName[MAXIMUM_FILENAME_LENGTH];
    } SideBuffer;

    PAGED_CODE();

    if( RxContext->Info.LengthRemaining < sizeof( SideBuffer ) ) {
        //
        // i replace the buffer and length in the context with my stuff.
        // This, of course, means that we can't go async....for that we'd
        // have to allocate in stead of using a stack-allocated buffer.
        // In that case we would have to store the buffer somewhere in the
        // context for use with [CODE.IMPROVEMENT] downlevel guys. what would make
        // this work would be if CreateOE saved the exchange and stufferstate
        // values in the context before it overwrote them with its own.
        //
        // it's not immediately obvious that we should be allocating such a large
        // structure on the stack. CODE.IMPROVEMENT..........

        UsingSideBuffer = TRUE;
        OriginalBuffer = RxContext->Info.Buffer;
        RxContext->Info.Buffer = &SideBuffer;
        RxContext->Info.LengthRemaining = sizeof(SideBuffer);
    }

    Status = MRxSmbQueryVolumeInformationWithFullBuffer(RxContext);

    if (Status != STATUS_SUCCESS) {
        goto FINALLY;
    }

    if( UsingSideBuffer == TRUE ) {
        ReturnedLength = sizeof(SideBuffer) - RxContext->Info.LengthRemaining;
    } else {
        ReturnedLength = OriginalLength - RxContext->Info.LengthRemaining;
    }

    if (ReturnedLength > OriginalLength) {
        Status = STATUS_BUFFER_OVERFLOW;
        ReturnedLength = OriginalLength;
    }

    if( UsingSideBuffer == TRUE ) {
        RtlCopyMemory(OriginalBuffer,&SideBuffer,ReturnedLength);
    }

    RxContext->Info.LengthRemaining = OriginalLength - ReturnedLength;

FINALLY:
    return Status;
}

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    RxCaptureFobx;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    PVOID                pBuffer = RxContext->Info.Buffer;
    PLONG                pLengthRemaining  = &RxContext->Info.LengthRemaining;
    LONG                 OriginalLength = *pLengthRemaining;

    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    LARGE_INTEGER             CurrentTime;
    BOOLEAN DoAsDownLevel;

    PVOID                        pInputParamBuffer;
    ULONG                        InputParamBufferLength;
    USHORT                       InformationLevel;
    USHORT                       Setup;
    REQ_QUERY_FS_INFORMATION     QueryFsInformationRequest;
    REQ_QUERY_FS_INFORMATION_FID DfsQueryFsInformationRequest;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if ( FsInformationClass == FileFsDeviceInformation ) {

        PFILE_FS_DEVICE_INFORMATION UsersBuffer = (PFILE_FS_DEVICE_INFORMATION)pBuffer;
        PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

        UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;

        if (NetRoot->Type==NET_ROOT_PIPE) {
            NetRoot->DeviceType = RxDeviceType(NAMED_PIPE);
        }

        UsersBuffer->DeviceType = NetRoot->DeviceType;
        *pLengthRemaining  -= (sizeof(FILE_FS_DEVICE_INFORMATION));
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: devinfo .. returning\n"));

        return RX_MAP_STATUS(SUCCESS);
    }

    if (capFobx != NULL) {
       SrvOpen = capFobx->pSrvOpen;
       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
       pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);
       pNetRootEntry = pVNetRootContext->pNetRootEntry;
    } else {
       return RX_MAP_STATUS(INVALID_PARAMETER);
    }

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (CscPerformOperationInDisconnectedMode(RxContext)){
            NTSTATUS VolInfoNtStatus;

            VolInfoNtStatus = MRxSmbDCscQueryVolumeInformation(RxContext);

            if (VolInfoNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(-1, Dbg,
                   ("MRxSmbQueryVolumeInfo returningDCON with status=%08lx\n",
                    VolInfoNtStatus ));

                return(VolInfoNtStatus);

            } else {

                NOTHING;
                //RxDbgTrace(0, Dbg,
                //  ("MRxSmbQueryVolumeInfo continueingDCON with status=%08lx\n",
                //            VolInfoNtStatus ));
            }
        }
    }

    if (FsInformationClass == FileFsVolumeInformation) {
        KeQueryTickCount(&CurrentTime);

        if (CurrentTime.QuadPart < pNetRootEntry->VolumeInfoExpiryTime.QuadPart) {
            // use the cached volume information if it is not expired
            RtlCopyMemory(pBuffer,
                          pNetRootEntry->VolumeInfo,
                          pNetRootEntry->VolumeInfoLength);
            *pLengthRemaining -= pNetRootEntry->VolumeInfoLength;
            return STATUS_SUCCESS;
        }
    }

    for (;;) {
        if (capFobx != NULL) {
            PMRX_V_NET_ROOT pVNetRoot;

            // Avoid device opens for which the FOBX is the VNET_ROOT instance

            pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

            if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
                PUNICODE_STRING AlreadyPrefixedName =
                            GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
                ULONG FcbAlreadyPrefixedNameLength = AlreadyPrefixedName->Length;
                ULONG NetRootInnerNamePrefixLength = capFcb->pNetRoot->InnerNamePrefix.Length;
                PWCHAR pName = AlreadyPrefixedName->Buffer;

                // If an FSCTL is being attempted against the root of a share.
                // The AlreadyPrefixedName associated with the FCB is the same as
                // the AlreadyPrefixedName length associated with the NET_ROOT instance
                // or atmost one character greater than it ( appending a \) try and
                // reestablish the connection before attempting the FSCTL.
                // This solves thorny issues regarding deletion/creation of shares
                // on the server sides, DFS referrals etc.

                if ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength) ||
                    ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength + sizeof(WCHAR)) &&
                     (*((PCHAR)pName + FcbAlreadyPrefixedNameLength - sizeof(WCHAR)) ==
                        L'\\'))) {
                    Status = SmbCeReconnect(capFobx->pSrvOpen->pVNetRoot);
                }
            }
        }

        DoAsDownLevel = MRxSmbForceCoreInfo;

        if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            DoAsDownLevel = TRUE;
        }

        if (FlagOn(pServerEntry->Server.DialectFlags,DF_W95)
            && (FsInformationClass==FileFsAttributeInformation)){ //use uplevel for w95 attribute info
            DoAsDownLevel = FALSE;
        }

        if (DoAsDownLevel) {
            Status = MRxSmbCoreInformation(RxContext,
                                        (ULONG)FsInformationClass,
                                        pBuffer,
                                        pLengthRemaining,   //CODE.IMPROVEMENT dont pass args 2-4
                                        SMBPSE_OE_FROM_QUERYVOLUMEINFO
                                       );
            goto FINALLY;
        }

        Status = STATUS_MORE_PROCESSING_REQUIRED;

        switch (FsInformationClass) {
        case FileFsVolumeInformation :
            InformationLevel = SMB_QUERY_FS_VOLUME_INFO;
            break;

        case FileFsLabelInformation :
            InformationLevel = SMB_QUERY_FS_LABEL_INFO;
            break;

        case FileFsSizeInformation :
            InformationLevel = SMB_QUERY_FS_SIZE_INFO;
            break;

        case FileFsAttributeInformation :
            InformationLevel = SMB_QUERY_FS_ATTRIBUTE_INFO;
            break;

        default:
            if( FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH ) ) {
                InformationLevel = FsInformationClass + SMB_INFO_PASSTHROUGH;
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: Invalid FS information class\n"));
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        }

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
            PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
            PMRX_SRV_OPEN                       SrvOpen    = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN                   smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            if (!FlagOn(pServerEntry->Server.DialectFlags,DF_DFS_TRANS2)) {
                Setup                 = TRANS2_QUERY_FS_INFORMATION;
                QueryFsInformationRequest.InformationLevel = InformationLevel;
                pInputParamBuffer      = &QueryFsInformationRequest;
                InputParamBufferLength = sizeof(QueryFsInformationRequest);
            } else {
                Setup = TRANS2_QUERY_FS_INFORMATION_FID;
                DfsQueryFsInformationRequest.InformationLevel = InformationLevel;
                DfsQueryFsInformationRequest.Fid = smbSrvOpen->Fid;
                pInputParamBuffer                 = &DfsQueryFsInformationRequest;
                InputParamBufferLength            = sizeof(DfsQueryFsInformationRequest);
            }

            Status = SmbCeTransact(
                         RxContext,
                         pTransactionOptions,
                         &Setup,
                         sizeof(Setup),
                         NULL,
                         0,
                         pInputParamBuffer,
                         InputParamBufferLength,
                         NULL,
                         0,
                         NULL,
                         0,
                         pBuffer,
                         *pLengthRemaining,
                         &ResumptionContext);

            if (NT_SUCCESS(Status)) {
                *pLengthRemaining  -= ResumptionContext.DataBytesReceived;
                 //CODE.IMPROVEMENT if this is a size query, we should store the clustersize in the netroot
                 //                 this would save us one packet later.
            }
        }

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: Failed .. returning %lx\n",Status));
        }

        if (Status != STATUS_NETWORK_NAME_DELETED) {
            break;
        }
    }

FINALLY:

    if ((Status == STATUS_SUCCESS) &&
        (FsInformationClass == FileFsVolumeInformation)) {
        LARGE_INTEGER ExpiryTimeInTicks;
        LONG VolumeInfoLength = OriginalLength - *pLengthRemaining;
        
        if (VolumeInfoLength > pNetRootEntry->VolumeInfoLength) {
            // If the Volume Label gets longer, allocate a new buffer
            if (pNetRootEntry->VolumeInfo != NULL) {
                RxFreePool(pNetRootEntry->VolumeInfo);
            }

            pNetRootEntry->VolumeInfo = RxAllocatePoolWithTag(PagedPool,
                                                              VolumeInfoLength,
                                                              MRXSMB_QPINFO_POOLTAG);
        }
        
        if (pNetRootEntry->VolumeInfo != NULL) {
            KeQueryTickCount(&CurrentTime);
            ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();
            ExpiryTimeInTicks.QuadPart = ExpiryTimeInTicks.QuadPart * NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME;

            pNetRootEntry->VolumeInfoExpiryTime.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;

            RtlCopyMemory(pNetRootEntry->VolumeInfo,
                          pBuffer,
                          VolumeInfoLength);
            pNetRootEntry->VolumeInfoLength = VolumeInfoLength;
        } else {
            pNetRootEntry->VolumeInfoLength = 0;
        }
    }
    
    return Status;
}

NTSTATUS
MRxSmbSetVolumeInformation(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    BOOLEAN ServerSupportsPassThroughForSetInfo = FALSE;

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (CscPerformOperationInDisconnectedMode(RxContext)){
            return STATUS_NOT_SUPPORTED;
        }
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer              = RxContext->Info.Buffer;
    BufferLength         = RxContext->Info.Length;

    if (!MRxSmbForceCoreInfo &&
        FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH)) {

        ServerSupportsPassThroughForSetInfo = TRUE;
    }

    if (ServerSupportsPassThroughForSetInfo) {
        USHORT Setup = TRANS2_SET_FS_INFORMATION;

        REQ_SET_FS_INFORMATION  SetFsInfoRequest;

        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;


        if (capFobx != NULL) {
            PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            SetFsInfoRequest.Fid              = smbSrvOpen->Fid;
            SetFsInfoRequest.InformationLevel = FileInformationClass +
                                                SMB_INFO_PASSTHROUGH;

            Status = SmbCeTransact(
                         RxContext,
                         pTransactionOptions,
                         &Setup,
                         sizeof(Setup),
                         NULL,
                         0,
                         &SetFsInfoRequest,
                         sizeof(SetFsInfoRequest),
                         NULL,
                         0,
                         pBuffer,
                         BufferLength,
                         NULL,
                         0,
                         &ResumptionContext);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {
        Status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Failed .. returning %lx\n",Status));
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

RXDT_DefineCategory(FILEINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_FILEINFO)

LONG GFAFromLocal;

NTSTATUS
MRxSmbQueryFileInformation(
    IN PRX_CONTEXT            RxContext )
/*++

Routine Description:

   This routine does a query file info.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID              pBuffer;
    PULONG             pLengthRemaining;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX     smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PUNICODE_STRING   RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT     NetRoot = capFcb->pNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
    PSMBCE_NET_ROOT   pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;

    USHORT SmbFileInfoLevel;

    USHORT Setup;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    REQ_QUERY_FILE_INFORMATION  QueryFileInfoRequest;
    RESP_QUERY_FILE_INFORMATION QueryFileInfoResponse;
    PREQ_QUERY_PATH_INFORMATION pQueryFilePathRequest = NULL;

    PVOID pSendParameterBuffer;
    ULONG SendParameterBufferLength;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;


    RxDbgTrace(+1, Dbg, ("MRxSmbQueryFileInformation: class=%08lx\n",FileInformationClass));

    //CODE.IMPROVEMENT.ASHAMED it is a real SHAME is that we don't do a SMB_QUERY_FILE_ALL_INFO
    //    in response to a FileAllInformation request. what we should do is to call down with all_info;
    //    if the mini returns SNI then we do the individual pieces. the problem with all_info is that
    //    it contains the name and that might cause it to overflow my buffer! however, a name can only be 32k
    //    so i could waltz around that with a big buffer.

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

/*
    // begin init code to replace switch with table lookup

#define SMB_QUERY_FILE_INFO_INVALID_REQ 0xFFF
#define SMB_QUERY_FILE_INFO_PIPE_REQ 0xFFE

    USHORT NtToSmbQueryFileInfo[FileMaximumInformation];
    for (i=0; i < FileMaximumInformation; i++) {
        NtToSmbQueryFileInfo[i] = SMB_QUERY_FILE_INFO_INVALID_REQ;
    }

    NtToSmbQueryFileInfo[FileBasicInformation] =         SMB_QUERY_FILE_BASIC_INFO;
    NtToSmbQueryFileInfo[FileStandardInformation] =      SMB_QUERY_FILE_STANDARD_INFO;
    NtToSmbQueryFileInfo[FileEaInformation] =            SMB_QUERY_FILE_EA_INFO;
    NtToSmbQueryFileInfo[FileAllocationInformation] =    SMB_QUERY_FILE_ALLOCATION_INFO;
    NtToSmbQueryFileInfo[FileEndOfFileInformation] =     SMB_QUERY_FILE_END_OF_FILEINFO;
    NtToSmbQueryFileInfo[FileAlternateNameInformation] = SMB_QUERY_FILE_ALT_NAME_INFO;
    NtToSmbQueryFileInfo[FileStreamInformation] =        SMB_QUERY_FILE_STREAM_INFO;
    NtToSmbQueryFileInfo[FilePipeInformation] =          SMB_QUERY_FILE_INFO_PIPE_REQ;
    NtToSmbQueryFileInfo[FilePipeLocalInformation] =     SMB_QUERY_FILE_INFO_PIPE_REQ;
    NtToSmbQueryFileInfo[FilePipeRemoteInformation] =    SMB_QUERY_FILE_INFO_PIPE_REQ;
    NtToSmbQueryFileInfo[FileCompressionInformation] =   SMB_QUERY_FILE_COMPRESSION_INFO;
    // end init


    if (FileInformationClass < FileMaximumInformation) {
        SmbFileInfoLevel = NtToSmbQueryFileInfo[FileInformationClass];
    } else {
        SmbFileInfoLevel = SMB_QUERY_FILE_INFO_INVALID_REQ;
    }

    if (SmbFileInfoLevel == SMB_QUERY_FILE_INFO_PIPE_REQ) {

        //CODE.IMPROVEMENT the last thress params should not be passed...........

       return MRxSmbQueryNamedPipeInformation(RxContext,FileInformationClass,pBuffer,pLengthRemaining);

    } else if (SmbFileInfoLevel == SMB_QUERY_FILE_INFO_INVALID_REQ) {

        RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Invalid FS information class\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
    }
*/

    if( FileInformationClass == FilePipeLocalInformation ||
        FileInformationClass == FilePipeInformation ||
        FileInformationClass == FilePipeRemoteInformation ) {

        return MRxSmbQueryNamedPipeInformation(
                   RxContext,
                   FileInformationClass,
                   pBuffer,
                   pLengthRemaining);
    }

    Status = STATUS_SUCCESS;
    
    switch (FileInformationClass) {
    case FileEaInformation:
        if (smbSrvOpen->IsNtCreate && 
            smbSrvOpen->FileStatusFlags & SMB_FSF_NO_EAS &&
            (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_BATCH ||
             smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_EXCLUSIVE)) {
            PFILE_EA_INFORMATION EaBuffer = (PFILE_EA_INFORMATION)pBuffer;

            EaBuffer->EaSize = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        }
        break;
    
    case FileStreamInformation:
        if (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_FAT) {
            // FAT doesn't have the stream
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }
        break;

    case FileAttributeTagInformation:
        if (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_FAT ||
            !(smbSrvOpen->FileInfo.Basic.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||
            smbSrvOpen->IsNtCreate && 
            smbSrvOpen->FileStatusFlags & SMB_FSF_NO_REPARSETAG &&
            (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_BATCH ||
             smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_EXCLUSIVE)) {
            PFILE_ATTRIBUTE_TAG_INFORMATION TagBuffer = (PFILE_ATTRIBUTE_TAG_INFORMATION)pBuffer;

            TagBuffer->FileAttributes = smbSrvOpen->FileInfo.Basic.FileAttributes;
            TagBuffer->ReparseTag = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_ATTRIBUTE_TAG_INFORMATION);
            goto FINALLY;
        }
    }
    
    if( MRxSmbForceCoreInfo ||
        !FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH ) ||
        MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {

        switch (FileInformationClass) {
        case FileBasicInformation:
            SmbFileInfoLevel = SMB_QUERY_FILE_BASIC_INFO;
            break;

        case FileStandardInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_STANDARD_INFO;
            break;

        case FileEaInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_EA_INFO;
            break;

        case FileAllocationInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_ALLOCATION_INFO;
            break;

        case FileEndOfFileInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_END_OF_FILEINFO;
            break;

        case FileAlternateNameInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_ALT_NAME_INFO;
            break;

        case FileStreamInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_STREAM_INFO;
            break;

        case FileCompressionInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_COMPRESSION_INFO;
            break;

        case FileInternalInformation:
            {
                PFILE_INTERNAL_INFORMATION UsersBuffer = (PFILE_INTERNAL_INFORMATION)pBuffer;
                //
                //  Note: We use the address of the FCB to determine the
                //  index number of the file.  If we have to maintain persistance between
                //  file opens for this request, then we might have to do something
                //  like checksuming the reserved fields on a FUNIQUE SMB response.
                //

                //
                // NT64: the address of capFcb used to be stuffed into
                //       IndexNumber.LowPart, with HighPart being zeroed.
                //
                //       Whoever is asking for this pointer value should be
                //       prepared to deal with the returned 64-bit value.
                //

                UsersBuffer->IndexNumber.QuadPart = (ULONG_PTR)capFcb;
                *pLengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
                Status = STATUS_SUCCESS;
            }
            goto FINALLY;

        default:
            RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Invalid FS information class\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }

    } else {

        //
        // This server supports transparent NT information level passthrough.  So
        //  just pass the request on to the server.
        //
        SmbFileInfoLevel = FileInformationClass + SMB_INFO_PASSTHROUGH;
    }

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (CscPerformOperationInDisconnectedMode(RxContext) ||
            FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN)){
            NTSTATUS QFINtStatus;

            QFINtStatus = MRxSmbDCscQueryFileInfo(RxContext);

            if (QFINtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(0, Dbg,
                   ("MRxSmbQueryFileInformation returningDCON with status=%08lx\n",
                    QFINtStatus ));

                Status = QFINtStatus;
                goto FINALLY;

            }
        }
    }

    if (MRxSmbIsFileNotFoundCached(RxContext)) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryFileInformation: FNF cached\n"));
        goto FINALLY;
    }

    // Don't use cached information for the request from create against an aliased server
    // so that we can be sure if it exists on the server.
    if ((!pServerEntry->Server.AliasedServers ||
         !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED)) &&
        (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ||
         FlagOn(capFcb->FcbState,FCB_STATE_FILESIZECACHEING_ENABLED) ||
         FileInformationClass == FileInternalInformation)) {
        switch (FileInformationClass) {
        case FileBasicInformation:
            if (MRxSmbIsBasicFileInfoCacheFound(RxContext,
                                                (PFILE_BASIC_INFORMATION)pBuffer,
                                                &Status,
                                                NULL)){
                *pLengthRemaining -= sizeof(FILE_BASIC_INFORMATION);
                RxDbgTrace( 0, Dbg, ("MRxSmbQueryFileInformation: Local Basic Info\n"));
                return Status;
            }
            break;

        case FileStandardInformation:
            if (MRxSmbIsStandardFileInfoCacheFound(RxContext,
                                                   (PFILE_STANDARD_INFORMATION)pBuffer,
                                                   &Status,
                                                   NULL)){
                *pLengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
                RxDbgTrace( 0, Dbg, ("MRxSmbQueryFileInformation: Local Standard Info\n"));
                return Status;
            }
            break;

        case FileEndOfFileInformation:
            {
                FILE_STANDARD_INFORMATION Standard;

                if (MRxSmbIsStandardFileInfoCacheFound(RxContext,
                                                       &Standard,
                                                       &Status,
                                                       NULL)){
                    ((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.QuadPart = Standard.EndOfFile.QuadPart;

                    *pLengthRemaining -= sizeof(FILE_END_OF_FILE_INFORMATION);
                    RxDbgTrace( 0, Dbg, ("MRxSmbQueryFileInformation: Local EndOfFile Info\n"));
                    return Status;
                }
            }
            break;
        
        case FileInternalInformation:
            if (MRxSmbIsInternalFileInfoCacheFound(RxContext,
                                                (PFILE_INTERNAL_INFORMATION)pBuffer,
                                                &Status,
                                                NULL)){
                *pLengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
                RxDbgTrace( 0, Dbg, ("MRxSmbQueryFileInformation: Local Internal Info\n"));
                return Status;
            }
            break;
        }
    }


    if (MRxSmbForceCoreInfo ||
        FlagOn(pServerEntry->Server.DialectFlags,DF_W95) ||
        !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        // Win9x server supports NT SMB but doesn't support transact2. Therefore we use core.

        return MRxSmbCoreInformation(
                   RxContext,
                   (ULONG)SmbFileInfoLevel,
                   pBuffer,
                   pLengthRemaining,
                   SMBPSE_OE_FROM_QUERYFILEINFO
                   );
    }

    Status = STATUS_SUCCESS;

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
       //here, the FID is valid. do a t2_QFI
        Setup = TRANS2_QUERY_FILE_INFORMATION;
        QueryFileInfoRequest.Fid = smbSrvOpen->Fid;
        QueryFileInfoRequest.InformationLevel = SmbFileInfoLevel;
        pSendParameterBuffer = &QueryFileInfoRequest;
        SendParameterBufferLength = sizeof(QueryFileInfoRequest);
        RxDbgTrace(0, Dbg, (" fid,smbclass=%08lx,%08lx\n",smbSrvOpen->Fid,SmbFileInfoLevel));
    } else {
        OEM_STRING OemName;
        BOOLEAN    FreeOemName = FALSE;

        Setup = TRANS2_QUERY_PATH_INFORMATION;

        if (!FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
            if (FlagOn(pServerEntry->Server.DialectFlags,DF_LONGNAME)) {
                Status = RtlUnicodeStringToOemString(&OemName, RemainingName, TRUE);
            } else {
                Status = RtlUpcaseUnicodeStringToOemString(&OemName, RemainingName, TRUE);
            }

            if (Status == STATUS_SUCCESS) {
                SendParameterBufferLength = FIELD_OFFSET(REQ_QUERY_PATH_INFORMATION,Buffer[0])
                                                + OemName.Length + sizeof(CHAR); //null-terminated
                FreeOemName = TRUE;
            }
        } else {
           SendParameterBufferLength = FIELD_OFFSET(REQ_QUERY_PATH_INFORMATION,Buffer[0])
                                           + RemainingName->Length + sizeof(WCHAR); //null-terminated
        }

        if (Status == STATUS_SUCCESS) {
            pSendParameterBuffer = RxAllocatePoolWithTag(PagedPool,
                                                         SendParameterBufferLength,
                                                         MRXSMB_QPINFO_POOLTAG);

            pQueryFilePathRequest = pSendParameterBuffer;
        
            if (pQueryFilePathRequest != NULL) {
                pQueryFilePathRequest->InformationLevel = SmbFileInfoLevel;
                SmbPutUlong(&pQueryFilePathRequest->Reserved,0);
    
                if (FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                    RtlCopyMemory(&pQueryFilePathRequest->Buffer[0],RemainingName->Buffer,RemainingName->Length);
                    *((PWCHAR)(&pQueryFilePathRequest->Buffer[RemainingName->Length])) = 0;
                } else {
                    RtlCopyMemory(&pQueryFilePathRequest->Buffer[0],OemName.Buffer,OemName.Length);
                    *((PCHAR)(&pQueryFilePathRequest->Buffer[OemName.Length])) = 0;
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (FreeOemName) {
            RtlFreeOemString(&OemName);
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeTransact(
                     RxContext,
                     pTransactionOptions,
                     &Setup,
                     sizeof(Setup),
                     NULL,
                     0,
                     pSendParameterBuffer,
                     SendParameterBufferLength,
                     &QueryFileInfoResponse,
                     sizeof(QueryFileInfoResponse),
                     NULL,
                     0,
                     pBuffer,
                     *pLengthRemaining,
                     &ResumptionContext);

        if (NT_SUCCESS(Status)) {
            *pLengthRemaining -= ResumptionContext.DataBytesReceived;
        }
    }

    //
    // Check for file not found status.  If this is the case then create a
    // name cache entry in the NetRoot name cache and record the status,
    // the smb received count and set the expiration time for 5 seconds.
    // Why: NB4 case of back to back srv reqs with 2nd req upcased.
    //

    

    if (NT_SUCCESS(Status)) {
        //
        // The request succeeded so free up the name cache entry.
        //
        MRxSmbInvalidateFileNotFoundCache(RxContext);

        // cache the file info returned from the server.
        switch (FileInformationClass) {
        case FileBasicInformation:
            MRxSmbCreateBasicFileInfoCache(RxContext,
                                           (PFILE_BASIC_INFORMATION)pBuffer,
                                           pServerEntry,
                                           Status);
            break;

        case FileStandardInformation:
            if (FlagOn(capFcb->FcbState,FCB_STATE_WRITEBUFFERING_ENABLED) &&
                !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                PFILE_STANDARD_INFORMATION Standard = (PFILE_STANDARD_INFORMATION)pBuffer;

                RxGetFileSizeWithLock((PFCB)capFcb,&Standard->EndOfFile.QuadPart);
            }

            MRxSmbCreateStandardFileInfoCache(RxContext,
                                              (PFILE_STANDARD_INFORMATION)pBuffer,
                                              pServerEntry,
                                              Status);
            break;

        case FileEndOfFileInformation:
            MRxSmbUpdateFileInfoCacheFileSize(RxContext,
                                              &((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile);
            break;
        
        case FileInternalInformation:
            MRxSmbCreateInternalFileInfoCache(RxContext,
                                              (PFILE_INTERNAL_INFORMATION)pBuffer,
                                              pServerEntry,
                                              Status);
            break;
        }
    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);
        }

        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);
    
    }

FINALLY:

    if (pQueryFilePathRequest != NULL) {
        RxFreePool(pQueryFilePathRequest);
    }

    if (!NT_SUCCESS(Status)) {
         RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Failed .. returning %lx\n",Status));
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

NTSTATUS
MRxSmbQueryFileInformationFromPseudoOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    FILE_INFORMATION_CLASS FileInformationClass
    )
/*++

Routine Description:

   This routine does a query file basic info from pseudo open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT LocalRxContext;

    PAGED_CODE();

    LocalRxContext = RxAllocatePoolWithTag(NonPagedPool,
                                           sizeof(RX_CONTEXT),
                                           MRXSMB_RXCONTEXT_POOLTAG);

    if (LocalRxContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        RtlZeroMemory(
            LocalRxContext,
            sizeof(RX_CONTEXT));

        RxInitializeContext(
            NULL,
            RxContext->RxDeviceObject,
            0,
            LocalRxContext );

        LocalRxContext->pFcb = RxContext->pFcb;
        LocalRxContext->pFobx = RxContext->pFobx;
        LocalRxContext->CurrentIrp = RxContext->CurrentIrp;
        LocalRxContext->CurrentIrpSp = RxContext->CurrentIrpSp;
        LocalRxContext->NonPagedFcb = RxContext->NonPagedFcb;
        LocalRxContext->MajorFunction = IRP_MJ_CREATE;
        LocalRxContext->pRelevantSrvOpen = RxContext->pRelevantSrvOpen;;
        LocalRxContext->Flags = RX_CONTEXT_FLAG_MINIRDR_INITIATED|RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK;

        switch (FileInformationClass) {
        case FileBasicInformation:
            LocalRxContext->Info.LengthRemaining = sizeof(FILE_BASIC_INFORMATION);
            LocalRxContext->Info.Buffer = &OrdinaryExchange->Create.FileInfo.Basic;
            break;
        case FileInternalInformation:
            LocalRxContext->Info.LengthRemaining = sizeof(FILE_INTERNAL_INFORMATION);
            LocalRxContext->Info.Buffer = &OrdinaryExchange->Create.FileInfo.Internal;
            //DbgPrint("Query file internal information from create\n");
            break;
        }

        LocalRxContext->Info.FileInformationClass = FileInformationClass;
        LocalRxContext->Create = RxContext->Create;

        Status = MRxSmbQueryFileInformation(LocalRxContext);
        
        RxFreePool(LocalRxContext);
    }

    if ((Status == STATUS_SUCCESS) && 
        (FileInformationClass == FileBasicInformation)) {
        OrdinaryExchange->Create.FileInfo.Standard.Directory = 
            BooleanFlagOn(OrdinaryExchange->Create.FileInfo.Basic.FileAttributes,FILE_ATTRIBUTE_DIRECTORY);

        OrdinaryExchange->Create.StorageTypeFromGFA =
            OrdinaryExchange->Create.FileInfo.Standard.Directory ?
            FileTypeDirectory : FileTypeFile;
    }

    return Status;
}

typedef enum _INTERESTING_SFI_FOLLOWONS {
    SFI_FOLLOWON_NOTHING,
    SFI_FOLLOWON_DISPOSITION_SENT
} INTERESTING_SFI_FOLLOWONS;


NTSTATUS
MRxSmbSetFileInformation (
      IN PRX_CONTEXT  RxContext
      )
/*++

Routine Description:

   This routine does a set file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

   The file is not really open if it is created for delete. In this case, set dispostion info
   will be delayed until file is closed.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;

    PMRX_SRV_OPEN   SrvOpen = capFobx->pSrvOpen;

    PMRX_SMB_FCB      smbFcb  = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX     smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
    PSMBCE_NET_ROOT   pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    USHORT SmbFileInfoLevel;

    USHORT Setup;

    INTERESTING_SFI_FOLLOWONS FollowOn = SFI_FOLLOWON_NOTHING;
    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    REQ_SET_FILE_INFORMATION SetFileInfoRequest;
    RESP_SET_FILE_INFORMATION SetFileInfoResponse;
    PREQ_SET_PATH_INFORMATION pSetFilePathRequest = NULL;

    PVOID pSendParameterBuffer;
    ULONG SendParameterBufferLength;

    BOOLEAN fDoneCSCPart=FALSE;
    BOOLEAN UseCore = FALSE;

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    FileInformationClass = RxContext->Info.FileInformationClass;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFile: Class %08lx size %08lx\n",FileInformationClass,BufferLength));

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        if (CscPerformOperationInDisconnectedMode(RxContext)){
            NTSTATUS SFINtStatus;

            SFINtStatus = MRxSmbDCscSetFileInfo(RxContext);

            fDoneCSCPart = TRUE;

            if (SFINtStatus != STATUS_MORE_PROCESSING_REQUIRED) {

                RxDbgTrace(0, Dbg,
                   ("MRxSmbSetFileInformation returningDCON with status=%08lx\n",
                    SFINtStatus ));

#ifdef LocalOpen
                if (FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN)) {
                    switch( FileInformationClass ) {
                    case FileRenameInformation:
                        MRxSmbRename( RxContext );
                        break;
                    }
                }
#endif

                Status = SFINtStatus;
                goto FINALLY;
            } else {
                NOTHING;
            }
        }
        else if (FileInformationClass == FileDispositionInformation)
        {
            if(CSCCheckLocalOpens(RxContext))
            {
                // disallow deletes if there are local open on this file
                // This happens only on a VDO marked share
                Status = STATUS_ACCESS_DENIED;
                goto FINALLY;
            }
        }
    }

    if (MRxSmbIsFileNotFoundCached(RxContext)) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        RxDbgTrace( 0, Dbg, ("MRxSmbSetFileInformation: FNF cached\n"));
        goto FINALLY;
    }

    if (FileInformationClass != FileBasicInformation &&
        FileInformationClass != FileDispositionInformation &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {

        Status = MRxSmbDeferredCreate(RxContext);

        if (Status != STATUS_SUCCESS) {
            goto FINALLY;
        }
    }

    if( FileInformationClass == FilePipeLocalInformation ||
        FileInformationClass == FilePipeInformation ||
        FileInformationClass == FilePipeRemoteInformation ) {

        return MRxSmbSetNamedPipeInformation(
                   RxContext,
                   FileInformationClass,
                   pBuffer,
                   BufferLength);
    }

    if (!MRxSmbForceCoreInfo &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
        FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH)) {

        SmbFileInfoLevel = FileInformationClass + SMB_INFO_PASSTHROUGH;

        if( FileInformationClass == FileRenameInformation ) {
            PFILE_RENAME_INFORMATION pRenameInformation;

            // The current implementation of pass through for rename information
            // on the server does not go all the way in implementing the
            // NT_TRANSACT, NT_RENAME function defined in SMBs. Therefore we need
            // to special case the code to accomodate the server implementation
            // The two cases that are not permitted are relative renames,
            // specifying a non null root directory and deep renames which
            // transcend the current directory structure. For these cases we will
            // have to revert back to what we had before.

            pRenameInformation = (PFILE_RENAME_INFORMATION)pBuffer;

            if (pRenameInformation->RootDirectory == NULL) {
                // Scan the name given for rename to determine if it is in
                // some other directory.
                ULONG  NameLengthInBytes = pRenameInformation->FileNameLength;
                PWCHAR pRenameTarget     = pRenameInformation->FileName;

                while ((NameLengthInBytes > 0) &&
                       (*pRenameTarget != OBJ_NAME_PATH_SEPARATOR)) {
                    NameLengthInBytes -= sizeof(WCHAR);
                }

                if (NameLengthInBytes > 0) {
                    UseCore = TRUE;
                }
            } else {
                UseCore = TRUE;
            }

#ifdef _WIN64
            // Don't thunk the data if we're going to take the downlevel path (since the data will be mapped into an SMB_RENAME
            if( !(UseCore ||
                  MRxSmbForceCoreInfo ||
                  !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS) ||
                  FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) )
            {
                PBYTE pNewBuffer = Smb64ThunkFileRenameInfo( pRenameInformation, &BufferLength, &Status );
                if( !NT_SUCCESS(Status) )
                {
                    goto FINALLY;
                }
                else
                {
                    pBuffer = pNewBuffer;
                }
            }
#endif
        }

        if (FileInformationClass == FileLinkInformation) {
            UseCore = TRUE;
        }
    } else {
        switch( FileInformationClass ) {
        case FileBasicInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_BASIC_INFO;
            break;
        case FileDispositionInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_DISPOSITION_INFO;
            break;
        case FileAllocationInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_ALLOCATION_INFO;
            break;
        case FileEndOfFileInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_END_OF_FILE_INFO;
            break;
        case FileLinkInformation:
        case FileRenameInformation:
            UseCore = TRUE;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }
    }

    if (UseCore ||
        MRxSmbForceCoreInfo ||
        !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS) ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {

        if (FileInformationClass == FileLinkInformation ||
            FileInformationClass == FileRenameInformation) {
            Status = MRxSmbBypassDownLevelRename ?
                        STATUS_INVALID_PARAMETER :
                        MRxSmbRename( RxContext );
        } else {
            Status = MRxSmbCoreInformation(
                        RxContext,
                        FileInformationClass,
                        pBuffer,
                        &BufferLength,
                        SMBPSE_OE_FROM_SETFILEINFO
                        );
        }

        goto FINALLY;
    }

    Setup = TRANS2_SET_FILE_INFORMATION;
    SetFileInfoRequest.Fid = smbSrvOpen->Fid;
    SetFileInfoRequest.InformationLevel = SmbFileInfoLevel;
    SetFileInfoRequest.Flags = 0;
    pSendParameterBuffer = &SetFileInfoRequest;
    SendParameterBufferLength = sizeof(SetFileInfoRequest);
    RxDbgTrace(0, Dbg, (" fid,smbclass=%08lx,%08lx\n",smbSrvOpen->Fid,SmbFileInfoLevel));
    
    Status = SmbCeTransact(
                 RxContext,
                 pTransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 pSendParameterBuffer,
                 SendParameterBufferLength,
                 &SetFileInfoResponse,
                 sizeof(SetFileInfoResponse),
                 pBuffer,
                 BufferLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (Status == STATUS_SUCCESS &&
        (FileInformationClass == FileRenameInformation ||
         FileInformationClass == FileDispositionInformation)) {
        // create the name based file not found cache
        MRxSmbCacheFileNotFound(RxContext);

        // invalidate the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);
        MRxSmbInvalidateInternalFileInfoCache(RxContext);

        if (FileInformationClass == FileDispositionInformation) {
            PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
            SetFlag((((PMRX_SMB_FCB)smbFcb)->MFlags),SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
        }
    }

FINALLY:

    if (NT_SUCCESS(Status)) {
        switch(FileInformationClass) {
        case FileBasicInformation:
            if (pServerEntry->Server.Dialect == NTLANMAN_DIALECT &&
                pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_NTFS) {
                MRxSmbUpdateBasicFileInfoCacheAll(RxContext,
                                                  (PFILE_BASIC_INFORMATION)pBuffer);
            } else {
                // some file system, i.e. FAT, has the time stamp with granularity of 2 seconds.
                // RDR cannot predict what the time stamp on the server, therefore invalid the cache
                MRxSmbInvalidateBasicFileInfoCache(RxContext);
            }
            break;

        case FileEndOfFileInformation:
            MRxSmbUpdateFileInfoCacheFileSize(RxContext,
                                              &((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile);
            break;

        case FileStandardInformation:
            MRxSmbUpdateStandardFileInfoCache(RxContext,
                                              (PFILE_STANDARD_INFORMATION)pBuffer,
                                              FALSE);
            break;

        case FileEaInformation:
            smbSrvOpen->FileStatusFlags &=  ~SMB_FSF_NO_EAS;
            break;

        case FileAttributeTagInformation:
            smbSrvOpen->FileStatusFlags &= ~SMB_FSF_NO_REPARSETAG;
            break;

#ifdef _WIN64
        case FileRenameInformation:
            // Clean up the Thunk data if necessary
            if( pBuffer != RxContext->Info.Buffer )
            {
                Smb64ReleaseThunkData( pBuffer );
                pBuffer = RxContext->Info.Buffer;
            }
            break;
#endif
        } 
    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);
        }

        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);


        RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Failed .. returning %lx\n",Status));
    }

    // update shadow as appropriate. This needs to be done only for NT servers
    // since pinning/CSC is not supported against non NT servers.

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow == 0);
    } else {
        if (!fDoneCSCPart) {
            if (FileInformationClass == FileRenameInformation) {
                MRxSmbCscRenameEpilogue(RxContext,&Status);
            } else {
                MRxSmbCscSetFileInfoEpilogue(RxContext, &Status);
            }
        }
    }

   RxDbgTraceUnIndent(-1,Dbg);
   return Status;
}

NTSTATUS
MRxSmbQueryNamedPipeInformation(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN OUT PVOID              pBuffer,
      IN OUT PULONG             pLengthRemaining)
{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN pSmbSrvOpen;

   NTSTATUS Status;

   USHORT Setup[2];
   USHORT Level;

   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   ULONG                      SmbPipeInformationLength;
   PNAMED_PIPE_INFORMATION_1  pSmbPipeInformation;

   SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
   SMB_TRANSACTION_OPTIONS             TransactionOptions;

   PAGED_CODE();

   ASSERT(*pLengthRemaining >= sizeof(FILE_PIPE_LOCAL_INFORMATION));
   ASSERT(capFobx != NULL);
   pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   // The SMB data structures defines a response that is significantly different from the
   // FILE_PIPE_LOCAL_INFORMATION data structures. This mismatch is resolved by obtaining
   // the SMB results in a different buffer and then copying the relevant pieces of
   // information onto the query information buffer. SInce the SMB definition involves the
   // pipe name as well a buffer that is large enough to hold the path name needs to be
   // defined.
   SmbPipeInformationLength = sizeof(NAMED_PIPE_INFORMATION_1) +
                               MAXIMUM_FILENAME_LENGTH;
   pSmbPipeInformation =  RxAllocatePoolWithTag(
                                 PagedPool,
                                 SmbPipeInformationLength,
                                 MRXSMB_PIPEINFO_POOLTAG);

   if (pSmbPipeInformation == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   Setup[0] = TRANS_QUERY_NMPIPE_INFO;
   Setup[1] = pSmbSrvOpen->Fid;
   Level    = 1;                       // Information Level Desired
   
   TransactionOptions = RxDefaultTransactionOptions;
   TransactionOptions.pTransactionName   = &s_NamedPipeTransactionName;

   Status = SmbCeTransact(
                  RxContext,                    // the RXContext for the transaction
                  &TransactionOptions,          // transaction options
                  Setup,                        // the setup buffer
                  sizeof(Setup),                // setup buffer length
                  NULL,
                  0,
                  &Level,                       // Input Param Buffer
                  sizeof(Level),                // Input param buffer length
                  pOutputParamBuffer,           // Output param buffer
                  OutputParamBufferLength,      // output param buffer length
                  pInputDataBuffer,             // Input data buffer
                  InputDataBufferLength,        // Input data buffer length
                  pSmbPipeInformation,          // output data buffer
                  SmbPipeInformationLength,     // output data buffer length
                  &ResumptionContext            // the resumption context
                  );

   if (NT_SUCCESS(Status)) {
      PFILE_PIPE_LOCAL_INFORMATION pFilePipeInformation = (PFILE_PIPE_LOCAL_INFORMATION)pBuffer;

      // MaximumInstances and CurrentInstances are UCHAR fields ...
      pFilePipeInformation->MaximumInstances    = (ULONG)pSmbPipeInformation->MaximumInstances;
      pFilePipeInformation->CurrentInstances    = (ULONG)pSmbPipeInformation->CurrentInstances;
      pFilePipeInformation->InboundQuota        = SmbGetUshort(&pSmbPipeInformation->InputBufferSize);
      pFilePipeInformation->ReadDataAvailable   = 0xffffffff;
      pFilePipeInformation->OutboundQuota       = SmbGetUshort(&pSmbPipeInformation->OutputBufferSize);
      pFilePipeInformation->WriteQuotaAvailable = 0xffffffff;
      pFilePipeInformation->NamedPipeState      = FILE_PIPE_CONNECTED_STATE;// Since no error
      pFilePipeInformation->NamedPipeEnd        = FILE_PIPE_CLIENT_END;

      RxDbgTrace( 0, Dbg, ("MRxSmbQueryNamedPipeInformation: Pipe Name .. %s\n",pSmbPipeInformation->PipeName));

      *pLengthRemaining -= sizeof(FILE_PIPE_LOCAL_INFORMATION);
   }

   RxFreePool(pSmbPipeInformation);

   RxDbgTrace( 0, Dbg, ("MRxSmbQueryNamedPipeInformation: ...returning %lx\n",Status));
   return Status;
}


NTSTATUS
MRxSmbSetNamedPipeInformation(
    IN PRX_CONTEXT            RxContext,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN PVOID                  pBuffer,
    IN ULONG                 BufferLength)
{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN pSmbSrvOpen;

   NTSTATUS Status;

   USHORT Setup[2];
   USHORT NewState;

   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PFILE_PIPE_INFORMATION pPipeInformation;

   SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
   SMB_TRANSACTION_OPTIONS             TransactionOptions;

   PAGED_CODE();

   pSmbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   if (BufferLength < sizeof(FILE_PIPE_INFORMATION)) {
      return STATUS_BUFFER_TOO_SMALL;
   }

   if (FileInformationClass != FilePipeInformation) {
      return STATUS_INVALID_PARAMETER;
   }

   pPipeInformation = (PFILE_PIPE_INFORMATION)pBuffer;
   NewState         = 0;

   if (pPipeInformation->ReadMode == FILE_PIPE_MESSAGE_MODE) {
      NewState |= SMB_PIPE_READMODE_MESSAGE;
   }

   if (pPipeInformation->CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {
      NewState |= SMB_PIPE_NOWAIT;
   }

   Setup[0] = TRANS_SET_NMPIPE_STATE;
   Setup[1] = pSmbSrvOpen->Fid;

   TransactionOptions = RxDefaultTransactionOptions;
   TransactionOptions.pTransactionName   = &s_NamedPipeTransactionName;

   Status = SmbCeTransact(
                  RxContext,                    // the RXContext for the transaction
                  &TransactionOptions,          // transaction options
                  Setup,                        // the setup buffer
                  sizeof(Setup),                // setup buffer length
                  NULL,
                  0,
                  &NewState,                    // Input Param Buffer
                  sizeof(NewState),             // Input param buffer length
                  pOutputParamBuffer,           // Output param buffer
                  OutputParamBufferLength,      // output param buffer length
                  pInputDataBuffer,             // Input data buffer
                  InputDataBufferLength,        // Input data buffer length
                  pOutputDataBuffer,            // output data buffer
                  OutputDataBufferLength,       // output data buffer length
                  &ResumptionContext            // the resumption context
                  );

   RxDbgTrace( 0, Dbg, ("MRxSmbQueryNamedPipeInformation: ...returning %lx\n",Status));
   return Status;
}

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. the old rdr just swallows this operation (i.e.
   it doesn't generate it). we are doing the same..........

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

   This routine checks a remote directory.

Arguments:

    RxContext - the RDBSS context
    DirectoryName - the directory needs to be checked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    BOOLEAN FinalizationComplete;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    KEVENT                   SyncEvent;
    
    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbIsValidDirectory\n", 0 ));

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetAssociatedServerEntry(RxContext->Create.pSrvCall);

        if (SmbCeIsServerInDisconnectedMode(pServerEntry)){
            NTSTATUS CscStatus;

            CscStatus = MRxSmbDCscIsValidDirectory(RxContext,DirectoryName);

            if (CscStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(0, Dbg,
                   ("MRxSmbQueryVolumeInfo returningDCON with status=%08lx\n",
                    CscStatus ));

                Status = CscStatus;
                goto FINALLY;
            } else {
                NOTHING;
            }
        }
    }

    Status = SmbCeReconnect(RxContext->Create.pVNetRoot);

    if (Status != STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status= SmbPseCreateOrdinaryExchange(
                RxContext,
                RxContext->Create.pVNetRoot,
                SMBPSE_OE_FROM_CREATE,
                MRxSmbCoreCheckPath,
                &OrdinaryExchange
                );

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    OrdinaryExchange->pPathArgument1 = DirectoryName;
    OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
    OrdinaryExchange->AssociatedStufferState.CurrentCommand = SMB_COM_NO_ANDX_COMMAND;
    OrdinaryExchange->pSmbCeSynchronizationEvent = &SyncEvent;

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT(Status != STATUS_PENDING);

    if (Status != STATUS_SUCCESS) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    ASSERT(FinalizationComplete);


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbIsValidDirectory  exit with status=%08lx\n", Status ));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the SMB mini rdr.

Author:

    Balan Sethu Raman [SethuR]    7-Mar-1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "ntbowsif.h"
#include <bowpub.h>
#include "netevent.h"
#include "nvisible.h"
#include <ntddbrow.h>

BOOL IsTerminalServicesServer();


#define RDBSS_DRIVER_LOAD_STRING L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, MRxSmbInitUnwind)
#pragma alloc_text(PAGE, MRxSmbInitUnwindSmb)
#pragma alloc_text(PAGE, MRxSmbInitUnwindBowser)
#pragma alloc_text(PAGE, MRxSmbUnload)
#pragma alloc_text(PAGE, MRxSmbInitializeTables)
#pragma alloc_text(PAGE, MRxSmbStart)
#pragma alloc_text(PAGE, MRxSmbStop)
#pragma alloc_text(PAGE, MRxSmbInitializeSecurity)
#pragma alloc_text(PAGE, MRxSmbUninitializeSecurity)
#pragma alloc_text(PAGE, MRxSmbReadMiscellaneousRegistryParameters)
#pragma alloc_text(PAGE, SmbCeGetConfigurationInformation)
#pragma alloc_text(PAGE, MRxSmbFsdDispatch)
#pragma alloc_text(PAGE, MRxSmbDeallocateForFcb)
#pragma alloc_text(PAGE, MRxSmbDeallocateForFobx)
#pragma alloc_text(PAGE, MRxSmbGetUlongRegistryParameter)
#pragma alloc_text(PAGE, MRxSmbPreUnload)
#pragma alloc_text(PAGE, IsTerminalServicesServer)
#endif

extern ERESOURCE       s_SmbCeDbResource;
extern ERESOURCE       s_SmbSecuritySignatureResource;

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

//
// Global data declarations .
//

PVOID MRxSmbPoRegistrationState = NULL;

FAST_MUTEX   MRxSmbSerializationMutex;
FAST_MUTEX   MRxSmbReadWriteMutex;

MRXSMB_CONFIGURATION MRxSmbConfiguration;

MRXSMB_STATE MRxSmbState = MRXSMB_STARTABLE;

SMBCE_CONTEXT SmbCeContext;
PMDL          s_pEchoSmbMdl = NULL;
ULONG         s_EchoSmbLength = 0;

BOOLEAN EnablePlainTextPassword = FALSE;
BOOLEAN SetupInProgress = FALSE;
BOOLEAN EnableWmiLog = FALSE;
BOOLEAN Win9xSessionRestriction = FALSE;
ULONG   OffLineFileTimeoutInterval = 1000;  // in seconds
ULONG   ExtendedSessTimeoutInterval = 1000;  // in seconds
ULONG   MaxNumOfExchangesForPipelineReadWrite = 8;

#ifdef EXPLODE_POOLTAGS
ULONG         MRxSmbExplodePoolTags = 1;
#else
ULONG         MRxSmbExplodePoolTags = 0;
#endif

//
// This counts any SMBs sent out which could make the contents of the Get
// File Attributes cache stale.
//
ULONG NameCacheGFAInvalidate;

// local functions forward declarations

NTSTATUS
MRxSmbDeleteRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName
    );
//
// Mini Redirector global variables.
//

struct _MINIRDR_DISPATCH  MRxSmbDispatch;

PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

MRXSMB_GLOBAL_PADDING MrxSmbCeGlobalPadding;

LIST_ENTRY ExchangesWaitingForServerResponseBuffer;
LONG NumOfBuffersForServerResponseInUse;

BOOLEAN MRxSmbEnableCompression   = FALSE;
BOOLEAN MRxSmbSecuritySignaturesRequired = FALSE;
BOOLEAN MRxSmbSecuritySignaturesEnabled = TRUE;
BOOLEAN MRxSmbEnableCachingOnWriteOnlyOpens = FALSE;
BOOLEAN MRxSmbEnableDownLevelLogOff = FALSE;

ULONG   MRxSmbConnectionIdLevel = 0;

BOOLEAN UniqueFileNames = FALSE;
BOOLEAN DisableByteRangeLockingOnReadOnlyFiles = FALSE;

FAST_MUTEX MRxSmbFileInfoCacheLock;

//
// The following variable controls whether clientside cacheing is enabled or not.
// It is the responsibility of the Csc routines themselves to do the right things
// is CSC is not enabled because we will make the calls anyway.
//

BOOLEAN MRxSmbIsCscEnabled = TRUE;
BOOLEAN MRxSmbIsCscEnabledForDisconnected = TRUE;
BOOLEAN MRxSmbCscTransitionEnabledByDefault = FALSE;
BOOLEAN MRxSmbEnableDisconnectedRB  = FALSE;    // don't transition remoteboot machine to disconnected state
BOOLEAN MRxSmbCscAutoDialEnabled = FALSE;
//
// If this flag is TRUE, we strictly obey the transport binding order.  If it is FALSE,
//  we can use whatever transport we want to connect to the remote server.
//
BOOLEAN MRxSmbObeyBindingOrder = FALSE;

ULONG MRxSmbBuildNumber = VER_PRODUCTBUILD;
#ifdef RX_PRIVATE_BUILD
ULONG MRxSmbPrivateBuild = 1;
#else
ULONG MRxSmbPrivateBuild = 0;
#endif

//
// MRxSmbSecurityInitialized indicates whether MRxSmbInitializeSecurity
// has been called.
//

BOOLEAN MRxSmbSecurityInitialized = FALSE;

//
// MRxSmbBootedRemotely indicates that the machine did a remote boot.
//

BOOLEAN MRxSmbBootedRemotely = FALSE;

//
// MRxSmbUseKernelSecurity indicates that the machine should use kernel mode security APIs
// during this remote boot boot.
//

BOOLEAN MRxSmbUseKernelModeSecurity = FALSE;


LIST_ENTRY MRxSmbPagingFilesSrvOpenList;

//
// These variables will, in the near future, be passed from the kernel to the
// redirector to tell it which share is the remote boot share and how to log on
// to the server.
//

PKEY_VALUE_PARTIAL_INFORMATION MRxSmbRemoteBootRootValue = NULL;
PKEY_VALUE_PARTIAL_INFORMATION MRxSmbRemoteBootMachineDirectoryValue = NULL;
UNICODE_STRING MRxSmbRemoteBootShare;
UNICODE_STRING MRxSmbRemoteBootPath;
UNICODE_STRING MRxSmbRemoteSetupPath;
UNICODE_STRING MRxSmbRemoteBootMachineName;
UNICODE_STRING MRxSmbRemoteBootMachinePassword;
UNICODE_STRING MRxSmbRemoteBootMachineDomain;
UCHAR MRxSmbRemoteBootMachineSid[RI_SECRET_SID_SIZE];
RI_SECRET MRxSmbRemoteBootSecret;
#if defined(REMOTE_BOOT)
BOOLEAN MRxSmbRemoteBootSecretValid = FALSE;
BOOLEAN MRxSmbRemoteBootDoMachineLogon;
BOOLEAN MRxSmbRemoteBootUsePassword2;
#endif // defined(REMOTE_BOOT)

//
// for LoopBack detection
//
GUID CachedServerGuid;

UNICODE_STRING MRxSmbRemoteBootRedirectionPrefix;
UNICODE_PREFIX_TABLE MRxSmbRemoteBootRedirectionTable;

//declare the shadow debugtrace controlpoints

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);
RXDT_DefineCategory(DISCCODE);   //this shouldn't be a shadow
RXDT_DefineCategory(BROWSER);    //this shouldn't be a shadow
RXDT_DefineCategory(CONNECT);    //this shouldn't be a shadow

typedef enum _MRXSMB_INIT_STATES {
    MRXSMBINIT_ALL_INITIALIZATION_COMPLETED,
    MRXSMBINIT_STARTED_BROWSER,
    MRXSMBINIT_INITIALIZED_FOR_CSC,
    MRXSMBINIT_MINIRDR_REGISTERED,
    MRXSMBINIT_START
} MRXSMB_INIT_STATES;



NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MRxSmbCheckTransportName(
    IN  PIRP                  Irp,
    OUT PSMBCEDB_SERVER_ENTRY *ppServerEntry
    );

NTSTATUS
SmbCeGetServersWithExtendedSessTimeout();

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the SMB mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS       Status;
    MRXSMB_INIT_STATES MRxSmbInitState = 0;
    UNICODE_STRING SmbMiniRedirectorName;

    PAGED_CODE();

#ifdef MONOLITHIC_MINIRDR
    DbgPrint("InitWrapper\n");
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    DbgPrint("BackFromInitWrapper %p\n",Status);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }
#endif

    NameCacheGFAInvalidate = 0;

    RtlZeroMemory(&MRxSmbStatistics,sizeof(MRxSmbStatistics));
    KeQuerySystemTime(&MRxSmbStatistics.StatisticsStartTime);
    RtlZeroMemory(&MrxSmbCeGlobalPadding,sizeof(MrxSmbCeGlobalPadding));
    MmInitializeMdl(&MrxSmbCeGlobalPadding.Mdl,&MrxSmbCeGlobalPadding.Pad[0],SMBCE_PADDING_DATA_SIZE);
    MmBuildMdlForNonPagedPool(&MrxSmbCeGlobalPadding.Mdl);

    ExInitializeFastMutex(&MRxSmbSerializationMutex);
    ExInitializeFastMutex(&MRxSmbReadWriteMutex);

    Status = MRxSmbInitializeTransport();
    if (Status != STATUS_SUCCESS) {
       RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry failed to init transport data structures: %08lx\n", Status ));
       return(STATUS_UNSUCCESSFUL);
    }

    MRxSmbReadMiscellaneousRegistryParameters();

    try {

        //
        // Initialize the discardable code functions before doing anything else.
        //

        RdrInitializeDiscardableCode();


        MRxSmbInitState = MRXSMBINIT_START;

        RtlInitUnicodeString(&SmbMiniRedirectorName,DD_NFS_DEVICE_NAME_U);
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry: DriverObject =%p\n", DriverObject ));

        Status = RxRegisterMinirdr(&MRxSmbDeviceObject,
                                    DriverObject,
                                    &MRxSmbDispatch,
                                    0,     //register with unc and for mailslots
                                    &SmbMiniRedirectorName,
                                    0, //IN  ULONG DeviceExtensionSize,
                                    FILE_DEVICE_NETWORK_FILE_SYSTEM, //IN  DEVICE_TYPE DeviceType,
                                    FILE_REMOTE_DEVICE //IN  ULONG DeviceCharacteristics
                                    );
        if (Status!=STATUS_SUCCESS) {
            RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry failed: %08lx\n", Status ));
            try_return(Status);
        }

        MRxSmbInitState = MRXSMBINIT_MINIRDR_REGISTERED;

        Status = MRxSmbInitializeCSC(&SmbMiniRedirectorName);
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        MRxSmbInitState = MRXSMBINIT_INITIALIZED_FOR_CSC;

        // init the browser.....BUT DONT TRUST IT!!!!

        try {

            //  Setup the browser
            Status = BowserDriverEntry(DriverObject, RegistryPath);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //  We had some trouble trying to start up the browser.....sigh.

            Status = GetExceptionCode();
            DbgPrint("Browser didn't start....%08lx\n", Status);

        }

        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }

        MRxSmbInitState = MRXSMBINIT_STARTED_BROWSER;

        //for all this stuff, there's no undo.....so no extra state

        Status = MRxSmbInitializeTables();
        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        RtlInitUnicodeString(&SmbCeContext.ComputerName,NULL);
        RtlInitUnicodeString(&SmbCeContext.DomainName,NULL);
        RtlInitUnicodeString(&SmbCeContext.OperatingSystem, NULL);
        RtlInitUnicodeString(&SmbCeContext.LanmanType, NULL);
        RtlInitUnicodeString(&SmbCeContext.Transports, NULL);
        RtlInitUnicodeString(&SmbCeContext.ServersWithExtendedSessTimeout, NULL);
        RtlInitUnicodeString(&MRxSmbRemoteBootMachineName, NULL);
        RtlInitUnicodeString(&MRxSmbRemoteBootMachineDomain, NULL);
        RtlInitUnicodeString(&MRxSmbRemoteBootMachinePassword, NULL);

        SmbCeGetConfigurationInformation();
        SmbCeGetServersWithExtendedSessTimeout();

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            MRxSmbInitUnwind(DriverObject,MRxSmbInitState);
        }
    }
    if (Status != STATUS_SUCCESS) {
        DbgPrint("MRxSmb failed to start with %08lx %08lx\n",Status,MRxSmbInitState);
        return(Status);
    }


    // Do not setup Unload Routine. This prevents mrxsmb from being unloaded individually

    //setup the driverdispatch for people who come in here directly....like the browser
    //CODE.IMPROVEMENT we should change this code so that the things that aren't examined
    //    in MRxSmbFsdDispatch are routed directly, i.e. reads and writes
    {ULONG i;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxSmbFsdDispatch;
    }}

    Status = IoWMIRegistrationControl ((PDEVICE_OBJECT)MRxSmbDeviceObject, WMIREG_ACTION_REGISTER);

    if (Status != STATUS_SUCCESS) {
        DbgPrint("MRxSmb fails to register WMI %lx\n",Status);
    } else {
        EnableWmiLog = TRUE;
    }

    //and get out
    return  STATUS_SUCCESS;

}



VOID
MRxSmbPreUnload(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:

--*/
{
    PDRIVER_OBJECT DriverObject = ((PDEVICE_OBJECT)MRxSmbDeviceObject)->DriverObject;

    PAGED_CODE();

    if (EnableWmiLog) {
        NTSTATUS Status;

        Status = IoWMIRegistrationControl ((PDEVICE_OBJECT)MRxSmbDeviceObject, WMIREG_ACTION_DEREGISTER);
        if (Status != STATUS_SUCCESS) {
            DbgPrint("MRxSmb fails to deregister WMI %lx\n",Status);
        }
    }

    //ASSERT(!"Starting to unload!");
    //RxUnregisterMinirdr(MRxSmbDeviceObject);
    MRxSmbInitUnwindSmb(DriverObject, MRXSMBINIT_ALL_INITIALIZATION_COMPLETED);

    // free the pool associated with the resource
    ExDeleteResource(&s_SmbCeDbResource);
    ExDeleteResource(&s_SmbSecuritySignatureResource);

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbPreUnload exit: DriverObject =%p\n", DriverObject) );
}


VOID
MRxSmbInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXSMB_INIT_STATES MRxSmbInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/
{
    PAGED_CODE();

    MRxSmbInitUnwindSmb(DriverObject, MRxSmbInitState);
    MRxSmbInitUnwindBowser(DriverObject, MRxSmbInitState);
}

VOID
MRxSmbInitUnwindSmb(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXSMB_INIT_STATES MRxSmbInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for SMB for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxSmbInitState) {
    case MRXSMBINIT_ALL_INITIALIZATION_COMPLETED:
        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional


#ifdef MRXSMB_BUILD_FOR_CSC
    case MRXSMBINIT_INITIALIZED_FOR_CSC:
        MRxSmbUninitializeCSC();
        //lack of break intentional
#endif


    case MRXSMBINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(MRxSmbDeviceObject);
        //lack of break intentional

    }

}

VOID
MRxSmbInitUnwindBowser(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXSMB_INIT_STATES MRxSmbInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for bowser for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{

    switch (MRxSmbInitState) {
    case MRXSMBINIT_ALL_INITIALIZATION_COMPLETED:
    case MRXSMBINIT_STARTED_BROWSER:
        BowserUnload(DriverObject);
    case MRXSMBINIT_START:
        RdrUninitializeDiscardableCode();
        break;
    }
}

VOID
MRxSmbUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the SMB mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the MRxSmb

Return Value:

     None

--*/

{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbUnload: DriverObject =%p\n", DriverObject) );
    MRxSmbInitUnwindBowser(DriverObject,MRXSMBINIT_ALL_INITIALIZATION_COMPLETED);
}



NTSTATUS
MRxSmbInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // Ensure that the SMB mini redirector context satisfies the size constraints
    ASSERT(sizeof(MRXSMB_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //local minirdr dispatch table init
    ZeroAndInitializeNodeType( &MRxSmbDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    // SMB mini redirector extension sizes and allocation policies.
    // CODE.IMPROVEMENT -- currently we do not allocate the NET_ROOT and SRV_CALL extensions
    // in the wrapper. Except for V_NET_ROOT wherein it is shared across multiple instances in
    // the wrapper all the other data structure management should be left to the wrappers

    MRxSmbDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION |
                               RDBSS_MANAGE_FOBX_EXTENSION);

    MRxSmbDispatch.MRxSrvCallSize  = 0;
    MRxSmbDispatch.MRxNetRootSize  = 0;
    MRxSmbDispatch.MRxVNetRootSize = 0;
    MRxSmbDispatch.MRxFcbSize      = sizeof(MRX_SMB_FCB);
    MRxSmbDispatch.MRxSrvOpenSize  = sizeof(MRX_SMB_SRV_OPEN);
    MRxSmbDispatch.MRxFobxSize     = sizeof(MRX_SMB_FOBX);

    // Mini redirector cancel routine ..
    MRxSmbDispatch.MRxCancel = NULL;

    // Mini redirector Start/Stop
    MRxSmbDispatch.MRxStart          = MRxSmbStart;
    MRxSmbDispatch.MRxStop           = MRxSmbStop;
    MRxSmbDispatch.MRxDevFcbXXXControlFile = MRxSmbDevFcbXXXControlFile;

    // Mini redirector name resolution
    MRxSmbDispatch.MRxCreateSrvCall = MRxSmbCreateSrvCall;
    MRxSmbDispatch.MRxSrvCallWinnerNotify = MRxSmbSrvCallWinnerNotify;
    MRxSmbDispatch.MRxCreateVNetRoot = MRxSmbCreateVNetRoot;
    MRxSmbDispatch.MRxUpdateNetRootState = MRxSmbUpdateNetRootState;
    MRxSmbDispatch.MRxExtractNetRootName = MRxSmbExtractNetRootName;
    MRxSmbDispatch.MRxFinalizeSrvCall = MRxSmbFinalizeSrvCall;
    MRxSmbDispatch.MRxFinalizeNetRoot = MRxSmbFinalizeNetRoot;
    MRxSmbDispatch.MRxFinalizeVNetRoot = MRxSmbFinalizeVNetRoot;

    // File System Object Creation/Deletion.
    MRxSmbDispatch.MRxCreate            = MRxSmbCreate;
    MRxSmbDispatch.MRxCollapseOpen      = MRxSmbCollapseOpen;
    MRxSmbDispatch.MRxShouldTryToCollapseThisOpen      = MRxSmbShouldTryToCollapseThisOpen;
    MRxSmbDispatch.MRxExtendForCache    = MRxSmbExtendForCache;
    MRxSmbDispatch.MRxExtendForNonCache = MRxSmbExtendForNonCache;
    MRxSmbDispatch.MRxTruncate          = MRxSmbTruncate;
    MRxSmbDispatch.MRxCleanupFobx       = MRxSmbCleanupFobx;
    MRxSmbDispatch.MRxCloseSrvOpen      = MRxSmbCloseSrvOpen;
    MRxSmbDispatch.MRxFlush             = MRxSmbFlush;
    MRxSmbDispatch.MRxForceClosed       = MRxSmbForcedClose;
    MRxSmbDispatch.MRxDeallocateForFcb  = MRxSmbDeallocateForFcb;
    MRxSmbDispatch.MRxDeallocateForFobx = MRxSmbDeallocateForFobx;
    MRxSmbDispatch.MRxIsLockRealizable  = MRxSmbIsLockRealizable;
    MRxSmbDispatch.MRxAreFilesAliased   = MRxSmbAreFilesAliased;

    // File System Objects query/Set
    MRxSmbDispatch.MRxQueryDirectory  = MRxSmbQueryDirectory;
    MRxSmbDispatch.MRxQueryVolumeInfo = MRxSmbQueryVolumeInformation;
    MRxSmbDispatch.MRxSetVolumeInfo   = MRxSmbSetVolumeInformation;
    MRxSmbDispatch.MRxQueryEaInfo     = MRxSmbQueryEaInformation;
    MRxSmbDispatch.MRxSetEaInfo       = MRxSmbSetEaInformation;
    MRxSmbDispatch.MRxQuerySdInfo     = MRxSmbQuerySecurityInformation;
    MRxSmbDispatch.MRxSetSdInfo       = MRxSmbSetSecurityInformation;
    MRxSmbDispatch.MRxQueryQuotaInfo  = MRxSmbQueryQuotaInformation;
    MRxSmbDispatch.MRxSetQuotaInfo    = MRxSmbSetQuotaInformation;
    MRxSmbDispatch.MRxQueryFileInfo   = MRxSmbQueryFileInformation;
    MRxSmbDispatch.MRxSetFileInfo     = MRxSmbSetFileInformation;
    MRxSmbDispatch.MRxSetFileInfoAtCleanup
                                      = MRxSmbSetFileInformationAtCleanup;
    MRxSmbDispatch.MRxIsValidDirectory= MRxSmbIsValidDirectory;


    // Buffering state change
    MRxSmbDispatch.MRxComputeNewBufferingState = MRxSmbComputeNewBufferingState;

    // New MRX functions
    MRxSmbDispatch.MRxPreparseName    = MRxSmbPreparseName;

    // File System Object I/O
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = MRxSmbRead;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = MRxSmbWrite;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = MRxSmbFsCtl;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = MRxSmbIoCtl;
    //CODE.IMPROVEMENT  shouldn't flush come thru lowio???
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = MRxSmbNotifyChangeDirectory;

    //no longer a field MRxSmbDispatch.MRxUnlockRoutine   = MRxSmbUnlockRoutine;


    // Miscellanous
    MRxSmbDispatch.MRxCompleteBufferingStateChangeRequest = MRxSmbCompleteBufferingStateChangeRequest;
    MRxSmbDispatch.MRxGetConnectionId                     = MRxSmbGetConnectionId;

    // initialize the paging file list
    InitializeListHead(&MRxSmbPagingFilesSrvOpenList);

    // The list contains the exchanges waiting on pre-allcate buffer in case of Security
    // Signature checking is actived and no more buffer can be allocated
    InitializeListHead(&ExchangesWaitingForServerResponseBuffer);
    NumOfBuffersForServerResponseInUse = 0;

    // initialize the mutex which protect the file info cache expire timer
    ExInitializeFastMutex(&MRxSmbFileInfoCacheLock);

    //
    // now callout to initialize other tables
    SmbPseInitializeTables();

    return(STATUS_SUCCESS);
}

BOOLEAN AlreadyStarted = FALSE;

NTSTATUS
MRxSmbStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS      Status;
    MRXSMB_STATE  CurrentState;

    PAGED_CODE();

    //
    // If this is a normal start (from the workstation service), change state from
    // START_IN_PROGRESS to STARTED. If this is a remote boot start (from ioinit),
    // don't change state. This is necessary to allow the workstation service to
    // initialize correctly when it finally comes up.
    //

    if (RxContext->LowIoContext.ParamsFor.FsCtl.FsControlCode == FSCTL_LMR_START) {
        CurrentState = (MRXSMB_STATE)
                        InterlockedCompareExchange(
                            (PLONG)&MRxSmbState,
                            MRXSMB_STARTED,
                            MRXSMB_START_IN_PROGRESS);
    } else {
        CurrentState = MRXSMB_START_IN_PROGRESS;
    }

    if (CurrentState == MRXSMB_START_IN_PROGRESS) {
        MRxSmbPoRegistrationState = PoRegisterSystemState(
                                        NULL,0);

        // Initialize the SMB connection engine data structures
        Status = SmbCeDbInit();

        if (NT_SUCCESS(Status)) {

            //
            // If this is a normal start, initialize the security related data
            // structures. If this is a remote boot start, we can't initialize
            // security yet because user mode hasn't started yet.
            //

            if (RxContext->LowIoContext.ParamsFor.FsCtl.FsControlCode == FSCTL_LMR_START) {
                Status = MRxSmbInitializeSecurity();
            }

            if (NT_SUCCESS(Status)) {
               Status = SmbMrxInitializeStufferFacilities();
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            if (NT_SUCCESS(Status)) {
               Status = MRxSmbInitializeRecurrentServices();
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            if (Status == STATUS_SUCCESS) {
                if (Status != STATUS_SUCCESS) {
                    RxLogFailure (
                        MRxSmbDeviceObject,
                        NULL,
                        EVENT_RDR_UNEXPECTED_ERROR,
                        Status);
                }
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            Status = SeRegisterLogonSessionTerminatedRoutine(
                        (PSE_LOGON_SESSION_TERMINATED_ROUTINE)
                        MRxSmbLogonSessionTerminationHandler);
        }
    } else if (MRxSmbState == MRXSMB_STARTED) {
        Status = STATUS_REDIRECTOR_STARTED;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}


NTSTATUS
MRxSmbStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the SMB mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    PoUnregisterSystemState(
        MRxSmbPoRegistrationState);

    Status = MRxSmbUninitializeSecurity();
    if (NT_SUCCESS(Status)) {
       Status = SmbMrxFinalizeStufferFacilities();
    }

    ASSERT(NT_SUCCESS(Status));

    SeUnregisterLogonSessionTerminatedRoutine(
        (PSE_LOGON_SESSION_TERMINATED_ROUTINE)
        MRxSmbLogonSessionTerminationHandler);

    // tear down the recurrent services
    MRxSmbTearDownRecurrentServices();

    // Tear down the connection engine database
    SmbCeDbTearDown();

    // Tear down the registration for notifications
    MRxSmbDeregisterForPnpNotifications();

    // Wait for all the work items to be processed
    RxSpinDownMRxDispatcher(MRxSmbDeviceObject);

    // Deallocate the configuration strings ....
    if (SmbCeContext.ComputerName.Buffer != NULL) {
       RxFreePool(SmbCeContext.ComputerName.Buffer);
       SmbCeContext.ComputerName.Buffer = NULL;
    }

    if (SmbCeContext.OperatingSystem.Buffer != NULL) {
       RxFreePool(SmbCeContext.OperatingSystem.Buffer);
       SmbCeContext.OperatingSystem.Buffer = NULL;
    }

    if (SmbCeContext.LanmanType.Buffer != NULL) {
       RxFreePool(SmbCeContext.LanmanType.Buffer);
       SmbCeContext.LanmanType.Buffer = NULL;
    }

    if (SmbCeContext.DomainName.Buffer != NULL) {
        RxFreePool(SmbCeContext.DomainName.Buffer);
        SmbCeContext.DomainName.Buffer = NULL;
    }

    if (SmbCeContext.Transports.Buffer != NULL) {

        // the transports buffer is at the end of a larger buffer (by 12 bytes)
        // allocated to read the value from the registry. recover the original buffer
        // pointer in orer to free.

        PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;
        TransportsValueFromRegistry = CONTAINING_RECORD(
                                         SmbCeContext.Transports.Buffer,
                                         KEY_VALUE_PARTIAL_INFORMATION,
                                         Data[0]
                                      );
        //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
        RxFreePool(TransportsValueFromRegistry);

        SmbCeContext.Transports.Buffer = NULL;
        SmbCeContext.Transports.Length = 0;
        SmbCeContext.Transports.MaximumLength = 0;
    }

    if (SmbCeContext.ServersWithExtendedSessTimeout.Buffer != NULL) {

        // the transports buffer is at the end of a larger buffer (by 12 bytes)
        // allocated to read the value from the registry. recover the original buffer
        // pointer in orer to free.

        PKEY_VALUE_PARTIAL_INFORMATION ServersValueFromRegistry;
        ServersValueFromRegistry = CONTAINING_RECORD(
                                         SmbCeContext.ServersWithExtendedSessTimeout.Buffer,
                                         KEY_VALUE_PARTIAL_INFORMATION,
                                         Data[0]
                                      );
        //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
        RxFreePool(ServersValueFromRegistry);

        SmbCeContext.ServersWithExtendedSessTimeout.Buffer = NULL;
        SmbCeContext.ServersWithExtendedSessTimeout.Length = 0;
        SmbCeContext.ServersWithExtendedSessTimeout.MaximumLength = 0;
    }

    RtlFreeUnicodeString(&MRxSmbRemoteBootMachineName);
    RtlFreeUnicodeString(&MRxSmbRemoteBootMachineDomain);
    RtlFreeUnicodeString(&MRxSmbRemoteBootMachinePassword);

//    MRxSmbUninitializeCSC();

    if (s_pNegotiateSmb != NULL) {
       RxFreePool(s_pNegotiateSmb - TRANSPORT_HEADER_SIZE);
       s_pNegotiateSmb = NULL;
    }
    if (s_pNegotiateSmbRemoteBoot != NULL) {
       RxFreePool(s_pNegotiateSmbRemoteBoot - TRANSPORT_HEADER_SIZE);
       s_pNegotiateSmbRemoteBoot = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbInitializeSecurity (VOID)
/*++

Routine Description:

    This routine initializes the SMB miniredirector security .

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   PAGED_CODE();

#ifndef WIN9X
   // DbgBreakPoint();
   if (MRxSmbSecurityInitialized)
       return STATUS_SUCCESS;

   if ( NULL == InitSecurityInterfaceW() ) {
       ASSERT(FALSE);
       Status = STATUS_INVALID_PARAMETER;
   } else {
      MRxSmbSecurityInitialized = TRUE;
      Status = STATUS_SUCCESS;
   }
#endif

   ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

   return Status;
}


NTSTATUS
MRxSmbUninitializeSecurity(VOID)
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return Status;
}

//
// Remote boot needs to use the ComputerName value, not ActiveComputerName, because
// ActiveComputerName is volatile and is set relatively late in system initialization.
//

#define SMBMRX_CONFIG_COMPUTER_NAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define SMBMRX_CONFIG_COMPUTER_NAME_NONVOLATILE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define COMPUTERNAME L"ComputerName"

#define SMBMRX_CONFIG_TRANSPORTS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Linkage"

#define TRANSPORT_BINDINGS L"Bind"

#define SMB_SERVER_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters"

BOOL
IsTerminalServicesServer()
/*++

Routine Description:

    This routine determines whether this is a TS machine, and that we should enable
    the per-user connectivity for multiplexing

Arguments:

    None

Return Value:

    TRUE for machines that are SERVER or better, and are running non-single-user TS.
    FALSE for all others.

--*/

{
    RTL_OSVERSIONINFOEXW Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    // First make sure that its a TS machine
    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = VER_SUITE_TERMINAL;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);
    if( NT_SUCCESS(RtlVerifyVersionInfo(&Osvi, TypeMask, ConditionMask)) )
    {
        // Now make sure this isn't single-user TS
        Osvi.wSuiteMask = VER_SUITE_SINGLEUSERTS;
        TypeMask = VER_SUITENAME;
        ConditionMask = 0;
        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);
        return !NT_SUCCESS(RtlVerifyVersionInfo(&Osvi, TypeMask, ConditionMask));
    }
    else
    {
        return FALSE;
    }
}

VOID
MRxSmbReadMiscellaneousRegistryParameters()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING WorkStationParametersRegistryKeyName;
    HANDLE ParametersHandle;
    ULONG Temp;
    KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
#if defined(REMOTE_BOOT)
    PKEY_VALUE_PARTIAL_INFORMATION RbrListFromRegistry;
    ULONG AllocationLength;
    PWCHAR RbrList;
    PWCHAR redirectionEntry;
    UNICODE_STRING prefix;
    PRBR_PREFIX prefixEntry;
    ULONG prefixEntryLength;

    PWCHAR DefaultRbrList =
        L"L\\pagefile.sys\0"
        L"L\\temp\0"
        L"L\\tmp\0"
        L"R\\\0"
        ;
#endif // defined(REMOTE_BOOT)

    PAGED_CODE();

    RtlInitUnicodeString(&UnicodeString, SMBMRX_MINIRDR_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        if (0) {
            MRxSmbGetUlongRegistryParameter(
                ParametersHandle,
                L"NoPreciousServerSetup",
                (PULONG)&Temp,
                FALSE
                );
        }

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"DeferredOpensEnabled",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            MRxSmbDeferredOpensEnabled = (BOOLEAN)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"OplocksDisabled",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            MRxSmbOplocksDisabled = (BOOLEAN)Temp;


        MRxSmbIsCscEnabled = TRUE;

        //this should be a macro......
        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"CscEnabled",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status)) {
            MRxSmbIsCscEnabled = (BOOLEAN)Temp;
        }


        //this would be the end of the macro.......

        if (MRxSmbIsCscEnabled) {

            //this should be a macro......
            Status = MRxSmbGetUlongRegistryParameter(
                         ParametersHandle,
                         L"CscEnabledDCON",
                         (PULONG)&Temp,
                         FALSE );

            if (NT_SUCCESS(Status))
                MRxSmbIsCscEnabledForDisconnected = (BOOLEAN)Temp;
            //this would be the end of the macro.......


            Status = MRxSmbGetUlongRegistryParameter(
                         ParametersHandle,
                         L"CscEnableTransitionByDefault",
                         (PULONG)&Temp,
                         FALSE );

            if (NT_SUCCESS(Status))
                MRxSmbCscTransitionEnabledByDefault = (BOOLEAN)Temp;

            Status = MRxSmbGetUlongRegistryParameter(
                         ParametersHandle,
                         L"CscEnableAutoDial",
                         (PULONG)&Temp,
                         FALSE );

            if (NT_SUCCESS(Status))
                MRxSmbCscAutoDialEnabled = (BOOLEAN)Temp;


        } else {

            MRxSmbIsCscEnabledForDisconnected = FALSE;

        }

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"EnableCompression",
                     (PULONG)&Temp,
                     FALSE);

        if (NT_SUCCESS(Status) &&
            (Temp != 0)) {
            MRxSmbEnableCompression = TRUE;
        }

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"IgnoreBindingOrder",
                     (PULONG)&Temp,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            MRxSmbObeyBindingOrder = !((BOOLEAN)Temp);
        }

#if defined(REMOTE_BOOT)
        RbrList = DefaultRbrList;

        RtlInitUnicodeString(&UnicodeString, L"RemoteBootRedirectionList");
        Status = ZwQueryValueKey(
                    ParametersHandle,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &InitialPartialInformationValue,
                    sizeof(InitialPartialInformationValue),
                    &Temp);
        if (Status== STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(Status)) {

            AllocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                           + InitialPartialInformationValue.DataLength;

            RbrListFromRegistry = RxAllocatePoolWithTag(
                                    PagedPool,
                                    AllocationLength,
                                    MRXSMB_MISC_POOLTAG);
            if (RbrListFromRegistry != NULL) {

                Status = ZwQueryValueKey(
                            ParametersHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            RbrListFromRegistry,
                            AllocationLength,
                            &Temp);

                if (NT_SUCCESS(Status) &&
                    (RbrListFromRegistry->DataLength > 0) &&
                    (RbrListFromRegistry->Type == REG_MULTI_SZ)) {
                    RbrList = (PWCHAR)(&RbrListFromRegistry->Data[0]);
                }
            }
        }

        RtlInitializeUnicodePrefix( &MRxSmbRemoteBootRedirectionTable );

        for ( redirectionEntry = RbrList; *redirectionEntry != 0; ) {

            BOOLEAN redirect;

            if ( *redirectionEntry == L'L' ) {
                redirect = TRUE;
                redirectionEntry++;
            } else if ( *redirectionEntry == L'R' ) {
                redirect = FALSE;
                redirectionEntry++;
            } else {
                redirect = TRUE;
            }

            RtlInitUnicodeString( &prefix, redirectionEntry );
            redirectionEntry = (PWCHAR)((PCHAR)redirectionEntry + prefix.MaximumLength);

            prefixEntryLength = sizeof(RBR_PREFIX) + prefix.MaximumLength;
            prefixEntry = RxAllocatePoolWithTag(
                              PagedPool,
                              prefixEntryLength,
                              MRXSMB_MISC_POOLTAG
                              );


            if ( prefixEntry != NULL ) {
                prefixEntry->Redirect = redirect;
                prefixEntry->Prefix.Buffer = (PWCH)(prefixEntry + 1);
                prefixEntry->Prefix.MaximumLength = prefix.Length + sizeof(WCHAR);
                RtlCopyUnicodeString( &prefixEntry->Prefix, &prefix );

                if ( !RtlInsertUnicodePrefix(
                        &MRxSmbRemoteBootRedirectionTable,
                        &prefixEntry->Prefix,
                        &prefixEntry->TableEntry
                        ) ) {

                    //
                    // The prefix is already in the table.  Ignore the duplicate.
                    //

                    RxFreePool( prefixEntry );
                }
            }
        }
#endif // defined(REMOTE_BOOT)

        ZwClose(ParametersHandle);
    }

    // For server terminal services machines, we multiplex based on LUID.
    if( IsTerminalServicesServer() && !MRxSmbIsCscEnabled )
    {
        MRxSmbConnectionIdLevel = 2;
    }

    RtlInitUnicodeString(&WorkStationParametersRegistryKeyName, SMBMRX_WORKSTATION_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkStationParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey(&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"RequireSecuritySignature",
                     (PULONG)&Temp,
                     FALSE);

        if (NT_SUCCESS(Status) && (Temp != 0)) {
            MRxSmbSecuritySignaturesEnabled = TRUE;
            MRxSmbSecuritySignaturesRequired = TRUE;
        } else {
            Status = MRxSmbGetUlongRegistryParameter(
                         ParametersHandle,
                         L"EnableSecuritySignature",
                         (PULONG)&Temp,
                        FALSE);

            if( NT_SUCCESS(Status) )
            {
                if( Temp != 0 )
                {
                    MRxSmbSecuritySignaturesEnabled = TRUE;
                }
                else
                {
                    MRxSmbSecuritySignaturesEnabled = FALSE;
                }
            }
        }

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"EnablePlainTextPassword",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            EnablePlainTextPassword = (BOOLEAN)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"OffLineFileTimeoutIntervalInSeconds",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            OffLineFileTimeoutInterval = (ULONG)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"ExtendedSessTimeout",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            ExtendedSessTimeoutInterval = (ULONG)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"MaxNumOfExchangesForPipelineReadWrite",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            MaxNumOfExchangesForPipelineReadWrite = (ULONG)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"Win9xSessionRestriction",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            Win9xSessionRestriction = (BOOLEAN)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"EnableCachingOnWriteOnlyOpens",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            MRxSmbEnableCachingOnWriteOnlyOpens = (BOOLEAN)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"DisableByteRangeLockingOnReadOnlyFiles",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            DisableByteRangeLockingOnReadOnlyFiles = (BOOLEAN)Temp;

        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"UniqueFileNames",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            UniqueFileNames = (BOOLEAN)Temp;

        //
        // Modified LOGOFF behavior for downlevel servers.
        //
        MRxSmbEnableDownLevelLogOff = FALSE;
        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"EnableDownLevelLogOff",
                     (PULONG)&Temp,
                     FALSE);

        if ( NT_SUCCESS( Status ) ) {
            if( Temp != 0 )
            {
                MRxSmbEnableDownLevelLogOff = TRUE;
            }
        }


        ZwClose(ParametersHandle);
    }

    // Detect if system setup in progress
    RtlInitUnicodeString(&WorkStationParametersRegistryKeyName, SYSTEM_SETUP_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkStationParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey(&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        Status = MRxSmbGetUlongRegistryParameter(
                     ParametersHandle,
                     L"SystemSetupInProgress",
                     (PULONG)&Temp,
                     FALSE );

        if (NT_SUCCESS(Status))
            SetupInProgress = (BOOLEAN)Temp;

        ZwClose(ParametersHandle);
    }

    // initialize event log parameter so that it can translate dos error into text description
    RtlInitUnicodeString(&WorkStationParametersRegistryKeyName, EVENTLOG_MRXSMB_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkStationParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey(&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        ULONG Storage[16];
        PKEY_VALUE_PARTIAL_INFORMATION Value;
        ULONG ValueSize;
        NTSTATUS Status;
        ULONG BytesRead;

        RtlInitUnicodeString(&UnicodeString, L"ParameterMessageFile");
        Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
        ValueSize = sizeof(Storage);

        Status = ZwQueryValueKey(
                        ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);

        if (Status != STATUS_SUCCESS || Value->Type != REG_EXPAND_SZ) {
            UNICODE_STRING UnicodeString1;

            RtlInitUnicodeString(&UnicodeString1, L"%SystemRoot%\\System32\\kernel32.dll");

            Status = ZwSetValueKey(
                         ParametersHandle,
                         &UnicodeString,
                         0,
                         REG_EXPAND_SZ,
                         UnicodeString1.Buffer,
                         UnicodeString1.Length+sizeof(NULL));
        }

        ZwClose(ParametersHandle);
    }

    //
    // Get Server GUID for Loopback Detection
    //     Server Restart updates cached GUID ????
    //
    RtlInitUnicodeString( &UnicodeString, SMB_SERVER_PARAMETERS );

    InitializeObjectAttributes(
    &ObjectAttributes,
    &UnicodeString,
    OBJ_CASE_INSENSITIVE,
    NULL,
    NULL
    );

    Status = ZwOpenKey( &ParametersHandle, KEY_READ, &ObjectAttributes );

    if( NT_SUCCESS( Status ) ) {

    ULONG BytesRead;
    ULONG regValue[ sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( GUID ) ];
    ULONG regValueSize = sizeof( regValue );


    RtlInitUnicodeString( &UnicodeString, L"Guid" );
    Status = ZwQueryValueKey( ParametersHandle,
                  &UnicodeString,
                  KeyValuePartialInformation,
                  (PKEY_VALUE_PARTIAL_INFORMATION)&regValue,
                  regValueSize,
                  &BytesRead
                  );

    RtlCopyMemory(&CachedServerGuid,
              ((PKEY_VALUE_PARTIAL_INFORMATION)&regValue)->Data,
              sizeof(GUID));


    ZwClose(ParametersHandle);
    }
}

NTSTATUS
SmbCeGetConfigurationInformation()
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;
   PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;

   PAGED_CODE();

   IF_NOT_MRXSMB_CSC_ENABLED {
       MRxSmbReadMiscellaneousRegistryParameters();
   }

   // Obtain the list of transports associated with SMB redirector. This is stored
   // as a multivalued string and is used subsequently to weed out the
   // appropriate transports. This is a two step process; first we try to find out
   // how much space we need; then we allocate; then we read in. unfortunately, the kind of
   // structure that we have to use to get the value has a header on it, so we have to offset the
   // returned pointer both here and in the free routine.

   //CODE.IMPROVEMENT we should perhaps get a subroutine going that does all this
   //also, there are no log entries.
   //also, we should be doing partial_infos instead of full

   RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_TRANSPORTS);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               &InitialPartialInformationValue,
               sizeof(InitialPartialInformationValue),
               &BytesRead);
   if (Status== STATUS_BUFFER_OVERFLOW) {
       Status = STATUS_SUCCESS;
   }

   if (!NT_SUCCESS(Status)) {
       ZwClose(hRegistryKey);
       return Status;
   }

   AllocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                  + InitialPartialInformationValue.DataLength;
   if (0) {
       DbgPrint("SizeofBindingInfo=%08lx %08lx\n",
                      AllocationLength,
                      InitialPartialInformationValue.DataLength);
   }

   if (SmbCeContext.Transports.Buffer != NULL) {

       // the transports buffer is at the end of a larger buffer (by 12 bytes)
       // allocated to read the value from the registry. recover the original buffer
       // pointer in orer to free.

       TransportsValueFromRegistry = CONTAINING_RECORD(
                                        SmbCeContext.Transports.Buffer,
                                        KEY_VALUE_PARTIAL_INFORMATION,
                                        Data[0]
                                     );
       //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
       RxFreePool(TransportsValueFromRegistry);

       SmbCeContext.Transports.Buffer = NULL;
       SmbCeContext.Transports.Length = 0;
       SmbCeContext.Transports.MaximumLength = 0;
   }

   (PBYTE)TransportsValueFromRegistry = RxAllocatePoolWithTag(
                                             PagedPool,
                                             AllocationLength,
                                             MRXSMB_MISC_POOLTAG);

   if (TransportsValueFromRegistry == NULL) {
       ZwClose(hRegistryKey);
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               TransportsValueFromRegistry,
               AllocationLength,
               &BytesRead);

   if (NT_SUCCESS(Status) &&
       (TransportsValueFromRegistry->DataLength > 0) &&
       (TransportsValueFromRegistry->Type == REG_MULTI_SZ)) {

       SmbCeContext.Transports.MaximumLength =
           SmbCeContext.Transports.Length = (USHORT)TransportsValueFromRegistry->DataLength;
       SmbCeContext.Transports.Buffer = (PWCHAR)(&TransportsValueFromRegistry->Data[0]);
      //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
   } else {
      RxLog(("Invalid Transport Binding string... using all transports"));
      SmbLog(LOG,
             SmbCeGetConfigurationInformation,
             LOGULONG(Status));
      RxFreePool(TransportsValueFromRegistry);
      TransportsValueFromRegistry = NULL;
   }

   ZwClose(hRegistryKey);

   return Status;
}


NTSTATUS
SmbCeGetComputerName(
   VOID
   )
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;

   PAGED_CODE();

   ASSERT(SmbCeContext.ComputerName.Buffer == NULL);

   // Obtain the computer name. This is used in formulating the local NETBIOS address
   RtlInitUnicodeString(&SmbCeContext.ComputerName, NULL);
   if (!MRxSmbBootedRemotely) {
        RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_COMPUTER_NAME);
   } else {
        //
        // For remote boot, we are initializing long before the volatile
        // ActiveComputerNameKey is created, so we need to read from the
        // nonvolatile key instead. This is not a problem, because we know
        // that the computer name hasn't been changed since the computer was
        // booted -- since we're very early in the boot sequence -- so the
        // nonvolatile key has the correct computer name.
        //
        RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_COMPUTER_NAME_NONVOLATILE);
   }

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, COMPUTERNAME);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {
      // Rtl conversion routines require NULL char to be excluded from the
      // length.
      SmbCeContext.ComputerName.MaximumLength =
          SmbCeContext.ComputerName.Length = (USHORT)Value->DataLength - sizeof(WCHAR);

      SmbCeContext.ComputerName.Buffer = RxAllocatePoolWithTag(
                                                PagedPool,
                                                SmbCeContext.ComputerName.Length,
                                                MRXSMB_MISC_POOLTAG);

      if (SmbCeContext.ComputerName.Buffer != NULL) {
         RtlCopyMemory(SmbCeContext.ComputerName.Buffer,
                       (PCHAR)Value+Value->DataOffset,
                       Value->DataLength - sizeof(WCHAR));
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   ZwClose(hRegistryKey);

   return Status;
}

NTSTATUS
SmbCeGetOperatingSystemInformation(
   VOID
   )
{
   ULONG            Storage[256], Storage2[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status, Status2;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   PKEY_VALUE_FULL_INFORMATION Value2 = (PKEY_VALUE_FULL_INFORMATION)Storage2;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;

   PAGED_CODE();

   ASSERT(SmbCeContext.OperatingSystem.Buffer == NULL);
   ASSERT(SmbCeContext.LanmanType.Buffer == NULL);

   RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_CURRENT_WINDOWS_VERSION);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);

   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_OPERATING_SYSTEM);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {

       // check for existance of Service Pack String
       RtlInitUnicodeString(&UnicodeString, L"CSDVersion");
       Status2 = ZwQueryValueKey(
       hRegistryKey,
       &UnicodeString,
       KeyValueFullInformation,
       Value2,
       sizeof(Storage2),
       &BytesRead);

       SmbCeContext.OperatingSystem.MaximumLength =
       (USHORT)Value->DataLength + sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) - sizeof(WCHAR);

       if(NT_SUCCESS(Status2)) {
       SmbCeContext.OperatingSystem.MaximumLength += (USHORT)Value2->DataLength;
       }

       SmbCeContext.OperatingSystem.Length = SmbCeContext.OperatingSystem.MaximumLength - sizeof(WCHAR);

       SmbCeContext.OperatingSystem.Buffer = RxAllocatePoolWithTag(
       PagedPool,
       SmbCeContext.OperatingSystem.MaximumLength,
       MRXSMB_MISC_POOLTAG);

       if (SmbCeContext.OperatingSystem.Buffer != NULL) {
       RtlCopyMemory(SmbCeContext.OperatingSystem.Buffer,
             RDR_CONFIG_OPERATING_SYSTEM_NAME,
             sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME));

       RtlCopyMemory((SmbCeContext.OperatingSystem.Buffer +
              (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
             (PCHAR)Value+Value->DataOffset,
             Value->DataLength);

       if(NT_SUCCESS(Status2)) {

           // add a space
           RtlCopyMemory(SmbCeContext.OperatingSystem.Buffer +
                 (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) + Value->DataLength)/sizeof(WCHAR) - 2,
                 L" ",
                 sizeof(WCHAR));

           RtlCopyMemory(SmbCeContext.OperatingSystem.Buffer +
                 (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) + Value->DataLength)/sizeof(WCHAR) - 1,
                 (PCHAR)Value2+Value2->DataOffset,
                 Value2->DataLength);
       }

       } else {
       Status = STATUS_INSUFFICIENT_RESOURCES;
       }
   }

   if (NT_SUCCESS(Status)) {
      RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_OPERATING_SYSTEM_VERSION);
      Status = ZwQueryValueKey(
                     hRegistryKey,
                     &UnicodeString,
                     KeyValueFullInformation,
                     Value,
                     sizeof(Storage),
                     &BytesRead);

      if (NT_SUCCESS(Status)) {
         SmbCeContext.LanmanType.MaximumLength =
             SmbCeContext.LanmanType.Length = (USHORT)Value->DataLength +
                                    sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) -
                                    sizeof(WCHAR);

         SmbCeContext.LanmanType.Buffer = RxAllocatePoolWithTag(
                                             PagedPool,
                                             SmbCeContext.LanmanType.Length,
                                             MRXSMB_MISC_POOLTAG);
         if (SmbCeContext.LanmanType.Buffer != NULL) {
            RtlCopyMemory(
                  SmbCeContext.LanmanType.Buffer,
                  RDR_CONFIG_OPERATING_SYSTEM_NAME,
                  sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME));

            RtlCopyMemory(
                  (SmbCeContext.LanmanType.Buffer +
                   (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
                  (PCHAR)Value+Value->DataOffset,
                  Value->DataLength);
         } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
         }
      }
   }

   ZwClose(hRegistryKey);

   return Status;
}

NTSTATUS
MRxSmbPnpIrpCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine completes the PNP irp for SMB mini redirector.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    pIrp - Supplies the Irp being processed

    pContext - the completion context

--*/
{
    PKEVENT pCompletionEvent = pContext;

    KeSetEvent(
        pCompletionEvent,
        IO_NO_INCREMENT,
        FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MRxSmbProcessPnpIrp(
    PIRP pIrp)
/*++

Routine Description:

    This routine initiates the processing of PNP irps for SMB mini redirector.

Arguments:

    pIrp - Supplies the Irp being processed

Notes:

    The query target device relation is the only call that is implemented
    currently. This is done by returing the PDO associated with the transport
    connection object. In any case this routine assumes the responsibility of
    completing the IRP and return STATUS_PENDING.

    This routine also writes an error log entry when the underlying transport
    fails the request. This should help us isolate the responsibility.

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( pIrp );

    IoMarkIrpPending(pIrp);

    if ((IrpSp->MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS)  &&
        (IrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation)) {
        PIRP         pAssociatedIrp;
        PFILE_OBJECT pConnectionFileObject = NULL;
        PMRX_FCB     pFcb = NULL;

        PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
        BOOLEAN       ServerTransportReferenced = FALSE;

        // Locate the transport connection object for the associated file object
        // and forward the query to that device.

        if ((IrpSp->FileObject != NULL) &&
            ((pFcb = IrpSp->FileObject->FsContext) != NULL) &&
            (NodeTypeIsFcb(pFcb))) {
            PMRX_SRV_CALL pSrvCall;
            PMRX_NET_ROOT pNetRoot;

            if (((pNetRoot = pFcb->pNetRoot) != NULL) &&
                ((pSrvCall = pNetRoot->pSrvCall) != NULL)) {
                pServerEntry = pSrvCall->Context;

                if (pServerEntry != NULL) {
                    SmbCeAcquireResource();

                    Status = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

                    if (Status == STATUS_SUCCESS) {
                        pConnectionFileObject = SmbCepReferenceEndpointFileObject(
                                                    pServerEntry->pTransport);

                        ServerTransportReferenced = TRUE;
                    }

                    SmbCeReleaseResource();
                }
            }
        }

        if (pConnectionFileObject != NULL) {
            PDEVICE_OBJECT                     pRelatedDeviceObject;
            PIO_STACK_LOCATION                 pIrpStackLocation,
                                               pAssociatedIrpStackLocation;

            pRelatedDeviceObject = IoGetRelatedDeviceObject(pConnectionFileObject);

            pAssociatedIrp = IoAllocateIrp(
                                 pRelatedDeviceObject->StackSize,
                                 FALSE);

            if (pAssociatedIrp != NULL) {
                KEVENT CompletionEvent;

                KeInitializeEvent( &CompletionEvent,
                                   SynchronizationEvent,
                                   FALSE );

                // Fill up the associated IRP and call the underlying driver.
                pAssociatedIrpStackLocation = IoGetNextIrpStackLocation(pAssociatedIrp);
                pIrpStackLocation           = IoGetCurrentIrpStackLocation(pIrp);

                *pAssociatedIrpStackLocation = *pIrpStackLocation;

                pAssociatedIrpStackLocation->FileObject = pConnectionFileObject;
                pAssociatedIrpStackLocation->DeviceObject = pRelatedDeviceObject;

                IoSetCompletionRoutine(
                    pAssociatedIrp,
                    MRxSmbPnpIrpCompletion,
                    &CompletionEvent,
                    TRUE,TRUE,TRUE);

                pAssociatedIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                Status = IoCallDriver(pRelatedDeviceObject,pAssociatedIrp);

                if (Status == STATUS_PENDING) {
                    (VOID) KeWaitForSingleObject(
                               &CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );
                }

                pIrp->IoStatus = pAssociatedIrp->IoStatus;
                Status = pIrp->IoStatus.Status;

                if (!NT_SUCCESS(Status)) {
                    MRxSmbLogTransportError(
                        &pServerEntry->pTransport->pTransport->RxCeTransport.Name,
                        &SmbCeContext.DomainName,
                        Status,
                        EVENT_RDR_CONNECTION);
                }

                ObDereferenceObject(pConnectionFileObject);

                IoFreeIrp(pAssociatedIrp);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        if (ServerTransportReferenced) {
            SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
        }
    } else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (Status != STATUS_PENDING) {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        Status = STATUS_PENDING;
    }

    return STATUS_PENDING;
}

WML_CONTROL_GUID_REG MRxSmb_ControlGuids[] = {
   { // 8fc7e81a-f733-42e0-9708-cfdae07ed969 MRxSmb
     0x8fc7e81a,0xf733,0x42e0,{0x97,0x08,0xcf,0xda,0xe0,0x7e,0xd9,0x69},
     { // eab93e5c-02ce-4e33-9419-901d82868816
       {0xeab93e5c,0x02ce,0x4e33,{0x94,0x19,0x90,0x1d,0x82,0x86,0x88,0x16},},
       // 56a0dee7-be12-4cf1-b7e0-976b0d174944
       {0x56a0dee7,0xbe12,0x4cf1,{0xb7,0xe0,0x97,0x6b,0x0d,0x17,0x49,0x44},},
       // ecabc730-60bf-481e-b92b-2749f8272d9d
       {0xecabc730,0x60bf,0x481e,{0xb9,0x2b,0x27,0x49,0xf8,0x27,0x2d,0x9d},}
     },
   },
};

#define MRxSmb_ControlGuids_len  1

NTSTATUS
MRxSmbProcessSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for doing System control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    WML_TINY_INFO Info;
    UNICODE_STRING RegPath;

    PAGED_CODE();

    if (EnableWmiLog) {
        RtlInitUnicodeString (&RegPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MRxSmb");

        RtlZeroMemory (&Info, sizeof(Info));

        Info.ControlGuids = MRxSmb_ControlGuids;
        Info.GuidCount = MRxSmb_ControlGuids_len;
        Info.DriverRegPath = &RegPath;

        Status = WmlTinySystemControl(&Info,DeviceObject,Irp);

        if (Status != STATUS_SUCCESS) {
            //DbgPrint("MRxSmb WMI control return %lx\n", Status);
        }
    } else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

extern LONG BowserDebugTraceLevel;
NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the smbmini DRIVER object.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

Notes:

    This routine centralizes the logic required to dela with special cases in
    handling various requests directed to the redirector.

    1) The Browser is built as part of the redirector driver ( mrxsmb.sys ) for
    historical reasons ( carryover effect from the old redirector ). Hence this
    routine serves as the switching point for redirecting requests to the browser
    or the redirector depending on the device object.

    2) The browser occasionally specifies a transport name in its open requests.
    This is a request by the browser to override the transport priority
    otherwise specified. In such cases this routine invokes the appropriate
    preprocessing before passing on the request to the wrapper.

    3) The DFS driver also specifies additional parameters in its open requests.
    In such cases this routine invokes the appropriate preprocessing routine.

    4) The PNP IRP for returning device relations are subverted by the mini
    redirector for SMB

    (2) (3) and (4) are legitimate uses of the wrapper architecture in which each
    mini redirector is given the ability to customize the response to IRPs
    passed in by the I/O subsystem. This is typically done by overiding the
    dispatch vector.

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget
    UCHAR  MajorFunctionCode = IrpSp->MajorFunction;
    ULONG  MinorFunctionCode = IrpSp->MinorFunction;
    BOOLEAN ForwardRequestToWrapper = TRUE;

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    NTSTATUS Status;


    PAGED_CODE();

    if (DeviceObject == (PDEVICE_OBJECT)BowserDeviceObject) {
        switch (MajorFunctionCode) {
        case IRP_MJ_DEVICE_CONTROL:
            {
                ULONG IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

                Status = BowserFsdDeviceIoControlFile(BowserDeviceObject, Irp);

                if ((Status == STATUS_SUCCESS) &&
                    (MinorFunctionCode == IRP_MN_USER_FS_REQUEST) &&
                    (IoControlCode == IOCTL_LMDR_START)) {

                    MRxSmbRegisterForPnpNotifications();
                }
            }

            return Status;

        case IRP_MJ_QUERY_INFORMATION:
            return BowserFsdQueryInformationFile(BowserDeviceObject, Irp);

        case IRP_MJ_CREATE:
            return BowserFsdCreate(BowserDeviceObject, Irp);

        case IRP_MJ_CLEANUP:
            return BowserFsdCleanup(BowserDeviceObject, Irp);

        case IRP_MJ_CLOSE:
            return BowserFsdClose(BowserDeviceObject, Irp);

        default:
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT );
            return (STATUS_NOT_IMPLEMENTED);
        }
    }

    ASSERT(DeviceObject==(PDEVICE_OBJECT)MRxSmbDeviceObject);
    if (DeviceObject!=(PDEVICE_OBJECT)MRxSmbDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    if (IrpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        return MRxSmbProcessSystemControlIrp(DeviceObject,Irp);
    }

    Status = STATUS_SUCCESS;

    FsRtlEnterFileSystem();

    if (IrpSp->MajorFunction == IRP_MJ_PNP) {
        ForwardRequestToWrapper = FALSE;
        Status = MRxSmbProcessPnpIrp(Irp);
    } else {
        if (IrpSp->MajorFunction == IRP_MJ_CREATE) {
            Status = CscPreProcessCreateIrp(Irp);
        }

        if (Status == STATUS_SUCCESS) {
            Status = MRxSmbCheckTransportName(Irp, &pServerEntry);
        }
    }

    FsRtlExitFileSystem();

    if ((Status == STATUS_SUCCESS) &&
        ForwardRequestToWrapper){
        Status = RxFsdDispatch((PRDBSS_DEVICE_OBJECT)MRxSmbDeviceObject,Irp);
    } else if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
    }

    if (pServerEntry != NULL ) {
        FsRtlEnterFileSystem();

        pServerEntry->TransportSpecifiedByUser = 0;
        SmbCeDereferenceServerEntry(pServerEntry);

        FsRtlExitFileSystem();
    }

    return Status;
}

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
{
    PAGED_CODE();

    MRxSmbCscDeallocateForFcb(pFcb);
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
{

    PAGED_CODE();

    IF_DEBUG {
        PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(pFobx);
        PMRX_SRV_OPEN SrvOpen = pFobx->pSrvOpen;
        PMRX_FCB Fcb = SrvOpen->pFcb;

        if (smbFobx && FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE)) {
            DbgPrint("Finalizobx side buffer %p %p %p %pon %wZ\n",
                     0, 0, // sidebuffer, count
                     smbFobx,pFobx,GET_ALREADY_PREFIXED_NAME(SrvOpen,Fcb)
                     );
        }
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbDeleteRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    PAGED_CODE(); //INIT

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwDeleteValueKey(ParametersHandle,
                        &UnicodeString);

    ASSERT(NT_SUCCESS(Status));

    return(Status);

}

NTSTATUS
MRxSmbGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    )
{
    ULONG Storage[16];
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    ULONG ValueSize;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ValueSize = sizeof(Storage);

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (!LogFailure) { return Status; }

     RxLogFailureWithBuffer(
         MRxSmbDeviceObject,
         NULL,
         EVENT_RDR_CANT_READ_REGISTRY,
         Status,
         ParameterName,
         (USHORT)(wcslen(ParameterName)*sizeof(WCHAR))
         );

     return Status;
}

NTSTATUS
SmbCeGetServersWithExtendedSessTimeout()
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;
   PKEY_VALUE_PARTIAL_INFORMATION ServersValueFromRegistry;

   PAGED_CODE();

   // Obtain the list of servers associated with extended session timeout.

   // This is required by third party server which handles SMB sessions with different processes.
   // The time to process requests on different sessions can be varied dramatically.

   RtlInitUnicodeString(&UnicodeString, SMBMRX_WORKSTATION_PARAMETERS);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       //DbgPrint("SmbCeGetServersWithExtendedSessTimeout ZwOpenKey failed %x\n",Status);
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, L"ServersWithExtendedSessTimeout");
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               &InitialPartialInformationValue,
               sizeof(InitialPartialInformationValue),
               &BytesRead);
   if (Status== STATUS_BUFFER_OVERFLOW) {
       Status = STATUS_SUCCESS;
   }

   if (!NT_SUCCESS(Status)) {
       ZwClose(hRegistryKey);
       return Status;
   }

   AllocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                  + InitialPartialInformationValue.DataLength;
   if (0) {
       DbgPrint("SizeofBindingInfo=%08lx %08lx\n",
                      AllocationLength,
                      InitialPartialInformationValue.DataLength);
   }

   ASSERT(SmbCeContext.ServersWithExtendedSessTimeout.Buffer == NULL);

   (PBYTE)ServersValueFromRegistry = RxAllocatePoolWithTag(
                                             PagedPool,
                                             AllocationLength,
                                             MRXSMB_MISC_POOLTAG);

   if (ServersValueFromRegistry == NULL) {
       ZwClose(hRegistryKey);
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               ServersValueFromRegistry,
               AllocationLength,
               &BytesRead);

   if (NT_SUCCESS(Status) &&
       (ServersValueFromRegistry->DataLength > 0) &&
       (ServersValueFromRegistry->Type == REG_MULTI_SZ)) {

       SmbCeContext.ServersWithExtendedSessTimeout.MaximumLength =
           SmbCeContext.ServersWithExtendedSessTimeout.Length = (USHORT)ServersValueFromRegistry->DataLength;
       SmbCeContext.ServersWithExtendedSessTimeout.Buffer = (PWCHAR)(&ServersValueFromRegistry->Data[0]);
       //DbgPrint("b1 %08lx b2 %08lx\n", ServersValueFromRegistry,SmbCeContext.ServersWithExtendedSessTimeout.Buffer);
   } else {
      RxLog(("Invalid Transport Binding string... using all transports"));
      SmbLog(LOG,
             SmbCeGetConfigurationInformation,
             LOGULONG(Status));
      RxFreePool(ServersValueFromRegistry);
      ServersValueFromRegistry = NULL;
   }

   ZwClose(hRegistryKey);

   return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\infocach.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the name cache for file basic and standard information.

Author:

    Yun Lin      [YunLin]      2-Octorber-1998

Revision History:

--*/

#include "precomp.h"
#include "smbce.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbIsStreamFile)
#pragma alloc_text(PAGE, MRxSmbCacheFileNotFound)
#pragma alloc_text(PAGE, MRxSmbCreateFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbIsFileInfoCacheFound)
#pragma alloc_text(PAGE, MRxSmbInvalidateFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbUpdateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbCreateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbUpdateFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxSmbCreateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbUpdateFileInfoCacheFileSize)
#pragma alloc_text(PAGE, MRxSmbUpdateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbInvalidateFileNotFoundCache)
#pragma alloc_text(PAGE, MRxSmbUpdateBasicFileInfoCacheAll)
#pragma alloc_text(PAGE, MRxSmbInvalidateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbUpdateBasicFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxSmbInvalidateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbInvalidateInternalFileInfoCache)
#pragma alloc_text(PAGE, MRxSmbUpdateStandardFileInfoCacheStatus)
#endif

extern FAST_MUTEX MRxSmbFileInfoCacheLock;

VOID
MRxSmbCreateFileInfoCache(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the file information package including basic and standard information
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PAGED_CODE();

    if (!pServerEntry->Server.IsLoopBack) {
        MRxSmbCreateBasicFileInfoCache(RxContext,&FileInfo->Basic,pServerEntry,Status);
        MRxSmbCreateStandardFileInfoCache(RxContext,&FileInfo->Standard,pServerEntry,Status);
    }
}

VOID
MRxSmbCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - the file basic information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    RX_NC_CHECK_STATUS      NameCacheStatus;
    PFILE_BASIC_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    if (pServerEntry->Server.IsLoopBack ||
        (MRxSmbIsLongFileName(RxContext) &&
         pServerEntry->Server.Dialect != LANMAN21_DIALECT)) {
        return;
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    NameCacheCtl = &pNetRootEntry->NameCacheCtlGFABasic;

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Basic;

        NameCache->PriorStatus = Status;

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME,
            MRxSmbStatistics.SmbsReceived.LowPart);

        //DbgPrint(" Create File Attrib cache : %x %wZ\n",Basic->FileAttributes,OriginalFileName);
        //DbgPrint(" Create File Attrib cache : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    if (pServerEntry->Server.IsLoopBack ||
        (MRxSmbIsLongFileName(RxContext) &&
         pServerEntry->Server.Dialect != LANMAN21_DIALECT)) {
        return;
    }

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Standard;

        NameCache->PriorStatus = Status;

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME,
            MRxSmbStatistics.SmbsReceived.LowPart);

        //DbgPrint(" Create Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbCreateInternalFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_INTERNAL_INFORMATION Internal,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file internal information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAInternal;
    PFILE_INTERNAL_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    if (pServerEntry->Server.IsLoopBack) {
        return;
    }

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_INTERNAL_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Internal;

        NameCache->PriorStatus = Status;

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME,
            MRxSmbStatistics.SmbsReceived.LowPart);

        //DbgPrint("  Create Internal  cache  : %I64x %wZ\n",((PFILE_INTERNAL_INFORMATION)NameCache->ContextExtension)->IndexNumber,OriginalFileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry as STATUS_OBJECT_NAME_NOT_FOUND
   for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    MRxSmbUpdateBasicFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
    MRxSmbUpdateStandardFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
}

VOID
MRxSmbUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    MRxSmbUpdateBasicFileInfoCacheStatus(RxContext,Status);
    MRxSmbUpdateStandardFileInfoCacheStatus(RxContext,Status);
}

VOID
MRxSmbUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        //DbgPrint("Update status basic    : %x %wZ\n",Status,OriginalFileName);
        RxLog(("Update status basic    : %x %wZ\n",Status,OriginalFileName));
    } else {
        RxLog(("Update status basic fails: %x %wZ\n",Status,OriginalFileName));
    }

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {

        // if it is a stream file, we invalid the root file name cache needs since we are not
        // sure what could happen to the root file on the server
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }

        //DbgPrint("Update status basic    : %x %wZ\n",Status,&FileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);
    }
    /*
    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    } */

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxSmbInvalidateBasicFileInfoCache(RxContext);
    MRxSmbInvalidateStandardFileInfoCache(RxContext);
}

VOID
MRxSmbInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file basic information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);

        //DbgPrint("Invalid Baisc    cache : %wZ\n",OriginalFileName);
        RxLog(("Invalid Baisc    cache : %wZ\n",OriginalFileName));
    }

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        //DbgPrint("Invalid Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName);
    }

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbInvalidateInternalFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file internal information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAInternal;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);

        //DbgPrint("Invalid Internal cache : %wZ\n",OriginalFileName);
        RxLog(("Invalid Internal cache : %wZ\n",OriginalFileName));
    }

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize
    )
/*++

Routine Description:

   This routine updates file size on the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        FileInfoCache->AllocationSize.QuadPart = FileSize->QuadPart;
        FileInfoCache->EndOfFile.QuadPart = FileSize->QuadPart;

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        //DbgPrint("Update File size cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName);
    }
    /*
    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }*/

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime
    )
/*++

Routine Description:

   This routine updates file attributs and last write time on the name cache entry
   for the file basic information.

Arguments:

    RxContext - the RDBSS context
    FileAttributes - new file attributes
    pLastWriteTime - address of file last write time

Return Value:

    none

--*/
{
    FILE_BASIC_INFORMATION Basic;

    Basic.ChangeTime.QuadPart = 0;
    Basic.CreationTime.QuadPart = 0;
    Basic.LastWriteTime.QuadPart = 0;
    Basic.LastAccessTime.QuadPart = 0;

    if (pLastWriteTime != NULL && pLastWriteTime->QuadPart != 0) {
        Basic.LastWriteTime = *pLastWriteTime;
    }

    Basic.FileAttributes = FileAttributes;

    MRxSmbUpdateBasicFileInfoCacheAll(RxContext,&Basic);
}

VOID
MRxSmbUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic - file basic information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFABasic;
    PFILE_BASIC_INFORMATION BasicFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        ULONG SavedAttributes = 0;

        BasicFileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        if (Basic->CreationTime.QuadPart != 0) {
            BasicFileInfoCache->CreationTime = Basic->CreationTime;
        }

        if (Basic->LastAccessTime.QuadPart != 0) {
            BasicFileInfoCache->LastAccessTime = Basic->LastAccessTime;
        }

        if (Basic->LastWriteTime.QuadPart != 0) {
            BasicFileInfoCache->LastWriteTime = Basic->LastWriteTime;
        }

        SavedAttributes = BasicFileInfoCache->FileAttributes &
                          ( FILE_ATTRIBUTE_DIRECTORY |
                            FILE_ATTRIBUTE_ENCRYPTED |
                            FILE_ATTRIBUTE_COMPRESSED |
                            FILE_ATTRIBUTE_SPARSE_FILE |
                            FILE_ATTRIBUTE_REPARSE_POINT );

        //DbgPrint("Update File Attrib cache 1: %x %wZ\n",FileAttributes,OriginalFileName);
        //DbgPrint("Update File Attrib cache 2: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName);

        BasicFileInfoCache->FileAttributes = Basic->FileAttributes;

        BasicFileInfoCache->FileAttributes |= SavedAttributes;

        if (BasicFileInfoCache->FileAttributes & ~FILE_ATTRIBUTE_NORMAL) {
            BasicFileInfoCache->FileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        //DbgPrint("Update File Attrib cache 3: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName);
        //DbgPrint("Update File Attrib cache  : %I64X %I64X %wZ\n",BasicFileInfoCache->CreationTime,BasicFileInfoCache->LastAccessTime,OriginalFileName);
    }

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        // if it is a stream file, we need to invalid the root file since we are not sure how this
        // could affect the root file.
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file standard information.

Arguments:

    RxContext   - the RDBSS context
    Standard    - file standard information
    IsDirectory - file is a directory

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION StandardFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        StandardFileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        if (Standard != NULL) {
            *StandardFileInfoCache = *Standard;
        } else {
            StandardFileInfoCache->Directory = IsDirectory;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        //DbgPrint(" Update Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName);
    }
    /*
    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    } */

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

BOOLEAN
MRxSmbIsFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - buffer to return file basic and standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    PFILE_BASIC_INFORMATION    Basic;
    PFILE_STANDARD_INFORMATION Standard;

    BOOLEAN CacheFound = FALSE;

    if (MRxSmbIsBasicFileInfoCacheFound(RxContext,&FileInfo->Basic,Status,OriginalFileName)) {
        if (*Status == STATUS_SUCCESS) {
            if (MRxSmbIsStandardFileInfoCacheFound(RxContext,&FileInfo->Standard,Status,OriginalFileName)) {
                CacheFound = TRUE;
            }
        } else {

            // if an error stored on the file basic information cache, return cache found
            CacheFound = TRUE;
        }
    }

    return CacheFound;
}

// these file attributes may be different between streams on a file
ULONG StreamAttributes = FILE_ATTRIBUTE_COMPRESSED |
                         FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_SPARSE_FILE;

BOOLEAN
MRxSmbIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - buffer to return file basic information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    ULONG                   RootAttributes = 0;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    NameCacheCtl = &pNetRootEntry->NameCacheCtlGFABasic;

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {

        // check for stream file attribute changes
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            NameCacheStatus = RxNameCacheCheckEntry(
                                  NameCache,
                                  NameCache->Context);

            if (NameCacheStatus == RX_NC_SUCCESS) {
                RootFound = TRUE;
                RootStatus = NameCache->PriorStatus;
                RootAttributes = ((PFILE_BASIC_INFORMATION)NameCache->ContextExtension)->FileAttributes & ~StreamAttributes;
                RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);
            } else {
                RxNameCacheExpireEntry(NameCacheCtl, NameCache);
            }
        }
    }

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound ||
             (*Status == RootStatus &&
             (Basic->FileAttributes & ~StreamAttributes) == RootAttributes))) {

            // The name cache matches if it is not expired and the attributes matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Basic = *((PFILE_BASIC_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            //DbgPrint("   Found Basic     cache  : %x %wZ\n",Basic->FileAttributes,OriginalFileName);
            //DbgPrint("   Get File Attrib cache  : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    } else {
        //DbgPrint("   No    Basic     cache  : %wZ\n",OriginalFileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);

    return CacheFound;
}

BOOLEAN
MRxSmbIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - buffer to return file standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAStandard;
    RX_NC_CHECK_STATUS NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PMRX_SMB_SRV_OPEN       smbSrvOpen;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    } else {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    if (MRxSmbIsStreamFile(OriginalFileName,&FileName)) {

        // check for stream file attribute changes
        NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

        if (NameCache != NULL) {
            NameCacheStatus = RxNameCacheCheckEntry(
                                  NameCache,
                                  NameCache->Context);

            if (NameCacheStatus == RX_NC_SUCCESS) {
                RootFound = TRUE;
                RootStatus = NameCache->PriorStatus;
                RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);
            } else {
                RxNameCacheExpireEntry(NameCacheCtl, NameCache);
            }
        }
    }

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound || *Status == RootStatus)) {

            // The name cache matches if it is not expired and the status matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Standard = *((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension);

            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN) &&
                !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                RxGetFileSizeWithLock((PFCB)capFcb,&Standard->EndOfFile.QuadPart);
            }

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            //DbgPrint("    Get Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);

    return CacheFound;
}

BOOLEAN
MRxSmbIsInternalFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_INTERNAL_INFORMATION Internal,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - buffer to return file basic information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }

    //DbgPrint("   Query Internal  cache  : %wZ\n",OriginalFileName);

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    NameCacheCtl = &pNetRootEntry->NameCacheCtlGFAInternal;

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS) {

            // The name cache matches if it is not expired and the attributes matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Internal = *((PFILE_INTERNAL_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            //DbgPrint("   Found Internal  cache  : %I64x %wZ\n",Internal->IndexNumber,OriginalFileName);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
            //DbgPrint("Internal cache expired : %wZ\n",OriginalFileName);
        }
    } else {
        //DbgPrint("     No  Internal  cache  : %wZ\n",OriginalFileName);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);

    return CacheFound;
}

NTSTATUS
MRxSmbGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine looks for the status of the name cache entry of either file basic or standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - statu of the name cache if found, otherwise, STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtlBasic = &pNetRootEntry->NameCacheCtlGFABasic;
    PNAME_CACHE_CONTROL     NameCacheCtlStandard = &pNetRootEntry->NameCacheCtlGFAStandard;
    NTSTATUS                Status = STATUS_MORE_PROCESSING_REQUIRED;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtlBasic,OriginalFileName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired
        //
        NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS) {
            //
            // If the cache has not expired, return the previous status.
            //
            Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtlBasic);

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtlBasic, NameCache, 0, 0);

            //DbgPrint("    Get Basic Status   : %x %wZ\n",Status,OriginalFileName);
            RxLog(("    Get Basic Status   : %x %wZ\n",Status,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtlBasic, NameCache);
        }
    } else {
        NameCache = RxNameCacheFetchEntry(NameCacheCtlStandard,OriginalFileName);

        if (NameCache != NULL) {
            RX_NC_CHECK_STATUS NameCacheStatus;
            //
            // Found it.  Now check entry for not expired
            //
            NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

            if (NameCacheStatus == RX_NC_SUCCESS) {
                //
                // If the cache has not expired, return the previous status.
                //
                Status = NameCache->PriorStatus;
                RxNameCacheOpSaved(NameCacheCtlStandard);

                // put the entry back to the active list without changing the expire time
                RxNameCacheActivateEntry(NameCacheCtlStandard, NameCache, 0, 0);
            } else {
                // put the entry back to the expire list
                RxNameCacheExpireEntry(NameCacheCtlStandard, NameCache);
            }
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);

    return Status;
}

BOOLEAN
MRxSmbIsFileNotFoundCached(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine checks if the name cache entry exists as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          StreamlessName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlFNF;

    BOOLEAN                 CacheFound = FALSE;

    PAGED_CODE();

    // If a file does not exist, its stream doesn't either
    MRxSmbIsStreamFile( OriginalFileName, &StreamlessName );

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&StreamlessName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              //MRxSmbStatistics.SmbsReceived.LowPart
                              NameCache->Context);

        if ((NameCacheStatus == RX_NC_SUCCESS) &&
            (NameCache->PriorStatus == STATUS_OBJECT_NAME_NOT_FOUND)) {
            //
            // This is a match.  Return the old status, file info and
            // reactivate the entry but leave expiration time unchanged.
            //

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);

    return CacheFound;
}

VOID
MRxSmbCacheFileNotFound(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlFNF;

    PAGED_CODE();

    // Never cache stream file opens
    if( MRxSmbIsStreamFile( OriginalFileName, NULL ) )
    {
        return;
    }

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME,
            MRxSmbStatistics.SmbsReceived.LowPart);
    } else {
        if (FlagOn(NetRoot->Flags,NETROOT_FLAG_UNIQUE_FILE_NAME)) {
            NameCache = RxNameCacheCreateEntry (
                            NameCacheCtl,
                            OriginalFileName,
                            TRUE);   // case insensitive match

            if (NameCache != NULL) {
                NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                RxNameCacheActivateEntry(
                    NameCacheCtl,
                    NameCache,
                    1,
                    MRxSmbStatistics.SmbsReceived.LowPart);
            }
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbCacheFileNotFoundFromQueryDirectory(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PUNICODE_STRING         Template = &capFobx->UnicodeQueryTemplate;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

    if (NameCache != NULL) {
        if ((NameCache == NULL) &&
            (OriginalFileName->Length > sizeof(WCHAR))) {
            //
            // Do lookup now since we may have skipped it at entry.
            //
            NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);
            if (NameCache == NULL) {
                NameCache = RxNameCacheCreateEntry (
                                NameCacheCtl,
                                OriginalFileName,
                                TRUE);   // case insensitive match
            }
        }
        if (NameCache != NULL) {
            NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            RxNameCacheActivateEntry(
                NameCacheCtl,
                NameCache,
                NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME,
                MRxSmbStatistics.SmbsReceived.LowPart);
        }
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    UNICODE_STRING          StreamlessName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlFNF;

    PAGED_CODE();

    // If we invalidate a stream, this invalidates the associated file entry
    MRxSmbIsStreamFile( OriginalFileName, &StreamlessName );

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl, &StreamlessName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

VOID
MRxSmbInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    UNICODE_STRING          RenameName;
    UNICODE_STRING          StreamlessName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    PNAME_CACHE_CONTROL     NameCacheCtl = &pNetRootEntry->NameCacheCtlFNF;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    //DbgPrint("Invalidate FNF cache %wZ\n", &RenameName);

    PAGED_CODE();

    // If we rename a stream, invalidate the name without the stream
    MRxSmbIsStreamFile( &RenameName, &StreamlessName );

    ExAcquireFastMutex(&MRxSmbFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&StreamlessName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxSmbFileInfoCacheLock);
}

BOOLEAN
MRxSmbIsStreamFile(
    PUNICODE_STRING FileName,
    PUNICODE_STRING AdjustFileName
    )
/*++

Routine Description:

   This routine checks if it is a stream file and return the root file name if true.

Arguments:

    FileName - the file name needs to be parsed
    AdjustFileName - the file name contains only root name of the stream

Return Value:

    BOOLEAN - stream file

--*/
{
    USHORT   i;
    BOOLEAN  IsStream = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    for (i=0;i<FileName->Length/sizeof(WCHAR);i++) {
        if (FileName->Buffer[i] == L':') {
            IsStream = TRUE;
            break;
        }
    }

    if (AdjustFileName != NULL) {
        if (IsStream) {
            AdjustFileName->Length =
            AdjustFileName->MaximumLength = i * sizeof(WCHAR);
            AdjustFileName->Buffer = FileName->Buffer;
        } else {
            AdjustFileName->Length =
            AdjustFileName->MaximumLength = FileName->Length;
            AdjustFileName->Buffer = FileName->Buffer;
        }
    }

    return IsStream;
}

BOOLEAN EnableInfoCache = TRUE;

BOOLEAN
MRxSmbIsLongFileName(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine checks if it is a short file name and return the first part of short name if true.

Arguments:

    FileName - the file name needs to be parsed
    AdjustFileName - the file name contains only root name of the stream

Return Value:

    BOOLEAN - stream file

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB  smbFcb = MRxSmbGetFcbExtension(capFcb);
    BOOLEAN       IsLongName = FALSE;

    if (!EnableInfoCache) {
        return TRUE;
    }

    if (FlagOn(smbFcb->MFlags, SMB_FCB_FLAG_LONG_FILE_NAME)) {
        IsLongName = TRUE;
    } else {
        USHORT          i;
        USHORT          Left = 0;
        USHORT          Right = 0;
        OEM_STRING      OemString;
        BOOLEAN         RightPart = FALSE;
        WCHAR           LastChar = 0;
        WCHAR           CurrentChar = 0;
        PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
        PSMBCE_NET_ROOT pSmbNetRoot = NULL;


        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            pVNetRootContext = RxContext->Create.pVNetRoot->Context;
            pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;
        } else {
            ASSERT(capFobx != NULL);
            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)capFobx->pSrvOpen->pVNetRoot->Context;
            pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;
        }

        for (i=0;i<FileName->Length/sizeof(WCHAR);i++) {
            LastChar = CurrentChar;
            CurrentChar = FileName->Buffer[i];

            if (CurrentChar == L'\\') {
                RightPart = FALSE;
                Left = 0;
                Right = 0;
                continue;
            }

            if (CurrentChar == L'.') {
                if (RightPart) {
                    IsLongName = TRUE;
                    break;
                } else {
                    RightPart = TRUE;
                    Right = 0;
                    continue;
                }
            }

            if (CurrentChar >= L'0' && CurrentChar <= L'9' ||
                CurrentChar >= L'a' && CurrentChar <= L'z' ||
                CurrentChar >= L'A' && CurrentChar <= L'Z' ||
                CurrentChar == L'~' ||
                CurrentChar == L'_' ||
                CurrentChar == L'$' ||
                CurrentChar == L'@') {
                if (RightPart) {
                    if (++Right > 3) {
                        IsLongName = TRUE;
                        break;
                    }
                } else {
                    if (++Left > 8) {
                        IsLongName = TRUE;
                        break;
                    }
                }

                if (pSmbNetRoot->NetRootFileSystem != NET_ROOT_FILESYSTEM_NTFS) {
                    if (CurrentChar >= L'A' && CurrentChar <= L'Z' &&
                        LastChar >= L'a' && LastChar <= L'z' ||
                        CurrentChar >= L'a' && CurrentChar <= L'z' &&
                        LastChar >= L'A' && LastChar <= L'Z') {
                        // On FAT volume, name with mixture of cases will be treated as long name
                        IsLongName = TRUE;
                        break;
                    }
                }
            } else {
                // if not, an alternate name may be created by the server which will
                // be different from this name.
                IsLongName = TRUE;
                break;
            }
        }
    }

    if (IsLongName) {
        SetFlag(smbFcb->MFlags, SMB_FCB_FLAG_LONG_FILE_NAME);
    }

    return IsLongName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\kerbxchg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kerbxchg.c

Abstract:

    This module implements the routines for setting up a kerberos session.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <kerbxchg.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbKerberosSessionSetupExchangeStart)
#pragma alloc_text(PAGE, ParseKerberosSessionSetupResponse)
#pragma alloc_text(PAGE, SmbKerberosSessionSetupExchangeReceive)
#pragma alloc_text(PAGE, SmbKerberosSessionSetupExchangeSendCompletionHandler)
#pragma alloc_text(PAGE, SmbKerberosSessionSetupExchangeCopyDataHandler)
#pragma alloc_text(PAGE, SmbKerberosSessionSetupExchangeFinalize)
#endif
//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

//
// Forward declarations ...
//

#define KERBEROS_SESSION_SETUP_BUFFER_SIZE (4096)

NTSTATUS
SmbKerberosSessionSetupExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize);


NTSTATUS
SmbKerberosSessionSetupExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;

   PSMB_KERBEROS_SESSION_SETUP_EXCHANGE pKerberosExchange;

   PAGED_CODE();

   pKerberosExchange = (PSMB_KERBEROS_SESSION_SETUP_EXCHANGE)pExchange;

   ASSERT(pKerberosExchange->Type == KERBEROS_SESSION_SETUP_EXCHANGE);

   pKerberosExchange->BufferLength = KERBEROS_SESSION_SETUP_BUFFER_SIZE;
   pKerberosExchange->pBuffer = RxAllocatePoolWithTag(
                                    PagedPool,
                                    pKerberosExchange->BufferLength,
                                    MRXSMB_KERBEROS_POOLTAG);
   pKerberosExchange->pServerResponseBlob = NULL;
   pKerberosExchange->ServerResponseBlobLength = 0;

   if (pKerberosExchange->pBuffer == NULL) {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   } else {
      PSMB_HEADER pSmbHeader = (PSMB_HEADER)(pKerberosExchange->pBuffer);

      PREQ_NT_SESSION_SETUP_ANDX pSessionSetupRequest;
      PGENERIC_ANDX              pGenericAndX;

      ULONG       SmbBufferUnconsumed;
      USHORT      Flags2 = 0;

      // Fill in the buffer header
      pSessionSetupRequest = (PREQ_NT_SESSION_SETUP_ANDX)(pSmbHeader + 1);
      pGenericAndX         = (PGENERIC_ANDX)pSessionSetupRequest;

      SmbBufferUnconsumed = pKerberosExchange->BufferLength - sizeof(SMB_HEADER);

      ASSERT(pExchange->SmbCeContext.pServerEntry->Server.Dialect == CAIROX_DIALECT);

      Flags2 |= (SMB_FLAGS2_UNICODE |
                 SMB_FLAGS2_KNOWS_EAS |
                 SMB_FLAGS2_KNOWS_LONG_NAMES |
                 SMB_FLAGS2_NT_STATUS);

      *((PULONG)&pSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
      pSmbHeader->Flags      = (SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS);
      pSmbHeader->Flags2     = Flags2;
      pSmbHeader->Pid        = MRXSMB_PROCESS_ID;
      pSmbHeader->Uid        = 0;
      pSmbHeader->Tid        = 0;
      pSmbHeader->ErrorClass = 0;
      pSmbHeader->Reserved   = 0;
      pSmbHeader->Command    = SMB_COM_SESSION_SETUP_ANDX;
      SmbPutUshort(&pSmbHeader->Error,0);

      // Build the session setup and x.
      Status = SMBCE_SERVER_DIALECT_DISPATCH(
                        &pExchange->SmbCeContext.pServerEntry->Server,
                        BuildSessionSetup,
                        (pExchange,
                         pGenericAndX,
                         &SmbBufferUnconsumed));

      if (Status == RX_MAP_STATUS(SUCCESS)) {
         // Update the buffer for the construction of the following SMB.
         SmbPutUshort(&pSessionSetupRequest->AndXOffset,
                      (USHORT)(pKerberosExchange->BufferLength - SmbBufferUnconsumed));
         pSessionSetupRequest->AndXCommand  = SMB_COM_NO_ANDX_COMMAND;
         pSessionSetupRequest->AndXReserved = 0;
      } else {
         if (Status == RX_MAP_STATUS(NO_LOGON_SERVERS)) {
            // If no kerberos logon servers are available downgrade to a downlevel
            // connection and retry.
            pKerberosExchange->SmbCeContext.pServerEntry->Server.Dialect = NTLANMAN_DIALECT;
         }

         SmbCeReferenceSessionEntry(pKerberosExchange->SmbCeContext.pSessionEntry);
         SmbCeUpdateSessionEntryState(
               pExchange->SmbCeContext.pSessionEntry,
               SMBCEDB_INVALID);
         SmbCeCompleteSessionEntryInitialization(pExchange->SmbCeContext.pSessionEntry);
         pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
      }

      if (Status == RX_MAP_STATUS(SUCCESS)) {
         pKerberosExchange->pBufferAsMdl = RxAllocateMdl(
                                                pKerberosExchange->pBuffer,
                                                KERBEROS_SESSION_SETUP_BUFFER_SIZE);
         if (pKerberosExchange->pBufferAsMdl != NULL) {
            RxProbeAndLockPages(
                     pKerberosExchange->pBufferAsMdl,
                     KernelMode,
                     IoModifyAccess,
                     Status);

            if (NT_SUCCESS(Status)) {
               Status = SmbCeTranceive(
                              pExchange,
                              (RXCE_SEND_PARTIAL | RXCE_SEND_SYNCHRONOUS),
                              pKerberosExchange->pBufferAsMdl,
                              (pKerberosExchange->BufferLength -
                               SmbBufferUnconsumed));

               RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
            }
         }
      }
   }

   return Status;
}

NTSTATUS
ParseKerberosSessionSetupResponse(
    IN PSMB_KERBEROS_SESSION_SETUP_EXCHANGE pKerberosExchange,
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    IN  PSMB_HEADER pSmbHeader)
{
   NTSTATUS Status;
   ULONG    ResponseLength;

   PAGED_CODE();

   // The SMB exchange completed without an error.
   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated %ld\n",BytesIndicated));
   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated %ld\n",BytesIndicated));
   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesAvailable %ld\n",BytesAvailable));

   // The bytes indicated should be atleast cover the SMB_HEADER and the
   // session setup response ( fixed portion )
   ResponseLength = sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer);
   if (BytesIndicated > ResponseLength) {
      PRESP_SESSION_SETUP_ANDX pSessionSetupResponse;

      pSessionSetupResponse = (PRESP_SESSION_SETUP_ANDX)(pSmbHeader + 1);

      pKerberosExchange->ResponseLength = ResponseLength +
                                          SmbGetUshort(&pSessionSetupResponse->ByteCount);

      pKerberosExchange->SmbCeContext.pSessionEntry->Session.UserId = pSmbHeader->Uid;

      RxDbgTrace(0,Dbg,("Kerberos session setup response length %ld\n",pKerberosExchange->ResponseLength));

      if (BytesIndicated < pKerberosExchange->ResponseLength) {
         // Set up the response for copying the data.
         if (pKerberosExchange->ResponseLength > pKerberosExchange->BufferLength) {
            Status = STATUS_BUFFER_OVERFLOW;
         } else {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
         }
      } else {
         // The regular session setup response consists of three strings corresponding
         // to the server's operating system type, lanman type and the domain name.
         // Skip past the three strings to locate the kerberos blob that has been
         // returned which needs to be autheticated locally.

         // ***** NOTE ******
         // Currently the server changes made by Arnold do not support the three
         // strings that were previously returned by the Server, viz., the operating
         // system name, the LANMAN version and the domain name. If the server is
         // changed in this regard the corresponding change neeeds to be made here.

         // set up the offsets in the response.
         pKerberosExchange->ServerResponseBlobOffset = sizeof(SMB_HEADER) +
                                                       FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer);
         pKerberosExchange->ServerResponseBlobLength = pSessionSetupResponse->ByteCount;

         // Copy the response onto the buffer associated with the exchange.
         RtlCopyMemory(pKerberosExchange->pBuffer,
                       pSmbHeader,
                       pKerberosExchange->ResponseLength);

         Status = STATUS_SUCCESS;
      }
   } else {
      // Abort the exchange. No further processing can be done.
      Status = STATUS_INVALID_NETWORK_RESPONSE;
   }

   return Status;
}

NTSTATUS
SmbKerberosSessionSetupExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG             pDataSize)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
   NTSTATUS Status;

   PSMB_KERBEROS_SESSION_SETUP_EXCHANGE pKerberosExchange;

   ULONG    SessionSetupResponseLength = 0;

   PAGED_CODE();

   pKerberosExchange = (PSMB_KERBEROS_SESSION_SETUP_EXCHANGE)pExchange;

   // Parse the response. Finalize the exchange instance if all the data is available
   Status = ParseKerberosSessionSetupResponse(
                     pKerberosExchange,
                     BytesIndicated,
                     BytesAvailable,
                     pSmbHeader);

   if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
      *pBytesTaken = BytesAvailable;
      Status = STATUS_SUCCESS;
   } else {
      *pBytesTaken        = 0;
      *pDataBufferPointer = pKerberosExchange->pBufferAsMdl;
      *pDataSize          = pKerberosExchange->ResponseLength;
   }

   return Status;
}

NTSTATUS
SmbKerberosSessionSetupExchangeSendCompletionHandler(
    IN PSMB_EXCHANGE 	pExchange,    // The exchange instance
    IN PMDL       pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
SmbKerberosSessionSetupExchangeCopyDataHandler(
    IN PSMB_EXCHANGE 	pExchange,    // The exchange instance
    IN PMDL             pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   PSMB_KERBEROS_SESSION_SETUP_EXCHANGE pKerberosExchange;
   PSMB_HEADER                      pSmbHeader;

   PAGED_CODE();

   pKerberosExchange = (PSMB_KERBEROS_SESSION_SETUP_EXCHANGE)pExchange;
   pSmbHeader        = (PSMB_HEADER)pCopyDataBuffer;

   pKerberosExchange->Status = ParseKerberosSessionSetupResponse(
                                       pKerberosExchange,
                                       DataSize,
                                       DataSize,
                                       pSmbHeader);

   return STATUS_SUCCESS;
}

NTSTATUS
SmbKerberosSessionSetupExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalkzes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;

   PSMB_KERBEROS_SESSION_SETUP_EXCHANGE pKerberosExchange;
   PSMBCE_RESUMPTION_CONTEXT            pResumptionContext;


   PAGED_CODE();

   if (RxShouldPostCompletion()) {
      *pPostFinalize = TRUE;
      return RX_MAP_STATUS(SUCCESS);
   } else {
      *pPostFinalize = FALSE;
   }

   pKerberosExchange = (PSMB_KERBEROS_SESSION_SETUP_EXCHANGE)pExchange;

   // A copying operation on the server response BLOB is avoided by temporarily
   // setting up the exchange pointer to the original buffer in which the response
   // was received and initiating a allocation only if required.
   pKerberosExchange->pServerResponseBlob =
                              ((PBYTE)pKerberosExchange->pBuffer +
                               pKerberosExchange->ServerResponseBlobOffset);

   // Determine if further processing is required. If not finalize the
   // session entry.
   RxDbgTrace(0,Dbg,
              ("SmbKerberosSessionSetupExchangeFinalize: pKerberosExchange->Status = %lx\n",pKerberosExchange->Status));

   if (pKerberosExchange->Status == RX_MAP_STATUS(SUCCESS)) {
      Status = KerberosValidateServerResponse(pKerberosExchange);
   }

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
      pKerberosExchange->pServerResponseBlob = RxAllocatePoolWithTag(
                                                   PagedPool,
                                                   pKerberosExchange->ServerResponseBlobLength,
                                                   MRXSMB_KERBEROS_POOLTAG);

      if (pKerberosExchange->pServerResponseBlob != NULL) {
         RtlCopyMemory(
               pKerberosExchange->pServerResponseBlob,
               ((PBYTE)pKerberosExchange->pBuffer +
                pKerberosExchange->ServerResponseBlobOffset),
               pKerberosExchange->ServerResponseBlobLength);
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   } else {
      pKerberosExchange->pServerResponseBlob = NULL;
   }

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
      Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pKerberosExchange);
   } else {
      // Reset the constructor flags in the exchange.
      pKerberosExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;

      if (pKerberosExchange->pServerResponseBlob != NULL) {
         RxFreePool(pKerberosExchange->pServerResponseBlob);
      }

      RxDbgTrace(0,Dbg,("Kerberos Exchange Session Final Status(%lx)\n",Status));

      // Finalize the session based upon the status
      if (Status == STATUS_SUCCESS) {
         SmbCeUpdateSessionEntryState(
               pKerberosExchange->SmbCeContext.pSessionEntry,
               SMBCEDB_ACTIVE);
      } else {
         if (Status == RX_MAP_STATUS(NO_LOGON_SERVERS)) {
            // If no kerberos logon servers are available downgrade to a downlevel
            // connection and retry.
            pKerberosExchange->SmbCeContext.pServerEntry->Server.Dialect = NTLANMAN_DIALECT;
         }

         SmbCeUpdateSessionEntryState(
               pKerberosExchange->SmbCeContext.pSessionEntry,
               SMBCEDB_INVALID);
      }

      // Complete the session construction.

      SmbCeReferenceSessionEntry(pKerberosExchange->SmbCeContext.pSessionEntry);
      SmbCeCompleteSessionEntryInitialization(pKerberosExchange->SmbCeContext.pSessionEntry);
      pKerberosExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;

      pResumptionContext = pKerberosExchange->pResumptionContext;

      // Tear down the exchange instance ...
      SmbCeDiscardExchange(pKerberosExchange);

      if (pResumptionContext != NULL) {
         pResumptionContext->Status = Status;
         SmbCeResume(pResumptionContext);
      }
   }

   return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
KerberosSessionSetupExchangeDispatch =
                                   {
                                       SmbKerberosSessionSetupExchangeStart,
                                       SmbKerberosSessionSetupExchangeReceive,
                                       SmbKerberosSessionSetupExchangeCopyDataHandler,
                                       NULL,
                                       SmbKerberosSessionSetupExchangeFinalize
                                   };


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\kerbxchg.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

Author:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

--*/

#ifndef _KERBXCHG_H_
#define _KERBXCHG_H_


#include <smbxchng.h>

#include "security.h"

#define IsCredentialHandleValid(pCredHandle)    \
        (((pCredHandle)->dwLower != 0xffffffff) && ((pCredHandle)->dwUpper != 0xffffffff))

#define IsSecurityContextHandleValid(pContextHandle)    \
        (((pContextHandle)->dwLower != 0xffffffff) && ((pContextHandle)->dwUpper != 0xffffffff))

typedef struct _SMBCE_KERBEROS_SESSION_ {
   SMBCE_SESSION;

   PCHAR        pServerResponseBlob;
   ULONG        ServerResponseBlobLength;

} SMBCE_KERBEROS_SESSION, *PSMBCE_KERBEROS_SESSION;

typedef struct _SMB_KERBEROS_SESSION_SETUP_EXCHANGE {
   SMB_EXCHANGE;
   PVOID    pBuffer;
   PMDL     pBufferAsMdl;
   ULONG    BufferLength;

   ULONG    ResponseLength;

   PVOID    pServerResponseBlob;
   ULONG    ServerResponseBlobOffset;
   ULONG    ServerResponseBlobLength;

   PSMBCE_RESUMPTION_CONTEXT pResumptionContext;
} SMB_KERBEROS_SESSION_SETUP_EXCHANGE, *PSMB_KERBEROS_SESSION_SETUP_EXCHANGE;


#ifdef _CAIRO_
extern NTSTATUS
KerberosValidateServerResponse(PSMB_KERBEROS_SESSION_SETUP_EXCHANGE   pExchange);
#else
#define KerberosValidateServerResponse(pExchange) (STATUS_NOT_IMPLEMENTED)
#endif

extern SMB_EXCHANGE_DISPATCH_VECTOR
KerberosSessionSetupExchangeDispatch;

#endif // _KERBXCHG_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\manipmdl.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    transact.c

Abstract:

    This file implements the MDL substring functions and tests.

Author:


--*/

#include "precomp.h"
#pragma hdrstop

#include "align.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbDbgDumpMdlChain)
#pragma alloc_text(PAGE, MRxSmbBuildMdlSubChain)
#pragma alloc_text(PAGE, MRxSmbFinalizeMdlSubChain)
#pragma alloc_text(PAGE, MRxSmbTestStudCode)
#endif

//RXDT_DefineCategory(TRANSACT);
extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_TRANSACT;
#define Dbg        (DEBUG_TRACE_TRANSACT)


#if DBG
VOID
MRxSmbDbgDumpMdlChain (
    PMDL MdlChain,
    PMDL WatchMdl,
    PSZ  Tagstring
    )
/*++

dumps chain with counts and buffers....watches for the watchmdl and prints the next field
if it is encountered.
--*/
{
    ULONG i,total;
    PSZ watchstring;

    PAGED_CODE();

    RxDbgTrace(+1,Dbg,("DbgDumpMdlChain: %s\n",Tagstring));
    for (total=i=0;MdlChain!=NULL;i++,MdlChain=MdlChain->Next) {
        if (MdlChain==WatchMdl) {
            if (MdlChain->Next==NULL) {
                watchstring = "gooddwatch";
            } else {
                watchstring = "badwatch";
            }
        } else {
            watchstring = "";
        }
        total+=MdlChain->ByteCount;
        RxDbgTrace(0,Dbg,("--->%02d %08lx %08lx %6d %6d %s\n",i,MdlChain,
               MmGetMdlVirtualAddress(MdlChain),MdlChain->ByteCount,total,watchstring));
    }
    RxDbgTraceUnIndent(-1,Dbg);

}
#endif

NTSTATUS
MRxSmbBuildMdlSubChain (
    PMDLSUB_CHAIN_STATE state,
    ULONG               Options,
    PMDL                InputMdlChain,
    ULONG               TotalListSize,
    ULONG               FirstByteToSend,
    ULONG               BytesToSend
    )
/*++

Routine Description:

    This routine returns an mdl chain that describes the bytes from
         [FirstByteToSend,FirstByteToSend+BytesToSend-1]
    (origin zero) from the "string of bytes" described by the InputMdlChain

    we do this by the following steps:

    a) find the subsequence of MDLs that contain the substring
    b) if either the first or the last is not used completely then build a partial
       to describe it (taking cognizance of the special case where first=last)
    c) save the ->Next field of the last; set it to zero. also, find out how many
       extra bytes are available on the MDL (i.e. how many bytes are on the same page
       as the last described byte but are not described.

    there are the following cases:

    1) a suffix chain of the original chain describes the message
    2) the message fits within a single original mdl (and not case 1 or 2b); return a partial
    2b) the message is exactly one block! no partial but muck the chain.
    3) a suffix chain can be formed by partialing the first containing MDL
    4) the msg ends exactly on a MDL boundary...front may or may not be partialed
    5) the msg ends in a partial but not case (2)

    (2b), (4), and (5) cause a chain fixup...but (5) is not the same chain fixup.
    (3) causes a partial; (5) causes one or two partials.

Arguments:

    as described in the text above. plus

    FirstTime - indicates if the structure should be cleared initially

Return Value:

    RXSTATUS - The return status for the operation.
       SUCCESS - if no allocation problems
       INSUFFICIENT_RESOURCES - if couldn't allocate a partial

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    ULONG PrefixBytes = 0;
    ULONG FirstByteNotToSend;
    PMDL  BeforeTheLastMdl,LastMdl;
    ULONG RemainingListSize = TotalListSize;
    PMDL OriginalFirstMdl = InputMdlChain;
    PMDL PreviousMdl = NULL;
    ULONG ThisCount,Offset,AvailableBytesThisRecord;
#if DBG
    ULONG WhichCase = 0;
#endif

    PAGED_CODE();

    RxDbgTrace(+1,Dbg,("MRxSmbBuildMdlSubChain: tot,1st,size %d,%d,%d \n",
                    TotalListSize,FirstByteToSend,BytesToSend
    ));
    ASSERT (BytesToSend>0);
    ASSERT (TotalListSize>FirstByteToSend);
    ASSERT (TotalListSize>=FirstByteToSend+BytesToSend);
    if (FlagOn(Options,SMBMRX_BUILDSUBCHAIN_DUMPCHAININ)) {
        MRxSmbDbgDumpMdlChain(InputMdlChain,NULL,"Input Chain......");
    }

    if (FlagOn(Options,SMBMRX_BUILDSUBCHAIN_FIRSTTIME)) {
        RtlZeroMemory(state,sizeof(*state));
    }

    //CODE.IMPROVEMENT we could make this go much faster if we would cache how far
    //                 we got in the list last time
    BeforeTheLastMdl = NULL;
    for (;;) {
        ThisCount = OriginalFirstMdl->ByteCount;
        if ( (ThisCount+PrefixBytes) > FirstByteToSend) break;
        RemainingListSize -= ThisCount;
        PrefixBytes += ThisCount;
        RxDbgTrace(0,Dbg,("-->pfxsize %d \n", PrefixBytes));
        OriginalFirstMdl = OriginalFirstMdl->Next;
    }

    //case (1) the rest of the list describes this string perfectly. so
    //         don't allocate anything and just get out. we still have to
    //         run the list to find the last pointer
    if (RemainingListSize == BytesToSend) {
        PMDL last;
        RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(1) \n"));
        last = state->FirstMdlOut = OriginalFirstMdl;
        for (;last->Next!=NULL;last=last->Next);
        state->LastMdlOut = last;
        DebugDoit(WhichCase = 1);
        goto FINALLY;
    } else {
        RxDbgTrace(0,Dbg,("-->NOT CASE 1, pfxsize %d \n", PrefixBytes));
        RemainingListSize -= ThisCount;
    }

    //either we need to partial this mdl  OR we have to hack the list end OR both
    Offset = FirstByteToSend - PrefixBytes;
    AvailableBytesThisRecord = ThisCount-Offset;
    if ( (Offset != 0) || (BytesToSend<AvailableBytesThisRecord) ) {
        //we need a partial....sigh
        state->FirstMdlOut = RxAllocateMdl(0,ThisCount);
        if (state->FirstMdlOut==NULL) {
            Status = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
            goto FINALLY;
        }
        state->FirstMdlWasAllocated = TRUE;
        RxBuildPartialMdlUsingOffset(OriginalFirstMdl,state->FirstMdlOut,Offset,min(BytesToSend,AvailableBytesThisRecord));
        if (BytesToSend<=AvailableBytesThisRecord) {
            RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(2) \n"));
            //case (2) this block completely contains the substring...cool.
            state->LastMdlOut = state->FirstMdlOut;
            state->FirstMdlOut->Next = NULL;
            DebugDoit(WhichCase = 2);
            goto FINALLY;
        }
        state->FirstMdlOut->Next = OriginalFirstMdl->Next;  //fix up the chain
        //case(3) the rest of the list could be perfect! still gotta run the list tho.....
        //moved up RemainingListSize -= ThisCount;
        if ( RemainingListSize == BytesToSend-AvailableBytesThisRecord) {
            PMDL last;
            RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(3) \n"));
            last = state->FirstMdlOut;
            for (;last->Next!=NULL;last=last->Next);
            state->LastMdlOut = last;
            DebugDoit(WhichCase = 3);
            goto FINALLY;
        }
    } else {
        RxDbgTrace(0,Dbg,("-->NO NEED FOR FIRST PARTIAL\n"));
        state->FirstMdlOut = OriginalFirstMdl;
        if ((Offset==0)&&(BytesToSend==AvailableBytesThisRecord)) {
            RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(2b) ...sigh\n"));
            //case (2b) this block matches the substring...no partial but muck with the next pointer.
            state->LastMdlOut = state->FirstMdlOut;
            state->ActualLastMdl = OriginalFirstMdl;
            state->ActualLastMdl_Next = OriginalFirstMdl->Next;
            state->FirstMdlOut->Next = NULL;
            DebugDoit(WhichCase = 2);
            goto FINALLY;
        }
    }

    //we don't know yet whether we have to partial the last...but we know that we'll have
    //to do a chain fixup/
    FirstByteNotToSend = FirstByteToSend + BytesToSend;
    BeforeTheLastMdl = state->FirstMdlOut;
    PrefixBytes+=ThisCount; //we're actully passing the current record
    for (;;) {
        LastMdl = BeforeTheLastMdl->Next;
        ASSERT(LastMdl);
        ThisCount = LastMdl->ByteCount;
        RxDbgTrace(0,Dbg,("-->(loop2)pfx,rem,count,1st %d,%d,%d,%d \n",
                              PrefixBytes,RemainingListSize,ThisCount,FirstByteNotToSend));
        if ( (ThisCount+PrefixBytes) == FirstByteNotToSend ) {
            ///case (4): no partial at the end..just fix up the last link
            RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(4) \n"));
            state->LastMdlOut = LastMdl;
            state->ActualLastMdl = LastMdl;
            state->ActualLastMdl_Next = LastMdl->Next;
            state->LastMdlOut->Next = NULL;
            DebugDoit(WhichCase = 4);
            goto FINALLY;
        }
        if ( (ThisCount+PrefixBytes) > FirstByteNotToSend) break;
        RemainingListSize -= ThisCount;
        ASSERT(RemainingListSize>0);
        PrefixBytes += ThisCount;
        BeforeTheLastMdl = BeforeTheLastMdl->Next;
    }

    //case (5): [THE LAST CASE!!!!] we have to partial the last guy so the chain fixup
    //           is different
    RxDbgTrace(0,Dbg,("MRxSmbBuildMdlSubChain:(5) \n"));
    state->LastMdlOut = RxAllocateMdl(0,ThisCount);
    if (state->LastMdlOut==NULL) {
        Status = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
        goto FINALLY;
    }
    state->LastMdlWasAllocated = TRUE;
    RxBuildPartialMdlUsingOffset(LastMdl,state->LastMdlOut,0,FirstByteNotToSend-PrefixBytes);
    state->OneBeforeActualLastMdl = BeforeTheLastMdl;
    state->ActualLastMdl = LastMdl;
    state->ActualLastMdl_Next = LastMdl->Next;
    BeforeTheLastMdl->Next = state->LastMdlOut;
    state->LastMdlOut->Next = NULL;
    DebugDoit(WhichCase = 5);


FINALLY:
    if (Status==RX_MAP_STATUS(SUCCESS)) {
        ASSERT(state->LastMdlOut->Next == NULL);
        if (FlagOn(Options,SMBMRX_BUILDSUBCHAIN_DUMPCHAININ)) {
            MRxSmbDbgDumpMdlChain(state->FirstMdlOut,state->LastMdlOut,"AND THE RESULT ------------");
        }
    } else {
        MRxSmbFinalizeMdlSubChain(state);
    }
    RxDbgTrace(-1,Dbg,("MRxSmbBuildMdlSubChain:case(%u) status %08lx \n",WhichCase,Status));
    return(Status);
}

VOID
MRxSmbFinalizeMdlSubChain (
    PMDLSUB_CHAIN_STATE state
    )
/*++

Routine Description:

    This routine finalizes a MDL chain by putting it back as it was.


Arguments:

    state - a structure describing the mdl-subchain and what the original looked like

Return Value:


Notes:


--*/
{
    PAGED_CODE();

    ASSERT(state->PadBytesAvailable==0);
    ASSERT(state->PadBytesAdded==0);

    //first restore the chain
    if (state->OneBeforeActualLastMdl) {
        state->OneBeforeActualLastMdl->Next = state->ActualLastMdl;
    }
    if (state->ActualLastMdl) {
        state->ActualLastMdl->Next = state->ActualLastMdl_Next;
    }

    //restore the count on the last mdl
    state->LastMdlOut -= state->PadBytesAdded;

    //get rid of the MDLs
    if (state->FirstMdlWasAllocated) {
        IoFreeMdl(state->FirstMdlOut);
    }
    if (state->LastMdlWasAllocated) {
        IoFreeMdl(state->LastMdlOut);
    }

}

#if DBG
LONG MRxSmbNeedSCTesting = 1;
VOID MRxSmbTestStudCode(void)
{
    PMDL Md11,Mdl2,Mdl4,Mdlx;
    PMDL ch;
    ULONG i,j;
    ULONG LastSize=1;
    ULONG TotalSize = LastSize+7;
    UCHAR dbgmssg[16],savedmsg[16];
    UCHAR reconstructedmsg[16];
    MDLSUB_CHAIN_STATE state;

    PAGED_CODE();

    ASSERT (TotalSize<=16);
    if (InterlockedExchange(&MRxSmbNeedSCTesting,0)==0) {
        return;
    }

    Mdl4 = RxAllocateMdl(dbgmssg+0,4);
    Mdl2 = RxAllocateMdl(dbgmssg+4,2);
    Md11 = RxAllocateMdl(dbgmssg+6,1);
    Mdlx = RxAllocateMdl(dbgmssg+7,LastSize);
    if ((Mdl4==NULL)||(Mdl2==NULL)||(Md11==NULL)||(Mdlx==NULL)) {
        DbgPrint("NoMDLS in teststudcode.......\n");
        //DbgBreakPoint();
        goto FINALLY;
    }
    MmBuildMdlForNonPagedPool(Md11);
    MmBuildMdlForNonPagedPool(Mdl2);
    MmBuildMdlForNonPagedPool(Mdl4);
    MmBuildMdlForNonPagedPool(Mdlx);
    Mdl4->Next = Mdl2;
    Mdl2->Next = Md11;
    Md11->Next = Mdlx;
    Mdlx->Next = NULL;

    for (i=0;i<10;i++) { dbgmssg[i] = '0'+(UCHAR)i; }
    for (j=0;i<16;i++,j++) { dbgmssg[i] = 'a'+(UCHAR)j; }
    RxDbgTrace(0,Dbg,("TestStudCode dbgmssg=%*.*s\n",16,16,dbgmssg));
    for (j=0;j<16;j++) { savedmsg[j] = dbgmssg[j]; }

    for (i=0;i<TotalSize;i++) {
//    for (i=1;i<TotalSize;i++) {
        for (j=i;j<TotalSize;j++) {
            ULONG size = j-i+1;
            ULONG k;BOOLEAN printflag;
            //RxDbgTrace(0,Dbg,("TestStudCode %d %d %*.*s\n",i,size,size,size,dbgmssg+i));
            printflag = RxDbgTraceDisableGlobally();//this is debug code anyway!
            MRxSmbBuildMdlSubChain(&state,SMBMRX_BUILDSUBCHAIN_FIRSTTIME,Mdl4,TotalSize,i,size);
            RxDbgTraceEnableGlobally(printflag);
            for (k=0,ch=state.FirstMdlOut;ch!=NULL;ch=ch->Next) {
                RtlCopyMemory(reconstructedmsg+k,MmGetMdlVirtualAddress(ch),ch->ByteCount);
                k+= ch->ByteCount;
            }
            if ((k!=size) || (memcmp(dbgmssg+i,reconstructedmsg,k)!=0) ) {
                RxDbgTrace(0,Dbg,("TestStudCode %d %d %*.*s\n",i,size,size,size,dbgmssg+i));
                RxDbgTrace(0,Dbg,("TestStudCode recmssg=%*.*s\n",k,k,reconstructedmsg));
            }
            MRxSmbFinalizeMdlSubChain(&state);
            for (k=0,ch=Mdl4;ch!=NULL;ch=ch->Next) {
                RtlCopyMemory(reconstructedmsg+k,MmGetMdlVirtualAddress(ch),ch->ByteCount);
                k+= ch->ByteCount;
            }
            if ((k!=TotalSize) || (memcmp(dbgmssg,reconstructedmsg,k)!=0) ) {
                RxDbgTrace(0,Dbg,("TestStudCodxxxe %d %d %*.*s\n",i,size,size,size,dbgmssg+i));
                RxDbgTrace(0,Dbg,("TestStudCode xxxrecmssg=%*.*s\n",k,k,reconstructedmsg));
            }
            //ASSERT(!"okay to go???");
        }
    }
FINALLY:
    if (Mdl4) IoFreeMdl(Mdl4);
    if (Mdl2) IoFreeMdl(Mdl2);
    if (Md11) IoFreeMdl(Md11);
    if (Mdlx) IoFreeMdl(Mdlx);
    RxDbgTrace(0,Dbg,("TestStudCodeEND \n"));
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\locks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

Author:

    Joe Linn     [JoeLi]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbLocks)
#pragma alloc_text(PAGE, MRxSmbBuildLocksAndX)
#pragma alloc_text(PAGE, MRxSmbBuildLockAssert)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Locks)
#pragma alloc_text(PAGE, MRxSmbFinishLocks)
#pragma alloc_text(PAGE, MRxSmbUnlockRoutine)
#pragma alloc_text(PAGE, MRxSmbCompleteBufferingStateChangeRequest)
#pragma alloc_text(PAGE, MRxSmbBuildFlush)
#pragma alloc_text(PAGE, MRxSmbFlush)
#pragma alloc_text(PAGE, MRxSmbIsLockRealizable)
#pragma alloc_text(PAGE, MRxSmbFinishFlush)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbSrvLockBufSize = 0xffff;
ULONG MRxSmbLockSendOptions = 0;     //use the default options

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbLocks(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLocks\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_LOCKS,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);


    if (Status!=RX_MAP_STATUS(PENDING)) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLocks  exit with status=%08lx\n", Status ));
    return(Status);

}

NTSTATUS
MRxSmbBuildLocksAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for a single unlock or a single lock.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    RxCaptureFcb;RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLARGE_INTEGER ByteOffsetAsLI,LengthAsLI;
    USHORT NumberOfLocks,NumberOfUnlocks;
    BOOLEAN UseLockList = FALSE;
    //ULONG OffsetLow,OffsetHigh;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLocksAndX\n"));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
        NumberOfLocks = 1; NumberOfUnlocks = 0;
        break;
    case LOWIO_OP_UNLOCK:
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        break;
    case LOWIO_OP_UNLOCK_MULTIPLE:
        //CODE.IMPROVEMENT these should be sent in groups....not one at a time!
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        UseLockList = TRUE;
        break;
    }

    if (!UseLockList) {
        ByteOffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
    } else {
        //it's okay that this code is big.....see the C.I. above
        PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
        PLOWIO_LOCK_LIST LockList = rw->LockList;
        ByteOffsetAsLI = (PLARGE_INTEGER)&LockList->ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LockList->Length;
        RxDbgTrace(0, Dbg, ("MRxSmbBuildLocksAndX using locklist, byteoffptr,lengthptr=%08lx,%08lx\n",
                                               ByteOffsetAsLI, LengthAsLI ));
        //DbgBreakPoint();
    }

    if (FlagOn(pServer->DialectFlags,DF_LANMAN20)) {
        ULONG SharedLock = (LowIoContext->Operation==LOWIO_OP_SHAREDLOCK);
        ULONG Timeout = (LowIoContext->ParamsFor.Locks.Flags&LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY)?0:0xffffffff;
        ULONG UseLargeOffsets = LOCKING_ANDX_LARGE_FILES;

        if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
            UseLargeOffsets = 0;
        }

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                SMB_REQUEST_SIZE(LOCKING_ANDX),
                                NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1000,"SMB w/ NTLOCKS&X before stuffing",StufferState);


        MRxSmbStuffSMB (StufferState,
             "XwwDwwB?",
                                        //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                        //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                        //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                        //            _USHORT( AndXOffset );              // Offset to next command WordCount
                  smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                        //
                                        //            //
                                        //            // When NT protocol is not negotiated the OplockLevel field is
                                        //            // omitted, and LockType field is a full word.  Since the upper
                                        //            // bits of LockType are never used, this definition works for
                                        //            // all protocols.
                                        //            //
                                        //
                  SharedLock            //  w         UCHAR( LockType );                  // Locking mode:
                      +UseLargeOffsets,
                                        //                                                //  bit 0: 0 = lock out all access
                                        //                                                //         1 = read OK while locked
                                        //                                                //  bit 1: 1 = 1 user total file unlock
                                        //            UCHAR( OplockLevel );               // The new oplock level
                  SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                  Timeout,              //  D         _ULONG( Timeout );
                  NumberOfUnlocks,      //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                  NumberOfLocks,        //  w         _USHORT( NumberOfLocks );           // Num. lock range structs following
                  SMB_WCT_CHECK(8) 0
                                        //  B?         _USHORT( ByteCount );               // Count of data bytes
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                                        //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                        //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                 );


         if (UseLargeOffsets) {
            //NTversion
            //CODE.IMPROVEMENT put in some kind of facility to do an offset check here
            MRxSmbStuffSMB (StufferState,
                 "wwdddd!",
                                               //        typedef struct _NT_LOCKING_ANDX_RANGE {
                      MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                      0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                      ByteOffsetAsLI->HighPart,//  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                      ByteOffsetAsLI->LowPart, //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                      LengthAsLI->HighPart,    //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                      LengthAsLI->LowPart      //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                                               //        } NTLOCKING_ANDX_RANGE;
                     );
         } else {
            MRxSmbStuffSMB (StufferState,
                 "wdd!",
                     MRXSMB_PROCESS_ID     ,   //         typedef struct _LOCKING_ANDX_RANGE {
                                               //   w         _USHORT( Pid );                     // PID of process "owning" lock
                                               //   d         _ULONG( Offset );                   // Ofset to bytes to [un]lock
                      ByteOffsetAsLI->LowPart,
                                               //   d         _ULONG( Length );                   // Number of bytes to [un]lock
                      LengthAsLI->LowPart
                                               //         } LOCKING_ANDX_RANGE;
                     );
         }

        MRxSmbDumpStufferState (700,"SMB w/ NTLOCKS&X after stuffing",StufferState);
    } else {
        //lockbyterange and unlockbyterange have the same format......
        COVERED_CALL(MRxSmbStartSMBCommand ( StufferState, SetInitialSMB_Never,
                                               (UCHAR)((NumberOfLocks==0)?SMB_COM_UNLOCK_BYTE_RANGE
                                                                :SMB_COM_LOCK_BYTE_RANGE),
                                               SMB_REQUEST_SIZE(LOCK_BYTE_RANGE),
                                               NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                               0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                                            );

        MRxSmbDumpStufferState (1000,"SMB w/ corelocking before stuffing",StufferState);

        ASSERT(ByteOffsetAsLI->HighPart==0);
        ASSERT(LengthAsLI->HighPart==0);

        MRxSmbStuffSMB (StufferState,
            "0wddB!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 5
               smbSrvOpen->Fid,         //  w         _USHORT( Fid );                     // File handle
               LengthAsLI->LowPart,     //  d         _ULONG( Count );                    // Count of bytes to lock
               ByteOffsetAsLI->LowPart, //  d         _ULONG( Offset );                   // Offset from start of file
                                        //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                  SMB_WCT_CHECK(5) 0
                                        //            UCHAR Buffer[1];                    // empty
                 );

        MRxSmbDumpStufferState (700,"SMB w/ corelocking after stuffing",StufferState);
    }

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildLockAssert (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for multiple locks by calling the lock enumerator.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

CODE.IMRPOVEMENT.ASHAMED this is just like the code in MRxSmbBuildLocksAndX; btw MRxSmbBuildLocksAndX
doesn't build a locksandX

CODE.IMPROVEMENT all of the checks to find out if a lock is of a valid type need to be moved
before the call to the fsrtl lockpackage. if you can't handle it then you need to get out before it tries
lock buffering. check this in on mark's bug


--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    RxCaptureFcb;RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PRX_LOCK_ENUMERATOR LockEnumerator = OrdinaryExchange->AssertLocks.LockEnumerator;
    ULONG UseLargeOffsets;
    BOOLEAN LocksExclusiveForThisPacket = TRUE;
    PBYTE PtrToLockCount;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLockAssert enum=%08lx\n",LockEnumerator));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    if (smbSrvOpen->Fid == 0xffff) {
        return STATUS_FILE_CLOSED;
    }

    RxDbgTrace(0,Dbg,("Oplock response for FID(%lx)\n",smbSrvOpen->Fid));

    UseLargeOffsets = FlagOn(pServer->DialectFlags,DF_NT_SMBS)?LOCKING_ANDX_LARGE_FILES:0;
    //UseLargeOffsets = FALSE;

    OrdinaryExchange->AssertLocks.NumberOfLocksPlaced = 0;
    for (;;) {

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

        RxDbgTrace(0, Dbg, ("top of loop %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));

        if (!OrdinaryExchange->AssertLocks.EndOfListReached
              && !OrdinaryExchange->AssertLocks.LockAreaNonEmpty) {
            //get a new lock
            //DbgBreakPoint();
            if (LockEnumerator(
                           OrdinaryExchange->AssertLocks.SrvOpen,
                           &OrdinaryExchange->AssertLocks.ContinuationHandle,
                           &OrdinaryExchange->AssertLocks.NextLockOffset,
                           &OrdinaryExchange->AssertLocks.NextLockRange,
                           &OrdinaryExchange->AssertLocks.NextLockIsExclusive
                           )){
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = TRUE;
            } else {
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
                OrdinaryExchange->AssertLocks.EndOfListReached = TRUE;
                OrdinaryExchange->AssertLocks.NextLockIsExclusive = TRUE;
            }
        }

        RxDbgTrace(0, Dbg, ("got a lockorempty %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));
        //DbgBreakPoint();

        if (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0){

            ULONG Timeout = 0xffffffff;
            ULONG SharedLock = !OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            LocksExclusiveForThisPacket = OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                    SMB_REQUEST_SIZE(LOCKING_ANDX),
                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                         );

            MRxSmbDumpStufferState (1000,"SMB w/ NTLOCKS&X(assertbuf) before stuffing",StufferState);


            MRxSmbStuffSMB (StufferState,
                 "XwrwDwrwB?",
                                            //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                            //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                            //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                            //            _USHORT( AndXOffset );              // Offset to next command WordCount
                      smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                            //
                                            //            //
                                            //            // When NT protocol is not negotiated the OplockLevel field is
                                            //            // omitted, and LockType field is a full word.  Since the upper
                                            //            // bits of LockType are never used, this definition works for
                                            //            // all protocols.
                                            //            //
                                            //
                                            //  rw         UCHAR( LockType );                  // Locking mode:
                      &OrdinaryExchange->AssertLocks.PtrToLockType,0,
                      SharedLock+UseLargeOffsets,
                                            //                                                //  bit 0: 0 = lock out all access
                                            //                                                //         1 = read OK while locked
                                            //                                                //  bit 1: 1 = 1 user total file unlock
                                            //            UCHAR( OplockLevel );               // The new oplock level
                      SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                      Timeout,              //  D         _ULONG( Timeout );
                      0,                    //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                                            // rw         _USHORT( NumberOfLocks );           // Num. lock range structs following
                      &PtrToLockCount,0,
                      0,
                      SMB_WCT_CHECK(8) 0
                                            //  B?         _USHORT( ByteCount );               // Count of data bytes
                                            //            UCHAR Buffer[1];                    // Buffer containing:
                                            //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                            //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                     );
            ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
            RxDbgTrace(0, Dbg, ("PTRS %08lx %08lx\n",
                      OrdinaryExchange->AssertLocks.PtrToLockType,
                      PtrToLockCount
                      ));
        }

        if (OrdinaryExchange->AssertLocks.EndOfListReached
             || (LocksExclusiveForThisPacket != OrdinaryExchange->AssertLocks.NextLockIsExclusive)
             || (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced >= 20) //CODE.IMPROVEMENT.ASHAMED
             // the lock limit will have to take cognizance of the remaining space in the buffer. this will be
             // different depending on whether a full buffer is used or a vestigial buffer. SO, this cannot just
             // be turned into another constant
            ){
            break;
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        if (UseLargeOffsets) {
            MRxSmbStuffSMB (StufferState,
                 "wwdddd?",
                                               //        typedef struct _NT_LOCKING_ANDX_RANGE {
                      MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                      0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                                               //  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockOffset.HighPart,
                                               //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockRange.HighPart,
                                               //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //        } NTLOCKING_ANDX_RANGE;
                      0
                     );
        } else {
            MRxSmbStuffSMB (StufferState,
                 "wdd?",
                     MRXSMB_PROCESS_ID     ,   //         typedef struct _LOCKING_ANDX_RANGE {
                                               //   w         _USHORT( Pid );                     // PID of process "owning" lock
                                               //   d         _ULONG( Offset );                   // Ofset to bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //   d         _ULONG( Length );                   // Number of bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //         } LOCKING_ANDX_RANGE;
                      0
                     );
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        OrdinaryExchange->AssertLocks.NumberOfLocksPlaced += 1;
        SmbPutUshort(PtrToLockCount, (USHORT)(OrdinaryExchange->AssertLocks.NumberOfLocksPlaced));
        OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

    }

    MRxSmbStuffSMB (StufferState, "!",  0);  //fill in the bytecount
    MRxSmbDumpStufferState (700,"SMB w/ NTLOCKS&X(assertingbuffered) after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for locks AND for flush.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG StartEntryCount;

    SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    RxCaptureFcb; RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    BOOLEAN  ThisIsARetry = FALSE;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Locks\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            if (!SynchronousIo) {
                OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Locks;
            }
            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

            //CODE.IMPROVEMENT union another field over this to lose the casts....we have to do this
            //early because copying the head of the list is only done once. this variable is reset for
            //those cases where we don't use the locklist
            rw->LockList = LowIoContext->ParamsFor.Locks.LockList;

            //lack of break is intentional
        case SmbPseOEInnerIoStates_ReadyToSend:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
            OrdinaryExchange->SendOptions = MRxSmbLockSendOptions;

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                OEType = SMBPSE_OETYPE_FLUSH;
                if (!ThisIsARetry) {
                    COVERED_CALL(MRxSmbBuildFlush(StufferState));
                }
                break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                OEType = SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS;
                if (!ThisIsARetry) {
                    COVERED_CALL(MRxSmbBuildLockAssert(StufferState));
                }   
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                   OrdinaryExchange->SendOptions = RXCE_SEND_SYNCHRONOUS;
                   OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                   OrdinaryExchange->Mid        = SMBCE_OPLOCK_RESPONSE_MID;
                   OrdinaryExchange->Flags |= SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED;
                   if (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II) {
                       *((WORD UNALIGNED *)OrdinaryExchange->AssertLocks.PtrToLockType) |=
                            ((OPLOCK_BROKEN_TO_II << 8) | 2);
                   } else {
                       *((WORD UNALIGNED *)OrdinaryExchange->AssertLocks.PtrToLockType) |=
                            ((OPLOCK_BROKEN_TO_NONE << 8) | 2);
                   }
                }
                break;
            case SMBPSE_OE_FROM_LOCKS:
                OEType = SMBPSE_OETYPE_LOCKS;
                switch (LowIoContext->Operation) {
                case LOWIO_OP_SHAREDLOCK:
                case LOWIO_OP_EXCLUSIVELOCK:
                    ASSERT (MRxSmbIsLockRealizable(
                                           capFcb,
                                           (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset,
                                           (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length,
                                           LowIoContext->ParamsFor.Locks.Flags
                                           )
                                  == STATUS_SUCCESS);
                    //lack of break is intentional...........
                case LOWIO_OP_UNLOCK:
                    rw->LockList = NULL;
                    if (!ThisIsARetry) {
                        COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    }
                    break;
                case LOWIO_OP_UNLOCK_MULTIPLE: {
                    RxDbgTrace(0, Dbg, ("--->in locks_start, remaining locklist=%08lx\n", rw->LockList));
                    ASSERT( rw->LockList != NULL );
                    if (!ThisIsARetry) {
                        COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    }
                    break;
                    }
                default:
                    ASSERT(!"Bad lowio op for locks\n");
                    Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
                    goto FINALLY;
                }
                break;
            default:
                ASSERT(!"Bad entrypoint for locks_start\n");
                Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
                goto FINALLY;
            }

            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            OEType
                                            );
            if (Status==RX_MAP_STATUS(PENDING)) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }

            ThisIsARetry = FALSE;
            
            //lack of break is intentional
        case SmbPseOEInnerIoStates_OperationOutstanding:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            Status = OrdinaryExchange->SmbStatus;

            if (Status == STATUS_RETRY) {
                SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                Status = SmbCeReconnect(SmbCeGetExchangeVNetRoot(OrdinaryExchange));

                if (Status == STATUS_SUCCESS) {
                    RxLog(("session recover %lx\n",OrdinaryExchange));
                    OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                    Status = SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);

                    if (Status != STATUS_SUCCESS) {
                        goto FINALLY;
                    }
                    
                    ThisIsARetry = TRUE;
                    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                    continue;
                } else {
                    goto FINALLY;
                }
            }

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                goto FINALLY;
                //break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                    goto FINALLY;
                }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            case SMBPSE_OE_FROM_LOCKS:
                // if the locklist is empty. we can get out. this can happen either because we're not using
                // the locklist OR because we advance to the end of the list. that's why there are two checks
                if (rw->LockList == NULL) goto FINALLY;
                rw->LockList = rw->LockList->Next;
                if (rw->LockList == 0) goto FINALLY;

                if (Status != RX_MAP_STATUS(SUCCESS)) { goto FINALLY; }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            //default:
            //    ASSERT(!"Bad entrypoint for locks_start\n");
            //    Status = RxStatus(NOT_IMPLEMENTED);
            //    goto FINALLY;
            }
            break;
        }
    }

FINALLY:
     
    //CODE.IMPROVEMENT read_start and write_start and locks_start should be combined.....we use this
    //macro until then to keep the async stuff identical
    if ( Status != RX_MAP_STATUS(PENDING) ) {
        SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Locks exit w %08lx\n", Status ));
    return Status;
}

//CODE.IMPROVEMENT this routine should not even be called...........
NTSTATUS
MRxSmbFinishLocks (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_LOCKING_ANDX             Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes the locks.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishLocks\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishLocks:");

    if (Response->WordCount != 2) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishLocks   returning %08lx\n", Status ));
    return Status;
}

#if 0
NTSTATUS
MRxSmbUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    )
/*++

Routine Description:

    This routine is called from the RDBSS whenever the fsrtl lock package calls the rdbss unlock routine.
    CODE.IMPROVEMENT what should really happen is that this should only be called for unlockall and unlockbykey;
    the other cases should be handled in the rdbss.

Arguments:

    Context - the RxContext associated with this request
    LockInfo - gives information about the particular range being unlocked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
       return STATUS_SUCCESS;
    case LOWIO_OP_UNLOCKALL:
    case LOWIO_OP_UNLOCKALLBYKEY:
    default:
       return STATUS_NOT_IMPLEMENTED;
    }
}
#endif


NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used. CODE.IMPROVEMENT this param is redundant if the rxcontext is filled out completely
    LockEnumerator - the routine to call to get the locks

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(Fcb);

    USHORT NewOplockLevel = (USHORT)(pContext);

    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("@@@@@@ Old Level (%lx) to New Level %lx @@@@\n",smbSrvOpen->OplockLevel,NewOplockLevel));
    
    if (NewOplockLevel == SMB_OPLOCK_LEVEL_NONE)
    {
        SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_READ_CACHEING;
    }
    
    smbFcb->LastOplockLevel = NewOplockLevel;
    if ((smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II) &&
        (NewOplockLevel == SMB_OPLOCK_LEVEL_NONE)) {
       return RX_MAP_STATUS(SUCCESS);
    }
    smbSrvOpen->OplockLevel = (UCHAR)NewOplockLevel;
    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    // The SERVER has a time window of 45 seconds associated with OPLOCK responses.
    // During this period oplock responses ( the last packet ) do not elicit any
    // response. If the response at the server is received after this window has
    // elapsed the OPLOCK response will elicit a normal LOCKING_ANDX response from
    // the server. In order to simplify the MID reuse logic at the clients without
    // violating the OPLOCK semantics, all the final responses are sent on a special
    // MID(0xffff). Any response received with this MID is accepted by default and this
    // MID is not used further.
    OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
    OrdinaryExchange->AssertLocks.LockEnumerator = RxLockEnumerator;
    OrdinaryExchange->AssertLocks.SrvOpen = SrvOpen;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=RX_MAP_STATUS(PENDING));
    if (Status!=RX_MAP_STATUS(PENDING)) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}


#undef  Dbg
#define Dbg                              (DEBUG_TRACE_FLUSH)

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Flush SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFlush\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_FLUSH,
                                SMB_REQUEST_SIZE(FLUSH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ FLUSH before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ FLUSH after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}


NTSTATUS
MRxSmbFlush(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for file flush

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFlush\n"));

    if (TypeOfOpen == RDBSS_NTC_SPOOLFILE) {
        //we don't buffer spoolfiles....just get out....
        RxDbgTrace(-1, Dbg, ("MRxSmbFlush exit on spoolfile\n"));
        return(STATUS_SUCCESS);
    }

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        NOTHING;
    } else {
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        if (smbSrvOpen->hfShadow != 0){
            NTSTATUS FlushNtStatus;

            FlushNtStatus = MRxSmbDCscFlush(RxContext);

            if (FlushNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(-1, Dbg, ("MRxSmbFlush exit on DCON\n"));
                return(FlushNtStatus);
            } else {
                NOTHING;
            }
        }
    }


    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_FLUSH,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=RX_MAP_STATUS(PENDING));
    if (Status!=RX_MAP_STATUS(PENDING)) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbFlush  exit with status=%08lx\n", Status ));
    return(Status);

}


NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    ULONG DialectFlags;

    PAGED_CODE();
    pServerEntry = SmbCeGetAssociatedServerEntry(pFcb->pNetRoot->pSrvCall);
    DialectFlags = pServerEntry->Server.DialectFlags;

    //nt servers implement all types of locks

    if (FlagOn(DialectFlags,DF_NT_SMBS)
           || SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        return(STATUS_SUCCESS);
    }

    //nonnt servers do not handle 64bit locks or 0-length locks

    if ( (ByteOffset->HighPart!=0)
           || (Length->HighPart!=0)
           || (Length->QuadPart==0) ) {
        return(STATUS_NOT_SUPPORTED);
    }

    //  Lanman 2.0 pinball servers don't support shared locks (even
    //  though Lanman 2.0 FAT servers support them).  As a result,
    //  we cannot support shared locks to Lanman servers.
    //

    if (!FlagOn(DialectFlags,DF_LANMAN21)
           && !FlagOn(LowIoLockFlags,LOWIO_LOCKSFLAG_EXCLUSIVELOCK)) {
        return(STATUS_NOT_SUPPORTED);
    }

    //  if a server cannot do lockingAndX, then we can't do
    //  !FailImmediately because there's no timeout

    if (!FlagOn(DialectFlags,DF_LANMAN20)
           && !FlagOn(LowIoLockFlags,LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY)) {
        return(STATUS_NOT_SUPPORTED);
    }

    return(STATUS_SUCCESS);
}

#if 0
CODE.IMPROVEMENT this is never called but it had been called it would have checked WC and BC.
                 this should be added to the model...especially for checked.
NTSTATUS
MRxSmbFinishFlush (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_FLUSH             Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes the locks.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishFlush\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishFlush:");

    if (Response->WordCount != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishFlush   returning %08lx\n", Status ));
    return Status;
}

#endif //if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\manipmdl.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    manipmdl.h

Abstract:

    This file defines the prototypes and structs for implementing the MDL substring functions and tests.

Author:


--*/


typedef struct _MDLSUB_CHAIN_STATE {
    PMDL FirstMdlOut;
    PMDL LastMdlOut;
    USHORT PadBytesAvailable;
    USHORT PadBytesAdded;
    PMDL  OneBeforeActualLastMdl;
    PMDL  ActualLastMdl;
    PMDL  ActualLastMdl_Next;
    UCHAR FirstMdlWasAllocated;
    UCHAR LastMdlWasAllocated;
} MDLSUB_CHAIN_STATE, *PMDLSUB_CHAIN_STATE;

VOID
MRxSmbFinalizeMdlSubChain (
    PMDLSUB_CHAIN_STATE state
    );

#if DBG
VOID
MRxSmbDbgDumpMdlChain (
    PMDL MdlChain,
    PMDL WatchMdl,
    PSZ  Tagstring
    );
#else
#define MRxSmbDbgDumpMdlChain(a,b,c) {NOTHING;}
#endif

#define SMBMRX_BUILDSUBCHAIN_FIRSTTIME    1
#define SMBMRX_BUILDSUBCHAIN_DUMPCHAININ  2
#define SMBMRX_BUILDSUBCHAIN_DUMPCHAINOUT 4

NTSTATUS
MRxSmbBuildMdlSubChain (
    PMDLSUB_CHAIN_STATE state,
    ULONG               Options,
    PMDL                InputMdlChain,
    ULONG               TotalListSize,
    ULONG               FirstByteToSend,
    ULONG               BytesToSend
    );

#if DBG
extern LONG MRxSmbNeedSCTesting;
VOID MRxSmbTestStudCode(void);
#else
#define MRxSmbTestStudCode(a) {NOTHING;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\midatlas.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAS_H_
#define _MIDATLAS_H_

typedef struct _MID_ATLAS_ {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      NumberOfMidsDiscarded;
   USHORT      MaximumMidFieldWidth;
   USHORT      Reserved;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} MID_ATLAS, *PMID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

#define FsRtlGetMaximumNumberOfMids(pMidAtlas) \
        ((pMidAtlas)->MaximumNumberOfMids)

#define FsRtlGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

extern PMID_ATLAS
FsRtlCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

extern VOID
FsRtlDestroyMidAtlas(
         PMID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

extern PVOID
FsRtlMapMidToContext(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid);

extern NTSTATUS
FsRtlAssociateContextWithMid(
         PMID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

extern NTSTATUS
FsRtlMapAndDissociateMidFromContext(
         PMID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

extern NTSTATUS
FsRtlReassociateMid(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\mm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mm.c

Abstract:

    This module implements the memory managment routines for the SMB mini
    redirector

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

Notes:

    The SMB mini redirector manipulates entities which have very different usage
    patterns. They range from very static entities ( which are allocated and freed
    with a very low frequency ) to very dynamic entities.

    The entities manipulated in the SMB mini redirector are SMBCE_SERVER, SMBCE_NET_ROOT,
    SMBCE_VC, SMBCE_SESSION. These represent a connection to a server, a share on
    a particular server, a virtual circuit used in the connection and a session
    for a particular user.

    These are not very dynamic, i.e., the allocation/deallocation is very infrequent.
    The SMB_EXCHANGE and SMBCE_REQUEST map to the SMB's that are sent along that
    a connection. Every file operation in turn maps to a certain number of calls
    for allocationg/freeing exchanges and requests. Therefore it is imperative
    that some form of scavenging/caching of recently freed entries be maintained
    to satisfy requests quickly.

    In the current implementation the exchanges and requests are implemented
    using the zone allocation primitives.

    The exchange allocation and free routines are currently implemented as wrappers
    around the RxAllocate and RxFree routines. It would be far more efficient if
    a look aside cache of some exchange instances are maintained.

--*/

#include "precomp.h"
#pragma hdrstop

#include <exsessup.h>
#include <mssndrcv.h>
#include <vcsndrcv.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbMmAllocateSessionEntry)
#pragma alloc_text(PAGE, SmbMmFreeSessionEntry)
#pragma alloc_text(PAGE, SmbMmAllocateServerTransport)
#pragma alloc_text(PAGE, SmbMmFreeServerTransport)
#pragma alloc_text(PAGE, SmbMmInit)
#pragma alloc_text(PAGE, SmbMmTearDown)
#endif

#define SMBMM_ZONE_ALLOCATION 0x10

// The memory management package addresses a number of concerns w.r.t debugging
// and performance. By centralizing all the allocation/deallocation routines to
// thsi one module it is possible to build up profiles regarding various data
// structures used by the connection engine. In addition debugging support is
// provided by thereading together all allocated objects of a particular type
// are threaded together in a linked list according to type.
//
// At any stage by inspecting these lists the currently active instances of a
// particular type can be enumerated.
//
// Each type handled by this module is provided with two routines, e.g., for
// server entries there are SmbMmInitializeEntry and SmbMmUninitializeEntry. The
// first routine is called before handing over a pointer of a newly created
// instance. This will ensure that the instance is in a wll known initial state.
// Similarly the second routine is called just before deallocating the pool
// associated with the instance. This helps enforce the necessary integrity
// constraints, e.g., all enclosed pointers must be NULL etc.
//
// The pool allocation/deallocation is handled by the following routines
//
//    SmbMmAllocateObjectPool/SmbMmFreeObjectPool
//
//    SmbMmAllocateExchange/SmbMmFreeExchange
//
// The Object allocation routines are split up into two parts so as to be able to
// handle the session allocationson par with other objects even though they are
// further subtyped.
//
// On debug builds additional pool is allocated and the appropriate linking is
// done into the corresponding list. On retail builds these map to the regular
// pool allocation wrappers.
//

// Zone allocation to speed up memory management of RxCe entities.
//

ULONG       SmbMmRequestZoneEntrySize;
ZONE_HEADER SmbMmRequestZone;
PVOID       SmbMmRequestZoneSegmentPtr;

//
// Pool allocation resources and spin locks
//

KSPIN_LOCK  SmbMmSpinLock;

ULONG SmbMmExchangeId;

//
// List of the various objects/exchanges allocated.
//

LIST_ENTRY SmbMmExchangesInUse[SENTINEL_EXCHANGE];
LIST_ENTRY SmbMmObjectsInUse[SMBCEDB_OT_SENTINEL];

ULONG  ObjectSizeInBytes[SMBCEDB_OT_SENTINEL];
ULONG  ExchangeSizeInBytes[SENTINEL_EXCHANGE];

//
// Lookaside lists for Exchange allocation
//

NPAGED_LOOKASIDE_LIST SmbMmExchangesLookasideList[SENTINEL_EXCHANGE];

INLINE PSMBCE_OBJECT_HEADER
SmbMmAllocateObjectPool(
    SMBCEDB_OBJECT_TYPE  ObjectType,
    ULONG                PoolType,
    ULONG                PoolSize)
{
    KIRQL SavedIrql;
    PVOID pv = NULL;
    UCHAR Flags = 0;

    PSMBCE_OBJECT_HEADER pHeader = NULL;

    ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

    if (ObjectType == SMBCEDB_OT_REQUEST) {
        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        if (!ExIsFullZone( &SmbMmRequestZone )) {
            pv = ExAllocateFromZone( &SmbMmRequestZone );
            Flags = SMBMM_ZONE_ALLOCATION;
        }

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
    }

    if (pv == NULL) {
        PLIST_ENTRY pListEntry;

        pv = RxAllocatePoolWithTag(
                 PoolType,
                 PoolSize + sizeof(LIST_ENTRY),
                 MRXSMB_MM_POOLTAG);

        if (pv != NULL) {
            pListEntry = (PLIST_ENTRY)pv;
            pHeader    = (PSMBCE_OBJECT_HEADER)(pListEntry + 1);

            ExInterlockedInsertTailList(
                &SmbMmObjectsInUse[ObjectType],
                pListEntry,
                &SmbMmSpinLock);
        }
    } else {
        pHeader = (PSMBCE_OBJECT_HEADER)pv;
    }

    if (pHeader != NULL) {
        // Zero the memory.
        RtlZeroMemory( pHeader, PoolSize);

        pHeader->Flags = Flags;
    }

    return pHeader;
}

VOID
SmbMmFreeObjectPool(
    PSMBCE_OBJECT_HEADER  pHeader)
{
    KIRQL               SavedIrql;
    BOOLEAN             ZoneAllocation = FALSE;
    PLIST_ENTRY         pListEntry;

    ASSERT((pHeader->ObjectType >= 0) && (pHeader->ObjectType < SMBCEDB_OT_SENTINEL));

    // Acquire the resource lock.
    KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

    // Check if it was a zone allocation
    if (pHeader->Flags & SMBMM_ZONE_ALLOCATION) {
        ZoneAllocation = TRUE;
        ExFreeToZone(&SmbMmRequestZone,pHeader);
    } else {
        pListEntry = (PLIST_ENTRY)((PCHAR)pHeader - sizeof(LIST_ENTRY));
        RemoveEntryList(pListEntry);
    }

    // Release the resource lock.
    KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );

    if (!ZoneAllocation) {
        RxFreePool(pListEntry);
    }
}

// Construction and destruction of various SMB connection engine objects
//

#define SmbMmInitializeServerEntry(pServerEntry)                                \
         InitializeListHead(&(pServerEntry)->OutstandingRequests.ListHead);   \
         InitializeListHead(&(pServerEntry)->MidAssignmentRequests.ListHead); \
         InitializeListHead(&(pServerEntry)->SecuritySignatureSyncRequests.ListHead); \
         InitializeListHead(&(pServerEntry)->Sessions.ListHead);              \
         InitializeListHead(&(pServerEntry)->NetRoots.ListHead);              \
         InitializeListHead(&(pServerEntry)->VNetRootContexts.ListHead);      \
         InitializeListHead(&(pServerEntry)->ActiveExchanges);                \
         InitializeListHead(&(pServerEntry)->ExpiredExchanges);                \
         InitializeListHead(&(pServerEntry)->Sessions.DefaultSessionList);     \
         (pServerEntry)->pTransport                = NULL;                      \
         (pServerEntry)->pMidAtlas                 = NULL

#define SmbMmInitializeSessionEntry(pSessionEntry)  \
         InitializeListHead(&(pSessionEntry)->Requests.ListHead); \
         InitializeListHead(&(pSessionEntry)->SerializationList); \
         (pSessionEntry)->DefaultSessionLink.Flink = NULL;        \
         (pSessionEntry)->DefaultSessionLink.Blink = NULL

#define SmbMmInitializeNetRootEntry(pNetRootEntry)  \
         InitializeListHead(&(pNetRootEntry)->Requests.ListHead)

#define SmbMmUninitializeServerEntry(pServerEntry)                                 \
         ASSERT(IsListEmpty(&(pServerEntry)->OutstandingRequests.ListHead) &&   \
                IsListEmpty(&(pServerEntry)->MidAssignmentRequests.ListHead) && \
                IsListEmpty(&(pServerEntry)->SecuritySignatureSyncRequests.ListHead) && \
                IsListEmpty(&(pServerEntry)->Sessions.ListHead) &&              \
                IsListEmpty(&(pServerEntry)->NetRoots.ListHead) &&              \
                ((pServerEntry)->pMidAtlas == NULL))

#define SmbMmUninitializeSessionEntry(pSessionEntry)  \
         ASSERT(IsListEmpty(&(pSessionEntry)->Requests.ListHead) && \
                ((pSessionEntry)->DefaultSessionLink.Flink == NULL))

#define SmbMmUninitializeNetRootEntry(pNetRootEntry)  \
         ASSERT(IsListEmpty(&(pNetRootEntry)->Requests.ListHead))

#define SmbMmInitializeRequestEntry(pRequestEntry)

#define SmbMmUninitializeRequestEntry(pRequestEntry)

PVOID
SmbMmAllocateObject(
    SMBCEDB_OBJECT_TYPE ObjectType)
{
    PSMBCE_OBJECT_HEADER pHeader;

    ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

    pHeader = SmbMmAllocateObjectPool(
                  ObjectType,
                  NonPagedPool,
                  ObjectSizeInBytes[ObjectType]);

    if (pHeader != NULL) {
        pHeader->NodeType = SMB_CONNECTION_ENGINE_NTC(ObjectType);
        pHeader->State = SMBCEDB_START_CONSTRUCTION;

        switch (ObjectType) {
        case SMBCEDB_OT_SERVER :
            SmbMmInitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
            break;

        case SMBCEDB_OT_NETROOT :
            SmbMmInitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
            break;

        case SMBCEDB_OT_REQUEST :
            SmbMmInitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
            break;

        default:
            ASSERT(!"Valid Type for SmbMmAllocateObject");
            break;
        }
    }

    return pHeader;
}

VOID
SmbMmFreeObject(
    PVOID pv)
{
    PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pv;

    switch (pHeader->ObjectType) {
    case SMBCEDB_OT_SERVER :
        SmbMmUninitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
        break;

    case SMBCEDB_OT_NETROOT :
        SmbMmUninitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
        break;

    case SMBCEDB_OT_REQUEST :
        SmbMmUninitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
        break;

    default:
        ASSERT(!"Valid Type for SmbMmFreeObject");
        break;
    }

    SmbMmFreeObjectPool(pHeader);
}

PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    BOOLEAN RemoteBootSession)
{
    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    SESSION_TYPE           SessionType;
    ULONG                  SessionSize;

    PAGED_CODE();

    SessionSize = sizeof(SMBCEDB_SESSION_ENTRY) -
                  sizeof(SMBCE_SESSION);

    if (pServerEntry->Header.State != SMBCEDB_INVALID) {
        if ((pServerEntry->Server.DialectFlags & DF_EXTENDED_SECURITY) && !RemoteBootSession) {
            SessionSize += sizeof(SMBCE_EXTENDED_SESSION);

            SessionType = EXTENDED_NT_SESSION;
        } else {
            // allocate a LANMAN session
            SessionSize += sizeof(SMBCE_SESSION);
            SessionType = LANMAN_SESSION;
        }
    } else {
        SessionSize += sizeof(SMBCE_EXTENDED_SESSION);
        SessionType = UNINITIALIZED_SESSION;
    }

    pSessionEntry = (PSMBCEDB_SESSION_ENTRY)
                    SmbMmAllocateObjectPool(
                        SMBCEDB_OT_SESSION,
                        NonPagedPool,
                        SessionSize);

    if (pSessionEntry != NULL) {
        pSessionEntry->Header.NodeType = SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION);
        pSessionEntry->Header.State = SMBCEDB_START_CONSTRUCTION;
        pSessionEntry->Session.Type = SessionType;

        SmbMmInitializeSessionEntry(pSessionEntry);

        SecInvalidateHandle( &pSessionEntry->Session.CredentialHandle );
        SecInvalidateHandle( &pSessionEntry->Session.SecurityContextHandle );

        if (SessionType == EXTENDED_NT_SESSION) {
            PSMBCE_EXTENDED_SESSION pExtSecuritySession = (PSMBCE_EXTENDED_SESSION)&pSessionEntry->Session;
            pExtSecuritySession->pServerResponseBlob           = NULL;
            pExtSecuritySession->ServerResponseBlobLength      = 0;
        }
    }

    return pSessionEntry;
}

VOID
SmbMmFreeSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
{
    PAGED_CODE();

    if (pSessionEntry->Session.Type == EXTENDED_NT_SESSION) {
        // KERBEROS specific asserts
    }

    SmbMmUninitializeSessionEntry(pSessionEntry);

    SmbMmFreeObjectPool(&pSessionEntry->Header);
}


PVOID
SmbMmAllocateExchange(
    SMB_EXCHANGE_TYPE ExchangeType,
    PVOID pv)
{
    KIRQL               SavedIrql;
    ULONG               SizeInBytes;
    USHORT              Flags = 0;
    PSMB_EXCHANGE       pExchange = NULL;
    PLIST_ENTRY         pListEntry;

    ASSERT((ExchangeType >= 0) && (ExchangeType < SENTINEL_EXCHANGE));

    if (pv==NULL) {
        pv = ExAllocateFromNPagedLookasideList(
                 &SmbMmExchangesLookasideList[ExchangeType]);
    } else {
        Flags |= SMBCE_EXCHANGE_NOT_FROM_POOL;
    }

    if (pv != NULL) {
        // Initialize the object header
        pExchange   = (PSMB_EXCHANGE)(pv);

        // Zero the memory.
        RtlZeroMemory(
            pExchange,
            ExchangeSizeInBytes[ExchangeType]);

        pExchange->NodeTypeCode = SMB_EXCHANGE_NTC(ExchangeType);
        pExchange->NodeByteSize = (USHORT)ExchangeSizeInBytes[ExchangeType];

        pExchange->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
        pExchange->SmbCeFlags = Flags;

        InitializeListHead(&pExchange->ExchangeList);
        InitializeListHead(&pExchange->CancelledList);

        switch (pExchange->Type) {
        case CONSTRUCT_NETROOT_EXCHANGE:
            pExchange->pDispatchVector = &ConstructNetRootExchangeDispatch;
            break;

        case TRANSACT_EXCHANGE :
            pExchange->pDispatchVector = &TransactExchangeDispatch;
            break;

        case EXTENDED_SESSION_SETUP_EXCHANGE:
            pExchange->pDispatchVector = &ExtendedSessionSetupExchangeDispatch;
            break;

        case ADMIN_EXCHANGE:
            pExchange->pDispatchVector = &AdminExchangeDispatch;
            break;
        }

        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        InsertTailList(
            &SmbMmExchangesInUse[pExchange->Type],
            &pExchange->SmbMmInUseListEntry);

        pExchange->Id = SmbMmExchangeId++;

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
    }

    return pExchange;
}

VOID
SmbMmFreeExchange(
    PSMB_EXCHANGE pExchange)
{
    if (pExchange != NULL) {
        SMB_EXCHANGE_TYPE ExchangeType;

        KIRQL       SavedIrql;

        ExchangeType = pExchange->Type;

        ASSERT((ExchangeType >= 0) && (ExchangeType < SENTINEL_EXCHANGE));
        ASSERT(pExchange->MdlForServerResponse == NULL &&
               pExchange->BufferForServerResponse == NULL);

        if (pExchange->WorkQueueItem.List.Flink != NULL) {
            //DbgBreakPoint();
        }

        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        RemoveEntryList(&pExchange->SmbMmInUseListEntry);

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );

        if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_NOT_FROM_POOL)) {
            ExFreeToNPagedLookasideList(
                &SmbMmExchangesLookasideList[ExchangeType],
                pExchange);
        }
    }
}

PVOID
SmbMmAllocateServerTransport(
    SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType)
{
    PSMBCE_OBJECT_HEADER pHeader;

    ULONG AllocationSize;
    ULONG PoolTag;

    PAGED_CODE();

    switch (ServerTransportType) {
    case SMBCE_STT_VC:
        AllocationSize = sizeof(SMBCE_SERVER_VC_TRANSPORT);
        PoolTag = MRXSMB_VC_POOLTAG;
        break;

    case SMBCE_STT_MAILSLOT:
        AllocationSize = sizeof(SMBCE_SERVER_MAILSLOT_TRANSPORT);
        PoolTag = MRXSMB_MAILSLOT_POOLTAG;
        break;

    default:
        ASSERT(!"Valid Server Transport Type");
        return NULL;
    }

    pHeader = (PSMBCE_OBJECT_HEADER)
              RxAllocatePoolWithTag(
                  NonPagedPool,
                  AllocationSize,
                  PoolTag);

    if (pHeader != NULL) {
        PSMBCE_SERVER_TRANSPORT pServerTransport;

        RtlZeroMemory(pHeader,AllocationSize);

        pHeader->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
        pHeader->ObjectType     = (UCHAR)ServerTransportType;
        pHeader->SwizzleCount   = 0;
        pHeader->State          = 0;
        pHeader->Flags          = 0;

        pServerTransport = (PSMBCE_SERVER_TRANSPORT)pHeader;

        pServerTransport->pRundownEvent = NULL;

        switch (ServerTransportType) {
        case SMBCE_STT_MAILSLOT:
            break;

        case SMBCE_STT_VC:
            {
                PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

                pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pHeader;
            }
            break;

        default:
            break;
        }
    }

    return pHeader;
}

VOID
SmbMmFreeServerTransport(
    PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    PAGED_CODE();

    ASSERT((pServerTransport->SwizzleCount == 0) &&
           (pServerTransport->ObjectCategory == SMB_SERVER_TRANSPORT_CATEGORY));

    RxFreePool(pServerTransport);
}

NTSTATUS SmbMmInit()
/*++

Routine Description:

    This routine initialises the connection engine structures for memory management

Return Value:

    STATUS_SUCCESS if successful, otherwise an informative error code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ZoneSegmentSize;

    PAGED_CODE();

    // Initialize the resource lock for the zone allocator.
    KeInitializeSpinLock( &SmbMmSpinLock );

    SmbMmRequestZoneEntrySize = QuadAlign(sizeof(SMBCEDB_REQUEST_ENTRY));

    // Currently the request zone size is restricted to that of a page. This can and should
    // be fine tuned.
    ZoneSegmentSize = PAGE_SIZE;

    SmbMmRequestZoneSegmentPtr = RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     ZoneSegmentSize,
                                     MRXSMB_MM_POOLTAG);

    if (SmbMmRequestZoneSegmentPtr != NULL) {
        SMB_EXCHANGE_TYPE ExchangeType;

        ExInitializeZone(
            &SmbMmRequestZone,
            SmbMmRequestZoneEntrySize,
            SmbMmRequestZoneSegmentPtr,
            ZoneSegmentSize );

        // set up the sizes for allocation.
        ObjectSizeInBytes[SMBCEDB_OT_SERVER] = sizeof(SMBCEDB_SERVER_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_NETROOT] = sizeof(SMBCEDB_NET_ROOT_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_SESSION] = sizeof(SMBCEDB_SESSION_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_REQUEST] = sizeof(SMBCEDB_REQUEST_ENTRY);

        ExchangeSizeInBytes[CONSTRUCT_NETROOT_EXCHANGE] = sizeof(SMB_CONSTRUCT_NETROOT_EXCHANGE);
        ExchangeSizeInBytes[TRANSACT_EXCHANGE]          = sizeof(SMB_TRANSACT_EXCHANGE);
        ExchangeSizeInBytes[ORDINARY_EXCHANGE]          = sizeof(SMB_PSE_ORDINARY_EXCHANGE);
        ExchangeSizeInBytes[EXTENDED_SESSION_SETUP_EXCHANGE]
                                                      = sizeof(SMB_EXTENDED_SESSION_SETUP_EXCHANGE);
        ExchangeSizeInBytes[ADMIN_EXCHANGE]             = sizeof(SMB_ADMIN_EXCHANGE);

        InitializeListHead(&SmbMmExchangesInUse[CONSTRUCT_NETROOT_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[CONSTRUCT_NETROOT_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_CONSTRUCT_NETROOT_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            1);

        InitializeListHead(&SmbMmExchangesInUse[TRANSACT_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[TRANSACT_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_TRANSACT_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            2);

        InitializeListHead(&SmbMmExchangesInUse[ORDINARY_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[ORDINARY_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_PSE_ORDINARY_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            4);

        InitializeListHead(&SmbMmExchangesInUse[EXTENDED_SESSION_SETUP_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[EXTENDED_SESSION_SETUP_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_EXTENDED_SESSION_SETUP_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            1);

        InitializeListHead(&SmbMmExchangesInUse[ADMIN_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[ADMIN_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_ADMIN_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            1);

        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SERVER]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SESSION]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_NETROOT]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_REQUEST]);

        SmbMmExchangeId = 1;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID SmbMmTearDown()
/*++

Routine Description:

    This routine tears down the memory management structures in the SMB connection
    engine

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // free the segment associated with RxCe object allocation.
    RxFreePool(SmbMmRequestZoneSegmentPtr);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[CONSTRUCT_NETROOT_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[TRANSACT_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[ORDINARY_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[EXTENDED_SESSION_SETUP_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[ADMIN_EXCHANGE]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the
    corresponding requests/contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, _InitializeMidMapFreeList)
#pragma alloc_text(PAGE, FsRtlCreateMidAtlas)
#pragma alloc_text(PAGE, _UninitializeMidMap)
#pragma alloc_text(PAGE, FsRtlDestroyMidAtlas)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        ((ULONG)((ULONG_PTR)pEntry) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)pEntry & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
_InitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("_InitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("_InitializeMidMapFreeList .. Exit\n");
}


PMID_ATLAS
FsRtlCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PMID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PMID_ATLAS)RxAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              MRXSMB_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        _InitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("FsRtlAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}

VOID
_UninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("_UninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));
   SmbLog(LOG,
          UninitializeMidMap,
          LOGXSHORT(pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            _UninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      RxFreePool(pMidMap);
   }

   //DbgPrint("_UninitializeMidMap .. Exit\n");
}

VOID
FsRtlDestroyMidAtlas(
   PMID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("FsRtlFreeMidAtlas .. Entry\n");
   _UninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   RxFreePool(pMidAtlas);
   //DbgPrint("FsRtlFreeMidAtlas .. Exit\n");
}

PVOID
FsRtlMapMidToContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
    ULONG     EntryType;
    PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
    PVOID     pContext;
    ULONG     Index;

    //DbgPrint("FsRtlMapMidToContext Mid %lx ",Mid);

    for (;;) {
        Index =  (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount;

        if (Index >= pMidMap->MaximumNumberOfMids) {
            pContext = NULL;
            break;
        }

        pContext = pMidMap->Entries[Index];
        EntryType = _GetEntryType(pContext);
        pContext = (PVOID)_GetEntryPointer(pContext);

        if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
            break;
        } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
            pContext = NULL;
            break;
        } else if (EntryType == ENTRY_TYPE_MID_MAP) {
            pMidMap = (PMID_MAP)pContext;
        } else {
            pContext = NULL;
            break;
        }
    }

    //DbgPrint("Context %lx \n",pContext);

    return pContext;
}

NTSTATUS
FsRtlMapAndDissociateMidFromContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("FsRtlMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[
                    (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            _RemoveMidMap(pMidMap);
            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;

         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
FsRtlReassociateMid(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("FsRtlReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
FsRtlAssociateContextWithMid(
      PMID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status;
   PMID_MAP pMidMap;
   PVOID    *pContextPointer;

   //DbgPrint("FsRtlAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                   << pMidMap->IndexAlignmentCount) |
                                  pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }
         else if( NumberOfEntriesInMap == 1 )
         {
             // The MID_MAP design does not allow for maps of length 1.  Extend to 2
             NumberOfEntriesInMap++;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        MRXSMB_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                pNewMidMap->NumberOfMidsInUse   = 0;
                pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                   i << pMidMap->IndexAlignmentCount);

                pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                  pMidMap->IndexFieldWidth;

                pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                _InitializeMidMapFreeList(pNewMidMap);

                //
                // After the RxInitializeMidMapFreeList call above the
                // pFreeMidListHead points to Entries[0]. We will be storing
                // the value pMidMap->Entries[i] at this location so we need
                // to make pFreeMidListHead point to Entries[1].
                //
                pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));

                //
                // Set up the mid map appropriately.
                //
                pNewMidMap->NumberOfMidsInUse = 1;
                pNewMidMap->Entries[0] = pMidMap->Entries[i];
                pNewMidMap->Level      = pMidMap->Level + 1;

                //
                // The new MinMap is stored at the pMidMap->Entries[i] location.
                //
                pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                //
                // Update the free list and the expansion list respectively.
                //
                _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                pNewMidMap->NumberOfMidsInUse++;
                pContextPointer = pNewMidMap->pFreeMidListHead;
                pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                *pContextPointer = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                *pNewMid = ((USHORT)
                            (pContextPointer - (PVOID *)&pNewMidMap->Entries)
                            << pNewMidMap->IndexAlignmentCount) |
                            pNewMidMap->BaseMid;

                Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == RX_MAP_STATUS(SUCCESS)) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\mrxsec.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrxsec.h

Abstract:

    This module defines functions for interfacing smb security functions with the NT securoty functions

Revision History:

    Jim McNelis     [JimMcN]    6-September-1995

--*/

#ifndef _MRXSEC_H_
#define _MRXSEC_H_

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

//
// Forward declarations ...
//

typedef struct _SECURITY_RESPONSE_CONTEXT {
   union {
      struct {
         PVOID pOutputContextBuffer;
      } KerberosSetup;

      struct {
         PVOID pResponseBuffer;
      } LanmanSetup;
   };
} SECURITY_RESPONSE_CONTEXT,*PSECURITY_RESPONSE_CONTEXT;

extern NTSTATUS
BuildSessionSetupSecurityInformation(
            PSMB_EXCHANGE pExchange,
            PBYTE           pSmbBuffer,
            PULONG          pSmbBufferSize);

extern NTSTATUS
BuildNtLanmanResponsePrologue(
   PSMB_EXCHANGE              pExchange,
   PUNICODE_STRING            pUserName,
   PUNICODE_STRING            pDomainName,
   PSTRING                    pCaseSensitiveResponse,
   PSTRING                    pCaseInsensitiveResponse,
   PSECURITY_RESPONSE_CONTEXT pResponseContext);

extern NTSTATUS
BuildExtendedSessionSetupResponsePrologueFake(
   PSMB_EXCHANGE              pExchange);

extern NTSTATUS
BuildExtendedSessionSetupResponsePrologue(
   PSMB_EXCHANGE              pExchange,
   PVOID                      pSecurityBlobPtr,
   PUSHORT                    SecurityBlobSize,
   PSECURITY_RESPONSE_CONTEXT pResponseContext);

extern NTSTATUS
BuildNtLanmanResponseEpilogue(
   PSMB_EXCHANGE              pExchange,
   PSECURITY_RESPONSE_CONTEXT pResponseContext);


extern NTSTATUS
BuildExtendedSessionSetupResponseEpilogue(
   PSECURITY_RESPONSE_CONTEXT pResponseContext);


#endif  // _MRXSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\mrxglbl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrxglbl.h

Abstract:

    The global include file for SMB mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

--*/

#ifndef _MRXGLBL_H_
#define _MRXGLBL_H_

#define SmbCeLog(x) \
        RxLog(x)

//
// the SMB protocol tree connections are identified by a Tree Id., each
// file opened on a tree connection by a File Id. and each outstanding request
// on that connection by a Multiplex Id.
//


typedef USHORT SMB_TREE_ID;
typedef USHORT SMB_FILE_ID;
typedef USHORT SMB_MPX_ID;


//
// Each user w.r.t a particular connection is identified by a User Id. and each
// process on the client side is identified by a Process id.
//

typedef USHORT SMB_USER_ID;
typedef USHORT SMB_PROCESS_ID;

//
// All exchanges are identified with a unique id. assigned on creation of the exchange
// which is used to track it.
//

typedef ULONG SMB_EXCHANGE_ID;

//
// Of the fields in this context the domain name is initialized during
// MRxSmbSetConfiguration. The others are initialized in init.c as
// parameters read from the registry
//

typedef struct _SMBCE_CONTEXT_ {
    UNICODE_STRING        DomainName;
    UNICODE_STRING        ComputerName;
    UNICODE_STRING        OperatingSystem;
    UNICODE_STRING        LanmanType;
    UNICODE_STRING        Transports;
    UNICODE_STRING        ServersWithExtendedSessTimeout;
} SMBCE_CONTEXT,*PSMBCE_CONTEXT;

extern SMBCE_CONTEXT SmbCeContext;

extern RXCE_ADDRESS_EVENT_HANDLER    MRxSmbVctAddressEventHandler;
extern RXCE_CONNECTION_EVENT_HANDLER MRxSmbVctConnectionEventHandler;

extern PBYTE  s_pNegotiateSmb;
extern PBYTE  s_pNegotiateSmbRemoteBoot;
extern ULONG  s_NegotiateSmbLength;
extern PMDL   s_pNegotiateSmbBuffer;

extern PBYTE  s_pEchoSmb;
extern ULONG  s_EchoSmbLength;
extern PMDL   s_pEchoSmbMdl;

extern FAST_MUTEX MRxSmbSerializationMutex;

extern BOOLEAN MRxSmbEnableCompression;

extern BOOLEAN MRxSmbObeyBindingOrder;

// Miscellanous definitions

extern PBYTE MRxSmb_pPaddingData;

#define SMBCE_PADDING_DATA_SIZE (32)

typedef struct _MRXSMB_GLOBAL_PADDING {
    MDL Mdl;
    ULONG Pages[2]; //this can't possibly span more than two pages
    UCHAR Pad[SMBCE_PADDING_DATA_SIZE];
} MRXSMB_GLOBAL_PADDING, *PMRXSMB_GLOBAL_PADDING;

extern MRXSMB_GLOBAL_PADDING MrxSmbCeGlobalPadding;

extern PEPROCESS    RDBSSProcessPtr;
extern PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

#define RxNetNameTable (*(MRxSmbDeviceObject->pRxNetNameTable))

extern LONG MRxSmbNumberOfSrvOpens;

extern PVOID MRxSmbPoRegistrationState;

NTKERNELAPI
PVOID
PoRegisterSystemState (
    IN PVOID StateHandle,
    IN EXECUTION_STATE Flags
    );

NTKERNELAPI
VOID
PoUnregisterSystemState (
    IN PVOID StateHandle
    );

//
// MRxSmbSecurityInitialized indicates whether MRxSmbInitializeSecurity
// has been called.
//

extern BOOLEAN MRxSmbSecurityInitialized;

//
// MRxSmbBootedRemotely indicates that the machine did a remote boot.
//

extern BOOLEAN MRxSmbBootedRemotely;

//
// MRxSmbUseKernelSecurity indicates that the machine should use kernel mode security APIs
// during this remote boot boot.
//

extern BOOLEAN MRxSmbUseKernelModeSecurity;


#if defined(REMOTE_BOOT)
extern BOOLEAN MRxSmbOplocksDisabledOnRemoteBootClients;
#endif // defined(REMOTE_BOOT)

//
// These variables will, in the near future, be passed from the kernel to the
// redirector to tell it which share is the remote boot share and how to log on
// to the server.
//

extern PKEY_VALUE_PARTIAL_INFORMATION MRxSmbRemoteBootRootValue;
extern PKEY_VALUE_PARTIAL_INFORMATION MRxSmbRemoteBootMachineDirectoryValue;
extern UNICODE_STRING MRxSmbRemoteBootShare;
extern UNICODE_STRING MRxSmbRemoteBootPath;
extern UNICODE_STRING MRxSmbRemoteSetupPath;
extern UNICODE_STRING MRxSmbRemoteBootMachineName;
extern UNICODE_STRING MRxSmbRemoteBootMachinePassword;
extern UNICODE_STRING MRxSmbRemoteBootMachineDomain;
extern UCHAR MRxSmbRemoteBootMachineSid[RI_SECRET_SID_SIZE];
extern RI_SECRET MRxSmbRemoteBootSecret;
#if defined(REMOTE_BOOT)
extern BOOLEAN MRxSmbRemoteBootSecretValid;
extern BOOLEAN MRxSmbRemoteBootDoMachineLogon;
extern BOOLEAN MRxSmbRemoteBootUsePassword2;
#endif // defined(REMOTE_BOOT)

#if defined(REMOTE_BOOT)
typedef struct _RBR_PREFIX {
    UNICODE_PREFIX_TABLE_ENTRY TableEntry;
    UNICODE_STRING Prefix;
    BOOLEAN Redirect;
} RBR_PREFIX, *PRBR_PREFIX;

extern UNICODE_STRING MRxSmbRemoteBootRedirectionPrefix;
extern UNICODE_PREFIX_TABLE MRxSmbRemoteBootRedirectionTable;
#endif // defined(REMOTE_BOOT)

#define MAXIMUM_PARTIAL_BUFFER_SIZE  65535  // Maximum size of a partial MDL

#define MAXIMUM_SMB_BUFFER_SIZE 4356

// The following scavenge interval is in seconds
#define MRXSMB_V_NETROOT_CONTEXT_SCAVENGER_INTERVAL (40)

// the following default interval for timed exchanges is in seconds
#define MRXSMB_DEFAULT_TIMED_EXCHANGE_EXPIRY_TIME    (60)

//
// The following are some defines for controling name cache behavior.
// -- The max number of entries in a name cache before it will stop creating new
// entries.
//
#define NAME_CACHE_NETROOT_MAX_ENTRIES 200
//
// -- The expiration life times for file not found and get file attributes
// in seconds.
//
#define NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME 5
#define NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME 7
//
// -- Incrementing NameCacheGFAInvalidate invalidates the contents
// of the GFA name cache.
//
// Code.Bug:  These increments need to be added on paths where dirs can be
// deleted/renamed.
//
// Code.Improvment: Currently this is rdr wide, an improvement
// would be to make it per SRV_CALL.  The same is true for file not found cache
// which currently uses MRxSmbStatistics.SmbsReceived.LowPart for a cache entry
// validation context.  I.E. any received SMB invalidates the file not found cache.
//
extern ULONG NameCacheGFAInvalidate;

//CODE.IMPROVEMENT this should be moved up AND used consistly throughout. since this is in terms
//                 of IoBuildPartial it would be straightforward to find them all by
//                 undeffing RxBuildPartialMdl

#define RxBuildPartialMdlUsingOffset(SourceMdl,DestinationMdl,Offset,Length) \
        IoBuildPartialMdl(SourceMdl,\
                          DestinationMdl,\
                          (PBYTE)MmGetMdlVirtualAddress(SourceMdl)+Offset,\
                          Length)

#define RxBuildPaddingPartialMdl(DestinationMdl,Length) \
        RxBuildPartialMdlUsingOffset(&MrxSmbCeGlobalPadding.Mdl,DestinationMdl,0,Length)


//we turn away async operations that are not wait by posting. if we can wait
//then we turn off the sync flag so that things will just act synchronous
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {        \
        if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)) {               \
            ClearFlag(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);   \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return(RX_MAP_STATUS(PENDING));                                \
        }                                                                  \
    }                                                                      \
  }


typedef struct _MRXSMB_CONFIGURATION_DATA_ {
   ULONG   NamedPipeDataCollectionTimeInterval;
   ULONG   NamedPipeDataCollectionSize;
   ULONG   MaximumNumberOfCommands;
   ULONG   SessionTimeoutInterval;
   ULONG   LockQuota;
   ULONG   LockIncrement;
   ULONG   MaximumLock;
   ULONG   PipeIncrement;
   ULONG   PipeMaximum;
   ULONG   CachedFileTimeout;
   ULONG   DormantFileTimeout;
   ULONG   DormantFileLimit;
   ULONG   NumberOfMailslotBuffers;
   ULONG   MaximumNumberOfThreads;
   ULONG   ConnectionTimeoutInterval;
   ULONG   CharBufferSize;

   BOOLEAN UseOplocks;
   BOOLEAN UseUnlocksBehind;
   BOOLEAN UseCloseBehind;
   BOOLEAN BufferNamedPipes;
   BOOLEAN UseLockReadUnlock;
   BOOLEAN UtilizeNtCaching;
   BOOLEAN UseRawRead;
   BOOLEAN UseRawWrite;
   BOOLEAN UseEncryption;

} MRXSMB_CONFIGURATION, *PMRXSMB_CONFIGURATION;

extern MRXSMB_CONFIGURATION MRxSmbConfiguration;

// this is to test long net roots using the smbminirdr (which doesn't actually have 'em)
// don't turn this on..........
//#define ZZZ_MODE 1

//
// Definitions for starting stopping theSMB mini redirector
//

typedef enum _MRXSMB_STATE_ {
   MRXSMB_STARTABLE,
   MRXSMB_START_IN_PROGRESS,
   MRXSMB_STARTED,
   MRXSMB_STOPPED
} MRXSMB_STATE,*PMRXSMB_STATE;

extern MRXSMB_STATE MRxSmbState;

extern
NTSTATUS
MRxSmbInitializeSecurity (VOID);

extern
NTSTATUS
MRxSmbUninitializeSecurity (VOID);

extern
NTSTATUS
MRxSmbInitializeTransport(VOID);

extern
NTSTATUS
MRxSmbUninitializeTransport(VOID);

extern
NTSTATUS
MRxSmbRegisterForPnpNotifications();

extern
NTSTATUS
MRxSmbDeregisterForPnpNotifications();

extern NTSTATUS
MRxSmbLogonSessionTerminationHandler(
    PLUID LogonId);

extern NTSTATUS
SmbCeEstablishConnection(
    IN PMRX_V_NET_ROOT            pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot);

extern NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT        pVNetRoot);

NTSTATUS
SmbCeGetComputerName(
   VOID
   );

NTSTATUS
SmbCeGetOperatingSystemInformation(
   VOID
   );

#endif _MRXGLBL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\mssndrcv.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    mssndrcv.h

Abstract:

    This is the include file that defines all constants and types for mailslot
    related transports.

Revision History:

    Balan Sethu Raman (SethuR) 06-June-95    Created

Notes:

--*/

#ifndef _MSSNDRCV_H_
#define _MSSNDRCV_H_

typedef struct SMBCE_SERVER_MAILSLOT_TRANSPORT {
   SMBCE_SERVER_TRANSPORT;                             // Anonymous struct for common fields
   ULONG                       TransportAddressLength;
   PTRANSPORT_ADDRESS          pTransportAddress;
} SMBCE_SERVER_MAILSLOT_TRANSPORT, *PSMBCE_SERVER_MAILSLOT_TRANSPORT;


#endif // _MSSNDRCV_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\nvisible.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NVisible.h

Abstract:

    This module declares a number of flag variables that are essentially private
    to various modules but which are exposed so that they can be initialized from
    the registry and/or modified by fsctls. This should not be in precomp.h.

Revision History:

--*/

#ifndef _INVISIBLE_INCLUDED_
#define _INVISIBLE_INCLUDED_

extern ULONG MRxSmbNegotiateMask;  //controls which protocols are not negotiated

extern BOOLEAN MRxSmbDeferredOpensEnabled;
extern BOOLEAN MRxSmbOplocksDisabled;

#endif // _INVISIBLE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\ntbowsif.h ===
/***********
//joejoe

Joelinn 2-13-95

This is the pits......i have to pull in the browser in order to be started form
the lanman network provider DLL. the browser should be moved elsewhere........

**********************/



/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    disccode.h

Abstract:

    This module implements the discardable code routines for the NT redirector

Author:

    Larry Osterman (LarryO) 12-Nov-1993

Revision History:

     12-Nov-1993 LarryO

        Created


--*/


#ifndef _DISCCODE_
#define _DISCCODE_


typedef enum {
    RdrFileDiscardableSection,
    RdrVCDiscardableSection,
    RdrConnectionDiscardableSection,
    BowserDiscardableCodeSection,
    BowserNetlogonDiscardableCodeSection,
    RdrMaxDiscardableSection
} DISCARDABLE_SECTION_NAME;

VOID
RdrReferenceDiscardableCode(
    IN DISCARDABLE_SECTION_NAME SectionName
    );

VOID
RdrDereferenceDiscardableCode(
    IN DISCARDABLE_SECTION_NAME SectionName
    );

VOID
RdrInitializeDiscardableCode(
    VOID
    );

VOID
RdrUninitializeDiscardableCode(
    VOID
    );

typedef struct _RDR_SECTION {
    LONG ReferenceCount;
    BOOLEAN Locked;
    BOOLEAN TimerCancelled;
    PKTIMER Timer;
    KEVENT TimerDoneEvent;
    PVOID CodeBase;
    PVOID CodeHandle;
    PVOID DataBase;
    PVOID DataHandle;
} RDR_SECTION, *PRDR_SECTION;

extern
RDR_SECTION
RdrSectionInfo[];

#define RdrIsDiscardableCodeReferenced(SectionName) \
    (BOOLEAN)((RdrSectionInfo[SectionName].ReferenceCount != 0) && \
              RdrSectionInfo[SectionName].Locked)


#endif // _DISCCODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\ntsecure.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#include <exsessup.h>
#include "ntlsapi.h"
#include "mrxsec.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildSessionSetupSecurityInformation)
#pragma alloc_text(PAGE, BuildTreeConnectSecurityInformation)
#endif

extern BOOLEAN EnablePlainTextPassword;

NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pSmbBuffer - the SMB buffer

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;

    STRING CaseSensitiveResponse;
    STRING CaseInsensitiveResponse;

    PVOID  pSecurityBlob;
    USHORT SecurityBlobSize;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    SECURITY_RESPONSE_CONTEXT ResponseContext;
    
    KAPC_STATE     ApcState;
    BOOLEAN        AttachToSystemProcess = FALSE;
    ULONG    BufferSize = *pSmbBufferSize;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("BuildSessionSetupSecurityInformation -- Entry\n"));

    SmbLog(LOG,
           BuildSessionSetupSecurityInformation,
           LOGPTR(pSession)
           LOGULONG(pSession->LogonId.HighPart)
           LOGULONG(pSession->LogonId.LowPart));

    if ((pServer->DialectFlags & DF_EXTENDED_SECURITY) &&
        !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

        //
        // For uplevel servers, this gets handled all at once:
        //

        PREQ_NT_EXTENDED_SESSION_SETUP_ANDX pExtendedNtSessionSetupReq;
        PBYTE    pBuffer    = pSmbBuffer;

        // Position the buffer for copying the security blob
        pBuffer += FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);
        BufferSize -= FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);

        pExtendedNtSessionSetupReq = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)pSmbBuffer;

        pSecurityBlob = pBuffer ;
        SecurityBlobSize = (USHORT) BufferSize ;

        Status = BuildExtendedSessionSetupResponsePrologue(
                     pExchange,
                     pSecurityBlob,
                     &SecurityBlobSize,
                     &ResponseContext);

        if ( NT_SUCCESS( Status ) )
        {
            SmbPutUshort(
                &pExtendedNtSessionSetupReq->SecurityBlobLength,
                SecurityBlobSize);
            
            BufferSize -= SecurityBlobSize;
        }

    } else {
        if (!MRxSmbUseKernelModeSecurity &&
            !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
            //NTRAID-455636-2/2/2000-yunlin We should consolidate three routines calling LSA into one
            Status = BuildExtendedSessionSetupResponsePrologueFake(pExchange);

            if (Status != STATUS_SUCCESS) {
                goto FINALLY;
            }
        }
        
        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveResponse,
                     &CaseInsensitiveResponse,
                     &ResponseContext);

        if (Status == STATUS_SUCCESS) {
            // If the security package returns us the credentials corresponding to a
            // NULL session mark the session as a NULL session. This will avoid
            // conflicts with the user trying to present the credentials for a NULL
            // session, i.e., explicitly specified zero length passwords, user name
            // and domain name.

            RxDbgTrace(0,Dbg,("Session %lx UN Length %lx DN length %ld IR length %ld SR length %ld\n",
                              pSession,UserName.Length,DomainName.Length,
                              CaseInsensitiveResponse.Length,CaseSensitiveResponse.Length));

            if ((UserName.Length == 0) &&
                (DomainName.Length == 0) &&
                (CaseSensitiveResponse.Length == 0) &&
                (CaseInsensitiveResponse.Length == 1)) {
                RxDbgTrace(0,Dbg,("Implicit NULL session setup\n"));
                pSession->Flags |= SMBCE_SESSION_FLAGS_NULL_CREDENTIALS;
            } else {
                if( pServerEntry->SecuritySignaturesEnabled == TRUE &&
                    pServerEntry->SecuritySignaturesActive == FALSE &&
                    !FlagOn(pSession->Flags, SMBCE_SESSION_FLAGS_GUEST_SESSION)) {

                    if (FlagOn(pSession->Flags, SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED)) {
                        UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

                        RtlZeroMemory(SessionKey, sizeof(SessionKey));
                        RtlCopyMemory(SessionKey, pSession->LanmanSessionKey, MSV1_0_LANMAN_SESSION_KEY_LENGTH);

                        SmbInitializeSmbSecuritySignature(pServer,
                                                          SessionKey,
                                                          CaseInsensitiveResponse.Buffer,
                                                          CaseInsensitiveResponse.Length);
                    } else{
                        SmbInitializeSmbSecuritySignature(pServer,
                                                          pSession->UserSessionKey,
                                                          CaseSensitiveResponse.Buffer,
                                                          CaseSensitiveResponse.Length);
                    }
                }
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        PBYTE    pBuffer    = pSmbBuffer;

        if (pServer->Dialect == NTLANMAN_DIALECT) {
            if (FlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY) &&
                !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

                //
                // Already done above
                //
                NOTHING ;
            } else {
                //PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;
                PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetupReq = (PREQ_NT_SESSION_SETUP_ANDX)pSmbBuffer;

                // It it is a NT server both the case insensitive and case sensitive passwords
                // need to be copied. for share-level, just copy a token 1-byte NULL password

                // Position the buffer for copying the password.
                pBuffer += FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
                BufferSize -= FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
                SmbPutUlong(&pNtSessionSetupReq->Reserved,0);

                if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){
                    RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtUserPasswords\n"));

                    if (pServer->EncryptPasswords) {
                        
                        SmbPutUshort(
                            &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                            CaseInsensitiveResponse.Length);

                        SmbPutUshort(
                            &pNtSessionSetupReq->CaseSensitivePasswordLength,
                            CaseSensitiveResponse.Length);

                        Status = SmbPutString(
                                     &pBuffer,
                                     &CaseInsensitiveResponse,
                                     &BufferSize);

                        if (NT_SUCCESS(Status)) {
                            Status = SmbPutString(
                                         &pBuffer,
                                         &CaseSensitiveResponse,
                                         &BufferSize);
                        }
                    } else if (EnablePlainTextPassword) {
                        if (pSession->pPassword != NULL) {
                            if (FlagOn(pServer->DialectFlags,DF_UNICODE)) {
                                PBYTE pTempBuffer = pBuffer;
                                
                                *pBuffer = 0;
                                pBuffer = ALIGN_SMB_WSTR(pBuffer);
                                BufferSize -= (ULONG)(pBuffer - pTempBuffer);
                                
                                SmbPutUshort(
                                    &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                                    0);

                                SmbPutUshort(
                                    &pNtSessionSetupReq->CaseSensitivePasswordLength,
                                    pSession->pPassword->Length + 2);

                                Status = SmbPutUnicodeString(
                                             &pBuffer,
                                             pSession->pPassword,
                                             &BufferSize);
                            } else {
                                SmbPutUshort(
                                    &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                                    pSession->pPassword->Length/2 + 1);

                                SmbPutUshort(
                                    &pNtSessionSetupReq->CaseSensitivePasswordLength,
                                    0);

                                Status = SmbPutUnicodeStringAsOemString(
                                             &pBuffer,
                                             pSession->pPassword,
                                             &BufferSize);
                            }
                        } else {
                            SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength,0);
                            SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength,1);
                            *pBuffer++ = '\0';
                            BufferSize -= sizeof(CHAR);
                        }
                    } else {
                        Status = STATUS_LOGIN_WKSTA_RESTRICTION;
                    }
                } else {
                    RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtSharePasswords\n"));
                    
                    SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength, 1);
                    SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength, 1);
                    *pBuffer = 0;
                    *(pBuffer+1) = 0;
                    pBuffer += 2;
                    BufferSize -= 2;
                }
            }
        } else {
            PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);

            if ( (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL)
                && (CaseInsensitiveResponse.Length > 0)) {

                if (pServer->EncryptPasswords) {
                    // For other lanman servers only the case insensitive password is required.
                    SmbPutUshort(
                        &pSessionSetupReq->PasswordLength,
                        CaseInsensitiveResponse.Length);

                    // Copy the password
                    Status = SmbPutString(
                                 &pBuffer,
                                 &CaseInsensitiveResponse,
                                 &BufferSize);
                } else {
                    if (EnablePlainTextPassword) {
                        if (pSession->pPassword != NULL) {
                            SmbPutUshort(
                                &pSessionSetupReq->PasswordLength,
                                pSession->pPassword->Length/2 + 1);

                            Status = SmbPutUnicodeStringAsOemString(
                                         &pBuffer,
                                         pSession->pPassword,
                                         &BufferSize);
                        } else {
                            SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                            *pBuffer++ = '\0';
                            BufferSize -= sizeof(CHAR);
                        }
                    } else {
                        Status = STATUS_LOGIN_WKSTA_RESTRICTION;
                    }
                }
            } else {
                // Share level security. Send a null string for the password
                SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                *pBuffer++ = '\0';
                BufferSize -= sizeof(CHAR);
            }
        }

        // The User name and the domain name strings can be either copied from
        // the information returned in the request response or the information
        // that is already present in the session entry.
        if (NT_SUCCESS(Status) &&
            (!FlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY) ||
             FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION))) {
            if ((pServer->Dialect == NTLANMAN_DIALECT) &&
                (pServer->NtServer.NtCapabilities & CAP_UNICODE)) {
                // Copy the account/domain names as UNICODE strings
                PBYTE pTempBuffer = pBuffer;

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as unicode\n"));
                *pBuffer = 0;
                pBuffer = ALIGN_SMB_WSTR(pBuffer);
                BufferSize -= (ULONG)(pBuffer - pTempBuffer);

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);

                }
            } else {
                // Copy the account/domain names as ASCII strings.
                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as ascii\n"));
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeStringAsOemString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            *pSmbBufferSize = BufferSize;
        }
    }

    // Free the buffer allocated by the security package.
    if ((pServer->DialectFlags & DF_EXTENDED_SECURITY) &&
        !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
        BuildExtendedSessionSetupResponseEpilogue(&ResponseContext);
    } else {
        BuildNtLanmanResponseEpilogue(pExchange, &ResponseContext);
    }

    // Detach from the rdr process.
FINALLY:
    RxDbgTrace( -1, Dbg, ("BuildSessionSetupSecurityInformation -- Exit, status=%08lx\n",Status));
    return Status;
}

NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize)
/*++

Routine Description:

    This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pBuffer - the password buffer

    pPasswordLength - where the password length is to be stored

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS FinalStatus,Status;

    UNICODE_STRING UserName,DomainName;
    STRING         CaseSensitiveChallengeResponse,CaseInsensitiveChallengeResponse;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    ULONG PasswordLength = 0;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);
    
    KAPC_STATE     ApcState;
    BOOLEAN        AttachToSystemProcess = FALSE;
    
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (pServer->EncryptPasswords) {

        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveChallengeResponse,
                     &CaseInsensitiveChallengeResponse,
                     &ResponseContext);

        if (NT_SUCCESS(Status)) {
            if (FlagOn(pServer->DialectFlags,DF_MIXEDCASEPW)) {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case sensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseSensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveChallengeResponse,
                             pSmbBufferSize);
            } else {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case insensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseInsensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveChallengeResponse,
                             pSmbBufferSize);
            }

            BuildNtLanmanResponseEpilogue(pExchange, &ResponseContext);
        }

    } else {
        if (pSession->pPassword == NULL) {
            // The logon password cannot be sent as plain text. Send a Null string as password.

            PasswordLength = 1;
            if (*pSmbBufferSize >= 1) {
                *((PCHAR)pBuffer) = '\0';
                pBuffer += sizeof(CHAR);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else {
            if (EnablePlainTextPassword) {
                OEM_STRING OemString;

                OemString.Length = OemString.MaximumLength = (USHORT)(*pSmbBufferSize - sizeof(CHAR));
                OemString.Buffer = pBuffer;
                Status = RtlUnicodeStringToOemString(
                             &OemString,
                             pSession->pPassword,
                             FALSE);

                if (NT_SUCCESS(Status)) {
                    PasswordLength = OemString.Length+1;
                }
            } else {
                Status = STATUS_LOGON_FAILURE;
            }
        }

        // reduce the byte count
        *pSmbBufferSize -= PasswordLength;
    }

    SmbPutUshort(pPasswordLength,(USHORT)PasswordLength);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\mssndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mssndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's for
    mailslot related operations.

Revision History:

    Balan Sethu Raman     [SethuR]    6-June-1995

Notes:


--*/

#include "precomp.h"
#pragma hdrstop

#include "hostannc.h"
#include "mssndrcv.h"

// Forward references of functions ....
//

NTSTATUS
MsUninitialize(PVOID pTransport);

NTSTATUS
MsInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
MsTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
MsReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange);

NTSTATUS
MsSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
MsSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
MsInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
MsUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

VOID
MsTimerEventHandler(
   PVOID    pTransport);

NTSTATUS
MsInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport);


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MsInstantiateServerTransport)
#pragma alloc_text(PAGE, MsTranceive)
#pragma alloc_text(PAGE, MsReceive)
#pragma alloc_text(PAGE, MsSend)
#pragma alloc_text(PAGE, MsSendDatagram)
#pragma alloc_text(PAGE, MsInitializeExchange)
#pragma alloc_text(PAGE, MsUninitializeExchange)
#pragma alloc_text(PAGE, MsTimerEventHandler)
#pragma alloc_text(PAGE, MsInitiateDisconnect)
#endif

RXDT_DefineCategory(MSSNDRCV);
#define Dbg        (DEBUG_TRACE_MSSNDRCV)

extern TRANSPORT_DISPATCH_VECTOR MRxSmbMailSlotTransportDispatch;

#define SMBDATAGRAM_LOCAL_ENDPOINT_NAME "*SMBDATAGRAM    "


NTSTATUS
MsInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine initializes the MAILSLOT transport information corresponding to a server

    It allocates the transport address.  It constructs two address strutures for the server
    name: a NETBIOS_EX type address and a NETBIOS type address.  The latter only has up to the
    first 16 characters of the name, while a NETBIOS_EX may have more.

Arguments:

    pContext -  the transport construction context

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The remote address can be either deduced from the information in the Rx Context
    or a NETBIOS address needs to be built from the server name.
    This transport address is used subsequently to establish the connection.

    // The last character of the name depends upon the path name passed in.
    // There are currently four possible alternatives ....
    //
    // \\*\mailslot\...... => the primary domain is used for broadcasts
    // (This mapping is handled by the RDBSS)
    //
    // \\Uniquename\mailslot\.... => maps to either a computer name or a group
    // name for mailslot writes.
    //
    // \\DomainName*\mailslot\.... => maps to a netbios address of the form
    // domainname ...1c for broadcasts.
    //
    // \\DomainName**\mailslot\.... => maps to a netbios address of the form
    // domainname....1b for broadcasts.
    //
    // Initialize the NETBIOS address according to these formats.

    Nbt.SendDatagram only looks at the first address.  It is smart enough to treat a NETBIOS_EX
    address like a NETBIOS address when the length < NETBIOS_NAME_LEN.  So if the name is
    short enough, I fill in byte 15 of the name for the NETBIOS_EX case as well.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY            pServerEntry;
    PSMBCE_SERVER_MAILSLOT_TRANSPORT pMsTransport;
    UNICODE_STRING ServerName;
    OEM_STRING OemServerName;
    ULONG ServerNameLength;
    PTRANSPORT_ADDRESS pTA;
    PTA_ADDRESS taa;
    PTDI_ADDRESS_NETBIOS na;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MsInitialize : Mailslot Transport Initialization\n"));

    ASSERT(pContext->State == SmbCeServerMailSlotTransportConstructionBegin);

    pServerEntry = pContext->pServerEntry;

    pMsTransport = (PSMBCE_SERVER_MAILSLOT_TRANSPORT)
        RxAllocatePoolWithTag(
            NonPagedPool,
            sizeof(SMBCE_SERVER_MAILSLOT_TRANSPORT),
            MRXSMB_MAILSLOT_POOLTAG);

    if (pMsTransport != NULL) {
        RtlZeroMemory(pMsTransport,sizeof(SMBCE_SERVER_MAILSLOT_TRANSPORT));

        ServerName.Buffer        = pServerEntry->Name.Buffer + 1;
        ServerName.Length        = pServerEntry->Name.Length - sizeof(WCHAR);
        ServerName.MaximumLength = pServerEntry->Name.MaximumLength - sizeof(WCHAR);
        ServerNameLength = RtlUnicodeStringToOemSize(&ServerName) - 1;

        pMsTransport->TransportAddressLength =   FIELD_OFFSET(TRANSPORT_ADDRESS,Address)
            + (FIELD_OFFSET(TA_ADDRESS,Address))
            + TDI_ADDRESS_LENGTH_NETBIOS
            + 4 * sizeof(ULONG); // if the server name length is NETBIOS_NAME_LEN, 
                                 // RtlUpcaseUnicodeStringToOemString could overrun the buffer.

        if (ServerNameLength > NETBIOS_NAME_LEN) {
            pMsTransport->TransportAddressLength += ServerNameLength;
        }

        pMsTransport->pTransportAddress = (PTRANSPORT_ADDRESS)RxAllocatePoolWithTag(
            NonPagedPool,
            pMsTransport->TransportAddressLength,
            MRXSMB_MAILSLOT_POOLTAG);

        if (pMsTransport->pTransportAddress != NULL) {
            pTA = pMsTransport->pTransportAddress;

            pTA->TAAddressCount = 1;

            // *****************************************
            // FIRST ADDRESS: TDI_ADDRESS_TYPE_NETBIOS
            // *****************************************

            taa = pTA->Address;
            taa->AddressLength = (USHORT) TDI_ADDRESS_LENGTH_NETBIOS;

            if (ServerNameLength > NETBIOS_NAME_LEN) {
                taa->AddressLength += (USHORT)(ServerNameLength - NETBIOS_NAME_LEN);
            }

            taa->AddressType  = TDI_ADDRESS_TYPE_NETBIOS;

            na = (PTDI_ADDRESS_NETBIOS) taa->Address;
            na->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

            OemServerName.MaximumLength = (USHORT) (ServerNameLength + 1); // in case null term
            OemServerName.Buffer =  na->NetbiosName;
            Status = RtlUpcaseUnicodeStringToOemString(&OemServerName,
                                                       &ServerName,
                                                       FALSE);
            if (Status == STATUS_SUCCESS) {

                // Blank-pad the server name buffer if necessary to 16 characters
                if (OemServerName.Length <= NETBIOS_NAME_LEN) {
                    RtlCopyMemory(&OemServerName.Buffer[OemServerName.Length],
                                  "                ",
                                  NETBIOS_NAME_LEN - OemServerName.Length);
                }

                // Set type pneultimate byte in netbios name
                if (OemServerName.Buffer[OemServerName.Length - 1] == '*') {
                    if (OemServerName.Length <= NETBIOS_NAME_LEN ||
                        (OemServerName.Length == NETBIOS_NAME_LEN + 1 &&
                         OemServerName.Buffer[OemServerName.Length - 2] == '*')) {
                        if ((OemServerName.Length >= 2) &&
                            (OemServerName.Buffer[OemServerName.Length - 2] == '*')) {
                            if (OemServerName.Length <= NETBIOS_NAME_LEN) {
                                OemServerName.Buffer[OemServerName.Length - 1] = ' ';
                                OemServerName.Buffer[OemServerName.Length - 2] = ' ';
                            } else {
                                taa->AddressLength = (USHORT)TDI_ADDRESS_LENGTH_NETBIOS;
                            }
                            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = PRIMARY_CONTROLLER_SIGNATURE;
                        } else {
                            OemServerName.Buffer[OemServerName.Length - 1] = ' ';
                            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = DOMAIN_CONTROLLER_SIGNATURE;
                        }
                    } else {
                        Status = STATUS_BAD_NETWORK_PATH;
                    }
                } else {
                    OemServerName.Buffer[NETBIOS_NAME_LEN - 1]  = WORKSTATION_SIGNATURE;
                }
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RxDbgTrace(0, Dbg, ("MsInitialize : Memory Allocation failed\n"));
        }

        if (Status == STATUS_SUCCESS) {
            pMsTransport->pTransport = NULL;
            pMsTransport->State = SMBCEDB_ACTIVE;
            pMsTransport->pDispatchVector = &MRxSmbMailSlotTransportDispatch;
        } else {
            RxDbgTrace(0, Dbg, ("MsInitialize : Mailsslot transport initialization Failed %lx\n",
                                Status));
            MsUninitialize(pMsTransport);
            pMsTransport = NULL;
        }
    } else {
        RxDbgTrace(0, Dbg, ("MsInitialize : Memory Allocation failed\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        pContext->pMailSlotTransport = (PSMBCE_SERVER_TRANSPORT)pMsTransport;
    } else {
        pContext->pMailSlotTransport = NULL;
    }

    pContext->State = SmbCeServerMailSlotTransportConstructionEnd;
    pContext->Status = Status;

    return Status;
}

NTSTATUS
MsUninitialize(
         PSMBCE_SERVER_TRANSPORT pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pVcTransport - the VC transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

Notes:

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;
   PKEVENT pRundownEvent = pTransport->pRundownEvent;
   PSMBCE_SERVER_MAILSLOT_TRANSPORT  pMsTransport = (PSMBCE_SERVER_MAILSLOT_TRANSPORT)pTransport;

   PAGED_CODE();

   if (pMsTransport->pTransportAddress != NULL) {
      RxFreePool(pMsTransport->pTransportAddress);
   }

   RxFreePool(pMsTransport);

   if (pRundownEvent != NULL) {
       KeSetEvent(pRundownEvent, 0, FALSE );
   }
   
   return Status;
}

NTSTATUS
MsInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pTransport - the mailslot transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

--*/
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}


NTSTATUS
MsTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport   - the transport instance

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
   PAGED_CODE();

   return RX_MAP_STATUS(NOT_SUPPORTED);
}


NTSTATUS
MsReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport   - the transport instance

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_PENDING - the request has been queued

    Other Status codes correspond to error situations.

--*/
{
   PAGED_CODE();

   ASSERT(FALSE);
   return RX_MAP_STATUS(NOT_SUPPORTED);
}

NTSTATUS
MsSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the transport instance

    pServer    - the recepient server

    pVc        - the Vc on which the SMB is sent( if it is NULL SMBCE picks one)

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be sent

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                         Status = STATUS_CONNECTION_DISCONNECTED;
   NTSTATUS                         FinalStatus = STATUS_CONNECTION_DISCONNECTED;
   PSMBCE_SERVER_MAILSLOT_TRANSPORT pMsTransport;
   PSMBCE_TRANSPORT                 pDatagramTransport;
   BOOLEAN                          fAtleastOneSendWasSuccessful = FALSE;
   PSMBCE_TRANSPORT_ARRAY           pTransportArray;

   RXCE_CONNECTION_INFORMATION RxCeConnectionInformation;

   PAGED_CODE();

   pMsTransport = (PSMBCE_SERVER_MAILSLOT_TRANSPORT)pTransport;

   RxCeConnectionInformation.RemoteAddress       = pMsTransport->pTransportAddress;
   RxCeConnectionInformation.RemoteAddressLength = pMsTransport->TransportAddressLength;

   RxCeConnectionInformation.UserDataLength = 0;
   RxCeConnectionInformation.UserData       = NULL;

   RxCeConnectionInformation.OptionsLength  = 0;
   RxCeConnectionInformation.Options        = NULL;

   pTransportArray = SmbCeReferenceTransportArray();

   if (pTransportArray == NULL) {
       RxDbgTrace(0, Dbg, ("MsSend : Transport not available.\n"));
       return STATUS_NETWORK_UNREACHABLE;
   }

   if (pTransportArray != NULL) {
        ULONG i;

        for(i=0;i<pTransportArray->Count;i++) {
            pDatagramTransport = pTransportArray->SmbCeTransports[i];

            if (pDatagramTransport->Active &&
                (pDatagramTransport->RxCeTransport.pProviderInfo->MaxDatagramSize > 0)) {
                Status = RxCeSendDatagram(
                         &pDatagramTransport->RxCeAddress,
                         &RxCeConnectionInformation,
                         SendOptions,
                         pSmbMdl,
                         SendLength,
                         NULL);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg, ("MsSend: RxCeSendDatagram on transport (%lx) returned %lx\n",pTransport,Status));
                    FinalStatus = Status;
                } else {
                    fAtleastOneSendWasSuccessful = TRUE;
                }
            }
        }
   }

   SmbCeDereferenceTransportArray(pTransportArray);

   if (fAtleastOneSendWasSuccessful) {
      SmbCeSendCompleteInd(pServerEntry,pSendCompletionContext,RX_MAP_STATUS(SUCCESS));
      Status = RX_MAP_STATUS(SUCCESS);
   } else {
      Status = FinalStatus;
   }

   return Status;
}

NTSTATUS
MsSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the transport instance

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl     - the SMB that needs to be sent.

    SendLength  - length of data to be sent

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
   PAGED_CODE();

   ASSERT(FALSE);
   return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MsInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine initializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   return STATUS_SUCCESS;
}

NTSTATUS
MsUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine uninitializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}


VOID
MsTimerEventHandler(
   PVOID    pTransport)
/*++

Routine Description:

    This routine handles the periodic strobes to determine if the connection is still alive

Arguments:

    pTransport  - the recepient server

Notes:

   This routine is not implemented for mail slot related transports

--*/
{
    PAGED_CODE();
}

TRANSPORT_DISPATCH_VECTOR
MRxSmbMailSlotTransportDispatch = {
                                 MsSend,
                                 MsSendDatagram,
                                 MsTranceive,
                                 MsReceive,
                                 MsTimerEventHandler,
                                 MsInitializeExchange,
                                 MsUninitializeExchange,
                                 MsUninitialize,
                                 MsInitiateDisconnect
                              };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\netroot.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the SMB net root.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"
#include "dfsfsctl.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbUpdateNetRootState)
#pragma alloc_text(PAGE, MRxSmbGetDialectFlagsFromSrvCall)
#pragma alloc_text(PAGE, MRxSmbCreateVNetRoot)
#pragma alloc_text(PAGE, MRxSmbFinalizeNetRoot)
#pragma alloc_text(PAGE, SmbCeReconnect)
#pragma alloc_text(PAGE, SmbCeEstablishConnection)
#pragma alloc_text(PAGE, SmbConstructNetRootExchangeStart)
#pragma alloc_text(PAGE, MRxSmbExtractNetRootName)
#endif

//
// Forward declarations ...
//

extern NTSTATUS
SmbCeParseConstructNetRootResponse(
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
   PSMB_HEADER                     pSmbHeader,
   ULONG                           BytesAvailable,
   ULONG                           BytesIndicated,
   ULONG                           *pBytesTaken);

extern NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE  pExchange,
         BOOLEAN        *pPostFinalize);

typedef struct _SMBCE_NETROOT_CONSTRUCTION_CONTEXT {
    NTSTATUS                      Status;

    PMRX_CREATENETROOT_CONTEXT    pCreateNetRootContext;
    PMRX_V_NET_ROOT               pVNetRoot;

    RX_WORK_QUEUE_ITEM            WorkQueueItem;
} SMBCE_NETROOT_CONSTRUCTION_CONTEXT,
  *PSMBCE_NETROOT_CONSTRUCTION_CONTEXT;

NTSTATUS
MRxSmbCreateVNetRootOffLine(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext);

NTSTATUS
MRxSmbUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine update the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    By diffrentiating the mini redirewctor state from the net rot condition it is possible
    to permit a variety of reconnect strategies. It is conceivable that the RDBSS considers
    a net root to be good while the underlying mini redirector might mark it as invalid
    and reconnect on the fly.

--*/
{
    if (pNetRoot->MRxNetRootState == MRX_NET_ROOT_STATE_GOOD) {
        if (pNetRoot->Context == NULL) {
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
        } else {
            PSMBCEDB_SERVER_ENTRY   pServerEntry;

            pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);
            if (pServerEntry != NULL) {
                if (pServerEntry->Server.CscState == ServerCscDisconnected) {
                    pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
                } else {
                    switch (pServerEntry->Header.State) {
                    case SMBCEDB_ACTIVE:
                         pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
                         break;
                    case SMBCEDB_INVALID:
                         pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_DISCONNECTED;
                         break;
                    case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
                         pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_RECONN;
                         break;
                    default:
                         pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
                         break;
                    }
                }

                SmbCeDereferenceServerEntry(pServerEntry);
            } else {
                pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
            }
        }
    }

    return STATUS_SUCCESS;
}

ULONG
MRxSmbGetDialectFlagsFromSrvCall(
    PMRX_SRV_CALL SrvCall
    )
{
   ULONG DialectFlags;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   PAGED_CODE();

   pServerEntry = SmbCeReferenceAssociatedServerEntry(SrvCall);
   ASSERT(pServerEntry != NULL);
   DialectFlags = pServerEntry->Server.DialectFlags;
   SmbCeDereferenceServerEntry(pServerEntry);
   return(DialectFlags);
}

BOOLEAN
MRxSmbIsThisACscAgentOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the open was made by the user mode CSC agent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    TRUE - if it is an agent open, FALSE otherwise

Notes:

    The agent opens are always satisfied by going to the server. They are never
    satisfied from the cached copies. This enables reintegration using snapshots
    even when the files are being currently used.

--*/
{
    BOOLEAN AgentOpen = FALSE;
    ULONG   EaInformationLength;

    PDFS_NAME_CONTEXT pDfsNameContext;

    if (RxContext->Create.EaLength > 0) {
        PFILE_FULL_EA_INFORMATION pEaEntry;

        pEaEntry = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        ASSERT(pEaEntry != NULL);

        for(;;) {
            if (strcmp(pEaEntry->EaName, EA_NAME_CSCAGENT) == 0) {
                AgentOpen = TRUE;
                break;
            }

            if (pEaEntry->NextEntryOffset == 0) {
                break;
            } else {
                pEaEntry = (PFILE_FULL_EA_INFORMATION)
                           ((PCHAR) pEaEntry + pEaEntry->NextEntryOffset);
            }
        }
    }

    pDfsNameContext = RxContext->Create.NtCreateParameters.DfsNameContext;

    if ((pDfsNameContext != NULL) &&
        (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT)) {
        AgentOpen = TRUE;
    }

    return AgentOpen;
}

NTSTATUS
MRxSmbCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

   In case the connection cannot be established, the mini redirector tries to transition
   the VNetRoot into disconnected mode and establishes the connection off-line. If the
   connection failes to establish in the synchronouse way, this routine will do the transition;
   Otherwise, SmbConstructNetRootExchangeFinalize routine will try the transition. In both
   cases, MRxSmbCreateVNetRoot will be called again to establish the connection in disconnected
   mode.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:
    CODE.IMPROVEMENT --  The net root create context must supply the open mode in order
    to enable the mini redirector to implement a wide variety of reconnect strategies.

--*/
{
    NTSTATUS  Status = STATUS_MORE_PROCESSING_REQUIRED;
    PRX_CONTEXT pRxContext = pCreateNetRootContext->RxContext;
    PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PUNICODE_STRING pNetRootName,pSrvCallName;

    BOOLEAN  fInitializeNetRoot;
    BOOLEAN  fDeferNetworkInitialization = FALSE;
    BOOLEAN  fCscAgentOpen = FALSE;
    BOOLEAN  fDisconnectedOperation;
    BOOLEAN  CallBack = FALSE;
    extern DWORD   hShareReint;

    PAGED_CODE();

    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    if ((pRxContext != NULL) &&
        (pRxContext->MajorFunction == IRP_MJ_CREATE)) {
        fCscAgentOpen = MRxSmbIsThisACscAgentOpen(pRxContext);

        if (pRxContext->Create.ThisIsATreeConnectOpen){
            // Determine if this tree connect was initiated by a CSC agent
            InterlockedIncrement(&MRxSmbStatistics.UseCount);
        }

        fDeferNetworkInitialization = pRxContext->Create.TreeConnectOpenDeferred;
    }

    SmbCeLog(("SmbCreateVNetRoot CscAgent %x %wZ \n",fCscAgentOpen,pNetRoot->pNetRootName));

    SmbLog(LOG,
           MRxSmbCreateVNetRoot,
           LOGUCHAR(fCscAgentOpen)
           LOGUSTR(*pNetRoot->pNetRootName));

    fInitializeNetRoot = (pNetRoot->Context == NULL);

    fDisconnectedOperation = (SmbCeIsServerInDisconnectedMode(pServerEntry) &&
                              !fCscAgentOpen);

    if (fCscAgentOpen &&
        SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        // this is an EA open. we want this one to succeed but want others to still
        // stay offline till an ioctl comes down to say we want to transition

        CscPrepareServerEntryForOnlineOperationPartial(pServerEntry);
    }

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
           (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

    if (pNetRoot->Type == NET_ROOT_MAILSLOT) {
        pVNetRoot->Context = NULL;
        Status = STATUS_SUCCESS;
        RxDbgTrace( 0, Dbg, ("Mailslot open\n"));
    } else if ((pNetRoot->Type == NET_ROOT_PIPE) &&
               (pServerEntry->Header.State == SMBCEDB_ACTIVE)) {
        if (fDisconnectedOperation) {
            pVNetRoot->Context = NULL;
            Status = STATUS_BAD_NETWORK_NAME;
        } else if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER &&
                   !FlagOn(MRxSmbGetDialectFlagsFromSrvCall(pSrvCall),DF_LANMAN10)) {
            pVNetRoot->Context = NULL;
            Status = STATUS_NOT_SUPPORTED;
            RxDbgTrace( 0, Dbg, ("pipe open to core server\n"));
        }
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        Status = SmbCeFindOrConstructVNetRootContext(
                     pVNetRoot,
                     fDeferNetworkInitialization,
                     fCscAgentOpen);
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        // Update the flags on the VNetRootContext to indicate if this is a
        // agent open

        Status = SmbCeEstablishConnection(
                     pVNetRoot,
                     pCreateNetRootContext,
                     fInitializeNetRoot);
    }

    if (Status != STATUS_PENDING) {
        if (fCscAgentOpen && Status == STATUS_RETRY) {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        if (!NT_SUCCESS(Status)) {
            if (!fCscAgentOpen &&
                !SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                // if it cannot establish the connect and didn't get chance to transition
                // into disconnected state, we should try the transition and if succeed,
                // establish the connect again in the disconnected state.

                Status = CscTransitionVNetRootForDisconnectedOperation(
                             pCreateNetRootContext->RxContext,
                             pVNetRoot,
                             Status);
            }

            if (fInitializeNetRoot &&
                (pNetRoot->Context != NULL)) {
                PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

                SmbCeAcquireResource();

                pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pNetRoot);

                if (pNetRootEntry != NULL) {
                    pNetRootEntry->pRdbssNetRoot = NULL;
                    SmbCeDereferenceNetRootEntry(pNetRootEntry);
                }

                pNetRoot->Context = NULL;

                SmbCeReleaseResource();
            }

            SmbCeDestroyAssociatedVNetRootContext(pVNetRoot);

            if ((pRxContext != NULL) &&
                (pRxContext->MajorFunction == IRP_MJ_CREATE) &&
                (pRxContext->Create.ThisIsATreeConnectOpen)) {
                InterlockedIncrement(&MRxSmbStatistics.FailedUseCount);
            }
        }

        pCreateNetRootContext->VirtualNetRootStatus = Status;

        if (fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;
        } else {
            pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
        }

        if (Status == STATUS_RETRY) {
            // STATUS_RETRY is returned from CscTransitionVNetRootForDisconnectedOperation if the
            // server entry is transitioned into disconnected mode.
            Status = MRxSmbCreateVNetRootOffLine(pCreateNetRootContext);

            if (Status != STATUS_SUCCESS) {
                // Callback the RDBSS for resumption if create VNetRootOffLine fails
                CallBack = TRUE;
            }
        } else {
            CallBack = TRUE;
        }

        // Map the error code to STATUS_PENDING since this triggers the synchronization
        // mechanism in the RDBSS.
        Status = STATUS_PENDING;
    }

    if (CallBack) {
        IF_NOT_MRXSMB_CSC_ENABLED{
            NOTHING;
        } else {
            if (pCreateNetRootContext->NetRootStatus == STATUS_SUCCESS){
                if ((pRxContext != NULL) &&
                    (pRxContext->MajorFunction == IRP_MJ_CREATE) &&
                    (pNetRoot->Type == NET_ROOT_DISK)) {
                    MRxSmbCscPartOfCreateVNetRoot(pRxContext,pNetRoot);
                }
            }
        }

        if (pServerEntry->Server.IsRemoteBootServer &&
            pCreateNetRootContext->NetRootStatus != STATUS_SUCCESS) {
            pCreateNetRootContext->NetRootStatus = STATUS_RETRY;
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_RETRY;
        }

        // Callback the RDBSS for resumption.
        pCreateNetRootContext->Callback(pCreateNetRootContext);
    }

    return Status;
}

NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry;

    // This cannot be paged code since we meed to protect the default session list with the lock

    RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeVNetRoot %lx\n",pVNetRoot));

    if (pVNetRoot->Context != NULL) {
        SmbCeDestroyAssociatedVNetRootContext(pVNetRoot);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeNetRoot %lx\n",pNetRoot));

    if (pNetRoot->Context != NULL) {
        SmbCeAcquireResource();

        pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pNetRoot);

        InterlockedCompareExchangePointer(
            &pNetRootEntry->pRdbssNetRoot,
            NULL,
            pNetRoot);

        SmbCeDereferenceNetRootEntry(pNetRootEntry);

        ASSERT(!FlagOn(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED));
        SetFlag(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED);

        SmbCeReleaseResource();
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeReconnectCallback(
   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext)
/*++

Routine Description:

   This routine signals the completion of a reconnect attempt

Arguments:

    pCreateNetRootContext - the net root context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   KeSetEvent(&pCreateNetRootContext->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}

NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot)
/*++

Routine Description:

   This routine reconnects, i.e, establishes a new session and tree connect to a previously
   connected serverb share

Arguments:

    pVNetRoot - the virtual net root instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext;

    PAGED_CODE();

    if ((pVNetRootContext != NULL) &&
        (pVNetRootContext->Header.State == SMBCEDB_ACTIVE)) {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pNetRootEntry = pVNetRootContext->pNetRootEntry;

        if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
            (pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
            (pNetRootEntry->Header.State == SMBCEDB_ACTIVE)) {
            return STATUS_SUCCESS;
        }
    }

    pCreateNetRootContext = (PMRX_CREATENETROOT_CONTEXT)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(MRX_CREATENETROOT_CONTEXT),
                                MRXSMB_NETROOT_POOLTAG);

    if (pCreateNetRootContext != NULL) {
        for (;;) {
            pCreateNetRootContext->pVNetRoot  = (PV_NET_ROOT)pVNetRoot;
            pCreateNetRootContext->NetRootStatus  = STATUS_SUCCESS;
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
            pCreateNetRootContext->Callback       = SmbCeReconnectCallback;
            pCreateNetRootContext->RxContext      = NULL;

            KeInitializeEvent(
                &pCreateNetRootContext->FinishEvent,
                SynchronizationEvent,
                FALSE );

            // Since this is a reconnect instance the net root initialization is not required
            Status = SmbCeEstablishConnection(
                         pVNetRoot,
                         pCreateNetRootContext,
                         FALSE);

            if (Status == STATUS_PENDING) {
                // Wait for the construction to be completed.
                KeWaitForSingleObject(
                    &pCreateNetRootContext->FinishEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                Status = pCreateNetRootContext->VirtualNetRootStatus;
            }

            if (Status != STATUS_LINK_FAILED) {
                break;
            }
        }

        RxFreePool(pCreateNetRootContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot
    )
/*++

Routine Description:

   This routine triggers off the connection attempt for initial establishment of a
   connection as well as subsequent reconnect attempts.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:
    CODE.IMPROVEMENT --  The net root create context must supply the open mode in order
    to enable the mini redirector to implement a wide variety of reconnect strategies.

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);
    
    if (pVNetRootContext == NULL) {
        Status = STATUS_BAD_NETWORK_PATH;
    } else {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pNetRootEntry = pVNetRootContext->pNetRootEntry;

        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        //
        // The following code initializes the NetRootEntry, VNetRootContext and
        // the session entry under certain cases.
        //
        // The session entry to a doenlevel server needs to be initialized. This
        // is not handled by the previous code since the session  entry and the
        // net root entry initialization can be combined into one exchange.
        //
        // The net root entry has not been initialized, i.e., this corresponds to
        // the construction of the first SMBCE_V_NET_ROOT_CONTEXT instance for a
        // given NetRootEntry.
        //
        // Subsequent SMBCE_V_NET_ROOT context constructions. In these cases the
        // construction of each context must obtain a new TID
        //

        BOOLEAN fNetRootExchangeRequired;

        fNetRootExchangeRequired = ((pSessionEntry->Header.State != SMBCEDB_ACTIVE) ||
                                   !BooleanFlagOn(pVNetRootContext->Flags,SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID));

        if (fNetRootExchangeRequired) {
            // This is a tree connect open which needs to be triggered immediately.
            PSMB_EXCHANGE                  pSmbExchange;
            PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

            pSmbExchange = SmbMmAllocateExchange(CONSTRUCT_NETROOT_EXCHANGE,NULL);
            if (pSmbExchange != NULL) {
                Status = SmbCeInitializeExchange(
                             &pSmbExchange,
                             NULL,
                             pVNetRoot,
                             CONSTRUCT_NETROOT_EXCHANGE,
                             &ConstructNetRootExchangeDispatch);

                if (Status == RX_MAP_STATUS(SUCCESS)) {
                    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pSmbExchange;

                    // Attempt to reconnect( In this case it amounts to establishing the
                    // connection/session)
                    pNetRootExchange->SmbCeFlags |= (SMBCE_EXCHANGE_ATTEMPT_RECONNECTS |
                                                   SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION);

                    // Initialize the continuation for resumption upon completion of the
                    // tree connetcion.
                    pNetRootExchange->NetRootCallback       = pCreateNetRootContext->Callback;
                    pNetRootExchange->pCreateNetRootContext = pCreateNetRootContext;
                    pNetRootExchange->RxContext = pCreateNetRootContext->RxContext;

                    pNetRootExchange->fInitializeNetRoot =  fInitializeNetRoot;

                    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC {
                        // Initiate the exchange.
                        Status = SmbCeInitiateExchange(pSmbExchange);

                        if (Status != STATUS_PENDING) {
                            SmbCeDiscardExchangeWorkerThreadRoutine(pSmbExchange);
                        }
                    } else {
                        if (!SmbCeIsServerInDisconnectedMode(pServerEntry) ||
                            FlagOn(
                                pVNetRootContext->Flags,
                                SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
                            // Initiate the exchange.
                            Status = SmbCeInitiateExchange(pSmbExchange);

                            if (Status != STATUS_PENDING) {
                                SmbCeDiscardExchangeWorkerThreadRoutine(pSmbExchange);
                            }
                        }  else {
                            //dont really initiate...just set up to call the completion
                            //routine which BTW discards the exchange
                            Status = MRxSmbCscDisconnectedConnect(pNetRootExchange);
                        }
                    }
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return Status;
}

//
// The net roots are normally constructed as part of some other exchange, i.e., the SMB for
// Tree connect is compounded with other operations. However, there is one situation in which
// the tree connect SMB needs to be sent by itself. This case refers to the prefix claim
// situation ( net use command ). This is handled by the construct net root exchange.
//

#define CONSTRUCT_NETROOT_BUFFER_SIZE (4096)

NTSTATUS
SmbConstructNetRootExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    NTSTATUS RequestLockStatus = STATUS_UNSUCCESSFUL;
    NTSTATUS ResponseLockStatus = STATUS_UNSUCCESSFUL;

    PVOID pSmbActualBuffer;
    PVOID pSmbBuffer;
    UCHAR SmbCommand,LastCommandInHeader;
    ULONG SmbLength;

    PUCHAR pCommand;

    PMDL  pSmbRequestMdl,pSmbResponseMdl;
    ULONG SmbMdlSize;

    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    PMRX_NET_ROOT pNetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

    PAGED_CODE();

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

    ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

    if ((pNetRoot->Type == NET_ROOT_PIPE) &&
        !FlagOn(pServerEntry->Server.DialectFlags,DF_LANMAN10)) {
        RxDbgTrace( 0, Dbg, ("pipe open to core server\n"));
        return STATUS_NOT_SUPPORTED;
    }

    pSmbRequestMdl = pSmbResponseMdl = NULL;

    pSmbActualBuffer = RxAllocatePoolWithTag(
                           PagedPool | POOL_COLD_ALLOCATION,
                           (CONSTRUCT_NETROOT_BUFFER_SIZE + TRANSPORT_HEADER_SIZE),
                           MRXSMB_NETROOT_POOLTAG);

    if (pSmbActualBuffer != NULL) {
        PSMBCE_SERVER pServer = SmbCeGetExchangeServer(pExchange);

        (PCHAR) pSmbBuffer = (PCHAR) pSmbActualBuffer + TRANSPORT_HEADER_SIZE;

        Status = SmbCeBuildSmbHeader(
                     pExchange,
                     pSmbBuffer,
                     CONSTRUCT_NETROOT_BUFFER_SIZE,
                     &SmbLength,
                     &LastCommandInHeader,
                     &pCommand);

        // Ensure that the NET_ROOT/SESSION still needs to be constructed before
        // sending it. It is likely that they were costructed by an earlier exchange
        if (NT_SUCCESS(Status) &&
            (SmbLength > sizeof(SMB_HEADER))) {

            if (LastCommandInHeader != SMB_COM_TREE_CONNECT){
                *pCommand = SMB_COM_NO_ANDX_COMMAND;
            }

            RxAllocateHeaderMdl(
                pSmbBuffer,
                SmbLength,
                pSmbRequestMdl
                );

            pSmbResponseMdl = RxAllocateMdl(pSmbBuffer,CONSTRUCT_NETROOT_BUFFER_SIZE);

            if ((pSmbRequestMdl != NULL) &&
                (pSmbResponseMdl != NULL)) {

                RxProbeAndLockHeaderPages(
                    pSmbRequestMdl,
                    KernelMode,
                    IoModifyAccess,
                    RequestLockStatus);

                RxProbeAndLockPages(
                    pSmbResponseMdl,
                    KernelMode,
                    IoModifyAccess,
                    ResponseLockStatus);

                if ((Status  == STATUS_SUCCESS) &&
                    ((Status = RequestLockStatus)  == STATUS_SUCCESS) &&
                    ((Status = ResponseLockStatus) == STATUS_SUCCESS)) {

                    pNetRootExchange->pSmbResponseMdl = pSmbResponseMdl;
                    pNetRootExchange->pSmbRequestMdl  = pSmbRequestMdl;
                    pNetRootExchange->pSmbActualBuffer = pSmbActualBuffer;
                    pNetRootExchange->pSmbBuffer      = pSmbBuffer;

                    Status = SmbCeTranceive(
                                 pExchange,
                                 (RXCE_SEND_PARTIAL | RXCE_SEND_SYNCHRONOUS),
                                 pNetRootExchange->pSmbRequestMdl,
                                 SmbLength);

                    RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if ((Status != STATUS_PENDING) &&
                (Status != STATUS_SUCCESS)) {

                pNetRootExchange->pSmbResponseMdl = NULL;
                pNetRootExchange->pSmbRequestMdl  = NULL;
                pNetRootExchange->pSmbActualBuffer = NULL;
                pNetRootExchange->pSmbBuffer      = NULL;

                if (pSmbResponseMdl != NULL) {
                    if (ResponseLockStatus == STATUS_SUCCESS) {
                        MmUnlockPages(pSmbResponseMdl);
                    }

                    IoFreeMdl(pSmbResponseMdl);
                }

                if (pSmbRequestMdl != NULL) {
                    if (RequestLockStatus == STATUS_SUCCESS) {
                        RxUnlockHeaderPages(pSmbRequestMdl);
                    }

                    IoFreeMdl(pSmbRequestMdl);
                }

                RxFreePool(pSmbActualBuffer);
            }
        } else {

            RxFreePool(pSmbActualBuffer);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbConstructNetRootExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN  PSMB_HEADER         pSmbHeader,
    OUT PMDL                *pDataBufferPointer,
    OUT PULONG              pDataSize,
    IN ULONG                ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status;

    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));

    if (BytesAvailable > BytesIndicated ||
        !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE)) {
        // The SMB response was not completely returned. Post a copy data request to
        // get the remainder of the response. If the response is greater than the original
        // buffer size, abort this connection request and consume the bytes available.

        if (BytesAvailable > CONSTRUCT_NETROOT_BUFFER_SIZE) {
            ASSERT(!"not enough bytes in parsesmbheader.....sigh.............."); // To be removed soon ...
            pExchange->Status = STATUS_NOT_IMPLEMENTED;
            *pBytesTaken = BytesAvailable;
            Status       = RX_MAP_STATUS(SUCCESS);
        } else {
            *pBytesTaken        = 0;
            *pDataBufferPointer = pNetRootExchange->pSmbResponseMdl;
            *pDataSize          = CONSTRUCT_NETROOT_BUFFER_SIZE;
            Status              = STATUS_MORE_PROCESSING_REQUIRED;
        }
    } else {
        // The SMB exchange completed without an error.
        pExchange->Status = SmbCeParseConstructNetRootResponse(
                                 pNetRootExchange,
                                 pSmbHeader,
                                 BytesAvailable,
                                 BytesIndicated,
                                 pBytesTaken);

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",*pBytesTaken));
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader Return Status %lx\n",pExchange->Status));
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
SmbConstructNetRootExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL       pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

    PSMB_HEADER pSmbHeader;
    ULONG       ResponseSize = DataSize;
    ULONG       ResponseBytesConsumed = 0;
    NTSTATUS    Status = STATUS_SUCCESS;

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;
    ASSERT(pCopyDataBuffer == pNetRootExchange->pSmbResponseMdl);

    pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pNetRootExchange->pSmbResponseMdl,LowPagePriority);

    if (pSmbHeader != NULL) {
        pExchange->Status = SmbCeParseConstructNetRootResponse(
                               pNetRootExchange,
                               pSmbHeader,
                               ResponseSize,
                               ResponseSize,
                               &ResponseBytesConsumed);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",ResponseBytesConsumed));

    return Status;
}

NTSTATUS
SmbCeParseConstructNetRootResponse(
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
    PSMB_HEADER                     pSmbHeader,
    ULONG                           BytesAvailable,
    ULONG                           BytesIndicated,
    ULONG                           *pBytesTaken)
{
    NTSTATUS     Status,SmbResponseStatus;
    GENERIC_ANDX CommandToProcess;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated %ld\n",BytesIndicated));
    Status = SmbCeParseSmbHeader(
                 (PSMB_EXCHANGE)pNetRootExchange,
                 pSmbHeader,
                 &CommandToProcess,
                 &SmbResponseStatus,
                 BytesAvailable,
                 BytesIndicated,
                 pBytesTaken);

    if (Status == STATUS_SUCCESS) {
        *pBytesTaken = BytesIndicated;
    }

    return Status;
}


NTSTATUS
SmbConstructNetRootExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalizes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;
    PMRX_CREATENETROOT_CONTEXT      pCreateNetRootContext;
    PMRX_NETROOT_CALLBACK           pNetRootCallback;

    PMRX_V_NET_ROOT pVNetRoot;
    PMRX_NET_ROOT   pNetRoot;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    NTSTATUS Status = pExchange->Status;

    if (RxShouldPostCompletion()) {
        *pPostFinalize = TRUE;
        return STATUS_SUCCESS;
    } else {
        *pPostFinalize = FALSE;
    }

    pVNetRoot = SmbCeGetExchangeVNetRoot(pExchange);
    pNetRoot  = pVNetRoot->pNetRoot;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);

    ASSERT((pVNetRoot == NULL) || (pVNetRoot->pNetRoot == pNetRoot));
    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;
    pNetRootCallback = pNetRootExchange->NetRootCallback;

    ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

    pCreateNetRootContext = pNetRootExchange->pCreateNetRootContext;

    pCreateNetRootContext->VirtualNetRootStatus = RX_MAP_STATUS(SUCCESS);
    pCreateNetRootContext->NetRootStatus        = RX_MAP_STATUS(SUCCESS);

    RxDbgTrace(0,Dbg,("SmbConstructNetRootExchangeFinalize: Net Root Exchange Status %lx\n", pExchange->Status));
    if (!NT_SUCCESS(pExchange->Status)) {
        if (pCreateNetRootContext->RxContext &&
            pCreateNetRootContext->RxContext->Create.ThisIsATreeConnectOpen){
            InterlockedIncrement(&MRxSmbStatistics.FailedUseCount);
        }

        if (!SmbCeIsServerInDisconnectedMode(pServerEntry) &&
            !FlagOn(pVNetRootContext->Flags,SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
            // if it cannot establish the connect and didn't get chance to transition
            // into disconnected state, we should try the transition and if succeed,
            // establish the connect again in the disconnected state.

            Status = CscTransitionVNetRootForDisconnectedOperation(
                                   pCreateNetRootContext->RxContext,
                                   pVNetRoot,
                                   pExchange->Status);
        }

        pCreateNetRootContext->VirtualNetRootStatus = Status;

        if (pCreateNetRootContext->VirtualNetRootStatus == STATUS_INVALID_HANDLE) {
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_UNEXPECTED_NETWORK_ERROR;
        }

        if (pNetRootExchange->fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;

            if (pCreateNetRootContext->NetRootStatus == STATUS_INVALID_HANDLE) {
                pCreateNetRootContext->NetRootStatus = STATUS_UNEXPECTED_NETWORK_ERROR;
            }
        }

        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            SMBCEDB_MARKED_FOR_DELETION);
    } else {
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

        pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

        if(pCreateNetRootContext->RxContext)
        {
            MRxSmbCscPartOfCreateVNetRoot(pCreateNetRootContext->RxContext, pNetRoot);
        }

        // Update the associated wrapper data structures.
        SmbCeUpdateNetRoot(pNetRootEntry,pNetRoot);
    }

    SmbCeReferenceVNetRootContext(pVNetRootContext);
    SmbCeCompleteVNetRootContextInitialization(pVNetRootContext);
    pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;

    ASSERT((pCreateNetRootContext->VirtualNetRootStatus != STATUS_SUCCESS) || (pVNetRoot->Context != NULL));

    if ((pCreateNetRootContext->NetRootStatus == STATUS_CONNECTION_RESET)||(pCreateNetRootContext->NetRootStatus == STATUS_IO_TIMEOUT))
    {
        SmbCeLog(("!!Remote Reset Status=%x\n", pCreateNetRootContext->NetRootStatus));
        SmbLogError(pCreateNetRootContext->NetRootStatus,
                    LOG,
                    SmbConstructNetRootExchangeFinalize,
                    LOGULONG(pCreateNetRootContext->NetRootStatus)
                    LOGPTR(pNetRoot)
                    LOGUSTR(*pNetRoot->pNetRootName));
    }

    if (pNetRootExchange->pSmbResponseMdl != NULL) {
        MmUnlockPages(pNetRootExchange->pSmbResponseMdl);
        IoFreeMdl(pNetRootExchange->pSmbResponseMdl);
    }

    if (pNetRootExchange->pSmbRequestMdl != NULL) {
        RxUnlockHeaderPages(pNetRootExchange->pSmbRequestMdl);
        IoFreeMdl(pNetRootExchange->pSmbRequestMdl);
    }

    if (pNetRootExchange->pSmbActualBuffer != NULL) {

        RxFreePool(pNetRootExchange->pSmbActualBuffer);
    }

    // Tear down the exchange instance ...
    SmbCeDiscardExchangeWorkerThreadRoutine(pExchange);

    if (Status == STATUS_RETRY) {
        // create VNetRoot offline if server entry is transitioned into disconnected state
        Status = MRxSmbCreateVNetRootOffLine(pCreateNetRootContext);

        if (Status != STATUS_SUCCESS) {
            // Callback the RDBSS for resumption if create VNetRoot offline fails
            pNetRootCallback(pCreateNetRootContext);
        }
    } else {
        if (pServerEntry->Server.IsRemoteBootServer &&
            pCreateNetRootContext->NetRootStatus != STATUS_SUCCESS) {
            pCreateNetRootContext->NetRootStatus = STATUS_RETRY;
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_RETRY;
        }   
        
        // Callback the RDBSS for resumption
        pNetRootCallback(pCreateNetRootContext);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbCreateVNetRootOffLine(
    PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext)
{
    NTSTATUS Status;

    Status = RxPostToWorkerThread(
                 MRxSmbDeviceObject,
                 CriticalWorkQueue,
                 &pCreateNetRootContext->WorkQueueItem,
                 MRxSmbCreateVNetRoot,
                 pCreateNetRootContext);

    return Status;
}




SMB_EXCHANGE_DISPATCH_VECTOR
ConstructNetRootExchangeDispatch = {
                                       SmbConstructNetRootExchangeStart,
                                       SmbConstructNetRootExchangeReceive,
                                       SmbConstructNetRootExchangeCopyDataHandler,
                                       NULL,  // No SendCompletionHandler
                                       SmbConstructNetRootExchangeFinalize,
                                       NULL
                                   };


VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    PAGED_CODE();

    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
#if ZZZ_MODE
            if (*(w-1) == L'z') {
                w++;
                continue;
            }
#endif //if ZZZ_MODE
            break;
        }
        w++;
    }
    NetRootName->Length = NetRootName->MaximumLength
                = (USHORT)((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    RxDbgTrace( 0,Dbg,("  MRxSmbExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0,Dbg,("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\ntbowsif.c ===
/***********
//joejoe

Joelinn 2-13-95

This is the pits......i have to pull in the browser in order to be started form
the lanman network provider DLL. the browser should be moved elsewhere........

**********************/


/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    disccode.c

Abstract:

    This module contains the code to manage the NT redirectors discardable
    code sections.


Author:

    Larry Osterman (larryo) 12-Nov-1993

Environment:

    Kernel mode.

Revision History:

    12-Nov-1993

        Created

--*/

//
// Include modules
//

#include "precomp.h"
#pragma hdrstop
#include <ntbowsif.h>

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NTBOWSIF)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DISCCODE)


BOOLEAN DiscCodeInitialized = FALSE;

VOID
RdrDiscardableCodeRoutine(
    IN PVOID Context
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RdrReferenceDiscardableCode)
#pragma alloc_text(PAGE, RdrDereferenceDiscardableCode)
#pragma alloc_text(PAGE, RdrDiscardableCodeRoutine)
#pragma alloc_text(INIT, RdrInitializeDiscardableCode)
#pragma alloc_text(PAGE, RdrUninitializeDiscardableCode)
#endif

//
//  These 7 variables maintain the state needed to manage the redirector
//  discardable code section.
//
//  The redirector discardable code section is referenced via a call to
//  RdrReferenceDiscardableCodeSection, and dereferenced via a call to
//  RdrDereferenceDiscardableCodeSection.
//
//  If the discardable code section is already mapped into memory, then
//  referencing the discardable code section is extremely quick.
//
//  When the reference count on the discardable code section drops to 0, a
//  timer is set that will actually perform the work needed to uninitalize the
//  section.  This means that if the reference count goes from 0 to 1 to 0
//  frequently, we won't thrash inside MmLockPagableCodeSection.
//

#define POOL_DISCTIMER 'wbxR'

ERESOURCE
RdrDiscardableCodeLock = {0};

ULONG
RdrDiscardableCodeTimeout = 10;

RDR_SECTION
RdrSectionInfo[RdrMaxDiscardableSection] = {0};

extern
PVOID
BowserAllocateViewBuffer(VOID);

extern
VOID
BowserNetlogonCopyMessage(int,int);

VOID
RdrReferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    RdrReferenceDiscardableCode is called to reference the redirectors
    discardable code section.

    If the section is not present in memory, MmLockPagableCodeSection is
    called to fault the section into memory.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG
    PVOID caller, callersCaller;
#endif
    PRDR_SECTION Section = &RdrSectionInfo[SectionName];

    PAGED_CODE();

    ExAcquireResourceExclusive(&RdrDiscardableCodeLock, TRUE);

    ASSERT( DiscCodeInitialized );

#if DBG
    RtlGetCallersAddress(&caller, &callersCaller);

    //dprintf(DPRT_DISCCODE, ("  RdrReferenceDiscardableCode: %ld: Caller: %lx, Callers Caller: %lx\n", SectionName, caller, callersCaller));
    RxDbgTrace(0, Dbg, ("  RdrReferenceDiscardableCode: %ld: Caller: %lx, Callers Caller: %lx\n",
                     SectionName, caller, callersCaller ));
#endif

    //
    //  If the reference count is already non zero, just increment it and
    //  return.
    //

    if (Section->ReferenceCount) {
        Section->ReferenceCount += 1;

        //dprintf(DPRT_DISCCODE, ("  RdrReferenceDiscardableCode: %d: Early out, Refcount now %ld\n", SectionName, Section->ReferenceCount));
        RxDbgTrace(0, Dbg, ("  RdrReferenceDiscardableCode: %d: Early out, Refcount now %ld\n",
                         SectionName, Section->ReferenceCount ));

        //
        //  Wait for the pages to be faulted in.
        //

        ExReleaseResource(&RdrDiscardableCodeLock);

        return;
    }

    Section->ReferenceCount += 1;

    //
    //  Cancel the timer, if it is running, we won't be discarding the code
    //  at this time.
    //
    //  If the cancel timer fails, this is not a problem, since we will be
    //  bumping a reference count in the MmLockPagableCodeSection, so when
    //  the timer actually runs and the call to MmUnlockPagableImageSection
    //  is called, we will simply unlock it.
    //

    if (Section->Timer != NULL) {

        Section->TimerCancelled = TRUE;

        if (KeCancelTimer(Section->Timer)) {

            //
            //  Free the timer and DPC, they aren't going to fire anymore.
            //

            RxFreePool(Section->Timer);
            Section->Timer = NULL;

            //
            //  Set the active event to the signalled state, since we're
            //  done canceling the timer.
            //

            KeSetEvent(&Section->TimerDoneEvent, 0, FALSE);

        } else {

            //
            //  The timer was active, and we weren't able to cancel it.
            //  But we marked it for cancellation, and the timer routine
            //  will recognize this and leave the section locked.
            //

        }
    }

    //
    //  If the discardable code section is still locked, then we're done,
    //  and we can return right away.
    //

    if (Section->Locked) {

        //dprintf(DPRT_DISCCODE, ("  RdrReferenceDiscardableCode: %d: Already locked, Refcount now %ld\n", SectionName, Section->ReferenceCount));
        RxDbgTrace(0, Dbg, ("  RdrReferenceDiscardableCode: %d: Already locked, Refcount now %ld\n",
                         SectionName, Section->ReferenceCount ));

        ExReleaseResource(&RdrDiscardableCodeLock);

        return;
    }

    ASSERT (Section->CodeHandle == NULL);
    ASSERT (Section->DataHandle == NULL);

    //
    //  Lock down the pagable image section.
    //

    //dprintf(DPRT_DISCCODE, ("  RdrReferenceDiscardableCode: %d: Lock, Refcount now %ld\n", SectionName, Section->ReferenceCount));
    RxDbgTrace(0, Dbg, ("  RdrReferenceDiscardableCode: %d: Lock, Refcount now %ld\n",
                     SectionName, Section->ReferenceCount ));

    if (Section->CodeBase != NULL) {
        Section->CodeHandle = MmLockPagableCodeSection(Section->CodeBase);
        ASSERT (Section->CodeHandle != NULL);
    }

    if (Section->DataBase != NULL) {
        Section->DataHandle = MmLockPagableDataSection(Section->DataBase);
        ASSERT (Section->DataHandle != NULL);
    }


    Section->Locked = TRUE;

    ExReleaseResource(&RdrDiscardableCodeLock);

}


VOID
RdrDiscardableCodeDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:
    This routine is called when the timeout expires. It is called at Dpc level
    to queue a WorkItem to a system worker thread.

Arguments:

    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2

Return Value
    None.

--*/
{
    PWORK_QUEUE_ITEM discardableWorkItem = Context;

    ExQueueWorkItem(discardableWorkItem, CriticalWorkQueue);

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

}

VOID
RdrDiscardableCodeRoutine(
    IN PVOID Context
    )
/*++

Routine Description:

    RdrDiscardableCodeRoutine is called at task time after the redirector
    discardable code timer has fired to actually perform the unlock on the
    discardable code section.

Arguments:

    Context - Ignored.

Return Value:

    None.

--*/

{
    PRDR_SECTION Section = Context;

    PAGED_CODE();

    ExAcquireResourceExclusive(&RdrDiscardableCodeLock, TRUE);

    if (Section->TimerCancelled) {

        //
        //  The timer was cancelled after it was scheduled to run.
        //  Don't unlock the section.
        //

    } else if (Section->Locked) {

        //
        //  The timer was not cancelled.  Unlock the section.
        //

        Section->Locked = FALSE;

        ASSERT (Section->CodeHandle != NULL ||
                Section->DataHandle != NULL);

        //dprintf(DPRT_DISCCODE, ("RDR: Unlock %x\n", Section));
        RxDbgTrace(0,Dbg,("RDR: Unlock %x\n", Section));

        if (Section->CodeHandle != NULL) {
            MmUnlockPagableImageSection(Section->CodeHandle);
            Section->CodeHandle = NULL;
        }

        if (Section->DataHandle != NULL) {
            MmUnlockPagableImageSection(Section->DataHandle);
            Section->DataHandle = NULL;
        }

    }

    //
    //  Free the timer and DPC, they aren't going to fire anymore.
    //

    RxFreePool(Section->Timer);
    Section->Timer = NULL;

    ExReleaseResource(&RdrDiscardableCodeLock);

    KeSetEvent(&Section->TimerDoneEvent, 0, FALSE);
}


VOID
RdrDereferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    RdrDereferenceDiscardableCode is called to dereference the redirectors
    discardable code section.

    When the reference count drops to 0, a timer is set that will fire in <n>
    seconds, after which time the section will be unlocked.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG
    PVOID caller, callersCaller;
#endif
    PRDR_SECTION Section = &RdrSectionInfo[SectionName];
    LARGE_INTEGER discardableCodeTimeout;
    PKTIMER Timer;
    PKDPC Dpc;
    PWORK_QUEUE_ITEM WorkItem;

    PAGED_CODE();

    ExAcquireResourceExclusive(&RdrDiscardableCodeLock, TRUE);

    ASSERT( DiscCodeInitialized );

#if DBG
    RtlGetCallersAddress(&caller, &callersCaller);

    //dprintf(DPRT_DISCCODE, ("RdrDereferenceDiscardableCode: %ld: Caller: %lx, Callers Caller: %lx\n", SectionName, caller, callersCaller));
    RxDbgTrace(0, Dbg,("RdrDereferenceDiscardableCode: %ld: Caller: %lx, Callers Caller: %lx\n",
                     SectionName, caller, callersCaller ));
#endif

    ASSERT (Section->ReferenceCount > 0);

    //
    //  If the reference count is above 1, just decrement it and
    //  return.
    //

    Section->ReferenceCount -= 1;

    if (Section->ReferenceCount) {

        //dprintf(DPRT_DISCCODE, ("RdrDereferenceDiscardableCode: %d: Early out, Refcount now %ld\n", SectionName, Section->ReferenceCount));
        RxDbgTrace(0, Dbg, ("RdrDereferenceDiscardableCode: %d: Early out, Refcount now %ld\n",
                         SectionName, Section->ReferenceCount ));

        ExReleaseResource(&RdrDiscardableCodeLock);

        return;
    }

    //
    //  If the discardable code timer is still active (which might happen if
    //  the RdrReferenceDiscardableCode failed to cancel the timer), we just
    //  want to bail out and let the timer do the work.  It means that we
    //  discard the code sooner, but that shouldn't be that big a deal.
    //

    if (Section->Timer != NULL) {
        ExReleaseResource(&RdrDiscardableCodeLock);
        return;
    }

    //
    //  The reference count just went to 0, set a timer to fire in
    //  RdrDiscardableCodeTimeout seconds.  When the timer fires,
    //  we queue a request to a worker thread and it will lock down
    //  the pagable code.
    //

    ASSERT (Section->Timer == NULL);

    Timer = RxAllocatePoolWithTag(NonPagedPool,
                          sizeof(KTIMER) + sizeof(KDPC) + sizeof(WORK_QUEUE_ITEM),
                          POOL_DISCTIMER
                          );

    if (Timer == NULL) {
        ExReleaseResource(&RdrDiscardableCodeLock);
        return;
    }

    Section->Timer = Timer;
    KeInitializeTimer(Timer);

    Dpc = (PKDPC)(Timer + 1);
    WorkItem = (PWORK_QUEUE_ITEM)(Dpc + 1);

    KeClearEvent(&Section->TimerDoneEvent);
    Section->TimerCancelled = FALSE;

    ExInitializeWorkItem(WorkItem, RdrDiscardableCodeRoutine, Section);

    KeInitializeDpc(Dpc, RdrDiscardableCodeDpcRoutine, WorkItem);

    discardableCodeTimeout.QuadPart = Int32x32To64(RdrDiscardableCodeTimeout, 1000 * -10000);
    KeSetTimer(Timer, discardableCodeTimeout, Dpc);

    //dprintf(DPRT_DISCCODE, ("RdrDereferenceDiscardableCode: %d: Set timer, Refcount now %ld\n", SectionName, Section->ReferenceCount));
    RxDbgTrace(0, Dbg, ("RdrDereferenceDiscardableCode: %d: Set timer, Refcount now %ld\n",
                     SectionName, Section->ReferenceCount ));

    ExReleaseResource(&RdrDiscardableCodeLock);
}

VOID
RdrInitializeDiscardableCode(
    VOID
    )
{
    DISCARDABLE_SECTION_NAME SectionName;
    PRDR_SECTION Section;

    for (SectionName = 0, Section = &RdrSectionInfo[0];
         SectionName < RdrMaxDiscardableSection;
         SectionName += 1, Section++ ) {
        KeInitializeEvent(&Section->TimerDoneEvent,
                          NotificationEvent,
                          TRUE);
    }

    RdrSectionInfo[RdrFileDiscardableSection].CodeBase = NULL; //RdrBackOff;
    RdrSectionInfo[RdrFileDiscardableSection].DataBase = NULL;
    RdrSectionInfo[RdrVCDiscardableSection].CodeBase = NULL; //RdrTdiDisconnectHandler;
    RdrSectionInfo[RdrVCDiscardableSection].DataBase = NULL; //RdrSmbErrorMap;
    RdrSectionInfo[RdrConnectionDiscardableSection].CodeBase = NULL; //RdrReferenceServer;
    RdrSectionInfo[RdrConnectionDiscardableSection].DataBase = NULL;
    RdrSectionInfo[BowserDiscardableCodeSection].CodeBase = BowserAllocateViewBuffer;
    RdrSectionInfo[BowserDiscardableCodeSection].DataBase = NULL;
    RdrSectionInfo[BowserNetlogonDiscardableCodeSection].CodeBase = BowserNetlogonCopyMessage;
    RdrSectionInfo[BowserNetlogonDiscardableCodeSection].DataBase = NULL;

    ExInitializeResource(&RdrDiscardableCodeLock);

    DiscCodeInitialized = TRUE;

}

VOID
RdrUninitializeDiscardableCode(
    VOID
    )
{
    DISCARDABLE_SECTION_NAME SectionName;
    PRDR_SECTION Section;

    PAGED_CODE();

    ExAcquireResourceExclusive(&RdrDiscardableCodeLock, TRUE);

    DiscCodeInitialized = FALSE;

    for (SectionName = 0, Section = &RdrSectionInfo[0];
         SectionName < RdrMaxDiscardableSection;
         SectionName += 1, Section++ ) {

        //
        // Cancel the timer if it is running.
        //

        if (Section->Timer != NULL) {
            if (!KeCancelTimer(Section->Timer)) {

                //
                //  The timer was active, and we weren't able to cancel it,
                //  wait until the timer finishes firing.
                //

                ExReleaseResource(&RdrDiscardableCodeLock);
                KeWaitForSingleObject(&Section->TimerDoneEvent,
                                      KernelMode, Executive, FALSE, NULL);
                ExAcquireResourceExclusive(&RdrDiscardableCodeLock, TRUE);
            } else {
                RxFreePool(Section->Timer);
                Section->Timer = NULL;
            }
        }

        if (Section->Locked) {

            //
            //  Unlock the section.
            //

            Section->Locked = FALSE;

            ASSERT (Section->CodeHandle != NULL ||
                    Section->DataHandle != NULL);

            //dprintf(DPRT_DISCCODE, ("RDR: Uninitialize unlock %x\n", Section));
            RxDbgTrace(0,Dbg,("RDR: Uninitialize unlock %x\n", Section));

            if (Section->CodeHandle != NULL) {
                MmUnlockPagableImageSection(Section->CodeHandle);
                Section->CodeHandle = NULL;
            }

            if (Section->DataHandle != NULL) {
                MmUnlockPagableImageSection(Section->DataHandle);
                Section->DataHandle = NULL;
            }

        }

    }

    ExReleaseResource(&RdrDiscardableCodeLock);

    ExDeleteResource(&RdrDiscardableCodeLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\openclos.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.

Author:

    Joe Linn      [JoeLi]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddmup.h>
#include <dfsfsctl.h>  //CODE.IMPROVEMENT  time to put this into precomp.h???
#include "csc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbMungeBufferingIfWriteOnlyHandles)
#pragma alloc_text(PAGE, MRxSmbCopyAndTranslatePipeState)
#pragma alloc_text(PAGE, IsReconnectRequired)
#pragma alloc_text(PAGE, MRxSmbIsCreateWithEasSidsOrLongName)
#pragma alloc_text(PAGE, MRxSmbShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, MRxSmbCreate)
#pragma alloc_text(PAGE, MRxSmbDeferredCreate)
#pragma alloc_text(PAGE, MRxSmbCollapseOpen)
#pragma alloc_text(PAGE, MRxSmbComputeNewBufferingState)
#pragma alloc_text(PAGE, MRxSmbConstructDeferredOpenContext)
#pragma alloc_text(PAGE, MRxSmbAdjustCreateParameters)
#pragma alloc_text(PAGE, MRxSmbAdjustReturnedCreateAction)
#pragma alloc_text(PAGE, MRxSmbBuildNtCreateAndX)
#pragma alloc_text(PAGE, MRxSmbBuildOpenAndX)
#pragma alloc_text(PAGE, MRxSmbBuildOpenPrintFile)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Create)
#pragma alloc_text(PAGE, MRxSmbSetSrvOpenFlags)
#pragma alloc_text(PAGE, MRxSmbCreateFileSuccessTail)
#pragma alloc_text(PAGE, MRxSmbFinishNTCreateAndX)
#pragma alloc_text(PAGE, MRxSmbFinishOpenAndX)
#pragma alloc_text(PAGE, MRxSmbFinishCreatePrintFile)
#pragma alloc_text(PAGE, MRxSmbFinishT2OpenFile)
#pragma alloc_text(PAGE, MRxSmbT2OpenFile)
#pragma alloc_text(PAGE, MRxSmbFinishLongNameCreateFile)
#pragma alloc_text(PAGE, MRxSmbCreateWithEasSidsOrLongName)
#pragma alloc_text(PAGE, MRxSmbZeroExtend)
#pragma alloc_text(PAGE, MRxSmbTruncate)
#pragma alloc_text(PAGE, MRxSmbCleanupFobx)
#pragma alloc_text(PAGE, MRxSmbForcedClose)
#pragma alloc_text(PAGE, MRxSmbCloseSrvOpen)
#pragma alloc_text(PAGE, MRxSmbBuildClose)
#pragma alloc_text(PAGE, MRxSmbBuildClosePrintFile)
#pragma alloc_text(PAGE, MRxSmbBuildFindClose)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Close)
#pragma alloc_text(PAGE, MRxSmbFinishClose)
#pragma alloc_text(PAGE, MRxSmbPreparseName )
#pragma alloc_text(PAGE, MRxSmbGetConnectionId )
#endif

//
// From ea.c.
//

NTSTATUS
MRxSmbAddExtraAcesToSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR OriginalSecurityDescriptor,
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    );

NTSTATUS
MRxSmbCreateExtraAcesSelfRelativeSD(
    IN BOOLEAN InheritableAces,
    OUT PSECURITY_DESCRIPTOR * NewSecurityDescriptor
    );

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

// forwards

NTSTATUS
SmbPseExchangeStart_Create(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_Close(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    );

NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG   MRxSmbInitialSrvOpenFlags = 0;     //CODE.IMPROVEMENT this should be regeditable

extern BOOLEAN MRxSmbEnableCachingOnWriteOnlyOpens;
extern BOOLEAN DisableByteRangeLockingOnReadOnlyFiles;
extern ULONG   MRxSmbConnectionIdLevel;

BOOLEAN MRxSmbDeferredOpensEnabled = TRUE;              //this is regedit-able
BOOLEAN MRxSmbOplocksDisabled = FALSE;                  //this is regedit-able

#if defined(REMOTE_BOOT)
//
// Oplocks for disabled for remote boot clients till we run autochk at which time
// it is turned on by the IOCTL.

BOOLEAN MRxSmbOplocksDisabledOnRemoteBootClients = FALSE;
#endif // defined(REMOTE_BOOT)

extern LIST_ENTRY MRxSmbPagingFilesSrvOpenList;

#ifndef FORCE_NO_NTCREATE
#define MRxSmbForceNoNtCreate FALSE
#else
BOOLEAN MRxSmbForceNoNtCreate = TRUE;
#endif


#ifdef RX_PRIVATE_BUILD
//CODE.IMPROVEMENT this should be on a registry setting......
//#define FORCE_SMALL_BUFFERS
#endif //#ifdef RX_PRIVATE_BUILD

#ifndef FORCE_SMALL_BUFFERS

//use size calculated from the negotiated size
ULONG MrxSmbLongestShortName = 0xffff;

//use the negotiated size
ULONG MrxSmbCreateTransactPacketSize = 0xffff;

#else

ULONG MrxSmbLongestShortName = 0;
ULONG MrxSmbCreateTransactPacketSize = 100;

#endif


LONG MRxSmbNumberOfSrvOpens = 0;

INLINE VOID
MRxSmbIncrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_OPEN         SrvOpen)
{
    LONG NumberOfSrvOpens;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (!FlagOn(smbSrvOpen->FileInfo.Basic.FileAttributes,
                FILE_ATTRIBUTE_DIRECTORY)) {
        ASSERT(!smbSrvOpen->NumOfSrvOpenAdded);
        smbSrvOpen->NumOfSrvOpenAdded = TRUE;

        InterlockedIncrement(&pServerEntry->Server.NumberOfSrvOpens);

        NumberOfSrvOpens = InterlockedIncrement(&MRxSmbNumberOfSrvOpens);

        if (NumberOfSrvOpens == 1) {
            PoRegisterSystemState(
                MRxSmbPoRegistrationState,
                (ES_SYSTEM_REQUIRED | ES_CONTINUOUS));
        }
    }
}

VOID
MRxSmbDecrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    LONG                  SrvOpenServerVersion,
    PMRX_SRV_OPEN         SrvOpen)
{
    LONG NumberOfSrvOpens;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (!FlagOn(smbSrvOpen->FileInfo.Basic.FileAttributes,
                FILE_ATTRIBUTE_DIRECTORY)) {
        ASSERT(smbSrvOpen->NumOfSrvOpenAdded);
        smbSrvOpen->NumOfSrvOpenAdded = FALSE;

        if (SrvOpenServerVersion == (LONG)pServerEntry->Server.Version) {
            ASSERT(pServerEntry->Server.NumberOfSrvOpens > 0);

            InterlockedDecrement(&pServerEntry->Server.NumberOfSrvOpens);
        }

        NumberOfSrvOpens = InterlockedDecrement(&MRxSmbNumberOfSrvOpens);

        if (NumberOfSrvOpens == 0) {
            PoRegisterSystemState(
                MRxSmbPoRegistrationState,
                ES_CONTINUOUS);
        }
    }
}

INLINE VOID
MRxSmbMungeBufferingIfWriteOnlyHandles (
    ULONG WriteOnlySrvOpenCount,
    PMRX_SRV_OPEN SrvOpen
    )
/*++

Routine Description:

   This routine modifies the buffering flags on a srvopen so that
   no cacheing will be allowed if there are any write-only handles
   to the file.

Arguments:

    WriteOnlySrvOpenCount - the number of writeonly srvopens

    SrvOpen - the srvopen whose buffring flags are to be munged

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    BOOLEAN IsLoopBack = FALSE;
    PMRX_SRV_CALL pSrvCall;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    IsLoopBack = pServerEntry->Server.IsLoopBack;

    if (IsLoopBack || (WriteOnlySrvOpenCount != 0)) {
        SrvOpen->BufferingFlags &=
           ~( FCB_STATE_WRITECACHEING_ENABLED  |
              FCB_STATE_FILESIZECACHEING_ENABLED |
              FCB_STATE_FILETIMECACHEING_ENABLED |
              FCB_STATE_LOCK_BUFFERING_ENABLED |
              FCB_STATE_READCACHEING_ENABLED |
              FCB_STATE_COLLAPSING_ENABLED
            );
    }
}

INLINE VOID
MRxSmbCopyAndTranslatePipeState(
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG       PipeState
    )
/*++

Routine Description:

   This routine updates the pipe state according to the parameters specified at
   setup time

Arguments:

    RxContext - the context

    PipeState - the state of the pipe

--*/
{
    PAGED_CODE();

    if (RxContext->Create.pNetRoot->Type == NET_ROOT_PIPE) {
        RxContext->Create.pNetRoot->NamedPipeParameters.DataCollectionSize =
            MRxSmbConfiguration.NamedPipeDataCollectionSize;

        RxContext->Create.PipeType =
            ((PipeState&SMB_PIPE_TYPE_MESSAGE)==SMB_PIPE_TYPE_MESSAGE)
                     ?FILE_PIPE_MESSAGE_TYPE:FILE_PIPE_BYTE_STREAM_TYPE;
        RxContext->Create.PipeReadMode =
            ((PipeState&SMB_PIPE_READMODE_MESSAGE)==SMB_PIPE_READMODE_MESSAGE)
                     ?FILE_PIPE_MESSAGE_MODE:FILE_PIPE_BYTE_STREAM_MODE;
        RxContext->Create.PipeCompletionMode =
            ((PipeState&SMB_PIPE_NOWAIT)==SMB_PIPE_NOWAIT)
                     ?FILE_PIPE_COMPLETE_OPERATION:FILE_PIPE_QUEUE_OPERATION;
    }
}

INLINE BOOLEAN
IsReconnectRequired(
      PMRX_SRV_CALL SrvCall)
/*++

Routine Description:

   This routine determines if a reconnect is required to a given server

Arguments:

    SrvCall - the SRV_CALL instance

Return Value:

    TRUE if a reconnect is required

--*/
{
   BOOLEAN ReconnectRequired = FALSE;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   PAGED_CODE();

   pServerEntry = SmbCeGetAssociatedServerEntry(SrvCall);
   if (pServerEntry != NULL) {
      ReconnectRequired = (pServerEntry->Header.State != SMBCEDB_ACTIVE);
   }

   return ReconnectRequired;
}


BOOLEAN
MRxSmbIsCreateWithEasSidsOrLongName(
    IN OUT PRX_CONTEXT RxContext,
    OUT    PULONG      DialectFlags
    )
/*++

Routine Description:

    This routine determines if the create operation involves EA's or security
    desriptors. In such cases a separate protocol is required

Arguments:

    RxContext - the RX_CONTEXT instance

    DialectFlags - the dialect flags associated with the server

Return Value:

    TRUE if a reconnect is required

--*/
{
    RxCaptureFcb;

    ULONG LongestShortName,LongestShortNameFromSrvBufSize;

    PMRX_SRV_CALL SrvCall = (PMRX_SRV_CALL)RxContext->Create.pSrvCall;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(SrvCall);

    ASSERT(pServerEntry != NULL);

    *DialectFlags = pServerEntry->Server.DialectFlags;


    // DOWN.LEVEL if the server takes OEM names or we use a different protocol
    // this would have to be different. maybe a switch or a precompute.

    LongestShortNameFromSrvBufSize =
        MAXIMUM_SMB_BUFFER_SIZE -
        QuadAlign(sizeof(NT_SMB_HEADER) +
                  FIELD_OFFSET(REQ_NT_CREATE_ANDX,Buffer[0])
                 );

    LongestShortName = min(MrxSmbLongestShortName,LongestShortNameFromSrvBufSize);

    return (RxContext->Create.EaLength  ||
            RxContext->Create.SdLength  ||
            RemainingName->Length > LongestShortName);
}

NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PMRX_SRV_OPEN           SrvOpen = RxContext->pRelevantSrvOpen;
    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = (PMRX_SMB_FCB)capFcb->Context;

    PAGED_CODE();

    if (SrvOpen)
    {
        PMRX_SMB_SRV_OPEN       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        PSMBCEDB_SERVER_ENTRY   pServerEntry = (PSMBCEDB_SERVER_ENTRY)(RxContext->Create.pSrvCall->Context);

        if (smbSrvOpen->Version != pServerEntry->Server.Version)
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        if ( smbFcb->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            // This is most likely a change notify for a directory, so don't allow collapsing to make change notifies
            // work correctly.  (Multiple notifies using different handles are different from multiple ones using the same handle)
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        NOTHING;
    } else {
        if (MRxSmbCscIsThisACopyChunkOpen(RxContext, NULL)){
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    return Status;
}

NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    PMRX_SRV_OPEN           SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SRV_CALL           SrvCall = RxContext->Create.pSrvCall;
    PSMBCEDB_SERVER_ENTRY   pServerEntry = (PSMBCEDB_SERVER_ENTRY)SrvCall->Context;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PMRX_V_NET_ROOT         pVNetRoot = SrvOpen->pVNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry ;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;

    BOOLEAN         ReconnectRequired;
    BOOLEAN         CreateWithEasSidsOrLongName = FALSE;
    ULONG           DialectFlags = pServerEntry->Server.DialectFlags;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;
    ULONG                 Disposition = CreateParameters->Disposition;

    SMBFCB_HOLDING_STATE SmbFcbHoldingState = SmbFcb_NotHeld;
    SMBFCB_HOLDING_STATE OriginalSmbFcbHoldingState;

    PVOID OldWriteOnlyOpenRetryContext = RxContext->WriteOnlyOpenRetryContext;

#if defined(REMOTE_BOOT)
    BOOLEAN      ModifiedSd = FALSE;
    ULONG        OriginalSdLength;
    PSECURITY_DESCRIPTOR SelfRelativeSd;
    PSECURITY_DESCRIPTOR OriginalSd;
    BOOLEAN      NetworkCreateSucceeded = FALSE;
    PMRX_SMB_FCB            smbFcb = MRxSmbGetFcbExtension(capFcb);
    FINISH_FCB_INIT_PARAMETERS FinishFcbInitParameters;
    UNICODE_STRING              relativeName;
    PUNICODE_PREFIX_TABLE_ENTRY tableEntry;
    PRBR_PREFIX                 prefixEntry;
#endif // defined(REMOTE_BOOT)

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbCreate\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace( 0, Dbg, ("     Attempt to open %wZ\n", RemainingName ));

    if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE ) &&
        !MRxSmbBootedRemotely) {
        return STATUS_NOT_IMPLEMENTED;
    }

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_STATUS) &&
        MRxSmbIsStreamFile(RemainingName,NULL)) {
        // The Samba server return file system type NTFS but doesn't support stream
        return STATUS_OBJECT_PATH_NOT_FOUND;
    }

    if (!(pServerEntry->Server.DialectFlags & DF_EXTENDED_SECURITY)) {
        // The Create Options have been extended for NT5 servers. Since
        // EXTENDED_SECURITY is also only supported by NT5 servers we use
        // that to distinguish NT5 servers from non NT5 servers. It would
        // be  better if we have a separate way of determining the create
        // options as opposed to this aliasing. This will have to do till
        // we can get the associated protocol change

        RxContext->Create.NtCreateParameters.CreateOptions &= 0xfffff;
    }

#if defined(REMOTE_BOOT)
    FinishFcbInitParameters.CallFcbFinishInit = FALSE;

    // If it is not a remote boot machine we do not permit paging over the
    // net yet.


    //
    // Remote boot redirection. If the file being opened is on the remote
    // boot share, and the share-relative part of the name matches a prefix
    // in the remote boot redirection list, reparse this open over to the
    // local disk.
    //

    if (pVNetRoot != NULL &&
        (pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot)) != NULL &&
        (pSessionEntry = pVNetRootContext->pSessionEntry) != NULL) {
        PSMBCE_SESSION pSession = &pSessionEntry->Session;
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
            (MRxSmbRemoteBootRedirectionPrefix.Length != 0)) {

            if (RtlPrefixUnicodeString( &MRxSmbRemoteBootPath,
                                        RemainingName,
                                        TRUE)) {
                relativeName.Buffer =
                    (PWCHAR)((PCHAR)RemainingName->Buffer + MRxSmbRemoteBootPath.Length);
                relativeName.Length = RemainingName->Length - MRxSmbRemoteBootPath.Length;
                if ((relativeName.Length != 0) && (*relativeName.Buffer == L'\\')) {
                    tableEntry = RtlFindUnicodePrefix(
                                     &MRxSmbRemoteBootRedirectionTable,
                                     &relativeName,
                                     0);
                    if (tableEntry != NULL) {
                        prefixEntry = CONTAINING_RECORD( tableEntry, RBR_PREFIX, TableEntry );
                        if ( prefixEntry->Redirect ) {
                            UNICODE_STRING newPath;
                            BOOLEAN reparseRequired;

                            newPath.Length = (USHORT)(MRxSmbRemoteBootRedirectionPrefix.Length +
                                                        relativeName.Length);
                            newPath.MaximumLength = newPath.Length;
                            // Note: Can't use RxAllocatePoolWithTag for this allocation.
                            newPath.Buffer = RxAllocatePoolWithTag(
                                                PagedPool,
                                                newPath.Length,
                                                MRXSMB_MISC_POOLTAG );
                            if (newPath.Buffer != NULL) {
                                RtlCopyMemory(
                                    newPath.Buffer,
                                    MRxSmbRemoteBootRedirectionPrefix.Buffer,
                                    MRxSmbRemoteBootRedirectionPrefix.Length);
                                RtlCopyMemory(
                                    (PCHAR)newPath.Buffer + MRxSmbRemoteBootRedirectionPrefix.Length,
                                    relativeName.Buffer,
                                    relativeName.Length);
                                Status = RxPrepareToReparseSymbolicLink(
                                            RxContext,
                                            TRUE,
                                            &newPath,
                                            TRUE,
                                            &reparseRequired
                                            );
                                ASSERT( reparseRequired || !NT_SUCCESS(Status) );
                                if ( reparseRequired ) {
                                    return STATUS_REPARSE;
                                } else {
                                    RxFreePool( newPath.Buffer );
                                    return Status;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
#endif // defined(REMOTE_BOOT)

    IF_NOT_MRXSMB_CSC_ENABLED{
        NOTHING;
    } else if (!smbSrvOpen->HotReconnectInProgress) {
        NTSTATUS CscCreateStatus;
        CscCreateStatus = MRxSmbCscCreatePrologue(RxContext,&SmbFcbHoldingState);
        if (CscCreateStatus != STATUS_MORE_PROCESSING_REQUIRED) {
            RxDbgTrace(-1, Dbg, ("MRxSmbRead shadow hit with status=%08lx\n", CscCreateStatus ));
            ASSERT(SmbFcbHoldingState==SmbFcb_NotHeld);
            return(CscCreateStatus);
        } else {
            RxDbgTrace(0, Dbg, ("MRxSmbCreate continuing from prolog w/ status=%08lx\n", CscCreateStatus ));
        }
    }
    OriginalSmbFcbHoldingState = SmbFcbHoldingState;

    // we cannot have a file cached on a write only handle. so we have to behave a little
    // differently if this is a write-only open. remember this in the smbsrvopen

    if (  ((CreateParameters->DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) == 0) &&
          ((CreateParameters->DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0)
       ) {
       if (MRxSmbEnableCachingOnWriteOnlyOpens &&
           (RxContext->WriteOnlyOpenRetryContext == NULL)) {
           CreateParameters->DesiredAccess |= (FILE_READ_DATA | FILE_READ_ATTRIBUTES);
           RxContext->WriteOnlyOpenRetryContext = UIntToPtr( 0xaaaaaaaa );
       } else {
           SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE);
           SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING;
       }
    }

    //the way that SMBs work, there is no buffering effect if we open for attributes-only
    //so set that up immediately.

    if ((CreateParameters->DesiredAccess
         & ~(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE))
                  == 0 ){
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE);
    }

    if (NetRoot->Type == NET_ROOT_MAILSLOT) {
        RxFinishFcbInitialization( capFcb, RDBSS_NTC_MAILSLOT, NULL);
        return STATUS_SUCCESS;
    }

    if ((NetRoot->Type == NET_ROOT_PIPE) &&
        (RemainingName->Length <= sizeof(WCHAR))) {
        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

        RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

        if (RxContext->pFobx != NULL) {
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return Status;
    }

    // Get the control struct for the file not found name cache.
    //
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot session, we need to put our ACLs on the
    // file.

    if (MRxSmbBootedRemotely &&
        MRxSmbRemoteBootDoMachineLogon &&
        (pVNetRoot != NULL) &&
        ((pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot)) != NULL) &&
        ((pSessionEntry = pVNetRootContext->pSessionEntry) != NULL)) {
        PSMBCE_SESSION pSession = &pSessionEntry->Session;

        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

            PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

            //
            // Set this so the success tail knows to delay the call
            // to RxFinishFcbInitialization.
            //

            smbFcb->FinishFcbInitParameters = &FinishFcbInitParameters;

            if ((cp->Disposition != FILE_OPEN) && (cp->Disposition != FILE_OVERWRITE)) {

                PACCESS_ALLOWED_ACE CurrentAce;
                ULONG NewDaclSize;
                ULONG i;
                BOOLEAN IsDirectory;

                ModifiedSd = TRUE;    // so we know to free it later.
                SelfRelativeSd = NULL;
                OriginalSdLength = RxContext->Create.SdLength;
                IsDirectory = (BOOLEAN)((cp->CreateOptions & FILE_DIRECTORY_FILE) != 0);

                if (RxContext->Create.SdLength == 0) {

                    ASSERT (cp->SecurityContext != NULL);
                    ASSERT (cp->SecurityContext->AccessState != NULL);

                    //
                    // Now create a security descriptor with the ACEs
                    // we need in the DACL.
                    //

                    Status = MRxSmbCreateExtraAcesSelfRelativeSD(
                                 IsDirectory,
                                 &SelfRelativeSd);

                    if (!NT_SUCCESS(Status)) {
                        goto FINALLY;
                    }

                    //
                    // Now replace the original SD with the new one.
                    //

                    cp->SecurityContext->AccessState->SecurityDescriptor = SelfRelativeSd;
                    RxContext->Create.SdLength = RtlLengthSecurityDescriptor(SelfRelativeSd);

                } else {

                    //
                    // There is already a security descriptor there, so we
                    // need to munge our ACLs on.
                    //

                    Status = MRxSmbAddExtraAcesToSelfRelativeSD(
                                 cp->SecurityContext->AccessState->SecurityDescriptor,
                                 IsDirectory,
                                 &SelfRelativeSd);

                    if (!NT_SUCCESS(Status)) {
                        goto FINALLY;
                    }

                    //
                    // Replace the SD, saving the original.
                    //

                    OriginalSd = cp->SecurityContext->AccessState->SecurityDescriptor;
                    cp->SecurityContext->AccessState->SecurityDescriptor = SelfRelativeSd;
                    RxContext->Create.SdLength = RtlLengthSecurityDescriptor(SelfRelativeSd);

                }
            }
        }
    }
#endif // defined(REMOTE_BOOT)

    // assume Reconnection to be trivially successful
    Status = STATUS_SUCCESS;

    if (!smbSrvOpen->HotReconnectInProgress) {
        CreateWithEasSidsOrLongName = MRxSmbIsCreateWithEasSidsOrLongName(RxContext,&DialectFlags);

        if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            CreateWithEasSidsOrLongName = FALSE;
        }
    }

    ReconnectRequired = IsReconnectRequired((PMRX_SRV_CALL)SrvCall);

    ////get rid of nonNT SDs right now    CODE.IMPROVEMENT fix this and enable it!!
    //if (RxContext->Create.SdLength) {
    //     RxDbgTrace(-1, Dbg, ("SDs w/o NTSMBS!\n"));
    //     return((STATUS_NOT_SUPPORTED));
    //}

    //get rid of nonEA guys right now
    if (RxContext->Create.EaLength && !FlagOn(DialectFlags,DF_SUPPORTEA)) {
         RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
         Status = STATUS_NOT_SUPPORTED;
         goto FINALLY;
    }

        //
        // Look for this name in the Name Cache associated with the NetRoot.
        // If it's found and the open failed within the last 5 seconds AND
        // no other SMBs have been received in the interim AND
        // the create disposition is not (open_if or overwrite_if or create or supersede)
        // then fail this create with the same status as the last request
        // that went to the server.
        //

    if (!((Disposition==FILE_CREATE) || (Disposition==FILE_OPEN_IF) ||
          (Disposition==FILE_OVERWRITE_IF) || (Disposition==FILE_SUPERSEDE)) &&
         !ReconnectRequired &&
         !CreateWithEasSidsOrLongName) {
        //
        // We're not going to create it so look in name cache.
        //

        if (MRxSmbIsFileNotFoundCached(RxContext)) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto FINALLY;
        }
    }

    if (ReconnectRequired || !CreateWithEasSidsOrLongName) {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               SrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_CREATE,
                               SmbPseExchangeStart_Create,
                               &OrdinaryExchange);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            goto FINALLY;
        }
        OrdinaryExchange->Create.CreateWithEasSidsOrLongName = CreateWithEasSidsOrLongName;

        // For Creates, the resources need to be reacquired after sending an
        // SMB; so, do not hold onto the MIDS till finalization; instead give the MID back
        // right away

        OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
        OrdinaryExchange->SmbCeFlags |= (SMBCE_EXCHANGE_ATTEMPT_RECONNECTS |
                                         SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION);
        OrdinaryExchange->pSmbCeSynchronizationEvent = &RxContext->SyncEvent;

        OrdinaryExchange->SmbFcbHoldingState = SmbFcbHoldingState;

        // drop the resource before you go in!
        // the start routine will reacquire it on the way out.....
        if (!smbSrvOpen->HotReconnectInProgress) {
            RxReleaseFcbResourceInMRx( capFcb );
        }

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        if (!smbSrvOpen->HotReconnectInProgress) {
            ASSERT((Status != STATUS_SUCCESS) || RxIsFcbAcquiredExclusive( capFcb ));
        }

        OrdinaryExchange->pSmbCeSynchronizationEvent = NULL;
        SmbFcbHoldingState = OrdinaryExchange->SmbFcbHoldingState;

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

        if (!smbSrvOpen->HotReconnectInProgress) {
            if (!RxIsFcbAcquiredExclusive(capFcb)) {
                ASSERT(!RxIsFcbAcquiredShared(capFcb));
                RxAcquireExclusiveFcbResourceInMRx( capFcb );
            }
        }
    }

    if (CreateWithEasSidsOrLongName && (Status == STATUS_SUCCESS)) {

        if (OriginalSmbFcbHoldingState != SmbFcbHoldingState) {
            //we have to reacquire the holding state
            NTSTATUS AcquireStatus = STATUS_UNSUCCESSFUL;
            ULONG AcquireOptions;
            BOOLEAN IsCopyChunkOpen = MRxSmbCscIsThisACopyChunkOpen(RxContext, NULL);

            //if we don't have it.....it must have been dropped........
            ASSERT(SmbFcbHoldingState == SmbFcb_NotHeld);

            if (IsCopyChunkOpen) {
                AcquireOptions = Exclusive_SmbFcbAcquire
                                      | DroppingFcbLock_SmbFcbAcquire
                                      | FailImmediately_SmbFcbAcquire;
            } else {
                AcquireOptions = Shared_SmbFcbAcquire
                                      | DroppingFcbLock_SmbFcbAcquire;
            }

            ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

            //must rezero the minirdr context.......
            RtlZeroMemory(&(RxContext->MRxContext[0]),sizeof(RxContext->MRxContext));
            AcquireStatus = MRxSmbCscAcquireSmbFcb(RxContext,AcquireOptions,&SmbFcbHoldingState);

            ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

            if (AcquireStatus != STATUS_SUCCESS) {
                //we couldn't acquire.....get out
                Status = AcquireStatus;
                ASSERT(SmbFcbHoldingState == SmbFcb_NotHeld);
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCreate couldn't reacquire!!!-> %08lx %08lx\n",RxContext,Status ));
                goto FINALLY;
            }
        }

        Status = SmbCeReconnect(RxContext->Create.pVNetRoot);

        if (Status == STATUS_SUCCESS)
        {
            Status = MRxSmbCreateWithEasSidsOrLongName(RxContext,
                                                   &SmbFcbHoldingState );
        }

    }

    // There are certain downlevel servers(OS/2 servers) that return the error
    // STATUS_OPEN_FAILED. This is a context sensitive error code that needs to
    // be interpreted in conjunction with the disposition specified for the OPEN.

    if (Status == STATUS_OPEN_FAILED) {
        switch (Disposition) {

        //
        //  If we were asked to create the file, and got OPEN_FAILED,
        //  this implies that the file already exists.
        //

        case FILE_CREATE:
            Status = STATUS_OBJECT_NAME_COLLISION;
            break;

        //
        //  If we were asked to open the file, and got OPEN_FAILED,
        //  this implies that the file doesn't exist.
        //

        case FILE_OPEN:
        case FILE_SUPERSEDE:
        case FILE_OVERWRITE:
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            break;

        //
        //  If there is an error from either FILE_OPEN_IF or
        //  FILE_OVERWRITE_IF, it indicates the user is trying to
        //  open a file on a read-only share, so return the
        //  correct error for that.
        //

        case FILE_OPEN_IF:
        case FILE_OVERWRITE_IF:
            Status = STATUS_NETWORK_ACCESS_DENIED;
            break;

        default:
            break;
        }
    }


    //
    // Check for file not found status.  If this is the case then create a
    // name cache entry in the NetRoot name cache and record the status,
    // the smb received count and set the expiration time for 5 seconds.
    //

    if (Status == STATUS_SUCCESS) {
        //
        // The open succeeded so free up the name cache entry.
        //
        MRxSmbInvalidateFileNotFoundCache(RxContext);
    } else {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
            Status == STATUS_OBJECT_PATH_NOT_FOUND) {
             // create the name based file not found cache
            MRxSmbCacheFileNotFound(RxContext);
            MRxSmbInvalidateInternalFileInfoCache(RxContext);
        } else {
             // invalid the name based file not found cache if other error happens
            MRxSmbInvalidateFileNotFoundCache(RxContext);
        }

        // invalid the name based file info cache
        MRxSmbInvalidateFileInfoCache(RxContext);
    }

FINALLY:
    ASSERT(Status != (STATUS_PENDING));

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN);
#if defined(REMOTE_BOOT)
        NetworkCreateSucceeded = TRUE;
#endif // defined(REMOTE_BOOT)
    }

#if defined(REMOTE_BOOT)
    //
    // Put back the old SD if there was one (we do this *before* calling
    // MRxSmbCscCreateEpilogue since it may try to apply the SD to the
    // shadow file).
    //

    if (ModifiedSd && !smbSrvOpen->HotReconnectInProgress) {
        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

        if (SelfRelativeSd != NULL) {
            RxFreePool(SelfRelativeSd);
        }

        RxContext->Create.SdLength = OriginalSdLength;

        if (OriginalSdLength > 0) {
            cp->SecurityContext->AccessState->SecurityDescriptor = OriginalSd;
        } else {
            cp->SecurityContext->AccessState->SecurityDescriptor = NULL;
        }
    }
#endif // defined(REMOTE_BOOT)

    if (!smbSrvOpen->HotReconnectInProgress &&
        (Status != STATUS_RETRY)) {

        ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

        MRxSmbCscCreateEpilogue(RxContext,&Status,&SmbFcbHoldingState);

#if defined(REMOTE_BOOT)
        if (!NT_SUCCESS(Status) &&
            NetworkCreateSucceeded) {

            NTSTATUS CloseStatus;
            PRX_CONTEXT pLocalRxContext;
            RxCaptureFobx;

            //
            // Epilogue failed, we need to close the open we just did on
            // the network since we are going to fail the create.
            //

            ClearFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN);

            pLocalRxContext = RxCreateRxContext(
                                  NULL,
                                  ((PFCB)capFcb)->RxDeviceObject,
                                  RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING);

            if (pLocalRxContext != NULL) {
                pLocalRxContext->MajorFunction = IRP_MJ_CLOSE;
                pLocalRxContext->pFcb  = capFcb;
                pLocalRxContext->pFobx = capFobx;

                DbgPrint("ABOUT TO CALL MRXSMBCLOSESRVOPEN, STATUS FROM EPILOGUE IS %lx\n", Status);
                //DbgBreakPoint();

                CloseStatus = MRxSmbCloseSrvOpen(pLocalRxContext);

                DbgPrint("MRXSMBCLOSESRVOPEN STATUS IS %lx\n", CloseStatus);

                RxDereferenceAndDeleteRxContext(pLocalRxContext);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
#endif // defined(REMOTE_BOOT)

    }

#if defined(REMOTE_BOOT)
    //
    // If we delayed the success tail until now, call it.
    //

    if (FinishFcbInitParameters.CallFcbFinishInit &&
        (Status == STATUS_SUCCESS)) {

        PFCB_INIT_PACKET         InitPacket;

        if (FinishFcbInitParameters.InitPacketProvided) {
            InitPacket = &FinishFcbInitParameters.InitPacket;
        } else {
            InitPacket = NULL;
        }

        RxFinishFcbInitialization(
            capFcb,
            FinishFcbInitParameters.FileType,
            InitPacket);

    }
#endif // defined(REMOTE_BOOT)

    if (Status == STATUS_NETWORK_NAME_DELETED) {
        Status = STATUS_RETRY;
    } else if (pServerEntry->Server.IsRemoteBootServer) {
        if (Status == STATUS_IO_TIMEOUT ||
            Status == STATUS_BAD_NETWORK_PATH ||
            Status == STATUS_NETWORK_UNREACHABLE ||
            Status == STATUS_REMOTE_NOT_LISTENING ||
            Status == STATUS_USER_SESSION_DELETED ||
            Status == STATUS_CONNECTION_DISCONNECTED) {

            RxDbgTrace(-1, Dbg, ("MRxSmbCreate: Got status %08lx, setting to RETRY status.\n", Status ));
            Status = STATUS_RETRY;
        }
    }

    if ((OldWriteOnlyOpenRetryContext == NULL) &&
        (RxContext->WriteOnlyOpenRetryContext != NULL)) {

        CreateParameters->DesiredAccess &= ~(FILE_READ_DATA | FILE_READ_ATTRIBUTES);

        if ((Status == STATUS_ACCESS_DENIED) ||
            (Status == STATUS_SHARING_VIOLATION)) {
            Status = STATUS_RETRY;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCreate  exit with status=%08lx\n", Status ));
    RxLog(("MRxSmbCreate exits %lx\n", Status));

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        SmbLogError(Status,
                    LOG,
                    MRxSmbCreate,
                    LOGULONG(Status)
                    LOGUSTR(*RemainingName));
    }

    return(Status);
}

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine constructs a rxcontext from saved information and then calls
   MRxSmbCreate. The hard/hokey part is that we have to keep the holding state
   of the resource "pure". the only way to do this without getting in the middle
   of the tracker code is to do drop release pairs. The plan is that this is a
   pretty infrequent operation..........

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_FOBX        smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN        SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext = smbSrvOpen->DeferredOpenContext;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PRX_CONTEXT OpenRxContext,oc;

    PAGED_CODE();

    if (!smbSrvOpen->HotReconnectInProgress &&
        (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)
          || !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN))) {

        Status = STATUS_SUCCESS;
        goto FINALLY;
    }

    if (DeferredOpenContext == NULL) {
        if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_CLOSED)) {
            Status = STATUS_FILE_CLOSED;
            goto FINALLY;
        } else {
            //DbgBreakPoint();
        }
    }

    if (!smbSrvOpen->HotReconnectInProgress) {
        ASSERT(RxIsFcbAcquiredExclusive(capFcb));
    }

    SmbCeAcquireResource();

    if (!smbSrvOpen->DeferredOpenInProgress) {
        PLIST_ENTRY pListHead;
        PLIST_ENTRY pListEntry;

        smbSrvOpen->DeferredOpenInProgress = TRUE;
        InitializeListHead(&smbSrvOpen->DeferredOpenSyncContexts);

        SmbCeReleaseResource();

        OpenRxContext = RxAllocatePoolWithTag(NonPagedPool,
                                              sizeof(RX_CONTEXT),
                                              MRXSMB_RXCONTEXT_POOLTAG);
        if (OpenRxContext==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RtlZeroMemory(
                OpenRxContext,
                sizeof(RX_CONTEXT));

            RxInitializeContext(
                NULL,
                RxContext->RxDeviceObject,
                0,
                OpenRxContext );

            oc = OpenRxContext;
            oc->pFcb = capFcb;
            oc->pFobx = capFobx;
            oc->NonPagedFcb = RxContext->NonPagedFcb;
            oc->CurrentIrp = RxContext->CurrentIrp;
            oc->CurrentIrpSp = RxContext->CurrentIrpSp;
            oc->MajorFunction = IRP_MJ_CREATE;
            oc->pRelevantSrvOpen = SrvOpen;
            oc->Create.pVNetRoot = SrvOpen->pVNetRoot;
            oc->Create.pNetRoot = oc->Create.pVNetRoot->pNetRoot;
            oc->Create.pSrvCall = oc->Create.pNetRoot->pSrvCall;

            oc->Flags = DeferredOpenContext->RxContextFlags;
            oc->Flags |= RX_CONTEXT_FLAG_MINIRDR_INITIATED|RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK;
            oc->Create.Flags = DeferredOpenContext->RxContextCreateFlags;
            oc->Create.NtCreateParameters = DeferredOpenContext->NtCreateParameters;

            if (!smbSrvOpen->HotReconnectInProgress) {
                //the tracker gets very unhappy if you don't do this!
                //RxTrackerUpdateHistory(oc,capFcb,'aaaa',__LINE__,__FILE__,0xbadbad);
            }

            Status = MRxSmbCreate(oc);

            if (Status==STATUS_SUCCESS) {
                if (!MRxSmbIsThisADisconnectedOpen(SrvOpen)) {
                    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                        MRxSmbIncrementSrvOpenCount(pServerEntry,SrvOpen);
                    } else {
                        ASSERT(smbSrvOpen->NumOfSrvOpenAdded);

                        if (smbSrvOpen->HotReconnectInProgress) {
                            smbSrvOpen->NumOfSrvOpenAdded = FALSE;
                            MRxSmbIncrementSrvOpenCount(pServerEntry,SrvOpen);
                        }
                    }
                }

                ClearFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
            }

            if (!smbSrvOpen->HotReconnectInProgress) {
                //the tracker gets very unhappy if you don't do this!
                //RxTrackerUpdateHistory(oc,capFcb,'rrDO',__LINE__,__FILE__,0xbadbad);
                RxLog(("DeferredOpen %lx %lx %lx %lx\n", capFcb, capFobx, RxContext, Status));
                SmbLog(LOG,
                       MRxSmbDeferredCreate_1,
                       LOGPTR(capFcb)
                       LOGPTR(capFobx)
                       LOGPTR(RxContext)
                       LOGULONG(Status));
            } else {
                RxLog(("RB Re-Open %lx %lx %lx %lx\n", capFcb, capFobx, RxContext, Status));
                SmbLog(LOG,
                       MRxSmbDeferredCreate_2,
                       LOGPTR(capFcb)
                       LOGPTR(capFobx)
                       LOGPTR(RxContext)
                       LOGULONG(Status));
            }

            ASSERT(oc->ReferenceCount==1);

            RxFreePool(oc);
        }

        if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_CLOSED) ||
            FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_ORPHANED)) {
            RxFreePool(smbSrvOpen->DeferredOpenContext);
            smbSrvOpen->DeferredOpenContext = NULL;
            RxDbgTrace(0, Dbg, ("Free deferred open context for file %wZ %lX\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),smbSrvOpen));
        }

        SmbCeAcquireResource();
        smbSrvOpen->DeferredOpenInProgress = FALSE;

        pListHead = &smbSrvOpen->DeferredOpenSyncContexts;
        pListEntry = pListHead->Flink;

        while (pListEntry != pListHead) {
            PDEFERRED_OPEN_SYNC_CONTEXT pWaitingContext;

            pWaitingContext = (PDEFERRED_OPEN_SYNC_CONTEXT)CONTAINING_RECORD(
                                   pListEntry,
                                   DEFERRED_OPEN_SYNC_CONTEXT,
                                   ListHead);

            pListEntry = pListEntry->Flink;
            RemoveHeadList(&pWaitingContext->ListHead);

            pWaitingContext->Status = Status;

            //DbgPrint("Signal RxContext %x after deferred open\n",pWaitingContext->RxContext);
            RxSignalSynchronousWaiter(pWaitingContext->RxContext);
        }

        SmbCeReleaseResource();

    } else {
        DEFERRED_OPEN_SYNC_CONTEXT WaitingContext;
        BOOLEAN AcquireExclusive = RxIsFcbAcquiredExclusive(capFcb);
        BOOLEAN AcquireShare = RxIsFcbAcquiredShared(capFcb) > 0;

        // put the RxContext on the waiting list
        WaitingContext.RxContext = RxContext;
        InitializeListHead(&WaitingContext.ListHead);

        InsertTailList(
            &smbSrvOpen->DeferredOpenSyncContexts,
            &WaitingContext.ListHead);

        SmbCeReleaseResource();

        if (AcquireExclusive || AcquireShare) {
            RxReleaseFcbResourceInMRx( capFcb );
        }

        RxWaitSync(RxContext);

        Status = WaitingContext.Status;

        KeInitializeEvent(
            &RxContext->SyncEvent,
            SynchronizationEvent,
            FALSE);

        if (AcquireExclusive) {
            RxAcquireExclusiveFcbResourceInMRx(capFcb);
        } else if (AcquireShare) {
            RxAcquireSharedFcbResourceInMRx(capFcb);
        }
    }

FINALLY:
    return Status;
}


NTSTATUS
MRxSmbCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    RX_BLOCK_CONDITION FinalSrvOpenCondition;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       Status = STATUS_SUCCESS;
    } else {
       Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(smbSrvOpen->hfShadow == 0);
    } else {
        if (smbSrvOpen->hfShadow != 0) {
            MRxSmbCscReportFileOpens();
        }
    }

    return Status;
}

NTSTATUS
MRxSmbComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps the SMB specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    ULONG OplockLevel,NewBufferingState;

    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(pMRxSrvOpen);
    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(pMRxSrvOpen->pFcb);

    PAGED_CODE();

    ASSERT(pNewBufferingState != NULL);

    OplockLevel = PtrToUlong(pMRxContext);

    if (OplockLevel == SMB_OPLOCK_LEVEL_II) {
        NewBufferingState = (FCB_STATE_READBUFFERING_ENABLED  |
                             FCB_STATE_READCACHEING_ENABLED);
    } else {
        NewBufferingState = 0;
    }

    pMRxSrvOpen->BufferingFlags = NewBufferingState;

    MRxSmbMungeBufferingIfWriteOnlyHandles(
        smbFcb->WriteOnlySrvOpenCount,
        pMRxSrvOpen);

    *pNewBufferingState = pMRxSrvOpen->BufferingFlags;

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbConstructDeferredOpenContext (
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine saves enough state that we can come back later and really do an
    open if needed. We only do this for NT servers.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    RxCaptureFobx;

    PMRX_SRV_OPEN         SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN     smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = (PSMBCEDB_SERVER_ENTRY)RxContext->Create.pSrvCall->Context;
    PSMBCE_SERVER         pServer = &pServerEntry->Server;

    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext;
    PDFS_NAME_CONTEXT   pDNC=NULL;
    DWORD       cbSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbConstructDeferredOpenContext\n"));

    //if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS) && !MRxSmbBootedRemotely) {
    //    goto FINALLY;
    //}

    ASSERT(smbSrvOpen->DeferredOpenContext == NULL);

    cbSize = sizeof(MRX_SMB_DEFERRED_OPEN_CONTEXT);

    // if there is a dfs name context, we need to allocate memory
    // fot aht too, because the name that is included in the
    // context is deallocated by DFS when it returns from the create call

    if(pDNC = RxContext->Create.NtCreateParameters.DfsNameContext)
    {
        cbSize += (sizeof(DFS_NAME_CONTEXT)+pDNC->UNCFileName.MaximumLength+sizeof(DWORD));
    }

    DeferredOpenContext = RxAllocatePoolWithTag(
                              NonPagedPool,
                              cbSize,
                              MRXSMB_DEFROPEN_POOLTAG);

    if (DeferredOpenContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    smbSrvOpen->DeferredOpenContext = DeferredOpenContext;
    DeferredOpenContext->NtCreateParameters = RxContext->Create.NtCreateParameters;
    DeferredOpenContext->RxContextCreateFlags = RxContext->Create.Flags;
    DeferredOpenContext->RxContextFlags = RxContext->Flags;
    DeferredOpenContext->NtCreateParameters.SecurityContext = NULL;
    MRxSmbAdjustCreateParameters(RxContext, &DeferredOpenContext->SmbCp);

    SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
    if (pDNC)
    {
        PDFS_NAME_CONTEXT   pDNCDeferred=NULL;

        // point the dfs name context after the rxcontext

        pDNCDeferred = (PDFS_NAME_CONTEXT)((PBYTE)DeferredOpenContext+sizeof(MRX_SMB_DEFERRED_OPEN_CONTEXT));
        DeferredOpenContext->NtCreateParameters.DfsNameContext = pDNCDeferred;

        // copy the info
        *pDNCDeferred = *pDNC;

        if (pDNC->UNCFileName.Length)
        {
            ASSERT(pDNC->UNCFileName.Buffer);

            // point the name buffer after deferredcontext+dfs_name_context

            pDNCDeferred->UNCFileName.Buffer = (PWCHAR)((PBYTE)pDNCDeferred+sizeof(DFS_NAME_CONTEXT));

            memcpy(pDNCDeferred->UNCFileName.Buffer,
                   pDNC->UNCFileName.Buffer,
                   pDNC->UNCFileName.Length);

        }

    }


 FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbConstructDeferredOpenContext, Status=%08lx\n",Status));
    return Status;
}

VOID
MRxSmbAdjustCreateParameters (
    PRX_CONTEXT RxContext,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This uses the RxContext as a base to reeach out and get the values of the NT
   create parameters. It also (a) implements the SMB idea that unbuffered is
   translated to write-through and (b) gets the SMB security flags.

Arguments:


Return Value:


Notes:

--*/
{
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbAdjustCreateParameters\n"));

    //CODE.IMPROVEMENT we might be better off looking for a deferred-open-context instead of
    //                 minirdr-initiated.

    if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED)) {
        cp->CreateOptions = cp->CreateOptions & ~(FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT);

        //the NT SMB spec says we have to change no-intermediate-buffering to write-through
        if (FlagOn(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING)) {
            ASSERT (RxContext->CurrentIrpSp!=NULL);
            if (RxContext->CurrentIrpSp!=NULL) {
                PFILE_OBJECT capFileObject = RxContext->CurrentIrpSp->FileObject;//sigh...CODE.IMPROVEMENT cp??
                ClearFlag(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING);
                SetFlag(cp->CreateOptions,FILE_WRITE_THROUGH);
                SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH);
                SetFlag(capFileObject->Flags,FO_WRITE_THROUGH);
            }
        }

        smbcp->Pid = RxGetRequestorProcessId(RxContext);
        smbcp->SecurityFlags = 0;
        if (cp->SecurityContext != NULL) {
            if (cp->SecurityContext->SecurityQos != NULL) {
                if (cp->SecurityContext->SecurityQos->ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {
                    smbcp->SecurityFlags |= SMB_SECURITY_DYNAMIC_TRACKING;
                }
                if (cp->SecurityContext->SecurityQos->EffectiveOnly) {
                    smbcp->SecurityFlags |= SMB_SECURITY_EFFECTIVE_ONLY;
                }
            }
        }

    } else {

        //here, we have a defered open!!!

        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

        //the parameters have already been adjusted...BUT null the security context.......
        cp->SecurityContext = NULL;
        *smbcp = smbSrvOpen->DeferredOpenContext->SmbCp;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbAdjustCreateParameters\n"));
}

INLINE VOID
MRxSmbAdjustReturnedCreateAction(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine repairs a bug in NT servers whereby the create action is
   contaminated by an oplock break. Basically, we make sure that if the guy
   asked for FILE_OPEN and it works then he does not get FILE_SUPERCEDED or
   FILE_CREATED as the result.

Arguments:

    RxContext - the context for the operation so as to find the place where
                info is returned

Return Value:

    none

Notes:

--*/
{
    ULONG q = RxContext->Create.ReturnedCreateInformation;

    PAGED_CODE();

    if ((q==FILE_SUPERSEDED)||(q==FILE_CREATED)||(q >FILE_MAXIMUM_DISPOSITION)) {
        RxContext->Create.ReturnedCreateInformation = FILE_OPENED;
    }
}

UNICODE_STRING UnicodeBackslash = {2,4,L"\\"};

NTSTATUS
MRxSmbBuildNtCreateAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This builds an NtCreateAndX SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = StufferState->RxContext;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    RxCaptureFcb;

    ACCESS_MASK DesiredAccess;
    ULONG       OplockFlags;
    ULONG       CreateOptions;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMBCE_SERVER pServer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildNtCreateAndX\n", 0 ));

    pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    if (!pServer->IsLoopBack &&
        !(cp->CreateOptions & FILE_DIRECTORY_FILE) &&
        (cp->DesiredAccess & (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE )) &&
        !MRxSmbOplocksDisabled
#if defined(REMOTE_BOOT)
        && (!pServer->IsRemoteBootServer || !MRxSmbOplocksDisabledOnRemoteBootClients)
#endif // defined(REMOTE_BOOT)
        ) {

       DesiredAccess = cp->DesiredAccess & ~SYNCHRONIZE;
       OplockFlags   = (NT_CREATE_REQUEST_OPLOCK | NT_CREATE_REQUEST_OPBATCH);
    } else {
       DesiredAccess = cp->DesiredAccess;
       OplockFlags   = 0;
    }

    if (FlagOn(pServer->DialectFlags,DF_NT_STATUS)) {
        CreateOptions = cp->CreateOptions;
    } else {
        // Samba server negotiates NT dialect bug doesn't support delete_on_close
        CreateOptions = cp->CreateOptions & ~FILE_DELETE_ON_CLOSE;
    }

    OplockFlags |= NT_CREATE_REQUEST_EXTENDED_RESPONSE;

    if ((RemainingName->Length==0)
           && (FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH)) ) {
        RemainingName = &UnicodeBackslash;
    }
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_NT_CREATE_ANDX, SMB_REQUEST_SIZE(NT_CREATE_ANDX),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );
    SmbCeSetFullProcessIdInHeader(
        StufferState->Exchange,
        smbcp->Pid,
        ((PNT_SMB_HEADER)StufferState->BufferBase));

    MRxSmbStuffSMB (StufferState,
       "XmwdddDdddDddyB",
                                  //  X         UCHAR WordCount;                    // Count of parameter words = 24
                                  //  .         UCHAR AndXCommand;                  // Secondary command; 0xFF = None
                                  //  .         UCHAR AndXReserved;                 // MBZ
                                  //  .         _USHORT( AndXOffset );              // Offset to next command wordcount
                                  //  m         UCHAR Reserved;                     // MBZ
           BooleanFlagOn(pServer->DialectFlags,DF_UNICODE)?
               RemainingName->Length:RtlxUnicodeStringToOemSize(RemainingName),
                                  //  w         _USHORT( NameLength );              // Length of Name[] in bytes
           OplockFlags,           //  d         _ULONG( Flags );                    // Create flags
           0, //not used          //  d         _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
           DesiredAccess,         //  d         ACCESS_MASK DesiredAccess;          // NT access desired
                                  //  Dd        LARGE_INTEGER AllocationSize;       // Initial allocation size
           SMB_OFFSET_CHECK(NT_CREATE_ANDX,AllocationSize)
           cp->AllocationSize.LowPart, cp->AllocationSize.HighPart,
           cp->FileAttributes,    //  d         _ULONG( FileAttributes );           // File attributes for creation
           cp->ShareAccess,       //  d         _ULONG( ShareAccess );              // Type of share access
                                  //  D         _ULONG( CreateDisposition );        // Action to take if file exists or not
           SMB_OFFSET_CHECK(NT_CREATE_ANDX,CreateDisposition)
           cp->Disposition,
           CreateOptions,         //  d         _ULONG( CreateOptions );            // Options to use if creating a file
           cp->ImpersonationLevel,//  d         _ULONG( ImpersonationLevel );       // Security QOS information
           smbcp->SecurityFlags,  //  y         UCHAR SecurityFlags;                // Security QOS information
           SMB_WCT_CHECK(24) 0    //  B         _USHORT( ByteCount );               // Length of byte parameters
                                  //  .         UCHAR Buffer[1];
                                  //  .         //UCHAR Name[];                       // File to open or create
           );

    //proceed with the stuff because we know here that the name fits

    //CODE.IMPROVEMENT we don't need to copy here, we can just Mdl like in writes
    MRxSmbStuffSMB(StufferState,
                   BooleanFlagOn(pServer->DialectFlags,DF_UNICODE)?"u!":"z!",
                   RemainingName);

    MRxSmbDumpStufferState (700,"SMB w/ NTOPEN&X after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

UNICODE_STRING MRxSmbOpenAndX_PipeString =
      {sizeof(L"\\PIPE")-sizeof(WCHAR),sizeof(L"\\PIPE"),L"\\PIPE"};

NTSTATUS
MRxSmbBuildOpenAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This builds an OpenAndX SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
    PSMB_EXCHANGE Exchange = StufferState->Exchange;
    RxCaptureFcb;

    PSMBCE_SERVER pServer;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    // CODE.IMPROVEMENT a possible good idea would be to share the translation
    // code with downlevel.......
    USHORT smbDisposition;
    USHORT smbSharingMode;
    USHORT smbAttributes;
    ULONG smbFileSize;
    USHORT smbOpenMode;
    USHORT OpenAndXFlags = (SMB_OPEN_QUERY_INFORMATION);

    //CODE.IMPROVEMENT this value appears all over the rdr
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildOpenAndX\n", 0 ));

    pServer = SmbCeGetExchangeServer(Exchange);

    smbDisposition = MRxSmbMapDisposition(cp->Disposition);
    smbSharingMode = MRxSmbMapShareAccess(((USHORT)cp->ShareAccess));
    smbAttributes = MRxSmbMapFileAttributes(cp->FileAttributes);
    smbFileSize = cp->AllocationSize.LowPart;
    smbOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);
    smbSharingMode |= smbOpenMode;

    if (cp->CreateOptions & FILE_WRITE_THROUGH) {
        smbSharingMode |= SMB_DA_WRITE_THROUGH;
    }

    //lanman10 servers apparently don't like to get the time passed in.......
    if (FlagOn(pServer->DialectFlags,DF_LANMAN20)) {

        KeQuerySystemTime(&CurrentTime);
        MRxSmbTimeToSecondsSince1970(&CurrentTime,
                                     pServer,
                                     &SecondsSince1970);
    } else {
        SecondsSince1970 = 0;
    }

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_OPEN_ANDX, SMB_REQUEST_SIZE(OPEN_ANDX),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbStuffSMB (StufferState,
         "XwwwwdwDddB",
                                    //  X         UCHAR WordCount;                    // Count of parameter words = 15
                                    //  .         UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                    //  .         UCHAR AndXReserved;                 // Reserved (must be 0)
                                    //  .         _USHORT( AndXOffset );              // Offset to next command WordCount
             OpenAndXFlags,         //  w         _USHORT( Flags );                   // Additional information: bit set-
                                    //                                                //  0 - return additional info
                                    //                                                //  1 - set single user total file lock
                                    //                                                //  2 - server notifies consumer of
                                    //                                                //      actions which may change file
             smbSharingMode,        //  w         _USHORT( DesiredAccess );           // File open mode
             SearchAttributes,      //  w         _USHORT( SearchAttributes );
             smbAttributes,         //  w         _USHORT( FileAttributes );
             SecondsSince1970,      //  d         _ULONG( CreationTimeInSeconds );
             smbDisposition,        //  w         _USHORT( OpenFunction );
                                    //  D         _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
             SMB_OFFSET_CHECK(OPEN_ANDX,AllocationSize)
             smbFileSize,
             0xffffffff,            //  d         _ULONG( Timeout );                  // Max milliseconds to wait for resource
             0,                     //  d         _ULONG( Reserved );                 // Reserved (must be 0)
             SMB_WCT_CHECK(15) 0    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 1
                                    //            UCHAR Buffer[1];                    // File name
             );
    //proceed with the stuff because we know here that the name fits

    if (capFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        //for open&x, you have to put \PIPE if it's a pipe....
        MRxSmbStuffSMB (StufferState,"z>!", &MRxSmbOpenAndX_PipeString,RemainingName);
    } else {
        MRxSmbStuffSMB (StufferState,"z!", RemainingName);
    }

    MRxSmbDumpStufferState (700,"SMB w/ OPEN&X after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildOpenPrintFile (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds an OpenPrintFile SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    WCHAR UserNameBuffer[UNLEN + 1];
    WCHAR UserDomainNameBuffer[UNLEN + 1];

    UNICODE_STRING UserName,UserDomainName;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbOpenPrintFile\n", 0 ));

    UserName.Length = UserName.MaximumLength = UNLEN * sizeof(WCHAR);
    UserName.Buffer = UserNameBuffer;
    UserDomainName.Length = UserDomainName.MaximumLength = UNLEN * sizeof(WCHAR);
    UserDomainName.Buffer = UserDomainNameBuffer;

    Status = SmbCeGetUserNameAndDomainName(
                 SmbCeGetExchangeSessionEntry(StufferState->Exchange),
                 &UserName,
                 &UserDomainName);

    if (Status != STATUS_SUCCESS) {
        RtlInitUnicodeString(&UserName,L"RDR2ID");
    } else {
        RtlUpcaseUnicodeString(&UserName,&UserName,FALSE);
    }

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_OPEN_PRINT_FILE, SMB_REQUEST_SIZE(OPEN_PRINT_FILE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    SmbCeSetFullProcessIdInHeader(
        StufferState->Exchange,
        RxGetRequestorProcessId(RxContext),
        ((PNT_SMB_HEADER)StufferState->BufferBase));

    // note that we hardwire graphics..........
    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
             0,                     //  w         _USHORT( SetupLength );             // Length of printer setup data
             1,                     //  w         _USHORT( Mode );                    // 0 = Text mode (DOS expands TABs)
                                    //                                                // 1 = Graphics mode
             SMB_WCT_CHECK(2)       //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
             &UserName              //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR IdentifierString[];         //  Identifier string
             );

    MRxSmbDumpStufferState (700,"SMB w/ openprintfile after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

typedef enum _SMBPSE_CREATE_METHOD {
    CreateAlreadyDone,
    CreateUseCore,
    CreateUseNT
} SMBPSE_CREATE_METHOD;

NTSTATUS
SmbPseExchangeStart_Create(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    NTSTATUS SetupStatus = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    SMBPSE_CREATE_METHOD CreateMethod = CreateAlreadyDone;
    PSMBCE_SERVER pServer;
    ULONG DialectFlags;

    RxCaptureFcb;
    PMRX_SMB_FCB      smbFcb  = MRxSmbGetFcbExtension(capFcb);
    PMRX_NET_ROOT     NetRoot = capFcb->pNetRoot;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_NET_ROOT   pSmbNetRoot = &(OrdinaryExchange->SmbCeContext.pVNetRootContext->pNetRootEntry->NetRoot);

    PBOOLEAN MustRegainExclusiveResource = &OrdinaryExchange->Create.MustRegainExclusiveResource;
    BOOLEAN CreateWithEasSidsOrLongName = OrdinaryExchange->Create.CreateWithEasSidsOrLongName;
    BOOLEAN fRetryCore = FALSE;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Create\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    DialectFlags = pServer->DialectFlags;

    COVERED_CALL(MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)));

    if (!smbSrvOpen->HotReconnectInProgress) {
        *MustRegainExclusiveResource = TRUE;
    }

    if (!FlagOn(DialectFlags,DF_NT_SMBS)) {
        OEM_STRING      OemString;
        PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

        if (PathName->Length != 0) {
            Status = RtlUnicodeStringToOemString(&OemString, PathName, TRUE);

            if (!NT_SUCCESS(Status)) {
                goto FINALLY;
            }

            //
            //  If we are canonicalizing as FAT, use FAT rules, otherwise use
            //  HPFS rules.
            //

            if (!FlagOn(DialectFlags,DF_LANMAN20)) {
                if (!FsRtlIsFatDbcsLegal(OemString, FALSE, TRUE, TRUE)) {
                    RtlFreeOemString(&OemString);
                    Status = STATUS_OBJECT_NAME_INVALID;
                    goto FINALLY;
                }
            } else if (!FsRtlIsHpfsDbcsLegal(OemString, FALSE, TRUE, TRUE)) {
                RtlFreeOemString(&OemString);
                Status = STATUS_OBJECT_NAME_INVALID;
                goto FINALLY;
            }

            RtlFreeOemString(&OemString);
        }
    }

    if (StufferState->PreviousCommand != SMB_COM_NO_ANDX_COMMAND) {
        // we have a latent session setup /tree connect command

        //CODE.IMPROVEMENT for nt4.0+ we should get things changed so that NT_CREATE&X is a valid
        //   followon for SS&X and TC&X. we would get a bit better performance for NT3.51- if we
        //   used an open&x here instead.

        //the status of the embedded header commands is passed back in the flags...joejoe make a proc
        SetupStatus = SmbPseOrdinaryExchange(
                          SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                          SMBPSE_OETYPE_LATENT_HEADEROPS
                          );

        if(SetupStatus != STATUS_SUCCESS) {
            Status = SetupStatus;
            goto FINALLY;
        }

        SmbCeUpdateSessionEntryAndVNetRootContext((PSMB_EXCHANGE)OrdinaryExchange);

        // Turn off reconnect attempts now that we have successfully established
        // the session and net root.
        OrdinaryExchange->SmbCeFlags &= ~(SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

        COVERED_CALL(MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)));
    }


    if (!CreateWithEasSidsOrLongName) {
        PUNICODE_STRING AlreadyPrefixedName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
        PMRXSMB_CREATE_PARAMETERS SmbCp = &OrdinaryExchange->Create.SmbCp;
        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
        USHORT mappedOpenMode;

        MRxSmbAdjustCreateParameters(RxContext,SmbCp);
        mappedOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);

        if (capFcb->pNetRoot->Type == NET_ROOT_PRINT) {

            COVERED_CALL(MRxSmbBuildOpenPrintFile(StufferState));

            Status = SmbPseOrdinaryExchange(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         SMBPSE_OETYPE_CREATEPRINTFILE
                         );

        } else if ((!MRxSmbForceNoNtCreate)
                        && FlagOn(DialectFlags,DF_NT_SMBS)) {

            BOOLEAN SecurityIsNULL =
                        (cp->SecurityContext == NULL) ||
                        (cp->SecurityContext->AccessState == NULL) ||
                        (cp->SecurityContext->AccessState->SecurityDescriptor == NULL);

            CreateMethod = CreateUseNT;

            //now catch the cases where we want to pseudoopen the file

            if ( MRxSmbDeferredOpensEnabled &&
                 !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED) &&
                 (capFcb->pNetRoot->Type == NET_ROOT_DISK) &&
                 SecurityIsNULL) {

                ASSERT( RxContext->CurrentIrp != 0 );

                if ((cp->Disposition==FILE_OPEN) &&
                    !BooleanFlagOn(cp->CreateOptions, FILE_OPEN_FOR_BACKUP_INTENT) &&
                    (!(cp->DesiredAccess & DELETE)||(capFcb->OpenCount == 0)) &&
                    (MustBeDirectory(cp->CreateOptions) ||
                     !(cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)))){

                    // NT apps expect that you will not succeed the create and then fail the attribs;
                    // if we had some way of identifying win32 apps then we could defer these (except
                    // for DFS). since we have no way to get that information (and don't even have
                    // a good SMB to send..........)

                    // we don't need to send the open for DELETE and FILE_READ_ATTRIBUTES requests since
                    // there are path basied SMB operations.

                    // we can also pseudoopen directories for file_open at the root of the
                    // share but otherwise we have to at least check that the directory
                    // exists. we might have to push out the open later. BTW, we wouldn't be
                    // in here if the name was too long for a GFA or CheckPath

                    Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(
                                  OrdinaryExchange,
                                  MustBeDirectory(cp->CreateOptions)?FileTypeDirectory:FileTypeFile);

                    if (Status == STATUS_SUCCESS) {
                        // query the basic information to make sure the file exists on the server
                        //DbgPrint("Query basic with path\n");
                        Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                     SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                     FileBasicInformation);

                        if (Status == STATUS_SUCCESS) {
                            if (MustBeDirectory(cp->CreateOptions)) {
                                if (!OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                                    Status = STATUS_NOT_A_DIRECTORY;
                                }
                            } else {
                                if (OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                                    capFcb->Header.NodeTypeCode = RDBSS_STORAGE_NTC(FileTypeDirectory);
                                    smbFcb->dwFileAttributes = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
                                }
                            }
                        }

                        if ((Status == STATUS_SUCCESS) &&
                            (cp->DesiredAccess & DELETE) &&
                            (smbFcb->IndexNumber.QuadPart == 0) &&
                            (FlagOn(DialectFlags,DF_EXTENDED_SECURITY)) &&
                            (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_NTFS)) {
                            // query internal information for the FID
                            //DbgPrint("Query Internal with path\n");
                            Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                         FileInternalInformation);

                            if (Status == STATUS_SUCCESS) {
                                smbFcb->IndexNumber = OrdinaryExchange->Create.FileInfo.Internal.IndexNumber;
                                //DbgPrint("FCB %x smbFcb %x %08x%08x\n",capFcb,smbFcb,smbFcb->IndexNumber.HighPart,smbFcb->IndexNumber.LowPart);
                            }
                        }

                        if (Status != STATUS_SUCCESS) {
                            RxFreePool(smbSrvOpen->DeferredOpenContext);
                            smbSrvOpen->DeferredOpenContext = NULL;
                        }
                    }

                    CreateMethod = CreateAlreadyDone;
                }
            }

            //if no pseudoopen case was hit, do a real open

            if (CreateMethod == CreateUseNT) {

               //use NT_CREATE&X
                COVERED_CALL(MRxSmbBuildNtCreateAndX(StufferState,SmbCp));

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_CREATE
                             );

                if ((Status != STATUS_SUCCESS) &&
                    (NetRoot->Type == NET_ROOT_PIPE) &&
                    (OrdinaryExchange->SendCompletionStatus != STATUS_SUCCESS)) {
                    // If a cluster server disconnect, the VC is valid until the send operation.
                    // A retry will ensure the seamless failover for PIPE creation.
                    Status = STATUS_RETRY;
                }

                if (Status == STATUS_SUCCESS && RxContext->pFobx == NULL) {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                }

                if ((Status == STATUS_SUCCESS) && (cp->Disposition == FILE_OPEN)) {
                    MRxSmbAdjustReturnedCreateAction(RxContext);
                }

                if (Status == STATUS_SUCCESS) {
                    MRxSmbInvalidateFileNotFoundCache(RxContext);
                }

                if ((Status == STATUS_SUCCESS) &&
                    (smbFcb->IndexNumber.QuadPart == 0) &&
                    (FlagOn(DialectFlags,DF_EXTENDED_SECURITY)) &&
                    (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_NTFS)) {

                    // query internal information for the FID
                    Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                 FileInternalInformation);

                    if (Status == STATUS_SUCCESS) {
                        smbFcb->IndexNumber = OrdinaryExchange->Create.FileInfo.Internal.IndexNumber;
                        //DbgPrint("FCB %x smbFcb %x %08x%08x\n",capFcb,smbFcb,smbFcb->IndexNumber.HighPart,smbFcb->IndexNumber.LowPart);
                    }
                }
            }
        } else if (FlagOn(DialectFlags, DF_LANMAN10) &&
                   (mappedOpenMode != ((USHORT)-1)) &&
                   !MustBeDirectory(cp->CreateOptions)) {
            PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

            if (MRxSmbDeferredOpensEnabled &&
                capFcb->pNetRoot->Type == NET_ROOT_DISK &&
                !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED) &&
                (pServer->Dialect != LANMAN21_DIALECT || MustBeDirectory(cp->CreateOptions)) &&
                (cp->Disposition==FILE_OPEN) && ((PathName->Length == 0) ||
                ((cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES)) == 0)) ){

                // we don't need to send the open for DELETE and FILE_READ_ATTRIBUTES requests since
                // there are path basied SMB operations.
                // we should do pseudo open for FILE_WRITE_ATTRIBUTES. Othewise the server will return
                // sharing violation


                // send query path information to make sure the file exists on the server

                Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(
                              OrdinaryExchange,
                              MustBeDirectory(cp->CreateOptions)?FileTypeDirectory:FileTypeFile);

                if (Status == STATUS_SUCCESS && AlreadyPrefixedName->Length > 0) {
                    Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                 FileBasicInformation);

                    if (Status != STATUS_SUCCESS) {
                        RxFreePool(smbSrvOpen->DeferredOpenContext);
                        smbSrvOpen->DeferredOpenContext = NULL;
                    }
                }

                CreateMethod = CreateAlreadyDone;
            } else {
                //use OPEN&X
                COVERED_CALL(MRxSmbBuildOpenAndX(StufferState,SmbCp));    //CODE.IMPROVEMENT dont pass smbcp

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_CREATE
                             );

                if (Status == STATUS_ACCESS_DENIED && !FlagOn(DialectFlags,DF_NT_SMBS)) {
                    CreateMethod = CreateUseCore;
                    fRetryCore = TRUE;
                }
            }
        } else {

            CreateMethod = CreateUseCore;
        }

        if (CreateMethod == CreateUseCore) {

            Status = MRxSmbDownlevelCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

            // put back the real error code if we are retrying open&x
            if ((Status != STATUS_SUCCESS) && fRetryCore)
            {
                Status = STATUS_ACCESS_DENIED;
            }

        }
    }

FINALLY:

    if (*MustRegainExclusiveResource) {
        SMBFCB_HOLDING_STATE *SmbFcbHoldingState = &OrdinaryExchange->SmbFcbHoldingState;
        if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
            MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        }

        RxAcquireExclusiveFcbResourceInMRx( capFcb );
    }

    // now that we have the fcb exclusive, we can do some updates

    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE)) {
        smbFcb->WriteOnlySrvOpenCount++;
    }

    MRxSmbMungeBufferingIfWriteOnlyHandles(
        smbFcb->WriteOnlySrvOpenCount,
        SrvOpen
        );

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Create exit w %08lx\n", Status ));
    return Status;
}

VOID
MRxSmbSetSrvOpenFlags (
    PRX_CONTEXT         RxContext,
    RX_FILE_TYPE        StorageType,
    PMRX_SRV_OPEN       SrvOpen,
    PMRX_SMB_SRV_OPEN   smbSrvOpen
    )
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("MRxSmbSetSrvOpenFlags      oplockstate =%08lx\n", smbSrvOpen->OplockLevel ));

    SrvOpen->BufferingFlags = 0;

    if (!FlagOn(SrvOpen->pFcb->Attributes,FILE_ATTRIBUTE_SPARSE_FILE) ) {
        switch (smbSrvOpen->OplockLevel) {
        case SMB_OPLOCK_LEVEL_II:
            SrvOpen->BufferingFlags |= (FCB_STATE_READBUFFERING_ENABLED  |
                                       FCB_STATE_READCACHEING_ENABLED);
            break;

        case SMB_OPLOCK_LEVEL_BATCH:
            if (StorageType == FileTypeFile) {
               SrvOpen->BufferingFlags |= FCB_STATE_COLLAPSING_ENABLED;
            }
            // lack of break intentional

        case SMB_OPLOCK_LEVEL_EXCLUSIVE:
            SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED  |
                                       FCB_STATE_FILESIZECACHEING_ENABLED |
                                       FCB_STATE_FILETIMECACHEING_ENABLED |
                                       FCB_STATE_WRITEBUFFERING_ENABLED |
                                       FCB_STATE_LOCK_BUFFERING_ENABLED |
                                       FCB_STATE_READBUFFERING_ENABLED  |
                                       FCB_STATE_READCACHEING_ENABLED);

            break;

        default:
            ASSERT(!"Valid Oplock Level for Open");

        case SMB_OPLOCK_LEVEL_NONE:
            break;
        }
    }

    SrvOpen->Flags |= MRxSmbInitialSrvOpenFlags;
}

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT             RxContext,
    PBOOLEAN                MustRegainExclusiveResource,
    SMBFCB_HOLDING_STATE    *SmbFcbHoldingState,
    RX_FILE_TYPE            StorageType,
    SMB_FILE_ID             Fid,
    ULONG                   ServerVersion,
    UCHAR                   OplockLevel,
    ULONG                   CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    )
/*++

Routine Description:

    This routine finishes the initialization of the fcb and srvopen for a successful open.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;

    PMRX_SMB_FCB              smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN             SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN         smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY     pServerEntry = (PSMBCEDB_SERVER_ENTRY)RxContext->Create.pSrvCall->Context;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
    ACCESS_MASK               DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;

    BOOLEAN ThisIsAPseudoOpen;

    FCB_INIT_PACKET LocalInitPacket, *InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCreateFileSuccessTail\n", 0 ));

    smbSrvOpen->Fid = Fid;
    smbSrvOpen->Version = ServerVersion;

    if (smbSrvOpen->HotReconnectInProgress) {
        PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

        //capFcb->ActualAllocationLength = pFileInfo->Standard.AllocationSize.QuadPart;
        //capFcb->Header.AllocationSize = pFileInfo->Standard.AllocationSize;
        //capFcb->Header.FileSize = pFileInfo->Standard.EndOfFile;
        //capFcb->Header.ValidDataLength  = pFileInfo->Standard.EndOfFile;

        // in case oplock breaks after re-open
        if ((smbSrvOpen->OplockLevel != OplockLevel) &&
            (pServerEntry->pRdbssSrvCall != NULL)) {
            ULONG NewOplockLevel;

            switch (OplockLevel) {
            case OPLOCK_BROKEN_TO_II:
               NewOplockLevel = SMB_OPLOCK_LEVEL_II;
               break;

            case OPLOCK_BROKEN_TO_NONE:
            default:
               NewOplockLevel = SMB_OPLOCK_LEVEL_NONE;
            }

            RxIndicateChangeOfBufferingState(
                     pServerEntry->pRdbssSrvCall,
                     MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId, Fid),
                     ULongToPtr(NewOplockLevel));
        }
    } else {
        PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
        ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

        if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
            MRxSmbCscReleaseSmbFcb(
                RxContext,
                SmbFcbHoldingState);
        }

        if (*MustRegainExclusiveResource) {
            //this is required because of oplock breaks

            RxAcquireExclusiveFcbResourceInMRx( capFcb );
            *MustRegainExclusiveResource = FALSE;
        }

        if (RxContext->pFobx==NULL) {
            RxContext->pFobx = RxCreateNetFobx(RxContext, SrvOpen);
        }

        ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
        RxDbgTrace(
            0, Dbg,
            ("Storagetype %08lx/Fid %08lx/Action %08lx\n", StorageType, Fid, CreateAction ));

        pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);
        SrvOpen->Key = MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId,Fid);

        // UPGRADE OPLOCK ON READ ONLY
        if (DisableByteRangeLockingOnReadOnlyFiles &&
            (OplockLevel == SMB_OPLOCK_LEVEL_II) &&
            (FileInfo->Basic.FileAttributes & FILE_ATTRIBUTE_READONLY) &&
            ((DesiredAccess & FILE_GENERIC_READ) ||
             !(DesiredAccess & FILE_GENERIC_WRITE) ||
             !(DesiredAccess & ~(FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | STANDARD_RIGHTS_READ)))) {
            OplockLevel = SMB_OPLOCK_LEVEL_BATCH;
        }

        if (MRxSmbIsStreamFile(FileName,NULL)) {
            smbSrvOpen->OplockLevel = SMB_OPLOCK_LEVEL_NONE;
        } else {
            smbSrvOpen->OplockLevel = OplockLevel;
        }

        RxContext->Create.ReturnedCreateInformation = CreateAction;

        //CODE.IMPROVEMENT maybe we shouldn't set the allocation up here.....rather we should max it where we use it
        //sometimes the allocation is wrong! max it......

        //CODE.IMPROVEMENT why not use 64bit compare????
        if ( ((FileInfo->Standard.AllocationSize.HighPart == FileInfo->Standard.EndOfFile.HighPart)
                               && (FileInfo->Standard.AllocationSize.LowPart < FileInfo->Standard.EndOfFile.LowPart))
               || (FileInfo->Standard.AllocationSize.HighPart < FileInfo->Standard.EndOfFile.HighPart)
           ) {
            FileInfo->Standard.AllocationSize = FileInfo->Standard.EndOfFile;
        }

        smbFcb->LastCscTimeStampHigh = FileInfo->Basic.LastWriteTime.HighPart;
        smbFcb->LastCscTimeStampLow  = FileInfo->Basic.LastWriteTime.LowPart;
        smbFcb->NewShadowSize = FileInfo->Standard.EndOfFile;
        smbFcb->dwFileAttributes = FileInfo->Basic.FileAttributes;

        if (smbSrvOpen->OplockLevel > smbFcb->LastOplockLevel) {
            ClearFlag(
                capFcb->FcbState,
                FCB_STATE_TIME_AND_SIZE_ALREADY_SET);
        }

        smbFcb->LastOplockLevel = smbSrvOpen->OplockLevel;

        //the thing is this: if we have good info (not a pseudoopen) then we make the
        //finish call passing the init packet; otherwise, we make the call NOT passing an init packet

        ThisIsAPseudoOpen = BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

        if (!ThisIsAPseudoOpen &&
            !MRxSmbIsThisADisconnectedOpen(SrvOpen)) {

            MRxSmbCreateFileInfoCache(RxContext,
                                      FileInfo,
                                      pServerEntry,
                                      STATUS_SUCCESS);

            MRxSmbIncrementSrvOpenCount(pServerEntry,SrvOpen);
        }


        if ((capFcb->OpenCount == 0) ||
            (!ThisIsAPseudoOpen &&
             !FlagOn(capFcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET))) {
            if (!ThisIsAPseudoOpen) {
                RxFormInitPacket(
                    LocalInitPacket,
                    &FileInfo->Basic.FileAttributes,
                    &FileInfo->Standard.NumberOfLinks,
                    &FileInfo->Basic.CreationTime,
                    &FileInfo->Basic.LastAccessTime,
                    &FileInfo->Basic.LastWriteTime,
                    &FileInfo->Basic.ChangeTime,
                    &FileInfo->Standard.AllocationSize,
                    &FileInfo->Standard.EndOfFile,
                    &FileInfo->Standard.EndOfFile);
                InitPacket = &LocalInitPacket;

            } else {
                InitPacket = NULL;
            }

#if defined(REMOTE_BOOT)
            //
            // If the caller wants it (on a remote boot system), then
            // save the parameters to call RxFinishFcbInitialization
            // later.
            //

            if (smbFcb->FinishFcbInitParameters) {
                smbFcb->FinishFcbInitParameters->CallFcbFinishInit = TRUE;
                smbFcb->FinishFcbInitParameters->FileType = RDBSS_STORAGE_NTC(StorageType);
                if (InitPacket) {
                    smbFcb->FinishFcbInitParameters->InitPacketProvided = TRUE;
                    RtlCopyMemory(
                        &smbFcb->FinishFcbInitParameters->InitPacket,
                        InitPacket,
                        sizeof(FCB_INIT_PACKET));
                } else {
                    smbFcb->FinishFcbInitParameters->InitPacketProvided = FALSE;
                }
            } else
#endif // defined(REMOTE_BOOT)

            // initialize only if the filesize version is identical.
            // This takes care of the situation where a create has retruned from the server
            // with some file size, and before it gets here the file has been extended
            // and the size has increased.
            // The version is snapped by the create in SrvOpen and is incremented
            // by the code that extends the filesize (in extending write)

            if (((PFCB)capFcb)->ulFileSizeVersion == SrvOpen->ulFileSizeVersion)
            {
                RxFinishFcbInitialization( capFcb,
                                           RDBSS_STORAGE_NTC(StorageType),
                                           InitPacket
                                         );
            }

            if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {
                PPAGING_FILE_CONTEXT PagingFileContext;

                ASSERT(FALSE);
                PagingFileContext = RxAllocatePoolWithTag(NonPagedPool,
                                                          sizeof(PAGING_FILE_CONTEXT),
                                                          MRXSMB_MISC_POOLTAG);

                if (PagingFileContext != NULL) {
                    PagingFileContext->pSrvOpen = SrvOpen;
                    PagingFileContext->pFobx = RxContext->pFobx;

                    InsertHeadList(
                        &MRxSmbPagingFilesSrvOpenList,
                        &PagingFileContext->ContextList);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        if (Status == STATUS_SUCCESS &&
            !SmbCeIsServerInDisconnectedMode(pServerEntry) &&
            pVNetRootContext->pNetRootEntry->IsRemoteBoot) {

            if (smbSrvOpen->DeferredOpenContext == NULL) {
                Status = MRxSmbConstructDeferredOpenContext(RxContext);

                if (Status == STATUS_SUCCESS) {
                    smbSrvOpen->DeferredOpenContext->NtCreateParameters.Disposition = FILE_OPEN;
                    ClearFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
                }
            }
        }

        MRxSmbSetSrvOpenFlags(RxContext,StorageType,SrvOpen,smbSrvOpen);

        //(wrapperFcb->Condition) = Condition_Good;

        RxContext->pFobx->OffsetOfNextEaToReturn = 1;
        //transition happens later
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCreateFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

NTSTATUS
MRxSmbFinishNTCreateAndX (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    PRESP_NT_CREATE_ANDX        Response
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTCreate_AndX response.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    RxCaptureFcb;

    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_SESSION      pSession = SmbCeGetExchangeSession(OrdinaryExchange);
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetExchangeNetRootEntry(OrdinaryExchange);
    PSMBCE_SERVER        pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    PSMBCE_NET_ROOT   pSmbNetRoot = &(pNetRootEntry->NetRoot);
    PMRX_SMB_FCB           smbFcb = MRxSmbGetFcbExtension(capFcb);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishNTCreateAndX\n", 0 ));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (FlagOn(pServer->DialectFlags,DF_NT_STATUS) &&
        RxContext->Create.NtCreateParameters.CreateOptions & FILE_DELETE_ON_CLOSE) {
        // Samba server negotiates NT dialect but doesn't support delete_after_close

        PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
        SetFlag((smbFcb)->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
    }

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
        StorageType = Response->Directory
                      ?(FileTypeDirectory)
                      :(FileTypeFile);
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    Fid  = SmbGetUshort(&Response->Fid);

    CreateAction = SmbGetUlong(&Response->CreateAction);

    pFileInfo->Basic.FileAttributes             = SmbGetUlong(&Response->FileAttributes);
    pFileInfo->Standard.NumberOfLinks           = 1;
    pFileInfo->Basic.CreationTime.LowPart       = SmbGetUlong(&Response->CreationTime.LowPart);
    pFileInfo->Basic.CreationTime.HighPart      = SmbGetUlong(&Response->CreationTime.HighPart);
    pFileInfo->Basic.LastAccessTime.LowPart     = SmbGetUlong(&Response->LastAccessTime.LowPart);
    pFileInfo->Basic.LastAccessTime.HighPart    = SmbGetUlong(&Response->LastAccessTime.HighPart);
    pFileInfo->Basic.LastWriteTime.LowPart      = SmbGetUlong(&Response->LastWriteTime.LowPart);
    pFileInfo->Basic.LastWriteTime.HighPart     = SmbGetUlong(&Response->LastWriteTime.HighPart);
    pFileInfo->Basic.ChangeTime.LowPart         = SmbGetUlong(&Response->ChangeTime.LowPart);
    pFileInfo->Basic.ChangeTime.HighPart        = SmbGetUlong(&Response->ChangeTime.HighPart);
    pFileInfo->Standard.AllocationSize.LowPart  = SmbGetUlong(&Response->AllocationSize.LowPart);
    pFileInfo->Standard.AllocationSize.HighPart = SmbGetUlong(&Response->AllocationSize.HighPart);
    pFileInfo->Standard.EndOfFile.LowPart       = SmbGetUlong(&Response->EndOfFile.LowPart);
    pFileInfo->Standard.EndOfFile.HighPart      = SmbGetUlong(&Response->EndOfFile.HighPart);
    pFileInfo->Standard.Directory               = Response->Directory;

    MRxSmbCopyAndTranslatePipeState(RxContext,
                                    SmbGetUshort(&Response->DeviceState));

    // If this is an EXTENDED create responce copy the appropriate information.
    // Note that this code relies on the fact that the fields common to
    // RESP_NT_CREATE_ANDX and RESP_EXTENDED_NT_CREATE_ANDX have identical
    // offsets in the two structures.

    if (Response->WordCount == 42) {
        PRESP_EXTENDED_NT_CREATE_ANDX ExtendedResponse;

        ULONG AccessRights;

        ExtendedResponse = (PRESP_EXTENDED_NT_CREATE_ANDX)Response;

        AccessRights = SmbGetUlong(&ExtendedResponse->MaximalAccessRights);
        smbSrvOpen->MaximalAccessRights = AccessRights;

        AccessRights = SmbGetUlong(&ExtendedResponse->GuestMaximalAccessRights);
        smbSrvOpen->GuestMaximalAccessRights = AccessRights;
    } else {
        // If the NT_CREATE_ANDX was to a downlevel server the access rights
        // information is not available. Currently we default to maximum
        // access for the current user and no access to other users in the
        // disconnected mode for such files

        smbSrvOpen->MaximalAccessRights = FILE_ALL_ACCESS;

        smbSrvOpen->GuestMaximalAccessRights = 0;
    }

    if (Response->OplockLevel > SMB_OPLOCK_LEVEL_NONE) {
        smbSrvOpen->FileStatusFlags = Response->FileStatusFlags;
        smbSrvOpen->IsNtCreate = TRUE;
    }

    MRxSmbCreateFileSuccessTail (
        RxContext,
        &OrdinaryExchange->Create.MustRegainExclusiveResource,
        &OrdinaryExchange->SmbFcbHoldingState,
        StorageType,
        Fid,
        OrdinaryExchange->ServerVersion,
        Response->OplockLevel,
        CreateAction,
        pFileInfo
        );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishNTCreateAndX   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));

    return Status;
}

NTSTATUS
MRxSmbFinishOpenAndX (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    PRESP_OPEN_ANDX        Response
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTCreate_AndX response.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    ULONG       Disposition = RxContext->Create.NtCreateParameters.Disposition;

    RxCaptureFcb;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    UCHAR OplockLevel = SMB_OPLOCK_LEVEL_NONE;
    ULONG CreateAction;
    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishOpenAndX\n", 0 ));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
        StorageType = FileTypeFile;
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    ASSERT (StorageType == FileTypeFile);

    Fid = SmbGetUshort(&Response->Fid);

    if (SmbGetUshort(&Response->Action) & SMB_OACT_OPLOCK) {
        OplockLevel = SMB_OPLOCK_LEVEL_BATCH;     //we only ever ask for batch currently!!!
    }

    CreateAction =  MRxSmbUnmapDisposition(SmbGetUshort(&Response->Action),Disposition);

    pFileInfo->Basic.FileAttributes =
        MRxSmbMapSmbAttributes(SmbGetUshort(&Response->FileAttributes));

    // This is a downlevel server, the access rights
    // information is not available. Currently we default to maximum
    // access for the current user and no access to other users in the
    // disconnected mode for such files

    smbSrvOpen->MaximalAccessRights = FILE_ALL_ACCESS;

    smbSrvOpen->GuestMaximalAccessRights = 0;

    MRxSmbSecondsSince1970ToTime(
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        SmbCeGetExchangeServer(OrdinaryExchange),
        &pFileInfo->Basic.LastWriteTime);

    pFileInfo->Standard.NumberOfLinks = 1;
    pFileInfo->Basic.CreationTime.HighPart = 0;
    pFileInfo->Basic.CreationTime.LowPart = 0;
    pFileInfo->Basic.LastAccessTime.HighPart = 0;
    pFileInfo->Basic.LastAccessTime.LowPart = 0;
    pFileInfo->Basic.ChangeTime.HighPart = 0;
    pFileInfo->Basic.ChangeTime.LowPart = 0;
    pFileInfo->Standard.EndOfFile.HighPart = 0;
    pFileInfo->Standard.EndOfFile.LowPart = SmbGetUlong(&Response->DataSize);
    pFileInfo->Standard.AllocationSize.QuadPart = pFileInfo->Standard.EndOfFile.QuadPart;
    pFileInfo->Standard.Directory = (StorageType == FileTypeDirectory);

    MRxSmbCopyAndTranslatePipeState(
        RxContext,
        SmbGetUshort(&Response->DeviceState) );

    MRxSmbCreateFileSuccessTail (
        RxContext,
        &OrdinaryExchange->Create.MustRegainExclusiveResource,
        &OrdinaryExchange->SmbFcbHoldingState,
        StorageType,
        Fid,
        OrdinaryExchange->ServerVersion,
        OplockLevel,
        CreateAction,
        pFileInfo );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishOpenAndX   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

NTSTATUS
MRxSmbFinishCreatePrintFile (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    PRESP_OPEN_PRINT_FILE       Response
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTCreate_AndX response.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFcb;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;
    SMBPSE_FILEINFO_BUNDLE FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCreatePrintFile\n", 0 ));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    StorageType = RDBSS_NTC_SPOOLFILE-RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    Fid = SmbGetUshort(&Response->Fid);
    CreateAction = FILE_OPENED;

    RtlZeroMemory(
        &FileInfo,
        sizeof(FileInfo));

    MRxSmbCreateFileSuccessTail (
        RxContext,
        &OrdinaryExchange->Create.MustRegainExclusiveResource,
        &OrdinaryExchange->SmbFcbHoldingState,
        StorageType,
        Fid,
        OrdinaryExchange->ServerVersion,
        SMB_OPLOCK_LEVEL_NONE,
        CreateAction,
        &FileInfo );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCreatePrintFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

NTSTATUS
MRxSmbFinishT2OpenFile (
    IN OUT PRX_CONTEXT            RxContext,
    IN     PRESP_OPEN2            Response,
    IN OUT PBOOLEAN               MustRegainExclusiveResource,
    IN OUT SMBFCB_HOLDING_STATE   *SmbFcbHoldingState,
    IN     ULONG                  ServerVersion
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the T2/Open response.
    CODE.IMPROVEMENT This routine is almost identical to the finish routine for NT long names
                     which, in turn, is almost the same as for short names. see the longname routine
                     details. CODE.IMPROVEMENT.ASHAMED this really is crappy........

Arguments:

    RxContext - the context of the operation being performed

    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID  Fid;
    ULONG        CreateAction;
    ULONG        Disposition = RxContext->Create.NtCreateParameters.Disposition;

    ULONG                     FileAttributes;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishT2OpenFile\n", 0 ));
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    FileAttributes = MRxSmbMapSmbAttributes(Response->FileAttributes);

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
       StorageType = (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                     ? FileTypeDirectory
                     : FileTypeFile;
    }

    if ((capFcb->OpenCount != 0) &&
        (StorageType != 0) &&
        (NodeType(capFcb) !=  RDBSS_STORAGE_NTC(StorageType))) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    Fid = Response->Fid;
    CreateAction =  MRxSmbUnmapDisposition(Response->Action,Disposition);
    RxDbgTrace( 0, Dbg, ("Storagetype %08lx/Fid %08lx/Action %08lx\n", StorageType, Fid, CreateAction ));

    if (Response->Action & SMB_OACT_OPLOCK) {
        smbSrvOpen->OplockLevel = SMB_OPLOCK_LEVEL_BATCH;     //we only ever ask for batch currently!!!
    }

    RxContext->Create.ReturnedCreateInformation = CreateAction;

    if (capFcb->OpenCount == 0) {
        //
        //  Please note that we mask off the low bit on the time stamp here.
        //
        //  We do this since the time stamps returned from other smbs (notably SmbGetAttrE and
        //  T2QueryDirectory) have a granularity of 2 seconds, while this
        //  time stamp has a granularity of 1 second.  In order to make these
        //  two times consistant, we mask off the low order second in the
        //  timestamp.  this idea was lifted from rdr1.
        //
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        MRxSmbSecondsSince1970ToTime(Response->CreationTimeInSeconds&0xfffffffe,
                                     &pServerEntry->Server,
                                     &pFileInfo->Basic.CreationTime);
        SmbCeDereferenceServerEntry(pServerEntry);
    }

    pFileInfo->Basic.FileAttributes             = FileAttributes;
    pFileInfo->Basic.LastAccessTime.QuadPart    = 0;
    pFileInfo->Basic.LastWriteTime.QuadPart     = 0;
    pFileInfo->Basic.ChangeTime.QuadPart        = 0;

    pFileInfo->Standard.NumberOfLinks           = 1;
    pFileInfo->Standard.AllocationSize.QuadPart =
    pFileInfo->Standard.EndOfFile.QuadPart      = Response->DataSize;
    pFileInfo->Standard.Directory               = (StorageType == FileTypeDirectory);

    MRxSmbCopyAndTranslatePipeState(
        RxContext,
        SmbGetUshort(&Response->DeviceState) );

    MRxSmbCreateFileSuccessTail(
        RxContext,
        MustRegainExclusiveResource,
        SmbFcbHoldingState,
        StorageType,
        Fid,
        ServerVersion,
        smbSrvOpen->OplockLevel,
        CreateAction,
        pFileInfo);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishT2OpenFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));

    return Status;
}

//#define MULTI_EA_MDL

NTSTATUS
MRxSmbT2OpenFile(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine opens a file across the network that has
        1) EAs,
        2) a name so long that it wont fit in an ordinary packet

   NTRAID-455638-2/2/2000-yunlin We silently ignore it if SDs are specified.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    USHORT Setup = TRANS2_OPEN2;

    BOOLEAN MustRegainExclusiveResource = FALSE;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    SMB_TRANSACTION_OPTIONS             TransactionOptions;

    PREQ_OPEN2 pCreateRequest = NULL;
    RESP_OPEN2 CreateResponse;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    MRXSMB_CREATE_PARAMETERS SmbCp;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
    USHORT smbDisposition;
    USHORT smbSharingMode;
    USHORT smbAttributes;
    ULONG smbFileSize;
    USHORT smbOpenMode;
    USHORT OpenFlags = SMB_OPEN_QUERY_INFORMATION;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;
    ULONG  SecondsSince1970;
    BOOLEAN IsUnicode;

    ULONG OS2_EaLength = 0;
    PFEALIST ServerEaList = NULL;

    ULONG EaLength = RxContext->Create.EaLength;
    PFILE_FULL_EA_INFORMATION EaBuffer = RxContext->Create.EaBuffer;

    ULONG FileNameLength,AllocationLength;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbT2Open---\n"));
    DbgPrint("MRxSmbT2Open---%08lx %08lx\n",EaBuffer,EaLength);
    MRxSmbAdjustCreateParameters(RxContext,&SmbCp);

    FileNameLength = RemainingName->Length;

    AllocationLength = WordAlign(FIELD_OFFSET(REQ_OPEN2,Buffer[0])) +
                       FileNameLength+sizeof(WCHAR);

    pCreateRequest = (PREQ_OPEN2)
                     RxAllocatePoolWithTag(
                        PagedPool,
                        AllocationLength,
                        'bmsX' );

    if (pCreateRequest==NULL) {
        RxDbgTrace(0, Dbg, ("  --> Couldn't get the pCreateRequest!\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    smbDisposition = MRxSmbMapDisposition(cp->Disposition);
    smbSharingMode = MRxSmbMapShareAccess(((USHORT)cp->ShareAccess));
    smbAttributes = MRxSmbMapFileAttributes(cp->FileAttributes);
    smbFileSize = cp->AllocationSize.LowPart;
    smbOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);
    smbSharingMode |= smbOpenMode;

    if (cp->CreateOptions & FILE_WRITE_THROUGH) {
        smbSharingMode |= SMB_DA_WRITE_THROUGH;
    }

    if (capFcb->pNetRoot->Type == NET_ROOT_DISK) {
        OpenFlags |= (SMB_OPEN_OPLOCK | SMB_OPEN_OPBATCH);
    }

    {
        BOOLEAN GoodTime;
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        LARGE_INTEGER CurrentTime;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        IsUnicode = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE);

        KeQuerySystemTime(&CurrentTime);

        GoodTime = MRxSmbTimeToSecondsSince1970(
                       &CurrentTime,
                       &pServerEntry->Server,
                       &SecondsSince1970
                       );

        SmbCeDereferenceServerEntry(pServerEntry);

        if (!GoodTime) {
            SecondsSince1970 = 0;
        }
    }

    pCreateRequest->Flags = OpenFlags;      // Creation flags
    pCreateRequest->DesiredAccess = smbSharingMode;
    pCreateRequest->SearchAttributes = SearchAttributes;
    pCreateRequest->FileAttributes = smbAttributes;
    pCreateRequest->CreationTimeInSeconds = SecondsSince1970;
    pCreateRequest->OpenFunction = smbDisposition;
    pCreateRequest->AllocationSize = smbFileSize;

    RtlZeroMemory(
        &pCreateRequest->Reserved[0],
        sizeof(pCreateRequest->Reserved));

    {
        NTSTATUS StringStatus;
        PBYTE NameBuffer = &pCreateRequest->Buffer[0];
        ULONG OriginalLengthRemaining = FileNameLength+sizeof(WCHAR);
        ULONG LengthRemaining = OriginalLengthRemaining;

        if (IsUnicode) {
            StringStatus = SmbPutUnicodeString(&NameBuffer,RemainingName,&LengthRemaining);
        } else {
            StringStatus = SmbPutUnicodeStringAsOemString(&NameBuffer,RemainingName,&LengthRemaining);
            DbgPrint("This is the name <%s>\n",&pCreateRequest->Buffer[0]);
        }

        ASSERT(StringStatus==STATUS_SUCCESS);
        SendParamsBufferLength = FIELD_OFFSET(REQ_OPEN2,Buffer[0])
                                    +OriginalLengthRemaining-LengthRemaining;
    }


    SendParamsBuffer = (PBYTE)pCreateRequest;
    //SendParamsBufferLength = qweee;
    ReceiveParamsBuffer = (PBYTE)&CreateResponse;
    ReceiveParamsBufferLength = sizeof(CreateResponse);

    if (EaLength!=0) {
        //
        //  Convert Nt format FEALIST to OS/2 format
        //
        DbgPrint("MRxSmbT2Open again---%08lx %08lx\n",EaBuffer,EaLength);
        OS2_EaLength = MRxSmbNtFullEaSizeToOs2 ( EaBuffer );
        if ( OS2_EaLength > 0x0000ffff ) {
            Status = STATUS_EA_TOO_LARGE;
            goto FINALLY;
        }

        ServerEaList = RxAllocatePoolWithTag (PagedPool, OS2_EaLength, 'Ebms');
        if ( ServerEaList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        MRxSmbNtFullListToOs2 ( EaBuffer, ServerEaList );
    } else {
        OS2_EaLength = 0;
        ServerEaList = NULL;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbT2Open---os2ea %d buf %x\n", OS2_EaLength,ServerEaList));
    DbgPrint("MRxSmbT2Open OS2 eastuff---%08lx %08lx\n",ServerEaList,OS2_EaLength);

    TransactionOptions = RxDefaultTransactionOptions;
    TransactionOptions.Flags |= SMB_XACT_FLAGS_FID_NOT_NEEDED;

    if (BooleanFlagOn(capFcb->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT) &&
        (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))) {
        TransactionOptions.Flags |= SMB_XACT_FLAGS_DFS_AWARE;
    }

    ASSERT (MrxSmbCreateTransactPacketSize>=100); //don't try something bad!
    TransactionOptions.MaximumTransmitSmbBufferSize = MrxSmbCreateTransactPacketSize;

    RxReleaseFcbResourceInMRx( capFcb );
    MustRegainExclusiveResource = TRUE;

    Status = SmbCeTransact(
                 RxContext,
                 &TransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 ServerEaList,
                 OS2_EaLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        MRxSmbFinishT2OpenFile (
            RxContext,
            &CreateResponse,
            &MustRegainExclusiveResource,
            SmbFcbHoldingState,
            ResumptionContext.ServerVersion);

        if (cp->Disposition == FILE_OPEN) {
            MRxSmbAdjustReturnedCreateAction(RxContext);
        }
    }

FINALLY:
    ASSERT (Status != (STATUS_PENDING));

    if (pCreateRequest != NULL) {
       RxFreePool(pCreateRequest);
    }

    if (ServerEaList != NULL) {
       RxFreePool(ServerEaList);
    }

    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
    }
    if (MustRegainExclusiveResource) {
        //this is required because of oplock breaks
        RxAcquireExclusiveFcbResourceInMRx(capFcb );
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

NTSTATUS
MRxSmbFinishLongNameCreateFile (
    IN OUT PRX_CONTEXT                RxContext,
    IN     PRESP_CREATE_WITH_SD_OR_EA Response,
    IN     PBOOLEAN                   MustRegainExclusiveResource,
    IN OUT SMBFCB_HOLDING_STATE       *SmbFcbHoldingState,
    IN     ULONG                      ServerVersion
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTTransact/NTCreateWithEAsOrSDs response.
    CODE.IMPROVEMENT This routine is almost identical to the finish routine for "short names"..so
                     much so that some sort of merging should occur. an important point is that
                     the whole idea of >4k names is a very uncommon path so merging should not be
                     done so as to slow up the other path. On the other hand, it's not good to have
                     to change things in two places.  CODE.IMPROVEMENT.ASHAMED this is terrible!

Arguments:

    RxContext - the context of the operation being performed
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    FCB_INIT_PACKET InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishLongNameCreateFile\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (RxContext->Create.NtCreateParameters.CreateOptions & FILE_DELETE_ON_CLOSE) {
        PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
        SetFlag((smbFcb)->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
    }

    StorageType = RxInferFileType(RxContext);

    if (StorageType == 0) {
        StorageType = Response->Directory
                      ?FileTypeDirectory
                      :FileTypeFile;
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    if ((capFcb->OpenCount != 0) &&
        (StorageType != 0) &&
        (NodeType(capFcb) !=  RDBSS_STORAGE_NTC(StorageType))) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    Fid = SmbGetUshort(&Response->Fid);

    CreateAction = SmbGetUlong(&Response->CreateAction);

    pFileInfo->Basic.FileAttributes = Response->FileAttributes;
    pFileInfo->Basic.CreationTime = Response->CreationTime;
    pFileInfo->Basic.LastAccessTime = Response->LastAccessTime;
    pFileInfo->Basic.LastWriteTime = Response->LastWriteTime;
    pFileInfo->Basic.ChangeTime = Response->ChangeTime;
    pFileInfo->Standard.NumberOfLinks = 1;
    pFileInfo->Standard.AllocationSize = Response->AllocationSize;
    pFileInfo->Standard.EndOfFile = Response->EndOfFile;
    pFileInfo->Standard.Directory = Response->Directory;

    if (((pFileInfo->Standard.AllocationSize.HighPart == pFileInfo->Standard.EndOfFile.HighPart) &&
         (pFileInfo->Standard.AllocationSize.LowPart < pFileInfo->Standard.EndOfFile.LowPart)) ||
        (pFileInfo->Standard.AllocationSize.HighPart < pFileInfo->Standard.EndOfFile.HighPart)) {
        pFileInfo->Standard.AllocationSize = pFileInfo->Standard.EndOfFile;
    }

    MRxSmbCopyAndTranslatePipeState(
        RxContext,
        SmbGetUshort(&Response->DeviceState) );

    //MRxSmbSetSrvOpenFlags(RxContext,StorageType,SrvOpen,smbSrvOpen);

    if (Response->ExtendedResponse) {
        PRESP_EXTENDED_CREATE_WITH_SD_OR_EA ExtendedResponse;

        ULONG AccessRights;

        ExtendedResponse = (PRESP_EXTENDED_CREATE_WITH_SD_OR_EA)Response;

        AccessRights = SmbGetUlong(&ExtendedResponse->MaximalAccessRights);
        smbSrvOpen->MaximalAccessRights = (USHORT)AccessRights;

        AccessRights = SmbGetUlong(&ExtendedResponse->GuestMaximalAccessRights);
        smbSrvOpen->GuestMaximalAccessRights = (USHORT)AccessRights;

    } else {

        // If the NT_CREATE_ANDX was to a downlevel server the access rights
        // information is not available. Currently we default to maximum
        // access for the current user and no access to other users in the
        // disconnected mode for such files

        smbSrvOpen->MaximalAccessRights = (USHORT)0x1ff;

        smbSrvOpen->GuestMaximalAccessRights = (USHORT)0;
    }

    MRxSmbCreateFileSuccessTail(
        RxContext,
        MustRegainExclusiveResource,
        SmbFcbHoldingState,
        StorageType,
        Fid,
        ServerVersion,
        Response->OplockLevel,
        CreateAction,
        pFileInfo);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishLongNameCreateFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

#ifndef WIN9X

//#define MULTI_EA_MDL

#if 0
//#define FORCE_T2_OPEN
#ifdef FORCE_T2_OPEN
BOOLEAN ForceT2Open = TRUE;
#else
#define ForceT2Open FALSE
#endif
#endif //if 0

//force_t2_open doesn't work on an NT server......sigh........
#define ForceT2Open FALSE

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine opens a file across the network that has
        1) EAs,
        2) SIDs, or
        3) a name so long that it wont fit in an ordinary packet


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;

    BOOLEAN MustRegainExclusiveResource = FALSE;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    SMB_TRANSACTION_OPTIONS             TransactionOptions;

    PREQ_CREATE_WITH_SD_OR_EA pCreateRequest = NULL;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer,SendDataBuffer;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength,SendDataBufferLength;

    RESP_EXTENDED_CREATE_WITH_SD_OR_EA CreateResponse;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
    MRXSMB_CREATE_PARAMETERS SmbCp;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;


    ULONG EaLength, SdLength, PadLength = 0, TotalLength = 0;
    PBYTE CombinedBuffer = NULL;
#ifdef MULTI_EA_MDL
    PRX_BUFFER  EaMdl2 = NULL;
    PRX_BUFFER  EaMdl3 = NULL;
#endif
    PMDL  EaMdl = NULL;
    PMDL  SdMdl = NULL; BOOLEAN SdMdlLocked = FALSE;
    PMDL  PadMdl = NULL;
    PMDL  DataMdl = NULL;

    ULONG FileNameLength,AllocationLength;

    BOOLEAN IsUnicode = TRUE;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("!!MRxSmbCreateWithEasSidsOrLongName---\n"));

    {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        BOOLEAN DoesNtSmbs;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        DoesNtSmbs = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS);
        IsUnicode = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE);

        SmbCeDereferenceServerEntry(pServerEntry);
        if (!DoesNtSmbs || ForceT2Open) {
            NTSTATUS Status = MRxSmbT2OpenFile(RxContext,
                                               SmbFcbHoldingState);
            if (ForceT2Open && (Status!=STATUS_SUCCESS)) {
                DbgPrint("BadStatus = %08lx\n",Status);
            }
            return(Status);
        }
    }


    MRxSmbAdjustCreateParameters(RxContext,&SmbCp);

#if DBG
    if (MRxSmbNeedSCTesting) MRxSmbTestStudCode();
#endif

    RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName---\n"));

    if(IsUnicode) {
            FileNameLength = RemainingName->Length;
    } else {
            FileNameLength = RtlUnicodeStringToAnsiSize(RemainingName);
    }

    //CODE.IMPROVEMENT when transacts can take MDL chains instead of just buffers, we can
    //                 use that here!
    AllocationLength = WordAlign(FIELD_OFFSET(REQ_CREATE_WITH_SD_OR_EA,Buffer[0]))
                        +FileNameLength;

    pCreateRequest = (PREQ_CREATE_WITH_SD_OR_EA)RxAllocatePoolWithTag( PagedPool,
                                             AllocationLength,'bmsX' );
    if (pCreateRequest==NULL) {
        RxDbgTrace(0, Dbg, ("  --> Couldn't get the pCreateRequest!\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    if (IsUnicode) {
        RtlCopyMemory((PBYTE)WordAlignPtr(&pCreateRequest->Buffer[0]),RemainingName->Buffer,FileNameLength);
    } else {
        PBYTE pName = &pCreateRequest->Buffer[0];
        ULONG BufferLength = FileNameLength;
        SmbPutUnicodeStringAsOemString(&pName, RemainingName, &BufferLength);
    }

    EaLength = RxContext->Create.EaLength;
    SdLength = RxContext->Create.SdLength;

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot client and it did a NULL session logon, then
    // we don't want to send ACLs to the server because a) the unchanged ACL
    // has no meaning and b) a NULL session requires that files have world
    // access.
    //

    if (MRxSmbBootedRemotely &&
        !MRxSmbRemoteBootDoMachineLogon) {
        PSMBCE_SESSION pSession;
        pSession = &SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot)->pSessionEntry->Session;
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {

            SdLength = 0;
        }
    }
#endif // defined(REMOTE_BOOT)

    pCreateRequest->Flags = NT_CREATE_REQUEST_EXTENDED_RESPONSE;  //nooplock  // Creation flags ISSUE
    pCreateRequest->RootDirectoryFid = 0;           //norelopen // Optional directory for relative open
    pCreateRequest->DesiredAccess = cp->DesiredAccess;              // Desired access (NT format)
    pCreateRequest->AllocationSize = cp->AllocationSize;            // The initial allocation size in bytes
    pCreateRequest->FileAttributes = cp->FileAttributes;            // The file attributes
    pCreateRequest->ShareAccess = cp->ShareAccess;                  // The share access
    pCreateRequest->CreateDisposition = cp->Disposition;            // Action to take if file exists or not
    pCreateRequest->CreateOptions = cp->CreateOptions;              // Options for creating a new file
    pCreateRequest->SecurityDescriptorLength = SdLength;        // Length of SD in bytes
    pCreateRequest->EaLength = EaLength;                        // Length of EA in bytes
    pCreateRequest->NameLength = IsUnicode ? FileNameLength : FileNameLength - 1;                // Length of name in characters
    pCreateRequest->ImpersonationLevel = cp->ImpersonationLevel;    // Security QOS information
    pCreateRequest->SecurityFlags = SmbCp.SecurityFlags;              // Security QOS information
                    //  UCHAR Buffer[1];
                    //  //UCHAR Name[];                     // The name of the file (not NUL terminated)

    SendParamsBuffer = (PBYTE)pCreateRequest;
    SendParamsBufferLength = AllocationLength;
    ReceiveParamsBuffer = (PBYTE)&CreateResponse;
    ReceiveParamsBufferLength = sizeof(CreateResponse);

    if ((EaLength==0)||(SdLength==0)) {
        PadLength = 0;
        if (EaLength) {
            // the EaBuffer is in nonpaged pool...so we dont lock or unlock
            PBYTE EaBuffer = RxContext->Create.EaBuffer;
#ifdef MULTI_EA_MDL
            ULONG EaLength0,EaLength2,EaLength3;
            PBYTE EaBuffer2,EaBuffer3;
            ASSERT(EaLength>11);
            RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName--MULTIEAMDL\n"));
            EaLength0 = (EaLength - 4)>>1;
            EaBuffer2 = EaBuffer + EaLength0;
            EaLength2 = 4;
            EaBuffer3 = EaBuffer2 + EaLength2;
            EaLength3 = EaLength - (EaBuffer3 - EaBuffer);
            EaMdl = RxAllocateMdl(EaBuffer,EaLength0);
            EaMdl2 = RxAllocateMdl(EaBuffer2,EaLength2);
            EaMdl3 = RxAllocateMdl(EaBuffer3,EaLength3);
            if ( (EaMdl==NULL) || (EaMdl2==NULL) || (EaMdl3==NULL) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto FINALLY;
            }
            MmBuildMdlForNonPagedPool(EaMdl);
            MmBuildMdlForNonPagedPool(EaMdl2);
            MmBuildMdlForNonPagedPool(EaMdl3);
            EaMdl3->Next = NULL;
            EaMdl2->Next = EaMdl3;
            EaMdl->Next = EaMdl2;
#else
            EaMdl = RxAllocateMdl(EaBuffer,EaLength);
            if (EaMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto FINALLY;
            }
            MmBuildMdlForNonPagedPool(EaMdl);
            EaMdl->Next = NULL;
#endif
            DataMdl = EaMdl;
        }

        if (SdLength) {
            SdMdl = RxAllocateMdl(cp->SecurityContext->AccessState->SecurityDescriptor,SdLength);
            if (SdMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(SdMdl,KernelMode,IoModifyAccess,Status);
            }
            if (!NT_SUCCESS(Status)) goto FINALLY;
            SdMdlLocked = TRUE;
            PadLength = LongAlign(SdLength) - SdLength;
            if (PadLength && EaLength) {
                PadMdl = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));
                if (PadMdl == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto FINALLY;
                }
                RxBuildPaddingPartialMdl(PadMdl,PadLength);
                PadMdl->Next = DataMdl;
                DataMdl = PadMdl;
            }
            SdMdl->Next = DataMdl;
            DataMdl = SdMdl;
        }
    } else {
        //CODE.IMPROVEMENT this path disappears when the MDLstudcode is enabled
        ULONG EaOffset = LongAlign(SdLength);
        ULONG CombinedBufferLength = EaOffset + EaLength;
        CombinedBuffer = RxAllocatePoolWithTag(PagedPool,CombinedBufferLength,'bms');
        if (CombinedBuffer==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }
        SdMdl = RxAllocateMdl(CombinedBuffer,CombinedBufferLength);
        if (SdMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxProbeAndLockPages(SdMdl,KernelMode,IoModifyAccess,Status);
        }
        if (!NT_SUCCESS(Status)) goto FINALLY;
        SdMdlLocked = TRUE;
        RtlCopyMemory(CombinedBuffer,cp->SecurityContext->AccessState->SecurityDescriptor,SdLength);
        RtlZeroMemory(CombinedBuffer+SdLength,EaOffset-SdLength);
        RtlCopyMemory(CombinedBuffer+EaOffset,RxContext->Create.EaBuffer,EaLength);
        DataMdl = SdMdl;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName---s,p,ea %d,%d,%d buf %x\n",
                   SdLength,PadLength,EaLength,RxContext->Create.EaBuffer));

    TransactionOptions = RxDefaultTransactionOptions;
    TransactionOptions.NtTransactFunction = NT_TRANSACT_CREATE;
    TransactionOptions.Flags |= SMB_XACT_FLAGS_FID_NOT_NEEDED;
    //dfs is only for nt servers........
    //if (BooleanFlagOn(capFcb->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT)
    //                        && (RxContext->Create.NtCreateParameters.DfsContext == (PVOID)DFS_OPEN_CONTEXT)) {
    //    TransactionOptions.Flags |= SMB_XACT_FLAGS_DFS_AWARE;
    //}


    ASSERT (MrxSmbCreateTransactPacketSize>=100); //don't try something bad!
    TransactionOptions.MaximumTransmitSmbBufferSize = MrxSmbCreateTransactPacketSize;

    if (DataMdl!=NULL) {
        SendDataBuffer = MmGetSystemAddressForMdlSafe(DataMdl,LowPagePriority);

        if (SendDataBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SendDataBufferLength = EaLength+SdLength+PadLength;
    } else {
        SendDataBuffer = NULL;
        SendDataBufferLength = 0;
    }

    RxReleaseFcbResourceInMRx(capFcb );
    MustRegainExclusiveResource = TRUE;

    Status = SmbCeTransact(
                 RxContext,
                 &TransactionOptions,
                 NULL,
                 0,
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 SendDataBuffer,
                 SendDataBufferLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        MRxSmbFinishLongNameCreateFile (
            RxContext,
            (PRESP_CREATE_WITH_SD_OR_EA)&CreateResponse,
            &MustRegainExclusiveResource,
            SmbFcbHoldingState,
            ResumptionContext.ServerVersion);

        if (cp->Disposition == FILE_OPEN) {
            MRxSmbAdjustReturnedCreateAction(RxContext);
        }
    }

FINALLY:
    ASSERT (Status != (STATUS_PENDING));


    if (SdMdlLocked) MmUnlockPages(SdMdl);
    if (EaMdl  != NULL) { IoFreeMdl(EaMdl);  }
#ifdef MULTI_EA_MDL
    if (EaMdl2  != NULL) { IoFreeMdl(EaMdl2);  }
    if (EaMdl3  != NULL) { IoFreeMdl(EaMdl3);  }
#endif
    if (PadMdl != NULL) { IoFreeMdl(PadMdl); }
    if (SdMdl  != NULL) { IoFreeMdl(SdMdl);  }

    if (pCreateRequest != NULL) {
       RxFreePool(pCreateRequest);
    }

    if (CombinedBuffer != NULL) {
       RxFreePool(CombinedBuffer);
    }

    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
    }

    if (MustRegainExclusiveResource) {
        //this is required because of oplock breaks
        RxAcquireExclusiveFcbResourceInMRx(capFcb );
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}
#endif


NTSTATUS
MRxSmbZeroExtend(
    IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine extends the data stream of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxSmbTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxSmbCleanupFobx(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop. unless it's a pipe in which case
   we do the close at cleanup time and mark the file as being not open.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN        SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX        smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbCleanup\n", 0 ));

    MRxSmbCscCleanupFobx(RxContext);

    if (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        SearchHandleOpen = BooleanFlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Cleanup");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
        RxDbgTrace(-1, Dbg, ("File orphaned\n"));
        return (STATUS_SUCCESS);
    }

    if (!SearchHandleOpen &&
        capFcb->pNetRoot->Type != NET_ROOT_PIPE) {
        RxDbgTrace(-1, Dbg, ("File not for closing at cleanup\n"));
        return (STATUS_SUCCESS);
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (smbSrvOpen->Version == pServerEntry->Server.Version) {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               SrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_CLEANUPFOBX,
                               SmbPseExchangeStart_Close,
                               &OrdinaryExchange
                               );

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            return(Status);
        }

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        ASSERT (Status != (STATUS_PENDING));

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCleanup  exit with status=%08lx\n", Status ));

    return(Status);
}

NTSTATUS
MRxSmbForcedClose(
    IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
   PAGED_CODE();

   return STATUS_NOT_IMPLEMENTED;
}

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
MRxSmbCloseSrvOpen(
    IN PRX_CONTEXT   RxContext
    )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxSmbGetFileObjectExtension(capFobx);

    PSMBCEDB_SERVER_ENTRY pServerEntry = (PSMBCEDB_SERVER_ENTRY)(capFcb->pNetRoot->pSrvCall->Context);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    BOOLEAN NeedDelete;
    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbClose\n", 0 ));

    if (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        SearchHandleOpen = BooleanFlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Close");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (!smbSrvOpen->DeferredOpenInProgress &&
        smbSrvOpen->DeferredOpenContext != NULL) {
        RxFreePool(smbSrvOpen->DeferredOpenContext);
        smbSrvOpen->DeferredOpenContext = NULL;
        RxDbgTrace(0, Dbg, ("Free deferred open context for file %wZ %lX\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),smbSrvOpen));
    }

    //Remove the open context from the list if it is a paging file
    if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {
        PLIST_ENTRY          pListHead = &MRxSmbPagingFilesSrvOpenList;
        PLIST_ENTRY          pListEntry = pListHead->Flink;

        ASSERT(FALSE);
        while (pListEntry != pListHead) {
            PPAGING_FILE_CONTEXT PagingFileContext;

            PagingFileContext = (PPAGING_FILE_CONTEXT)CONTAINING_RECORD(pListEntry,PAGING_FILE_CONTEXT,ContextList);
            if (PagingFileContext->pSrvOpen == SrvOpen) {
                RemoveEntryList(pListEntry);

                break;
            }
        }
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED));
        ASSERT(smbFcb->SurrogateSrvOpen==NULL);
        ASSERT(smbFcb->CopyChunkThruOpen==NULL);
    } else {
        if (MRxSmbIsThisADisconnectedOpen(capFobx->pSrvOpen)) {
            // If the net root entry has been transitioned into a disconnected
            // mode of operation, trivially succeed close of deferred open
            // operations and perform the appropriate book keeping for non
            // deferred opens

            if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                MRxSmbCscUpdateShadowFromClose(NULL,RxContext);
                SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

                RxDbgTrace(-1, Dbg, ("Disconnected close\n"));
            }

            if ((capFcb->OpenCount == 0) &&
                FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE)) {
                MRxSmbCscDeleteAfterCloseEpilogue(RxContext,&Status);
            }

            goto FINALLY;
        }

        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED)){
            if (smbSrvOpen->hfShadow != 0){
                MRxSmbCscCloseShadowHandle(RxContext);
            }
            RxDbgTrace(-1, Dbg, ("Surrogated Open\n"));
            goto FINALLY;
        }

        if (smbFcb->CopyChunkThruOpen == capFobx) {
            smbFcb->CopyChunkThruOpen = NULL;
            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                ASSERT(smbSrvOpen->hfShadow == 0);
                RxDbgTrace(-1, Dbg, ("CopyChunkOpen already closed\n"));
                goto FINALLY;
            }
        }

        if (smbFcb->SurrogateSrvOpen == SrvOpen) {
            smbFcb->SurrogateSrvOpen = NULL;
        }
    }

    if ((FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) ||
        (capFcb->pNetRoot->Type == NET_ROOT_MAILSLOT) ||
        (capFcb->pNetRoot->Type == NET_ROOT_PIPE) ) {
        RxDbgTrace(-1, Dbg, ("File orphan or ipc\n"));
        goto FINALLY;
    }

    if (smbSrvOpen->hfShadow != 0){
        MRxSmbCscCloseShadowHandle(RxContext);
    }

    if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED) ||
        FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED) ){
        RxDbgTrace(-1, Dbg, ("File already closed by ren/del\n"));
        goto FINALLY;
    }

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    if (smbSrvOpen->Fid == 0xffff) {
        // File has already been closed on the server.
        goto FINALLY;
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(smbSrvOpen->hfShadow == 0);
    }

    NeedDelete = FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE) && (capFcb->OpenCount == 0);

    if (!NeedDelete &&
        !SearchHandleOpen &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)){
        RxDbgTrace(-1, Dbg, ("File was not really open\n"));
        goto FINALLY;
    }

    if (smbSrvOpen->Version == pServerEntry->Server.Version) {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               SrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_CLOSESRVCALL,
                               SmbPseExchangeStart_Close,
                               &OrdinaryExchange
                               );

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            goto FINALLY;
        }

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        ASSERT (Status != (STATUS_PENDING));

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbClose  exit with status=%08lx\n", Status ));

FINALLY:

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED) &&
        (pServerEntry != NULL)) {

        MRxSmbDecrementSrvOpenCount(
            pServerEntry,
            smbSrvOpen->Version,
            SrvOpen);

        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
    }

    return(Status);
}


NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildClose\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ CLOSE before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             0xffffffff,            //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ close after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildClosePrintFile (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a ClosePrintFile SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildClosePrintFile\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_CLOSE_PRINT_FILE,
                                SMB_REQUEST_SIZE(CLOSE_PRINT_FILE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ closeprintfile before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ closeprintfile after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFindClose\n", 0 ));

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse, SMB_COM_FIND_CLOSE2,
                                SMB_REQUEST_SIZE(FIND_CLOSE2),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ CLOSE before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
                                    //  w         _USHORT( Sid );                     // Find handle
             smbFobx->Enumeration.SearchHandle,
             SMB_WCT_CHECK(1) 0     //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ FindClose2 after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
SmbPseExchangeStart_Close(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for close.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMBCEDB_SERVER_ENTRY pServerEntry= SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Close\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    if(TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY){
        if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)) {
            // we have a search handle open.....close it
            //CODE.IMPROVEMENT the close and findclose operations should be compounded...but smbs don't allow it.
            //     problem is......findclose is on cleanup whereas close is on close
            //actually...we should have a handle-based enum and then we wouldn't have a search handle

            Status = MRxSmbBuildFindClose(StufferState);

            if (Status == STATUS_SUCCESS) {
                PSMBCE_SERVER pServer;
                // Ensure that the searchhandle is valid

                pServer = SmbCeGetExchangeServer(OrdinaryExchange);

                if (smbFobx->Enumeration.Version == pServer->Version) {
                    NTSTATUS InnerStatus;
                    InnerStatus = SmbPseOrdinaryExchange(
                                      SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                      SMBPSE_OETYPE_FINDCLOSE
                                      );
                }
            }

            // if this didn't work, there's nothing you can do............
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST);
        }
    }

    if ((OrdinaryExchange->EntryPoint == SMBPSE_OE_FROM_CLEANUPFOBX) &&
        (capFcb->pNetRoot->Type != NET_ROOT_PIPE) ) {

        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit after searchhandle close %08lx\n", Status ));
        return Status;
    }

    if ( !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ) {
        //even if it didn't work there's nothing i can do......keep going
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

        MRxSmbDecrementSrvOpenCount(pServerEntry,pServerEntry->Server.Version,SrvOpen);

        if (NodeType(capFcb)!=RDBSS_NTC_SPOOLFILE) {
            Status = MRxSmbBuildClose(StufferState);
        } else {
            Status = MRxSmbBuildClosePrintFile(StufferState);
        }

        if (Status == STATUS_SUCCESS) {

            // Ensure that the Fid is validated
            SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

            Status = SmbPseOrdinaryExchange(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         SMBPSE_OETYPE_CLOSE
                         );

            // Ensure that the Fid validation is disabled
            ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE)) {
                smbFcb->WriteOnlySrvOpenCount--;
            }
        }
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(smbFcb->hShadow==0);
    } else {
        if (smbFcb->hShadow!=0) {
            MRxSmbCscUpdateShadowFromClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        }
    }

    if ((Status!=STATUS_SUCCESS) ||
        (capFcb->OpenCount > 0)  ||
        !FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE)) {
        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
        return Status;
    }

    RxDbgTrace(0, Dbg, ("SmbPseExchangeStart_Close delete on close\n" ));

    if ( !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED)) {
        if (!FlagOn(smbFcb->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO)) {
            //no need for setinitsmb here because coredelete does a init-on-resuse.....
            //it's bad to pass the name this way...........
            OrdinaryExchange->pPathArgument1 = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY )));

            if (Status == STATUS_FILE_IS_A_DIRECTORY) {
                Status = MRxSmbCoreDeleteForSupercedeOrClose(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             TRUE);
            }

            MRxSmbCacheFileNotFound(RxContext);
        } else {
            // if flag FILE_DELETE_ON_CLOSE is set on NT create, the file is deleted on close
            // without client send any set disposition info request
            MRxSmbInvalidateFileInfoCache(RxContext);
            MRxSmbInvalidateInternalFileInfoCache(RxContext);
            MRxSmbCacheFileNotFound(RxContext);

            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
        }
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        IF_DEBUG {
            PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                          SmbCeGetAssociatedNetRootEntry(NetRoot);

            ASSERT(smbFcb->hShadow==0);
            ASSERT(!pNetRootEntry->NetRoot.CscEnabled);
        }
    } else {
        MRxSmbCscDeleteAfterCloseEpilogue(RxContext,&Status);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishClose (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CLOSE                 Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes
    the close.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishClose(orClosePrintFile)\n", 0 ));

    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishClose:");

    if (Response->WordCount != 0 ||
        SmbGetUshort(&Response->ByteCount) !=0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CLOSE) {
            PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            smbSrvOpen->Fid = 0xffff;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishClose   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbAreFilesAliased(
    PFCB Fcb1,
    PFCB Fcb2
    )
{
    PMRX_SMB_FCB smbFcb1 = MRxSmbGetFcbExtension(Fcb1);
    PMRX_SMB_FCB smbFcb2 = MRxSmbGetFcbExtension(Fcb2);

    if ((smbFcb2->IndexNumber.QuadPart == 0) ||
        (smbFcb2->IndexNumber.QuadPart == smbFcb1->IndexNumber.QuadPart)) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
MRxSmbPreparseName(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name
    )
{
#define SNAPSHOT_DESIGNATION L"@GMT-"
#define SNAPSHOT_DESIGNATION_LENGTH wcslen(SNAPSHOT_DESIGNATION)
#define SNAPSHOT_FULL_LENGTH wcslen(L"@GMT-YYYY.MM.DD-HH.MM.SS")
    PWSTR pStart, pCurrent, pEnd;
    ULONG iCount;

//  DbgPrint( "Checking %wZ\n", Name );

    // Setup the pointers
    pCurrent = Name->Buffer;
    pEnd = Name->Buffer + (Name->Length/sizeof(WCHAR));

    // Walk the string
    while( pCurrent < pEnd )
    {
        // Walk to the next path element
        while( (pCurrent < pEnd) &&
               (*pCurrent != L'\\') )
            pCurrent++;

        // Skip the trailing slash
        pCurrent++;

//      DbgPrint( "Checking at %p\n", pCurrent );

        if( pCurrent + SNAPSHOT_FULL_LENGTH <= pEnd )
        {
            pStart = pCurrent;

            // First make sure the header for the element matches
            for( iCount=0; iCount<SNAPSHOT_DESIGNATION_LENGTH; iCount++,pCurrent++ )
            {
                if( *pCurrent != SNAPSHOT_DESIGNATION[iCount] )
                {
//                  DbgPrint( "NoMatch1: %C != %C (%d)\n", *pCurrent, SNAPSHOT_DESIGNATION[iCount], iCount );
                    goto no_match;
                }
            }

            // Now make sure the length is correct, with no path designators in the middle
            for( ; iCount < SNAPSHOT_FULL_LENGTH; iCount++, pCurrent++ )
            {
                if( *pCurrent == L'\\' )
                {
//                  DbgPrint( "NoMatch2: %C == \\ (%d)\n", *pCurrent, iCount );
                    goto no_match;
                }
            }

            // Make sure this is either the final element or we're at the end of the string
            if( pCurrent != pEnd )
            {
                if( *pCurrent != L'\\' )
                {
//                  DbgPrint( "NoMatch2: %C != \\ (%d)\n", *pCurrent, SNAPSHOT_DESIGNATION[iCount], iCount );
                    goto no_match;
                }
            }

            // We've found an element, mark it
            RxContext->Create.Flags |= RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH;
            return STATUS_SUCCESS;
        }
        else
        {
            // We can't fit the token in the remaining length, so we know we don't need to continue
//          DbgPrint( "NoMatch4: Length runs past end.\n" );
            return STATUS_SUCCESS;
        }

no_match:
        continue;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbGetConnectionId(
    IN PRX_CONTEXT RxContext,
    IN OUT PRX_CONNECTION_ID RxConnectionId
    )
{
    RtlZeroMemory( RxConnectionId, sizeof(RX_CONNECTION_ID) );

    switch( MRxSmbConnectionIdLevel )
    {
    case 0:
        break;

    case 1:
        {
            PQUERY_PATH_REQUEST QpReq;
            PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext = NULL;
            PIO_STACK_LOCATION IrpSp = RxContext->CurrentIrpSp;

            if( (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
                (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH) ) {

                QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SubjectSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;
            }
            else if( (IrpSp->MajorFunction == IRP_MJ_CREATE) && (IrpSp->Parameters.Create.SecurityContext != NULL) ) {

                SubjectSecurityContext = &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext;

            }

            if( SubjectSecurityContext )
            {
                if (SubjectSecurityContext->ClientToken != NULL) {
                    SeQuerySessionIdToken(SubjectSecurityContext->ClientToken, &RxConnectionId->SessionID);
                } else {
                    SeQuerySessionIdToken(SubjectSecurityContext->PrimaryToken, &RxConnectionId->SessionID);
                }
            }
        }
        break;

    case 2:
        {
            PQUERY_PATH_REQUEST QpReq;
            PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext = NULL;
            PIO_STACK_LOCATION IrpSp = RxContext->CurrentIrpSp;

            if( (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
                (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH) ) {

                QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SubjectSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;
            }
            else if( (IrpSp->MajorFunction == IRP_MJ_CREATE) && (IrpSp->Parameters.Create.SecurityContext != NULL) ) {

                SubjectSecurityContext = &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext;

            }

            if( SubjectSecurityContext )
            {
                if (SubjectSecurityContext->ClientToken != NULL) {
                    SeQueryAuthenticationIdToken(SubjectSecurityContext->ClientToken, &RxConnectionId->Luid);
                } else {
                    SeQueryAuthenticationIdToken(SubjectSecurityContext->PrimaryToken, &RxConnectionId->Luid);
                }
            }
        }
        break;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\onepath.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

Author:

    Jim McNelis         [JimMcN]        15-November-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbDosPathFunction)
#pragma alloc_text(PAGE, MRxSmbLoadPathFileSearchBuffer)
#pragma alloc_text(PAGE, MRxSmbPathFileSearch)
#pragma alloc_text(PAGE, MrxSmbPathQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbPathQueryDiskAttributes)
#pragma alloc_text(PAGE, SmbPseExchangeStart_PathFunction)
#endif

#define Dbg        (DEBUG_TRACE_VOLINFO)


extern SMB_EXCHANGE_DISPATCH_VECTOR SmbPseDispatch_PathFunction;

//++
//
// VOID
// NAME_LENGTH(
//     OUT ULONG Length,
//     IN PUCHAR Ptr
//     )
//
// Routine Description:
//
//  Determines the length of a Path filename returned by search. This
//  is normally a NULL terminated string less than MAXIMUM_COMPONENT_CORE.
//  In some cases this is Non-null teminated and space filled.
//
// Arguments:
//
//     Length   -   Returns the string length
//     Ptr      -   The filename to be measured
//
// Return Value:
//
//     None.
//
//--
#define NAME_LENGTH( Length, Ptr, Max ) {                         \
    Length = 0;                                                   \
    while( ((PCHAR)Ptr)[Length] != '\0' ) {                       \
         Length++;                                                \
         if ( Length == Max ) {                                   \
             break;                                               \
         }                                                        \
    }                                                             \
    while( ((PCHAR)Ptr)[Length-1] == ' ' && Length ) {            \
        Length--;                                                 \
    }                                                             \
}
MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );
NTSTATUS
MRxSmbDosPathFunction(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine perfoms one of several single path functions to the network

Arguments:

    RxContext - the RDBSS context
    InformationClass - a class variable that is specific to the call.
                       sometimes it's a SMB class; sometimes an NT class.
                       CODE.IMPROVEMENT.ASHAMED we should always use the NT
                       guy OR we should define some other enumeration that
                       we like better. consideration of the latter has kept
                       me from proceeding here..........

    pBuffer - pointer to the user's buffer
    pBufferLength - a pointer to a ulong containing the bufferlength that is
                    updated as we go; if it's a setinfo then we deref and
                    place the actual bufferlength in the OE.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    RxCaptureRequestPacket;
//    RxCaptureFcb;

    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;
    PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    RxDbgTrace(1, Dbg, ("MRxSmbDownLevelQueryInformation\n", 0 ));

    switch (RxContext->MajorFunction) {
    case DOSBASED_DELETE:
    case DOSBASED_DIRFUNCTION:
        break;

    default:
        ASSERT(!"Supposed to be here");

    }

    StufferState = MRxSmbCreateSmbStufferState(RxContext,
                                               RxContext->DosVolumeFunction.VNetRoot,
                                               RxContext->DosVolumeFunction.NetRoot,
                                               ORDINARY_EXCHANGE,CREATE_SMB_SIZE,
                                               &SmbPseDispatch_PathFunction
                                               );
    if (StufferState==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(RX_MAP_STATUS(INSUFFICIENT_RESOURCES));
    }

    OrdinaryExchange =
       (PSMB_PSE_ORDINARY_EXCHANGE)( Exchange = StufferState->Exchange );

    OrdinaryExchange->pPathArgument1 = RxContext->DosVolumeFunction.pUniStringParam1;
    Status = SmbCeInitiateExchange(Exchange);

    //async was turned away at the top level

    ASSERT (Status != RX_MAP_STATUS(PENDING));

    //NTRAID-455630-2/2/2000-yunlin possible reconnect point

    MRxSmbFinalizeSmbStufferState(StufferState);

FINALLY:
    RxDbgTrace(-1, Dbg,
               ("MRxSmbDownLevelQueryInformation  exit with status=%08lx\n",
                Status ));

    return(Status);

}

extern UNICODE_STRING MRxSmbAll8dot3Files;

#if DBG
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
extern
VOID
MRxSmbDumpResumeKey(
    PSZ             text,
    PSMB_RESUME_KEY ResumeKey
    );
#else
#define MRxSmbDumpResumeKey(x,y)
#endif


NTSTATUS
MRxSmbLoadPathFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a CORE_SMB_SEARCH and leaves the result in the SMBbuf.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    //SMBbuf_STATUS SMBbufStatus;

#ifndef WIN9X
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
//  RxCaptureFileObject;
    PMRX_SMB_FOBX smbFobx = (PMRX_SMB_FOBX)capFobx;
    //PSRV_OPEN SrvOpen = capFobx->SrvOpen;
    //PMRX_SMB_SRV_OPEN smbSrvOpen = (PMRX_SMB_SRV_OPEN)SrvOpen;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_HEADER SmbHeader;

    //PUNICODE_STRING DirectoryName;
    //PUNICODE_STRING Template;
    BOOLEAN FindFirst;
    UNICODE_STRING FindFirstPattern;
    USHORT ResumeKeyLength;
    ULONG ReturnCount;
    BOOLEAN EndOfSearchReached;
    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);
    PULONG pCountRemainingInSmbbuf = &OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLoadPathFileSearchBuffer entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.PathResumeKey));

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        PUNICODE_STRING DirectoryName = &capFcb->AlreadyPrefixedName;
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //this is the first time thru....the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            // we will need to have an upcased template for compares; we do this in place
            RtlUpcaseUnicodeString( Template, Template, FALSE );
            //CODE.IMPROVEMENT but we should specialcase *.* (altho the fsrtl routine also does it)
            Template = &MRxSmbAll8dot3Files; //we will have to filter on this side
        }
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        //*((PWCHAR)SmbFileName) = 0; SmbFileName+= sizeof(WCHAR); //trailing NULL;
        //CODE.IMPROVEMENT we should potentially 8.3ize the string here
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
        FindFirst = TRUE;
        ResumeKeyLength = 0;

    } else {

        RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
        FindFirstPattern.Buffer = NULL;
        if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS)) {
            Status = smbFobx->Enumeration.ErrorStatus;
            RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
            goto FINALLY;
        }
        FindFirst = FALSE;
        FindFirstPattern.Length = 0;
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        MRxSmbDumpResumeKey("FindNext:",smbFobx->Enumeration.PathResumeKey);

    }

    //get the correct return count. there are three factors: countremaining from the OE,
    //     how many could fit the the user's buffer, and how many could fit in a negotiated buffer.
    //     we pick the smallest of the three.
    ReturnCount = OrdinaryExchange->Info.CoreSearch.CountRemaining;
    { ULONG t = (*OrdinaryExchange->Info.pBufferLength) / smbFobx->Enumeration.FileNameOffset;
      if (t<ReturnCount) { ReturnCount = t; }
    }
    { PSMBCE_SERVER pServer = &((PSMB_EXCHANGE)OrdinaryExchange)->SmbCeContext.pServerEntry->Server;
      ULONG AvailableBufferSize = pServer->MaximumBufferSize -
                                      (sizeof(SMB_HEADER) +
                                         FIELD_OFFSET(RESP_SEARCH,Buffer[0])
                                         +sizeof(UCHAR)+sizeof(USHORT)       //bufferformat,datalength fields
                                      );
      ULONG t = AvailableBufferSize / sizeof(SMB_DIRECTORY_INFORMATION);
      if (t<ReturnCount) { ReturnCount = t; }
    }
    RxDbgTrace( 0, Dbg, ("-------->count=%08lx\n",ReturnCount));
    if (ReturnCount==0) {
        Status = RX_MAP_STATUS(MORE_PROCESSING_REQUIRED);
        RxDbgTrace(0, Dbg, ("-->Count==0 EARLY OUT\n"));
        goto FINALLY;
    }

    StufferState = OrdinaryExchange->StufferState;
    ASSERT( StufferState );

    *pCountRemainingInSmbbuf = 0;
    OrdinaryExchange->Info.CoreSearch.NextDirInfo = NULL;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                          SMB_COM_SEARCH, SMB_REQUEST_SIZE(SEARCH),
                                          NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("core search command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               ReturnCount,         //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c         //UCHAR SearchStatus[];             //  Resume key
               ResumeKeyLength,smbFobx->Enumeration.PathResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORESEARCH
                                    );

    if (!NT_SUCCESS(Status)) goto FINALLY;

    smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST|SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
    //if (Status==RxStatus(SUCCESS) && FilesReturned==0) {
    //     RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: no files returned...switch status\n"));
    //     EndOfSearchReached = TRUE;
    //     Status = RxStatus(NO_MORE_FILES);
    //}
    if (Status==RX_MAP_STATUS(SUCCESS) && *pCountRemainingInSmbbuf==0) {
         RxDbgTrace( 0, Dbg, ("MRxSmbLoadPathFileSearchBuffer: no files returned...switch status\n"));
         EndOfSearchReached = TRUE;
         Status = RX_MAP_STATUS(NO_MORE_FILES);
    } else {
        //CODE.IMPROVEMENT a possible improvement here is to know that the search is closed
        //                 based on a "smaller-than-normal" return; we would key this off of the
        //                 operatingsystem return string i guess. for NT systems, we don't do this
         EndOfSearchReached = FALSE;
    }
    if (EndOfSearchReached) {
        RxDbgTrace( 0, Dbg, ("MRxSmbLoadPathFileSearchBuffer: no longer in progress...EOS\n"));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = RX_MAP_STATUS(NO_MORE_FILES);
    }
    //we dont save a resume key here since each individual copy operation will have to do that


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }
    if (!NT_SUCCESS(Status)&&(Status!=RX_MAP_STATUS(MORE_PROCESSING_REQUIRED))) {
        RxDbgTrace( 0, Dbg, ("MRxSmbPathFileSearch: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadPathFileSearchBuffer exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
#endif
    return(Status);
}

#define ASSERT_SAME_FIELD(__field,__t1,__t2) { \
      ASSERT(FIELD_OFFSET(__t1,__field)==FIELD_OFFSET(__t2,__field)); \
      }

#define ASSERT_SAME_DIRINFO_FIELDS(__t1,__t2) {\
      ASSERT_SAME_FIELD(LastWriteTime,__t1,__t2); \
      ASSERT_SAME_FIELD(EndOfFile,__t1,__t2); \
      ASSERT_SAME_FIELD(AllocationSize,__t1,__t2); \
      ASSERT_SAME_FIELD(FileAttributes,__t1,__t2); \
      }
#if DBG
VOID MRxSmbPathFileSeach_AssertFields(void){
    //just move this out of the main execution path so that we don't have to look at it while
    //we Uing the code
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_FULL_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_BOTH_DIR_INFORMATION);
}
#else
#define MRxSmbPathFileSeach_AssertFields()
#endif

NTSTATUS
MRxSmbPathFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    //SMBbuf_STATUS SMBbufStatus;
#ifndef WIN9X

    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
//  RxCaptureFileObject;
    PMRX_SMB_FOBX smbFobx = (PMRX_SMB_FOBX)capFobx;

    PBYTE pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pLengthRemaining = OrdinaryExchange->Info.pBufferLength;
    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;

    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG SuccessCount = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbPathFileSearch entering.......OE=%08lx\n",OrdinaryExchange));
    MRxSmbPathFileSeach_AssertFields();

    OrdinaryExchange->Info.CoreSearch.CountRemaining =
              RxContext->QueryD.ReturnSingleEntry?1:0x7ffffff;

    if ( (smbFobx->Enumeration.PathResumeKey ==NULL )
             && ((smbFobx->Enumeration.PathResumeKey = RxAllocatePoolWithTag(PagedPool,sizeof(SMB_RESUME_KEY),'rbms'))==NULL) ){
        RxDbgTrace(0, Dbg, ("...couldn't allocate resume key\n"));
        Status = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
        goto FINALLY;
    }
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.PathResumeKey));

    Status = MRxSmbLoadPathFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

    for (;;) {
        BOOLEAN BufferOverflow = FALSE;
        PSMB_DIRECTORY_INFORMATION NextDirInfo;
        UNICODE_STRING FileNameU;
        OEM_STRING FileNameA;
        WCHAR FileNameU_buffer[14];
        ULONG NameLength;
        PBYTE NextFileName;
        BOOLEAN Match,BufferOverFlow;

        if (!NT_SUCCESS(Status)) {
            if (Status = RX_MAP_STATUS(NO_MORE_FILES)) {
                if (SuccessCount > 0) {
                    Status = RX_MAP_STATUS(SUCCESS);
                }
            } else if (Status = RX_MAP_STATUS(MORE_PROCESSING_REQUIRED)) {
                if (SuccessCount > 0) {
                    Status = RX_MAP_STATUS(SUCCESS);
                } else {
                    Status = RX_MAP_STATUS(BUFFER_OVERFLOW);
                }
            }

            goto FINALLY;
        }
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemaining>0 );
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf>0 );
        RxDbgTrace(0, Dbg, ("MRxSmbPathFileSearch looptopcheck counts=%08lx,%08lx\n",
                    OrdinaryExchange->Info.CoreSearch.CountRemaining,
                    OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf
                    ));

        //next issue: does the next dirinfo match the criteria?!?

        NextDirInfo = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
        NextFileName = &NextDirInfo->FileName[0];

        // According to colinw, some core servers do not remember to insert the null at the end of the name...
        // but the namelength macro handles this correctly. some servers (Xenix, apparently) pad the
        // names with spaces. again, the macro handles it....
        //

        NAME_LENGTH(NameLength, NextFileName,sizeof(NextDirInfo->FileName));

        FileNameA.Length = (USHORT)NameLength;
        FileNameA.MaximumLength = (USHORT)NameLength;
        FileNameA.Buffer = NextFileName;
        FileNameU.Length = sizeof(FileNameU_buffer);
        FileNameU.MaximumLength = sizeof(FileNameU_buffer);
        FileNameU.Buffer = &FileNameU_buffer[0];

        Status = RtlOemStringToUnicodeString(&FileNameU, &FileNameA, TRUE);
        RxDbgTrace(0, Dbg, ("MRxSmbPathFileSearch considering.......filename=%wZ, template=%wZ\n",
                                    &FileNameU,&capFobx->UnicodeQueryTemplate));

        ASSERT(Status==RX_MAP_STATUS(SUCCESS));

        // we deal with a conversion failure by skipping this guy
        Match = (Status==RX_MAP_STATUS(SUCCESS));
        if (Match && smbFobx->Enumeration.WildCardsFound ) {
            //DbgBreakPoint();
            try
            {
                Match = FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                      &FileNameU, TRUE, NULL );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                Match = FALSE;
            }
        }

        //next issue: will the next dirinfo fit in the user's buffer?!?
        if (Match) {
            ULONG SpaceNeeded;
            PBYTE pRememberBuffer = pBuffer;
            pBuffer = (PBYTE)LongAlign(pBuffer); //assume that this will fit
            SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileNameU.Length;
            if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {
                BufferOverflow = TRUE;
                pBuffer = pRememberBuffer; //rollback
            } else {
                PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;
                SMB_TIME Time;
                SMB_DATE Date;
                BufferOverflow = FALSE;
                if (pPreviousBuffer != NULL) {
                    pPreviousBuffer->NextEntryOffset = ((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer);
                }
                pPreviousBuffer = pThisBuffer;
                RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
                RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset, FileNameU.Buffer,FileNameU.Length);
                *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileNameU.Length;
                //hallucinate the record based on specific return type
                switch (InformationClass) {
                case SMB_FIND_FILE_NAMES_INFO:
                    break;
                case SMB_FIND_FILE_DIRECTORY_INFO:
                case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
                    //just fill what we have...we do not go to a lot of trouble on allocinfo as rdr1 did.
                    //     actually, rdr1 didn't do that here...only on getfielinfo.......
                    SmbMoveTime (&Time, &NextDirInfo->LastWriteTime);
                    SmbMoveDate (&Date, &NextDirInfo->LastWriteDate);
                    pThisBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Exchange, Time, Date);
                    pThisBuffer->EndOfFile.LowPart = SmbGetUlong(&NextDirInfo->FileSize);
                    pThisBuffer->FileAttributes = MRxSmbMapSmbAttributes (NextDirInfo->FileAttributes);
                    break;
                default:
                   RxDbgTrace( 0, Dbg, ("MRxSmbPathFileSearch: Invalid FS information class\n"));
                   ASSERT(!"this can't happen");
                   Status = STATUS_INVALID_PARAMETER;
                   goto FINALLY;
                }
                pBuffer += SpaceNeeded;
                *pLengthRemaining -= pBuffer-pRememberBuffer;
                OrdinaryExchange->Info.CoreSearch.CountRemaining--;
                SuccessCount++;
            }
        }

        //
        // if no match or no overflow, move up in the buffer. this means not only juggling the
        // pointers but also saving the resume key

        if (!Match || !BufferOverflow) {
            MRxSmbDumpResumeKey("BufferKey:",&NextDirInfo->ResumeKey);
            *(smbFobx->Enumeration.PathResumeKey) = NextDirInfo->ResumeKey;
            MRxSmbDumpResumeKey("SaveKey:  ",smbFobx->Enumeration.PathResumeKey);
            OrdinaryExchange->Info.CoreSearch.NextDirInfo = NextDirInfo + 1;
            OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf--;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemaining==0) {
            Status = RX_MAP_STATUS(SUCCESS);
            goto FINALLY;
        }

        //should we jam these together by smashing the countrem to 0 on bufferoverflow??? CODE.IMPROVEMENT
        if (BufferOverflow) {
            Status = (SuccessCount==0)?RX_MAP_STATUS(BUFFER_OVERFLOW):RX_MAP_STATUS(SUCCESS);
            goto FINALLY;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf==0) {

            Status = MRxSmbLoadPathFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

        }

    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbPathFileSearch exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    //CODE.IMPROVEMENT if we're done with the resume key we could free it!
#endif
    return(Status);
}

NTSTATUS
MrxSmbPathQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    //SMBbuf_STATUS SMBbufStatus;

#ifndef WIN9X
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
//  RxCaptureFileObject;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MrxSmbPathQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = OrdinaryExchange->StufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ searchvolumelabel before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since its in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    MRxSmbStuffSMB (StufferState,
         "0wwB4yw!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               1,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
                                    //  w         _USHORT( SearchAttributes );
               SMB_FILE_ATTRIBUTE_VOLUME,
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &MRxSmbAll8dot3Files,//  4         //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //           //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               0                    //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //            //UCHAR SearchStatus[];             //  Resume key
             );


    MRxSmbDumpStufferState (700,"SMB w/ searchvolumelabel after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYLABEL
                                    );

    //Status = RxStatus(NOT_IMPLEMENTED);
    ASSERT ( *pBufferLength>=sizeof(FILE_FS_VOLUME_INFORMATION));
    RxDbgTrace(0, Dbg, ("MrxSmbPathQueryFsVolumeInfo OEstatus=%08lx\n",Status));
    //DbgBreakPoint();

    pBuffer->SupportsObjects = FALSE;
    pBuffer->VolumeCreationTime.LowPart = 0;
    pBuffer->VolumeCreationTime.HighPart = 0;
    pBuffer->VolumeSerialNumber = 0;
    pBuffer->VolumeLabelLength = 0;

    if (NT_SUCCESS(Status) &&
        (OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] != 0) ) {
        UNICODE_STRING VolumeLabelU;
        OEM_STRING VolumeLabelA;
        SMB_DIRECTORY_INFORMATION Buffer;
        ULONG NameLength;
        ULONG BytesToCopy;
        PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

        //pBuffer->VolumeSerialNumber =
        //        (((SmbGetUshort(&Buffer.LastWriteTime.Ushort)) << 16) |
        //          (SmbGetUshort(&Buffer.LastWriteDate.Ushort)));

        NAME_LENGTH(NameLength, VolumeLabel,
                   sizeof(OrdinaryExchange->Info.QFSVolInfo.CoreLabel));

        VolumeLabelA.Length = (USHORT)NameLength;
        VolumeLabelA.MaximumLength = (USHORT)NameLength;
        VolumeLabelA.Buffer = VolumeLabel;

        //some core servers put a '.' in the labelname.....if it's there then remove it
        if ((NameLength>8)&& (VolumeLabel[8]=='.') ) {
            ULONG i;
            for (i=8;i<NameLength;i++) {
                VolumeLabel[i] = VolumeLabel[i+1];
            }
        }

        Status = RtlOemStringToUnicodeString(&VolumeLabelU, &VolumeLabelA, TRUE);

        if (NT_SUCCESS(Status)) {

            ULONG BytesToCopy = min((ULONG)VolumeLabelU.Length, (*pBufferLength-sizeof(FILE_FS_VOLUME_INFORMATION)));

            RtlCopyMemory(&pBuffer->VolumeLabel[0],
                          VolumeLabelU.Buffer,
                          BytesToCopy);

            *pBufferLength -= BytesToCopy;
            pBuffer->VolumeLabelLength = VolumeLabelU.Length;
            IF_DEBUG {
                UNICODE_STRING FinalLabel;
                FinalLabel.Buffer = &pBuffer->VolumeLabel[0];
                FinalLabel.Length = (USHORT)BytesToCopy;
                RxDbgTrace(0, Dbg, ("MrxSmbPathQueryFsVolumeInfo vollabel=%wZ\n",&FinalLabel));
            }

            RtlFreeUnicodeString(&VolumeLabelU);
        }

    } else if (Status == RX_MAP_STATUS(NO_SUCH_FILE)) {
        //
        //  If we got no such file, this means that there's no volume label
        //  the remote volume.  Return success with no data.
        //

        Status = RX_MAP_STATUS(SUCCESS);

    }

    if (NT_SUCCESS(Status)) {
        *pBufferLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel);
    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbPathQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
#endif
    return(Status);
}


NTSTATUS
MrxSmbPathQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    //SMBbuf_STATUS SMBbufStatus;

    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
//  RxCaptureFileObject;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MrxSmbPathQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = OrdinaryExchange->StufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION_DISK,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION_DISK),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("querydiskattribs command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ querydiskattribs before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
               SMB_WCT_CHECK(0) 0   //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

    MRxSmbDumpStufferState (700,"SMB w/ querydiskattribs after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES
                                    );
FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbPathQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
SmbPseExchangeStart_PathFunction(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for VOLINFO.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                        (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PSMBSTUFFER_BUFFER_STATE StufferState = OrdinaryExchange->StufferState;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_PathFunction\n", 0 ));

    ASSERT(pExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    switch (RxContext->MajorFunction) {
    case DOSBASED_DELETE:

        Status = MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS, FALSE);
        goto FINALLY;
    case DOSBASED_DIRFUNCTION:
        switch (RxContext->MinorFunction) {
        case DOSBASED_CREATEDIR:
            break;
        case DOSBASED_DELETEDIR:
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS, TRUE);
            goto FINALLY;
        case DOSBASED_CHECKDIR:
            Status = MRxSmbCoreCheckDirFunction(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        case DOSBASED_QUERY83DIR:
            break;
        default:
            ASSERT(!"DIR MINOR FUNCTION SUPPOSED TO BE HERE!");
        }
    default:
        ASSERT(!"Supposed to be here");

    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_PathFunction exit w %08lx\n", Status ));
    return Status;
}

extern
NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );

extern
NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );

SMB_EXCHANGE_DISPATCH_VECTOR
SmbPseDispatch_PathFunction = {
                                       SmbPseExchangeStart_PathFunction,
                                       SmbPseExchangeReceive_default,
                                       SmbPseExchangeCopyDataHandler_default,
                                       SmbPseExchangeSendCallbackHandler_default,
                                       SmbPseExchangeFinalize_default,
                                       NULL
                                   };





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\precomp.h ===
// a minirdr must declare his name and his imports ptr

#define MINIRDR__NAME MRxSMB
#define ___MINIRDR_IMPORTS_NAME (MRxSmbDeviceObject->RdbssExports)

#include "rx.h"         // get the minirdr environment

#include "ntddnfs2.h"   // NT network file system driver include file
#include "netevent.h"

#include "smbmrx.h"     // the global include for this mini

//
// If we are using the new TDI PNP and Power Management
//  headers, then we should use the new routines
//
#if defined( TDI20 ) || defined( _PNP_POWER_ )
#define MRXSMB_PNP_POWER5
#endif

#include "smbprocs.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\recursvc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recursvc.c

Abstract:

    This module implements the recurrent services in the mini rdr. These are services that
    are not triggered as a response to some request from the wrapper, they are autonomous
    services that aid in the functioning of the mini redirector.

    Scavenging -- The construction of the SMB mini redirector counterparts to SRV_CALL,
    NET_ROOT and V_NET_ROOT involve network traffic. Therefore the SMB mini redirector
    introduces a hystersis between the deletion of the data structures by the wrapper and
    effecting those changes in the mini redirector data structures and the remote server.
    This is done by transitioning the deleted data structures to a dormant state and
    scavenging them after a suitable interval( approximately 45 sec).

    Probing Servers -- Sometimes the server response to a client request is delayed. The
    mini redirector has a probing mechanism which enables it to cope with overloaded
    servers. When a response is not forthcoming from a server it sends it an ECHO SMB.
    Since the server can respond to an ECHO SMB without having to commit many resources,
    a reply to the ECHO SMB is interpreted as a sign that the server is indeed alive and
    well.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:


Notes:

    A recurrent service can be either periodic or aperiodic. The periodic services are
    triggered at regular time intervals. These services then perform some tasks if
    required. The advantage of having periodic recurrent services is the guarantee that
    work will get done and the disadvantage is that it consumes system resources when
    there is no work to be done. Also if the handling time happens to straddle the
    service time period multiple threads wil

    An aperiodic recurrent service is a one shot mechanism. The service once invoked gets
    to decide when the next invocation will be. The advantage of such services is that
    it provides an inbuilt throttling mechanism.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbInitializeRecurrentService)
#pragma alloc_text(PAGE, MRxSmbCancelRecurrentService)
#pragma alloc_text(PAGE, MRxSmbActivateRecurrentService)
#pragma alloc_text(PAGE, MRxSmbInitializeRecurrentServices)
#pragma alloc_text(PAGE, MRxSmbTearDownRecurrentServices)
#pragma alloc_text(PAGE, MRxSmbInitializeScavengerService)
#pragma alloc_text(PAGE, MRxSmbTearDownScavengerService)
#endif

MRXSMB_ECHO_PROBE_SERVICE_CONTEXT MRxSmbEchoProbeServiceContext;

MRXSMB_SCAVENGER_SERVICE_CONTEXT  MRxSmbScavengerServiceContext;

extern VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID pContext);

VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval)
/*++

Routine Description:

    This routine initializes a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

    pServiceRoutine - the recurrent service routine

    pServiceRoutineParameter - the recurrent service routine parameter

    pTimeInterval - the time interval which controls the frequency of the recurrent
                    service

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    pRecurrentServiceContext->State = RECURRENT_SERVICE_DORMANT;

    pRecurrentServiceContext->pServiceRoutine = pServiceRoutine;
    pRecurrentServiceContext->pServiceRoutineParameter = pServiceRoutineParameter;
    pRecurrentServiceContext->Interval.QuadPart = pTimeInterval->QuadPart;

    // Initialize the cancel completion event associated with the service
    KeInitializeEvent(
        &pRecurrentServiceContext->CancelCompletionEvent,
        NotificationEvent,
        FALSE);
}

VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext)
/*++

Routine Description:

    This routine cancels a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

    When the cancel request is handled the recurrent service can be in one
    of two states -- either active or on the timer queue awaiting dispatch.

    The service state is changed and an attempt is made to cancel the service
    in the timer queue and if it fails this request is suspended till the
    active invocation of the service is completed

--*/
{
    NTSTATUS Status;
    LONG    State;

    PAGED_CODE();

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_CANCELLED,
                RECURRENT_SERVICE_ACTIVE);

    if (State == RECURRENT_SERVICE_ACTIVE) {
        // Cancel the echo processing timer request.
        Status = RxCancelTimerRequest(
                     MRxSmbDeviceObject,
                     MRxSmbRecurrentServiceDispatcher,
                     pRecurrentServiceContext);

        if (Status != STATUS_SUCCESS) {
            // The request is currently active. Wait for it to be completed.
            KeWaitForSingleObject(
                &pRecurrentServiceContext->CancelCompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }
    }
}

VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID   pContext)
/*++

Routine Description:

    This routine dispatches the recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

    The dispatcher provides a centralized location for monitoring the state
    of the recurrent service prior to and after invocation. Based on the
    state a decision as to whether a subsequent request must be posted
    is made.

--*/
{
    NTSTATUS Status;

    PRECURRENT_SERVICE_CONTEXT  pRecurrentServiceContext;

    LONG State;

    pRecurrentServiceContext = (PRECURRENT_SERVICE_CONTEXT)pContext;

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_ACTIVE,
                RECURRENT_SERVICE_ACTIVE);

    // If the state of the service is active invoke the handler
    if (State == RECURRENT_SERVICE_ACTIVE) {
        Status = (pRecurrentServiceContext->pServiceRoutine)(
                      pRecurrentServiceContext->pServiceRoutineParameter);

        State = InterlockedCompareExchange(
                    &pRecurrentServiceContext->State,
                    RECURRENT_SERVICE_ACTIVE,
                    RECURRENT_SERVICE_ACTIVE);

        if (State == RECURRENT_SERVICE_ACTIVE) {
            // If the service is still active and further continuation
            // was desired by the handler post another timer request
            if (Status == STATUS_SUCCESS) {
                Status = RxPostOneShotTimerRequest(
                             MRxSmbDeviceObject,
                             &pRecurrentServiceContext->WorkItem,
                             MRxSmbRecurrentServiceDispatcher,
                             pRecurrentServiceContext,
                             pRecurrentServiceContext->Interval);
            } else {
                do {
                    State = InterlockedCompareExchange(
                                &pRecurrentServiceContext->State,
                                RECURRENT_SERVICE_DORMANT,
                                State);
                } while (State != RECURRENT_SERVICE_DORMANT);
            }
        }
    }

    if (State == RECURRENT_SERVICE_CANCELLED) {
        // if the recurrent service was cancelled resume the cancel request
        KeSetEvent(
             &pRecurrentServiceContext->CancelCompletionEvent,
             0,
             FALSE );
    }
}

NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext)
/*++

Routine Description:

    This routine activates a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    NTSTATUS Status;
    LONG    State;

    PAGED_CODE();

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_ACTIVE,
                RECURRENT_SERVICE_DORMANT);

    if (State == RECURRENT_SERVICE_DORMANT) {
        Status = RxPostOneShotTimerRequest(
                     MRxSmbDeviceObject,
                     &pRecurrentServiceContext->WorkItem,
                     MRxSmbRecurrentServiceDispatcher,
                     pRecurrentServiceContext,
                     pRecurrentServiceContext->Interval);
    } else if (State == RECURRENT_SERVICE_ACTIVE) {
        Status = STATUS_SUCCESS;
    } else if (State == RECURRENT_SERVICE_CANCELLED) {
        Status = STATUS_CANCELLED;
    }
    else if (State == RECURRENT_SERVICE_SHUTDOWN) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        ASSERT(!"Valid State for Recurrent Service");
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
MRxSmbInitializeRecurrentServices()
/*++

Routine Description:

    This routine initializes all the recurrent services associated with the SMB
    mini redirector

Notes:

--*/
{
    NTSTATUS Status;

    LARGE_INTEGER RecurrentServiceInterval;

    BOOLEAN       fEchoProbeServiceInitialized = FALSE;
    BOOLEAN       fScavengerServiceInitialized = FALSE;

    PAGED_CODE();

    try {
        RecurrentServiceInterval.QuadPart = 30 * 1000 * 10000; // 30 seconds in 100 ns intervals

        MRxSmbInitializeRecurrentService(
            &MRxSmbEchoProbeServiceContext.RecurrentServiceContext,
            SmbCeProbeServers,
            &MRxSmbEchoProbeServiceContext,
            &RecurrentServiceInterval);

        Status = MRxSmbInitializeEchoProbeService(
                    &MRxSmbEchoProbeServiceContext);

        if (Status == STATUS_SUCCESS) {
            fEchoProbeServiceInitialized = TRUE;

            Status = MRxSmbActivateRecurrentService(
                         &MRxSmbEchoProbeServiceContext.RecurrentServiceContext);
        }

        if (Status != STATUS_SUCCESS) {
            try_return(Status);
        }

        MRxSmbInitializeRecurrentService(
            &MRxSmbScavengerServiceContext.RecurrentServiceContext,
            SmbCeScavenger,
            &MRxSmbScavengerServiceContext,
            &RecurrentServiceInterval);

        Status = MRxSmbInitializeScavengerService(
                     &MRxSmbScavengerServiceContext);

        if (Status == STATUS_SUCCESS) {
            fScavengerServiceInitialized = TRUE;
        }

    try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            if (fEchoProbeServiceInitialized) {
                SmbCeLog(("Tearing down Echo Probe Service\n"));
                SmbLogError(Status,
                            LOG,
                            MRxSmbInitializeRecurrentServices,
                            LOGULONG(Status));
                MRxSmbTearDownEchoProbeService(
                    &MRxSmbEchoProbeServiceContext);
            }
        }
    };

    return Status;
}

VOID
MRxSmbTearDownRecurrentServices()
/*++

Routine Description:

    This routine tears down the recurrent services associated with the
    SMB mini redirector

Notes:

--*/
{
    PAGED_CODE();

    MRxSmbCancelRecurrentService(
        &MRxSmbEchoProbeServiceContext.RecurrentServiceContext);

    MRxSmbEchoProbeServiceContext.RecurrentServiceContext.State = RECURRENT_SERVICE_SHUTDOWN;

    MRxSmbTearDownEchoProbeService(
        &MRxSmbEchoProbeServiceContext);

    MRxSmbCancelRecurrentService(
        &MRxSmbScavengerServiceContext.RecurrentServiceContext);

    MRxSmbScavengerServiceContext.RecurrentServiceContext.State = RECURRENT_SERVICE_SHUTDOWN;

    MRxSmbTearDownScavengerService(
        &MRxSmbScavengerServiceContext);
}


NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext)
/*++

Routine Description:

    This routine initializes the scavenger recurrent service

Arguments:

    pScavengerServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    PAGED_CODE();

    InitializeListHead(
        &pScavengerServiceContext->VNetRootContexts.ListHead);

    return STATUS_SUCCESS;
}

VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext)
/*++

Routine Description:

    This routine tears down the scavenger recurrent service

Arguments:

    pScavengerServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    PAGED_CODE();

    SmbCeScavenger(pScavengerServiceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\reconnct.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effect
Copyright (c) 1987-1998  Microsoft Corporation

Module Name:

    remoteboot.c

Abstract:

    This is the source file that implements the silent reconnection form the client to the server.

Author:

    Yun Lin (YunLin) 21-April-98    Created

Notes:

    The remote boot client is the workstation that boots up from the boot server. The connection
    between the remote boot client and server is different from the one between ordinary client
    server in such a way that losing the connection to the boot server, the remote boot client
    may not function properly, sometime even crash.

    The make the connection between the remote boot client and server more relaible, we introduce
    a machanism that in case of connection fails, the RDR try to reconnect to the boot server
    transparently to the applications.

    The reconnection can be initiated in three places: initialize a exchange, in the middle of read
    and write. The reconnection is triggered by the mis-matching of server verion stored on the
    server and the one stored on smbSrvOpen which happens on a remote boot session.

    The reconnection process starts with seting up a new session to the boot server. If it succeed,
    it checks if the paging file is on the boot (in case of diskless client). If ture, it re-opens
    the paging file with the same create options stored on the deferred open context created. When
    a file is successful opened on the boot server at first time, the client creates a open context
    for the file storing all the desired access and create options.

    After re-opens the paging file or it is on the local disk, the reconnection code re-opens the
    file as if it is a deferred open file. As the file is successfully opened, the old FID and the
    server version are updated. The operation on the file can be resumed without noticing of the
    user.



--*/

#include "precomp.h"
#pragma hdrstop

RXDT_DefineCategory(RECONNECT);
#define Dbg        (DEBUG_TRACE_RECONNECT)

BOOLEAN    PagedFileReconnectInProgress = FALSE;
LIST_ENTRY PagedFileReconnectSynchronizationExchanges;
extern LIST_ENTRY MRxSmbPagingFilesSrvOpenList;

NTSTATUS
SmbCeRemoteBootReconnect(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    RxContext)
/*++

Routine Description:

   This routine reconnects the paged file first, and then re-open the given file on the server
   in case of remote boot client.

Arguments:

    pExchange         - the placeholder for the exchange instance.

    pRxContext        - the associated RxContext

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pListEntry;
    KAPC_STATE  ApcState;
    PRX_CONTEXT RxContextOfPagedFile;
    BOOLEAN     AttachToSystemProcess = FALSE;
    PMRX_SRV_OPEN               SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN        smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);

    DbgPrint("Re-open %wZ\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext));

    if (pServerEntry->Server.CscState == ServerCscDisconnected) {
        return STATUS_CONNECTION_DISCONNECTED;
    }

    if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
        KeStackAttachProcess(RxGetRDBSSProcess(),&ApcState);
        AttachToSystemProcess = TRUE;
    }

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    if (!PagedFileReconnectInProgress) {
        InitializeListHead(&PagedFileReconnectSynchronizationExchanges);
        PagedFileReconnectInProgress = TRUE;
        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        SmbCeUninitializeExchangeTransport(pExchange);

        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);

        if (pServerEntry->Header.State ==  SMBCEDB_INVALID &&
            pServerEntry->Server.CscState != ServerCscDisconnected) {

            do {
                SmbCeUpdateServerEntryState(pServerEntry,
                                            SMBCEDB_CONSTRUCTION_IN_PROGRESS);
    
                Status = SmbCeInitializeServerTransport(pServerEntry,NULL,NULL);

                if (Status == STATUS_SUCCESS) {
                    Status = SmbCeNegotiate(
                                 pServerEntry,
                                 pServerEntry->pRdbssSrvCall,
                                 pServerEntry->Server.IsRemoteBootServer
                                 );
                }
            } while ((Status == STATUS_IO_TIMEOUT ||
                      Status == STATUS_BAD_NETWORK_PATH ||
                      Status == STATUS_NETWORK_UNREACHABLE ||
                      Status == STATUS_USER_SESSION_DELETED ||
                      Status == STATUS_REMOTE_NOT_LISTENING ||
                      Status == STATUS_CONNECTION_DISCONNECTED) &&
                     pServerEntry->Server.CscState != ServerCscDisconnected);

            SmbCeCompleteServerEntryInitialization(pServerEntry,Status);
        }

        if (pServerEntry->Server.CscState == ServerCscDisconnected) {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();

        pListHead = &PagedFileReconnectSynchronizationExchanges;
        pListEntry = pListHead->Flink;

        while (pListEntry != pListHead) {
            PSMB_EXCHANGE pWaitingExchange;

            pWaitingExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);

            pListEntry = pListEntry->Flink;
            RemoveEntryList(&pWaitingExchange->ExchangeList);
            InitializeListHead(&pWaitingExchange->ExchangeList);

            pWaitingExchange->SmbStatus = Status;

            //DbgPrint("Signal Exchange %x after reconnect.\n",pWaitingExchange);
            RxSignalSynchronousWaiter(pWaitingExchange->RxContext);
        }

        PagedFileReconnectInProgress = FALSE;

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();
    } else {
        InsertTailList(
            &PagedFileReconnectSynchronizationExchanges,
            &pExchange->ExchangeList);

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        SmbCeUninitializeExchangeTransport(pExchange);

        //DbgPrint("Exchange %x waits for re-open paged file on %wZ\n",pExchange,&pServerEntry->Name);
        RxWaitSync(RxContext);
        //DbgPrint("Resume exchange %x\n",pExchange);

        KeInitializeEvent(
            &RxContext->SyncEvent,
            SynchronizationEvent,
            FALSE);

        Status = pExchange->SmbStatus;
    }

    if (Status == STATUS_SUCCESS &&
        !FlagOn(capFcb->FcbState, FCB_STATE_PAGING_FILE) &&
        pServerEntry->Server.CscState != ServerCscDisconnected) {
        LONG HotReconnecteInProgress;

        HotReconnecteInProgress = InterlockedExchange(&smbSrvOpen->HotReconnectInProgress,1);

        do {
            Status = MRxSmbDeferredCreate(RxContext);

            if (Status == STATUS_CONNECTION_DISCONNECTED) {
                SmbCeTransportDisconnectIndicated(pServerEntry);
            }

            if (Status != STATUS_SUCCESS) {
                LARGE_INTEGER time;
                LARGE_INTEGER Delay = {0,-1};
                ULONG Interval;

                // Select a random delay within 6 seconds.
                KeQuerySystemTime(&time);
                Interval = RtlRandom(&time.LowPart) % 60000000;
                Delay.LowPart = MAXULONG - Interval;

                KeDelayExecutionThread(KernelMode, FALSE, &Delay);
            }
        } while ((Status == STATUS_RETRY ||
                  Status == STATUS_IO_TIMEOUT ||
                  Status == STATUS_BAD_NETWORK_PATH ||
                  Status == STATUS_NETWORK_UNREACHABLE ||
                  Status == STATUS_USER_SESSION_DELETED ||
                  Status == STATUS_REMOTE_NOT_LISTENING ||
                  Status == STATUS_CONNECTION_DISCONNECTED) &&
                 pServerEntry->Server.CscState != ServerCscDisconnected);

        if (HotReconnecteInProgress == 0) {
            smbSrvOpen->HotReconnectInProgress = 0;
        }
    }

    if (AttachToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }
    
    DbgPrint("Re-open return %x\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\rename.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rename.c

Abstract:

    This module implements rename in the smb minirdr.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbRename)
#pragma alloc_text(PAGE, MRxSmbBuildRename)
#pragma alloc_text(PAGE, MRxSmbBuildDeleteForRename)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Rename)
#pragma alloc_text(PAGE, MRxSmbFinishRename)
#pragma alloc_text(PAGE, MRxSmbBuildCheckEmptyDirectory)
#pragma alloc_text(PAGE, SmbPseExchangeStart_SetDeleteDisposition)
#pragma alloc_text(PAGE, MRxSmbSetDeleteDisposition)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );
NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );



MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a rename by
     1) purge and remove buffering rights....setup the FCB so that no more stuff can get thru.
     2) closing its fid along with any deferred fids.
     3) if replace...do a delete
     4) do a downlevel smb_com_rename.

   there are many provisos but i think that this is the best balance. it is a real shame that the
   NT-->NT path was never implemented in nt4.0 or before.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

RETRY:
    RxDbgTrace(0, Dbg, ("MRxSmbRename\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    //ASSERT( RxContext->Info.FileInformationClass == FileRenameInformation); //later we'll do downlevel delete here as well

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          capFobx->pSrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_RENAME,
                                          SmbPseExchangeStart_Rename,
                                          &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != RX_MAP_STATUS(PENDING));

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    if (Status == STATUS_RETRY) {
        goto RETRY;
    }

    if (Status == STATUS_SUCCESS) {
        // create the name based file not found cache
        MRxSmbCacheFileNotFound(RxContext);
        // invalide the file not found cache for the new name if exists
        MRxSmbInvalidateFileNotFoundCacheForRename(RxContext);
    }

    // invalidate the name based file info cache
    MRxSmbInvalidateFileInfoCache(RxContext);
    MRxSmbInvalidateInternalFileInfoCache(RxContext);

    RxDbgTrace(0, Dbg, ("MRxSmbRename  exit with status=%08lx\n", Status ));
    return(Status);
}


NTSTATUS
MRxSmbBuildRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Rename SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    NTSTATUS StufferStatus;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    UNICODE_STRING RenameName;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN | SMB_FILE_ATTRIBUTE_DIRECTORY;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildRename\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    if (RxContext->Info.FileInformationClass == FileRenameInformation) {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_RENAME,
                                    SMB_REQUEST_SIZE(RENAME),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                    );
    
        MRxSmbDumpStufferState (1100,"SMB w/ RENAME before stuffing",StufferState);
    
        MRxSmbStuffSMB (StufferState,
             "0wB",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                 SearchAttributes,      //  w         _USHORT( SearchAttributes );
                 SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                                        //            //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                        //            //UCHAR OldFileName[];              //  Old file name
                                        //            //UCHAR BufferFormat2;              //  0x04 -- ASCII
                                        //            //UCHAR NewFileName[];              //  New file name
                 );
    } else {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_NT_RENAME,
                                    SMB_REQUEST_SIZE(NTRENAME),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                    );
    
        MRxSmbDumpStufferState (1100,"SMB w/ NTRENAME before stuffing",StufferState);
    
        MRxSmbStuffSMB (StufferState,
             "0wwdB",
                                              //  0         UCHAR WordCount;                    // Count of parameter words = 1
                 SearchAttributes,            //  w         _USHORT( SearchAttributes );
                 SMB_NT_RENAME_SET_LINK_INFO, //  w         _USHORT( InformationLevel );
                 0,                           //  d         _ULONG( ClusterCount );
                 SMB_WCT_CHECK(4) 0           //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                              //            UCHAR Buffer[1];                    // Buffer containing:
                                              //            //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                              //            //UCHAR OldFileName[];              //  Old file name
                                              //            //UCHAR BufferFormat2;              //  0x04 -- ASCII
                                              //            //UCHAR NewFileName[];              //  New file name
                 );
    }
    
    //CODE.IMPROVEMENT we don't need to copy here, we can just Mdl like in writes
    //                 of course, this causes a problem later for an NCB rdr in that
    //                 you can't andX without copying....also, the stuffer would probably
    //                 get confused
    //Code.IMPROVEMENT since you know that you're gonna copy, we might as well
    //                 include this earlier unless we want to MDL it in
    Status = MRxSmbStuffSMB (StufferState,
                                    "44!", RemainingName, &RenameName );

    MRxSmbDumpStufferState (700,"SMB w/ RENAME after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildDeleteForRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Delete SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    NTSTATUS StufferStatus;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    UNICODE_STRING RenameName;
    ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuild Delete 4RENAME\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;


    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                SMB_REQUEST_SIZE(DELETE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB  Delete 4RENAME before stuffing",StufferState);

    //CODE.IMPROVEMENT if this is truly core, we have to copy the name since it's in UNICODE
    //                 otherwise, we don't need to copy the name here, we can just Mdl like in writes
    //                 on the other hand, if it's NT<-->NT we don't do it here anyway
    MRxSmbStuffSMB (StufferState,
         "0wB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
                SearchAttributes,   //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &RenameName         //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
            );

    MRxSmbDumpStufferState (700,"SMB w/ Delete 4RENAME after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for rename and downlevel delete.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    ULONG SmbLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Rename\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    //first we have to close the fid....if it's a directory, we close the search handle as well
    //CODE.IMPROVEMENT do we have to do that for NT servers.....or will the server close them auto.

    MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );
    ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    if( (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY)
            &&  FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)  ){
        // we have a search handle open.....close it
        NTSTATUS Status2 = MRxSmbBuildFindClose(StufferState);

        if (Status2 == RX_MAP_STATUS(SUCCESS)) {
            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_FINDCLOSE
                                            );
        }

        ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST);

        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
        COVERED_CALL(MRxSmbBuildClose(StufferState));

        // we also get here when hardlink is being created. We want to
        // set the rename flag only when the file is really renamed
        // otherwise other operations such as flush etc. start to fail because 
        // the flag indicates that the file has been renamed when it isn't.
        if(RxContext->Info.FileInformationClass == FileRenameInformation)
        {
            SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED);
        }
        
        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_CLOSE
                                        );

        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
    }

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //
    // the fid is now closed and we are almost ready to do the rename. first, tho, we have
    // to check for ReplaceIfExists. our implementation here is the same as rdr1....we pop out
    // a smb_com_delete, which only works for a file. be like mike!! remember to ignore any errors....

    if (0) {
        DbgPrint("RxContext->Info.ReplaceIfExists %08lx %02lx\n",
                      &RxContext->Info.ReplaceIfExists,
                      RxContext->Info.ReplaceIfExists);
        if (0) {
            //DbgBreakPoint();
        }
    }

    if (RxContext->Info.ReplaceIfExists) {
        NTSTATUS DeleteStatus;
        PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
        UNICODE_STRING RenameName;
        BOOLEAN CaseInsensitive;

        CaseInsensitive= BooleanFlagOn(capFcb->pNetRoot->pSrvCall->Flags,SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES);
        RenameName.Buffer = &RenameInformation->FileName[0];
        RenameName.Length = (USHORT)RenameInformation->FileNameLength;

        // We cannot delete the file that is renamed as its own.
        if (RtlCompareUnicodeString(RemainingName,
                                    &RenameName,
                                    CaseInsensitive)) {
            DeleteStatus = MRxSmbBuildDeleteForRename(StufferState);
            if (DeleteStatus==STATUS_SUCCESS) {

                DeleteStatus = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      SMBPSE_OETYPE_DELETE_FOR_RENAME);
            }
        } else {
            if ( !CaseInsensitive || (CaseInsensitive &&
                 !RtlCompareUnicodeString(RemainingName,&RenameName,FALSE)) ) {
                    Status = STATUS_SUCCESS;
                    goto FINALLY;
            }
        }
    }

    //
    // now do the rename..........

    Status = MRxSmbBuildRename(StufferState);
    SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
    if ( (Status == STATUS_BUFFER_OVERFLOW)
                 || (SmbLength>pServer->MaximumBufferSize) ){
        RxDbgTrace(0, Dbg, ("MRxSmbRename - name too long\n", 0 ));
        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_RENAME
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Rename exit w %08lx\n", Status ));
    return Status;
}

#if 0
NTSTATUS
MRxSmbFinishRename (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_RENAME                 Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Rename response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishRename\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishRename:");

    if (Response->WordCount != 0 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        smbSrvOpen->Fid = 0xffff;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishRename   returning %08lx\n", Status ));
    return Status;
}
#endif

extern UNICODE_STRING MRxSmbAll8dot3Files;

NTSTATUS
MRxSmbBuildCheckEmptyDirectory (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a FindFirst SMB.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    ULONG ResumeKeyLength = 0;

    UNICODE_STRING FindFirstPattern;

    // SearchAttributes is hardcoded to the magic number 0x16  CODE.IMPROVEMENT.ASHAMED use a macro!!!
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildCheckEmptyDirectory \n"));

    if (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL) {
        PUNICODE_STRING DirectoryName = RemainingName;
        PUNICODE_STRING Template = &MRxSmbAll8dot3Files;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        //*((PWCHAR)SmbFileName) = 0; SmbFileName+= sizeof(WCHAR); //trailing NULL;
        //CODE.IMPROVEMENT we should potentially 8.3ize the string here
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
    } else {
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        FindFirstPattern.Buffer = NULL;
        FindFirstPattern.Length = 0;
    }


    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               3,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c
               ResumeKeyLength,OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search for checkempty after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbBuildCheckEmptyDirectory exiting.......st=%08lx\n",Status));
    return(Status);
}

NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for SetDeleteDisposition and downlevel delete. This only thing that happens here
    is that we check for an empty directory. On core, this is harder than you think. what we do is to try to get three
    entries. if the directory is empty, we will get only two . and ..; since we do not know whether the server just terminated
    early or whether those are the only two, we go again. we do this until either we get a name that is not . or .. or until
    NO_MORE_FILES is returned. sigh..................

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    ULONG SmbLength;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    ASSERT (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL);

    for (;;) {
        MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC')); //CODE.IMPROVEMENT do this in the buildroutine

        Status = MRxSmbBuildCheckEmptyDirectory(StufferState);
        SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);
        if ( (Status == RX_MAP_STATUS(BUFFER_OVERFLOW))
                     || (SmbLength>pServer->MaximumBufferSize) ){
            RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition - name too long\n", 0 ));
            return(RX_MAP_STATUS(OBJECT_NAME_INVALID));
        } else if ( Status != RX_MAP_STATUS(SUCCESS) ){
            goto FINALLY;
        }

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY
                                        );
        //
        // if success is returned with a resume key then we have to go again

        if ( (Status == RX_MAP_STATUS(SUCCESS)) && (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey != NULL) ) continue;
        break;
    }

    //
    // this is pretty strange. if it succeeds, then fail the empty check. similarly, if the search
    // fails with the right status...succeeed the check. otherwise fail

FINALLY:
    if (Status == RX_MAP_STATUS(SUCCESS)) {
        Status = RX_MAP_STATUS(DIRECTORY_NOT_EMPTY);
    } else if (Status == RX_MAP_STATUS(NO_MORE_FILES)) {
        Status = RX_MAP_STATUS(SUCCESS);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition exit w %08lx\n", Status ));
    return Status;
}


MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a delete for downlevel.

   It is impossible to provide exact NTish semantics on a core server. So, all we do here is to ensure that
   a directory is empty. The actual delete happens when on the last close.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();


    RxDbgTrace(+1, Dbg, ("MRxSmbSetDeleteDisposition\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
        RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition not a directory!\n"));
        return(RX_MAP_STATUS(SUCCESS));
    }

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
                                                    SmbPseExchangeStart_SetDeleteDisposition,
                                                    &OrdinaryExchange
                                                    );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != RX_MAP_STATUS(PENDING));

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition  exit with status=%08lx\n", Status ));
    return(Status);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    read of file system objects.

Author:

    Joe Linn     [JoeLi]      7-March-1995

Revision History:

    Balan Sethu Raman [SethuR] 7-October-1997

Notes:

    The READ adn WRITE paths in the mini redirector have to contend with a number
    of different variations based on the kind of the server and the capabilities
    of the server.

    Currently there are atleast four variations of the read operation that needs
    to be supported.

        1) SMB_COM_READ
            This is the read operation of choice against all servers which
            support old dialects of the SMB protocol ( < DF_LANMAN10 )

        2) SMB_COM_READ_ANDX
            This is the read operation of choice against all servers which
            support read extensions in the new dialects of the SMB protocol

            However READ_ANDX itself can be further customized based upon the
            server capabilities. There are two dimensions in which this
            change can occur -- large sized reads being supported and compressed
            reads.

    In addition the SMB protocol supports the following flavours of a READ
    operation which are not supported in the redirector

        1) SMB_COM_READ_RAW
            This is used to initiate large transfers to a server. However this
            ties up the VC exclusively for this operation. The large READ_ANDX
            overcomes this by providing for large read operations which can
            be multiplexed on the VC.

        2) SMB_COM_READ_MPX,SMB_COM_READ_MPX_SECONDARY,
            These operations were designed for a direct host client. The NT
            redriector does not use these operations because the recent
            changes to NetBt allows us to go directly over a TCP connection.

    The implementation of a read operation in the RDR hinges upon two decisions --
    selecting the type of command to use and decomposing the original read
    operation into a number of smaller read operations while adhering to
    protocol/server restrictions.

    The exchange engine provides the facility for sending a packet to the server
    and picking up the associated response. Based upon the amount of data to be
    read a number of such operations need to be initiated.

    This module is organized as follows ---

        MRxSmbRead --
            This represents the top level entry point in the dispatch vector for
            read operations associated with this mini redirector.

        MRxSmbBuildReadRequest --
            This routine is used for formatting the read command to be sent to
            the server. We will require a new routine for each new type of read
            operation that we would like to support

        SmbPseExchangeStart_Read --
            This routine is the heart of the read engine. It farms out the
            necessary number of read operations and ensures the continuation
            of the local operation on completion for both synchronous and
            asynchronous reads.

    All the state information required for the read operation is captured in an
    instance of SMB_PSE_ORDINARY_EXCHANGE. This state information can be split
    into two parts - the generic state information and the state information
    specific to the read operation. The read operation specific state information
    has been encapsulated in SMB_PSE_OE_READWRITE field in the exchange instance.

    The read operation begins with the instantiation of an exchange in MRxSmbRead
    and is driven through the various stages based upon a state diagram. The
    state diagram is encoded in the OpSpecificState field in the ordinary
    exchange.

    The state diagram associated with the read exchange is as follows

                     SmbPseOEInnerIoStates_Initial
                                |
                                |
                                |
                                V
                ---->SmbPseOEInnerIoStates_ReadyToSend
                |               |
                |               |
                |               |
                |               V
                ---SmbPseOEInnerIoStates_OperationOutstanding
                                |
                                |
                                |
                                V
                    SmbPseOEInnerIoStates_OperationCompleted


--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbRead)
#pragma alloc_text(PAGE, MRxSmbBuildReadAndX)
#pragma alloc_text(PAGE, MRxSmbBuildCoreRead)
#pragma alloc_text(PAGE, MRxSmbBuildSmallRead)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Read)
#pragma alloc_text(PAGE, MRxSmbFinishNoCopyRead)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

ULONG MRxSmbSrvReadBufSize = 0xffff; //use the negotiated size
ULONG MRxSmbReadSendOptions = 0;     //use the default options

#define MIN_CHUNK_SIZE (0x1000)

NTSTATUS
MRxSmbBuildReadRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange);

#if DBG
VOID
MRxSmbValidateCompressedDataInfo(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange);
#else
INLINE VOID
MRxSmbValidateCompressedDataInfo(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange)
{
    UNREFERENCED_PARAMETER(OrdinaryExchange);
}
#endif

NTSTATUS
MRxSmbRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_V_NET_ROOT VNetRootToUse = capFobx->pSrvOpen->pVNetRoot;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    SMBFCB_HOLDING_STATE SmbFcbHoldingState = SmbFcb_NotHeld;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbRead\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    do {
        IF_NOT_MRXSMB_CSC_ENABLED{
            ASSERT(smbSrvOpen->hfShadow == 0);
        } else {
            if (smbSrvOpen->hfShadow != 0){
                NTSTATUS ShadowReadNtStatus;
                if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED)) {
                    if (smbFcb->SurrogateSrvOpen == NULL) {
                        //whoops....my surrogate closed.....
                        RxDbgTrace(-1, Dbg, ("MRxSmbRead surrogate closed!! rxc=%08lx\n", RxContext ));
                        return(STATUS_UNSUCCESSFUL);
                    }
                    VNetRootToUse = smbFcb->SurrogateSrvOpen->pVNetRoot;
                } else if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                    //whoops again........someone closed my handle!
                    RxDbgTrace(-1, Dbg, ("MRxSmbRead thruopen closed!! rxc=%08lx\n", RxContext ));
                    return(STATUS_UNSUCCESSFUL);
                }
                ShadowReadNtStatus = MRxSmbCscReadPrologue(RxContext,&SmbFcbHoldingState);
                if (ShadowReadNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbRead shadow hit with status=%08lx\n", ShadowReadNtStatus ));
                    return(ShadowReadNtStatus);
                } else {
                    RxDbgTrace(0, Dbg, ("MRxSmbRead shadowmiss with status=%08lx\n", ShadowReadNtStatus ));
                }
            }
        }

        Status = SmbPseCreateOrdinaryExchange(
                                RxContext,
                                VNetRootToUse,
                                SMBPSE_OE_FROM_READ,
                                SmbPseExchangeStart_Read,
                                &OrdinaryExchange );

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            goto FINALLY;
        }

        OrdinaryExchange->SmbFcbHoldingState = SmbFcbHoldingState;
        OrdinaryExchange->pSmbCeSynchronizationEvent = &RxContext->SyncEvent;

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        if (Status != STATUS_PENDING) {
            BOOLEAN FinalizationComplete;

            SmbFcbHoldingState = OrdinaryExchange->SmbFcbHoldingState;
            FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            ASSERT(FinalizationComplete);
        } else {
            // let the exchange engine take care it
            SmbFcbHoldingState = SmbFcb_NotHeld;
        }

        if ((Status == STATUS_RETRY) &&
            BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            MRxSmbResumeAsyncReadWriteRequests(RxContext);
            Status = STATUS_PENDING;
        }
    } while (Status == STATUS_RETRY);


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbRead  exit with status=%08lx\n", Status ));

    if (SmbFcbHoldingState != SmbFcb_NotHeld) {
        MRxSmbCscReleaseSmbFcb(
            RxContext,
            &SmbFcbHoldingState);
    }


    return(Status);
} // MRxSmbRead


NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for read.

Arguments:

    RxContext - the local context

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    ULONG StartEntryCount;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);
    PSMBCE_SERVER   pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    PSMBCE_NET_ROOT pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB  SmbFcb  = MRxSmbGetFcbExtension(capFcb);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(OrdinaryExchange);
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Read\n", 0 ));

    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                // If not a synchronous read, then continue here when resumed
                if (!SynchronousIo) {
                    OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Read;
                }

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

                rw->UserBufferBase          = RxLowIoGetBufferAddress(RxContext);
                rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
                rw->RemainingByteCount      = LowIoContext->ParamsFor.ReadWrite.ByteCount;

                //record if this is a msgmode/pipe operation......
                if ((capFcb->pNetRoot->Type == NET_ROOT_PIPE) &&
                    (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) ) {
                    SetFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_MSGMODE_PIPE_OPERATION);
                }

                rw->ThisBufferOffset = 0;
                rw->CompressedReadOrWrite = FALSE;

                rw->PartialDataMdlInUse = FALSE;
                rw->PartialExchangeMdlInUse = FALSE;

                rw->UserBufferPortionLength = 0;
                rw->ExchangeBufferPortionLength = 0;

            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
                ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_SUCCESS_IN_COPYHANDLER);
                OrdinaryExchange->SendOptions = MRxSmbReadSendOptions;

                Status = MRxSmbBuildReadRequest(
                             OrdinaryExchange);

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0, Dbg, ("bad read stuffer status........\n"));
                    goto FINALLY;
                }

                if (FlagOn(
                        LowIoContext->ParamsFor.ReadWrite.Flags,
                        LOWIO_READWRITEFLAG_PAGING_IO)) {
                    RxLog(
                        ("PagingIoRead: rxc/offset/length %lx/%lx/%lx",
                         RxContext,
                         &rw->ByteOffsetAsLI,
                         rw->ThisByteCount
                         )
                        );
                    SmbLog(LOG,
                           SmbPseExchangeStart_Read,
                           LOGPTR(RxContext)
                           LOGULONG(rw->ByteOffsetAsLI.LowPart)
                           LOGULONG(rw->ThisByteCount));
                }

                InterlockedIncrement(&MRxSmbStatistics.ReadSmbs);

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_READ );

                // If the status is PENDING, then we're done for now. We must
                // wait until we're re-entered when the receive happens.

                if (Status == STATUS_PENDING) {
                    ASSERT(!SynchronousIo);
                    goto FINALLY;
                }
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
                OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;

                if (OrdinaryExchange->SmbStatus == STATUS_RETRY) {
                    SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                    Status = SmbCeReconnect(SmbCeGetExchangeVNetRoot(OrdinaryExchange));

                    if (Status == STATUS_SUCCESS) {
                        rw->BytesReturned = 0;
                        OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                        Status = SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                        ASSERT(Status == STATUS_SUCCESS);

                        if (Status != STATUS_SUCCESS) {
                            goto FINALLY;
                        }
                    } else {
                        goto FINALLY;
                    }
                } else if (OrdinaryExchange->SmbStatus != STATUS_SUCCESS &&
                    FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
                    switch (OrdinaryExchange->SmbStatus) {
                    case STATUS_IO_TIMEOUT:
                    case STATUS_BAD_NETWORK_PATH:
                    case STATUS_NETWORK_UNREACHABLE:
                    case STATUS_REMOTE_NOT_LISTENING:
                    case STATUS_USER_SESSION_DELETED:
                    case STATUS_CONNECTION_DISCONNECTED:

                        ASSERT(smbSrvOpen->DeferredOpenContext != NULL);
    
                        Status = SmbCeRemoteBootReconnect((PSMB_EXCHANGE)OrdinaryExchange, RxContext);
    
                        OrdinaryExchange->Status = STATUS_RETRY;

                        if (Status == STATUS_SUCCESS) {
                            // Resume the read from the previous offset.

                            OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                            SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                            rw->BytesReturned = 0;
                        } else {
                            Status = STATUS_RETRY;
                            OrdinaryExchange->SmbStatus = STATUS_RETRY;
                            goto FINALLY;
                        }
                        break;
                    }
                }

                if (rw->BytesReturned > 0) {
                    if (rw->CompressedReadOrWrite) {
                        // The Server sent back a compressed response.
                        PUCHAR UserBufferPortion,ExchangeBufferPortion;
                        ULONG  UserBufferPortionLength,ExchangeBufferPortionLength;
                        PUCHAR CompressedBuffer,CompressedTailBuffer;
                        ULONG  CompressedBufferLength,CompressedTailBufferLength;

                        PMDL   OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

                        UserBufferPortionLength = rw->UserBufferPortionLength;
                        ExchangeBufferPortionLength = rw->ExchangeBufferPortionLength;

                        rw->UserBufferPortionLength = 0;
                        if (rw->PartialDataMdlInUse) {
                            MmPrepareMdlForReuse(
                                &rw->PartialDataMdl);

                            rw->PartialDataMdlInUse = FALSE;
                        }

                        rw->ExchangeBufferPortionLength = 0;
                        if (rw->PartialExchangeMdlInUse) {
                            MmPrepareMdlForReuse(
                                &rw->PartialExchangeMdl);

                            rw->PartialExchangeMdlInUse = FALSE;
                        }

                        if (UserBufferPortionLength > 0) {
                            UserBufferPortion = (PCHAR)rw->UserBufferBase +
                                                MmGetMdlByteCount(OriginalDataMdl) -
                                                UserBufferPortionLength;
                        } else {
                            UserBufferPortion = NULL;
                        }

                        if (ExchangeBufferPortionLength > 0) {
                            ExchangeBufferPortion = StufferState->BufferBase;
                        } else {
                            ExchangeBufferPortion =  NULL;
                        }

                        if (UserBufferPortionLength >= rw->CompressedDataInfoLength) {
                            RtlCopyMemory(
                                &rw->CompressedDataInfo,
                                UserBufferPortion,
                                rw->CompressedDataInfoLength);

                                UserBufferPortion += rw->CompressedDataInfoLength;
                                UserBufferPortionLength -= rw->CompressedDataInfoLength;
                        } else {
                            RtlCopyMemory(
                                &rw->CompressedDataInfo,
                                UserBufferPortion,
                                UserBufferPortionLength);

                            RtlCopyMemory(
                                ((PUCHAR)&rw->CompressedDataInfo + UserBufferPortionLength),
                                ExchangeBufferPortion,
                                rw->CompressedDataInfoLength - UserBufferPortionLength);

                            ExchangeBufferPortionLength -= (rw->CompressedDataInfoLength
                                                            - UserBufferPortionLength);
                            ExchangeBufferPortion += (rw->CompressedDataInfoLength
                                                      - UserBufferPortionLength);

                            UserBufferPortionLength = 0;
                        }

                        if (UserBufferPortionLength > 0) {
                            CompressedBuffer            = UserBufferPortion;
                            CompressedBufferLength      = UserBufferPortionLength;
                            CompressedTailBuffer        = ExchangeBufferPortion;
                            CompressedTailBufferLength  = ExchangeBufferPortionLength;
                        } else {
                            CompressedBuffer            = ExchangeBufferPortion;
                            CompressedBufferLength      = ExchangeBufferPortionLength;
                            CompressedTailBuffer        = NULL;
                            CompressedTailBufferLength  = 0;
                        }

                        MRxSmbValidateCompressedDataInfo(
                            OrdinaryExchange);

                        OrdinaryExchange->Status =
                            RtlDecompressChunks(
                                (PCHAR)rw->UserBufferBase + rw->ThisBufferOffset,
                                LowIoContext->ParamsFor.ReadWrite.ByteCount - rw->ThisBufferOffset,
                                CompressedBuffer,
                                CompressedBufferLength,
                                CompressedTailBuffer,
                                CompressedTailBufferLength,
                                &rw->CompressedDataInfo);

                        rw->BytesReturned = rw->CompressedDataInfo.NumberOfChunks * MIN_CHUNK_SIZE;

                        {
                            LARGE_INTEGER Offset = rw->ByteOffsetAsLI;

                            Offset.QuadPart += rw->BytesReturned;

                            if (Offset.QuadPart > capFcb->Header.FileSize.QuadPart) {

                                DbgPrint("Truncating read size from %lx",
                                    rw->BytesReturned);

                                rw->BytesReturned = (ULONG)( capFcb->Header.FileSize.QuadPart -
                                                    rw->ByteOffsetAsLI.QuadPart);

                                DbgPrint(" to %lx\n",rw->BytesReturned);

                            }
                        }

                    } else {

                        if (rw->PartialDataMdlInUse) {
                            MmPrepareMdlForReuse(
                                &rw->PartialDataMdl);

                            rw->PartialDataMdlInUse = FALSE;
                        }
                    }
                } else {
                    if (OrdinaryExchange->Status == STATUS_SUCCESS) {
                        if (capFcb->pNetRoot->Type == NET_ROOT_PIPE){
                            OrdinaryExchange->Status = STATUS_PIPE_EMPTY;
                        } else {
                            OrdinaryExchange->Status = STATUS_END_OF_FILE;
                        }
                    }
                }

                rw->RemainingByteCount -=  rw->BytesReturned;

                if ((OrdinaryExchange->Status == STATUS_END_OF_FILE) &&
                    (RxContext->InformationToReturn > 0)) {
                    OrdinaryExchange->Status = STATUS_SUCCESS;
                    rw->RemainingByteCount = 0;
                }

                RxContext->InformationToReturn += rw->BytesReturned;
                
                Status = OrdinaryExchange->Status;

                if (Status != STATUS_RETRY) {
                    if (NT_ERROR(Status) || (rw->RemainingByteCount==0)) {
                        goto FINALLY;
                    } 

                    if (capFcb->pNetRoot->Type != NET_ROOT_DISK) {
                        if (Status != STATUS_BUFFER_OVERFLOW) {
                            goto FINALLY;
                        } else {
                            ASSERT (rw->BytesReturned == rw->ThisByteCount);
                        }
                    }
                }
                
                //reset the smbstatus.....
                rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
                rw->ThisBufferOffset += rw->BytesReturned;
                rw->BytesReturned = 0;

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

                break;
            }
        }
    }

FINALLY:
    if ( Status != STATUS_PENDING) {
        // update shadow as appropriate............
        IF_NOT_MRXSMB_CSC_ENABLED{
            ASSERT(MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow == 0);
        } else {
            if (MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow != 0){
                MRxSmbCscReadEpilogue(RxContext,&Status);
            }
        }

        if (Status != STATUS_RETRY) {
            if (OrdinaryExchange->SmbFcbHoldingState != SmbFcb_NotHeld) {
                MRxSmbCscReleaseSmbFcb(
                    StufferState->RxContext,
                    &OrdinaryExchange->SmbFcbHoldingState);
            }

            SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
        } else {
            // the exchange will be left hanging if STATUS_PENDING has been returned
            ASSERT(!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
            RxContext->InformationToReturn = 0;
        }
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Read exit w %08lx\n", Status ));

    return Status;
} // SmbPseExchangeStart_Read


NTSTATUS
MRxSmbFinishNoCopyRead (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
{
    PAGED_CODE();

    return(OrdinaryExchange->NoCopyFinalStatus);
}

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
      )
/*++

Routine Description:

    This routine causes the bytes from the message to be transferred to the user's
    buffer. In order to do this, it takes enough bytes from the indication and
    then crafts up an MDL to cause the transport to do the copy.

Arguments:

    please refer to smbpse.c...the only place from which this may be called

Return Value:

    UCHAR - a value representing the action that OE receive routine will perform.
            options are discard (in case of an error),
            copy_for_resume (never called after this is all debugged),
            and normal

--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PRX_CONTEXT    RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL           OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

    PBYTE UserBuffer,ExchangeBuffer;

    ULONG   BytesReturned,DataOffset,CompressedDataBytesReturned = 0;
    ULONG   UserBufferLength;
    ULONG   StartingOffsetInUserBuffer;

    UCHAR   ContinuationCode;

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishReadNoCopy\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishReadNoCopy:");

    rw->CompressedReadOrWrite = BooleanFlagOn(pSmbHeader->Flags2,SMB_FLAGS2_COMPRESSED);

    if (rw->CompressedReadOrWrite) {
        ASSERT(MRxSmbEnableCompression);
    }

    UserBufferLength = MmGetMdlByteCount(OriginalDataMdl);
    UserBuffer = rw->UserBufferBase + rw->ThisBufferOffset;
    ExchangeBuffer = StufferState->BufferBase;

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_READ_ANDX:
        {
            if (Response->WordCount != 12) {
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
                goto FINALLY;
            }

            BytesReturned = SmbGetUshort(&Response->DataLength);
            DataOffset    =  SmbGetUshort(&Response->DataOffset);

            if (rw->CompressedReadOrWrite) {
                rw->CompressedDataInfoLength = SmbGetUshort(&Response->CdiLength);
                CompressedDataBytesReturned = SmbGetUshort(&Response->ByteCount);
            }
        }

        if (DataOffset > sizeof(SMB_HEADER)+sizeof(RESP_READ_ANDX)) {
            OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
            goto FINALLY;
        }

        break;

    case SMB_COM_READ:
        {
            PRESP_READ CoreResponse = (PRESP_READ)Response; //recast response for core read
            
            ASSERT(!rw->CompressedReadOrWrite);

            if (Response->WordCount != 5) {
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
                goto FINALLY;
            }
            
            BytesReturned = SmbGetUshort(&CoreResponse->DataLength);
            DataOffset =  sizeof(SMB_HEADER)+FIELD_OFFSET(RESP_READ,Buffer[0]);
        }
        break;
    }

    if ( BytesReturned > rw->ThisByteCount ) {
        //cut back if we got a bad response
        BytesReturned = rw->ThisByteCount;
    }

    RxDbgTrace(0, Dbg, ("-->ByteCount,Offset,Returned,DOffset,Buffer=%08lx/%08lx/%08lx/%08lx/%08lx\n",
                rw->ThisByteCount,
                rw->ThisBufferOffset,
                BytesReturned,DataOffset,UserBuffer
               ));

    OrdinaryExchange->ContinuationRoutine = MRxSmbFinishNoCopyRead;
    OrdinaryExchange->ReadWrite.BytesReturned =  BytesReturned;

    // now, move the data to the user's buffer If enough is showing, just copy it in.

    if (rw->CompressedReadOrWrite) {
        // The compressed data needs to be copied such that an inplace decompress
        // can be attempted. In order to do so we exploit the fact that we have
        // a preallocated SMB buffer as part of the exchange which spans one chunk
        //
        // This is accomplished by copying the compressed data returned at an offset
        // greater than one chunk in the user buffer. The data returned from the
        // server is copied to the tail portion of the user buffer using the
        // preallocated buffer in the exchange if required.
        //
        // This leads to two possibilities
        //
        //      1) The compressed data returned from the server fits into
        // the preallocated buffer in the exchange
        //
        // or alternatively
        //
        //      2) the compressed data returned from the server spans the tail
        // portion of the user buffer and the preallocated buffer in the exchange

        rw->ExchangeBufferPortionLength = min(
                                              CompressedDataBytesReturned,
                                              OrdinaryExchange->SmbBufSize);

        rw->UserBufferPortionLength = CompressedDataBytesReturned -
                                      rw->ExchangeBufferPortionLength;

        StartingOffsetInUserBuffer = UserBufferLength -
                                     rw->UserBufferPortionLength;
    } else {
        StartingOffsetInUserBuffer = rw->ThisBufferOffset;
        rw->UserBufferPortionLength = BytesReturned;
        rw->ExchangeBufferPortionLength = 0;
    }

    if (BytesIndicated >= (DataOffset +
                           rw->UserBufferPortionLength +
                           rw->ExchangeBufferPortionLength)) {
        if (rw->CompressedReadOrWrite) {
            if (rw->UserBufferPortionLength > 0) {
                RtlCopyMemory(
                    UserBuffer,
                    ((PBYTE)pSmbHeader)+DataOffset,
                    rw->UserBufferPortionLength);
            }

            if (rw->ExchangeBufferPortionLength > 0) {
                RtlCopyMemory(
                    ExchangeBuffer,
                    ((PBYTE)pSmbHeader) + DataOffset + rw->UserBufferPortionLength,
                    rw->ExchangeBufferPortionLength);
            }
        } else {
            RtlCopyMemory(
                UserBuffer,
                ((PBYTE)pSmbHeader)+DataOffset,
                rw->UserBufferPortionLength);
        }

        *pBytesTaken  = DataOffset +
                        rw->UserBufferPortionLength +
                        rw->ExchangeBufferPortionLength;

        RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy  copy fork\n" ));

        ContinuationCode = SMBPSE_NOCOPYACTION_NORMALFINISH;
    } else {
        // otherwise, MDL it in.  we use the smbbuf as an Mdl!
        if (BytesIndicated < DataOffset) {
            OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
            goto FINALLY;
        }

        if (rw->UserBufferPortionLength > 0) {
            rw->PartialDataMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialDataMdl,
                0,
                PAGE_SIZE + rw->UserBufferPortionLength);

            IoBuildPartialMdl(
                OriginalDataMdl,
                &rw->PartialDataMdl,
                (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) + StartingOffsetInUserBuffer,
                rw->UserBufferPortionLength);
        }

        if (rw->ExchangeBufferPortionLength > 0) {
            rw->PartialExchangeMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialExchangeMdl,
                0,
                PAGE_SIZE + rw->ExchangeBufferPortionLength);

            IoBuildPartialMdl(
                StufferState->HeaderMdl,
                &rw->PartialExchangeMdl,
                MmGetMdlVirtualAddress( StufferState->HeaderMdl ),
                rw->ExchangeBufferPortionLength);
        }

        if (rw->PartialDataMdlInUse) {
            if (rw->PartialExchangeMdlInUse) {
                rw->PartialDataMdl.Next = &rw->PartialExchangeMdl;
            }

            *pDataBufferPointer = &rw->PartialDataMdl;
        } else {
            *pDataBufferPointer = &rw->PartialExchangeMdl;
        }

        *pDataSize    = rw->UserBufferPortionLength +
                        rw->ExchangeBufferPortionLength;
        *pBytesTaken  = DataOffset;

        RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy   mdlcopy fork \n" ));

        ContinuationCode = SMBPSE_NOCOPYACTION_MDLFINISH;
    }

FINALLY:
    return ContinuationCode;
}

NTSTATUS
MRxSmbBuildReadRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange)
/*++

Routine Description:

    This routine formats the appropriate type of read request issued to the
    server

Arguments:

    OrdinaryExchange - the exchange instance encapsulating the information

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;
    UCHAR    SmbCommand;
    ULONG    SmbCommandSize;
    BOOLEAN  CompressedReadRequest;

    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);
    PSMBCE_SERVER         pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    PSMBCE_NET_ROOT       pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);
    PMRX_V_NET_ROOT       pVNetRoot = SmbCeGetExchangeVNetRoot(OrdinaryExchange);

    PRX_CONTEXT              RxContext    = OrdinaryExchange->RxContext;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    rw->ThisByteCount = min(rw->RemainingByteCount,pNetRoot->MaximumReadBufferSize);

    OffsetLow  = rw->ByteOffsetAsLI.LowPart;
    OffsetHigh = rw->ByteOffsetAsLI.HighPart;

    CompressedReadRequest = FALSE;

    if (FlagOn(pServer->DialectFlags,DF_LANMAN10)) {
        SmbCommand = SMB_COM_READ_ANDX;
        SmbCommandSize = SMB_REQUEST_SIZE(NT_READ_ANDX);

        if (MRxSmbEnableCompression &&
            (pServer->Capabilities & COMPRESSED_DATA_CAPABILITY) &&
            (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) &&
            ((rw->ThisByteCount & 0xfff) == 0 ) &&
            ((rw->ByteOffsetAsLI.LowPart & 0xfff) == 0 )) {
            CompressedReadRequest = TRUE;
        }
    } else {
        SmbCommandSize = SMB_REQUEST_SIZE(READ);
        SmbCommand = SMB_COM_READ;
    }

    MRxSmbDumpStufferState(
        1000,
        "SMB w/ READ before stuffing",
        StufferState);


    Status = MRxSmbStartSMBCommand (
                 StufferState,
                 SetInitialSMB_Never,
                 SmbCommand,
                 SmbCommandSize,
                 NO_EXTRA_DATA,
                 NO_SPECIAL_ALIGNMENT,
                 RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                 0,0,0,0 STUFFERTRACE(Dbg,'FC'));

    if (Status != STATUS_SUCCESS) {
        return Status;

    }

    switch (SmbCommand) {
    case SMB_COM_READ:
        {
            // below, we just set mincount==maxcount. rdr1 did this.......
            MRxSmbStuffSMB (
                StufferState,
                "0wwdwB!",
                                         //  0         UCHAR WordCount;
                 smbSrvOpen->Fid,        //  w         _USHORT( Fid );
                 rw->ThisByteCount,      //  w         _USHORT( Count );
                 OffsetLow,              //  d         _ULONG( Offset );
                 rw->RemainingByteCount, //  w         _USHORT( Remaining );
                                         //  B!        _USHORT( ByteCount );
                 SMB_WCT_CHECK(5) 0
                                         //            UCHAR Buffer[1];
                 );
        }
        break;

    case SMB_COM_READ_ANDX:
        {
            PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
            BOOLEAN UseNtVersion;
            ULONG Timeout = 0;

            if (pVNetRoot->pNetRoot->Type == NET_ROOT_PIPE) {
                Timeout = (ULONG)-1;
            }

            UseNtVersion = BooleanFlagOn(pServer->DialectFlags,DF_NT_SMBS);

            if (UseNtVersion &&
                FlagOn(
                    LowIoContext->ParamsFor.ReadWrite.Flags,
                    LOWIO_READWRITEFLAG_PAGING_IO)) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2) | SMB_FLAGS2_PAGING_IO );
            }

            if (UseNtVersion &&
                CompressedReadRequest) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2) | SMB_FLAGS2_COMPRESSED);
            }

            IF_NOT_MRXSMB_CSC_ENABLED{
                ASSERT(!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED));
            } else {
                if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED)) {
                    SmbPutAlignedUshort(
                        &NtSmbHeader->Flags2,
                        SmbGetAlignedUshort(&NtSmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO );
                }
            }

            // below, we just set mincount==maxcount. rdr1 did this.......
            MRxSmbStuffSMB (
                StufferState,
                "XwdwWdw",
                                                     //  X        UCHAR WordCount;
                                                     //           UCHAR AndXCommand;
                                                     //           UCHAR AndXReserved;
                                                     //           _USHORT( AndXOffset );
                smbSrvOpen->Fid,                     //  w        _USHORT( Fid );
                OffsetLow,                           //  d        _ULONG( Offset );
                rw->ThisByteCount,                   //  w        _USHORT( MaxCount );
                SMB_OFFSET_CHECK(READ_ANDX,MinCount)
                rw->ThisByteCount,                   //  W        _USHORT( MinCount );
                Timeout,                             //  d        _ULONG( Timeout );
                rw->RemainingByteCount,              //  w        _USHORT( Remaining );
                StufferCondition(UseNtVersion), "D",
                SMB_OFFSET_CHECK(NT_READ_ANDX,OffsetHigh)
                OffsetHigh,                          //  D NTonly _ULONG( OffsetHigh );
                                                     //
                STUFFER_CTL_NORMAL, "B!",
                                                     //  B!       _USHORT( ByteCount );
                SMB_WCT_CHECK(((UseNtVersion)?12:10)) 0
                                                     //           UCHAR Buffer[1];
                );
        }
        break;
    default:
        break;
    }

    if (Status == STATUS_SUCCESS) {
        MRxSmbDumpStufferState(
            700,
            "SMB w/ READ after stuffing",
            StufferState);

        InterlockedIncrement(&MRxSmbStatistics.SmallReadSmbs);
    }

    return Status;
}

#if DBG
VOID
MRxSmbValidateCompressedDataInfo(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange)
/*++

Routine Description:

    This routine validated the Compressed data info structure returned from the
    server

Arguments:

    OrdinaryExchange - the exchange instance encapsulating the information

--*/
{

    PSMBCE_NET_ROOT       pNetRoot;
    PSMB_PSE_OE_READWRITE rw;
    PCOMPRESSED_DATA_INFO pCompressedDataInfo;

    ULONG  RequestedReadLength,CompressedDataLength;
    ULONG  NumberOfChunks,ChunkSize;
    USHORT i;

    pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

    rw = &OrdinaryExchange->ReadWrite;

    pCompressedDataInfo = &rw->CompressedDataInfo;
    RequestedReadLength = rw->ThisByteCount;

    if ((pCompressedDataInfo->ChunkShift == 0) ||
        (pCompressedDataInfo->ClusterShift == 0) ||
        (pCompressedDataInfo->CompressionUnitShift == 0)) {
        DbgPrint("Invalid CDI:%lx\n",pCompressedDataInfo);
        //DbgBreakPoint();
    }

    ChunkSize = (1 << pCompressedDataInfo->ChunkShift);

    if (ChunkSize == 0) {
        DbgPrint("CDI: %lx Invalid Chunk Size\n",pCompressedDataInfo);
        //DbgBreakPoint();
    }

    NumberOfChunks = RequestedReadLength / ChunkSize;
    if ((pCompressedDataInfo->NumberOfChunks == 0) ||
        (pCompressedDataInfo->NumberOfChunks > NumberOfChunks)){
        DbgPrint("CDI: %lx, Invalid number Of Chunks returned\n",pCompressedDataInfo);
    }

    CompressedDataLength = 0;
    for (i = 0; i < pCompressedDataInfo->NumberOfChunks; i++) {
        CompressedDataLength += pCompressedDataInfo->CompressedChunkSizes[i];
    }

    if (CompressedDataLength > RequestedReadLength) {
        DbgPrint("CDI: %lx, More data returned than requested\n",pCompressedDataInfo);
        //DbgBreakPoint();
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\sessetup.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop


#include "exsessup.h"
#include "ntlsapi.h"
#include "mrxsec.h"
#include "rdrssp\kfuncs.h"
#include "rdrssp\secret.h"

#include <wincred.h>
#include <secpkg.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildSessionSetupSmb)
#pragma alloc_text(PAGE, BuildNtLanmanResponsePrologue)
#pragma alloc_text(PAGE, BuildNtLanmanResponseEpilogue)
#pragma alloc_text(PAGE, BuildExtendedSessionSetupResponsePrologue)
#pragma alloc_text(PAGE, BuildExtendedSessionSetupResponseEpilogue)
#endif

extern BOOLEAN MRxSmbSecuritySignaturesEnabled;

UNICODE_STRING CifsServiceName = { 8, 10, L"cifs" };

NTSTATUS
BuildSessionSetupSmb(
    PSMB_EXCHANGE pExchange,
    PGENERIC_ANDX  pAndXSmb,
    PULONG         pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the session setup SMB for a NT server

Arguments:

    pExchange - the exchange instance

    pAndXSmb  - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the general structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    PSMBCE_SERVER          pServer;
    PSMBCE_SESSION         pSession;

    PREQ_SESSION_SETUP_ANDX pSessionSetup;
    PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetup;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX pExtendedNtSessionSetup;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    PAGED_CODE();

    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pServer  = SmbCeGetExchangeServer(pExchange);
    pSession = SmbCeGetExchangeSession(pExchange);

    // There are three different variants of session setup and X that can be shipped to the
    // server. All three of them share some common fields. The setting of these common fields
    // is done in all the three cases by accessing the passed in buffer as an instance of
    // REQ_SESSION_SETUP_ANDX. The fields specific to the remaining two are conditionalized upon
    // accessing the same buffer as an instance of REQ_NT_SESSION_SETUP_ANDX and
    // REQ_EXTENDED_NT_SESSION_SETUP_ANDX respectively. This implies that great care must be
    // taken in shuffling the fields in these three structs.

    pSessionSetup           = (PREQ_SESSION_SETUP_ANDX)pAndXSmb;
    pNtSessionSetup         = (PREQ_NT_SESSION_SETUP_ANDX)pSessionSetup;
    pExtendedNtSessionSetup =  (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)pSessionSetup;

    pSessionSetup->AndXCommand = 0xff;   // No ANDX
    pSessionSetup->AndXReserved = 0x00;  // Reserved (MBZ)

    SmbPutUshort(&pSessionSetup->AndXOffset, 0x0000); // No AndX as of yet.

    //  Since we can allocate pool dynamically, we set our buffer size
    //  to match that of the server.
    SmbPutUshort(&pSessionSetup->MaxBufferSize, (USHORT)pServer->MaximumBufferSize);
    SmbPutUshort(&pSessionSetup->MaxMpxCount, pServer->MaximumRequests);

    SmbPutUshort(&pSessionSetup->VcNumber, (USHORT)pSessionEntry->SessionVCNumber);

    SmbPutUlong(&pSessionSetup->SessionKey, pServer->SessionKey);
    SmbPutUlong(&pSessionSetup->Reserved, 0);

    if (pServer->Dialect == NTLANMAN_DIALECT) {
        // Set up the NT server session setup specific parameters.
        if (FlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY) &&
            !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
            SmbPutUshort(&pExtendedNtSessionSetup->WordCount,12);

            // Set the capabilities
            SmbPutUlong(
                &pExtendedNtSessionSetup->Capabilities,
                (CAP_NT_STATUS |
                 CAP_UNICODE |
                 CAP_LEVEL_II_OPLOCKS |
                 CAP_NT_SMBS |
                 CAP_DYNAMIC_REAUTH |
                 CAP_EXTENDED_SECURITY));
        } else {
            SmbPutUshort(&pNtSessionSetup->WordCount,13);

            // Set the capabilities
            SmbPutUlong(
                &pNtSessionSetup->Capabilities,
                (CAP_NT_STATUS |
                 CAP_UNICODE |
                 CAP_LEVEL_II_OPLOCKS |
                 CAP_NT_SMBS ));
        }
    } else {
        SmbPutUshort(&pSessionSetup->WordCount,10);
    }

    // Build the security information in the session setup SMB.
    Status = BuildSessionSetupSecurityInformation(
                 pExchange,
                 (PBYTE)pSessionSetup,
                 pAndXSmbBufferSize);

    if (NT_SUCCESS(Status)) {
        // Copy the operating system name and the LANMAN version info
        // position the buffer for copying the operating system name and the lanman type.
        PBYTE pBuffer = (PBYTE)pSessionSetup +
                        OriginalBufferSize -
                        *pAndXSmbBufferSize;

        if (FlagOn(pServer->DialectFlags,DF_UNICODE)){

            //
            // Make sure the UNICODE string is suitably aligned
            //
            if( ((ULONG_PTR)pBuffer) & 01 ) {
                pBuffer++;
                (*pAndXSmbBufferSize)--;
            }

            Status = SmbPutUnicodeString(
                         &pBuffer,
                         &SmbCeContext.OperatingSystem,
                         pAndXSmbBufferSize);

            if (NT_SUCCESS(Status)) {

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &SmbCeContext.LanmanType,
                             pAndXSmbBufferSize);
            }
        } else {
            Status = SmbPutUnicodeStringAsOemString(
                         &pBuffer,
                         &SmbCeContext.OperatingSystem,
                         pAndXSmbBufferSize);

            if (NT_SUCCESS(Status)) {
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &SmbCeContext.LanmanType,
                             pAndXSmbBufferSize);
            }
        }

        if (NT_SUCCESS(Status)) {
            if (pServer->Dialect == NTLANMAN_DIALECT) {
                if (FlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY) &&
                    !FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
                    SmbPutUshort(
                        &pExtendedNtSessionSetup->ByteCount,
                        (USHORT)(OriginalBufferSize -
                        FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer) -
                        *pAndXSmbBufferSize));
                } else {
                    SmbPutUshort(
                        &pNtSessionSetup->ByteCount,
                        (USHORT)(OriginalBufferSize -
                        FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer) -
                        *pAndXSmbBufferSize));
                }
            } else {
                SmbPutUshort(
                    &pSessionSetup->ByteCount,
                    (USHORT)(OriginalBufferSize -
                    FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer) -
                    *pAndXSmbBufferSize));
            }
        }
    }

    return Status;
}

NTSTATUS
BuildNtLanmanResponsePrologue(
    PSMB_EXCHANGE              pExchange,
    PUNICODE_STRING            pUserName,
    PUNICODE_STRING            pDomainName,
    PSTRING                    pCaseSensitiveResponse,
    PSTRING                    pCaseInsensitiveResponse,
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB to
   without extended security negotiation

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine needs to be executed in the system process in order to protect virtual memory

--*/
{
    NTSTATUS       Status;
    NTSTATUS       FinalStatus;
    
    UNICODE_STRING ServerName;
    UNICODE_STRING TargetServerName;

    PVOID          pTargetInformation;
    ULONG          TargetInformationSize;
    ULONG           ExtraSize = 0;
    PVOID           ExtraServerTargetInfo = NULL;

    SecBufferDesc  InputToken;
    SecBuffer      InputBuffer[2];
    SecBufferDesc  *pOutputBufferDescriptor = NULL;
    SecBuffer      *pOutputBuffer           = NULL;
    ULONG_PTR       OutputBufferDescriptorSize;

    ULONG LsaFlags = ISC_REQ_ALLOCATE_MEMORY;
    TimeStamp Expiry;
    PCHALLENGE_MESSAGE InToken = NULL;
    ULONG InTokenSize;
    PNTLM_CHALLENGE_MESSAGE NtlmInToken = NULL;
    ULONG NtlmInTokenSize = 0;
    PAUTHENTICATE_MESSAGE OutToken = NULL;
    PNTLM_INITIALIZE_RESPONSE NtlmOutToken = NULL;
    PUCHAR          p = NULL;
    ULONG_PTR       AllocateSize;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    
    PAGED_CODE();

    try {
        pResponseContext->KerberosSetup.pOutputContextBuffer = NULL;

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot session and we do not have the proper
        // credentials to log in to the machine account, then use the NULL
        // session.
        //

        if (FlagOn(pSession->Flags, SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
            !MRxSmbRemoteBootDoMachineLogon) {

            //
            // Remote boot session with no credentials. Set up a NULL session.
            //

            pCaseSensitiveResponse->Length = 0;
            pCaseSensitiveResponse->MaximumLength = 0;
            pCaseSensitiveResponse->Buffer = NULL;
            pCaseInsensitiveResponse->Length = 0;
            pCaseInsensitiveResponse->MaximumLength = 0;
            pCaseInsensitiveResponse->Buffer = NULL;
            pDomainName->Length = 0;
            pDomainName->MaximumLength = 0;
            pDomainName->Buffer = NULL;
            pUserName->Length = 0;
            pUserName->MaximumLength = 0;
            pUserName->Buffer = NULL;
            Status = STATUS_SUCCESS;

        } else
#endif // defined(REMOTE_BOOT)
        {
            SmbCeGetServerName(
                pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,
                &ServerName);

            if (pServerEntry->DomainName.Length && pServerEntry->DomainName.Buffer) {
                TargetServerName = ServerName;
                ExtraSize = ServerName.Length;
                ExtraServerTargetInfo = ServerName.Buffer;
                ServerName = pServerEntry->DomainName;
            }

            TargetInformationSize = ServerName.Length;
            pTargetInformation    = ServerName.Buffer;

            InTokenSize = sizeof(CHALLENGE_MESSAGE) + TargetInformationSize + ExtraSize;

            NtlmInTokenSize = sizeof(NTLM_CHALLENGE_MESSAGE);

            if (pSession->pPassword != NULL) {
                NtlmInTokenSize += pSession->pPassword->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            if (pSession->pUserName != NULL) {
                NtlmInTokenSize += pSession->pUserName->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            if (pSession->pUserDomainName != NULL) {
                NtlmInTokenSize += pSession->pUserDomainName->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            // For Alignment purposes, we want InTokenSize rounded up to
            // the nearest word size.

            AllocateSize = ((InTokenSize + 3) & ~3) + NtlmInTokenSize;

            InToken = ExAllocatePool( 
                        PagedPool, 
                        AllocateSize );

            if ( InToken == NULL )
            {
                Status = STATUS_NO_MEMORY;
                try_return( Status );
                
            }

            // Allocate the output buffer
            OutputBufferDescriptorSize = sizeof(SecBufferDesc) + 2 * sizeof(SecBuffer);

            pOutputBufferDescriptor = ExAllocatePool( 
                                            PagedPool, 
                                            OutputBufferDescriptorSize );

            if ( pOutputBufferDescriptor == NULL )
            {
                Status = STATUS_NO_MEMORY ;
                try_return( Status );
                
            }

            pOutputBuffer = (SecBuffer *)(pOutputBufferDescriptor + 1);
            pResponseContext->KerberosSetup.pOutputContextBuffer = pOutputBufferDescriptor;

            RxDbgTrace(0,Dbg,("Allocate pool %p\n", InToken));

            // partition off the NTLM in token part of the
            // buffer
            if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
            {
                NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
                NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) (((ULONG_PTR) NtlmInToken + 3) & ~3);
                RtlZeroMemory(NtlmInToken,NtlmInTokenSize);
                p = (PUCHAR) NtlmInToken + sizeof(NTLM_CHALLENGE_MESSAGE);
            }

            if(!SecIsValidHandle(&pSession->CredentialHandle)) {
                UNICODE_STRING LMName;
                TimeStamp LifeTime;

                LMName.Buffer = (PWSTR) InToken;
                LMName.Length = NTLMSP_NAME_SIZE;
                LMName.MaximumLength = LMName.Length;
                RtlCopyMemory(
                    LMName.Buffer,
                    NTLMSP_NAME,
                    NTLMSP_NAME_SIZE);


                if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                    MRxSmbUseKernelModeSecurity) {
                    ULONG fCredentialUse = SECPKG_CRED_OUTBOUND;

                    if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
                        fCredentialUse |= SECPKG_CRED_OWF_PASSWORD;
                    }

                    Status = AcquireCredentialsHandleK(
                                 NULL,
                                 &LMName,
                                 fCredentialUse,
                                 &pSession->LogonId,
                                 NULL,
                                 NULL,
                                 (PVOID)1,
                                 &pSession->CredentialHandle,
                                 &LifeTime);
                } else {
                    Status = AcquireCredentialsHandleW(
                                 NULL,
                                 &LMName,
                                 SECPKG_CRED_OUTBOUND,
                                 &pSession->LogonId,
                                 NULL,
                                 NULL,
                                 (PVOID)1,
                                 &pSession->CredentialHandle,
                                 &LifeTime);
                }

                if(!NT_SUCCESS(Status)) {
                    SecInvalidateHandle( &pSession->CredentialHandle );
                    SmbLogError(Status,
                                LOG,
                                BuildNtLanmanResponsePrologue_1,
                                LOGPTR(pSession)
                                LOGULONG(Status)
                                LOGUSTR(ServerName));
                    
                    // We need to free the output buffer (and description) because if they are valid,
                    // BuildNtLanmanResponseEpilogue will try and parse them, and they have not been 
                    // initialized yet...
                    ExFreePool( pOutputBufferDescriptor );
                    pResponseContext->KerberosSetup.pOutputContextBuffer = NULL;

                    try_return(Status);
                }
            }
            
            // Copy in the pass,user,domain if they were specified
            if(pSession->pPassword != NULL) {
                NtlmInToken->Password.Length = pSession->pPassword->Length;
                NtlmInToken->Password.MaximumLength = pSession->pPassword->Length;
                RtlCopyMemory(
                    p,
                    pSession->pPassword->Buffer,
                    pSession->pPassword->Length);
                NtlmInToken->Password.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pPassword->Length;
            }

            if(pSession->pUserName != NULL) {
                NtlmInToken->UserName.Length = pSession->pUserName->Length;
                NtlmInToken->UserName.MaximumLength = pSession->pUserName->Length;
                RtlCopyMemory(
                    p,
                    pSession->pUserName->Buffer,
                    pSession->pUserName->Length);
                NtlmInToken->UserName.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pUserName->Length;
            }

            if (pSession->pUserDomainName != NULL) {
                NtlmInToken->DomainName.Length = pSession->pUserDomainName->Length;
                NtlmInToken->DomainName.MaximumLength = pSession->pUserDomainName->Length;
                RtlCopyMemory(
                    p,
                    pSession->pUserDomainName->Buffer,
                    pSession->pUserDomainName->Length);
                NtlmInToken->DomainName.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pUserDomainName->Length;
            }

            RtlCopyMemory(
                InToken->Signature,
                NTLMSSP_SIGNATURE,
                sizeof(NTLMSSP_SIGNATURE));
            InToken->MessageType = NtLmChallenge;

            InToken->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                      NTLMSSP_NEGOTIATE_OEM |
                                      NTLMSSP_REQUEST_INIT_RESPONSE;

            if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
                InToken->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;
            }

            RtlCopyMemory(
                InToken->Challenge,
                pServer->EncryptionKey,
                MSV1_0_CHALLENGE_LENGTH);

            InToken->TargetName.Length =
            InToken->TargetName.MaximumLength = (USHORT)TargetInformationSize;
            InToken->TargetName.Buffer = sizeof(CHALLENGE_MESSAGE);

            RtlCopyMemory(
                (PCHAR)InToken + sizeof(CHALLENGE_MESSAGE),
                pTargetInformation,
                TargetInformationSize);

            TargetServerName.Buffer = (PWCHAR) ((PCHAR)InToken + 
                                             sizeof(CHALLENGE_MESSAGE) +
                                             TargetInformationSize);

            if (ExtraSize) {
                RtlCopyMemory(
                    TargetServerName.Buffer,
                    ExtraServerTargetInfo,
                    ExtraSize);

                InToken->NegotiateFlags |= NTLMSSP_TARGET_TYPE_DOMAIN;
            } else {
                InToken->NegotiateFlags |= NTLMSSP_TARGET_TYPE_SERVER;
            }

            InputToken.pBuffers = InputBuffer;
            InputToken.cBuffers = 1;
            InputToken.ulVersion = 0;
            InputBuffer[0].pvBuffer = InToken;
            InputBuffer[0].cbBuffer = InTokenSize;
            InputBuffer[0].BufferType = SECBUFFER_TOKEN;

            if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
            {
                InputToken.cBuffers = 2;
                InputBuffer[1].pvBuffer = NtlmInToken;
                InputBuffer[1].cbBuffer = NtlmInTokenSize;
                InputBuffer[1].BufferType = SECBUFFER_TOKEN;
            }

            pOutputBufferDescriptor->pBuffers = pOutputBuffer;
            pOutputBufferDescriptor->cBuffers = 2;
            pOutputBufferDescriptor->ulVersion = 0;
            pOutputBuffer[0].pvBuffer = NULL;
            pOutputBuffer[0].cbBuffer = 0;
            pOutputBuffer[0].BufferType = SECBUFFER_TOKEN;
            pOutputBuffer[1].pvBuffer = NULL;
            pOutputBuffer[1].cbBuffer = 0;
            pOutputBuffer[1].BufferType = SECBUFFER_TOKEN;

            if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                MRxSmbUseKernelModeSecurity) {
                Status = InitializeSecurityContextK(
                             &pSession->CredentialHandle,
                             (PCtxtHandle)NULL,
                             ExtraSize ? &TargetServerName : NULL,
                             LsaFlags,
                             0,
                             SECURITY_NATIVE_DREP,
                             &InputToken,
                             0,
                             &pSession->SecurityContextHandle,
                             pOutputBufferDescriptor,
                             &FinalStatus,
                             &Expiry);
            } else {
                Status = InitializeSecurityContextW(
                             &pSession->CredentialHandle,
                             (PCtxtHandle)NULL,
                             ExtraSize ? &TargetServerName : NULL,
                             LsaFlags,
                             0,
                             SECURITY_NATIVE_DREP,
                             &InputToken,
                             0,
                             &pSession->SecurityContextHandle,
                             pOutputBufferDescriptor,
                             &FinalStatus,
                             &Expiry);
            }

            if(!NT_SUCCESS(Status)) {
                if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                    MRxSmbUseKernelModeSecurity) {
                    Status = MapSecurityErrorK(Status);
                } else {
                    Status = MapSecurityError(Status);
                }
                SmbCeLog(("IniSecCtxStat %p %lx\n",SmbCeGetExchangeSessionEntry(pExchange),Status));
                SmbLogError(Status,
                            LOG,
                            BuildNtLanmanResponsePrologue_2,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));

                try_return(Status);
            }

            OutToken = (PAUTHENTICATE_MESSAGE) pOutputBuffer[0].pvBuffer;

            ASSERT(OutToken != NULL);
            RxDbgTrace(0,Dbg,("InitSecCtxt OutToken is %p\n", OutToken));
            
            if (OutToken == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                SmbLogError(Status,
                            LOG,
                            BuildNtLanmanResponsePrologue_3,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));
                try_return(Status);
            }

            // The security response the pointers are encoded in terms off the offset
            // from the beginning of the buffer. Make the appropriate adjustments.

            if (ARGUMENT_PRESENT(pCaseSensitiveResponse)) {
                pCaseSensitiveResponse->Length        = OutToken->NtChallengeResponse.Length;
                pCaseSensitiveResponse->MaximumLength = OutToken->NtChallengeResponse.MaximumLength;
                pCaseSensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG_PTR)OutToken->NtChallengeResponse.Buffer;
            }

            if (ARGUMENT_PRESENT(pCaseInsensitiveResponse)) {
                pCaseInsensitiveResponse->Length        = OutToken->LmChallengeResponse.Length;
                pCaseInsensitiveResponse->MaximumLength = OutToken->LmChallengeResponse.MaximumLength;
                pCaseInsensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG_PTR)OutToken->LmChallengeResponse.Buffer;
            }

            if (pSession->pUserDomainName != NULL) {
                *pDomainName = *(pSession->pUserDomainName);
            } else {
                pDomainName->Length        = OutToken->DomainName.Length;
                pDomainName->MaximumLength = pDomainName->Length;
                pDomainName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG_PTR)OutToken->DomainName.Buffer);
            }

            if (pSession->pUserName != NULL) {
                *pUserName = *(pSession->pUserName);
            } else {
                pUserName->Length        = OutToken->UserName.Length;
                pUserName->MaximumLength = OutToken->UserName.MaximumLength;
                pUserName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG_PTR)OutToken->UserName.Buffer);
            }

            NtlmOutToken = pOutputBuffer[1].pvBuffer;
            if (NtlmOutToken != NULL) {
                RtlCopyMemory(
                    pSession->UserSessionKey,
                    NtlmOutToken->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    pSession->LanmanSessionKey,
                    NtlmOutToken->LanmanSessionKey,
                    MSV1_0_LANMAN_SESSION_KEY_LENGTH);
            }
        }

try_exit:NOTHING;
    } finally {
        if (InToken != NULL) {

            ExFreePool( InToken );
        }

        if (!NT_SUCCESS(Status)) {
            BuildNtLanmanResponseEpilogue(pExchange, pResponseContext);
        } else {
            // This routine can be call from tree connect request, the SecurityContextHandle
            // will be overwritten if not deleted, which causes pool leak on LSA.
            DeleteSecurityContextForSession(pSession);
        }
    }
    
    SmbLogError(Status,
                LOG,
                BuildNtLanmanResponsePrologue,
                LOGPTR(pSession)
                LOGULONG(Status));

    return Status;
}

NTSTATUS
BuildNtLanmanResponseEpilogue(
    PSMB_EXCHANGE              pExchange,
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
/*++
    This routine needs to be executed in the system process in order to protect virtual memory
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);

    PAGED_CODE();

    if (pResponseContext->KerberosSetup.pOutputContextBuffer != NULL) {
        ULONG i = 0;
        SecBufferDesc *pBufferDescriptor = (SecBufferDesc *)pResponseContext->KerberosSetup.pOutputContextBuffer;
        SecBuffer     *pBuffer = pBufferDescriptor->pBuffers;
        ULONG_PTR      BufferDescriptorSize = sizeof(SecBufferDesc) + 2 * sizeof(SecBuffer);

        for (i = 0; i < pBufferDescriptor->cBuffers; i++) {
            if (pBuffer[i].pvBuffer != NULL) {
                if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                    MRxSmbUseKernelModeSecurity) {
                    FreeContextBufferK(pBuffer[i].pvBuffer);
                } else {
                    FreeContextBuffer(pBuffer[i].pvBuffer);
                }
            }
        }

        ExFreePool( pBufferDescriptor );

        pResponseContext->KerberosSetup.pOutputContextBuffer = NULL;
    }
    
    return Status;
}


NTSTATUS
BuildExtendedSessionSetupResponsePrologue(
    PSMB_EXCHANGE              pExchange,
    PVOID                      pSecurityBlobPtr,
    PUSHORT                    pSecurityBlobSize,
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB to
   a NT server with extended security

Arguments:

    pExchange - the SMB_EXCHANGE that's going on for this call.  If this is a
                subsequent call, this exchange will have the server's security
                blob.
    
    pSecurityBlobPtr - On entry, pointer to where in the SMB to stick the security
                blob destined for the server.
                
    pSecurityBlobSize - On entry, the max size allowed for a security blob. On
                exit, the actual size of the blob.
                
    pResponseContext -                 


Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.
    
    This routine needs to be executed in the system process in order to protect virtual memory

--*/
{
    NTSTATUS        Status;
    SECURITY_STATUS SecStatus;

    ULONG           Catts;
    TimeStamp       Expiry;

    ULONG           LsaFlags = (ISC_REQ_MUTUAL_AUTH |
                                ISC_REQ_DELEGATE |
                                ISC_REQ_FRAGMENT_TO_FIT );
    ULONG_PTR       RemoteBlobOffset;
    ULONG_PTR       OutputBufferSize;

    UNICODE_STRING  PrincipalName = { 0 };
    PUNICODE_STRING pServerPrincipalName;

    PVOID           pServerSecurityBlob;
    ULONG           ServerSecurityBlobSize;

    PUCHAR          pTempBlob = NULL;

    PSMBCE_SERVER   pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION  pSession = SmbCeGetExchangeSession(pExchange);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    
    UNICODE_STRING  ServerName;
    BOOLEAN         bTempServerName = FALSE;
    PUNICODE_STRING pServerDomainName;
    UNICODE_STRING  TargetInfoMarshalled;

    PSMBCE_EXTENDED_SESSION              pExtendedSession;
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtendedSessionSetupExchange;

    SecBufferDesc   InputToken;
    SecBuffer       InputBuffer;
    SecBufferDesc   OutputToken;
    SecBuffer       OutputBuffer;

    PCtxtHandle     pInputContextHandle = NULL;
    ULONG           SpnSize = 0;

    PAGED_CODE();

    ASSERT((pExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) &&
           (pSession->Type  == EXTENDED_NT_SESSION));

    SmbCeAcquireResource();
    
    if (pServerEntry->DnsName.Buffer != NULL) {
        ServerName.Length = pServerEntry->DnsName.Length;
        ServerName.MaximumLength = pServerEntry->DnsName.MaximumLength;
        
        ServerName.Buffer = RxAllocatePoolWithTag(PagedPool,ServerName.MaximumLength,MRXSMB_SERVER_POOLTAG);

        if (ServerName.Buffer) {
            RtlCopyMemory(ServerName.Buffer,
                          pServerEntry->DnsName.Buffer,
                          pServerEntry->DnsName.Length);

            bTempServerName = TRUE;
        } else {
            SmbCeReleaseResource();

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        //DbgPrint("DNS name is used for session setup %wZ\n", &ServerName);
    } else {
        SmbCeGetServerName(
            pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,
            &ServerName);
    }
    
    SmbCeReleaseResource();

    ASSERT(ServerName.MaximumLength > (ServerName.Length + sizeof(WCHAR)));
    
    if ((pExchange->RxContext != NULL) &&
        (pExchange->RxContext->MajorFunction == IRP_MJ_CREATE) &&
        ((pExchange->RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT)) ||
         (pExchange->RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)))) {
        ASSERT(pExchange->RxContext->Create.NtCreateParameters.DfsNameContext != NULL);
        
        if (pSession->TargetInfoMarshalled == NULL) {
            PDFS_NAME_CONTEXT DfsNameContext = (PDFS_NAME_CONTEXT)pExchange->RxContext->Create.NtCreateParameters.DfsNameContext;

            if (DfsNameContext->pDfsTargetInfo) {
                PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo = DfsNameContext->pDfsTargetInfo;
#if 0
                DbgPrint("DFS TargetInfo is used %x\n",InTargetInfo);
                DbgPrint("TargeInfo TargetName %ws\n",InTargetInfo->TargetName);
                DbgPrint("TargeInfo NetbiosServerName %ws\n",InTargetInfo->NetbiosServerName);
                DbgPrint("TargeInfo DnsServerName %ws\n",InTargetInfo->DnsServerName);
                DbgPrint("TargeInfo NetbiosDomainName %ws\n",InTargetInfo->NetbiosDomainName);
                DbgPrint("TargeInfo DnsDomainName %ws\n",InTargetInfo->DnsDomainName);
                DbgPrint("TargeInfo DnsTreeName %ws\n",InTargetInfo->DnsTreeName);
                DbgPrint("TargeInfo CredTypes %ws\n",InTargetInfo->CredTypes);
                DbgPrint("TargeInfo TargetNameFlags %x\n",InTargetInfo->Flags);
                DbgPrint("TargeInfo CredTypeCount %x\n",InTargetInfo->CredTypeCount);
#endif
                Status = CredMarshalTargetInfo(
                             InTargetInfo,
                             &pSession->TargetInfoMarshalled,
                             &pSession->TargetInfoLength);

                if(!NT_SUCCESS(Status)) {
                    goto FINALLY;
                }
            } else if (DfsNameContext->pLMRTargetInfo){
                PLMR_QUERY_TARGET_INFO LmrTargetInfo = DfsNameContext->pLMRTargetInfo;
                
#if 0
                DbgPrint("LMR TargetInfo is used %x\n",LmrTargetInfo);
#endif

                pSession->TargetInfoMarshalled = RxAllocatePoolWithTag(PagedPool,
                                                                       LmrTargetInfo->BufferLength,
                                                                       MRXSMB_SESSION_POOLTAG);

                if (pSession->TargetInfoMarshalled == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto FINALLY;
                }

                pSession->TargetInfoLength = LmrTargetInfo->BufferLength;
                RtlCopyMemory(pSession->TargetInfoMarshalled,
                              LmrTargetInfo->TargetInfoMarshalled,
                              LmrTargetInfo->BufferLength);
            }
        }
    }

    TargetInfoMarshalled.Buffer = pSession->TargetInfoMarshalled;
    TargetInfoMarshalled.Length =
    TargetInfoMarshalled.MaximumLength = (USHORT)pSession->TargetInfoLength;

    Status = SecMakeSPNEx(
                    &CifsServiceName,
                    &ServerName,
                    NULL,
                    0,
                    NULL,
                    (pSession->TargetInfoMarshalled? &TargetInfoMarshalled : NULL),
                    &PrincipalName,
                    &SpnSize,
                    TRUE );
    

    pExtendedSessionSetupExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;
    pExtendedSession  = (PSMBCE_EXTENDED_SESSION)pSession;

    pResponseContext->KerberosSetup.pOutputContextBuffer = NULL;

    pServerPrincipalName = pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall->pPrincipalName;

    RxDbgTrace(0,Dbg,("KerberosResponsePrologue: Prinicpal name length %ld\n",PrincipalName.Length));
    
    
    if ( ( pExtendedSessionSetupExchange->pServerResponseBlob == NULL) &&
         ( !SecIsValidHandle( &pExtendedSession->SecurityContextHandle ) ) ) {
        // This is the first time. Pass in the BLOB obtained during NEGOTIATE to
        // the client side security package.

        ServerSecurityBlobSize = pServer->NtServer.SecurityBlobLength;
        pServerSecurityBlob    = pServer->NtServer.pSecurityBlob;
    } else {
        ServerSecurityBlobSize = pExtendedSessionSetupExchange->ServerResponseBlobLength;
        pServerSecurityBlob = pExtendedSessionSetupExchange->pServerResponseBlob;
    }
    
    try {

        if( !SecIsValidHandle( &pExtendedSession->CredentialHandle )) {
            // Obtain a credential handle
            UNICODE_STRING KerberosName;
            TimeStamp      LifeTime;

            ULONG_PTR                  CredentialBufferLength;
            PSEC_WINNT_AUTH_IDENTITY_EX pCredentialBuffer;

            PBYTE          pStringBuffer;

            // The supplied credentials need to be packaged for the kerberos package
            // These need to be supplied in a special format as speced out by the
            // security packages. 

            CredentialBufferLength = 0;
            pCredentialBuffer      = NULL;

            if(pSession->pUserName != NULL) {
                CredentialBufferLength += pSession->pUserName->Length + sizeof(WCHAR);
            }

            if (pSession->pUserDomainName != NULL) {
                CredentialBufferLength += pSession->pUserDomainName->Length + sizeof(WCHAR);
            }

            if(pSession->pPassword != NULL) {
                CredentialBufferLength += pSession->pPassword->Length + sizeof(WCHAR);
            }

            if (CredentialBufferLength != 0) {
                CredentialBufferLength += sizeof(SEC_WINNT_AUTH_IDENTITY_EX);

                pCredentialBuffer = ExAllocatePool( PagedPool, CredentialBufferLength );

                if ( pCredentialBuffer == NULL )
                {
                    Status = STATUS_NO_MEMORY ;
                    try_return( Status );
                    
                }

                //
                // Zero all the fixed length fields
                //

                RtlZeroMemory( pCredentialBuffer, sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) );

                pCredentialBuffer->Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
                pCredentialBuffer->Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EX );
                pCredentialBuffer->Flags = (SEC_WINNT_AUTH_IDENTITY_UNICODE |
                                            SEC_WINNT_AUTH_IDENTITY_MARSHALLED);

                pStringBuffer = (PBYTE) (pCredentialBuffer + 1);

                if (pSession->pUserName != NULL) {
                    pCredentialBuffer->UserLength = pSession->pUserName->Length / sizeof(WCHAR);
                    pCredentialBuffer->User       = (PWCHAR)pStringBuffer;

                    RtlCopyMemory(
                        pCredentialBuffer->User,
                        pSession->pUserName->Buffer,
                        pSession->pUserName->Length);

                    pStringBuffer += pSession->pUserName->Length;

                    SmbPutUshort(pStringBuffer,L'\0');
                    pStringBuffer += sizeof(WCHAR);
                }

                if (pSession->pUserDomainName != NULL) {
                    pCredentialBuffer->DomainLength = pSession->pUserDomainName->Length / sizeof(WCHAR);
                    pCredentialBuffer->Domain       = (PWCHAR)pStringBuffer;

                    RtlCopyMemory(
                        pCredentialBuffer->Domain,
                        pSession->pUserDomainName->Buffer,
                        pSession->pUserDomainName->Length);

                    pStringBuffer += pSession->pUserDomainName->Length;

                    SmbPutUshort(pStringBuffer,L'\0');
                    pStringBuffer += sizeof(WCHAR);
                }

                if (pSession->pPassword != NULL) {
                    pCredentialBuffer->PasswordLength = pSession->pPassword->Length / sizeof(WCHAR);
                    pCredentialBuffer->Password       = (PWCHAR)pStringBuffer;

                    RtlCopyMemory(
                        pCredentialBuffer->Password,
                        pSession->pPassword->Buffer,
                        pSession->pPassword->Length);

                    pStringBuffer += pSession->pPassword->Length;

                    SmbPutUshort(pStringBuffer, L'\0');
                    pStringBuffer += sizeof(WCHAR);
                }
            }

            RxDbgTrace(0,Dbg,("KerberosResponsePrologue: Acquiring Credential handle\n"));
            RtlInitUnicodeString(&KerberosName, NEGOSSP_NAME_W);

            SecStatus = AcquireCredentialsHandleW(
                            NULL,
                            &KerberosName,
                            SECPKG_CRED_OUTBOUND,
                            &pExtendedSession->LogonId,
                            pCredentialBuffer,
                            NULL,
                            NULL,
                            &pExtendedSession->CredentialHandle,
                            &LifeTime);

            Status = MapSecurityError( SecStatus );

            if ( pCredentialBuffer )
            {
                ExFreePool( pCredentialBuffer );
                pCredentialBuffer = NULL ;
                
            }

            if(!NT_SUCCESS(Status)) {

                SecInvalidateHandle( &pExtendedSession->CredentialHandle );

                SmbLogError(Status,
                            LOG,
                            BuildExtendedSessionSetupResponsePrologue_1,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));
                try_return(Status);
            }
        }
        
        if (SecIsValidHandle( &pExtendedSession->SecurityContextHandle) ) {
            pInputContextHandle = &pExtendedSession->SecurityContextHandle;
        }

        InputToken.pBuffers    = &InputBuffer;
        InputToken.cBuffers    = 1;
        InputToken.ulVersion   = 0;
        InputBuffer.pvBuffer   = pServerSecurityBlob;
        InputBuffer.cbBuffer   = ServerSecurityBlobSize;
        InputBuffer.BufferType = SECBUFFER_TOKEN;
        
        RxDbgTrace(0,Dbg,("ExtendedSessionSetupResponsePrologue: Finished setting up input token\n"));

        OutputBuffer.pvBuffer   = pSecurityBlobPtr ;
        OutputBuffer.cbBuffer   = SmbCeGetExchangeServer( pExchange )->MaximumBufferSize ;
        OutputBuffer.cbBuffer  -= (sizeof( REQ_SESSION_SETUP_ANDX ) + sizeof( SMB_HEADER ) + 0x80 );

        ASSERT( OutputBuffer.cbBuffer <= *pSecurityBlobSize );

        OutputBuffer.BufferType = SECBUFFER_TOKEN;
        OutputBufferSize = OutputBuffer.cbBuffer;

        OutputToken.pBuffers    = &OutputBuffer;
        OutputToken.cBuffers    = 1;
        OutputToken.ulVersion   = SECBUFFER_VERSION ;

        if (MRxSmbSecuritySignaturesEnabled) {
            LsaFlags |= ISC_REQ_INTEGRITY;
        }

        RxDbgTrace(0,Dbg,("ExtendedSessionSetupResponsePrologue: Finished setting up output token\n"));

        SecStatus = InitializeSecurityContextW(
                        &pExtendedSession->CredentialHandle,
                        pInputContextHandle,
                        &PrincipalName,
                        LsaFlags,
                        0,                     // reserved
                        SECURITY_NATIVE_DREP,
                        &InputToken,
                        0,                     // reserved
                        &pExtendedSession->SecurityContextHandle,
                        &OutputToken,
                        &Catts,
                        &Expiry);

        Status = MapSecurityError( SecStatus );

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            PUCHAR pValidate = (PUCHAR) OutputBuffer.pvBuffer ;
            ASSERT( (pValidate[0] != 0) ||
                    (pValidate[1] != 0) ||
                    (pValidate[2] != 0) ||
                    (pValidate[3] != 0) );
        }
    }
#endif

        if((Status != STATUS_SUCCESS) &&
           (SecStatus != SEC_I_COMPLETE_NEEDED) &&
           (SecStatus != SEC_I_CONTINUE_NEEDED)) {

            SmbLogError(Status,
                        LOG,
                        BuildExtendedSessionSetupResponsePrologue_2,
                        LOGPTR(pSession)
                        LOGULONG(Status)
                        LOGUSTR(ServerName));
            
            try_return(Status);
        }

        if ((SecStatus == SEC_I_COMPLETE_NEEDED) ||
            (SecStatus == SEC_I_CONTINUE_NEEDED)) {
            Status = STATUS_SUCCESS;
        }

        if (SecStatus == STATUS_SUCCESS) {
            SecPkgContext_SessionKey SecKeys;

            SecStatus = QueryContextAttributesW(
                            &pExtendedSession->SecurityContextHandle,
                            SECPKG_ATTR_SESSION_KEY,
                            &SecKeys);

            Status = MapSecurityError( SecStatus );

            if (Status == STATUS_SUCCESS) {
                ULONG SessionKeyLength = (MSV1_0_USER_SESSION_KEY_LENGTH >
                                          SecKeys.SessionKeyLength) ?
                                          MSV1_0_USER_SESSION_KEY_LENGTH :
                                          SecKeys.SessionKeyLength;
                RtlZeroMemory(
                    (PVOID) pSession->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    (PVOID) pSession->UserSessionKey,
                    SecKeys.SessionKey,
                    SessionKeyLength);

                pSession->SessionKeyLength = SessionKeyLength;

                if (SecKeys.SessionKey != NULL) {
                    FreeContextBuffer( SecKeys.SessionKey );
                }

            } else {
                SmbLogError(Status,
                            LOG,
                            BuildExtendedSessionSetupResponsePrologue_3,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));
            }

        }

        RxDbgTrace(0,Dbg,("ExtendedSessionSetupResponsePrologue: Initialize security context successful\n"));

        *pSecurityBlobSize = (USHORT)OutputBuffer.cbBuffer;


try_exit:NOTHING;
    } finally {
        NOTHING ;
    }

FINALLY:

    if(bTempServerName == TRUE) {
        RxFreePool(ServerName.Buffer);
    }

    if ( PrincipalName.Buffer )
    {
        ExFreePool( PrincipalName.Buffer );
    }

    if ((Status != STATUS_SUCCESS) &&
        (Status != STATUS_WRONG_PASSWORD) &&
        (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
        /*
        if (!pServer->EventLogPosted) {
            RxLogFailure(
                MRxSmbDeviceObject,
                NULL,
                EVENT_RDR_CANT_GET_SECURITY_CONTEXT,
                Status);

            pServer->EventLogPosted = TRUE;
        } */

        SmbCeLog(("KerbProlg %lx Status %lx\n",SmbCeGetExchangeSessionEntry(pExchange),Status));
        SmbLogError(Status,
                    LOG,
                    BuildExtendedSessionSetupResponsePrologue,
                    LOGPTR(pSession)
                    LOGULONG(Status));
    }
    
    return Status;
}

NTSTATUS
BuildExtendedSessionSetupResponseEpilogue(
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
{
    ULONG_PTR Zero = 0 ;
    PAGED_CODE();


    return STATUS_SUCCESS;
}

NTSTATUS
ValidateServerExtendedSessionSetupResponse(
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtendedSessionSetupExchange,
    PVOID                                pServerResponseBlob,
    ULONG                                ServerResponseBlobLength)

/*++

Routine Description:

   This routine builds the security related information for the session setup SMB to
   a server with extended security negotiation

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS        Status;
    SECURITY_STATUS SecStatus;

    ULONG           Catts = 0;
    TimeStamp       Expiry;

    ULONG           LsaFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_ALLOCATE_MEMORY;

    UNICODE_STRING  PrincipalName;
    PUNICODE_STRING pServerPrincipalName;

    PUCHAR          pTempBlob = NULL;

    PSMBCE_SERVER   pServer  = SmbCeGetExchangeServer(pExtendedSessionSetupExchange);
    PSMBCE_SESSION  pSession = SmbCeGetExchangeSession(pExtendedSessionSetupExchange);
    
    UNICODE_STRING  ServerName;
    PUNICODE_STRING pServerDomainName;

    PSMBCE_EXTENDED_SESSION pExtendedSession;

    SecBufferDesc   InputToken;
    SecBuffer       InputBuffer;
    SecBufferDesc   OutputToken;
    SecBuffer       OutputBuffer;

    SecPkgContext_SessionKey SecKeys;

    KAPC_STATE     ApcState;
    BOOLEAN        AttachToSystemProcess = FALSE;

    PAGED_CODE();

    ASSERT((pExtendedSessionSetupExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) &&
           (pSession->Type  == EXTENDED_NT_SESSION));


    SecKeys.SessionKey = NULL;

    pExtendedSession  = (PSMBCE_EXTENDED_SESSION)pSession;

    if (pExtendedSession == NULL ||
        !SecIsValidHandle(&pExtendedSession->CredentialHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    SmbCeGetServerName(
        pExtendedSessionSetupExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,&ServerName);



    try {


        RxDbgTrace(0,Dbg,("ValidateServerResponse: Blob Length %ld\n",pExtendedSessionSetupExchange->ServerResponseBlobLength));

        InputToken.pBuffers    = &InputBuffer;
        InputToken.cBuffers    = 1;
        InputToken.ulVersion   = 0;
        InputBuffer.pvBuffer   = pServerResponseBlob ;
        InputBuffer.cbBuffer   = pExtendedSessionSetupExchange->ServerResponseBlobLength;
        InputBuffer.BufferType = SECBUFFER_TOKEN;

        RxDbgTrace(0,Dbg,("ValidateKerberosServerResponse: filled in input token\n"));

        OutputToken.pBuffers    = &OutputBuffer;
        OutputToken.cBuffers    = 1;
        OutputToken.ulVersion   = 0;
        OutputBuffer.pvBuffer   = NULL;
        OutputBuffer.cbBuffer   = 0;
        OutputBuffer.BufferType = SECBUFFER_TOKEN;

        RxDbgTrace(0,Dbg,("ValidateKerberosServerResponse: filled in output token\n"));

        SecStatus = InitializeSecurityContextW(
                        &pExtendedSession->CredentialHandle,
                        &pExtendedSession->SecurityContextHandle,
                        NULL,
                        LsaFlags,
                        0,                     // reserved
                        SECURITY_NATIVE_DREP,
                        &InputToken,
                        0,                     // reserved
                        &pExtendedSession->SecurityContextHandle,
                        &OutputToken,
                        &Catts,
                        &Expiry);

        Status = MapSecurityError( SecStatus );

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            ASSERT( NT_SUCCESS( KSecValidateBuffer( OutputBuffer.pvBuffer, OutputBuffer.cbBuffer ) ) );
        }
    }
#endif

        if((Status != STATUS_SUCCESS) &&
           (SecStatus != SEC_I_COMPLETE_NEEDED) &&
           (SecStatus != SEC_I_CONTINUE_NEEDED)) {
            SmbLogError(Status,
                        LOG,
                        ValidateServerExtendedSessionSetupResponse_1,
                        LOGPTR(pSession)
                        LOGULONG(Status)
                        LOGUSTR(ServerName));
            try_return(Status);
        }

        if ((SecStatus == SEC_I_COMPLETE_NEEDED) ||
            (SecStatus == SEC_I_CONTINUE_NEEDED)) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            SecStatus = QueryContextAttributesW(
                            &pExtendedSession->SecurityContextHandle,
                            SECPKG_ATTR_SESSION_KEY,
                            &SecKeys);

            Status = MapSecurityError( SecStatus );

            if (Status == STATUS_SUCCESS) {
                ULONG SessionKeyLength = (MSV1_0_USER_SESSION_KEY_LENGTH >
                                          SecKeys.SessionKeyLength) ?
                                          MSV1_0_USER_SESSION_KEY_LENGTH :
                                          SecKeys.SessionKeyLength;
                RtlZeroMemory(
                    (PVOID) pSession->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    (PVOID) pSession->UserSessionKey,
                    SecKeys.SessionKey,
                    SessionKeyLength);

                pSession->SessionKeyLength = SessionKeyLength;
            } else {
                SmbLogError(Status,
                            LOG,
                            ValidateServerExtendedSessionSetupResponse_2,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));
            }

            if (SecKeys.SessionKey != NULL) {
                FreeContextBuffer( SecKeys.SessionKey );
            }
        }

        RxDbgTrace(0,Dbg,("ValidateKerberosServerResponse: SecuritContext returned %ld\n",Status));

        if (OutputBuffer.pvBuffer != NULL) {
            FreeContextBuffer(OutputBuffer.pvBuffer);
        }

try_exit:NOTHING;
    } finally {

        NOTHING ;
    }

    if ((Status != STATUS_SUCCESS) &&
        (Status != STATUS_WRONG_PASSWORD) &&
        (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
        /*
        if (!pServer->EventLogPosted) {
            RxLogFailure(
                MRxSmbDeviceObject,
                NULL,
                EVENT_RDR_CANT_GET_SECURITY_CONTEXT,
                Status);

            pServer->EventLogPosted = TRUE;
        } */

        SmbCeLog((
            "ValServer %lx Status %lx\n",
            SmbCeGetExchangeSessionEntry(
                (PSMB_EXCHANGE)pExtendedSessionSetupExchange),
            Status));
        SmbLogError(Status,
                    LOG,
                    ValidateServerExtendedSessionSetupResponse,
                    LOGPTR(pSession)
                    LOGULONG(Status));
    }


    return Status;
}

VOID
UninitializeSecurityContextsForSession(
    PSMBCE_SESSION pSession)
{
    CtxtHandle CredentialHandle,SecurityContextHandle ;

    SmbCeLog(("UninitSecCont %lx\n",pSession));
    SmbLog(LOG,
           UninitializeSecurityContextsForSession,
           LOGPTR(pSession));


    SmbCeAcquireSpinLock();

    CredentialHandle = pSession->CredentialHandle;
    SecInvalidateHandle( &pSession->CredentialHandle );

    SecurityContextHandle = pSession->SecurityContextHandle;
    SecInvalidateHandle( &pSession->SecurityContextHandle );

    SmbCeReleaseSpinLock();

    if (SecIsValidHandle(&CredentialHandle)) {
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
            MRxSmbUseKernelModeSecurity) {
            FreeCredentialsHandleK(&CredentialHandle);
        } else {
            FreeCredentialsHandle(&CredentialHandle);
        }
    }

    if (SecIsValidHandle(&SecurityContextHandle)) {
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
            MRxSmbUseKernelModeSecurity) {
            DeleteSecurityContextK(&SecurityContextHandle);
        } else {
            DeleteSecurityContext(&SecurityContextHandle);
        }
    }
}

VOID
DeleteSecurityContextForSession(
    PSMBCE_SESSION pSession)
{
    CtxtHandle SecurityContextHandle ;

    SmbCeLog(("DelSecContext %lx\n",pSession));
    SmbLog(LOG,
           DeleteSecurityContextForSession,
           LOGPTR(pSession));

    SmbCeAcquireSpinLock();

    SecurityContextHandle = pSession->SecurityContextHandle;
    SecInvalidateHandle( &pSession->SecurityContextHandle);

    SmbCeReleaseSpinLock();

    if (SecIsValidHandle(&SecurityContextHandle)) {
        if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
            MRxSmbUseKernelModeSecurity) {
            DeleteSecurityContextK(&SecurityContextHandle);
        } else {
            DeleteSecurityContext(&SecurityContextHandle);
        }
    }
}


NTSTATUS
BuildExtendedSessionSetupResponsePrologueFake(
    PSMB_EXCHANGE              pExchange)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB to
   a NT server with extended security

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

    This routine needs to be executed in the system process in order to protect virtual memory

--*/
{
    NTSTATUS        Status;
    SECURITY_STATUS SecStatus;

    TimeStamp       Expiry;
    ULONG           Catts = ISC_RET_MUTUAL_AUTH;
    ULONG           LsaFlags = (ISC_REQ_DELEGATE |
                                ISC_REQ_MUTUAL_AUTH |
                                ISC_REQ_FRAGMENT_TO_FIT);
    
    ULONG_PTR       RegionSize = 0;
    ULONG_PTR       OutputBufferSize;

    UNICODE_STRING  PrincipalName;
    PUNICODE_STRING pServerPrincipalName;

    PVOID           pServerSecurityBlob;
    ULONG           ServerSecurityBlobSize;

    PSMBCE_SERVER   pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION  pSession = SmbCeGetExchangeSession(pExchange);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    
    UNICODE_STRING  ServerName;
    PUNICODE_STRING pServerDomainName;

    SMBCE_EXTENDED_SESSION ExtendedSession;

    SecBufferDesc   InputToken;
    SecBuffer       InputBuffer = { 0 };
    SecBufferDesc   OutputToken;
    SecBuffer       OutputBuffer = { 0 };

    PCtxtHandle     pInputContextHandle = NULL;

    SecPkgContext_NegotiationInfoW NegInfo = { 0 };

    PAGED_CODE();

    SmbCeGetServerName(
        pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,
        &ServerName);

    ASSERT(ServerName.MaximumLength > (ServerName.Length + sizeof(WCHAR)));

    ExtendedSession.Flags = pSession->Flags;
    ExtendedSession.LogonId = pSession->LogonId;
    SecInvalidateHandle( &ExtendedSession.CredentialHandle );
    SecInvalidateHandle( &ExtendedSession.SecurityContextHandle );
    
    pServerPrincipalName = pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall->pPrincipalName;


    ServerSecurityBlobSize = 0;  //there is no security blob in case of NTLM
    pServerSecurityBlob    = NULL;
    
    try {
        UNICODE_STRING KerberosName;
        TimeStamp      LifeTime;

        ULONG_PTR                  CredentialBufferLength;
        PSEC_WINNT_AUTH_IDENTITY_EXW pCredentialBuffer;

        PBYTE          pStringBuffer;

        

        CredentialBufferLength = 0;
        pCredentialBuffer      = NULL;

        if(pSession->pUserName != NULL) {
            CredentialBufferLength += pSession->pUserName->Length + sizeof(WCHAR);
        }

        if (pSession->pUserDomainName != NULL) {
            CredentialBufferLength += pSession->pUserDomainName->Length + sizeof(WCHAR);
        }

        if(pSession->pPassword != NULL) {
            CredentialBufferLength += pSession->pPassword->Length + sizeof(WCHAR);
        }

        if (CredentialBufferLength != 0) {

            CredentialBufferLength += sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);

            pCredentialBuffer = (PSEC_WINNT_AUTH_IDENTITY_EXW) ExAllocatePool( 
                                                                PagedPool, 
                                                                CredentialBufferLength );

            if ( !pCredentialBuffer )
            {
                Status = STATUS_NO_MEMORY ;
                try_return( Status );
                
            }
            //
            // Zero the fixed portion
            //
            RtlZeroMemory( pCredentialBuffer, sizeof( SEC_WINNT_AUTH_IDENTITY_EXW ));

            pCredentialBuffer->Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
            pCredentialBuffer->Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EXW );
            pCredentialBuffer->Flags = (SEC_WINNT_AUTH_IDENTITY_UNICODE |
                                        SEC_WINNT_AUTH_IDENTITY_MARSHALLED);


            pStringBuffer = (PBYTE)( pCredentialBuffer + 1 );

            if (pSession->pUserName != NULL) {
                pCredentialBuffer->UserLength = pSession->pUserName->Length / sizeof(WCHAR);
                pCredentialBuffer->User       = (PWCHAR)pStringBuffer;

                RtlCopyMemory(
                    pCredentialBuffer->User,
                    pSession->pUserName->Buffer,
                    pSession->pUserName->Length);

                pStringBuffer += pSession->pUserName->Length;

                SmbPutUshort(pStringBuffer,L'\0');
                pStringBuffer += sizeof(WCHAR);
            }

            if (pSession->pUserDomainName != NULL) {
                pCredentialBuffer->DomainLength = pSession->pUserDomainName->Length / sizeof(WCHAR);
                pCredentialBuffer->Domain       = (PWCHAR)pStringBuffer;

                RtlCopyMemory(
                    pCredentialBuffer->Domain,
                    pSession->pUserDomainName->Buffer,
                    pSession->pUserDomainName->Length);

                pStringBuffer += pSession->pUserDomainName->Length;

                SmbPutUshort(pStringBuffer,L'\0');
                pStringBuffer += sizeof(WCHAR);
            }

            if (pSession->pPassword != NULL) {
                pCredentialBuffer->PasswordLength = pSession->pPassword->Length / sizeof(WCHAR);
                pCredentialBuffer->Password       = (PWCHAR)pStringBuffer;

                RtlCopyMemory(
                    pCredentialBuffer->Password,
                    pSession->pPassword->Buffer,
                    pSession->pPassword->Length);

                pStringBuffer += pSession->pPassword->Length;

                SmbPutUshort(pStringBuffer, L'\0');
                pStringBuffer += sizeof(WCHAR);
            }
        }

        RxDbgTrace(0,Dbg,("KerberosResponsePrologue: Acquiring Credential handle\n"));
        RtlInitUnicodeString(&KerberosName, NEGOSSP_NAME_W);

        SecStatus = AcquireCredentialsHandleW(
                        NULL,
                        &KerberosName,
                        SECPKG_CRED_OUTBOUND,
                        &ExtendedSession.LogonId,
                        pCredentialBuffer,
                        NULL,
                        NULL,
                        &ExtendedSession.CredentialHandle,
                        &LifeTime);

        Status = MapSecurityError( SecStatus );

        if (pCredentialBuffer != NULL) {

            ExFreePool( pCredentialBuffer );
        }

        if(!NT_SUCCESS(Status)) {
            SecInvalidateHandle( &ExtendedSession.CredentialHandle );
            SmbLogError(Status,
                        LOG,
                        BuildExtendedSessionSetupResponsePrologueFake_1,
                        LOGPTR(pSession)
                        LOGULONG(Status)
                        LOGUSTR(ServerName));
            try_return(Status);
        }
        

        Status = SecMakeSPN(
                    &CifsServiceName,
                    &ServerName,
                    NULL,
                    0,
                    NULL,
                    &PrincipalName,
                    NULL,
                    TRUE );


        InputToken.pBuffers    = &InputBuffer;
        InputToken.cBuffers    = 1;
        InputToken.ulVersion   = 0;
        InputBuffer.pvBuffer   = pServerSecurityBlob;
        InputBuffer.cbBuffer   = ServerSecurityBlobSize;
        InputBuffer.BufferType = SECBUFFER_TOKEN;

        OutputBuffer.pvBuffer   = NULL;
        OutputBuffer.cbBuffer   = SmbCeGetExchangeServer( pExchange )->MaximumBufferSize;
        OutputBuffer.cbBuffer  -= (sizeof( REQ_SESSION_SETUP_ANDX ) + sizeof( SMB_HEADER ) + 0x80 );
        OutputBuffer.BufferType = SECBUFFER_TOKEN;
        OutputBufferSize = OutputBuffer.cbBuffer;

        OutputBuffer.pvBuffer = ExAllocatePool( PagedPool, OutputBufferSize );

        if ( OutputBuffer.pvBuffer == NULL )
        {
            Status = STATUS_NO_MEMORY ;
            try_return( Status );
            
        }

        OutputToken.pBuffers    = &OutputBuffer;
        OutputToken.cBuffers    = 1;
        OutputToken.ulVersion   = SECBUFFER_VERSION ;

        if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) 
        {
            LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }   

        SecStatus = InitializeSecurityContextW(
                        &ExtendedSession.CredentialHandle,
                        pInputContextHandle,
                        &PrincipalName,
                        LsaFlags,
                        0,                     // reserved
                        SECURITY_NATIVE_DREP,
                        &InputToken,
                        0,                     // reserved
                        &ExtendedSession.SecurityContextHandle,
                        &OutputToken,
                        &Catts,
                        &Expiry);

        Status = MapSecurityError( SecStatus );

#if DBG

    //
    // RDR or SRV is sending in a corrupt security blob to LSA -- need to
    // find out what the source is.
    //

    if( NT_SUCCESS(Status) )
    {
        if( (OutputBuffer.pvBuffer != NULL) &&
            (OutputBuffer.cbBuffer >= sizeof(DWORD))
            )
        {
            ASSERT( NT_SUCCESS( KSecValidateBuffer( OutputBuffer.pvBuffer, OutputBuffer.cbBuffer ) ) );
        }
    }
#endif

        if((Status != STATUS_SUCCESS) &&
           (SecStatus != SEC_I_COMPLETE_NEEDED) &&
           (SecStatus != SEC_I_CONTINUE_NEEDED)) {

            RxLog(("ISC returned %lx\n",Status));
            SmbLogError(Status,
                        LOG,
                        BuildExtendedSessionSetupResponsePrologueFake_2,
                        LOGPTR(pSession)
                        LOGULONG(Status)
                        LOGUSTR(ServerName));
            try_return(Status);
        }

        SecStatus = QueryContextAttributesW(
                        &ExtendedSession.SecurityContextHandle,
                        SECPKG_ATTR_NEGOTIATION_INFO,
                        &NegInfo);

        Status = MapSecurityError( SecStatus );

        if (Status != STATUS_SUCCESS) {
            RxLog(("QCA returned %lx\n",Status));
            SmbLogError(Status,
                        LOG,
                        BuildExtendedSessionSetupResponsePrologueFake_3,
                        LOGPTR(pSession)
                        LOGULONG(Status)
                        LOGUSTR(ServerName));
        } 

try_exit:NOTHING;
    } finally {
        if (Status == STATUS_SUCCESS) {

            if (NegInfo.PackageInfo->wRPCID != NTLMSP_RPCID) {
                Status = STATUS_LOGIN_WKSTA_RESTRICTION;

                //RxLogFailure(
                //    MRxSmbDeviceObject,
                //    NULL,
                //    EVENT_RDR_ENCOUNTER_DOWNGRADE_ATTACK,
                //    Status);

                RxLog(("NTLM downgrade attack from %wZ\n",&pServerEntry->Name));
#if DBG
                DbgPrint("NTLM downgrade attack from %wZ\n",&pServerEntry->Name);
#endif 
                SmbLogError(Status,
                            LOG,
                            BuildExtendedSessionSetupResponsePrologueFake_4,
                            LOGPTR(pSession)
                            LOGULONG(Status)
                            LOGUSTR(ServerName));
            }
        }

        UninitializeSecurityContextsForSession((PSMBCE_SESSION)(&ExtendedSession));
          
        if ( NegInfo.PackageInfo != NULL) {
            FreeContextBuffer(NegInfo.PackageInfo);
        }

        if (OutputBuffer.pvBuffer != NULL) {
            ExFreePool( OutputBuffer.pvBuffer );
        }
        

        SmbLogError(Status,
                    LOG,
                    BuildExtendedSessionSetupResponsePrologueFake,
                    LOGPTR(pSession)
                    LOGULONG(Status));
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\recursvc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recursvc.h

Abstract:



Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:


Notes:

    Refer to recursvc.c

--*/

#ifndef _RECURSVC_H_
#define _RECURSVC_H_

extern NTSTATUS
MRxSmbInitializeRecurrentServices();

extern VOID
MRxSmbTearDownRecurrentServices();


#define RECURRENT_SERVICE_CANCELLED (0xcccccccc)
#define RECURRENT_SERVICE_ACTIVE    (0xaaaaaaaa)
#define RECURRENT_SERVICE_DORMANT   (0xdddddddd)
#define RECURRENT_SERVICE_SHUTDOWN  (0xffffffff)

typedef
NTSTATUS
(NTAPI *PRECURRENT_SERVICE_ROUTINE) (
    IN PVOID Context
    );

typedef struct _RECURRENT_SERVICE_CONTEXT_ {
    LONG           State;
    NTSTATUS       Status;
    LARGE_INTEGER  Interval;
    RX_WORK_ITEM   WorkItem;
    KEVENT         CancelCompletionEvent;
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine;
    PVOID          pServiceRoutineParameter;
} RECURRENT_SERVICE_CONTEXT, *PRECURRENT_SERVICE_CONTEXT;

extern VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval);

extern VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

extern NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

typedef struct _MRXSMB_ECHO_PROBE_SERVICE_CONTEXT_ {
    RECURRENT_SERVICE_CONTEXT RecurrentServiceContext;

    PVOID  pEchoSmb;
    ULONG  EchoSmbLength;
} MRXSMB_ECHO_PROBE_SERVICE_CONTEXT, *PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT;

extern MRXSMB_ECHO_PROBE_SERVICE_CONTEXT MRxSmbEchoProbeServiceContext;

extern NTSTATUS
SmbCeProbeServers(
    PVOID    pContext);

extern NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProcessingContext);

extern VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProcessingContext);

typedef struct _MRXSMB_SCAVENGER_SERVICE_CONTEXT_ {
    RECURRENT_SERVICE_CONTEXT RecurrentServiceContext;

    SMBCE_V_NET_ROOT_CONTEXTS VNetRootContexts;
} MRXSMB_SCAVENGER_SERVICE_CONTEXT, *PMRXSMB_SCAVENGER_SERVICE_CONTEXT;

extern MRXSMB_SCAVENGER_SERVICE_CONTEXT  MRxSmbScavengerServiceContext;

extern NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

extern VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

extern NTSTATUS
SmbCeScavenger(
    PVOID pContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smb64.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smb64.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to thunking structures for SMB to put them on the wire

Revision History:

    David Kruse     [DKruse]    30-November 2000

--*/

#ifndef _SMB64
#define _SMB64

// Need to thunk RenameInfo before hitting the wire                            
typedef struct _FILE_RENAME_INFORMATION32 {
    BOOLEAN ReplaceIfExists;
    ULONG RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION32, *PFILE_RENAME_INFORMATION32;

// For link tracking code thunking
typedef struct _REMOTE_LINK_TRACKING_INFORMATION32_ {
    ULONG       TargetFileObject;
    ULONG   TargetLinkTrackingInformationLength;
    UCHAR   TargetLinkTrackingInformationBuffer[1];
} REMOTE_LINK_TRACKING_INFORMATION32,
 *PREMOTE_LINK_TRACKING_INFORMATION32;

#ifdef _WIN64

PBYTE
Smb64ThunkFileRenameInfo(
    IN PFILE_RENAME_INFORMATION pRenameInfo,
    IN OUT PULONG BufferSize,
    OUT NTSTATUS *pStatus
    );

PBYTE
Smb64ThunkRemoteLinkTrackingInfo(
    IN PBYTE pRemoteTrackingInfo,
    IN OUT PULONG BufferSize,
    OUT NTSTATUS* pStatus
    );

#define Smb64ReleaseThunkData(X) if( X ) RxFreePool( X );



#endif // _WIN64
#endif // _SMB64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smb64.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smb64.c

Abstract:

    This module implements thunking needed for the SMB MiniRDR

Author:

    David Kruse           [DKruse]      30-November 2000

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


PBYTE
Smb64ThunkFileRenameInfo(
    IN PFILE_RENAME_INFORMATION pRenameInfo,
    IN OUT PULONG pBufferSize,
    OUT NTSTATUS* pStatus
    );

PBYTE
Smb64ThunkRemoteLinkTrackingInfo(
    IN PBYTE pData,
    IN OUT PULONG BufferSize,
    OUT NTSTATUS* pStatus
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, Smb64ThunkFileRenameInfo)
#pragma alloc_text(PAGE, Smb64ThunkRemoteLinkTrackingInfo)
#endif

PBYTE
Smb64ThunkFileRenameInfo(
    IN PFILE_RENAME_INFORMATION pRenameInfo,
    IN OUT PULONG pBufferSize,
    OUT NTSTATUS* pStatus
    )
/*++

Routine Description:

    This routine thunks the FILE_RENAME_INFORMATION structure IN PLACE.  This means that the
    original buffer will no longer be intact after this call!  (However, it requires no memory
    allocation either)
    
Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Remoting of FSCTL's is permitted only to NT servers.

--*/
{
    PFILE_RENAME_INFORMATION32 pRenameInfo32;

    // Allocate the new buffer
    pRenameInfo32 = RxAllocatePoolWithTag( NonPagedPool, *pBufferSize, MRXSMB_MISC_POOLTAG );
    if( !pRenameInfo32 )
    {
        *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        return NULL;
    }

    // Copy the data into the new buffer
    pRenameInfo32->ReplaceIfExists = pRenameInfo->ReplaceIfExists;
    pRenameInfo32->RootDirectory = *((PULONG)&pRenameInfo->RootDirectory);
    pRenameInfo32->FileNameLength = pRenameInfo->FileNameLength;
    RtlCopyMemory( &pRenameInfo32->FileName, &pRenameInfo->FileName, pRenameInfo->FileNameLength );

    // Succeeded.  Return
    *pStatus = STATUS_SUCCESS;
    return (PBYTE)pRenameInfo32;
}

PBYTE
Smb64ThunkRemoteLinkTrackingInfo(
    IN PBYTE pData,
    IN OUT PULONG BufferSize,
    OUT NTSTATUS* pStatus
    )
/*++

Routine Description:

    This routine handles all the FSCTL's

Arguments:

    RxContext          - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Remoting of FSCTL's is permitted only to NT servers.

--*/
{
    PREMOTE_LINK_TRACKING_INFORMATION pRemoteLink = (PREMOTE_LINK_TRACKING_INFORMATION)pData;
    PREMOTE_LINK_TRACKING_INFORMATION32 pRemoteLink32;

    // Allocate the new buffer
    pRemoteLink32 = RxAllocatePoolWithTag( NonPagedPool, *BufferSize, MRXSMB_MISC_POOLTAG );
    if( !pRemoteLink32 )
    {
        *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        return NULL;
    }

    // Copy the data into the new buffer
    pRemoteLink32->TargetFileObject = *((PULONG)&pRemoteLink->TargetFileObject);
    pRemoteLink32->TargetLinkTrackingInformationLength = pRemoteLink->TargetLinkTrackingInformationLength;
    RtlCopyMemory( &pRemoteLink32->TargetLinkTrackingInformationBuffer, 
                   &pRemoteLink->TargetLinkTrackingInformationBuffer,
                   pRemoteLink->TargetLinkTrackingInformationLength );

    // Succeeded.  Return
    *pStatus = STATUS_SUCCESS;
    return (PBYTE)pRemoteLink32;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbadmin.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbadmin.h

Abstract:

    This module implements the SMB's that need to be exchanged to facilitate
    bookkeeping at the server

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:


Notes;

    In the normal course of events a TreeId/UserId which translates into a Share/Session instance
    is required to send a SMB to the server. In terms of the local data structures it translates
    to a SMBCEDB_SERVER_ENTRY/SMBCEDB_SESSION_ENTRY/SMBCEDB_NET_ROOT_ENTRY. However, there are a
    few exceptions to this rule in which one or more of the fields in not required. These are
    normally used during connection establishment/connection tear down and connection state
    maintenance.

    All these SMB's have been grouped together in the implementation of SMB_ADMIN_EXCHANGE which
    is derived from SMB_EXCHANGE. All NEGOTIATE,LOG_OFF,DISCONNECT and ECHO SMB are sent
    using this type of exchange. The important factor that distinguishes the SMB_ADMIN_EXCHANGE
    from regular exchanges is the way the state of the exchange is manipulated to take into
    account the specialized requirements of each of the above mentioned commands.

--*/

#ifndef _SMBADMIN_H_
#define _SMBADMIN_H_

#include <smbxchng.h>

typedef struct _SMB_ADMIN_EXCHANGE_ {
    SMB_EXCHANGE;

    ULONG                     SmbBufferLength;
    PVOID                     pSmbBuffer;
    PMDL              pSmbMdl;
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext;

    union {
        struct {
            PMRX_SRV_CALL  pSrvCall;
            UNICODE_STRING DomainName;
            PMDL           pSecurityBlobMdl;
        } Negotiate;

        struct {
            UCHAR DisconnectSmb[TRANSPORT_HEADER_SIZE +
                               sizeof(SMB_HEADER) +
                               sizeof(REQ_TREE_DISCONNECT)];
        } Disconnect;

        struct {
            UCHAR LogOffSmb[TRANSPORT_HEADER_SIZE +
                           sizeof(SMB_HEADER) +
                           sizeof(REQ_LOGOFF_ANDX)];
        } LogOff;

        struct {
            PMDL  pEchoProbeMdl;
            ULONG EchoProbeLength;
        } EchoProbe;
    };
} SMB_ADMIN_EXCHANGE, *PSMB_ADMIN_EXCHANGE;

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern SMB_EXCHANGE_DISPATCH_VECTOR AdminExchangeDispatch;

extern NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall,
    BOOLEAN               RemoteBootSession);

extern NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pNetRootEntry);

extern NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY  pServerEntry,
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);


#endif // _SMBADMIN_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbadmin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbadmin.c

Abstract:

    This module implements the SMB's that need to be exchanged to facilitate
    bookkeeping at the server

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeNegotiate)
#pragma alloc_text(PAGE, SmbCeDisconnect)
#pragma alloc_text(PAGE, SmbCeLogOff)
#pragma alloc_text(PAGE, SmbCeInitializeAdminExchange)
#pragma alloc_text(PAGE, SmbCeDiscardAdminExchange)
#pragma alloc_text(PAGE, SmbCeCompleteAdminExchange)
#pragma alloc_text(PAGE, SmbAdminExchangeStart)
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

extern
SMB_EXCHANGE_DISPATCH_VECTOR EchoExchangeDispatch;

extern NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand);

extern VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange);

extern NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange);

VOID
SmbReferenceRecord(
    PREFERENCE_RECORD pReferenceRecord,
    PVOID FileName,
    ULONG FileLine)
{
    int i;

    for (i=REFERENCE_RECORD_SIZE-1;i>0;i--) {
         pReferenceRecord[i].FileName = pReferenceRecord[i-1].FileName;
         pReferenceRecord[i].FileLine = pReferenceRecord[i-1].FileLine;
    }

    pReferenceRecord[0].FileName = FileName;
    pReferenceRecord[0].FileLine = FileLine;
}

PSMB_EXCHANGE
SmbSetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_ADMIN_EXCHANGE   pSmbAdminExchange)
{
    PSMB_EXCHANGE pStoredExchange;

    SmbCeIncrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);

    pStoredExchange = InterlockedCompareExchangePointer(
                          &pServerEntry->pNegotiateExchange,
                          pSmbAdminExchange,
                          NULL);

    if (pStoredExchange != NULL) {
        SmbCeDecrementPendingLocalOperationsAndFinalize((PSMB_EXCHANGE)pSmbAdminExchange);
    }

    return pStoredExchange;
}

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    PSMB_EXCHANGE pStoredExchange;

    pStoredExchange = (PSMB_EXCHANGE)InterlockedCompareExchangePointer(
                                         &pServerEntry->pNegotiateExchange,
                                         NULL,
                                         pServerEntry->pNegotiateExchange);

    return pStoredExchange;
}

NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall,
    BOOLEAN               RemoteBootSession)
/*++

Routine Description:

    This routine issues the negotiate SMB to the server

Arguments:

    pServerEntry - the server entry

    pSrvCall     - the associated srv call instance in the wrapper

    RemoteBootSession - is this a negotiate for a remote boot session

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Since the negotiate SMB can be directed at either a unknown server or a server
    whose capabilitiese are known it is upto the caller to decide to wait for the
    response.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitializsing it.

    As part of the negotiate response the domain name to which the server belongs is
    sent back. Since the negotiate response is processed at DPC level, a preparatory
    allocation needs to be made ( This will ensure minimal work at DPC level).

    In this routine this is accomplished by allocating a buffer from nonpaged
    pool of MAX_PATH and associating it with the DomainName fild in the server entry
    prior to the TRanceive. On resumption from Tranceive this buffer is deallocated and
    a buffer from paged pool corresponding to the exact length is allocated to hold the
    domain name.

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    ULONG    NegotiateSmbLength;
    PVOID    pNegotiateSmb;

    PAGED_CODE();

    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC {
        NOTHING;
    } else {
#if 0
        if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
            return MRxSmbCscNegotiateDisconnected(pServerEntry);
        }
#endif
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     NULL,
                     SMB_COM_NEGOTIATE);

        if (Status == STATUS_SUCCESS) {
            // Build the negotiate SMB and allocate the temporary buffer for
            // the DOMAIN name.

            Status = BuildNegotiateSmb(
                         &pNegotiateSmb,
                         &NegotiateSmbLength,
                         RemoteBootSession);

            if (Status == STATUS_SUCCESS) {
                pSmbAdminExchange->pSmbBuffer      = pNegotiateSmb;
                pSmbAdminExchange->SmbBufferLength = NegotiateSmbLength;

                // Preparatory allocation for the domain name buffer
                pSmbAdminExchange->Negotiate.pSrvCall                 = pSrvCall;
                pSmbAdminExchange->Negotiate.DomainName.Length        = 0;
                pSmbAdminExchange->Negotiate.DomainName.MaximumLength = MAX_PATH;
                pSmbAdminExchange->Negotiate.DomainName.Buffer
                    = (PWCHAR)RxAllocatePoolWithTag(
                                  NonPagedPool,
                                  MAX_PATH,
                                  MRXSMB_ADMIN_POOLTAG);

                if (pSmbAdminExchange->Negotiate.DomainName.Buffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (Status == STATUS_SUCCESS) {
                BOOLEAN fExchangeDiscarded = FALSE;
                SMBCE_RESUMPTION_CONTEXT ResumptionContext;
                PSMB_EXCHANGE pStoredExchange;

                SmbCeInitializeResumptionContext(&ResumptionContext);
                pSmbAdminExchange->pResumptionContext = &ResumptionContext;

                // Since the Negotiate SMB is the first SMB that is sent on a
                // connection the MID mapping data structures have not been setup.
                // Therefore a certain amount of additional initialization is
                // required to ensure that the Negotiate SMB can be handled correctly.
                // This involves presetting the MID field in the header and the
                // SMBCE_EXCHANGE_MID_VALID field in the exchange.
                //
                // A beneficial side effect of implementing it this way is the reduced
                // path length for the regular Send/Receives on a connection.

                pSmbAdminExchange->SmbCeFlags = (SMBCE_EXCHANGE_REUSE_MID  |
                                                 SMBCE_EXCHANGE_RETAIN_MID |
                                                 SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION |
                                                 SMBCE_EXCHANGE_MID_VALID);

                // Prevent the admin exchange from being finalized before returning back to this routine.
                SmbCeIncrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);

                pStoredExchange = SmbSetServerEntryNegotiateExchange(
                                      pServerEntry,
                                      pSmbAdminExchange);

                if ((pServerEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS) &&
                    (pStoredExchange == NULL)) {

                    // The Negotiate SMB exchange has been built successfully. Initiate it.
                    Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                    if ((pSmbAdminExchange->SmbStatus != STATUS_SUCCESS) ||
                        (Status != STATUS_PENDING && Status != STATUS_SUCCESS)) {
                        pStoredExchange = (PSMB_EXCHANGE)InterlockedCompareExchangePointer(
                                                             &pServerEntry->pNegotiateExchange,
                                                             NULL,
                                                             pSmbAdminExchange);

                        if (pStoredExchange == (PSMB_EXCHANGE)pSmbAdminExchange) {
                            SmbCeDecrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);
                        }

                        if (pSmbAdminExchange->SmbStatus == STATUS_SUCCESS) {
                            pSmbAdminExchange->SmbStatus = Status;
                        }

                        pSmbAdminExchange->Status = pSmbAdminExchange->SmbStatus;
                    }

                    // Admin exchange is ready to be finalized
                    SmbCeDecrementPendingLocalOperationsAndFinalize((PSMB_EXCHANGE)pSmbAdminExchange);

                    // Wait for the finalization.
                    SmbCeSuspend(&ResumptionContext);
                    Status = SmbCeCompleteAdminExchange(pSmbAdminExchange);
                } else {
                    InterlockedCompareExchangePointer(
                         &pServerEntry->pNegotiateExchange,
                         NULL,
                         pSmbAdminExchange);

                    SmbCeDiscardAdminExchange(pSmbAdminExchange);
                    Status = STATUS_CONNECTION_DISCONNECTED;
                }
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_LOGIN_WKSTA_RESTRICTION) {
        DbgPrint("MRXSMB: Cannot talk to %wZ which doesn't support Security Signature.\n",&pServerEntry->Name);
    }

    return Status;
}

NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine sends an echo probe to the specified server

Arguments:

    pServerEntry     - the server entry

    pEchoProbeCOntext - the echo probe context

Return Value:

    STATUS_SUCCESS - the disconnect SMB was sent successfully

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     NULL,
                     SMB_COM_ECHO);

        if (Status == STATUS_SUCCESS) {
            ULONG EchoMdlSize;
            ULONG requestSize;

            pSmbAdminExchange->Mid = SMBCE_ECHO_PROBE_MID;
            pSmbAdminExchange->SmbCeFlags = (SMBCE_EXCHANGE_REUSE_MID  |
                                             SMBCE_EXCHANGE_RETAIN_MID |
                                             SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION |
                                             SMBCE_EXCHANGE_MID_VALID);

            requestSize = pEchoProbeContext->EchoSmbLength + TRANSPORT_HEADER_SIZE;

            EchoMdlSize = (ULONG)MmSizeOfMdl(
                                     pEchoProbeContext->pEchoSmb,
                                     requestSize);
            pSmbAdminExchange->EchoProbe.pEchoProbeMdl =
                          RxAllocatePoolWithTag(
                              NonPagedPool,
                              (EchoMdlSize + requestSize ),
                              MRXSMB_ADMIN_POOLTAG);

            if (pSmbAdminExchange->EchoProbe.pEchoProbeMdl != NULL) {
                PBYTE pEchoProbeBuffer;

                pEchoProbeBuffer = (PBYTE)pSmbAdminExchange->EchoProbe.pEchoProbeMdl +
                    EchoMdlSize + TRANSPORT_HEADER_SIZE;

                pSmbAdminExchange->EchoProbe.EchoProbeLength = pEchoProbeContext->EchoSmbLength;

                RtlCopyMemory(
                    pEchoProbeBuffer,
                    pEchoProbeContext->pEchoSmb,
                    pEchoProbeContext->EchoSmbLength);

                RxInitializeHeaderMdl(
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl,
                    pEchoProbeBuffer,
                    pEchoProbeContext->EchoSmbLength);

                MmBuildMdlForNonPagedPool(
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl);

                InterlockedIncrement(&pServerEntry->Server.NumberOfEchoProbesSent);

                // The ECHO probe SMB exchange has been built successfully. Initiate it.
                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (Status != STATUS_PENDING) {
                Status = SmbCeCompleteAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine issues the disconnect SMB for an existing connection to the server

Arguments:

    pServerEntry     - the server entry

    pVNetRootContext - the VNetRootContext

Return Value:

    STATUS_SUCCESS - the disconnect SMB was sent successfully

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_TREE_DISCONNECT pReqTreeDisconnect;

    PAGED_CODE();

    // On mailslot servers no disconnects are required.
    if (SmbCeGetServerType(pVNetRootContext->pServerEntry) == SMBCEDB_MAILSLOT_SERVER) {
        return STATUS_SUCCESS;
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pVNetRootContext->pServerEntry,
                     pVNetRootContext->pSessionEntry,
                     pVNetRootContext->pNetRootEntry,
                     SMB_COM_TREE_DISCONNECT);

        if (Status == STATUS_SUCCESS) {
            BOOLEAN fExchangeDiscarded = FALSE;

            pSmbAdminExchange->pSmbBuffer =
                (PCHAR) pSmbAdminExchange->Disconnect.DisconnectSmb + TRANSPORT_HEADER_SIZE;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqTreeDisconnect = (PREQ_TREE_DISCONNECT)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);

            if (Status == STATUS_SUCCESS) {
                ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
                *pCommand = SMB_COM_TREE_DISCONNECT;

                pSmbHeader->Tid = pVNetRootContext->TreeId;
                pReqTreeDisconnect->WordCount = 0;
                SmbPutUshort(&pReqTreeDisconnect->ByteCount,0);

                pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_TREE_DISCONNECT,Buffer);

                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                if ((Status == STATUS_PENDING) ||
                    (Status == STATUS_SUCCESS)) {
                    // async completion will also discard the exchange
                    fExchangeDiscarded = TRUE;
                }
            }

            if (!fExchangeDiscarded) {
                SmbCeDiscardAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

extern BOOLEAN MRxSmbEnableDownLevelLogOff;

NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry)
/*++

Routine Description:

    This routine issues the logoff SMB for an existing session to the server

Arguments:

    pServerEntry  - the server entry

    pSessionEntry - the associated session entry

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_LOGOFF_ANDX     pReqLogOffAndX;

    PAGED_CODE();

    if ((SmbCeGetServerType(pServerEntry) == SMBCEDB_MAILSLOT_SERVER) ||
        (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL)) {
        if (pSessionEntry != NULL) {
            SmbCeDereferenceSessionEntry(pSessionEntry);
        }

        return STATUS_SUCCESS;
    }

    //
    // Some servers (like linux) don't really know how to handle session logoffs.
    //  So, let's just be sure that we only do this to NT or better servers,
    //  because we know that they handle it correctly.  The version of Linux we have
    //  seems to like to negotiate the NT dialect even though it really isn't NT.  That's
    //  why the extra check is put in here for NT status codes.
    //
    // Bypass this behavior based on the 'EnableDownLevelLogOff' registry key.
    //

    if( MRxSmbEnableDownLevelLogOff == FALSE ) {
    
        if( pServerEntry->Server.Dialect < NTLANMAN_DIALECT ||
            !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_STATUS) ) {
            if (pSessionEntry != NULL) {
                SmbCeDereferenceSessionEntry(pSessionEntry);
            }
            return STATUS_SUCCESS;
        }
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     pSessionEntry,
                     NULL,
                     SMB_COM_LOGOFF_ANDX);

        if (Status == STATUS_SUCCESS) {
            BOOLEAN fExchangeDiscarded = FALSE;

            pSmbAdminExchange->pSmbBuffer =
                (PCHAR) pSmbAdminExchange->LogOff.LogOffSmb + TRANSPORT_HEADER_SIZE;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqLogOffAndX     = (PREQ_LOGOFF_ANDX)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);


            if (Status == STATUS_SUCCESS) {
                ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
                *pCommand = SMB_COM_LOGOFF_ANDX;

                pReqLogOffAndX->WordCount    = 2;
                pReqLogOffAndX->AndXCommand  = SMB_COM_NO_ANDX_COMMAND;
                pReqLogOffAndX->AndXReserved = 0;

                SmbPutUshort(&pReqLogOffAndX->AndXOffset,0);
                SmbPutUshort(&pReqLogOffAndX->ByteCount,0);

                pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_LOGOFF_ANDX,Buffer);

                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                if ((Status == STATUS_PENDING) ||
                    (Status == STATUS_SUCCESS)) {

                    // async completion will discard the exchange
                    fExchangeDiscarded = TRUE;
                }
            }

            if (!fExchangeDiscarded) {
                SmbCeDiscardAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
    }

    return Status;
}

NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand)
/*++

Routine Description:

    This routine initializes the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

    pServerEntry       - the associated server entry

    pSessionEntry      - the associated session entry

    pNetRootEntry      - the associated net root entry

    SmbCommand         - the SMB command

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

    The ADMIN_EXCHANGE is a special type of exchange used for bootstrap/teardown
    situations in which the initialization of the exchange cannot follow the noraml
    course of events. In some cases not all the components required for proper
    initialization of the exchange are present, e.g., NEGOTIATE we do not have a
    valid session/tree connect. It is for this reason that the three important
    elements of initialization, i.e., Server/Session/NetRoot have to be explicitly
    specified. NULL is used to signify a dont care situation for a particular component.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = SmbCeIncrementActiveExchangeCount();

    if (Status == STATUS_SUCCESS) {
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

        pSmbAdminExchange->CancellationStatus = SMBCE_EXCHANGE_NOT_CANCELLED;

        if ((SmbCommand == SMB_COM_NEGOTIATE) ||
            (SmbCommand == SMB_COM_ECHO)) {
            pSmbAdminExchange->SmbCeContext.pServerEntry     = pServerEntry;
            pSmbAdminExchange->SmbCeContext.pVNetRootContext = NULL;
        } else {
            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)
                       RxAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(SMBCE_V_NET_ROOT_CONTEXT),
                            MRXSMB_VNETROOT_POOLTAG);

            if (pVNetRootContext != NULL) {
                pVNetRootContext->pServerEntry = pServerEntry;
                pVNetRootContext->pSessionEntry = pSessionEntry;
                pVNetRootContext->pNetRootEntry = pNetRootEntry;

                pSmbAdminExchange->SmbCeContext.pVNetRootContext = pVNetRootContext;
                pSmbAdminExchange->SmbCeContext.pServerEntry = pServerEntry;
            }  else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            SmbCeReferenceServerEntry(pServerEntry);

            pSmbAdminExchange->pSmbMdl    = NULL;
            pSmbAdminExchange->pSmbBuffer = NULL;
            pSmbAdminExchange->SmbBufferLength = 0;

            // Set the SmbCe state to overrule the common method of having to hunt
            // up a valid TID/FID etc. and reconnects.
            pSmbAdminExchange->SmbCommand = SmbCommand;
            pSmbAdminExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;

            switch (pSmbAdminExchange->SmbCommand) {
            case SMB_COM_NEGOTIATE:
                {
                    pSmbAdminExchange->Negotiate.DomainName.Length = 0;
                    pSmbAdminExchange->Negotiate.DomainName.MaximumLength = 0;
                    pSmbAdminExchange->Negotiate.DomainName.Buffer = NULL;
                    pSmbAdminExchange->Negotiate.pSecurityBlobMdl  = NULL;
                }
                break;

            case SMB_COM_TREE_DISCONNECT:
            case SMB_COM_LOGOFF_ANDX:
                break;

            case SMB_COM_ECHO:
                {
                    pSmbAdminExchange->pDispatchVector = &EchoExchangeDispatch;
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl = NULL;
                    pSmbAdminExchange->EchoProbe.EchoProbeLength = 0;
                }
                break;

            default:
                ASSERT(!"Valid Command for Admin Exchange");
                break;
            }

            SmbCeAcquireResource();
            if ((pSessionEntry != NULL) &&
                pServerEntry->SecuritySignaturesEnabled && 
                !pServerEntry->SecuritySignaturesActive) {
                // if security signature is enabled and not yet turned on, exchange should wait for
                // outstanding extended session setup to finish before resume in order to avoid index mismatch.
                Status = SmbCeSyncExchangeForSecuritySignature((PSMB_EXCHANGE)pSmbAdminExchange);
                ASSERT(Status != STATUS_PENDING);
            }
            SmbCeReleaseResource();

            if (Status != STATUS_SUCCESS) {
                RxFreePool(pSmbAdminExchange->SmbCeContext.pVNetRootContext);
                pSmbAdminExchange->SmbCeContext.pVNetRootContext = NULL;
            }
        }
    }

    return Status;
}

VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange)
/*++

Routine Description:

    This routine discards the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

--*/
{
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    SmbCeAcquireResource();
    
    RemoveEntryList(&pSmbAdminExchange->ExchangeList);
    
    SmbCeReleaseResource();

    pServerEntry  = SmbCeGetExchangeServerEntry(pSmbAdminExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pSmbAdminExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pSmbAdminExchange);

    pVNetRootContext = SmbCeGetExchangeVNetRootContext(pSmbAdminExchange);

    if (pSmbAdminExchange->pSmbMdl != NULL) {
        RxUnlockHeaderPages(pSmbAdminExchange->pSmbMdl);
        IoFreeMdl(pSmbAdminExchange->pSmbMdl);
    }

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            pSmbAdminExchange->pSmbBuffer = NULL;

            if (pSmbAdminExchange->Negotiate.DomainName.Buffer != NULL) {
                RxFreePool(
                    pSmbAdminExchange->Negotiate.DomainName.Buffer);
            }

            if (pSmbAdminExchange->Negotiate.pSecurityBlobMdl != NULL) {
                IoFreeMdl(
                    pSmbAdminExchange->Negotiate.pSecurityBlobMdl);
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
        break;

    case SMB_COM_LOGOFF_ANDX:
        SmbCeDereferenceSessionEntry(pSessionEntry);
        break;

    case SMB_COM_ECHO:
        {
            if (pSmbAdminExchange->EchoProbe.pEchoProbeMdl != NULL) {
                MmPrepareMdlForReuse(pSmbAdminExchange->EchoProbe.pEchoProbeMdl);
                RxFreePool(pSmbAdminExchange->EchoProbe.pEchoProbeMdl);
            }
        }
        break;

    default:
        ASSERT(!"Valid Command For Admin Exchange");
        break;
    }

    // Tear down all the copy data requests associated with this exchange
    SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,(PSMB_EXCHANGE)pSmbAdminExchange);

    SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)pSmbAdminExchange);

    SmbCeDereferenceServerEntry(pServerEntry);

    if (pVNetRootContext != NULL) {
        RxFreePool(pVNetRootContext);
    }

    SmbCeFreeBufferForServerResponse((PSMB_EXCHANGE)pSmbAdminExchange);

    SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
    SmbCeDecrementActiveExchangeCount();
}

NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange)
/*++

Routine Description:

    This is the routine used for completing the SMB ADMIN exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine encapsulates the TAIL for all SMB admin exchanges. They carry
    out the local action required based upon the outcome of the exchange.

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    SMBCEDB_OBJECT_STATE  ServerState;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pSmbAdminExchange);

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            if (pSmbAdminExchange->Status != STATUS_SUCCESS) {
                pServerEntry->ServerStatus = pSmbAdminExchange->Status;
            }

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {

                if (!FlagOn(pServerEntry->Server.DialectFlags,DF_EXTENDED_SECURITY)) {
                    if (pServerEntry->DomainName.Buffer) {
                        RxFreePool(pServerEntry->DomainName.Buffer);
                        pServerEntry->DomainName.Buffer = NULL;
                    }

                    pServerEntry->DomainName.Length = pSmbAdminExchange->Negotiate.DomainName.Length;
                    pServerEntry->DomainName.MaximumLength = pServerEntry->DomainName.Length;

                    if (pServerEntry->DomainName.Length > 0) {
                        pServerEntry->DomainName.Buffer = RxAllocatePoolWithTag(
                                                              NonPagedPool,
                                                              pServerEntry->DomainName.Length,
                                                              MRXSMB_SERVER_POOLTAG);
                    }

                    if (pServerEntry->DomainName.Buffer != NULL) {
                        // Copy the domain name into the server entry
                        RtlCopyMemory(
                            pServerEntry->DomainName.Buffer,
                            pSmbAdminExchange->Negotiate.DomainName.Buffer,
                            pServerEntry->DomainName.Length);
                    } else {
                        //The downlevel server doesn't have a domain name. It's not a problem if the
                        //DomainName.Buffer equals to NULL.
                        if (pServerEntry->DomainName.Length > 0) {
                            pServerEntry->DomainName.Length = 0;
                            pServerEntry->DomainName.MaximumLength = 0;
                            pServerEntry->ServerStatus = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                }

                if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                    pServerEntry->ServerStatus = SmbCeUpdateSrvCall(pServerEntry);
                }
            }

            Status = pServerEntry->ServerStatus;

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                pServerEntry->Server.EchoProbeState = ECHO_PROBE_IDLE;
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_ECHO:
    default:
        break;
    }

    SmbCeDiscardAdminExchange(pSmbAdminExchange);

    return Status;
}

NTSTATUS
SmbAdminExchangeStart(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for administrative SMB exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS   Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    PAGED_CODE();

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
    case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_TREE_DISCONNECT:
        {
            ASSERT(pSmbAdminExchange->pSmbMdl == NULL);
            RxAllocateHeaderMdl(
                pSmbAdminExchange->pSmbBuffer,
                pSmbAdminExchange->SmbBufferLength,
                pSmbAdminExchange->pSmbMdl
                );

            if (pSmbAdminExchange->pSmbMdl != NULL) {

                RxProbeAndLockHeaderPages(
                    pSmbAdminExchange->pSmbMdl,
                    KernelMode,
                    IoModifyAccess,
                    Status);

                if (Status == STATUS_SUCCESS) {
                    Status = SmbCeTranceive(
                                 pExchange,
                                 RXCE_SEND_SYNCHRONOUS,
                                 pSmbAdminExchange->pSmbMdl,
                                 pSmbAdminExchange->SmbBufferLength);

                    RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
                } else {
                    IoFreeMdl(pSmbAdminExchange->pSmbMdl);
                    pSmbAdminExchange->pSmbMdl = NULL;
                }
            } else {
                Status = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
            }
        }
        break;

    case SMB_COM_ECHO:
        {
            Status = SmbCeSend(
                         pExchange,
                         0,
                         pSmbAdminExchange->EchoProbe.pEchoProbeMdl,
                         pSmbAdminExchange->EchoProbe.EchoProbeLength);
        }
        break;

    default:
        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN  PSMB_HEADER         pSmbHeader,
    OUT PMDL                *pDataBufferPointer,
    OUT PULONG              pDataSize,
    IN ULONG                ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS             Status;
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            Status = ParseNegotiateResponse(
                         pSmbAdminExchange,
                         BytesIndicated,
                         BytesAvailable,
                         pBytesTaken,
                         pSmbHeader,
                         pDataBufferPointer,
                         pDataSize);

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                if (*pDataBufferPointer != NULL &&
                    ((*pBytesTaken + *pDataSize) <= BytesAvailable ||
                     !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE))) {
                    pSmbAdminExchange->Negotiate.pSecurityBlobMdl = *pDataBufferPointer;
                } else {
                    *pBytesTaken = BytesAvailable;
                    Status       = STATUS_SUCCESS;
                    pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
        {
            *pBytesTaken = BytesAvailable;
            Status       = STATUS_SUCCESS;
        }
        break;

    case SMB_COM_ECHO:
        // Since the echo probe responses are handled by the receive indication routine
        // at DPC level this routine should never be called for echo probes.

    default:
        {
            *pBytesTaken = 0;
            Status       = STATUS_DATA_NOT_ACCEPTED;
        }
        break;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for administrative SMB exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbAdminExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(pExchange);
    UNREFERENCED_PARAMETER(pXmitBuffer);
    UNREFERENCED_PARAMETER(SendCompletionStatus);
}

NTSTATUS
SmbAdminExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalkzes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    if (pSmbAdminExchange->pResumptionContext != NULL) {
        // Signal the event
        *pPostFinalize = FALSE;
        SmbCeResume(pSmbAdminExchange->pResumptionContext);
    } else {
        if (RxShouldPostCompletion()) {
            *pPostFinalize = TRUE;
            return STATUS_SUCCESS;
        } else {
            *pPostFinalize = FALSE;
            SmbCeCompleteAdminExchange(pSmbAdminExchange);
        }
    }

   return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
AdminExchangeDispatch = {
                            SmbAdminExchangeStart,
                            SmbAdminExchangeReceive,
                            SmbAdminExchangeCopyDataHandler,
                            NULL,                            // No Send Completion handler
                            SmbAdminExchangeFinalize
                        };

SMB_EXCHANGE_DISPATCH_VECTOR
EchoExchangeDispatch = {
                            SmbAdminExchangeStart,
                            SmbAdminExchangeReceive,
                            SmbAdminExchangeCopyDataHandler,
                            SmbAdminExchangeSendCallbackHandler,
                            SmbAdminExchangeFinalize
                        };







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbcaps.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SmbCaps.h

Abstract:

    This module defines the types and functions related to the determining the capabilities supported
    by any particular server according to both the dialect it negotiates and the capabilties it returns.

Revision History:

--*/

#ifndef _SMBCAPS_H_
#define _SMBCAPS_H_


//
//      Dialect flags
//
//      These flags describe the various and sundry capabilities that
//      a server can provide. I essentially just lifted this list from rdr1 so that I
//      could also use the level2,3 of getconnectinfo which was also just lifted from rdr1.
//      Many of these guys you can get directly from the CAPS field of the negotiate response but others
//      you cannot. These is a table in the negotiate code that fills in the stuff that is just inferred
//      from the dialect negotiated (also, just lifted from rdr1....a veritable fount of just info.)
//
//      Another set of capabilities is defined in smbce.h....perhaps these should go there or vice versa.
//      The advantage to having them here is that this file has to be included by the aforementioned getconfiginfo code
//      up in the wrapper.
//

#define DF_CORE                0x00000001      // Server is a core server
#define DF_MIXEDCASEPW         0x00000002      // Server supports mixed case password
#define DF_OLDRAWIO            0x00000004      // Server supports MSNET 1.03 RAW I/O
#define DF_NEWRAWIO            0x00000008      // Server supports LANMAN Raw I/O
#define DF_LANMAN10            0x00000010      // Server supports LANMAN 1.0 protocol
#define DF_LANMAN20            0x00000020      // Server supports LANMAN 2.0 protocol
#define DF_MIXEDCASE           0x00000040      // Server supports mixed case files
#define DF_LONGNAME            0x00000080      // Server supports long named files
#define DF_EXTENDNEGOT         0x00000100      // Server returns extended negotiate
#define DF_LOCKREAD            0x00000200      // Server supports LockReadWriteUnlock
#define DF_SECURITY            0x00000400      // Server supports enhanced security
#define DF_NTPROTOCOL          0x00000800      // Server supports NT semantics
#define DF_SUPPORTEA           0x00001000      // Server supports extended attribs
#define DF_LANMAN21            0x00002000      // Server supports LANMAN 2.1 protocol
#define DF_CANCEL              0x00004000      // Server supports NT style cancel
#define DF_UNICODE             0x00008000      // Server supports unicode names.
#define DF_NTNEGOTIATE         0x00010000      // Server supports NT style negotiate.
#define DF_LARGE_FILES         0x00020000      // Server supports large files.
#define DF_NT_SMBS             0x00040000      // Server supports NT SMBs
#define DF_RPC_REMOTE          0x00080000      // Server is administrated via RPC
#define DF_NT_STATUS           0x00100000      // Server returns NT style statuses
#define DF_OPLOCK_LVL2         0x00200000      // Server supports level 2 oplocks.
#define DF_TIME_IS_UTC         0x00400000      // Server time is in UTC.
#define DF_WFW                 0x00800000      // Server is Windows for workgroups.
#define DF_EXTENDED_SECURITY   0x01000000      // Server does extended security
#define DF_TRANS2_FSCTL        0x02000000      // Server accepts remoted fsctls in tran2s
#define DF_DFS_TRANS2          0x04000000      // Server accepts Dfs related trans2
                                               // functions. Can this be merged with
                                               // DF_TRANS2_FSCTL?
#define DF_NT_FIND             0x08000000      // Server supports NT infolevels
#define DF_W95                 0x10000000      // this is a win95 server.....sigh
#define DF_NT_INFO_PASSTHROUGH 0x20000000      // This server supports setting and getting
                                               // NT infolevels by offsetting the requested
                                               // infolevel by SMB_INFO_PASSTHROUGH
#define DF_LARGE_WRITEX        0x40000000      // This server supports large writes
#define DF_OPLOCK              0x80000000      // This server supports opportunistic lock

#endif // _SMBCAPS_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbce.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbce.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

--*/

#ifndef _SMBCE_H_
#define _SMBCE_H_

#define SECURITY_KERNEL

#define SECURITY_NTLM
#include "security.h"
#include "secint.h"
#include "md5.h"

//
// The SMB protocol has a number of dialects. These reflect the extensions made
// to the core protocol over a period of time to cater to increasingly sophisticated
// file systems. The connection engine must be capable of dealing with different
// dialects implemented by server. The underlying Transport mechanism is used to
// uniquely identify the file server and the SMB protocol furnishes the remaining
// identification information to uniquely map an SMB onto a particular file opened by
// a particular client. The three important pieces of information are the SMB_TREE_ID,
// SMB_FILE_ID and SMB_USER_ID. These identify the particular connection made by a
// client machine, the particular file opened on that connection, and the user on
// behalf of whom the file has been opened. Note that there could be multiple
// connections from a client machine to a server machine. Therefore the unique id. is
// really connection based rather than machine based. The SMB connection engine
// data structures are built around these concepts.

//
// The known SMB dialects are as follows.
//

typedef enum _SMB_DIALECT_ {
    PCNET1_DIALECT,
    //XENIXCORE_DIALECT,
    //MSNET103_DIALECT,
    LANMAN10_DIALECT,
    WFW10_DIALECT,
    LANMAN12_DIALECT,
    LANMAN21_DIALECT,
    NTLANMAN_DIALECT
} SMB_DIALECT, *PSMB_DIALECT;

#define   NET_ROOT_FILESYSTEM_UNKOWN  ((UCHAR)0)
#define   NET_ROOT_FILESYSTEM_FAT     ((UCHAR)1)
#define   NET_ROOT_FILESYSTEM_NTFS    ((UCHAR)2)
typedef UCHAR NET_ROOT_FILESYSTEM, *PNET_ROOT_FILESYSTEM;

//
// The SMBCE_NET_ROOT encapsulates the information pertaining to a share on a server.
//

//we restrict to the first 7 characters (HPFS386)
#define SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL 7

#define MaximumNumberOfVNetRootContextsForScavenging 10

typedef struct _SMBCE_NET_ROOT_ {
    BOOLEAN       DfsAware;

    NET_ROOT_TYPE NetRootType;
    NET_ROOT_FILESYSTEM NetRootFileSystem;

    SMB_USER_ID   UserId;

    ULONG         MaximumReadBufferSize;
    ULONG         MaximumWriteBufferSize;

    LIST_ENTRY    ClusterSizeSerializationQueue;

    ULONG         FileSystemAttributes;

    LONG          MaximumComponentNameLength;


    USHORT  CompressionFormatAndEngine;
    UCHAR   CompressionUnitShift;
    UCHAR   ChunkShift;
    UCHAR   ClusterShift;

    ULONG   ChunkSize;

    //CSC Stuff
    CSC_ROOT_INFO   sCscRootInfo;

    ULONG CachedNumberOfSrvOpens;

    BOOLEAN  CscEnabled;            //this, if we are to automatically build shadows
    BOOLEAN  CscShadowable;         //this, if we are allowed to build shadows

    USHORT   CscFlags;              // CSC flags as returned by the server

    BOOLEAN  UpdateCscShareRights;  // indication to update share rights on the CSC database

    BOOLEAN  Disconnected;

    LIST_ENTRY DirNotifyList;       // head of a list of notify Irps.

    PNOTIFY_SYNC pNotifySync;       // used to synchronize the dir notify list.

    LIST_ENTRY  NotifyeeFobxList;     // list of fobx's given to the fsrtl structure
    FAST_MUTEX  NotifyeeFobxListMutex;

    union {
        struct {
            USHORT FileSystemNameLength;
            WCHAR FileSystemName[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
        };
        struct {
            USHORT Pad2;
            UCHAR FileSystemNameALength;
            UCHAR FileSystemNameA[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
            UCHAR Pad;  //this field is used for a null in a dbgprint; don't move it
        };
    };

    //ULONG         ClusterSize;
} SMBCE_NET_ROOT, *PSMBCE_NET_ROOT;

//
// There are two levels of security in the SMB protocol. User level security and Share level
// security. Corresponding to each user in the user level security mode there is a session.
//
// Typically the password, user name and domain name strings associated with the session entry
// revert to the default values, i.e., they are zero. In the event that they are not zero the
// SessionString represents a concatenated version of the password,user name and domain name in
// that order. This representation in a concatenated way yields us a savings of atleast 3
// USHORT's over other representations.
//

typedef enum _SECURITY_MODE_ {
    SECURITY_MODE_SHARE_LEVEL = 0,
    SECURITY_MODE_USER_LEVEL = 1
} SECURITY_MODE, *PSECURITY_MODE;

#define SMBCE_SHARE_LEVEL_SERVER_USERID 0xffffffff

typedef enum _SESSION_TYPE_ {
    UNINITIALIZED_SESSION,
    LANMAN_SESSION,
    EXTENDED_NT_SESSION
} SESSION_TYPE, *PSESSION_TYPE;

#define SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED (0x2)
#define SMBCE_SESSION_FLAGS_NULL_CREDENTIALS        (0x4)
#define SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION     (0x8)
#define SMBCE_SESSION_FLAGS_GUEST_SESSION           (0x10)
#define SMBCE_SESSION_FLAGS_LOGGED_OFF              (0x20)
#define SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION     (0x40)
#define SMBCE_SESSION_FLAGS_SECSIG_ENABLED          (0x80)

typedef struct _SMBCE_SESSION_ {
    SESSION_TYPE    Type;
    SMB_USER_ID     UserId;

    // Flags associated with the session.
    ULONG           Flags;

    LUID            LogonId;
    PUNICODE_STRING pUserName;
    PUNICODE_STRING pPassword;
    PUNICODE_STRING pUserDomainName;

    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    // The credential and context handles.
    CtxtHandle      SecurityContextHandle;
    CredHandle      CredentialHandle;
    ULONG           SessionId;
    ULONG           SessionKeyLength;

    ULONG           NumberOfActiveVNetRoot;
    ULONG           TargetInfoLength;
    PUSHORT         TargetInfoMarshalled;
} SMBCE_SESSION, *PSMBCE_SESSION;

extern VOID
UninitializeSecurityContextsForSession(PSMBCE_SESSION pSession);

extern VOID
DeleteSecurityContextForSession(PSMBCE_SESSION pSession);

//
// SMBCE_*_SERVER -- This data structure encapsulates all the information related to a server.
// Since there are multiple dialects of the SMB protocol, the capabilities as well as the
// actions that need to be taken at the client machine are very different.
//
// Owing to the number of dialects of the SMB protocol we have two design possibilities.
// Either we define an all encompassing data structure and have a code path that
// uses the dialect and the capabilities of the connection to determine the action
// required, or we use a subclassing mechanism associated with a dispatch vector.
// The advantage of the second mechanism is that it can be developed incrementally and
// it is very easily extensible. The disadvantage of this mechanism is that it can
// lead to a very large footprint, if sufficient care is not exercised during
// factorization and we could have lots and lots of procedure calls which has an
// adverse effect on the code generated.
//
// We will adopt the second approach ( Thereby implicitly defining the metrics by
// which the code should be evaluated !! ).
//
// The types of SMBCE_SERVER's can be classified in the following hierarchy
//
//    SMBCE_SERVER
//
//        SMBCE_USER_LEVEL_SERVER
//
//            SMBCE_NT_SERVER
//
//        SMBCE_SHARE_LEVEL_SERVER
//
// The dispatch vector which defines the set of methods supported by all the connections
// (virtual functions in C++ terminology) are as follows
//

#define RAW_READ_CAPABILITY         0x0001
#define RAW_WRITE_CAPABILITY        0x0002
#define COMPRESSED_DATA_CAPABILITY  0x0008

#define ECHO_PROBE_IDLE              0x1
#define ECHO_PROBE_AWAITING_RESPONSE 0x2

#define CRYPT_TEXT_LEN MSV1_0_CHALLENGE_LENGTH

typedef struct _NTLANMAN_SERVER_ {
    ULONG    NtCapabilities;
    GUID     ServerGuid;
    ULONG    SecurityBlobLength;
    PVOID    pSecurityBlob;
} NTLANMAN_SERVER, *PNTLANMAN_SERVER;

typedef struct _SMBCE_SERVER_ {
    // the server version count
    ULONG           Version;

    // the dispatch vector
    struct _SMBCE_SERVER_DISPATCH_VECTOR_  *pDispatch;

    // the SMB dialect
    SMB_DIALECT     Dialect;

    // More Server Capabilities
    ULONG           DialectFlags;

    // the session key
    ULONG           SessionKey;

    // the server Ip address
    ULONG           IpAddress;

    // Security mode supported on the server
    SECURITY_MODE   SecurityMode;

    // Time zone bias for conversion.
    LARGE_INTEGER   TimeZoneBias;

    // Echo Expiry Time
    LARGE_INTEGER   EchoExpiryTime;

    LONG            SmbsReceivedSinceLastStrobe;

    //CSC stuff
    LONG            CscState;

    LONG            EchoProbeState;
    LONG            NumberOfEchoProbesSent;

    // Maximum negotiated buffer size.
    ULONG           MaximumBufferSize;

    // maximum buffer size for read/write operations
    ULONG           MaximumDiskFileReadBufferSize;
    ULONG           MaximumNonDiskFileReadBufferSize;
    ULONG           MaximumDiskFileWriteBufferSize;
    ULONG           MaximumNonDiskFileWriteBufferSize;

    // This is used to detect the number of server opens. If it is larger than 0,
    // we shouldn't tear down the current transport in case the user provides the transport.
    LONG            NumberOfSrvOpens;

    LONG            NumberOfVNetRootContextsForScavenging;

    LONG            MidCounter;

    // Maximum number of multiplexed requests
    USHORT          MaximumRequests;

    // Maximum number of VC's
    USHORT          MaximumVCs;

    // Server Capabilities
    USHORT          Capabilities;

    // encrypt passwords
    BOOLEAN         EncryptPasswords;

    BOOLEAN         SecuritySignaturesEnabled;

    BOOLEAN         SecuritySignaturesRequired;

    // distinguishes a loopback connections
    BOOLEAN         IsLoopBack;

    // TRUE if the same server is being referred to by multiple names
    BOOLEAN         AliasedServers;

    BOOLEAN         IsRemoteBootServer;

    // There are certain servers that return DF_NT_SMBS in the negotiate
    // but do not support change notifies. This allows us to suppress
    // change notify requests to those servers.

    BOOLEAN         ChangeNotifyNotSupported;

    // avoid multiple event logs posted for security context failures
    BOOLEAN         EventLogPosted;

    // The sessions on this server should use the extended timeout interval
    BOOLEAN         ExtendedSessTimeout;

    USHORT          EncryptionKeyLength;
    UCHAR           EncryptionKey[CRYPT_TEXT_LEN];

    // Dialect specific information
    union {
        NTLANMAN_SERVER   NtServer;
    };

    MD5_CTX         SmbSecuritySignatureIntermediateContext;
    ULONG           SmbSecuritySignatureIndex;
    
    BOOLEAN         IsFakeDfsServerForOfflineUse;
    BOOLEAN         IsPinnedOffline;

} SMBCE_SERVER, *PSMBCE_SERVER;

typedef
NTSTATUS
(*PBUILD_SESSION_SETUP_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX  pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef
NTSTATUS
(*PBUILD_TREE_CONNECT_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX   pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef struct _SMBCE_SERVER_DISPATCH_VECTOR_ {
    PBUILD_SESSION_SETUP_SMB  BuildSessionSetup;
    PBUILD_TREE_CONNECT_SMB   BuildTreeConnect;
} SMBCE_SERVER_DISPATCH_VECTOR, *PSMBCE_SERVER_DISPATCH_VECTOR;

#define SMBCE_SERVER_DIALECT_DISPATCH(pServer,Routine,Arguments)        \
      (*((pServer)->pDispatch->Routine))##Arguments

// The SMBCE engine process all requests in an asychronous fashion. Therefore for synchronous
// requests an additional mechanism is required for synchronization. The following data structure
// provides an easy way for implementing this synchronization.
//
// NOTE: For asynchronous resumption contexts the resumption routine can be invoked
// at DPC level.

#define SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS (0x1)

typedef struct SMBCE_RESUMPTION_CONTEXT {
    ULONG    Flags;
    NTSTATUS Status;              // the status
    PVOID    pContext;            // a void pointer for clients to add additional context information
    union {
        PRX_WORKERTHREAD_ROUTINE pRoutine; // asynchronous contexts
        KEVENT                   Event;    // the event for synchronization
    };
    BOOLEAN  SecuritySignatureReturned;
} SMBCE_RESUMPTION_CONTEXT, *PSMBCE_RESUMPTION_CONTEXT;

#define SmbCeIsResumptionContextAsynchronous(pResumptionContext)   \
         ((pResumptionContext)->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)

INLINE VOID
SmbCeInitializeResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    KeInitializeEvent(&(pResumptionContext)->Event,NotificationEvent,FALSE);
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = 0;
    pResumptionContext->pContext = NULL;
}

INLINE VOID
SmbCeInitializeAsynchronousResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext,
    PRX_WORKERTHREAD_ROUTINE  pResumptionRoutine,
    PVOID                     pResumptionRoutineParam)
{
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS;
    pResumptionContext->pContext = pResumptionRoutineParam;
    pResumptionContext->pRoutine = pResumptionRoutine;
}

INLINE VOID
SmbCeSuspend(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    ASSERT(!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS));
    KeWaitForSingleObject(
        &pResumptionContext->Event,
        Executive,
        KernelMode,
        FALSE,
        NULL);
}

INLINE VOID
SmbCeResume(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    if (!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)) {
        KeSetEvent(&(pResumptionContext)->Event,0,FALSE);
    } else {
        if (RxShouldPostCompletion()) {
            RxDispatchToWorkerThread(
                MRxSmbDeviceObject,
                CriticalWorkQueue,
                pResumptionContext->pRoutine,
                pResumptionContext->pContext);
        } else {
            (pResumptionContext->pRoutine)(pResumptionContext->pContext);
        }
    }
}

//
// The SMBCE_REQUEST struct encapsulates the continuation context associated. Typically
// the act of sending a SMB along an exchange results in a SMBCE_REQUEST structure being
// created with sufficient context information to resume the exchange upon reciept of
// response from the serve. The SMBCE_REQUEST conatins ebough information to identify
// the SMB for which the response is being obtained followed by enough context information
// to resume the exchange.
//

typedef enum _SMBCE_OPERATION_ {
    SMBCE_TRANCEIVE,
    SMBCE_RECEIVE,
    SMBCE_SEND,
    SMBCE_ASYNCHRONOUS_SEND,
    SMBCE_ACQUIRE_MID
} SMBCE_OPERATION, *PSMBCE_OPERATION;

typedef enum _SMBCE_REQUEST_TYPE_ {
    ORDINARY_REQUEST,
    COPY_DATA_REQUEST,
    RECONNECT_REQUEST,
    ACQUIRE_MID_REQUEST
} SMBCE_REQUEST_TYPE, *PSMBCE_REQUEST_TYPE;

typedef struct _SMBCE_GENERIC_REQUEST_ {
    SMBCE_REQUEST_TYPE      Type;

    // the exchange instance that originated this SMB
    struct _SMB_EXCHANGE *  pExchange;
} SMBCE_GENERIC_REQUEST, *PSMBCE_GENERIC_REQUEST;

typedef struct _SMBCE_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the type of request
    SMBCE_OPERATION Operation;

    // the virtual circuit along which this request was sent.
    PRXCE_VC        pVc;

    // MPX Id of outgoing request.
    SMB_MPX_ID      Mid;

    // the pedigree of the request
    SMB_TREE_ID     TreeId;      // The Tree Id.
    SMB_FILE_ID     FileId;      // The file id.
    SMB_USER_ID     UserId;      // User Id. for cancel.
    SMB_PROCESS_ID  ProcessId;   // Process Id. for cancel.

    PMDL            pSendBuffer;
    ULONG           BytesSent;
} SMBCE_REQUEST, *PSMBCE_REQUEST;


typedef struct _SMBCE_COPY_DATA_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the virtual circuit along which this request was sent.
    PRXCE_VC    pVc;

    // the buffer into whihc data is being copied.
    PVOID          pBuffer;

    // the actual number of bytes copied
    ULONG          BytesCopied;
} SMBCE_COPY_DATA_REQUEST, *PSMBCE_COPY_DATA_REQUEST;


typedef struct _SMBCE_RECONNECT_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
} SMBCE_RECONNECT_REQUEST, *PSMBCE_RECONNECT_REQUEST;

typedef struct _SMBCE_MID_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
    PSMBCE_RESUMPTION_CONTEXT   pResumptionContext;
} SMBCE_MID_REQUEST, *PSMBCE_MID_REQUEST;


//
// extern function declarations
//

extern NTSTATUS
BuildSessionSetupSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX  pAndXSmb,
    PULONG         pAndXSmbBufferSize);

extern NTSTATUS
CoreBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
LmBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
NtBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength,
    BOOLEAN  RemoteBootSession);

extern NTSTATUS
ParseNegotiateResponse(
    IN OUT struct _SMB_ADMIN_EXCHANGE_ *pExchange,
    IN     ULONG               BytesIndicated,
    IN     ULONG               BytesAvailable,
       OUT PULONG              pBytesTaken,
    IN     PSMB_HEADER         pSmbHeader,
       OUT PMDL                *pDataBufferPointer,
       OUT PULONG              pDataSize);


extern struct _MINIRDR_DISPATCH MRxSmbDispatch;

#endif // _SMBCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbcedb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:

    The construction of server, net root and session entries involve a certain
    amount of network traffic. Therefore, all these entities are constructed
    using a two phase protocol

    This continuation context is that of the RDBSS during construction of
    srv call and net root entries. For the session entries it is an SMB exchange
    that needs to be resumed.

    Two of the three primary data structures in the SMB mini redirector, i.e.,
    SMBCEDB_SERVER_ENTRY, SMBCEDB_SESSION_ENTRY and SMBCEDB_NET_ROOT_ENTRY  have
    directcounterparts in the RDBSS (MRX_SRV_CALL, MRX_V_NET_ROOT and MRX_NET_ROOT)
    constitute the core of the SMB mini redirector connection engine. There exists
    a one to one mapping between the SERVER_ENTRY and the MRX_SRV_CALL, as well
    as NET_ROOT_ENTRY and MRX_NET_ROOT.

    The SMBCEDB_SESSION_ENTRY does not have a direct mapping to a wrapper data
    structue, It is a part of SMBCE_V_NET_ROOT_CONTEXT which is the data
    structure associated with a MRX_V_NET_ROOT instance.

    More than one tree connect to a server can use the same session on a USER level
    security share. Consequently mapping rules need to be established to manage this
    relationship. The SMB mini redirector implements the following rules ...

         1) The first session with explicitly specified credentials will be
         treated as the default session for all subsequent requests to any given
         server unless credentials are explicitly specified for the new session.

         2) If no session with explicitly specified credentials exist then a
         session with the same logon id. is choosen.

         3) If no session with the same logon id. exists a new session is created.

    These rules are liable to change as we experiment with rules for establishing
    sessions with differing credentials to a given server. The problem is not with
    creating/manipulating these sessions but providing an adequate set of
    fallback rules for emulating the behaviour of the old redirector.

    These rules are implemented in SmbCeFindOrConstructSessionEntry.

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"
#include "secext.h"
#include "csc.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeUpdateSrvCall)
#pragma alloc_text(PAGE, SmbCeTearDownServerEntry)
#pragma alloc_text(PAGE, SmbCeGetUserNameAndDomainName)
#pragma alloc_text(PAGE, SmbCeTearDownSessionEntry)
#pragma alloc_text(PAGE, SmbCeTearDownNetRootEntry)
#pragma alloc_text(PAGE, SmbCeUpdateNetRoot)
#pragma alloc_text(PAGE, SmbCeDbInit)
#endif

extern BOOLEAN MRxSmbSecuritySignaturesRequired;
extern BOOLEAN MRxSmbSecuritySignaturesEnabled;
extern BOOLEAN Win9xSessionRestriction;

RXDT_DefineCategory(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)

// The flag mask to control reference count tracing.

ULONG MRxSmbReferenceTracingValue = 0;

PSMBCEDB_SERVER_ENTRY
SmbCeFindServerEntry(
    PUNICODE_STRING     pServerName,
    SMBCEDB_SERVER_TYPE ServerType,
    PRX_CONNECTION_ID   RxConnectionId )
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry

Arguments:

    pServerName - the name of the server

    ServerType  - the server type

    RxConnectionId - Used to control whether this will be multiplexed or not

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    RX_CONNECTION_ID LocalId;

    ASSERT(SmbCeIsResourceOwned());

    if( !RxConnectionId )
    {
        RtlZeroMemory( &LocalId, sizeof(RX_CONNECTION_ID) );
        RxConnectionId = &LocalId;
    }


    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        if ((RtlCompareUnicodeString(
                    pServerName,
                    &pServerEntry->Name,
                    TRUE) == 0)) {
            // Check the connection ID
            if( RxEqualConnectionId( RxConnectionId, &pServerEntry->ConnectionId ) )
            {
                SmbCeReferenceServerEntry(pServerEntry);
                break;
            }
            else
            {
                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    return pServerEntry;
}

PSMBCEDB_SERVER_ENTRY
SmbCeFindServerEntryNoId(
    PUNICODE_STRING     pServerName,
    SMBCEDB_SERVER_TYPE ServerType)
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry and ignores the ConnectionId

Arguments:

    pServerName - the name of the server

    ServerType  - the server type

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    RX_CONNECTION_ID LocalId;

    ASSERT(SmbCeIsResourceOwned());

    RtlZeroMemory( &LocalId, sizeof(RX_CONNECTION_ID) );

    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        if ((RtlCompareUnicodeString(
                    pServerName,
                    &pServerEntry->Name,
                    TRUE) == 0)) {
            if( RxEqualConnectionId( &LocalId, &pServerEntry->ConnectionId ) )
            {
                SmbCeReferenceServerEntry(pServerEntry);
                break;
            }
            else
            {
                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    return pServerEntry;
}


PSMBCEDB_SERVER_ENTRY
SmbCeFindDfsServerEntry(
    PUNICODE_STRING     pServerName,
    SMBCEDB_SERVER_TYPE ServerType)
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry

Arguments:

    pServerName - the name of the server

    ServerType  - the server type

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    ASSERT(SmbCeIsResourceOwned());

    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        if ((RtlCompareUnicodeString(
                    pServerName,
                    &pServerEntry->DfsRootName,
                    TRUE) == 0)) {
            SmbCeReferenceServerEntry(pServerEntry);
            break;
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    return pServerEntry;
}

NTSTATUS
SmbCeFindOrConstructServerEntry(
    PUNICODE_STRING       pServerName,
    SMBCEDB_SERVER_TYPE   ServerType,
    PSMBCEDB_SERVER_ENTRY *pServerEntryPtr,
    PBOOLEAN              pNewServerEntry,
    PRX_CONNECTION_ID     RxConnectionId )
/*++

Routine Description:

    This routine searches the list of server entries and locates a matching
    entry or constructs a new one with the given name

Arguments:

    pServerName - the name of the server

    ServerType  - the type of server

    pServerEntryPtr - placeholder for the server entry

    pNewServerEntry - set to TRUE if it is a newly created server entry

Notes:

    The SmbCeResource must be held on entry and its ownership state will remain
    unchanged on exit

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN               fNewServerEntry = FALSE;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    RX_CONNECTION_ID      LocalId;

    ASSERT(SmbCeIsResourceOwned());

    if( !RxConnectionId )
    {
        RtlZeroMemory( &LocalId, sizeof(RX_CONNECTION_ID) );
        RxConnectionId = &LocalId;
    }

    pServerEntry = SmbCeFindServerEntry(
                       pServerName,
                       ServerType,
                       RxConnectionId);

    if (pServerEntry == NULL) {
        // Create a server instance, initialize its state, add it to the list

        pServerEntry = (PSMBCEDB_SERVER_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_SERVER);

        if (pServerEntry != NULL) {
            pServerEntry->Name.Buffer = RxAllocatePoolWithTag(
                                             NonPagedPool,
                                             pServerName->Length,
                                             MRXSMB_SERVER_POOLTAG);

            if (pServerEntry->Name.Buffer == NULL) {
                SmbMmFreeObject(pServerEntry);
                pServerEntry = NULL;
            }
        }

        if (pServerEntry != NULL) {
            fNewServerEntry = TRUE;

            pServerEntry->Name.Length = pServerName->Length;
            pServerEntry->Name.MaximumLength = pServerEntry->Name.Length;
            RtlCopyMemory(
                pServerEntry->Name.Buffer,
                pServerName->Buffer,
                pServerEntry->Name.Length);

            SmbCeUpdateServerEntryState(
                pServerEntry,
                SMBCEDB_CONSTRUCTION_IN_PROGRESS);

            SmbCeSetServerType(
                pServerEntry,
                ServerType);

            pServerEntry->PreferredTransport = NULL;

            SmbCeReferenceServerEntry(pServerEntry);
            SmbCeAddServerEntry(pServerEntry);

            pServerEntry->Server.IsRemoteBootServer = FALSE;
            if (MRxSmbBootedRemotely &&
                (MRxSmbRemoteBootShare.Length > pServerEntry->Name.Length)) {
                UNICODE_STRING RemoteBootServer;

                RemoteBootServer.Length = pServerEntry->Name.Length;
                RemoteBootServer.MaximumLength = pServerEntry->Name.MaximumLength;
                RemoteBootServer.Buffer = MRxSmbRemoteBootShare.Buffer;

                if (RtlEqualUnicodeString(
                    &pServerEntry->Name,
                    &RemoteBootServer,
                    TRUE)) {
                    pServerEntry->Server.IsRemoteBootServer = TRUE;
                }
            }

            pServerEntry->Server.IsFakeDfsServerForOfflineUse = FALSE;
            pServerEntry->Server.IsPinnedOffline = FALSE;
            pServerEntry->Server.SecurityMode = SECURITY_MODE_USER_LEVEL;

            RtlCopyMemory( &pServerEntry->ConnectionId, RxConnectionId, sizeof(RX_CONNECTION_ID) );

            if (SmbCeContext.ServersWithExtendedSessTimeout.Length != 0) {
                PWSTR          pSmbMRxServers = (PWSTR)SmbCeContext.ServersWithExtendedSessTimeout.Buffer;
                UNICODE_STRING SmbMRxServer, TargetServer;

                TargetServer.Length = pServerEntry->Name.Length - sizeof(WCHAR);
                TargetServer.MaximumLength = pServerEntry->Name.MaximumLength;
                TargetServer.Buffer = &pServerEntry->Name.Buffer[1];

                while (*pSmbMRxServers) {
                    SmbMRxServer.Length = wcslen(pSmbMRxServers) * sizeof(WCHAR);

                    if (SmbMRxServer.Length == TargetServer.Length) {
                        SmbMRxServer.MaximumLength = SmbMRxServer.Length;
                        SmbMRxServer.Buffer = pSmbMRxServers;

                        if (RtlCompareUnicodeString(
                               &SmbMRxServer,
                               &TargetServer,
                               TRUE) == 0) {
                            pServerEntry->Server.ExtendedSessTimeout = TRUE;
                            //DbgPrint("Extended SessTimeout %wZ\n",&pServerEntry->Name);
                            break;
                        }
                    }

                    pSmbMRxServers += (SmbMRxServer.Length / sizeof(WCHAR) + 1);
                }
            }

            SmbCeLog(("NewSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));
            SmbLog(LOG,
                   SmbCeFindOrConstructServerEntry_1,
                   LOGPTR(pServerEntry)
                   LOGUSTR(pServerEntry->Name));
        } else {
            RxDbgTrace(0, Dbg, ("SmbCeOpenServer : Server Entry Allocation failed\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        if (pServerEntry->PreferredTransport != NULL) {
            // reset the preferred transport created by previous owner
            SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
            pServerEntry->PreferredTransport = NULL;
        }

        SmbCeLog(("CachedSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));
        SmbLog(LOG,
               SmbCeFindOrConstructServerEntry_2,
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));
    }

    *pServerEntryPtr = pServerEntry;
    *pNewServerEntry = fNewServerEntry;

    return Status;
}

VOID
SmbCeCompleteSrvCallConstruction(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

    This routine comlpletes the srvcall construtcion routine by invoking
    the callback routine to the wrapper.

Arguments:

    pCallbackContext   - the RDBSS context

Notes:

--*/
{
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure;
    PMRX_SRV_CALL              pSrvCall;
    PSMBCEDB_SERVER_ENTRY      pServerEntry;
    BOOLEAN                    MustSucceed = FALSE;
    NTSTATUS                   Status;

    PAGED_CODE();

    SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;
    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pCallbackContext->RecommunicateContext;

    if (pServerEntry != NULL) {
        if (!NT_SUCCESS(pCallbackContext->Status)) {
            if (pServerEntry->Server.IsRemoteBootServer ||
                pCallbackContext->Status == STATUS_RETRY) {
                MustSucceed = TRUE;
            }

            SmbCeDereferenceServerEntry(pServerEntry);
        } else {
            if (SmbCeGetServerType(pServerEntry) == SMBCEDB_MAILSLOT_SERVER) {
                pServerEntry->Header.State = SMBCEDB_ACTIVE;
            }
        }
    } else {
        if (pCallbackContext->Status == STATUS_SUCCESS) {
            pCallbackContext->Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (MustSucceed) {
        //DbgPrint("Build ServerEntry %X try again.\n",pCallbackContext->Status);

        // in case it is the remote boot server, if the server entry cannot be created for some
        // reason, i.e. transport is not ready and the cache is not filled, we need to create the
        // server entry again until it succeeds.
        Status = RxDispatchToWorkerThread(
                     MRxSmbDeviceObject,
                     CriticalWorkQueue,
                     SmbCeCreateSrvCall,
                     pCallbackContext);
    } else {
        SrvCalldownStructure->CallBack(pCallbackContext);
    }
}

NTSTATUS
SmbCeInitializeServerEntry(
    PMRX_SRV_CALL                 pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext,
    BOOLEAN                       fDeferNetworkInitialization)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pSrvCall           - the SrvCall instance

    pCallbackContext   - the RDBSS context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    BOOLEAN               MailSlotCreate = FALSE;
    PSMBCE_TRANSPORT      PreferredTransport = NULL;
    BOOLEAN               fNewServerEntry = FALSE;
    SMBCEDB_SERVER_TYPE   ServerType = SMBCEDB_FILE_SERVER;
    UNICODE_STRING        TransportName;
    RX_CONNECTION_ID      sRxConnectionId;

//   RxProfile(SmbCe,SmbCeOpenServer);

    ASSERT(pSrvCall->Context == NULL);
    TransportName = pCallbackContext->SrvCalldownStructure->RxContext->Create.TransportName;

    Status = MRxSmbGetConnectionId( pCallbackContext->SrvCalldownStructure->RxContext, &sRxConnectionId );
    if( !NT_SUCCESS(Status) )
    {
        DbgPrint( "MRXSMB: GetConnectionId failed.\n" );
        ASSERT(FALSE);
        RtlZeroMemory( &sRxConnectionId, sizeof(RX_CONNECTION_ID) );
    }

    if (TransportName.Length > 0) {
        if ((PreferredTransport=SmbCeFindTransport(&TransportName)) == NULL) {
            ASSERT(pCallbackContext->RecommunicateContext == NULL);
            Status = STATUS_NETWORK_UNREACHABLE;
            goto FINALLY;
        }
    }

    MailSlotCreate = BooleanFlagOn(
                        pCallbackContext->SrvCalldownStructure->RxContext->Flags,
                        RX_CONTEXT_FLAG_CREATE_MAILSLOT);

    if (MailSlotCreate) {
        fDeferNetworkInitialization = FALSE;
        ServerType = SMBCEDB_MAILSLOT_SERVER;
    }

    SmbCeAcquireResource();

    Status = SmbCeFindOrConstructServerEntry(
                 pSrvCall->pSrvCallName,
                 ServerType,
                 &pServerEntry,
                 &fNewServerEntry,
                 &sRxConnectionId);

    SmbCeReleaseResource();

    pCallbackContext->RecommunicateContext = pServerEntry;

    if (Status == STATUS_SUCCESS) {

        ASSERT(pServerEntry != NULL);

        InterlockedExchangePointer(
            &pServerEntry->pRdbssSrvCall,
            pSrvCall);

        Status = SmbCeUpdateSrvCall(pServerEntry);

        if(!SmbCeIsServerInDisconnectedMode(pServerEntry)) {
            if (Status == STATUS_SUCCESS) {
                if (PreferredTransport != NULL) {
                    // Transfer the ownership of the preferred transport to the
                    // server entry.
                    pServerEntry->PreferredTransport = PreferredTransport;
                    PreferredTransport = NULL;
                } else {
                    pServerEntry->PreferredTransport = NULL;
                }

                if (fNewServerEntry) {
                    pServerEntry->Header.State = SMBCEDB_INVALID;
                    // Initialize the mailslot server parameters.
                    pServerEntry->Server.Dialect = LANMAN21_DIALECT;
                    //  MaximumBufferSize will be set based on negotiate response
                    pServerEntry->Server.MaximumBufferSize = 0xffff;

                    Status = CscInitializeServerEntryDfsRoot(
                                 pCallbackContext->SrvCalldownStructure->RxContext,
                                 pServerEntry);
                }

                if (Status == STATUS_SUCCESS) {
                    if (!fDeferNetworkInitialization &&
                        !MailSlotCreate) {
                        Status = SmbCeInitializeServerTransport(
                                     pServerEntry,
                                     SmbCeCompleteSrvCallConstruction,
                                     pCallbackContext);
                    } else {
                        Status = SmbCeInitializeServerMailSlotTransport(
                                     pServerEntry,
                                     SmbCeCompleteSrvCallConstruction,
                                     pCallbackContext);
                    }
                }
            }
        }
    }

FINALLY:
    if (Status != STATUS_PENDING) {
        pCallbackContext->Status = Status;
        SmbCeCompleteSrvCallConstruction(pCallbackContext);
    }

    if (PreferredTransport != NULL) {
        SmbCeDereferenceTransport(PreferredTransport);
    }

    return STATUS_PENDING;
}


NTSTATUS
SmbCeUpdateSrvCall(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine initializes the wrapper data structure corresponding to a
    given server entry.

Arguments:

    pServerEntry  - the server entry

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMRX_SRV_CALL pSrvCall = pServerEntry->pRdbssSrvCall;

    PAGED_CODE();

    if (pSrvCall != NULL) {
        // Copy the domain name into the server entry
        Status = RxSetSrvCallDomainName(
                     pSrvCall,
                     &pServerEntry->DomainName);

        // Initialize the SrvCall flags based upon the capabilities of the remote
        // server. The only flag that the SMB mini redirector updates is the
        // SRVCALL_FLAG_DFS_AWARE

        if (pServerEntry->Server.Capabilities & CAP_DFS) {
            SetFlag(
                pSrvCall->Flags,
                SRVCALL_FLAG_DFS_AWARE_SERVER);
        }
    }

    return Status;
}

BOOLEAN
SmbCeAreServerEntriesAliased(
    PSMBCEDB_SERVER_ENTRY pServerEntry1,
    PSMBCEDB_SERVER_ENTRY pServerEntry2)
/*++

Routine Description:

    This routine is used to determine if two server entries are aliased. For uplevel
    servers (NT5 or greater) the server GUID can be used to determine if the two
    server entries are aliased. For downlevel servers it is determined by checking if
    they have the same IP address.

Arguments:

    pServerEntry1  - the first server entry

    pServerEntry2  - the second server entry

Return Value:

    TRUE if the two server entries are aliased and FALSE otherwise

Notes:

    There are two interesting points to note ...

    1) a server entry cannot be an alias of itself. The first test in the implementation.
    This semantic makes checking a server entry against a collection of entries easy.

    2) the mechanism that we have for detecting aliases is not complete. There are cases
    (downlevel) when the two server entries are aliases of each other but we will conclude
    otherwise. This is because there is no foolproof way of establishing the absence of
    aliasing. The algorithm that is currently implemented detects the most important case
    of aliasing, i.e., DNS names and NETBIOS names to the same server on TCP.

--*/
{
    BOOLEAN ServerEntriesAliased = FALSE;

    if (pServerEntry1 != pServerEntry2) {
        if (BooleanFlagOn(
                pServerEntry1->Server.DialectFlags,
                DF_EXTENDED_SECURITY) &&
            BooleanFlagOn(
                pServerEntry2->Server.DialectFlags,
                DF_EXTENDED_SECURITY)) {
            if (RtlEqualMemory(
                    &pServerEntry1->Server.NtServer.ServerGuid,
                    &pServerEntry2->Server.NtServer.ServerGuid,
                    sizeof(GUID))) {
                ServerEntriesAliased = TRUE;
            }

        } else {
            if ((pServerEntry1->Server.IpAddress == pServerEntry2->Server.IpAddress) &&
                (pServerEntry1->Server.IpAddress != 0)) {
                ServerEntriesAliased = TRUE;
            }
        }
    }

    return ServerEntriesAliased;
}

VOID
SmbCeCompleteServerEntryInitialization(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    NTSTATUS              Status)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a server entry

Arguments:

    pServerEntry  - the server entry to be finalized

    ServerState   - the final state of the server

--*/
{
    NTSTATUS                ServerStatus;

    SMBCEDB_OBJECT_STATE    PreviousState;
    SMBCEDB_REQUESTS        ReconnectRequests;
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry;

    KIRQL                   SavedIrql;

    RxDbgTrace( 0, Dbg, ("Server Entry Finalization\n"));
    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    InitializeListHead(&ReconnectRequests.ListHead);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    // The server status could have changed because of the transport disconnects
    // from the time the admin exchange was completed to the time the server
    // entry initialization complete routine is called. Update the state
    // accordingly.

    PreviousState = pServerEntry->Header.State;

    if (PreviousState == SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
        pServerEntry->ServerStatus = Status;

        if (Status == STATUS_SUCCESS) {
            pServerEntry->Header.State = SMBCEDB_ACTIVE;
        } else {
            pServerEntry->Header.State = SMBCEDB_INVALID;
        }
    }

    ServerStatus = pServerEntry->ServerStatus;

    pServerEntry->NegotiateInProgress = FALSE;

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);

            SmbCeRemoveRequestEntryLite(
                &pServerEntry->OutstandingRequests,
                pTempRequestEntry);

            SmbCeAddRequestEntryLite(
                &ReconnectRequests,
                pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);
        }
    }

    pServerEntry->Server.NumberOfVNetRootContextsForScavenging = 0;
    pServerEntry->Server.AliasedServers = FALSE;
    if ((Status == STATUS_SUCCESS) && (ServerStatus == STATUS_SUCCESS)) {
        // Walk through the list of currently active servers to establish the
        // session numbering. This traversal is required because of server
        // name aliasing that occurs when the different name formats are used
        // to access the server, i.e., dotted IP address, DNS name, NETBIOS name.
        // The disambiguation between different servers is done in one of two
        // ways. For uplevel servers ( NT5.0 or later ) the Server GUID is used.
        // For downlevel servers ( NT 4.0 or before ) the IP address is used
        // to distinguish the two. Note that there is one case that is not
        // covered by the current solution, the connection using a NETBIOS
        // name is established over some transport other than NetBt and this
        // is followed by establishing a connection establishment using the
        // DNS name over NetBt. In such cases this numbering scheme fails. In
        // some ways there is no complete solution for this once we start using
        // *SMBSERVER names as opposed to the NETBIOS name for connection
        // establishment with dotted IP address.

        PSMBCEDB_SERVER_ENTRY pTempServerEntry;

        pTempServerEntry = SmbCeGetFirstServerEntry();

        while (pTempServerEntry != NULL) {
            if (pTempServerEntry->Header.State == SMBCEDB_ACTIVE) {
                if (SmbCeAreServerEntriesAliased(
                        pServerEntry,
                        pTempServerEntry)) {
                    pServerEntry->Server.AliasedServers = TRUE;
                    pTempServerEntry->Server.AliasedServers = TRUE;
                }
            }

            pTempServerEntry = SmbCeGetNextServerEntry(pTempServerEntry);
        }
    }

    SmbCeReleaseSpinLock();

    if ((Status == STATUS_SUCCESS) &&
        (ServerStatus == STATUS_SUCCESS) &&
        (PreviousState == SMBCEDB_CONSTRUCTION_IN_PROGRESS)) {
        PSMBCEDB_SESSION_ENTRY pSessionEntry;
        SESSION_TYPE           SessionType;

        InterlockedIncrement(&pServerEntry->Server.Version);
        pServerEntry->Server.NumberOfSrvOpens = 0;

        ASSERT(pServerEntry->pMidAtlas == NULL);

        // Initialize the MID Atlas
        pServerEntry->pMidAtlas = FsRtlCreateMidAtlas(
                                       pServerEntry->Server.MaximumRequests,
                                       pServerEntry->Server.MaximumRequests);

        if (pServerEntry->pMidAtlas == NULL) {
            pServerEntry->ServerStatus = RX_MAP_STATUS(INSUFFICIENT_RESOURCES);
        }

        if (MRxSmbSecuritySignaturesEnabled &&
            pServerEntry->Server.SecuritySignaturesEnabled) {
            pServerEntry->SecuritySignaturesEnabled = TRUE;
        } else {
            pServerEntry->SecuritySignaturesEnabled = FALSE;
        }

        // The sessions that have been created but whose initialization has been
        // deferred will have the session types set incorrectly. This is because
        // there is no previous knowledge of the session type required for deferred
        // servers.

        if (pServerEntry->Server.DialectFlags & DF_EXTENDED_SECURITY) {
            SessionType = EXTENDED_NT_SESSION;
        } else {
            SessionType = LANMAN_SESSION;
        }

        pSessionEntry =  SmbCeGetFirstSessionEntry(pServerEntry);
        while (pSessionEntry != NULL) {
            if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
                pSessionEntry->Session.Type = SessionType;
            } else {
                pSessionEntry->Session.Type = LANMAN_SESSION;
            }
            pSessionEntry = SmbCeGetNextSessionEntry(
                                pServerEntry,
                                pSessionEntry);
        }

        MRxSmbCheckForLoopBack(pServerEntry);
    }

    // Release the resource for the server entry
    SmbCeReleaseResource();

    // Resume all the outstanding reconnect requests that were held up because an earlier
    // reconnect request was under way.
    // Iterate over the list of pending requests and resume all of them
    SmbCeResumeOutstandingRequests(&ReconnectRequests,ServerStatus);
}


VOID
SmbCepDereferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine dereferences a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    if (pServerEntry != NULL) {
        BOOLEAN fTearDownEntry = FALSE;
        LONG    FinalRefCount;

        ASSERT((pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER) &&
               (pServerEntry->Header.SwizzleCount > 0));

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();

    /* if this is a work item request then clear the flag */
    /* WorkerRoutine is set to NULL just before work items are called */
    if((pServerEntry->WorkQueueItemForDisconnect.WorkerRoutine == NULL) &&
       pServerEntry->DisconnectWorkItemOutstanding == TRUE) {
        pServerEntry->DisconnectWorkItemOutstanding = FALSE;
    }

        FinalRefCount = InterlockedDecrement(&pServerEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {
            // This is to ensure that the routines for traversing the server
            // entry list, i.e., probing servers do not colide with the teardown.

            if (pServerEntry->Header.SwizzleCount == 0) {
                pServerEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeRemoveServerEntryLite(pServerEntry);

                if (SmbCeGetFirstServerEntry() == NULL &&
                    SmbCeStartStopContext.pServerEntryTearDownEvent != NULL) {
                    KeSetEvent(SmbCeStartStopContext.pServerEntryTearDownEvent,0,FALSE);
                }
            } else {
                fTearDownEntry = FALSE;
            }
        }

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        if (fTearDownEntry) {
            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                SmbCeTearDownServerEntry(pServerEntry);
            } else {
                InitializeListHead(&pServerEntry->WorkQueueItem.List);

                RxPostToWorkerThread(
                    MRxSmbDeviceObject,
                    CriticalWorkQueue,
                    &pServerEntry->WorkQueueItem,
                    SmbCeTearDownServerEntry,
                    pServerEntry);
            }
        }
    }
}

VOID
SmbCeTearDownServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine tears down a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    SmbCeLog(("TearSrvEntry %lx %wZ\n",pServerEntry,&pServerEntry->Name));
    SmbLog(LOG,
           SmbCeTearDownServerEntry,
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));
    ASSERT(pServerEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION);

    if (pServerEntry->pMidAtlas != NULL) {
        FsRtlDestroyMidAtlas(pServerEntry->pMidAtlas,NULL);
        pServerEntry->pMidAtlas = NULL;
    }

    if (pServerEntry->pTransport != NULL ||
        pServerEntry->pMailSlotTransport != NULL) {
        Status = SmbCeUninitializeServerTransport(pServerEntry,NULL,NULL);
        ASSERT(Status == STATUS_SUCCESS);
    }

    if (pServerEntry->Server.NtServer.pSecurityBlob != NULL) {
        RxFreePool(pServerEntry->Server.NtServer.pSecurityBlob);
    }

    if (pServerEntry->Name.Buffer != NULL) {
        RxFreePool(pServerEntry->Name.Buffer);
    }

    if (pServerEntry->DomainName.Buffer != NULL) {
        RxFreePool(pServerEntry->DomainName.Buffer);
    }

    if (pServerEntry->DfsRootName.Buffer != NULL) {
        RxFreePool(pServerEntry->DfsRootName.Buffer);
    }

    if (pServerEntry->DnsName.Buffer != NULL) {
        RxFreePool(pServerEntry->DnsName.Buffer);
    }

    if (pServerEntry->PreferredTransport != NULL) {
        SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
    }

    SmbMmFreeObject(pServerEntry);
}

NTSTATUS
SmbCeFindOrConstructSessionEntry(
    PMRX_V_NET_ROOT         pVNetRoot,
    PSMBCEDB_SESSION_ENTRY *pSessionEntryPtr)
/*++

Routine Description:

    This routine opens/creates a session for a given user in the connection engine database

Arguments:

    pVNetRoot - the RDBSS Virtual net root instance

Return Value:

    STATUS_SUCCESS - if successful

    Other Status codes correspond to error situations.

Notes:

    This routine assumes that the necesary concurreny control mechanism has already
    been taken.

    On Entry the connection engine resource must have been acquired exclusive and
    ownership remains invariant on exit.

    In case of UPN, we should pass a NULL string instead of NULL as domain name.

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    BOOLEAN                 fSessionEntryFound = FALSE;
    PUNICODE_STRING         UserName;
    PUNICODE_STRING         Password;
    PUNICODE_STRING         UserDomainName;
    DWORD                   SessionType;
    LUID                    AnonymousLogonID = ANONYMOUS_LOGON_LUID;

#define SessionTypeDefault      1
#define SessionTypeUser         2
#define SessionTypeNull         3
#define SessionTypeRemoteBoot   4

    ASSERT(SmbCeIsResourceOwned());

    UserName = pVNetRoot->pUserName;
    Password = pVNetRoot->pPassword;
    UserDomainName = pVNetRoot->pUserDomainName;

    //
    // If this is a remote boot client, and we're connecting to the boot share,
    // we always use the machine account, not the user account. This is
    // necessary in order to get security (ACL checking) to behave correctly.
    //

    SessionType = SessionTypeDefault;

    if ( MRxSmbBootedRemotely ) {

        //DbgPrint( "FindOrConstructSessionEntry: root %wZ\n", pVNetRoot->pNetRoot->pNetRootName );
        //DbgBreakPoint();
        if ( RtlCompareUnicodeString(
                 pVNetRoot->pNetRoot->pNetRootName,
                 &MRxSmbRemoteBootShare,
                 TRUE
                 ) == 0 ) {
            SessionType = SessionTypeRemoteBoot;
            //DbgPrint( "  Original user/password/domain: %wZ/%wZ/%wZ\n", UserName, Password, UserDomainName );
            UserName = &MRxSmbRemoteBootMachineName;
            Password = &MRxSmbRemoteBootMachinePassword;
            UserDomainName = &MRxSmbRemoteBootMachineDomain;
            //DbgPrint( "  Machine user/password/domain: %wZ/%wZ/%wZ\n", UserName, Password, UserDomainName );
        }
    }

    if (SessionType != SessionTypeRemoteBoot) {
        if ((UserName != NULL)       &&
            (UserName->Length == 0)  &&
            (Password != NULL)       &&
            (Password->Length == 0)  &&
            (UserDomainName != NULL) &&
            (UserDomainName->Length == 0)) {
            SessionType = SessionTypeNull;
        } else if ((UserName != NULL) ||
                   ((Password != NULL) &&
                    (Password->Length > 0))) {
            SessionType = SessionTypeUser;
        }
    }

    *pSessionEntryPtr = NULL;

    // Reference the server handle
    pServerEntry = SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
    if (pServerEntry != NULL) {
        if (SessionType != SessionTypeUser &&
            pServerEntry->Server.SecurityMode != SECURITY_MODE_SHARE_LEVEL) {

            SmbCeAcquireSpinLock();
            // Rule No. 1
            // 1) The first session with explicitly specified credentials will be treated as the
            // default session for all subsequent requests to any given server.
            if (SessionType == SessionTypeDefault) {
                pSessionEntry = SmbCeGetDefaultSessionEntry(
                                    pServerEntry,
                                    pVNetRoot->SessionId,
                                    &pVNetRoot->LogonId);

                while (pSessionEntry != NULL &&
                       FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {

                    SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                    pSessionEntry = SmbCeGetDefaultSessionEntry(
                                        pServerEntry,
                                        pVNetRoot->SessionId,
                                        &pVNetRoot->LogonId);
                }
            }

            if (pSessionEntry == NULL) {
                // Enumerate the sessions to detect if a session satisfying rule 2 exists

                pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
                while (pSessionEntry != NULL) {
                    if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {
                        if (SessionType == SessionTypeDefault) {
                            //
                            // Rule No. 2
                            // 2) If no session with explicitly specified credentials exist then a
                            // session with the same logon id. is choosen.
                            //

                            if (RtlEqualLuid(
                                    &pSessionEntry->Session.LogonId,
                                    &pVNetRoot->LogonId)) {
                                break;
                            }
                        } else if (SessionType == SessionTypeNull) {
                            if (FlagOn(
                                    pSessionEntry->Session.Flags,
                                    SMBCE_SESSION_FLAGS_NULL_CREDENTIALS)) {
                                break;
                            }
                        } else {
                            ASSERT(SessionType == SessionTypeRemoteBoot);
                            if (FlagOn(
                                    pSessionEntry->Session.Flags,
                                    SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION)) {
                                break;
                            }
                        }
                    }

                    pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
                }
            }

            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }

            SmbCeReleaseSpinLock();
        } else {
            BOOLEAN SessionEntryFound = FALSE;

            SmbCeAcquireSpinLock();
            pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }
            SmbCeReleaseSpinLock();

            while ((pSessionEntry != NULL) && !SessionEntryFound) {
                if (!FlagOn(pSessionEntry->Session.Flags,
                        SMBCE_SESSION_FLAGS_NULL_CREDENTIALS |
                        SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION |
                        SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION)) {
                    PSecurityUserData pSecurityData = NULL;

                    if (pServerEntry->Server.SecurityMode != SECURITY_MODE_SHARE_LEVEL) {
                        for (;;) {
                            PSMBCE_SESSION  pSession = &pSessionEntry->Session;
                            PUNICODE_STRING TempUserName,TempUserDomainName;

                            // For each existing session check to determine if the credentials
                            // supplied match the credentials used to construct the session.
                            if( pSession->SessionId != pVNetRoot->SessionId ) {
                                break;
                            }

                            if (!RtlEqualLuid(
                                    &pSessionEntry->Session.LogonId,
                                    &pVNetRoot->LogonId)) {
                                break;
                            }

                            TempUserName       = pSession->pUserName;
                            TempUserDomainName = pSession->pUserDomainName;

                            if (TempUserName == NULL ||
                                TempUserDomainName == NULL) {
                                Status = GetSecurityUserInfo(
                                             &pVNetRoot->LogonId,
                                             UNDERSTANDS_LONG_NAMES,
                                             &pSecurityData);

                                if (NT_SUCCESS(Status)) {
                                    if (TempUserName == NULL) {
                                        TempUserName = &(pSecurityData->UserName);
                                    }

                                    if (TempUserDomainName == NULL) {
                                        TempUserDomainName = &(pSecurityData->LogonDomainName);
                                    }
                                } else {
                                    break;
                                }
                            }

                            if (UserName != NULL &&
                                !RtlEqualUnicodeString(UserName,TempUserName,TRUE)) {
                                Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                                break;
                            }

                            if (UserDomainName != NULL &&
                                !RtlEqualUnicodeString(UserDomainName,TempUserDomainName,TRUE)) {
                                Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                                break;
                            }

                            if ((Password != NULL) &&
                                (pSession->pPassword != NULL)) {
                                if (!RtlEqualUnicodeString(
                                        Password,
                                        pSession->pPassword,
                                        FALSE)) {
                                    Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                                    break;
                                }
                            }

                            SessionEntryFound = TRUE;

                            // We use existing session if either the stored or new password is NULL.
                            // Later, a new security API will be created for verify the password
                            // based on the logon ID.

                            // An entry that matches the credentials supplied has been found. use it.
                            break;
                        }

                        //ASSERT(Status != STATUS_NETWORK_CREDENTIAL_CONFLICT);

                        if (pSecurityData != NULL) {
                            LsaFreeReturnBuffer(pSecurityData);
                            pSecurityData = NULL;
                        }
                    } else {
                        if (RtlEqualLuid(
                                &pSessionEntry->Session.LogonId,
                                &pVNetRoot->LogonId)) {
                            // For share level security, each share will have a different session
                            if (pSessionEntry->pNetRootName != NULL) {
                                if (RtlEqualUnicodeString(
                                        pVNetRoot->pNetRoot->pNetRootName,
                                        pSessionEntry->pNetRootName,
                                        FALSE)) {
                                    SessionEntryFound = TRUE;
                                }
                            }
                        }
                    }
                }

                if (!SessionEntryFound) {
                    if (Status == STATUS_SUCCESS) {
                        PSMBCEDB_SESSION_ENTRY pNextSessionEntry;

                        SmbCeAcquireSpinLock();
                        pNextSessionEntry = SmbCeGetNextSessionEntry(
                                                pServerEntry,
                                                pSessionEntry);
                        if (pNextSessionEntry != NULL) {
                            SmbCeReferenceSessionEntry(pNextSessionEntry);
                        }
                        SmbCeReleaseSpinLock();

                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = pNextSessionEntry;
                    } else {
                        // An error situation was encountered. Terminate the iteration.
                        // Typically a set of conflicting credentials have been presented
                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = NULL;
                    }
                } else {
                    if (RtlEqualLuid(&pSessionEntry->Session.LogonId,&AnonymousLogonID) &&
                        (Password != NULL || UserName != NULL || UserDomainName != NULL)) {
                        Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                    }
                }
            }
        }

        if (Win9xSessionRestriction &&
            (pSessionEntry == NULL) &&
            (Status == STATUS_SUCCESS) &&
            FlagOn(pServerEntry->Server.DialectFlags,DF_W95)) {
            PSMBCEDB_SESSION_ENTRY  TempSessionEntry;

            TempSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
            while (TempSessionEntry != NULL) {
                if (!FlagOn(TempSessionEntry->Session.Flags,
                           SMBCE_SESSION_FLAGS_NULL_CREDENTIALS)) {
                    Status = STATUS_LOGIN_WKSTA_RESTRICTION;
                    break;
                }

                TempSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,TempSessionEntry);
            }
        }

        if ((pSessionEntry == NULL) && (Status == STATUS_SUCCESS)) {
            // Rule No. 3
            // 3) If no session with the same logon id. exists a new session is created.
            //
            // Allocate a new session entry

            // This is the point at which a many to mapping between session entries and
            // V_NET_ROOT's in the RDBSS is being established. From this point it is
            // true that the session entry can outlive the associated V_NET_ROOT entry.
            // Therefore copies of the parameters used in the session setup need be made.

            PSMBCE_SESSION  pSession = &pSessionEntry->Session;
            PUNICODE_STRING pPassword,pUserName,pUserDomainName,pNetRootName;

            if (Password != NULL) {
                pPassword = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + Password->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pPassword != NULL) {
                    pPassword->Buffer = (PWCHAR)((PCHAR)pPassword + sizeof(UNICODE_STRING));
                    pPassword->Length = Password->Length;
                    pPassword->MaximumLength = pPassword->Length;
                    RtlCopyMemory(
                        pPassword->Buffer,
                        Password->Buffer,
                        pPassword->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pPassword = NULL;
            }

            if ((UserName != NULL) &&
                (Status == RX_MAP_STATUS(SUCCESS))) {
                pUserName = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + UserName->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pUserName != NULL) {
                    pUserName->Buffer = (PWCHAR)((PCHAR)pUserName + sizeof(UNICODE_STRING));
                    pUserName->Length = UserName->Length;
                    pUserName->MaximumLength = pUserName->Length;
                    RtlCopyMemory(
                        pUserName->Buffer,
                        UserName->Buffer,
                        pUserName->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserName = NULL;
            }

            if ((UserDomainName != NULL) &&
                (Status == RX_MAP_STATUS(SUCCESS))) {
                pUserDomainName = (PUNICODE_STRING)
                                  RxAllocatePoolWithTag(
                                      NonPagedPool,
                                      sizeof(UNICODE_STRING) + UserDomainName->Length + sizeof(WCHAR),
                                      MRXSMB_SESSION_POOLTAG);

                if (pUserDomainName != NULL) {
                    pUserDomainName->Buffer = (PWCHAR)((PCHAR)pUserDomainName + sizeof(UNICODE_STRING));
                    pUserDomainName->Length = UserDomainName->Length;
                    pUserDomainName->MaximumLength = pUserDomainName->Length;

                    // in case of UPN name, domain name will be a NULL string
                    *pUserDomainName->Buffer = 0;

                    if (UserDomainName->Length > 0) {
                        RtlCopyMemory(
                            pUserDomainName->Buffer,
                            UserDomainName->Buffer,
                            pUserDomainName->Length);
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserDomainName = NULL;
            }


            if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
                pNetRootName = (PUNICODE_STRING)RxAllocatePoolWithTag(
                                          NonPagedPool,
                                          sizeof(UNICODE_STRING) +
                                          pVNetRoot->pNetRoot->pNetRootName->Length,
                                          MRXSMB_SESSION_POOLTAG);

                if (pNetRootName != NULL) {
                    pNetRootName->Buffer = (PWCHAR)((PCHAR)pNetRootName + sizeof(UNICODE_STRING));
                    pNetRootName->Length = pVNetRoot->pNetRoot->pNetRootName->Length;
                    pNetRootName->MaximumLength = pNetRootName->Length;

                    if (pNetRootName->Length > 0) {
                        RtlCopyMemory(
                            pNetRootName->Buffer,
                            pVNetRoot->pNetRoot->pNetRootName->Buffer,
                            pNetRootName->Length);
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pNetRootName = NULL;
            }

            if (Status == STATUS_SUCCESS) {
                pSessionEntry = SmbMmAllocateSessionEntry(
                                    pServerEntry,
                                    (BOOLEAN)(SessionType == SessionTypeRemoteBoot));
                if (pSessionEntry != NULL) {
                    PSMBCE_SESSION pSession = & pSessionEntry->Session;

                    SmbCeLog(("NewSessEntry %lx\n",pSessionEntry));
                    SmbLog(LOG,
                           SmbCeFindOrConstructSessionEntry_1,
                           LOGPTR(pSessionEntry));

                    pSessionEntry->Header.State = SMBCEDB_INVALID;
                    pSessionEntry->pServerEntry = pServerEntry;
                    pSessionEntry->pNetRootName = pNetRootName;

                    if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
                        pSessionEntry->Session.UserId = (SMB_USER_ID)SMBCE_SHARE_LEVEL_SERVER_USERID;
                    }

                    pSession->Flags           = 0;
                    if ( SessionType == SessionTypeRemoteBoot ) {
                        pSession->Flags = SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION;
                    }

                    if ( SessionType == SessionTypeNull ) {
                        pSession->Flags |= SMBCE_SESSION_FLAGS_NULL_CREDENTIALS;
                    }

                    pSession->LogonId         = pVNetRoot->LogonId;
                    pSession->pUserName       = pUserName;
                    pSession->pPassword       = pPassword;
                    pSession->pUserDomainName = pUserDomainName;
                    pSession->SessionId       = pVNetRoot->SessionId;

                    SmbCeReferenceSessionEntry(pSessionEntry);
                    SmbCeAddSessionEntry(pServerEntry,pSessionEntry);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (Status != STATUS_SUCCESS) {
                if (pUserName != NULL) {
                    RxFreePool(pUserName);
                }

                if (pPassword != NULL) {
                    RxFreePool(pPassword);
                }

                if (pUserDomainName != NULL) {
                    RxFreePool(pUserDomainName);
                }

                if (pNetRootName != NULL) {
                    RxFreePool(pNetRootName);
                }
            }
        } else {
            if (Status == STATUS_SUCCESS) {
                SmbCeLog(("CachedSessEntry %lx\n",pSessionEntry));
                SmbLog(LOG,
                       SmbCeFindOrConstructSessionEntry_2,
                       LOGPTR(pSessionEntry));
            }
        }

        if (Status == STATUS_SUCCESS) {
            *pSessionEntryPtr = pSessionEntry;
        }

        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

VOID
SmbCeCompleteSessionEntryInitialization(
    PVOID    pContext,
    NTSTATUS Status,
    BOOLEAN  SecuritySignatureReturned)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a session entry

Arguments:

    pContext  - the session entry to be activated

Notes:

    PRE_CONDITION: The session entry must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    PSMBCEDB_SESSION_ENTRY pSessionEntry = (PSMBCEDB_SESSION_ENTRY)pContext;
    PSMBCE_SESSION         pSession = &pSessionEntry->Session;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = pSessionEntry->pServerEntry;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    SMBCEDB_REQUESTS       Requests;
    SMBCEDB_REQUESTS       SecuritySignatureSyncRequests;

    RxDbgTrace( 0, Dbg, ("Session Entry Finalization\n"));
    ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();

    // reset the constructor exchange field since the construction is complete
    pSessionEntry->pExchange = NULL;

    //
    SmbCeUnblockSerializedSessionSetupRequests(pSessionEntry);

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.
    SmbCeTransferRequests(&Requests,&pSessionEntry->Requests);
    SmbCeTransferRequests(&SecuritySignatureSyncRequests,&pServerEntry->SecuritySignatureSyncRequests);
    pServerEntry->ExtSessionSetupInProgress = FALSE;

    if (Status == STATUS_SUCCESS) {
        SmbCeUpdateSessionEntryState(
            pSessionEntry,
            SMBCEDB_ACTIVE);

        if ((pSession->pPassword != NULL || pSession->pUserName != NULL) &&
            !BooleanFlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_NULL_CREDENTIALS)) {
            if (pSessionEntry->DefaultSessionLink.Flink == NULL ) {
                ASSERT( pSessionEntry->DefaultSessionLink.Blink == NULL );
                InsertHeadList(&pServerEntry->Sessions.DefaultSessionList,
                               &pSessionEntry->DefaultSessionLink );
            }
        }

        if (SecuritySignatureReturned &&
            pServerEntry->SecuritySignaturesEnabled == TRUE &&
            pServerEntry->SecuritySignaturesActive == FALSE) {

            if (pSession->Type == EXTENDED_NT_SESSION) {
                SmbInitializeSmbSecuritySignature(&pServerEntry->Server,
                                                  NULL,
                                                  pSession->UserSessionKey,
                                                  pSession->SessionKeyLength);

                //DbgPrint("MRXSMB: Security Signature is active to W2K server %wZ\n", &pServerEntry->Name);
            } else {
                //DbgPrint("MRXSMB: Security Signature is active to NT4 server %wZ\n", &pServerEntry->Name);
            }

            // turn on the security signature on the client side
            pServerEntry->SecuritySignaturesActive = TRUE;
            pServerEntry->Server.SmbSecuritySignatureIndex = 2;
        }
    } else {
        SmbCeUpdateSessionEntryState(
            pSessionEntry,
            SMBCEDB_INVALID);
    }

    pSessionEntry->SessionRecoverInProgress = FALSE;
    //RxLog(("UnMark Sess Rec %lx\n",pSessionEntry));

    // Release the resource for the session entry
    SmbCeReleaseResource();

    if (!IsListEmpty(&Requests.ListHead)) {
        // Iterate over the list of pending requests and resume all of them
        SmbCeResumeOutstandingRequests(&Requests,Status);
    }

    if (!IsListEmpty(&SecuritySignatureSyncRequests.ListHead)) {
        SmbCeResumeOutstandingRequests(&SecuritySignatureSyncRequests,STATUS_SUCCESS);
    }

    SmbCeDereferenceSessionEntry(pSessionEntry);
}

NTSTATUS
SmbCeGetUserNameAndDomainName(
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PUNICODE_STRING         pUserName,
    PUNICODE_STRING         pUserDomainName)
/*++

Routine Description:

    This routine returns the user name and domain name associated with a session
    in a caller allocated buffer.

Arguments:

    pSessionEntry - the session entry to be dereferenced

    pUserName     - the User name

    pUserDomainName - the user domain name

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;

    PSMBCE_SESSION  pSession;
    PUNICODE_STRING pSessionUserName,pSessionDomainName;

    PSecurityUserData   pSecurityData;

    PAGED_CODE();

    ASSERT(pSessionEntry != NULL);
    pSession = &pSessionEntry->Session;

    if ((pUserName == NULL) ||
        (pUserDomainName == NULL) ||
        (pUserName->MaximumLength < (UNLEN * sizeof(WCHAR))) ||
        (pUserDomainName->MaximumLength < (DNLEN * sizeof(WCHAR)))) {
        return STATUS_INVALID_PARAMETER;
    }

    Status          = STATUS_SUCCESS;
    pSecurityData   = NULL;

    pSessionUserName   = pSession->pUserName;
    pSessionDomainName = pSession->pUserDomainName;

    try {
        if (pSessionUserName == NULL ||
            pSessionDomainName == NULL) {
            Status = GetSecurityUserInfo(
                         &pSession->LogonId,
                         UNDERSTANDS_LONG_NAMES,
                         &pSecurityData);

            if (NT_SUCCESS(Status)) {
                if (pSessionUserName == NULL) {
                    pSessionUserName   = &(pSecurityData->UserName);
                }

                if (pSessionDomainName == NULL) {
                    pSessionDomainName = &(pSecurityData->LogonDomainName);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            ASSERT(pSessionUserName->Length <= pUserName->MaximumLength);

            ASSERT(pSessionDomainName->Length <= pUserDomainName->MaximumLength);

            pUserName->Length = pSessionUserName->Length;
            RtlCopyMemory(
                pUserName->Buffer,
                pSessionUserName->Buffer,
                pUserName->Length);

            pUserDomainName->Length = pSessionDomainName->Length;
            if (pUserDomainName->Length > 0) {
                RtlCopyMemory(
                    pUserDomainName->Buffer,
                    pSessionDomainName->Buffer,
                    pUserDomainName->Length);
            }
        }
    } finally {
        if (pSecurityData != NULL) {
            LsaFreeReturnBuffer(pSecurityData);
        }
    }

    return Status;
}

VOID
SmbCepDereferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine dereferences a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    if (pSessionEntry != NULL) {
        BOOLEAN fTearDownEntry;
        BOOLEAN fLogOffRequired;

        LONG    FinalRefCount;

        PSMBCEDB_SERVER_ENTRY pServerEntry;

        ASSERT((pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION) &&
               (pSessionEntry->Header.SwizzleCount > 0));

        pServerEntry = pSessionEntry->pServerEntry;

        SmbCeAcquireResource();

        FinalRefCount = InterlockedDecrement(&pSessionEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {
            // A logoff smb needs to be sent if the user id associated with
            // the session is not zero. Note that we cannot rely on the state
            // of the session to indicate this since extended session setups
            // cna be terminated midway through the construction

            SmbCeReferenceServerEntry(pServerEntry);

            if (pSessionEntry->Header.SwizzleCount == 0) {
                if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                    SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
                }

                SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
                    (pSessionEntry->Session.UserId != 0) &&
                    (pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
                    !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
                    SmbCeReferenceServerEntry(pServerEntry);
                    SmbCeReferenceSessionEntry(pSessionEntry);

                    fLogOffRequired = TRUE;
                } else {
                    fLogOffRequired = FALSE;
                }

                pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;
                fTearDownEntry = TRUE;
            } else {
                fTearDownEntry = FALSE;
            }

            SmbCeDereferenceServerEntry(pServerEntry);
        }

        SmbCeReleaseResource();

        if (fTearDownEntry) {
            if (fLogOffRequired) {
                SmbCeLogOff(pServerEntry,pSessionEntry);
                SmbCeDereferenceServerEntry(pServerEntry);
            } else {
                SmbCeTearDownSessionEntry(pSessionEntry);
            }
        }
    }
}

NTSTATUS
MRxSmbLogonSessionTerminationHandler(
    PLUID pLogonId)
/*++

Routine Description:

    This routine issues a log off command to the server on all the sessions
    for the given logon id.

Arguments:

    pLogonId - the logon id of the logon session that was terminated

--*/
{
#if 0
    PSMBCEDB_SERVER_ENTRY  pServerEntry,pNextServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry,pNextSessionEntry;

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        ASSERT(SmbCeIsResourceOwned());

        SmbCeReferenceServerEntry(pServerEntry);

        pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
        while (pSessionEntry != NULL) {
            if (RtlEqualLuid(
                    &pSessionEntry->Session.LogonId,
                    pLogonId)) {
                if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
                    (pSessionEntry->Session.UserId != 0) &&
                    !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {

                    SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
                    SmbCeRemoveDefaultSessionEntry(pSessionEntry);

                    pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                    pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;

                    SmbCeReferenceSessionEntry(pSessionEntry);

                    SmbCeReleaseResource();

                    if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
                        SmbCeLogOff(pServerEntry,pSessionEntry);
                    } else {
                        SmbCeDereferenceSessionEntry(pSessionEntry);
                    }

                    SmbCeAcquireResource();

                    pNextSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);

                    SmbCeDereferenceSessionEntry(pSessionEntry);

                    pSessionEntry = pNextSessionEntry;
                }
            } else {
                pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
            }
        }

        pNextServerEntry = SmbCeGetNextServerEntry(pServerEntry);

        SmbCeDereferenceServerEntry(pServerEntry);

        pServerEntry = pNextServerEntry;
    }

    SmbCeReleaseResource();
#endif
    return STATUS_SUCCESS;
}

VOID
SmbCeTearDownSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine tears down a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    PAGED_CODE();

    ASSERT((pSessionEntry->Header.SwizzleCount == 0) &&
           (pSessionEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    ASSERT(IsListEmpty(&pSessionEntry->SerializationList));

    SmbCeLog(("TearSessEntry %lx\n",pSessionEntry));
    SmbLog(LOG,
           SmbCeTearDownSessionEntry,
           LOGPTR(pSessionEntry));

    if (pSessionEntry->Session.pUserName != NULL) {
        RxFreePool(pSessionEntry->Session.pUserName);
    }

    if (pSessionEntry->Session.pPassword != NULL) {
        RxFreePool(pSessionEntry->Session.pPassword);
    }

    if (pSessionEntry->Session.pUserDomainName != NULL) {
        RxFreePool(pSessionEntry->Session.pUserDomainName);
    }

    if (pSessionEntry->Session.TargetInfoMarshalled != NULL) {
        RxFreePool(pSessionEntry->Session.TargetInfoMarshalled);
    }

    if (pSessionEntry->pNetRootName != NULL) {
        RxFreePool(pSessionEntry->pNetRootName);
    }

    UninitializeSecurityContextsForSession(&pSessionEntry->Session);

    SmbMmFreeSessionEntry(pSessionEntry);
}

PSMBCEDB_NET_ROOT_ENTRY
SmbCeFindNetRootEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PUNICODE_STRING pServerShare
    )
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

   ASSERT(SmbCeIsResourceOwned());

   pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);

    while (pNetRootEntry != NULL) {
        if (RtlCompareUnicodeString(
                pServerShare,
                &pNetRootEntry->Name,
                TRUE) == 0) {
            break;
        }

        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);

    }

    return pNetRootEntry;
}

NTSTATUS
SmbCeFindOrConstructNetRootEntry(
    IN  PMRX_NET_ROOT pNetRoot,
    OUT PSMBCEDB_NET_ROOT_ENTRY *pNetRootEntryPtr)
/*++

Routine Description:

    This routine opens/creates a net root entry in the connection engine database

Arguments:

    pNetRoot -- the RDBSS net root instance

    pNetRootEntryPtr -- Initialized to the SMBCEDB_NET_ROOT_ENTRY instance if
                        successful

Return Value:

    STATUS_SUCCESS - the construction of the net root instance has been finalized

    Other Status codes correspond to error situations.

Notes:

    This routine assumes that the necesary concurreny control mechanism has already
    been taken.

    On Entry the connection engine resource must have been acquired exclusive and
    ownership remains invariant on exit.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry   = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry  = NULL;

    SMB_USER_ID UserId = 0;

    ASSERT(SmbCeIsResourceOwned());

    *pNetRootEntryPtr = NULL;

    pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);

    if (pServerEntry != NULL) {
        // Check if any of the SMBCEDB_NET_ROOT_ENTRY associated with the server
        // can be used. An existing entry is reusable if the names match

        pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
        while (pNetRootEntry != NULL) {
            if (RtlCompareUnicodeString(
                    pNetRoot->pNetRootName,
                    &pNetRootEntry->Name,
                    TRUE) == 0) {
                SmbCeLog(("CachedNREntry %lx\n",pNetRootEntry));
                SmbLog(LOG,
                       SmbCeFindOrConstructNetRootEntry_1,
                       LOGPTR(pNetRootEntry));
                break;
            }

            pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
        }

        if (pNetRootEntry != NULL) {
            SmbCeReferenceNetRootEntry(pNetRootEntry);
        } else {
            pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_NETROOT);
            if (pNetRootEntry != NULL) {
                Status = MRxSmbCscInitializeNetRootEntry(pNetRootEntry);

                if (Status != STATUS_SUCCESS) {
                    SmbMmFreeObject(pNetRootEntry);
                } else {
                    pNetRootEntry->Name.Buffer = RxAllocatePoolWithTag(
                                                     PagedPool | POOL_COLD_ALLOCATION,
                                                     pNetRoot->pNetRootName->Length,
                                                     MRXSMB_NETROOT_POOLTAG);

                    if (pNetRootEntry->Name.Buffer != NULL) {
                        SmbCeLog(("NewNetREntry %lx\n",pNetRootEntry));
                        SmbLog(LOG,
                               SmbCeFindOrConstructNetRootEntry_2,
                               LOGPTR(pNetRootEntry));

                        pNetRootEntry->Name.Length = pNetRoot->pNetRootName->Length;
                        pNetRootEntry->Name.MaximumLength = pNetRootEntry->Name.Length;
                        RtlCopyMemory(
                            pNetRootEntry->Name.Buffer,
                            pNetRoot->pNetRootName->Buffer,
                            pNetRootEntry->Name.Length);

                        pNetRootEntry->pServerEntry = pServerEntry;
                        pNetRootEntry->NetRoot.UserId = UserId;
                        pNetRootEntry->NetRoot.NetRootType   = pNetRoot->Type;
                        InitializeListHead(&pNetRootEntry->NetRoot.ClusterSizeSerializationQueue);

                        pNetRootEntry->Header.State = SMBCEDB_ACTIVE;

                        // Init the NetRoot Name Caches.
                        //
                        // The get file attributes name cache tracks the file attributes response
                        // from the last GFA sent to the server for a given file.
                        // NB: There is no struct defined for the extension to the GFA name
                        // cache since the extension is only an SMBPSE_FILEINFO_BUNDLE.
                        //
                        RxNameCacheInitialize(
                            &pNetRootEntry->NameCacheCtlGFABasic,
                            sizeof(FILE_BASIC_INFORMATION),
                            NAME_CACHE_NETROOT_MAX_ENTRIES);

                        RxNameCacheInitialize(
                            &pNetRootEntry->NameCacheCtlGFAStandard,
                            sizeof(FILE_STANDARD_INFORMATION),
                            NAME_CACHE_NETROOT_MAX_ENTRIES);

                        RxNameCacheInitialize(
                            &pNetRootEntry->NameCacheCtlGFAInternal,
                            sizeof(FILE_INTERNAL_INFORMATION),
                            NAME_CACHE_NETROOT_MAX_ENTRIES);

                        //
                        // The file not found name cache just tracks opens on files where the
                        // response was file not found.
                        //
                        RxNameCacheInitialize(
                            &pNetRootEntry->NameCacheCtlFNF,
                            0,
                            NAME_CACHE_NETROOT_MAX_ENTRIES);


                        SmbCeReferenceNetRootEntry(pNetRootEntry);
                        SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry);

                        if ( RtlCompareUnicodeString(
                                 pNetRoot->pNetRootName,
                                 &MRxSmbRemoteBootShare,
                                 TRUE
                                 ) == 0 ) {
                            pNetRootEntry->IsRemoteBoot = TRUE;
                        }
                    } else {
                        SmbMmFreeObject(pNetRootEntry);
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            ASSERT(pNetRootEntry != NULL);
            *pNetRootEntryPtr = pNetRootEntry;
        }
        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

VOID
SmbCepDereferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine)
/*++

Routine Description:

    This routine dereferences a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

Notes:

    Disconnects are not required for mailslot servers. They need to be
    sent to File servers only.

--*/
{
    if (pNetRootEntry != NULL) {
        LONG    FinalRefCount;
        BOOLEAN fTearDownEntry;
        BOOLEAN fDisconnectRequired;

        ASSERT((pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT) &&
               (pNetRootEntry->Header.SwizzleCount > 0));

        SmbCeAcquireResource();

        FinalRefCount = InterlockedDecrement(&pNetRootEntry->Header.SwizzleCount);

        fTearDownEntry = (FinalRefCount == 0);

        if (fTearDownEntry) {

            if (pNetRootEntry->Header.SwizzleCount == 0) {
                PSMBCEDB_SERVER_ENTRY   pServerEntry  = pNetRootEntry->pServerEntry;
                PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

                SmbCeRemoveNetRootEntryLite(pNetRootEntry->pServerEntry,pNetRootEntry);
                pNetRootEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                fTearDownEntry = TRUE;

                pVNetRootContext = SmbCeGetFirstVNetRootContext(&pServerEntry->VNetRootContexts);
                while (pVNetRootContext != NULL) {
                    ASSERT(pVNetRootContext->pNetRootEntry != pNetRootEntry);

                    pVNetRootContext = SmbCeGetNextVNetRootContext(
                                           &pServerEntry->VNetRootContexts,
                                           pVNetRootContext);
                }
            } else {
                fTearDownEntry = FALSE;
            }
        }

        SmbCeReleaseResource();

        if (fTearDownEntry) {
            SmbCeTearDownNetRootEntry(pNetRootEntry);
        }
    }
}

VOID
SmbCeTearDownNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
/*++

Routine Description:

    This routine tears down a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

--*/
{
    PAGED_CODE();

    ASSERT((pNetRootEntry->Header.SwizzleCount == 0) &&
           (pNetRootEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    SmbCeLog(("TearNetREntry %lx\n",pNetRootEntry));
    SmbLog(LOG,
           SmbCeTearDownNetRootEntry,
           LOGPTR(pNetRootEntry));

    MRxSmbCscUninitializeNetRootEntry(pNetRootEntry);

    //
    // Free storage associated with all entries in the name caches.
    //
    RxNameCacheFinalize(&pNetRootEntry->NameCacheCtlGFABasic);
    RxNameCacheFinalize(&pNetRootEntry->NameCacheCtlGFAStandard);
    RxNameCacheFinalize(&pNetRootEntry->NameCacheCtlGFAInternal);
    RxNameCacheFinalize(&pNetRootEntry->NameCacheCtlFNF);

    if (pNetRootEntry->Name.Buffer != NULL) {
        RxFreePool(pNetRootEntry->Name.Buffer);
        pNetRootEntry->Name.Buffer = NULL;
    }

    if (pNetRootEntry->VolumeInfo != NULL) {
        RxFreePool(pNetRootEntry->VolumeInfo);
        pNetRootEntry->VolumeInfo = NULL;
    }

    SmbMmFreeObject(pNetRootEntry);
}


NTSTATUS
SmbCeUpdateNetRoot(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PMRX_NET_ROOT           pNetRoot)
/*++

Routine Description:

    This routine initializes the wrapper data structure corresponding to a
    given net root entry.

Arguments:

    pNetRootEntry - the server entry

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PAGED_CODE();

    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_WILD) {
        pNetRoot->Type = pNetRootEntry->NetRoot.NetRootType;
    }

    switch (pNetRoot->Type) {
    case NET_ROOT_DISK:
        {
            pNetRoot->DeviceType = RxDeviceType(DISK);

            RxInitializeNetRootThrottlingParameters(
                &pNetRoot->DiskParameters.LockThrottlingParameters,
                MRxSmbConfiguration.LockIncrement,
                MRxSmbConfiguration.MaximumLock);
        }
        break;

    case NET_ROOT_PIPE:
        {
            pNetRoot->DeviceType = RxDeviceType(NAMED_PIPE);

            RxInitializeNetRootThrottlingParameters(
                &pNetRoot->NamedPipeParameters.PipeReadThrottlingParameters,
                MRxSmbConfiguration.PipeIncrement,
                MRxSmbConfiguration.PipeMaximum);
        }
        break;
    case NET_ROOT_COMM:
        pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
        break;
    case NET_ROOT_PRINT:
        pNetRoot->DeviceType = RxDeviceType(PRINTER);
        break;
    case NET_ROOT_MAILSLOT:
        pNetRoot->DeviceType = RxDeviceType(MAILSLOT);
        break;
    case NET_ROOT_WILD:
        break;
    default:
        ASSERT(!"Valid Net Root Type");
    }

    if (pNetRootEntry->NetRoot.DfsAware) {
        SetFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
    } else {
        ClearFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeProbeServers(
    PVOID    pContext)
/*++

Routine Description:

    This routine probes all the remote servers on which no activity has been
    detected in the recent past.

Notes:

    The current implementation of walking through the list of all servers to
    initiate echo processing will not scale very well for gateway servers. A
    different mechanism needs to be implemented.


--*/
{
    LIST_ENTRY              DiscardedServersList;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext;
    PSMBCEDB_SERVER_ENTRY pPreviousServerEntry = NULL;

    pEchoProbeContext = (PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT)pContext;

    InitializeListHead(&DiscardedServersList);

    SmbCeAcquireSpinLock();
    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        BOOLEAN               TearDownTransport = FALSE;

        if ((SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) &&
            ((pServerEntry->Header.State == SMBCEDB_ACTIVE) ||
             (pServerEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS))) {

            // The additional reference is required to keep this server entry
            // as a place marker in the list of server entries.
            // This will be released on resumption of the processinf further
            // down in this routine
            InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
            SmbCeReleaseSpinLock();

            if (pPreviousServerEntry != NULL) {
                SmbCeDereferenceServerEntry(pPreviousServerEntry);
            }

            // For loop back servers we forego the expired exchange detection
            // mechanism. Since the I/O is directed to the same machine this
            // indicates a problem with the local system.

            TearDownTransport = SmbCeDetectExpiredExchanges(pServerEntry);

            if (!TearDownTransport) {
                if ((pServerEntry->Server.SmbsReceivedSinceLastStrobe == 0) &&
                    (pServerEntry->pMidAtlas != NULL) &&
                    (pServerEntry->pMidAtlas->NumberOfMidsInUse > 0)) {
                    if (pServerEntry->Server.EchoProbeState == ECHO_PROBE_IDLE) {
                        NTSTATUS      Status;
                        LARGE_INTEGER CurrentTime,ExpiryTimeInTicks;

                        KeQueryTickCount( &CurrentTime );

                        ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

                        ExpiryTimeInTicks.QuadPart = MRxSmbConfiguration.SessionTimeoutInterval * ExpiryTimeInTicks.QuadPart;

                        pServerEntry->Server.EchoExpiryTime.QuadPart = CurrentTime.QuadPart +
                                                                ExpiryTimeInTicks.QuadPart;


                        InterlockedExchange(
                            &pServerEntry->Server.EchoProbeState,
                            ECHO_PROBE_AWAITING_RESPONSE);

                        Status = SmbCeSendEchoProbe(
                                     pServerEntry,
                                     pEchoProbeContext);

                        RxDbgTrace(0,Dbg,("Sending ECHO SMB %lx Status %lx\n",pServerEntry,Status));

                        TearDownTransport = ((Status != STATUS_SUCCESS) &&
                                             (Status != STATUS_PENDING));
                        if( TearDownTransport )
                        {
                            RxLogRetail(( "Echo failed %x (%x)\n", pServerEntry, Status ));
                        }
                    } else if (pServerEntry->Server.EchoProbeState == ECHO_PROBE_AWAITING_RESPONSE) {
                        // Compare the current time with the time at which the echo probe
                        // was sent. If the interval is greater than the response time then
                        // it can be deemed that the echo response is not forthcoming and
                        // the tear down can be initiated.
                        LARGE_INTEGER CurrentTime;

                        KeQueryTickCount( &CurrentTime );

                        if ((pServerEntry->Server.EchoExpiryTime.QuadPart != 0) &&
                            (pServerEntry->Server.EchoExpiryTime.QuadPart < CurrentTime.QuadPart)) {

                            RxLogRetail(( "Echo failed %x (timeout)\n", pServerEntry ));
                            TearDownTransport = TRUE;
                        }
                    }

                    if (TearDownTransport) {
                        RxLog(("Echo Problem for srvr%lx \n",pServerEntry));
                        SmbLog(LOG,
                               SmbCeProbeServers,
                               LOGPTR(pServerEntry)
                               LOGUSTR(pServerEntry->Name));
                    }
                } else {
                    InterlockedExchange(&pServerEntry->Server.SmbsReceivedSinceLastStrobe,0);
                }
            }

            if (TearDownTransport) {
                InterlockedIncrement(&MRxSmbStatistics.HungSessions);
                SmbCeTransportDisconnectIndicated(pServerEntry);
            }

            // reacquire the spin lock to traverse the list.
            SmbCeAcquireSpinLock();

            pPreviousServerEntry = pServerEntry;
            pServerEntry = SmbCeGetNextServerEntry(pPreviousServerEntry);
        } else {
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    }

    SmbCeReleaseSpinLock();

    if (pPreviousServerEntry != NULL) {
        SmbCeDereferenceServerEntry(pPreviousServerEntry);
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeTransportDisconnectIndicated(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine invalidates a server entry on notification from the underlying transport

Arguments:

    pServerEntry - the server entry to be dereferenced

Notes:

    The server entry and the associated net roots and sessions are marked as invalid. A
    reconnect is facilitated on other requests as and when required. In addition all
    pending requests are resumed with the appropriate error indication.

--*/
{
    NTSTATUS Status;
    BOOLEAN  ShouldResumeRequests = FALSE;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    RxDbgTrace(0,
              Dbg,
              ("SmbCeDbTransportDisconnectIndicated for %lx -- Entry\n",pServerEntry));

    // Acquire the database resource (DPC Level)
    SmbCeAcquireSpinLock();

    if (!pServerEntry->ResumeRequestsInProgress) {
        ShouldResumeRequests = TRUE;
        pServerEntry->ResumeRequestsInProgress = TRUE;

        pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;
        pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;
        pServerEntry->SecuritySignaturesActive = FALSE;

        SmbCeReferenceServerEntry(pServerEntry);

        // Increment the associated version count so as to invalidate all existing Fids
        InterlockedIncrement(&pServerEntry->Server.Version);
    }

    // release the database resource (DPC Level)
    SmbCeReleaseSpinLock();

    SmbLog(LOG,
           SmbCeTransportDisconnectIndicated,
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));

    if (ShouldResumeRequests) {
        if (RxShouldPostCompletion()) {
            InitializeListHead(&pServerEntry->WorkQueueItemForResume.List);

            RxPostToWorkerThread(
                MRxSmbDeviceObject,
                CriticalWorkQueue,
                &pServerEntry->WorkQueueItemForResume,
                SmbCeResumeAllOutstandingRequestsOnError,
                pServerEntry);
        } else {
            SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);
        }
    }

    RxDbgTrace(0,
              Dbg,
              ("SmbCeTransportDisconnectIndicated -- Exit\n"));
}

VOID
SmbCeHandleTransportInvalidation(
    IN PSMBCE_TRANSPORT  pTransport)
/*++

Routine Description:

    This routine invalidates all servers using a particular transport. This is different from
    a disconnect indication in which one server is invalidated. In this case a transport is being
    removed/invalidated locally and all servers using that transport must be invalidated

Arguments:

    pTransport  - the transport being invalidated

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;

            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
        }

        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
    }

    SmbCeReleaseSpinLock();

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pPrevServerEntry;
        BOOLEAN               fDereferencePrevServerEntry = FALSE;

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            SmbCeReleaseResource();

            SmbCeTransportDisconnectIndicated(pServerEntry);

            SmbCeReferenceServerEntry(pServerEntry);

            // the reference count of Server Entry will be taken away while the transport
            // is torn down, which prevents the server tranports being torn down again at
            // time the server entry being freed.
            SmbCeUninitializeServerTransport(pServerEntry,
                                             SmbCeCompleteUninitializeServerTransport,
                                             pServerEntry);

            SmbCeAcquireResource();

            if (pServerEntry->PreferredTransport != NULL) {
                SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                pServerEntry->PreferredTransport = NULL;
            }

            fDereferencePrevServerEntry = TRUE;
        }

        pPrevServerEntry = pServerEntry;
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);

        if (fDereferencePrevServerEntry) {
            SmbCeDereferenceServerEntry(pPrevServerEntry);
        }
    }

    SmbCeReleaseResource();
}

VOID
SmbCeResumeOutstandingRequests(
    PSMBCEDB_REQUESTS pRequests,
    NTSTATUS          RequestStatus)
/*++

Routine Description:

    This routine resumes the outstanding requests with the appropriate status

Arguments:

    pRequests - the list of requests

    RequestStatus - the resumption status ..

Notes:

    As a side effect the list of requests is torn down.

--*/
{
    NTSTATUS               Status;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

    // Resume all the outstanding reconnect requests that were held up because an earlier
    // reconnect request was under way.
    // Iterate over the list of pending requests and resume all of them

    pRequestEntry = SmbCeGetFirstRequestEntry(pRequests);
    while (pRequestEntry != NULL) {
        PSMB_EXCHANGE pExchange = pRequestEntry->ReconnectRequest.pExchange;

        RxDbgTrace(0, Dbg, ("Resuming outstanding reconnect request exchange %lx \n",pExchange));

        pExchange->Status = RequestStatus;

        SmbCeDecrementPendingLocalOperations(pExchange);

        // Resume the exchange.
        if (pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent == NULL) {
            if (RequestStatus == STATUS_SUCCESS) {
                Status = SmbCeResumeExchange(pExchange);
            } else {
                // Invoke the error handler
                RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pRequestEntry->Request.pExchange));
                SmbCeFinalizeExchange(pExchange);
            }
        } else {
            KeSetEvent(
                pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }

        // Delete the request entry
        SmbCeRemoveRequestEntryLite(pRequests,pRequestEntry);

        // Tear down the continuation entry
        SmbCeTearDownRequestEntry(pRequestEntry);

        // Skip to the next one.
        pRequestEntry = SmbCeGetFirstRequestEntry(pRequests);
    }
}

VOID
SmbCeResumeAllOutstandingRequestsOnError(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine handles the resumption of all outstanding requests on an error

Arguments:

    pServerEntry  - the Server entry which is being classified as disconnected
Notes:

    This routine requires the caller to have obtained a reference on the corresponding
    server entry. This is required because invocation of this routine can be posted
    which implies that a reference is required to avoid premature destruction of
    the associated server entry.

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    SMBCEDB_REQUESTS       Requests;
    SMBCEDB_REQUESTS       MidRequests;

    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    PMID_ATLAS             pMidAtlas;
    PSMB_EXCHANGE          pNegotiateExchange = NULL;
    LIST_ENTRY             ExpiredExchanges;

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Invoked \n");
    InitializeListHead(&ExpiredExchanges);
    InitializeListHead(&Requests.ListHead);

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    if (pServerEntry->Header.State != SMBCEDB_DESTRUCTION_IN_PROGRESS) {
        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        SmbCeDereferenceServerEntry(pServerEntry);

        return;
    }

    if (pServerEntry->pNegotiateExchange != NULL) {
        if (pServerEntry->pNegotiateExchange->ReceivePendingOperations > 0) {
            pNegotiateExchange = SmbResetServerEntryNegotiateExchange(pServerEntry);
        }
    }

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.

    // Copy all the MID assignment requests pending.
    SmbCeTransferRequests(&MidRequests,&pServerEntry->MidAssignmentRequests);

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->OutstandingRequests,pTempRequestEntry);
            SmbCeAddRequestEntryLite(&Requests,pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
        }
    }

    // The exchanges that have valid MID's assigned to them fall into two categories
    // Those that have a ReceivePendingOperation count of > 0 and those that have
    // a ReceievePendingOperation count of zero. For all the exchanges that belong
    // to the first category the finalize ( quiescent state ) routine must be invoked
    // since no receives will be forthcoming. For those exchanges that are in the
    // second category it is sufficient to mark the MID as being invalid. The
    // finalization( quiescent state ) routine is going to be called on completion
    // of other opertaions in this case.

    pMidAtlas = pServerEntry->pMidAtlas;
    if (pMidAtlas != NULL) {
        PVOID  pContext;
        USHORT MidsProcessed = 0;
        USHORT NumberOfMidsInUse;
        USHORT MaximumNumberOfMids;
        USHORT NextMid = 0;

        MaximumNumberOfMids = FsRtlGetMaximumNumberOfMids(pMidAtlas);
        NumberOfMidsInUse = FsRtlGetNumberOfMidsInUse(pMidAtlas);

        while ((NumberOfMidsInUse > MidsProcessed) &&
               (NextMid < MaximumNumberOfMids)) {
            pContext = FsRtlMapMidToContext(pMidAtlas,NextMid);

            if (pContext != NULL) {
                PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pContext;

                pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

                pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
                pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;

                if ((pExchange->ReceivePendingOperations > 0) &&
                    ((pExchange->LocalPendingOperations > 0) ||
                    (pExchange->CopyDataPendingOperations > 0) ||
                    (pExchange->SendCompletePendingOperations > 0))) {
                    // There are other pending operations. By merely setting the
                    // pending receive operations to zero, the finalization of
                    // the exchange is ensured.
                    pExchange->ReceivePendingOperations = 0;
                }

                if (pExchange->ReceivePendingOperations ==  0) {
                    FsRtlMapAndDissociateMidFromContext(pMidAtlas,NextMid,&pContext);
                }

                MidsProcessed++;
            }

            NextMid++;
        }
    }

    // Transfer all the active exchanges to expired exchanges. This will prevent these
    // exchanges from being considered for time outs again.
    if (!IsListEmpty(&pServerEntry->ActiveExchanges)) {
        pServerEntry->ExpiredExchanges.Blink->Flink = pServerEntry->ActiveExchanges.Flink;
        pServerEntry->ActiveExchanges.Flink->Blink = pServerEntry->ExpiredExchanges.Blink;

        pServerEntry->ExpiredExchanges.Blink = pServerEntry->ActiveExchanges.Blink;
        pServerEntry->ActiveExchanges.Blink->Flink = &pServerEntry->ExpiredExchanges;

        InitializeListHead(&pServerEntry->ActiveExchanges);
    }

    // Splice together all the requests that are awaiting the completion of the
    // session/netroot construction.

    pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
    while (pSessionEntry != NULL) {
        if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
            pSessionEntry->Header.State = SMBCEDB_INVALID;
        }

        if (!IsListEmpty(&pSessionEntry->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pSessionEntry->Requests.ListHead.Flink;
            pSessionEntry->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pSessionEntry->Requests.ListHead.Blink;
            pSessionEntry->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pSessionEntry->Requests);
        }

        pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
    }

    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        if (pNetRootEntry->Header.State == SMBCEDB_ACTIVE) {
            pNetRootEntry->Header.State = SMBCEDB_INVALID;
        }

        if (!IsListEmpty(&pNetRootEntry->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pNetRootEntry->Requests.ListHead.Flink;
            pNetRootEntry->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pNetRootEntry->Requests.ListHead.Blink;
            pNetRootEntry->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pNetRootEntry->Requests);
        }

        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }

    pVNetRootContext = SmbCeGetFirstVNetRootContext(&pServerEntry->VNetRootContexts);
    while (pVNetRootContext != NULL) {
        pVNetRootContext->Header.State = SMBCEDB_INVALID;
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;

        if (!IsListEmpty(&pVNetRootContext->Requests.ListHead)) {
            Requests.ListHead.Blink->Flink = pVNetRootContext->Requests.ListHead.Flink;
            pVNetRootContext->Requests.ListHead.Flink->Blink = Requests.ListHead.Blink;

            Requests.ListHead.Blink = pVNetRootContext->Requests.ListHead.Blink;
            pVNetRootContext->Requests.ListHead.Blink->Flink = &Requests.ListHead;

            SmbCeInitializeRequests(&pVNetRootContext->Requests);
        }

        pVNetRootContext = SmbCeGetNextVNetRootContext(
                               &pServerEntry->VNetRootContexts,
                               pVNetRootContext);
    }

    pVNetRootContext = SmbCeGetFirstVNetRootContext(&MRxSmbScavengerServiceContext.VNetRootContexts);
    while (pVNetRootContext != NULL &&
           pVNetRootContext->pServerEntry == pServerEntry) {
        // prevent the VNetRootContexts on the scavenger list from being reused
        pVNetRootContext->Header.State = SMBCEDB_INVALID;
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;

        pVNetRootContext = SmbCeGetNextVNetRootContext(
                               &MRxSmbScavengerServiceContext.VNetRootContexts,
                               pVNetRootContext);
    }

    pServerEntry->pMidAtlas          = NULL;

    if (pServerEntry->NegotiateInProgress) {
        pServerEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
    } else {
        pServerEntry->Header.State = SMBCEDB_INVALID;
    }

    pServerEntry->ResumeRequestsInProgress = FALSE;

    SmbCeReleaseSpinLock();

    if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        SmbCeInitiateDisconnect(pServerEntry);
    }

    SmbCeReleaseResource();

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing outsanding request \n");
    SmbCeResumeOutstandingRequests(&Requests,STATUS_CONNECTION_DISCONNECTED);

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing MID request \n");
    SmbCeResumeDiscardedMidAssignmentRequests(
        &MidRequests,
        STATUS_CONNECTION_DISCONNECTED);

    // Resume all the outstanding requests with the error indication
    // The FsRtlDestroyMidAtlas destroys the Mid atlas and at the same
    // time invokes the specified routine on each valid context.
    if (pMidAtlas != NULL) {
        FsRtlDestroyMidAtlas(pMidAtlas,SmbCeFinalizeExchangeOnDisconnect);
    }

    if (pNegotiateExchange != NULL) {
        pNegotiateExchange->Status    = STATUS_CONNECTION_DISCONNECTED;
        pNegotiateExchange->SmbStatus = STATUS_CONNECTION_DISCONNECTED;
        pNegotiateExchange->ReceivePendingOperations = 0;

        SmbCeDecrementPendingLocalOperationsAndFinalize(pNegotiateExchange);
    }

    // The remaining ECHO exchanges on the expired exchanges list in the server entry
    // needs to be finalized as well.

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    if (!IsListEmpty(&pServerEntry->ExpiredExchanges)) {
        PLIST_ENTRY pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = pServerEntry->ExpiredExchanges.Flink;

        while (pListEntry != &pServerEntry->ExpiredExchanges) {
            PLIST_ENTRY pNextListEntry = pListEntry->Flink;

            pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
            if ((pExchange->Mid == SMBCE_ECHO_PROBE_MID) &&
                !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED) &&
                ((pExchange->ReceivePendingOperations > 0) ||
                 (pExchange->LocalPendingOperations > 0) ||
                 (pExchange->CopyDataPendingOperations > 0) ||
                 (pExchange->SendCompletePendingOperations > 0))) {
                RemoveEntryList(&pExchange->ExchangeList);
                InsertTailList(&ExpiredExchanges,&pExchange->ExchangeList);
                InterlockedIncrement(&pExchange->LocalPendingOperations);
            }

            pListEntry = pNextListEntry;
        }
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    while (!IsListEmpty(&ExpiredExchanges)) {
        PLIST_ENTRY   pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = ExpiredExchanges.Flink;
        RemoveHeadList(&ExpiredExchanges);

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
        InitializeListHead(&pExchange->ExchangeList);

        RxLog(("Finalizing scavenged exchange %lx Type %ld\n",pExchange,pExchange->Type));
        SmbLog(LOG,
               SmbCeResumeAllOutstandingRequestsOnError,
               LOGPTR(pExchange)
               LOGUCHAR(pExchange->Type));
        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Exit \n");
    SmbCeDereferenceServerEntry(pServerEntry);
}

VOID
SmbCeFinalizeAllExchangesForNetRoot(
    PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

    This routine handles the resumption of all outstanding requests on a forced
    finalization of a connection

Arguments:

    pNetRoot - the NetRoot which is being fianlized forcibly

Notes:

--*/
{
    PMRX_SRV_CALL         pSrvCall;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    SMBCEDB_REQUESTS       Requests;
    LIST_ENTRY             ExpiredExchanges;

    PSMB_EXCHANGE pExchange;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    PLIST_ENTRY            pListEntry;

    pSrvCall = pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    InitializeListHead(&Requests.ListHead);
    InitializeListHead(&ExpiredExchanges);

    SmbCeAcquireSpinLock();

    // Walk through the list of active exchanges, and the pending requests to
    // weed out the exchanges for the given VNET_ROOT.

    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        pExchange = pRequestEntry->GenericRequest.pExchange;

        if ((pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) &&
            (pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->OutstandingRequests,pTempRequestEntry);
            SmbCeAddRequestEntryLite(&Requests,pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
        }
    }

    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->MidAssignmentRequests);
    while (pRequestEntry != NULL) {
        pExchange = pRequestEntry->GenericRequest.pExchange;

        ASSERT(pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST);

        if ((pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST) &&
            (pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {

            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->MidAssignmentRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->MidAssignmentRequests,pTempRequestEntry);

            // Signal the waiter for resumption
            pTempRequestEntry->MidRequest.pResumptionContext->Status = STATUS_CONNECTION_DISCONNECTED;
            SmbCeResume(pTempRequestEntry->MidRequest.pResumptionContext);

            SmbCeTearDownRequestEntry(pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->MidAssignmentRequests,pRequestEntry);
        }
    }

    pListEntry = pServerEntry->ActiveExchanges.Flink;

    while (pListEntry != &pServerEntry->ActiveExchanges) {
        PLIST_ENTRY pNextListEntry = pListEntry->Flink;

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);

        if ((pExchange->SmbCeContext.pVNetRoot != NULL) &&
            (pExchange->SmbCeContext.pVNetRoot->pNetRoot == pNetRoot)) {


            if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
                if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                    NTSTATUS LocalStatus;

                    LocalStatus = SmbCepDiscardMidAssociatedWithExchange(
                                      pExchange);

                    ASSERT(LocalStatus == STATUS_SUCCESS);
                }

                if ((pExchange->ReceivePendingOperations > 0) ||
                    (pExchange->LocalPendingOperations > 0) ||
                    (pExchange->CopyDataPendingOperations > 0) ||
                    (pExchange->SendCompletePendingOperations > 0)) {

                    RemoveEntryList(&pExchange->ExchangeList);
                    InsertTailList(&ExpiredExchanges,&pExchange->ExchangeList);
                    InterlockedIncrement(&pExchange->LocalPendingOperations);
                }
            }
        }

        pListEntry = pNextListEntry;
    }

    SmbCeReleaseSpinLock();

    while (!IsListEmpty(&ExpiredExchanges)) {
        PLIST_ENTRY   pListEntry;
        PSMB_EXCHANGE pExchange;

        pListEntry = ExpiredExchanges.Flink;
        RemoveHeadList(&ExpiredExchanges);

        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
        InitializeListHead(&pExchange->ExchangeList);

        RxLog(("Finalizing scavenged exchange %lx Type %ld\n",pExchange,pExchange->Type));
        SmbLog(LOG,
               SmbCeFinalizeAllExchangesForNetRoot,
               LOGPTR(pExchange)
               LOGUCHAR(pExchange->Type));

        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;
        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    SmbCeResumeOutstandingRequests(&Requests,STATUS_CONNECTION_DISCONNECTED);
}

VOID
SmbCeTearDownRequestEntry(
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry)
/*++

Routine Description:

    This routine tears down a request entry

Arguments:

    pRequestEntry - the request entry to be torn down

Notes:

--*/
{
    SmbMmFreeObject(pRequestEntry);
}

//
// The connection engine database initializtion/tear down routines
//

extern NTSTATUS
SmbMmInit();

extern VOID
SmbMmTearDown();

KIRQL           s_SmbCeDbSpinLockSavedIrql;
KSPIN_LOCK      s_SmbCeDbSpinLock;
ERESOURCE       s_SmbCeDbResource;
ERESOURCE       s_SmbSecuritySignatureResource;
SMBCEDB_SERVERS s_DbServers;
BOOLEAN         s_SmbCeDbSpinLockAcquired;

NTSTATUS
SmbCeDbInit()
/*++

Routine Description:

    This routine initializes the SMBCe database

Notes:

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // Initialize the lists associated with various database entities
    InitializeListHead(&s_DbServers.ListHead);

    // Initialize the resource associated with the database.
    KeInitializeSpinLock(&s_SmbCeDbSpinLock );
    ExInitializeResource(&s_SmbCeDbResource);
    ExInitializeResource(&s_SmbSecuritySignatureResource);
    s_SmbCeDbSpinLockAcquired = FALSE;

    MRxSmbInitializeSmbCe();

    // Initialize the memory management data structures.
    Status = SmbMmInit();

    return Status;
}

VOID
SmbCeDbTearDown()
/*++

Routine Description:

    This routine tears down the SMB connection engine database

Notes:

--*/
{
    // Walk through the list of servers and tear them down.
    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    KEVENT ServerEntryTearDownEvent;
    BOOLEAN NeedToWait = FALSE;

    KeInitializeEvent(
        &ServerEntryTearDownEvent,
        NotificationEvent,
        FALSE);

    SmbCeStartStopContext.pServerEntryTearDownEvent = &ServerEntryTearDownEvent;

    // The CSC code obtains references on all the servers that are operating in
    // disconnected mode. Force it to release the references since we are shutting
    // down.
    CscTransitionServerToOnline(0);

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();

    if (pServerEntry != NULL) {
        SmbCeReferenceServerEntry(pServerEntry);
        NeedToWait = TRUE;
    }

    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pTempServerEntry;

        pTempServerEntry = pServerEntry;
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);

        if (pServerEntry != NULL) {
            SmbCeReferenceServerEntry(pServerEntry);
        }

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        pTempServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;
        pTempServerEntry->ServerStatus = RX_MAP_STATUS(REDIRECTOR_PAUSED);
        SmbCeResumeAllOutstandingRequestsOnError(pTempServerEntry);

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    MRxSmbUninitializeTransport();
    MRxSmbTearDownSmbCe();

    if (NeedToWait) {
        KeWaitForSingleObject(
            &ServerEntryTearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }

    // Tear down the connection engine memory management data structures.
    SmbMmTearDown();
}

NTSTATUS
FindServerEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_SERVER_ENTRY *ppServerEntry
)
/*++

Routine Description:

    Given a UNC path of the form \\server\share, this routine looks up the redir
    in-memory data structures to locate such s SMBCEDB_SERVER_ENTRY for the server

Arguments:

    lpuServerShareName  \\server\share

    ppServerEntry      Contains the server entry if successful

Notes:

    The server entry is refcounted, hence the caller must dereference it after use by
    calling SmbCeDereferenceServerEntry

--*/
{

    UNICODE_STRING unistrServerName;
    USHORT  *lpuT = lpuServerShareName;
    DWORD   dwlenServerShare, dwlenServer=0;

    if ((*lpuT++ != (USHORT)'\\') || (*lpuT++ != (USHORT)'\\'))
    {
        return STATUS_INVALID_PARAMETER;
    }


    for (dwlenServerShare = 1; *lpuT; lpuT++, dwlenServerShare++)
    {
        if (*lpuT == (USHORT)'\\')
        {
            if (dwlenServer)
            {
                break;
            }
            else
            {
                dwlenServer = dwlenServerShare; // length of the \server part
            }
        }
    }

    unistrServerName.Length = unistrServerName.MaximumLength = (USHORT)(dwlenServer * sizeof(USHORT));
    unistrServerName.Buffer = lpuServerShareName+1;

    SmbCeAcquireResource();

    try
    {
        *ppServerEntry = SmbCeFindServerEntry(&unistrServerName, SMBCEDB_FILE_SERVER, NULL);

        if (!*ppServerEntry)
        {
            *ppServerEntry = SmbCeFindDfsServerEntry(&unistrServerName, SMBCEDB_FILE_SERVER);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        SmbCeReleaseResource();
        return STATUS_UNSUCCESSFUL;
    }

    SmbCeReleaseResource();

    if (*ppServerEntry)
    {
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
FindNetRootEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_NET_ROOT_ENTRY *ppNetRootEntry
)
/*++

Routine Description:

    Given a UNC path of the form \\server\share, this routine looks up the redir
    in-memory data structures to locate such a NETROOT

Arguments:

    lpuServerShareName  \\server\share

    ppNetRootEntry      Contains the netroot entry if successful.

Notes:

    The netroot entry is refcounted, hence the caller must dereference it after use by
    calling SmbCeDereferenceNetRootEntry

--*/
{

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;
    UNICODE_STRING unistrServerName, unistrServerShare;
    USHORT  *lpuT = lpuServerShareName, *lpuDfsShare=NULL, *lpuSav;
    DWORD   dwlenServerShare, dwlenServer=0;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if ((*lpuT++ != (USHORT)'\\') || (*lpuT++ != (USHORT)'\\'))
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (dwlenServerShare = 1; *lpuT; lpuT++, dwlenServerShare++)
    {
        if (*lpuT == (USHORT)'\\')
        {
            if (dwlenServer)
            {
                break;
            }
            else
            {
                dwlenServer = dwlenServerShare; // length of the \server part
            }
        }
    }

    ASSERT((dwlenServerShare>dwlenServer));

    unistrServerName.Length = unistrServerName.MaximumLength = (USHORT)(dwlenServer * sizeof(USHORT));
    unistrServerName.Buffer = lpuServerShareName+1;

    unistrServerShare.Length = unistrServerShare.MaximumLength =  (USHORT)(dwlenServerShare * sizeof(USHORT));
    unistrServerShare.Buffer = lpuServerShareName+1;

    SmbCeAcquireResource();

    try
    {
        // lookup in standard places

        pServerEntry = SmbCeFindServerEntry(&unistrServerName, SMBCEDB_FILE_SERVER, NULL);
        if (pServerEntry)
        {
            pNetRootEntry = SmbCeFindNetRootEntry(pServerEntry, &unistrServerShare);
            SmbCeDereferenceServerEntry(pServerEntry);

            if (pNetRootEntry)
            {
                goto bailout;
            }
        }

        // now look to see if a DFS alternate has this share

        pServerEntry = SmbCeGetFirstServerEntry();

        while (pServerEntry != NULL) {

            DWORD   dwAllocationSize = 0;

            if ((RtlCompareUnicodeString(
                        &unistrServerName,
                        &pServerEntry->DfsRootName,
                        TRUE) == 0)) {

                dwAllocationSize =  pServerEntry->Name.MaximumLength+
                                    (dwlenServerShare-dwlenServer+2) * sizeof(USHORT);

                lpuDfsShare =  RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    dwAllocationSize,
                                    MRXSMB_SESSION_POOLTAG);
                if (!lpuDfsShare)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto bailout;
                }

                ASSERT(dwAllocationSize > pServerEntry->Name.MaximumLength);

                unistrServerShare.Length = (USHORT)(pServerEntry->Name.Length + (dwlenServerShare-dwlenServer) * sizeof(USHORT));
                unistrServerShare.MaximumLength = (USHORT)(pServerEntry->Name.MaximumLength+
                                                      (dwlenServerShare-dwlenServer+2) * sizeof(USHORT));

                memcpy(lpuDfsShare, pServerEntry->Name.Buffer, pServerEntry->Name.Length);
                memcpy(&lpuDfsShare[pServerEntry->Name.Length/sizeof(USHORT)],
                       &(unistrServerShare.Buffer[dwlenServer]),
                        (dwlenServerShare-dwlenServer) * sizeof(USHORT));

                lpuSav = unistrServerShare.Buffer;
                unistrServerShare.Buffer = lpuDfsShare;

                pNetRootEntry = SmbCeFindNetRootEntry(pServerEntry, &unistrServerShare);

                unistrServerShare.Buffer = lpuSav;

                RxFreePool(lpuDfsShare);

                // stop if we found it
                if (pNetRootEntry)
                {
                    break;
                }
            }

            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto bailout;
    }

bailout:
    if (pNetRootEntry)
    {
        SmbCeReferenceNetRootEntry(pNetRootEntry);
        *ppNetRootEntry = pNetRootEntry;
        Status = STATUS_SUCCESS;
    }

    SmbCeReleaseResource();

    return Status;
}

NTSTATUS
MRxSmbCscCachingBitsFromCompleteUNCPath(
    PWSTR   lpServerShare,
    ULONG   *lpulBits
    )
/*++

Routine Description:

    Given a UNC path of the form \\server\share, this routine checks to see whether
    such a NETROOT exists, and if so, it gets the SMB flags for that entry

Arguments:

    lpuServerShareName  \\server\share

    lpulBits            SMB bits

Notes:

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry=NULL;
    NTSTATUS Status;

    if ((Status = FindNetRootEntryFromCompleteUNCPath(lpServerShare, &pNetRootEntry)) == STATUS_SUCCESS)
    {
        // convert these bits to those defined in csc\inc\shdcom.h
        *lpulBits = (pNetRootEntry->NetRoot.CscFlags << 4);

        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    return Status;
}

NTSTATUS
MRxSmbCscServerStateFromCompleteUNCPath(
    PWSTR   lpServerShare,
    BOOL    *lpfOnline,
    BOOL    *lpfPinnedOffline
    )
{
    PSMBCEDB_SERVER_ENTRY   pServerEntry = NULL;
    NTSTATUS Status;

    if ((Status = FindServerEntryFromCompleteUNCPath(lpServerShare, &pServerEntry)) == STATUS_SUCCESS)
    {
        *lpfOnline = (pServerEntry->Server.CscState == ServerCscShadowing);
        *lpfPinnedOffline = (pServerEntry->Server.IsPinnedOffline == TRUE);

        SmbCeDereferenceServerEntry(pServerEntry);
    }

    return Status;

}

PSMBCEDB_SESSION_ENTRY
SmbCeGetDefaultSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG SessionId,
    PLUID pLogonId
    )
/*++

Routine Description:

    This routine returns the session entry from the default sessions list.

Arguments:

    pServerEntry - Server entry

    SessionId    - Hydra session Id.

    pLogonId     - the logon id.

Notes:

    This is called with the SmbCe spinlock held.

--*/
{
    PLIST_ENTRY pListEntry;
    PSMBCEDB_SESSION_ENTRY pSession;
    PSMBCEDB_SESSION_ENTRY pReturnSession = NULL;

    ASSERT( pServerEntry != NULL );

    pListEntry = pServerEntry->Sessions.DefaultSessionList.Flink;

    while( pListEntry != &pServerEntry->Sessions.DefaultSessionList ) {

        pSession = CONTAINING_RECORD( pListEntry, SMBCEDB_SESSION_ENTRY, DefaultSessionLink );

        if( pSession->Session.SessionId == SessionId ) {
            if (RtlEqualLuid(
                    &pSession->Session.LogonId,
                    pLogonId)) {
                pReturnSession = pSession;
                break;
            }
        }

        pListEntry = pListEntry->Flink;
    }

    return( pReturnSession );
}

VOID
SmbCeRemoveDefaultSessionEntry(
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry
    )
/*++

Routine Description:

    This routine removes the session entry from the default sessions list.

Arguments:

    pServerEntry - Server entry

    SessionId    - Hydra session Id.

    pLogonId     - the logon id.

Notes:

    This is called with the SmbCe spinlock held.

--*/
{
    if( pDefaultSessionEntry &&
        pDefaultSessionEntry->DefaultSessionLink.Flink ) {

        RemoveEntryList( &pDefaultSessionEntry->DefaultSessionLink );

        pDefaultSessionEntry->DefaultSessionLink.Flink = NULL;
        pDefaultSessionEntry->DefaultSessionLink.Blink = NULL;
    }
}

VOID
MRxSmbTrackRefCount(
      PVOID   pInstance,
      PCHAR   FileName,
      ULONG   Line)
{
    LONG State = ((PSMBCE_OBJECT_HEADER)pInstance)->State;
    LONG RefCount = ((PSMBCE_OBJECT_HEADER)pInstance)->SwizzleCount;
    SMBCEDB_OBJECT_TYPE ObjectType = ((PSMBCE_OBJECT_HEADER)pInstance)->ObjectType;

    switch (ObjectType) {
    case SMBCEDB_OT_SERVER :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("  Ref ServerEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("  Ref ServerEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(SERVER,MRxSmbRefServerEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_NETROOT :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("  Ref NetRootEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("  Ref NetRootEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(NETROOT,MRxSmbRefNetRootEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_SESSION :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("  Ref SessionEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("  Ref SessionEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(SESSION,MRxSmbRefSessionEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_VNETROOTCONTEXT :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_VNETROOT_CONTEXT)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("  Ref VNetRootConext %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("  Ref VNetRootContext %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(VNETROOT,MRxSmbRefVNetRootContext,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;
    }
}

VOID
MRxSmbTrackDerefCount(
      PVOID   pInstance,
      PCHAR   FileName,
      ULONG   Line)
{
    LONG State = ((PSMBCE_OBJECT_HEADER)pInstance)->State;
    LONG RefCount = ((PSMBCE_OBJECT_HEADER)pInstance)->SwizzleCount;
    SMBCEDB_OBJECT_TYPE ObjectType = ((PSMBCE_OBJECT_HEADER)pInstance)->ObjectType;

    switch (ObjectType) {
    case SMBCEDB_OT_SERVER :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("Deref ServerEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("Deref ServerEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(SERVER,MRxSmbDerefServerEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_NETROOT :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("Deref NetRootEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("Deref NetRootEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(NETROOT,MRxSmbDerefNetRootEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_SESSION :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("Deref SessionEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("Deref SessionEntry %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(SESSION,MRxSmbDerefSessionEntry,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;

    case SMBCEDB_OT_VNETROOTCONTEXT :
        if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_VNETROOT_CONTEXT)) {
            if (MRxSmbReferenceTracingValue & MRXSMB_LOG_REF_TRACKING) {
                RxLog(("Deref VNetRootConext %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName));
            }

            if (MRxSmbReferenceTracingValue & MRXSMB_PRINT_REF_TRACKING) {
                DbgPrint("Deref VNetRootContext %lx %d %d %ld %s\n",pInstance,State,RefCount,Line,FileName);
            }
        }

        SmbLog(VNETROOT,MRxSmbDerefVNetRootContext,LOGPTR(pInstance)LOGULONG(State)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbcedb.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:

    The various data structures created by the mini rdr (Server Entries, Session Entries
    and Net Root Entries) are used in asynchronous operations. Hence a reference count
    mechanism is used to keep track of the creation/use/destruction of these data structures.

    The usage patterns for these data structures falls into one of two cases

      1) A prior reference exists and access is required

      2) A new reference need be created.

    These two scenarios are dealt with by two sets of access routines
      SmbCeGetAssociatedServerEntry,
      SmbCeGetAssociatedNetRootEntry
    and
      SmbCeReferenceAssociatedServerEntry,
      SmbCeReferenceAssociatedNetRootEntry.

    The first set of routines include the necessary asserts in a debug build to ensure that a
    reference does exist.

    The dereferencing mechanism is provided by the following routines
      SmbCeDereferenceServerEntry,
      SmbCeDereferenceSessionEntry,
      SmbCeDereferenceNetRootEntry.

    The dereferencing routines also ensure that the data structures are deleted if the reference
    count is zero.

    The construction of the various SMB mini redirector structures ( Server,Session and Net root entries )
    follow a two phase protocol since network traffic is involved. The first set of routines
    initiate the construction while the second set of routines complete the construction.

    These routines are
      SmbCeInitializeServerEntry,
      SmbCeCompleteServerEntryInitialization,
      SmbCeInitializeSessionEntry,
      SmbCeCompleteSessionEntryInitialization,
      SmbCeInitializeNetRootEntry,
    and SmbCeCompleteNetRootEntryInitialization.

    Each of the SMB mini redirector data structures  embodies a state diagram that consist of
    the following states

      SMBCEDB_ACTIVE,                    // the instance is in use
      SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
      SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
      SMBCEDB_RECYCLE,                   // the instance is available for recycling
      SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
      SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
      SMBCEDB_DESTRUCTION_IN_PROGRESS    // the instance destruction is in progress

    A SMB MRX data structure instance begins its life in SMBCEDB_START_CONSTRUCTION state.
    When the construction is initiated the state transitions to SMBCEDB_CONSTRUCTION_IN_PROGRESS.

    On completion of the construction the state is either transitioned to SMBCEDB_ACTIVE if the
    construction was successful. If the construction was not successful the state transitions to
    SMBCEDB_MARKED_FOR_DELETION if scavenging is to be done or SMBCEDB_DESTRUCTION_IN_PROGRESS
    if the tear down has been initiated.

    An instance in the SMBCEDB_ACTIVE state transitions to SMBCEDB_INVALID when the transport/remote server
    information associated with it has been invalidated due to disconnects etc. This state is a
    cue for a reconnect attempt to be initiated.

    The SMBCEDB_RECYCLE state is not in use currently.

    All the state transitions are accomplished by the following set of routines which ensure that
    the appropriate concurrency control action is taken.

         SmbCeUpdateServerEntryState,
         SmbCeUpdateSessionEntryState,
    and  SmbCeUpdateNetRootEntryState.

    Since the Server,Session and NetRoot entries are often referenced together the following
    two routines provide a batching mechanism to minimize the concurrency control overhead.

      SmbCeReferenceAssociatedEntries,
      SmbCeDereferenceEntries

    In addition this file also contains helper functions to access certain fields of
    MRX_SRV_CALL,MRX_NET_ROOT and MRX_V_NET_ROOT which are intrepreted differently by the SMB
    mini redirector.

--*/

#ifndef _SMBCEDB_H_
#define _SMBCEDB_H_
#include <smbcedbp.h>    // To accomodate inline routines.

//
// All the routines below return the referenced object if successful. It is the caller's
// responsibility to dereference them subsequently.
//

PSMBCEDB_SERVER_ENTRY
SmbCeFindServerEntry(
    PUNICODE_STRING pServerName,
    SMBCEDB_SERVER_TYPE ServerType,
    PRX_CONNECTION_ID   RxConnectionId);

extern NTSTATUS
SmbCeFindOrConstructServerEntry(
    PUNICODE_STRING       pServerName,
    SMBCEDB_SERVER_TYPE   ServerType,
    PSMBCEDB_SERVER_ENTRY *pServerEntryPtr,
    PBOOLEAN              pNewServerEntry,
    PRX_CONNECTION_ID     RxConnectionId);

extern NTSTATUS
SmbCeInitializeServerEntry(
    IN     PMRX_SRV_CALL                 pSrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext,
    IN     BOOLEAN                       DeferNetworkInitialization);

extern NTSTATUS
SmbCeFindOrConstructSessionEntry(
    IN PMRX_V_NET_ROOT pVirtualNetRoot,
    OUT PSMBCEDB_SESSION_ENTRY *pSessionEntryPtr);

extern NTSTATUS
SmbCeFindOrConstructNetRootEntry(
    IN PMRX_NET_ROOT  pNetRoot,
    OUT PSMBCEDB_NET_ROOT_ENTRY *pNetRootEntryPtr);

extern NTSTATUS
SmbCeFindOrConstructVNetRootContext(
    IN OUT PMRX_V_NET_ROOT pVNetRoot,
    IN     BOOLEAN         fDeferNetworkInitialization,
    IN     BOOLEAN         fCscAgentOpen);

//
// The finalization routines are invoked in the context of a worker thread to finalize
// the construction of an entry as well as resume other entries waiting for it.
//

extern VOID
SmbCeCompleteServerEntryInitialization(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    NTSTATUS              Status);

extern VOID
SmbCeCompleteSessionEntryInitialization(
    PVOID    pSessionEntry,
    NTSTATUS Status,
    BOOLEAN  SecuritySignatureReturned);

extern VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pVNetRootContextEntry);

extern VOID
SmbReferenceRecord(
    PREFERENCE_RECORD pReferenceRecord,
    PVOID FileName,
    ULONG FileLine);

//
// Routines for referencing/dereferencing SMB Mini redirector information associated with
// the wrapper data structures.
//

INLINE PSMBCEDB_SERVER_ENTRY
SmbCeGetAssociatedServerEntry(
    PMRX_SRV_CALL pSrvCall)
{
   ASSERT(pSrvCall->Context != NULL);
   return (PSMBCEDB_SERVER_ENTRY)(pSrvCall->Context);
}

INLINE PSMBCE_V_NET_ROOT_CONTEXT
SmbCeGetAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot)
{
   ASSERT(pVNetRoot != NULL);
   return (PSMBCE_V_NET_ROOT_CONTEXT)(pVNetRoot->Context);
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeGetAssociatedNetRootEntry(
    PMRX_NET_ROOT pNetRoot)
{
   ASSERT(pNetRoot->Context != NULL);
   return (PSMBCEDB_NET_ROOT_ENTRY)(pNetRoot->Context);
}

//
// All the macros for referencing and dereferencing begin with a prefix SmbCep...
// The p stands for a private version which is used for implementing reference tracking.
// By selectively turning on the desired flag it is possible to track every instance
// of a given type as the reference count is modified.
//

#define MRXSMB_REF_TRACE_SERVER_ENTRY     (0x00000001)
#define MRXSMB_REF_TRACE_NETROOT_ENTRY    (0x00000002)
#define MRXSMB_REF_TRACE_SESSION_ENTRY    (0x00000004)
#define MRXSMB_REF_TRACE_VNETROOT_CONTEXT (0x00000008)

#define MRXSMB_LOG_REF_TRACKING      (0x80000000)
#define MRXSMB_PRINT_REF_TRACKING    (0x40000000)

extern ULONG MRxSmbReferenceTracingValue;

VOID
MRxSmbTrackRefCount(
      PVOID   pInstance,
      PCHAR   FileName,
      ULONG   Line);

VOID
MRxSmbTrackDerefCount(
      PVOID   pInstance,
      PCHAR   FileName,
      ULONG   Line);

#define MRXSMB_REF_TRACING_ON(TraceMask)  (TraceMask & MRxSmbReferenceTracingValue)
//#define MRXSMB_PRINT_REF_COUNT(TYPE,Count)                                \
//        if (MRXSMB_REF_TRACING_ON( MRXSMB_REF_TRACE_ ## TYPE )) {              \
//           DbgPrint("%ld\n",Count);                                \
//        }

INLINE VOID
SmbCepReferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
   InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
}

INLINE VOID
SmbCepReferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
{
   ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);
   InterlockedIncrement(&(pSessionEntry->Header.SwizzleCount));
}

INLINE VOID
SmbCepReferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine)
{
   ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
   InterlockedIncrement(&(pNetRootEntry->Header.SwizzleCount));
}

INLINE VOID
SmbCepReferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
{
   ASSERT(pVNetRootContext->Header.ObjectType == SMBCEDB_OT_VNETROOTCONTEXT);
   InterlockedIncrement(&(pVNetRootContext->Header.SwizzleCount));
}

INLINE PSMBCEDB_SERVER_ENTRY
SmbCeReferenceAssociatedServerEntry(
    PMRX_SRV_CALL pSrvCall)
{
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   if ((pServerEntry = pSrvCall->Context) != NULL) {
      ASSERT(pServerEntry->Header.SwizzleCount > 0);
      MRxSmbTrackRefCount(pServerEntry,__FILE__,__LINE__);
      SmbCepReferenceServerEntry(pServerEntry);
   }

   return pServerEntry;
}


INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeReferenceAssociatedNetRootEntry(
    PMRX_NET_ROOT pNetRoot)
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

   if ((pNetRootEntry = pNetRoot->Context) != NULL) {
      ASSERT(pNetRootEntry->Header.SwizzleCount > 0);
      MRxSmbTrackRefCount(pNetRootEntry,__FILE__,__LINE__);
      SmbCepReferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__);
   }

   return pNetRootEntry;
}

extern VOID
SmbCepDereferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCepDereferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCepDereferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PVOID                   FileName,
    ULONG                   FileLine);

extern VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

#define SmbCeReferenceServerEntry(pServerEntry)         \
   MRxSmbTrackRefCount(pServerEntry,__FILE__,__LINE__); \
   SmbReferenceRecord(&pServerEntry->ReferenceRecord[0],__FILE__,__LINE__); \
   SmbCepReferenceServerEntry(pServerEntry)

#define SmbCeReferenceNetRootEntry(pNetRootEntry)        \
   MRxSmbTrackRefCount(pNetRootEntry,__FILE__,__LINE__); \
   SmbCepReferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__)

#define SmbCeReferenceVNetRootContext(pVNetRootContext)     \
   MRxSmbTrackRefCount(pVNetRootContext,__FILE__,__LINE__); \
   SmbReferenceRecord(&pVNetRootContext->ReferenceRecord[0],__FILE__,__LINE__); \
   SmbCepReferenceVNetRootContext(pVNetRootContext)

#define SmbCeReferenceSessionEntry(pSessionEntry)        \
   MRxSmbTrackRefCount(pSessionEntry,__FILE__,__LINE__); \
   SmbCepReferenceSessionEntry(pSessionEntry)

#define SmbCeDereferenceServerEntry(pServerEntry)         \
   MRxSmbTrackDerefCount(pServerEntry,__FILE__,__LINE__); \
   SmbReferenceRecord(&pServerEntry->ReferenceRecord[0],__FILE__,__LINE__); \
   SmbCepDereferenceServerEntry(pServerEntry)

#define SmbCeDereferenceNetRootEntry(pNetRootEntry)        \
   MRxSmbTrackDerefCount(pNetRootEntry,__FILE__,__LINE__); \
   SmbCepDereferenceNetRootEntry(pNetRootEntry,__FILE__,__LINE__)

#define SmbCeDereferenceSessionEntry(pSessionEntry)        \
   MRxSmbTrackDerefCount(pSessionEntry,__FILE__,__LINE__); \
   SmbCepDereferenceSessionEntry(pSessionEntry)

#define SmbCeDereferenceVNetRootContext(pVNetRootContext)     \
   MRxSmbTrackDerefCount(pVNetRootContext,__FILE__,__LINE__); \
   SmbReferenceRecord(&pVNetRootContext->ReferenceRecord[0],__FILE__,__LINE__); \
   SmbCepDereferenceVNetRootContext(pVNetRootContext)

INLINE VOID
SmbCeDereferenceEntries(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMBCEDB_SESSION_ENTRY  pSessionEntry,
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
{
   SmbCeDereferenceNetRootEntry(pNetRootEntry);
   SmbCeDereferenceSessionEntry(pSessionEntry);
   SmbCeDereferenceServerEntry(pServerEntry);
}

//
// Routines for updating the state of SMB MRX data structures
//

#define SmbCeUpdateServerEntryState(pServerEntry,NEWSTATE)   \
        InterlockedExchange(&pServerEntry->Header.State,(NEWSTATE))

#define SmbCeUpdateSessionEntryState(pSessionEntry,NEWSTATE)  \
        InterlockedExchange(&pSessionEntry->Header.State,(NEWSTATE))

#define SmbCeUpdateNetRootEntryState(pNetRootEntry,NEWSTATE)   \
        InterlockedExchange(&pNetRootEntry->Header.State,(NEWSTATE))

#define SmbCeUpdateVNetRootContextState(pVNetRootContext,NEWSTATE)   \
        InterlockedExchange(&pVNetRootContext->Header.State,(NEWSTATE))

INLINE BOOLEAN
SmbCeIsServerInDisconnectedMode(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    return ((pServerEntry->Server.CscState == ServerCscDisconnected) ||
            (pServerEntry->Server.CscState == ServerCscTransitioningToShadowing));
}

INLINE BOOLEAN
SmbCeIsServerSetupForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    return (pServerEntry->pTransport == NULL);
}

//
// The RDBSS wrapper stores all the server names with a backslash prepended to
// them. This helps synthesize UNC names easily. In order to manipulate the
// Server name in the SMB protocol the \ needs to be stripped off.

INLINE VOID
SmbCeGetServerName(
    PMRX_SRV_CALL pSrvCall,
    PUNICODE_STRING pServerName)
{
   ASSERT(pSrvCall->pSrvCallName != NULL);
   pServerName->Buffer        = pSrvCall->pSrvCallName->Buffer + 1;
   pServerName->Length        = pSrvCall->pSrvCallName->Length - sizeof(WCHAR);
   pServerName->MaximumLength = pSrvCall->pSrvCallName->MaximumLength - sizeof(WCHAR);
}

INLINE VOID
SmbCeGetNetRootName(
    PMRX_NET_ROOT pNetRoot,
    PUNICODE_STRING pNetRootName)
{
   ASSERT(pNetRoot->pNetRootName != NULL);
   *pNetRootName  = *pNetRoot->pNetRootName;
}

extern NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot);

extern VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

extern NTSTATUS
SmbCeGetUserNameAndDomainName(
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PUNICODE_STRING         pUserName,
    PUNICODE_STRING         pUserDomainName);

extern BOOLEAN
SmbCeAreServerEntriesAliased(
    PSMBCEDB_SERVER_ENTRY pServernEntry1,
    PSMBCEDB_SERVER_ENTRY pServerEntry2);

extern VOID
SmbCeUnblockSerializedSessionSetupRequests(
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern NTSTATUS
SmbCeUpdateSrvCall(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCeUpdateNetRoot(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    PMRX_NET_ROOT           pNetRoot);

extern NTSTATUS
SmbCeScavengeRelatedContexts(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeResumeOutstandingRequests(
    IN OUT PSMBCEDB_REQUESTS pRequests,
    IN     NTSTATUS          Status);


// given \\server\share, this routine returns a refcounted serverentry
NTSTATUS
FindServerEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_SERVER_ENTRY *ppServerEntry);

// given \\server\share, this routine returns a refcounted netroot entry
NTSTATUS
FindNetRootEntryFromCompleteUNCPath(
    USHORT  *lpuServerShareName,
    PSMBCEDB_NET_ROOT_ENTRY *ppNetRootEntry);

#endif // _SMBCEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbcedbp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcedbp.h

Abstract:

    This is the include file that defines all constants and types for
    implementing the SMB mini redirector connection engine.

    This module contains all the implementation details of the connection engine
    data structures and should be included only by the implementation modules.

Revision History:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

Notes:

--*/

#ifndef _SMBCEDBP_H_
#define _SMBCEDBP_H_

//
// There is reliance on the fact that SMBCEDB_OT_SENTINEL is the last entry in the
// enumerated type and the types have a range of values from 0. Please ensure that
// this is always true.
//
typedef struct _REFERENCE_RECORD_ {
    PVOID   FileName;
    ULONG   FileLine;
} REFERENCE_RECORD,*PREFERENCE_RECORD;

#define REFERENCE_RECORD_SIZE 20

typedef enum _SMBCEDB_OBJECT_TYPE {
   SMBCEDB_OT_SERVER,
   SMBCEDB_OT_NETROOT,
   SMBCEDB_OT_SESSION,
   SMBCEDB_OT_REQUEST,
   SMBCEDB_OT_VNETROOTCONTEXT,
   SMBCEDB_OT_SENTINEL,
   SMBCEDB_OT_TRANSPORT
} SMBCEDB_OBJECT_TYPE, *PSMBCEDB_OBJECT_TYPE;

typedef enum _SMBCEDB_OBJECT_STATE_ {
   SMBCEDB_ACTIVE,                    // the instance is in use
   SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
   SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
   SMBCEDB_RECYCLE,                   // the instance is available for recycling
   SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
   SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
   SMBCEDB_DESTRUCTION_IN_PROGRESS,   // the instance destruction is in progress
   SMBCEDB_RECOVER                    // the instance need to be recovered
} SMBCEDB_OBJECT_STATE, *PSMBCEDB_OBJECT_STATE;

typedef struct _SMBCE_OBJECT_HEADER_ {
    union {
        struct {
            UCHAR   ObjectType;      // type of the object
            UCHAR   ObjectCategory;  // Node type for debugging
        };
        USHORT NodeType;
    };
    UCHAR   Flags;           // flags associated with the object, This is implementation dependent
    UCHAR   Reserved;        // padding
    LONG    SwizzleCount;    // Number of swizzled references to this object
    LONG    State;           // State of the object
} SMBCE_OBJECT_HEADER, *PSMBCE_OBJECT_HEADER;

typedef struct _SMBCE_SERVERS_LIST_ {
    LIST_ENTRY ListHead;
} SMBCEDB_SERVERS, *PSMBCEDB_SERVERS;

typedef struct _SMBCEDB_SESSIONS_ {
   LIST_ENTRY                     ListHead;
   LIST_ENTRY                     DefaultSessionList;
} SMBCEDB_SESSIONS, *PSMBCEDB_SESSIONS;

typedef struct _SMBCEDB_NET_ROOTS_ {
   LIST_ENTRY  ListHead;
} SMBCEDB_NET_ROOTS, *PSMBCEDB_NET_ROOTS;

typedef struct _MRX_SMB_V_NET_ROOT_CONTEXTS {
    LIST_ENTRY ListHead;
} SMBCE_V_NET_ROOT_CONTEXTS, *PSMBCE_V_NET_ROOT_CONTEXTS;

typedef struct _SMBCEDB_REQUESTS_ {
    LIST_ENTRY  ListHead;
    SMB_MPX_ID  NextRequestId;
} SMBCEDB_REQUESTS, *PSMBCEDB_REQUESTS;

typedef enum _SMBCEDB_SERVER_TYPE_ {
   SMBCEDB_MAILSLOT_SERVER = 1,
   SMBCEDB_FILE_SERVER     = 2
} SMBCEDB_SERVER_TYPE, *PSMBCEDB_SERVER_TYPE;

//
// The SMBCEDB_SERVER_ENTRY is the data structure which encapsulates all the information
// w.r.t a remote server for the connection engine. This information includes the dialect
// details as well as the operational data structures required to communicate with the server.
//
// All the dialect related details are further encapsulated in SMBCE_SERVER while the operational
// data structures constitute the remaining parts of the server entry. A pointer to a
// SMBCEDB_SERVER_ENTRY instance is associated with every SRV_CALL that has been hooked
// onto this mini redirector by the wrapper. It is stored in the Context field of MRX_SRV_CALL.
//
// The operational information associated with a server entry includes the Transport related
// information, a collection of requests and a mechanism for associating MID's ( See SMB
// protocol spec.) and a mechanism for posting to threads ( WORK_QUEUE_ITEM ).
//

typedef struct _SMBCEDB_SERVER_ENTRY {
    SMBCE_OBJECT_HEADER           Header;           // struct header.
    LIST_ENTRY                    ServersList;      // list of server instances.
    PMRX_SRV_CALL                 pRdbssSrvCall;
    UNICODE_STRING                Name;             // the server name.
    UNICODE_STRING                DomainName;       // the server domain name.
    SMBCEDB_SESSIONS              Sessions;         // the sessions associated with the server
    SMBCEDB_NET_ROOTS             NetRoots;         // the net roots associated with the server.
    SMBCE_V_NET_ROOT_CONTEXTS     VNetRootContexts; // the V_NET_ROOT contexts
    LIST_ENTRY                    ActiveExchanges;  // list of exchanges active for this server
    LIST_ENTRY                    ExpiredExchanges; // exchanges that have been timed out
    RX_WORK_QUEUE_ITEM            WorkQueueItem;    // work queue item for posting
    NTSTATUS                      ServerStatus;     // the status of the server as determined by negotiate response
    struct _SMBCE_TRANSPORT_      *PreferredTransport;
    LONG                          TransportSpecifiedByUser; // ture if the connection is established on the tranport
                                                            // with the name specified
    struct SMBCE_SERVER_TRANSPORT *pTransport;
    struct SMBCE_SERVER_TRANSPORT *pMailSlotTransport;

    SMBCEDB_REQUESTS              MidAssignmentRequests;
    SMBCEDB_REQUESTS              OutstandingRequests;
    PMID_ATLAS                    pMidAtlas;
    struct _SMB_EXCHANGE          *pNegotiateExchange;
    SMBCE_SERVER                  Server;           // the server data structure.
    UNICODE_STRING                DfsRootName;
    UNICODE_STRING                DnsName;
    PVOID                         ConstructionContext;       // debug only
    KEVENT                        MailSlotTransportRundownEvent;
    KEVENT                        TransportRundownEvent;
    BOOLEAN                       IsTransportDereferenced;   // prevent transport from being dereferenced more than once
    BOOLEAN                       NegotiateInProgress;       // a negotiate is in progress for this server
    BOOLEAN                       SecuritySignaturesActive;  // process the security signature if it is active
    BOOLEAN                       SecuritySignaturesEnabled; // true if the security signature is required by either the
                                                             // client or server, and both have the capability.
    BOOLEAN                       ExtSessionSetupInProgress; // a probe server is in progress for security signature
    BOOLEAN                       ResumeRequestsInProgress;
    RX_WORK_QUEUE_ITEM            WorkQueueItemForResume;    // work queue item for posting resume requests
    SMBCEDB_REQUESTS              SecuritySignatureSyncRequests; // requests waiting on extended session setup for security signature
    REFERENCE_RECORD              ReferenceRecord[REFERENCE_RECORD_SIZE]; // debug only
    RX_WORK_QUEUE_ITEM            WorkQueueItemForDisconnect;    // work queue item for posting dereference server entry requests
    BOOLEAN                       DisconnectWorkItemOutstanding; // is the disconnect work item in the queue?
    RX_CONNECTION_ID              ConnectionId;
} SMBCEDB_SERVER_ENTRY, *PSMBCEDB_SERVER_ENTRY;

// The SMBCEDB_NET_ROOT_ENTRY encapsulates all the information associated with a particular
// TREE_CONNECT ( Net use ) made on a server. As with the server entry this data structure
// encapsulates the dialect oriented details as well as the opertaional information
// associated with handling the requests on a net root.
//
// The dialect specific information is encapsulated in the SMBCE_NET_ROOT data structure. A
// pointer to an instance of this data structure is associated with every MRX_NET_ROOT call
// associated with a MRX_SRV_CALL hooked to this mini redirector.

// ********** code.improvement  ******* The Name cache control structs should be replaced
// ************************************ with pointers to alloced structs so their size remains the
// ************************************ province of the wrapper.
//
typedef struct _SMBCEDB_NET_ROOT_ENTRY {
    SMBCE_OBJECT_HEADER      Header;              // the struct header
    LIST_ENTRY               NetRootsList;        // the list of net roots asssociated with a server
    PMRX_NET_ROOT            pRdbssNetRoot;       // the associated net root ( purely as a debug aid )
    PSMBCEDB_SERVER_ENTRY    pServerEntry;        // the associated server entry
    struct _SMB_EXCHANGE    *pExchange;          // the exchange which is responsible for construction
    SMBCEDB_REQUESTS         Requests;            // the pending requests for this net root
    UNICODE_STRING           Name;
    ACCESS_MASK              MaximalAccessRights;
    ACCESS_MASK              GuestMaximalAccessRights;
    SMBCE_NET_ROOT           NetRoot;             // the net root data structure.
    NAME_CACHE_CONTROL       NameCacheCtlGFABasic;    // The basic file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlGFAStandard; // The standard file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlGFAInternal; // The internal file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlFNF;         // The File not found name cache control.
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;           // The FS Volume Information cache.
    LONG                        VolumeInfoLength;
    LARGE_INTEGER               VolumeInfoExpiryTime;
    BOOLEAN                  IsRemoteBoot;
} SMBCEDB_NET_ROOT_ENTRY, *PSMBCEDB_NET_ROOT_ENTRY;

// The SMBCEDB_SESSION_ENTRY encapsulates all the information associated with a session
// established to a remote machine. The session encapsulates all the security information.
// The dialect specific details are encapsulated in teh SMBCE_SESSION data structure. The
// SMBCE_SESSION data structure is available in many flavours depending on the security
// package used. Currently there is support for handling LSA and KERBEROS sessions.
//
// A pointer to an instance of this data structure is associated with every MRX_V_NET_ROOT
// data structure hooked to this mini redirector by the wrapper.

typedef struct _SMBCEDB_SESSION_ENTRY {
    SMBCE_OBJECT_HEADER        Header;           // the struct header
    LIST_ENTRY                 SessionsList;     // the list of sessions associated with the server
    LIST_ENTRY                 DefaultSessionLink; // the list of explicit credentials for this server
    PSMBCEDB_SERVER_ENTRY      pServerEntry;     // the associated server entry
    struct _SMB_EXCHANGE       *pExchange;       // the exchange which is responsible for construction
    SMBCEDB_REQUESTS           Requests;         // pending requests
    LIST_ENTRY                 SerializationList; // session construction serialization
    PKEVENT                    pSerializationEvent;
    ULONG                      SessionVCNumber;  // the VC number to be packaged with session setup
    SMBCE_SESSION              Session;          // the Session
    PUNICODE_STRING            pNetRootName;     // for share level security only
    BOOLEAN                    SessionRecoverInProgress;
} SMBCEDB_SESSION_ENTRY, *PSMBCEDB_SESSION_ENTRY;

//
// The wrapper exposes three data structures for manipulating and describing
// name spaces set up on remote servers, Viz., MRX_SRV_CALL, MRX_NET_ROOT and
// MRX_V_NET_ROOT. The SRV_CALL corresponds to a remote server, the MRX_NET_ROOT
// corresponds to a share on that machine and V_NET_ROOT encapsulates
// the notion of a view of a MRX_NET_ROOT ( share in SMB terminology)
//
// The mapping between the wrapper level data structures and the SMB notion
// of SMBCEDB_SERVER_ENTRY, SMBCEDB_SESSION_ENTRY and SMBCEDB_NET_ROOT_ENTRY
// is not one to one in all cases.
//
// It is one to one between MRX_SRV_CALL and SMBCEDB_SERVER_ENTRY. It is for this
// reason that a pointer to SMBCEDB_SERVER_ENTRY is stored in the context field
// of the MRX_SRV_CALL instance.
//
// SMBCEDB_SESSION_ENTRY has a one to one mapping with the set of credentials
// supplied to establish a connection to a server. Having established a session
// one can have access to all the shares available on the server.
//
// SMBCEDB_NET_ROOT_ENTRY has a one to one mapping with a share on a given
// server. Since this closely corresponds to the wrappers interpretation of
// MRX_NET_ROOT a pointer to SMBCEDB_NET_ROOT_ENTRY is stored as part of the
// MRX_NET_ROOT instance.
//
// The context associated with every MRX_V_NET_ROOT instance is a pointer to
// an instance of SMBCE_V_NET_ROOT_CONTEXT. This encapsulates the associated session
// entry, the net root entry and the relevant book keeping information.
//
// The bookkeeping information is the UID/TID used in the SMB protocol, a
// reference count and a LIST_ENTRY to thread the instance into the appropriate
// list.
//

#define SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID    (0x1)
#define SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE (0x2)

typedef struct _SMBCE_V_NET_ROOT_CONTEXT {
    SMBCE_OBJECT_HEADER     Header;

    PMRX_V_NET_ROOT         pRdbssVNetRoot;   // the associated VNetRoot ( purely as a debug aid)
    struct _SMB_EXCHANGE    *pExchange;           // the exchange which is responsible for construction
    SMBCEDB_REQUESTS        Requests;

    LIST_ENTRY              ListEntry;
    LARGE_INTEGER           ExpireTime;

    struct _SMBCEDB_SERVER_ENTRY   *pServerEntry;
    struct _SMBCEDB_SESSION_ENTRY  *pSessionEntry;
    struct _SMBCEDB_NET_ROOT_ENTRY *pNetRootEntry;

    USHORT          Flags;
    SMB_TREE_ID     TreeId;

    REFERENCE_RECORD        ReferenceRecord[REFERENCE_RECORD_SIZE]; // debug only
} SMBCE_V_NET_ROOT_CONTEXT, *PSMBCE_V_NET_ROOT_CONTEXT;

//
// An SMBCEDB_REQUEST_ENTRY encapsulates an action being processed by the SMBCE connection
// engine. The requests come in vairous flavours and each of these flavours is associated
// with the appropriate context required for resumption. In order to provide better memory
// management mechanisms the REQUEST_ENTRY encapsulates a union of the requests of various
// flavours. Each SERVER_ENTRY in the connection engine is associated with a list or
// request entries. In order to hide the abstraction of a list which does not scale well to
// the case of GATEWAY redirectors a set of routines are provided to manipulate the
// collection of requests. They provide a mechanism for intializing the collection of requests,
// adding a request, deleting a request and enumeratiung requests in a collection.
//
// Special mechanisms are built in to handle batching of operations. Each operation on the
// collection of requests come in two flavours, a vanila version and a lite version. In the
// lite version it is assumed that the appropriate concurrency control action has been taken
//
// One common scenario that is often encountered in processing the requests is invocation
// of a specific function on the requests in the collection. As an example if a disconnect
// request is received on a server entry then all the outstanding requests must be resumed
// with the appropriate error. Since these indications can potentially occur at DPC levels in
// NT it is not desirable to manipulate the collection while holding onto a spinlock, nor is
// it desirable to repeatedly release and accquire the spin lock. A special operation is
// provided for transferring the requests enmasse from one collection to another and resetting
// the original. With the help of this operation it is sufficient to hold the spinlock only
// for the duration of the transfer. The remainder of the processing can be done on the newly
// created collection.
//
//
// NT Specific Implementation Note:
//
// On NT the transport indications are at DPC level, therefore it is required to protect
// the manipulation of the requests data structure with a spinlock.
//
//

typedef struct _SMBCEDB_REQUEST_ENTRY_ {
    SMBCE_OBJECT_HEADER           Header;        // the struct header
    LIST_ENTRY                      RequestsList;  // the next request for the VC.
    union {
       SMBCE_GENERIC_REQUEST    GenericRequest;
       SMBCE_REQUEST            Request;           // the next request.
       SMBCE_COPY_DATA_REQUEST  CopyDataRequest;
       SMBCE_RECONNECT_REQUEST  ReconnectRequest;
       SMBCE_MID_REQUEST        MidRequest;
    };
} SMBCEDB_REQUEST_ENTRY, *PSMBCEDB_REQUEST_ENTRY;

#define SmbCeInitializeRequests(pRequests)  \
         InitializeListHead(&(pRequests)->ListHead); \
         (pRequests)->NextRequestId = 0

#define SmbCeAddRequestEntry(pRequestList,pRequestEntry)                             \
           SmbCeAcquireSpinLock();                                                   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList); \
           SmbCeReleaseSpinLock()

#define SmbCeAddRequestEntryLite(pRequestList,pRequestEntry)   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList)

#define SmbCeRemoveRequestEntry(pRequests,pEntry)     \
           SmbCeAcquireSpinLock();                    \
           RemoveEntryList(&(pEntry)->RequestsList);  \
           SmbCeReleaseSpinLock()

#define SmbCeRemoveRequestEntryLite(pRequests,pEntry)         \
               RemoveEntryList(&(pEntry)->RequestsList)

#define SmbCeGetFirstRequestEntry(pRequestList)                    \
            (IsListEmpty(&(pRequestList)->ListHead)                \
             ? NULL                                                \
             : (PSMBCEDB_REQUEST_ENTRY)                            \
               (CONTAINING_RECORD((pRequestList)->ListHead.Flink,  \
                                  SMBCEDB_REQUEST_ENTRY,           \
                                  RequestsList)))

#define SmbCeGetNextRequestEntry(pRequestList,pRequestEntry)                     \
            (((pRequestEntry)->RequestsList.Flink == &(pRequestList)->ListHead)  \
             ? NULL                                                              \
             : (PSMBCEDB_REQUEST_ENTRY)                                          \
               (CONTAINING_RECORD((pRequestEntry)->RequestsList.Flink,           \
                                  SMBCEDB_REQUEST_ENTRY,                         \
                                  RequestsList)))

#define SmbCeTransferRequests(pDestination,pSource)                               \
         if (IsListEmpty(&(pSource)->ListHead)) {                                 \
            SmbCeInitializeRequests((pDestination));                              \
         } else {                                                                 \
            *(pDestination) = *(pSource);                                         \
            (pDestination)->ListHead.Flink->Blink = &(pDestination)->ListHead;    \
            (pDestination)->ListHead.Blink->Flink = &(pDestination)->ListHead;    \
            SmbCeInitializeRequests((pSource));                                   \
         }


// Much along the lines of a collection of request a collection of all server entries is
// maintained as part of the connection engine. The following operations are supported on
// the colection of server entries
//    1) adding a server entry to the collection
//    2) removing a server entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.

#define SmbCeAddServerEntry(pServerEntry)                                      \
            SmbCeAcquireSpinLock();                                            \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeAddServerEntryLite(pServerEntry)                                   \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList)

#define SmbCeRemoveServerEntry(pServerEntry)                \
            SmbCeAcquireSpinLock();                         \
            RemoveEntryList(&(pServerEntry)->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeRemoveServerEntryLite(pServerEntry)   \
            RemoveEntryList(&(pServerEntry)->ServersList)

#define SmbCeGetFirstServerEntry()                                   \
               (IsListEmpty(&s_DbServers.ListHead)                   \
                ? NULL                                               \
                : (PSMBCEDB_SERVER_ENTRY)                            \
                  (CONTAINING_RECORD(s_DbServers.ListHead.Flink,     \
                                     SMBCEDB_SERVER_ENTRY,           \
                                     ServersList)))

#define SmbCeGetNextServerEntry(pServerEntry)                               \
           (((pServerEntry)->ServersList.Flink == &s_DbServers.ListHead)    \
            ? NULL                                                          \
            : (PSMBCEDB_SERVER_ENTRY)                                       \
              (CONTAINING_RECORD((pServerEntry)->ServersList.Flink,         \
                                 SMBCEDB_SERVER_ENTRY,                      \
                                 ServersList)))


// Since the mapping between V_NET_ROOT's in the RDBSS and the session entries in the mini
// redirector is a many to one mapping a collection of session entries is maintained as part
// of each server entry. The following operations are supported on the collection of session
// entries
//    1) adding a session entry to the collection
//    2) removing a session entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//
// In addition two more methods are specified for retrieving the default session entry and
// setting the default session entry for any given server.

#define SmbCeAddSessionEntry(pServerEntry,pSessionEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddSessionEntryLite(pServerEntry,pSessionEntry)   \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList)

#define SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               if ((pSessionEntry)->DefaultSessionLink.Flink != NULL) {              \
                   RemoveEntryList(&(pSessionEntry)->DefaultSessionLink);            \
                   pSessionEntry->DefaultSessionLink.Flink = NULL;                   \
                   pSessionEntry->DefaultSessionLink.Blink = NULL;                   \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList);                       \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveSessionEntryLite(pServerEntry,pSessionEntry)                      \
               ASSERT( SmbCeSpinLockAcquired() );                                    \
               if ((pSessionEntry)->DefaultSessionLink.Flink != NULL) {              \
                   RemoveEntryList(&(pSessionEntry)->DefaultSessionLink);            \
                   pSessionEntry->DefaultSessionLink.Flink = NULL;                   \
                   pSessionEntry->DefaultSessionLink.Blink = NULL;                   \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList);


#define SmbCeGetFirstSessionEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->Sessions.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_SESSION_ENTRY)                                        \
               (CONTAINING_RECORD((pServerEntry)->Sessions.ListHead.Flink,     \
                                  SMBCEDB_SESSION_ENTRY,                       \
                                  SessionsList)))

#define SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry)                  \
            (((pSessionEntry)->SessionsList.Flink ==                          \
                              &(pServerEntry)->Sessions.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_SESSION_ENTRY)                                       \
               (CONTAINING_RECORD((pSessionEntry)->SessionsList.Flink,        \
                                  SMBCEDB_SESSION_ENTRY,                      \
                                  SessionsList)))

#define SmbCeSetDefaultSessionEntry(pServerEntry,pSessionEntry)               \
               SmbCeAcquireSpinLock();                                        \
               if ((pSessionEntry)->DefaultSessionLink.Flink == NULL) {       \
                   ASSERT( pSessionEntry->DefaultSessionLink.Blink == NULL ); \
               InsertHeadList(&(pServerEntry)->Sessions.DefaultSessionList,&(pSessionEntry)->DefaultSessionLink); \
               };                                                             \
           SmbCeReleaseSpinLock()

extern PSMBCEDB_SESSION_ENTRY
SmbCeGetDefaultSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG SessionId,
    PLUID pLogonId
    );

VOID
SmbCeRemoveDefaultSessionEntry(
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry
    );

// In order to encapsulate the notion of reconnects and to provide for hot reconnects,
// i.e., reconnection attempts in which the saved state in the server/client prior to
// a transport level disconnect can be reused it is required to mark each net root
// entry associated with a server as invalid on receipt of a transport level disconnect.
//
// Therefore an abstraction of a collection of net root entries is provided and is associated
// with each server entry.
//
// The following operations are supported on the collection of net root entries
//    1) adding a net root entry to the collection
//    2) removing a net root entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//


#define SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddNetRootEntryLite(pServerEntry,pNetRootEntry)   \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList)

#define SmbCeRemoveNetRootEntry(pServerEntry,pNetRootEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveNetRootEntryLite(pServerEntry,pNetRootEntry)                      \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList)


#define SmbCeGetFirstNetRootEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->NetRoots.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                       \
               (CONTAINING_RECORD((pServerEntry)->NetRoots.ListHead.Flink,     \
                                  SMBCEDB_NET_ROOT_ENTRY,                      \
                                  NetRootsList)))

#define SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry)                  \
            (((pNetRootEntry)->NetRootsList.Flink ==                          \
                              &(pServerEntry)->NetRoots.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                      \
               (CONTAINING_RECORD((pNetRootEntry)->NetRootsList.Flink,        \
                                  SMBCEDB_NET_ROOT_ENTRY,                     \
                                  NetRootsList)))


// Macros to manipulate the collection of SMBCE_V_NET_ROOT_CONTEXT instances.

#define SmbCeAddVNetRootContext(pVNetRootContexts,pVNetRootContext)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pVNetRootContexts)->ListHead,&(pVNetRootContext)->ListEntry); \
            SmbCeReleaseSpinLock()


#define SmbCeAddVNetRootContextLite(pVNetRootContexts,pVNetRootContext)   \
            InsertTailList(&(pVNetRootContexts)->ListHead,&(pVNetRootContext)->ListEntry)

#define SmbCeRemoveVNetRootContext(pVNetRootContexts,pVNetRootContext)               \
               SmbCeAcquireSpinLock();                                               \
               RemoveEntryList(&(pVNetRootContext)->ListEntry);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveVNetRootContextLite(pVNetRootContexts,pVNetRootContext)              \
               RemoveEntryList(&(pVNetRootContext)->ListEntry)


#define SmbCeGetFirstVNetRootContext(pVNetRootContexts)                        \
            (IsListEmpty(&((pVNetRootContexts)->ListHead))                       \
             ? NULL                                                            \
             : (PSMBCE_V_NET_ROOT_CONTEXT)                                     \
               (CONTAINING_RECORD((pVNetRootContexts)->ListHead.Flink,         \
                                  SMBCE_V_NET_ROOT_CONTEXT,                    \
                                  ListEntry)))

#define SmbCeGetNextVNetRootContext(pVNetRootContexts,pVNetRootContext)          \
            (((pVNetRootContext)->ListEntry.Flink ==                          \
                              &(pVNetRootContexts)->ListHead)                 \
             ? NULL                                                           \
             : (PSMBCE_V_NET_ROOT_CONTEXT)                                    \
               (CONTAINING_RECORD((pVNetRootContext)->ListEntry.Flink,        \
                                  SMBCE_V_NET_ROOT_CONTEXT,                   \
                                  ListEntry)))


//
// SmbCe database initialization
//

extern NTSTATUS
SmbCeDbInit();

extern VOID
SmbCeDbTearDown();

//
// Object allocation and deallocation
//

extern PSMBCE_OBJECT_HEADER
SmbCeDbAllocateObject(
      SMBCEDB_OBJECT_TYPE ObjectType);

extern VOID
SmbCeDbFreeObject(
      PVOID pObject);

//
// Object destruction
//

extern VOID
SmbCeTearDownServerEntry(PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeTearDownNetRootEntry(PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry);

extern VOID
SmbCeTearDownSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCeTearDownRequestEntry(PSMBCEDB_REQUEST_ENTRY pRequestEntry);

//
// The routines for mapping a MID with an exchange and for associating an exchange with
// a MID
//

extern NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid);

extern NTSTATUS
SmbCeDissociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer);

extern NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                 pBuffer);

extern VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange);

extern NTSTATUS
SmbCepDiscardMidAssociatedWithExchange(
    struct _SMB_EXCHANGE * pExchange);

extern VOID
SmbCeResumeDiscardedMidAssignmentRequests(
    PSMBCEDB_REQUESTS pMidRequests,
    NTSTATUS          ResumptionStatus);

//
// Routines for handling transport disconnects/invalidation.
//

extern VOID
SmbCeTransportDisconnectIndicated(
      PSMBCEDB_SERVER_ENTRY pServerEntry);


extern VOID
SmbCeResumeAllOutstandingRequestsOnError(
   PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeHandleTransportInvalidation(
   struct _SMBCE_TRANSPORT_ *pTransport);

extern VOID
SmbCeFinalizeAllExchangesForNetRoot(
    PMRX_NET_ROOT pNetRoot);

extern NTSTATUS
MRxSmbCheckForLoopBack(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry);

//
// Resource acquistion/release
//

PVOID SmbCeDbResourceAcquireFile;
ULONG SmbCeDbResourceAcquireLine;

#define SmbCeAcquireResource() \
        KeEnterCriticalRegion(); \
        ExAcquireResourceExclusiveLite(&s_SmbCeDbResource,TRUE);\
        SmbCeDbResourceAcquireFile = __FILE__;\
        SmbCeDbResourceAcquireLine = __LINE__

#define SmbCeReleaseResource() \
        SmbCeDbResourceAcquireFile = NULL;\
        SmbCeDbResourceAcquireLine = 0;\
        ExReleaseResourceLite(&s_SmbCeDbResource);\
        KeLeaveCriticalRegion()

#define SmbCeIsResourceOwned() ExIsResourceAcquiredExclusiveLite(&s_SmbCeDbResource)

#define SmbCeAcquireSpinLock() \
                KeAcquireSpinLock(&s_SmbCeDbSpinLock,&s_SmbCeDbSpinLockSavedIrql);   \
                s_SmbCeDbSpinLockAcquired = TRUE

#define SmbCeReleaseSpinLock()   \
                s_SmbCeDbSpinLockAcquired = FALSE;                                  \
                KeReleaseSpinLock(&s_SmbCeDbSpinLock,s_SmbCeDbSpinLockSavedIrql)

#define SmbCeSpinLockAcquired()   \
                (s_SmbCeDbSpinLockAcquired == TRUE)

#define SmbCeAcquireSecuritySignatureResource() \
        ExAcquireResourceExclusiveLite(&s_SmbSecuritySignatureResource,TRUE)

#define SmbCeReleaseSecuritySignatureResource() \
        ExReleaseResourceLite(&s_SmbSecuritySignatureResource)

//INLINE BOOLEAN SmbCeDbIsEntryInUse(PSMBCE_OBJECT_HEADER pHeader)
/*++

Routine Description:

    This routine determines if a SmbCe database entry is in use.

Arguments:

    pHeader - the entry header

Return Value:

    TRUE if the entry is in use otherwise FALSE

--*/

#define SmbCeIsEntryInUse(pHeader)                                                   \
                  (((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_ACTIVE  ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_INVALID ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_CONSTRUCTION_IN_PROGRESS)


#define SmbCeSetServerType(pServerEntry,ServerType) \
           (pServerEntry)->Header.Flags = (UCHAR)(ServerType)

#define SmbCeGetServerType(pServerEntry)   \
           ((SMBCEDB_SERVER_TYPE)(pServerEntry)->Header.Flags)


//
// Static variable declarations that constitute the SmbCe database.
//

extern SMBCEDB_SERVERS     s_DbServers;

//
// Currently there is only one resource for synchronizing the access to all the
// entities in the connection engine database. It is possible to customize it
// subsequently since the acquistion/release methods take the type of the object
// as a parameter.
//

extern ERESOURCE  s_SmbCeDbResource;
extern RX_SPIN_LOCK s_SmbCeDbSpinLock;
extern KIRQL      s_SmbCeDbSpinLockSavedIrql;
extern BOOLEAN    s_SmbCeDbSpinLockAcquired;

#endif  // _SMBCEDBP_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbcemid.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcemid.c

Abstract:

    This module defines the routines for manipulating MIDs associated with SMB's

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#endif

RXDT_DefineCategory(SMBCEMID);

#define Dbg        (DEBUG_TRACE_SMBCEMID)

INLINE
BOOLEAN
SmbCeVerifyMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange,
    SMB_MPX_ID            Mid)
{
    BOOLEAN MidIsValid = TRUE;
    USHORT  ServerVersion;

    ASSERT(pServerEntry != NULL);
    ASSERT(pServerEntry->pMidAtlas != NULL);

    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        USHORT MidMask;

        MidMask = 0x1 << pServerEntry->pMidAtlas->MaximumMidFieldWidth;
        MidMask = MidMask -1;

        MidIsValid = ((Mid & ~MidMask) == pExchange->MidCookie);
    }


    return MidIsValid;
}

INLINE
SMB_MPX_ID
SmbCeEncodeMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_EXCHANGE         pExchange,
    SMB_MPX_ID            Mid)
{
    USHORT VersionNumber;
    SMB_MPX_ID EncodedMid;

    EncodedMid = Mid;
    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        LONG MidCookie = InterlockedIncrement(&pServerEntry->Server.MidCounter);

        pExchange->MidCookie= ((USHORT)MidCookie <<
                               pServerEntry->pMidAtlas->MaximumMidFieldWidth);

        EncodedMid |= pExchange->MidCookie;
    }

    return EncodedMid;
}

INLINE
SMB_MPX_ID
SmbCeExtractMid(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    SMB_MPX_ID            EncodedMid)
{
    SMB_MPX_ID Mid = EncodedMid;

    if (pServerEntry->pMidAtlas->MaximumMidFieldWidth < 16) {
        USHORT MidMask;

        MidMask = 0x1 << pServerEntry->pMidAtlas->MaximumMidFieldWidth;
        MidMask = MidMask -1;

        Mid &= MidMask;
    }

    return Mid;
}

NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine associates an exchange with a MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the Exchange instance.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. Currently this routine does not return control till a
   MID is acquired or the exchange is aborted/terminated.

--*/
{
    NTSTATUS                 Status = STATUS_SUCCESS;
    PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
    SMBCE_RESUMPTION_CONTEXT ResumptionContext;
    SMBCEDB_SERVER_TYPE      ServerType;
    BOOLEAN                  ResetServerEntry = FALSE;

    ServerType = SmbCeGetServerType(pServerEntry);

    // Acquire the resource
    SmbCeAcquireSpinLock();

    // Attempt to allocate a MID only for FILE Servers. Mailslot servers do
    // not require a valid MID.

    if (ServerType != SMBCEDB_MAILSLOT_SERVER) {
        if (pServerEntry->pMidAtlas != NULL) {
            if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE) {
                // This exchange response can be arbitrarily delayed. Ensure that
                // all the available MIDS are not tied up in such exchanges.

                if ((pServerEntry->pMidAtlas->NumberOfMidsInUse + 1) >=
                    pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                    Status = STATUS_TOO_MANY_COMMANDS;
                }
            }

            if (Status == STATUS_SUCCESS) {
                if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
                    pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                    Status = STATUS_TOO_MANY_COMMANDS;
                    ResetServerEntry = TRUE;
                }
            }

            if (Status == STATUS_SUCCESS) {
                SMB_MPX_ID Mid;

                Status = FsRtlAssociateContextWithMid(
                              pServerEntry->pMidAtlas,
                              pExchange,
                              &Mid);

                if (Status == STATUS_SUCCESS) {
                    pExchange->Mid = SmbCeEncodeMid(pServerEntry,pExchange,Mid);
                }
            }
        } else {
            if (pServerEntry->Header.State == SMBCEDB_ACTIVE) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
    }

    if (Status == STATUS_UNSUCCESSFUL) {
        // Allocate a new entry and add it to the list.
        pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
        if (pRequestEntry != NULL) {
            // Enqueue the request entry.

            SmbCeInitializeResumptionContext(&ResumptionContext);

            pRequestEntry->MidRequest.Type               = ACQUIRE_MID_REQUEST;
            pRequestEntry->MidRequest.pExchange          = pExchange;
            pRequestEntry->MidRequest.pResumptionContext = &ResumptionContext;
            SmbCeAddRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else if (Status == STATUS_SUCCESS) {
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    if (Status == STATUS_UNSUCCESSFUL) {
        //DbgPrint("***** Thread %lx Waiting for MID Resumption Context %lx*****\n",PsGetCurrentThread(),&ResumptionContext);
        SmbCeSuspend(&ResumptionContext);
        Status = ResumptionContext.Status;
        //DbgPrint("***** Thread %lx MID Wait Satisfied %lx *****\n",PsGetCurrentThread(),&ResumptionContext);
    }

    if (ResetServerEntry) {
        // If all the mids have been discarded we rest the transport connection
        // to start afresh.
        SmbCeTransportDisconnectIndicated(pServerEntry);
    }

    return Status;
}

struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid)
/*++

Routine Description:

   This routine maps a given MID to the exchange associated with it

Arguments:

    pServerEntry - the servere entry

    Mid          - the mid to be mapped to an Exchange.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

--*/
{
    PSMB_EXCHANGE pExchange;

    // Acquire the resource
    SmbCeAcquireSpinLock();

    if (pServerEntry->pMidAtlas != NULL) {
        pExchange = FsRtlMapMidToContext(
                        pServerEntry->pMidAtlas,
                        Mid);

        if (pExchange != NULL) {
            if (!SmbCeVerifyMid(pServerEntry,pExchange,Mid)) {
                pExchange = NULL;
            }
        }
    } else {
        pExchange = NULL;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    return pExchange;
}

NTSTATUS
SmbCeDissociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine disassociates an exchange from the MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. This modification will also include posting requests
   for resumption of exchanges when invoked at DPC level.

--*/
{
    NTSTATUS               Status = RX_MAP_STATUS(SUCCESS);
    SMBCEDB_SERVER_TYPE    ServerType;

    ServerType = SmbCeGetServerType(pServerEntry);

    if ((ServerType != SMBCEDB_MAILSLOT_SERVER) &&
        (pExchange->Mid != SMBCE_OPLOCK_RESPONSE_MID) &&
        (pExchange->Mid != SMBCE_MAILSLOT_OPERATION_MID)) {
        PVOID                  pContext;
        PSMBCEDB_REQUEST_ENTRY pRequestEntry = NULL;

        // Acquire the resource
        SmbCeAcquireSpinLock();

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
            // Check if there are any pending MID assignment requests and transfer the MID
            // if one exists.
            pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->MidAssignmentRequests);

            if (pRequestEntry != NULL) {
                SmbCeRemoveRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
            }

            if (pServerEntry->pMidAtlas != NULL) {
                SMB_MPX_ID Mid;

                Mid = SmbCeExtractMid(pServerEntry,pExchange->Mid);

                if (pRequestEntry != NULL) {
                    Status = FsRtlReassociateMid(
                                 pServerEntry->pMidAtlas,
                                 Mid,
                                 pRequestEntry->MidRequest.pExchange);

                    ASSERT(Status == STATUS_SUCCESS);

                    pRequestEntry->MidRequest.pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                    pRequestEntry->MidRequest.pExchange->Mid = SmbCeEncodeMid(
                                                                   pServerEntry,
                                                                   pRequestEntry->MidRequest.pExchange,
                                                                   Mid);
                    pRequestEntry->MidRequest.pResumptionContext->Status = STATUS_SUCCESS;
                } else {
                    Status = FsRtlMapAndDissociateMidFromContext(
                                 pServerEntry->pMidAtlas,
                                 Mid,
                                 &pContext);

                    ASSERT(pContext == pExchange);
                }
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        }

        // Release the resource
        SmbCeReleaseSpinLock();

        if (pRequestEntry != NULL) {
             // Signal the waiter for resumption
            SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

            SmbCeTearDownRequestEntry(pRequestEntry);
        }
    }

    pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

    return Status;
}

VOID
SmbCeDiscardMidAssignmentRequests(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

   This routine discards all mid assignment requests for a given server entry

Arguments:

    pServerEntry - the servere entry

Notes:

    This typically happens when the mids in use are being cancelled against a
    down level server. In such cases there is no cancel command that can be
    sent to the server. Typically we throw away the MID and not use it any
    further. this will lead to a graceful degradation in performance when
    the connection is reestablished

--*/
{
    SMBCEDB_REQUESTS MidRequests;

    InitializeListHead(&MidRequests.ListHead);

    SmbCeAcquireSpinLock();

    if (pServerEntry->pMidAtlas != NULL) {
        if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
            pServerEntry->pMidAtlas->MaximumNumberOfMids) {
            SmbCeTransferRequests(
                &MidRequests,
                &pServerEntry->MidAssignmentRequests);
        }
    }

    SmbCeReleaseSpinLock();

    SmbCeResumeDiscardedMidAssignmentRequests(
        &MidRequests,
        STATUS_TOO_MANY_COMMANDS);

    SmbCeDereferenceServerEntry(pServerEntry);
}

NTSTATUS
SmbCepDiscardMidAssociatedWithExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine discards the mid associated with an exchange

Arguments:

    pExchange - the exchange

Notes:

    We use the hypercritical thread to ensure that this request does not block
    behind other requests.

    This routine also assumes that it is invoked with the SmbCeSpinLock held

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) &&
        (pExchange->Mid != SMBCE_OPLOCK_RESPONSE_MID) &&
        (pExchange->Mid != SMBCE_MAILSLOT_OPERATION_MID) &&
        (pExchange->Mid != SMBCE_ECHO_PROBE_MID)) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

        if ((pServerEntry != NULL) &&
            (pServerEntry->pMidAtlas != NULL)) {
            SMB_MPX_ID Mid;

            Mid = SmbCeExtractMid(pServerEntry,pExchange->Mid);

            Status = FsRtlReassociateMid(
                         pServerEntry->pMidAtlas,
                         Mid,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                pServerEntry->pMidAtlas->NumberOfMidsDiscarded++;

                if (pServerEntry->pMidAtlas->NumberOfMidsDiscarded ==
                    pServerEntry->pMidAtlas->MaximumNumberOfMids) {
                    // All the mids have been discarded. Any pending
                    // mid assignment requests needs to be completed
                    // with the appropriate error code.

                    SmbCeReferenceServerEntry(pServerEntry);

                    Status = RxDispatchToWorkerThread(
                                 MRxSmbDeviceObject,
                                 HyperCriticalWorkQueue,
                                 SmbCeDiscardMidAssignmentRequests,
                                 pServerEntry);
                }
            }

            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}

VOID
SmbCeResumeDiscardedMidAssignmentRequests(
    PSMBCEDB_REQUESTS pMidRequests,
    NTSTATUS          ResumptionStatus)
/*++

Routine Description:

   This routine resumes discarded mid assignment requests with the appropriate error

Arguments:

    pMidRequests - the discarded requests

    ResumptionStatus - the resumption status

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   This routine and the routines that follow enable a pipelined reuse of MID's
   If a large buffer is to be copied then this can be done without hodling onto
   a MID. This improves the throughput between the client and the server. At the
   very least this mechanism ensures that the connection engine will not be the
   constraining factor in MID reuse.

--*/
{
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

    pRequestEntry = SmbCeGetFirstRequestEntry(pMidRequests);
    while (pRequestEntry != NULL) {
        // Remove the request entry from the list
        SmbCeRemoveRequestEntryLite(pMidRequests,pRequestEntry);

        ASSERT(pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST);

        // Signal the waiter for resumption
        pRequestEntry->MidRequest.pResumptionContext->Status = ResumptionStatus;
        SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

        SmbCeTearDownRequestEntry(pRequestEntry);
        pRequestEntry = SmbCeGetFirstRequestEntry(pMidRequests);
    }
}

struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer)
/*++

Routine Description:

   This routine gets the exchange associated with a buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   This routine and the routines that follow enable a pipelined reuse of MID's
   If a large buffer is to be copied then this can be done without hodling onto
   a MID. This improves the throughput between the client and the server. At the
   very least this mechanism ensures that the connection engine will not be the
   constraining factor in MID reuse.

--*/
{
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMB_EXCHANGE          pExchange = NULL;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the cached buffer ptr with the ptr indicated
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
          (pRequestEntry->CopyDataRequest.pBuffer == pBuffer)) {
         pExchange = pRequestEntry->CopyDataRequest.pExchange;
         pRequestEntry->CopyDataRequest.pBuffer = NULL;
         break;
      }

      pRequestEntry = SmbCeGetNextRequestEntry(
                              &pServerEntry->OutstandingRequests,
                              pRequestEntry);
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   return pExchange;
}

NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                  pBuffer)
/*++

Routine Description:

   This routine establishes an association between an exchange and a copy data request
   buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    STATUS_SUCCESS if succesful

--*/
{
   NTSTATUS               Status = STATUS_SUCCESS;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   Status = pServerEntry->ServerStatus;
   if (Status == RX_MAP_STATUS(SUCCESS)) {
      // Walk through the list of requests maintained on this and remove the one
      // matching the cached buffer ptr with the ptr indicated
      pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
      while (pRequestEntry != NULL) {
         if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
             (pRequestEntry->CopyDataRequest.pBuffer == NULL)) {
            pRequestEntry->CopyDataRequest.pExchange = pExchange;
            pRequestEntry->CopyDataRequest.pBuffer = pBuffer;
            break;
         }
         pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      }
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   if ((Status == RX_MAP_STATUS(SUCCESS)) &&
       (pRequestEntry == NULL)) {
      // Allocate a new entry and add it to the list.
      pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
      if (pRequestEntry != NULL) {
         // Enqueue the request entry.
         pRequestEntry->CopyDataRequest.Type      = COPY_DATA_REQUEST;
         pRequestEntry->CopyDataRequest.pExchange = pExchange;
         pRequestEntry->CopyDataRequest.pBuffer   = pBuffer;

         // Acquire the resource
         SmbCeAcquireSpinLock();

         if ((Status = pServerEntry->ServerStatus) == RX_MAP_STATUS(SUCCESS)) {
            SmbCeAddRequestEntryLite(&pServerEntry->OutstandingRequests,pRequestEntry);
         }

         // Release the resource
         SmbCeReleaseSpinLock();

         if (Status != RX_MAP_STATUS(SUCCESS)) {
            SmbCeTearDownRequestEntry(pRequestEntry);
         }
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   return Status;
}

VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange)
/*++

Routine Description:

   This routine purges all the copy data requests associated with an exchange.

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Notes:

   This mechanism of delaying the purging of requests associated with an exchange
   till it is discared is intended to solve the problem of repeated allocation/freeing
   of request entries. This rests on the assumption that there will not be too many
   copy data requests outstanding for any exchange. If evidence to the contrary is
   noticed this technique has to be modified.

--*/
{
   SMBCEDB_REQUESTS       ExchangeRequests;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMBCEDB_REQUEST_ENTRY pNextRequestEntry;

   SmbCeInitializeRequests(&ExchangeRequests);

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the given exchange
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      pNextRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      if (pRequestEntry->GenericRequest.pExchange == pExchange) {
         SmbCeRemoveRequestEntryLite(&pServerEntry->OutStandingRequests,pRequestEntry);
         SmbCeAddRequestEntryLite(&ExchangeRequests,pRequestEntry);
      }
      pRequestEntry = pNextRequestEntry;
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   while (pRequestEntry != NULL) {
      SmbCeRemoveRequestEntryLite(&ExchangeRequests,pRequestEntry);
      SmbCeTearDownRequestEntry(pRequestEntry);
      pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbea.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbea.h

Abstract:

    This module defines the prototypes for various functions which aid in the conversion
    from NT's EA format to the OS21.2 style and vice versa.

Revision History:

    Joe Linn             [JoeLinn]  17-April-1996      Lifted these from the rdr1

--*/

#ifndef _SMBEA_H_
#define _SMBEA_H_

VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    );

PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    );

PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

#endif // _SMBEA_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbmrx.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbmrx.h

Abstract:

    The global include file for SMB mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

--*/

#ifndef _SMBMRX_H_
#define _SMBMRX_H_


#include "align.h"

#define INCLUDE_SMB_ALL
#define INCLUDE_SMB_CAIRO

#include "status.h"
#include "smbtypes.h"
#include "smbmacro.h"
#include "smb.h"
#include "smbtrans.h"
#include "smbtrace.h"
#include "smbtrsup.h"
#include "smbgtpt.h"
#include "smb64.h"

#define RX_MAP_STATUS(__xxx) ((NTSTATUS)STATUS_##__xxx) //temporary.....


#include "remboot.h"
#include "mrxglbl.h"    // global data declarations/defines etc.
#include "smbpoolt.h"   // Pool tag definitions


#define SMBMRX_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MRxSmb\\Parameters"

#define SMBMRX_WORKSTATION_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Parameters"

#define SMBMRX_REDIR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Redir\\Parameters"

#define EVENTLOG_MRXSMB_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\System\\mrxsmb"

#define SYSTEM_SETUP_PARAMETERS \
    L"\\Registry\\Machine\\System\\Setup"

typedef  ULONG  CSC_SHARE_HANDLE,  *PCSC_SHARE_HANDLE;
typedef  ULONG  CSC_SHADOW_HANDLE, *PCSC_SHADOW_HANDLE;

typedef struct tagCSC_ROOT_INFO {
    CSC_SHARE_HANDLE    hShare;
    CSC_SHADOW_HANDLE   hRootDir;
    USHORT              ShareStatus;
    USHORT              Flags;
}
CSC_ROOT_INFO, *PCSC_ROOT_INFO;

#define CSC_ROOT_INFO_FLAG_DFS_ROOT 0x0001
//mini's does use these
#undef RxCaptureRequestPacket
#undef RxCaptureParamBlock

//
typedef enum _SMBFCB_HOLDING_STATE {
    SmbFcb_NotHeld = 0,
    SmbFcb_HeldShared = 1,
    SmbFcb_HeldExclusive = 2
} SMBFCB_HOLDING_STATE;

//
// With respect to CSC the server entry is in one of the following states
//  it is being shadowed in connected mode
//  it has been setup for disconnected mode of operation
//  it has been transitioned from disconnected mode to connected mode of operation
//
// The following enumerated type captures these states for the server

typedef enum _SERVER_CSC_STATE_ {
    ServerCscShadowing,
    ServerCscDisconnected,
    ServerCscTransitioningToShadowing,
    ServerCscTransitioningToDisconnected
} SERVER_CSC_STATE, *PSERVER_CSC_STATE;

#if defined(REMOTE_BOOT)
//
// On a remote boot system, we need to save the parameters passed to
// RxFinishFcbInitialization until later. This structure saves them.
//

typedef struct _FINISH_FCB_INIT_PARAMETERS {
    BOOLEAN                 CallFcbFinishInit;
    BOOLEAN                 InitPacketProvided;
    RX_FILE_TYPE            FileType;
    FCB_INIT_PACKET         InitPacket;
} FINISH_FCB_INIT_PARAMETERS, *PFINISH_FCB_INIT_PARAMETERS;
#endif

//
// Sometimes for Csc, we need to pass in a structure that's like a SMB_MRX_FCB
// but it only contains certain fields: i.e. the shadow handles and the status
// we declare these separately so that we can declare just the minimal thing but
// still we can find the containing record if necessary.

// hShadowRenamed and it's parent have to be added because after the rename the name
// in the fcb is still the same, so if there is a delete pending on this fcb
// we endup deleting to source of the rename instead of the target.
// most of the time this not a problem, but when word saves a file the following sequence happens
// ren foo.doc -> ~w000x.tmp
// ren ~w000y.tmp foo.doc
// del ~w000x.tmp
// The last delete causes foo.doc to be deleted becuase in DeleteAfterCloseEpilogue
// we endup looking the inode based on the wrong name and delete that.
// We do the lookup becuase we set hShadow to 0. This is done becuase of a complicated
// set of reasons. So we endup having to have two more entries to identify the new
// inode after rename

typedef struct _MINIMAL_CSC_SMBFCB {
    CSC_SHADOW_HANDLE   hShadow;
    CSC_SHADOW_HANDLE   hParentDir;

    CSC_SHADOW_HANDLE   hShadowRenamed;       // these are set of an inode is renamed
    CSC_SHADOW_HANDLE   hParentDirRenamed;    // we use these for deleteonclose

    PMRX_FCB    ContainingFcb;

    USHORT  ShadowStatus;
    USHORT  LocalFlags;
    USHORT  LastComponentOffset;
    USHORT  LastComponentLength;
    ULONG   cntLocalOpens;                      // count of local opens on this FCB
                                                // can be non-zero only for VDO shares
    CSC_ROOT_INFO   sCscRootInfo;

    UNICODE_STRING  uniDfsPrefix;                 // Dfs reverse mapping strings
    UNICODE_STRING  uniActualPrefix;
    BOOL            fDoBitCopy;
    LPVOID          lpDirtyBitmap;

} MINIMAL_CSC_SMBFCB, *PMINIMAL_CSC_SMBFCB;

//
// A pointer to an instance of MRX_SMB_FCB is stored in the context field of
// MRX_FCBs handled by the SMB mini rdr.
//

typedef struct _MRX_SMB_FCB_ {
    //M for Minirdr
    ULONG   MFlags;
    USHORT  WriteOnlySrvOpenCount;
    USHORT  NumberOfFailedCompressedWrites;

    SMB_TREE_ID Tid;
    USHORT      LastOplockLevel;

    // CODE.IMPROVEMENT all this stuff is for CSC.... it could/should be allocated
    // independently
    union {
        MINIMAL_CSC_SMBFCB;
        MINIMAL_CSC_SMBFCB MinimalCscSmbFcb;
    };

    LIST_ENTRY ShadowReverseTranslationLinks;

    BOOLEAN ShadowIsCorrupt;

    ULONG           LastCscTimeStampLow;
    ULONG           LastCscTimeStampHigh;
    LARGE_INTEGER   NewShadowSize;
    LARGE_INTEGER   OriginalShadowSize;
    ULONG           dwFileAttributes;

    PMRX_SRV_OPEN SurrogateSrvOpen;
    PMRX_FOBX     CopyChunkThruOpen;

    //read/write synchronization
    LIST_ENTRY CscReadWriteWaitersList;
    LONG       CscOutstandingReaders; //-1 => a single writer
    FAST_MUTEX CscShadowReadWriteMutex;

    LARGE_INTEGER   ExpireTime;  // It's time for get attributs from server
    LARGE_INTEGER   IndexNumber; // Fid 

#if defined(REMOTE_BOOT)
    //stores saved RxFinishFcbInitialization parameters

    PFINISH_FCB_INIT_PARAMETERS FinishFcbInitParameters;
#endif

} MRX_SMB_FCB, *PMRX_SMB_FCB;

#define AttributesSyncInterval 10  // Number of seconds before local file attributes expired

#define MRxSmbGetFcbExtension(pFcb)      \
        (((pFcb) == NULL) ? NULL : (PMRX_SMB_FCB)((pFcb)->Context))

#define SMB_FCB_FLAG_SENT_DISPOSITION_INFO      0x00000001
#define SMB_FCB_FLAG_WRITES_PERFORMED           0x00000002
#define SMB_FCB_FLAG_LONG_FILE_NAME             0x00000004
#define SMB_FCB_FLAG_CSC_TRUNCATED_SHADOW		0x00000008

typedef struct _SMBPSE_FILEINFO_BUNDLE {
    FILE_BASIC_INFORMATION Basic;
    FILE_STANDARD_INFORMATION Standard;
    FILE_INTERNAL_INFORMATION Internal;
} SMBPSE_FILEINFO_BUNDLE, *PSMBPSE_FILEINFO_BUNDLE;

typedef struct _MRXSMB_CREATE_PARAMETERS {
    //this is done this way for when this expands...as it's likely too
    //CODE.IMPROVEMENT for example, we should put the mapped stuff in here
    ULONG Pid;
    UCHAR SecurityFlags;
} MRXSMB_CREATE_PARAMETERS, *PMRXSMB_CREATE_PARAMETERS;

typedef struct _MRX_SMB_DEFERRED_OPEN_CONTEXT {
    NT_CREATE_PARAMETERS     NtCreateParameters; // a copy of the createparameters
    ULONG                    RxContextFlags;
    MRXSMB_CREATE_PARAMETERS SmbCp;
    USHORT                   RxContextCreateFlags;
} MRX_SMB_DEFERRED_OPEN_CONTEXT, *PMRX_SMB_DEFERRED_OPEN_CONTEXT;

//
// A pointer to an instance of MRX_SMB_SRV_OPEN is stored in the context fields
// of MRX_SRV_OPEN handled by the SMB mini rdr. This encapsulates the FID used
// to identify open files/directories in the SMB protocol.

typedef struct _MRX_SMB_SRV_OPEN_ {
    ULONG       Flags;
    ULONG       Version;
    SMB_FILE_ID Fid;
    UCHAR       OplockLevel;

    //for CSC
    PVOID   hfShadow;
    ACCESS_MASK MaximalAccessRights;
    ACCESS_MASK GuestMaximalAccessRights;

    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext;

    // the following fields are used for to save the results of a GetFileAttributes
    // and to validate whether the fields should be reused or not

    ULONG                  RxContextSerialNumber;
    LARGE_INTEGER          TimeStampInTicks;
    SMBPSE_FILEINFO_BUNDLE FileInfo;

    // the following fields are used for preventing multiple reconnection activties
    // to the remote boot server while the connection is lost.
    LIST_ENTRY             ReconnectSynchronizationExchanges;
    LONG                   HotReconnectInProgress;
    
    BOOLEAN                NumOfSrvOpenAdded;    // debug only

    BOOLEAN                DeferredOpenInProgress;
    LIST_ENTRY             DeferredOpenSyncContexts;
    
    USHORT                 FileStatusFlags;
    BOOLEAN                IsNtCreate;
} MRX_SMB_SRV_OPEN, *PMRX_SMB_SRV_OPEN;

typedef struct _DEFERRED_OPEN_SYNC_CONTEXT_ {
    LIST_ENTRY  ListHead;
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;
} DEFERRED_OPEN_SYNC_CONTEXT, *PDEFERRED_OPEN_SYNC_CONTEXT;

typedef struct _PAGING_FILE_CONTEXT_ {
    PMRX_SRV_OPEN pSrvOpen;
    PMRX_FOBX     pFobx;

    // The following LIST_ENTRY is used for two purposes.
    // while a reconnect is not in progress it is threaded together to maintain
    // a list of all SRV_OPEN instances corresponding to paging files. Note
    // that this is not done for non paging files.
    // When a reconnect is in progress the field is used to ensure that
    // there is atmost one reconnect request in progress for any given SRV_OPEN
    // instance at the server
    // All manipulation of this list is done while owning the SmbCeSpinLock,

    LIST_ENTRY    ContextList;
} PAGING_FILE_CONTEXT, *PPAGING_FILE_CONTEXT;

#define SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN       0x00000001
#define SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN       0x00000002
#define SMB_SRVOPEN_FLAG_CANT_GETATTRIBS       0x00000004
#define SMB_SRVOPEN_FLAG_DEFERRED_OPEN         0x00000008
#define SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE     0x00000010
#define SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN        0x00000020
#define SMB_SRVOPEN_FLAG_OPEN_SURROGATED       0x00000040
#define SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN     0x00000080
#define SMB_SRVOPEN_FLAG_FILE_DELETED          0x00000100
#define SMB_SRVOPEN_FLAG_LOCAL_OPEN            0x00000200

#define SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED  0x00000400
#define SMB_SRVOPEN_FLAG_SHADOW_ATTRIB_MODIFIED 0x00000800
#define SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED    0x00001000

#define SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN   0x00002000

#define SMB_SRVOPEN_FLAG_SHADOW_MODIFIED         (SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED|\
                                                  SMB_SRVOPEN_FLAG_SHADOW_ATTRIB_MODIFIED|\
                                                  SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED)

#define MRxSmbGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PMRX_SMB_SRV_OPEN)((pSrvOpen)->Context))

INLINE
BOOLEAN
MRxSmbIsThisADisconnectedOpen(PMRX_SRV_OPEN SrvOpen)
{
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    return BooleanFlagOn(
               smbSrvOpen->Flags,
               SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN);
}

typedef USHORT SMB_SEARCH_HANDLE;

typedef struct _MRX_SMB_DIRECTORY_RESUME_INFO {
   REQ_FIND_NEXT2 FindNext2_Request;
   //now we have to include space for a resume name........
   WCHAR NameSpace[MAXIMUM_FILENAME_LENGTH+1]; //trailing null
   USHORT ParametersLength;
} MRX_SMB_DIRECTORY_RESUME_INFO, *PMRX_SMB_DIRECTORY_RESUME_INFO;

// A pointer to an instance of MRX_SMB_FOBX is stored in the context field
// of MRX_FOBXs handled by the SMB mini rdr. Depending upon the file type
// i.e., file or directory the appropriate context information is stored.

typedef struct _MRX_SMB_FOBX_ {
   union {
       struct {
           struct {
               SMB_SEARCH_HANDLE SearchHandle;
               ULONG Version;
               union {
                   //the close code will try to free this!
                   PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo;
                   PSMB_RESUME_KEY CoreResumeKey;
               };
               struct {
                   //unaligned direntry sidebuffering params
                   PBYTE UnalignedDirEntrySideBuffer;    //close will try to free this too
                   ULONG SerialNumber;
                   BOOLEAN EndOfSearchReached;
                   BOOLEAN IsUnicode;
                   BOOLEAN IsNonNtT2Find;
                   ULONG   FilesReturned;
                   ULONG EntryOffset;
                   ULONG TotalDataBytesReturned;
                   //ULONG ReturnedEntryOffset;
               };
           };
           NTSTATUS ErrorStatus;
           USHORT Flags;
           USHORT FileNameOffset;
           USHORT FileNameLengthOffset;
           BOOLEAN WildCardsFound;
       } Enumeration;
   };
   union {
       struct {
           //dont do this yet
           //ULONG MaximumReadBufferLength;
           //ULONG MaximumWriteBufferLength;
           USHORT Flags;
       } File;
   };
} MRX_SMB_FOBX, *PMRX_SMB_FOBX;

#define MRxSmbGetFileObjectExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PMRX_SMB_FOBX)((pFobx)->Context))

#define SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST    0x0001
#define SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN      0x0002
#define SMBFOBX_ENUMFLAG_FAST_RESUME             0x0004
#define SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS 0x0008
#define SMBFOBX_ENUMFLAG_LOUD_FINALIZE           0x0010
#define SMBFOBX_ENUMFLAG_READ_FROM_CACHE         0x0020
#define SMBFOBX_ENUMFLAG_IS_CSC_SEARCH           0x0100
#define SMBFOBX_ENUMFLAG_NO_WILDCARD             0x0200

typedef
NTSTATUS
(NTAPI *PMRXSMB_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

// The RX_CONTEXT instance has four fields ( ULONG's ) provided by the wrapper
// which can be used by the mini rdr to store its context. This is used by
// the SMB mini rdr to identify the parameters for request cancellation

typedef struct _MRXSMB_RX_CONTEXT {
   PMRXSMB_CANCEL_ROUTINE          pCancelRoutine;
   PVOID                           pCancelContext;
   struct _SMB_EXCHANGE            *pExchange;
   struct _SMBSTUFFER_BUFFER_STATE *pStufferState;
} MRXSMB_RX_CONTEXT, *PMRXSMB_RX_CONTEXT;


#define MRxSmbGetMinirdrContext(pRxContext)     \
        ((PMRXSMB_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define MRxSmbMakeSrvOpenKey(Tid,Fid) \
        ULongToPtr(((ULONG)(Tid) << 16) | (ULONG)(Fid))

//
// forward declarations for all dispatch vector methods.
//

extern NTSTATUS
MRxSmbStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxSmbStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxSmbMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

extern NTSTATUS
MRxSmbDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbRead (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbWrite (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbLocks(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbFlush(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

#if 0
extern NTSTATUS
MRxSmbUnlockRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_LOCK_INFO LockInfo
    );
#endif

extern NTSTATUS
MRxSmbComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

extern NTSTATUS
MRxSmbFlush (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbIsValidDirectory (
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    );

extern NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxSmbQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

extern NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

extern NTSTATUS
MRxSmbFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

extern NTSTATUS
MRxSmbUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

extern NTSTATUS
MRxSmbCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

extern NTSTATUS
MRxSmbFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

extern NTSTATUS
MRxSmbSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);

extern NTSTATUS
MRxSmbQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
MRxSmbQueryNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID              Buffer,
    IN OUT PULONG             pLengthRemaining
    );

extern NTSTATUS
MRxSmbSetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
MRxSmbSetNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN     PVOID              pBuffer,
    IN     ULONG              BufferLength
    );

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

extern NTSTATUS
MRxSmbForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

extern NTSTATUS
MRxSmbExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
MRxSmbExtendForNonCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );

//csc dcon needs to see this
NTSTATUS
MRxSmbGetFsAttributesFromNetRoot(
    IN OUT PRX_CONTEXT RxContext
    );

#include "smbwmi.h"
#include "smbutils.h"
#include "smbce.h"
#include "midatlas.h"
#include "smbcedbp.h"
#include "smbcedb.h"
#include "smbxchng.h"
#include "stuffer.h"
#include "smbpse.h"
#include "smbcaps.h"
#include "transprt.h"
#include "transact.h"
#include "recursvc.h"   // recurrent service definitions
#include "smbadmin.h"
#include "smbmrxmm.h"   // memory mgmt. routines
#include "smbprocs.h"   // crossreferenced routines
#include "manipmdl.h"   // routines for MDL substringing
#include "devfcb.h"     // includes Statistics data strcutures/macros
#include "smbea.h"
#include "csc.h"

#endif   // _SMBMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbdebug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:
    smbdebug.h
--*/

#ifndef _SMBDEBUG_H_
#define _SMBDEBUG_H_

//
// Structs for IOCTL_GET_DEBUG_INFO
//

typedef struct _SMBCEDB_NETROOT_ENTRY_ARG2 {
    PWCHAR                Name;
    ULONG                 MaximalAccessRights;
    ULONG                 GuestMaximalAccessRights;
    BOOLEAN               DfsAware;
    ULONG                 hShare;
    ULONG                 hRootDir;
    USHORT                ShareStatus;
    BOOLEAN               CscEnabled;
    BOOLEAN               CscShadowable;
    BOOLEAN               Disconnected;
} SMBCEDB_NETROOT_ENTRY_ARG2, *PSMBCEDB_NETROOT_ENTRY_ARG2;

typedef struct _SMBCEDB_NETROOT_ENTRY_ARG {
    PWCHAR                Name;
    ULONG                 MaximalAccessRights;
    ULONG                 GuestMaximalAccessRights;
    BOOLEAN               DfsAware;
    ULONG                 hShare;
    ULONG                 hRootDir;
    USHORT                ShareStatus;
    ULONG                 CscFlags;
    BOOLEAN               CscEnabled;
    BOOLEAN               CscShadowable;
    BOOLEAN               Disconnected;
} SMBCEDB_NETROOT_ENTRY_ARG, *PSMBCEDB_NETROOT_ENTRY_ARG;

typedef struct _SMBCEDB_SERVER_ENTRY_ARG2 {
    PWCHAR                Name;
    PWCHAR                DomainName;
    ULONG                 ServerStatus;
    PWCHAR                DfsRootName;
    PWCHAR                DnsName;
    BOOLEAN               SecuritySignaturesEnabled;
    ULONG                 CscState;
    BOOLEAN               IsFakeDfsServerForOfflineUse;
    ULONG                 NetRootEntryCount;
    union {
        PSMBCEDB_NETROOT_ENTRY_ARG2 pNetRoots2;   // Array, # is NetRootEntryCount
        PSMBCEDB_NETROOT_ENTRY_ARG  pNetRoots;    // Array, # is NetRootEntryCount
    };
} SMBCEDB_SERVER_ENTRY_ARG2, *PSMBCEDB_SERVER_ENTRY_ARG2;

typedef struct _SMBCEDB_SERVER_ENTRY_ARG {
    PWCHAR                Name;
    PWCHAR                DomainName;
    ULONG                 ServerStatus;
    PWCHAR                DfsRootName;
    PWCHAR                DnsName;
    BOOLEAN               SecuritySignaturesEnabled;
    ULONG                 CscState;
    BOOLEAN               IsFakeDfsServerForOfflineUse;
    BOOLEAN               IsPinnedOffline;
    ULONG                 NetRootEntryCount;
    union {
        PSMBCEDB_NETROOT_ENTRY_ARG2 pNetRoots2;   // Array, # is NetRootEntryCount
        PSMBCEDB_NETROOT_ENTRY_ARG  pNetRoots;    // Array, # is NetRootEntryCount
    };
} SMBCEDB_SERVER_ENTRY_ARG, *PSMBCEDB_SERVER_ENTRY_ARG;

typedef struct _MRX_SMB_FCB_ENTRY_ARG {
    ULONG                   MFlags;
    USHORT                  Tid;
    BOOLEAN                 ShadowIsCorrupt;
    ULONG                   hShadow;
    ULONG                   hParentDir;
    ULONG                   hShadowRenamed;
    ULONG                   hParentDirRenamed;
    USHORT                  ShadowStatus;
    USHORT                  LocalFlags;
    USHORT                  LastComponentOffset;
    USHORT                  LastComponentLength;
    ULONG                   hShare;
    ULONG                   hRootDir;
    USHORT                  ShareStatus;
    USHORT                  Flags;
    PWCHAR                  DfsPrefix;
    PWCHAR                  ActualPrefix;
} MRX_SMB_FCB_ENTRY_ARG, *PMRX_SMB_FCB_ENTRY_ARG;

typedef struct _IOCTL_GET_DEBUG_INFO_ARG {
    ULONG Status;
    ULONG Version;
    ULONG EntryCount;
    union {
        SMBCEDB_SERVER_ENTRY_ARG ServerEntryObject[1];
        SMBCEDB_SERVER_ENTRY_ARG2 ServerEntryObject2[1];
        MRX_SMB_FCB_ENTRY_ARG FcbEntryObject[1];
    };
} IOCTL_GET_DEBUG_INFO_ARG, *PIOCTL_GET_DEBUG_INFO_ARG;

#define OFFSET_TO_POINTER(field, buffer)  \
    ( ((PCHAR)field) += ((ULONG_PTR)buffer) )

#define POINTER_TO_OFFSET(field, buffer)  \
    ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )

#define DEBUG_INFO_SERVERLIST   1
#define DEBUG_INFO_CSCFCBSLIST  2
    
#endif  // _SMBDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbmrxmm.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbmrxmm.h

Abstract:

    This module implements the memory managment routines for the SMB mini redirector

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

Notes:

    The SMB mini redirector manipulates entities which have very different usage patterns.
    They range from very static entities ( which are allocated and freed with a very low
    frequency ) to very dynamic entities.

    The entities manipulated in the SMB mini redirector are SMBCE_SERVER, SMBCE_NET_ROOT,
    SMBCE_VC, SMBCE_SESSION. These represent a connection to a server, a share on a particular
    server, a virtual circuit used in the connection and a session for a particular user.

    These are not very dynamic, i.e., the allocation/deallocation is very infrequent. The
    SMB_EXCHANGE and SMBCE_REQUEST map to the SMB's that are sent along that a connection.
    Every file operation in turn maps to a certain number of calls for allocationg/freeing
    exchanges and requests. Therefore it is imperative that some form of scavenging/caching
    of recently freed entries be maintained to satisfy requests quickly.

    In the current implementation the exchanges and requests are implemented using the zone
    allocation primitives.

--*/

#ifndef _SMBMRXMM_H_
#define _SMBMRXMM_H_

//
// Object Allocation and deletion
//

extern PVOID
SmbMmAllocateObject(SMBCEDB_OBJECT_TYPE ObjectType);

extern VOID
SmbMmFreeObject(PVOID pObject);

extern PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(PSMBCEDB_SERVER_ENTRY pServerEntry, BOOLEAN RemoteBootSession);

extern VOID
SmbMmFreeSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern PVOID
SmbMmAllocateExchange(
    SMB_EXCHANGE_TYPE ExchangeType,
    PVOID             pv);

extern VOID
SmbMmFreeExchange(PVOID pExchange);

extern PVOID
SmbMmAllocateServerTransport(SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType);

extern VOID
SmbMmFreeServerTransport(PSMBCE_SERVER_TRANSPORT);


#define SmbMmInitializeHeader(pHeader)                        \
         RtlZeroMemory((pHeader),sizeof(SMBCE_OBJECT_HEADER))

#endif _SMBMRXMM_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbpoolt.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbpoolt.h

Abstract:

    The pool tag definitions for SMB mini redirector

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled. For most builds the tags should be aliased such that about
   6 tags are consumed by the mini redirector. In special builds the aliasing of tags
   will be suppressed, thereby consuming more tags to track down memory leaks easily.

   The following are the major tags ....

      1) SmCe -- the Smb Mini Redirector connection engine.

      2) SmOe -- the Smb Mini redirector ordinary exchange related allocation.

      3) SmAd -- the Smb Mini redirector ADMIN exchange/session setup/tree connect etc.

      4) SmRw -- the Smb mini redirector read/write paths

      5) SmTr -- the Transact exchange related allocations

      6) SmMs -- the miscellanous category.

      7) SmRb -- the remote boot category.

--*/

#ifndef _SMBPOOLT_H_
#define _SMBPOOLT_H_

#define MRXSMB_CE_POOLTAG        ('eCmS')
#define MRXSMB_MM_POOLTAG        ('mMmS')
#define MRXSMB_ADMIN_POOLTAG     ('dAmS')
#define MRXSMB_RW_POOLTAG        ('wRmS')
#define MRXSMB_XACT_POOLTAG      ('rTmS')
#define MRXSMB_MISC_POOLTAG      ('sMmS')
#define MRXSMB_TRANSPORT_POOLTAG ('pTmS')
#define MRXSMB_REMOTEBOOT_POOLTAG ('bRmS')

extern ULONG MRxSmbExplodePoolTags;

#define MRXSMB_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((MRxSmbExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define MRXSMB_FSCTL_POOLTAG     MRXSMB_DEFINE_POOLTAG('cFmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_DIRCTL_POOLTAG    MRXSMB_DEFINE_POOLTAG('cDmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_PIPEINFO_POOLTAG  MRXSMB_DEFINE_POOLTAG('iPmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_DEFROPEN_POOLTAG  MRXSMB_DEFINE_POOLTAG('ODmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_QPINFO_POOLTAG    MRXSMB_DEFINE_POOLTAG('PQmS',MRXSMB_MISC_POOLTAG)
#define MRXSMB_RXCONTEXT_POOLTAG MRXSMB_DEFINE_POOLTAG('xRmS',MRXSMB_MISC_POOLTAG)

#define MRXSMB_VNETROOT_POOLTAG  MRXSMB_DEFINE_POOLTAG('rVmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_SERVER_POOLTAG    MRXSMB_DEFINE_POOLTAG('rSmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_SESSION_POOLTAG   MRXSMB_DEFINE_POOLTAG('eSmS',MRXSMB_CE_POOLTAG)
#define MRXSMB_NETROOT_POOLTAG   MRXSMB_DEFINE_POOLTAG('rNmS',MRXSMB_CE_POOLTAG)

#define MRXSMB_MIDATLAS_POOLTAG  MRXSMB_DEFINE_POOLTAG('aMmS', MRXSMB_CE_POOLTAG)

#define MRXSMB_MAILSLOT_POOLTAG  MRXSMB_DEFINE_POOLTAG('tMmS', MRXSMB_CE_POOLTAG)
#define MRXSMB_VC_POOLTAG        MRXSMB_DEFINE_POOLTAG('cVmS',MRXSMB_CE_POOLTAG)

#define MRXSMB_ECHO_POOLTAG      MRXSMB_DEFINE_POOLTAG('cEmS',MRXSMB_ADMIN_POOLTAG)

#define MRXSMB_KERBEROS_POOLTAG  MRXSMB_DEFINE_POOLTAG('sKmS',MRXSMB_ADMIN_POOLTAG)

// NodeType Codes

#define SMB_EXCHANGE_CATEGORY             (0xed)
#define SMB_CONNECTION_ENGINE_DB_CATEGORY (0xea)
#define SMB_SERVER_TRANSPORT_CATEGORY     (0xeb)

#define SMB_EXCHANGE_NTC(x) \
        ((SMB_EXCHANGE_CATEGORY << 8) | (x))

#define SMB_CONNECTION_ENGINE_NTC(x)    \
        ((SMB_CONNECTION_ENGINE_DB_CATEGORY << 8) | (x))

#define SMB_NTC_STUFFERSTATE  0xed80

#endif _SMBPOOLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbprocs.h

Abstract:

    Prototypes for routines that cross protocol-selection boundaries

Author:


Revision History:

--*/

#ifndef _SMBPROCS_H_
#define _SMBPROCS_H_

#include "exsessup.h"
#include "tdikrnl.h"

//cross-referenced internal routines

//from rename.c
MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      );

//from openclos.c
NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName);

//paged internal routines


NTSTATUS
MRxSmbSetConfigurationInformation(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbGetConfigurationInformation(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetDomainName(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetServerGuid(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbTestDevIoctl(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbExternalStart (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbGetStatistics(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbQueryQuotaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbSetQuotaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    );

VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    );

PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    );

ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    );

PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

NTSTATUS
MRxSmbSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    );

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    SMBFCB_HOLDING_STATE *SmbFcbHoldingState,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
SmbCeInitializeExtendedSessionSetupExchange(
    PSMB_EXCHANGE*  pExchangePtr,
    PMRX_V_NET_ROOT pVNetRoot);

VOID
SmbCeDiscardExtendedSessionSetupExchange(
    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSessionSetupExchange);

NTSTATUS
SmbExtSecuritySessionSetupExchangeStart(
    PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbExtSecuritySessionSetupExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG   BytesIndicated,
    IN ULONG   BytesAvailable,
    OUT ULONG  *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL   *pDataBufferPointer,
    OUT PULONG pDataSize,
    IN ULONG   ReceiveFlags);

NTSTATUS
SmbExtSecuritySessionSetupExchangeSendCompletionHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL       pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize);

VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    );

VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    );

VOID
MRxSmbTranslateLanManFindBuffer(
    PRX_CONTEXT RxContext,
    PULONG PreviousReturnedEntry,
    PBYTE ThisEntryInBuffer
    );

NTSTATUS
MrxSmbUnalignedDirEntryCopyTail(
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  pBuffer,
    IN OUT PULONG                 pLengthRemaining,
    IN OUT PMRX_SMB_FOBX          smbFobx
    );

NTSTATUS
MRxSmbQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    );

NTSTATUS
MRxSmbQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      );

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      );

NTSTATUS
MRxSmbSetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      );

    NTSTATUS
MRxSmbSetFileInformation (
      IN PRX_CONTEXT  RxContext
      );

NTSTATUS
MRxSmbQueryNamedPipeInformation(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN OUT PVOID              pBuffer,
      IN OUT PULONG             pLengthRemaining);

NTSTATUS
MRxSmbSetNamedPipeInformation(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                 BufferLength);

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    );

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT PSMBCE_NET_ROOT  psmbNetRoot,
    IN     PSMBCE_SERVER    pServer
    );

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      );

NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

VOID MRxSmbCoreFileSeach_AssertFields(void);

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    );

MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

 NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );

NTSTATUS
MRxSmbExtendForCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxSmbExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    );

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      );

NTSTATUS
MRxSmbFsCtl(
      IN OUT PRX_CONTEXT RxContext);

VOID
MRxSmbNotifyChangeDirectoryCompletion(
   struct _SMB_NOTIFY_CHANGE_DIRECTORY_CONTEXT_ *pNotificationContext);

NTSTATUS
MRxSmbNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbNamedPipeFsControl(PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbFsCtlUserTransact(PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbMailSlotFsControl(PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbDfsFsControl(PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbFsControl(PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbIoCtl(
      IN OUT PRX_CONTEXT RxContext);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MRxSmbInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN enum _MRXSMB_INIT_STATES MRxSmbInitState
    );


VOID
MRxSmbInitUnwindSmb(
    IN PDRIVER_OBJECT DriverObject,
    IN enum _MRXSMB_INIT_STATES MRxSmbInitState
    );

VOID
MRxSmbInitUnwindBowser(
    IN PDRIVER_OBJECT DriverObject,
    IN enum _MRXSMB_INIT_STATES MRxSmbInitState
    );


VOID
MRxSmbUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MRxSmbStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxSmbStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxSmbInitializeSecurity (VOID);

NTSTATUS
MRxSmbUninitializeSecurity(VOID);

VOID
MRxSmbReadMiscellaneousRegistryParameters();

NTSTATUS
SmbCeGetConfigurationInformation();

NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MRxSmbPreUnload(
    VOID
    );

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxSmbGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    );

NTSTATUS
MRxSmbInitializeTables(void);

NTSTATUS
MRxSmbLocks(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbBuildLocksAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState);

NTSTATUS
MRxSmbBuildLockAssert (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFinishLocks (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_LOCKING_ANDX             Response
      );

NTSTATUS
MRxSmbUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    );

NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbFlush(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

NTSTATUS
MRxSmbFinishFlush (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_FLUSH             Response
      );


VOID
_InitializeMidMapFreeList(struct _MID_MAP_ *pMidMap);

PMID_ATLAS
FsRtlCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart);

VOID
_UninitializeMidMap(
         struct _MID_MAP_    *pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor);

VOID
FsRtlDestroyMidAtlas(
   PMID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor);

NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize);

NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize);

VOID
MRxSmbMungeBufferingIfWriteOnlyHandles (
    ULONG WriteOnlySrvOpenCount,
    PMRX_SRV_OPEN SrvOpen
    );

VOID
MRxSmbCopyAndTranslatePipeState(
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG       PipeState
    );

BOOLEAN
IsReconnectRequired(
      PMRX_SRV_CALL SrvCall);

BOOLEAN
MRxSmbIsCreateWithEasSidsOrLongName(
      IN OUT PRX_CONTEXT RxContext,
      OUT    PULONG      DialectFlags
      );

NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      );

NTSTATUS
MRxSmbComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState);

NTSTATUS
MRxSmbConstructDeferredOpenContext (
    IN OUT PRX_CONTEXT RxContext
      );

VOID
MRxSmbAdjustCreateParameters (
    PRX_CONTEXT RxContext,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

VOID
MRxSmbAdjustReturnedCreateAction(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildNtCreateAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

NTSTATUS
MRxSmbBuildOpenAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    );

NTSTATUS
MRxSmbBuildOpenPrintFile (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Create(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

VOID
MRxSmbSetSrvOpenFlags (
    PRX_CONTEXT  RxContext,
    RX_FILE_TYPE StorageType,
    PMRX_SRV_OPEN SrvOpen,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    );

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    SMBFCB_HOLDING_STATE *SmbFcbHoldingState,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishNTCreateAndX (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_NT_CREATE_ANDX        Response
      );

NTSTATUS
MRxSmbFinishOpenAndX (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN_ANDX        Response
      );

NTSTATUS
MRxSmbFinishCreatePrintFile (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN_PRINT_FILE       Response
      );

NTSTATUS
MRxSmbFinishT2OpenFile (
    IN OUT PRX_CONTEXT            RxContext,
    IN     PRESP_OPEN2            Response,
    IN OUT PBOOLEAN               MustRegainExclusiveResource,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState,
    IN     ULONG                  ServerVersion
    );

NTSTATUS
MRxSmbT2OpenFile(
      IN OUT PRX_CONTEXT RxContext,
      IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

NTSTATUS
MRxSmbFinishLongNameCreateFile (
    IN OUT PRX_CONTEXT                RxContext,
    IN     PRESP_CREATE_WITH_SD_OR_EA Response,
    IN     PBOOLEAN                   MustRegainExclusiveResource,
    IN OUT SMBFCB_HOLDING_STATE       *SmbFcbHoldingState,
    IN     ULONG                      ServerVersion
    );

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName(
      IN OUT PRX_CONTEXT RxContext,
      IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

NTSTATUS
MRxSmbZeroExtend(
      IN PRX_CONTEXT pRxContext);

NTSTATUS
MRxSmbTruncate(
      IN PRX_CONTEXT pRxContext);

NTSTATUS
MRxSmbCleanupFobx(
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen);

NTSTATUS
MRxSmbCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      );

NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildClosePrintFile (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Close(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishClose (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CLOSE                 Response
      );

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    );

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes
    );

NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    );

NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    );

NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      );

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      );

NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );

NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    );

BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    );

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    );

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    );

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    );

ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    ULONG     Disposition
    );

USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    );

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    );

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    );

NTSTATUS
MRxSmbRead(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildReadAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
MRxSmbBuildCoreRead (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
MRxSmbBuildSmallRead (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    );

NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishNoCopyRead (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbBuildRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbBuildDeleteForRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbFinishRename (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_RENAME                 Response
      );

NTSTATUS
MRxSmbBuildCheckEmptyDirectory (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval);

VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID   pContext);

NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

NTSTATUS
MRxSmbInitializeRecurrentServices();

VOID
MRxSmbTearDownRecurrentServices();

NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall,
    BOOLEAN               RemoteBootSession);

NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry);

NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand);

VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange);

NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange);

NTSTATUS
SmbAdminExchangeStart(
    PSMB_EXCHANGE  pExchange);

VOID
SmbCeCreateSrvCall(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

NTSTATUS
MRxSmbCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

NTSTATUS
MRxSmbFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN       Force);

NTSTATUS
MRxSmbSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext);

NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);

VOID
MRxSmbMaskNegotiateSmb ();

NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength,
    BOOLEAN  RemoteBootSession);

LARGE_INTEGER
ConvertSmbTimeToTime (
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );

VOID
__SmbPseDbgCheckOEMdls(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    );

NTSTATUS
SmbPseContinueOrdinaryExchange(
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN     SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    );

NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState OPTIONAL,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    );

VOID
SmbPseFinalizeOETrace(PSZ text,ULONG finalstate);

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

NTSTATUS
SmbPseExchangeAssociatedExchangeCompletionHandler_default(
    IN OUT PSMB_EXCHANGE  pExchange,
    OUT    BOOLEAN        *pPostFinalize
    );

NTSTATUS
SmbPseExchangeStart_default(
    IN PSMB_EXCHANGE    pExchange
    );

NTSTATUS
SmbPseExchangeCopyDataHandler_Read(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pCopyDataBuffer,
    IN ULONG            CopyDataSize
    );

VOID
__SmbPseRMTableEntry(
    UCHAR SmbCommand,
    UCHAR Flags,
    SMBPSE_RECEIVE_HANDLER_TOKEN ReceiveHandlerToken,
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler
#if DBG
    ,
    PBYTE IndicationString,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE HighType
#endif
    );

VOID
SmbPseInitializeTables(
    void
    );

NTSTATUS
MRxSmbQueryDosVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength
      );

VOID
MRxSmbSetFixedStufferStateFields (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN PMDL Mdl,
    IN PSMB_EXCHANGE     pExchange,
    IN PRX_CONTEXT RxContext,
    IN PBYTE ActualBufferBase,
    IN PBYTE BufferBase,
    IN PBYTE BufferLimit
    );

VOID SMBStuffHexDump(
    IN PBYTE Base,
    IN PBYTE Limit,
    IN ULONG  AddressOffset
    );

VOID
MRxSmbFakeUpAnMdl(
    IN OUT PMDL Mdl,
    IN PBYTE Base,
    IN ULONG Length
    );

VOID MRxSmbStfTestReadAndWrite();

VOID MRxSmbStfTestSessionStuff();

VOID MRxSmbStfTestMoreOpenStuff();

NTSTATUS
MRxSmbStufferDebug(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildSmbHeaderTestSurrogate(
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pNextCommandPtr);

VOID
SmbStuffWrapRtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    );

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command, //joejoe this next four params could come from a table...2offset and you're smaller
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    );

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    );

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbWrite (
      IN PRX_CONTEXT RxContext);

NTSTATUS
MRxSmbWriteMailSlot(
    PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    BOOLEAN                    IsPagingIo,
    UCHAR                      WriteCommand,
    ULONG                      ByteCount,
    PLARGE_INTEGER             ByteOffsetAsLI,
    PBYTE                      Buffer,
    PMDL                       BufferAsMdl);

NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
BuildCanonicalNetRootInformation(
            PUNICODE_STRING     pServerName,
            PUNICODE_STRING     pNetRootName,
            NET_ROOT_TYPE       NetRootType,
            BOOLEAN             fUnicode,
            BOOLEAN             fPostPendServiceString,
            PBYTE               *pBufferPointer,
            PULONG              pBufferSize);

NTSTATUS
CoreBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

NTSTATUS
LmBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

NTSTATUS
NtBuildTreeConnectSmb(
            PSMB_EXCHANGE     pExchange,
            PGENERIC_ANDX     pAndXSmb,
            PULONG            pAndXSmbBufferSize);

BOOLEAN
MRxSmbPackStringIntoConnectInfo(
    IN     PUNICODE_STRING String,
    IN     PUNICODE_STRING Source,
    IN OUT PCHAR * BufferStart,
    IN OUT PCHAR * BufferEnd,
    IN     ULONG   BufferDisplacement,
    IN OUT PULONG TotalBytes
    );

BOOLEAN
MRxSmbPackConnectEntry (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG Level,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN     PV_NET_ROOT VNetRoot,
    IN OUT ULONG   BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    );

VOID
MRxSmbGetConnectInfoLevel3Fields(
    IN OUT PLMR_CONNECTION_INFO_3 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY  pServerEntry,
    IN  BOOL    fAgentCall

    );

NTSTATUS
MRxSmbEnumerateConnections (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
MRxSmbGetConnectionInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
MRxEnumerateTransports(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN   pPostToFsp);

NTSTATUS
MRxEnumerateTransportBindings(
   IN PLMR_REQUEST_PACKET pLmrRequestPacket,
   IN ULONG               LmrRequestPacketLength,
   OUT PVOID              pBindingBuffer,
   IN OUT ULONG           BindingBufferLength);

VOID
MRxSmbDbgDumpMdlChain (
    PMDL MdlChain,
    PMDL WatchMdl,
    PSZ  Tagstring
    );

VOID MRxSmbTestStudCode(void);

NTSTATUS
MRxSmbUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot);

ULONG
MRxSmbGetDialectFlagsFromSrvCall(
    PMRX_SRV_CALL SrvCall
    );

NTSTATUS
MRxSmbCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect);

NTSTATUS
MRxSmbFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect);

NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot);

NTSTATUS
SmbCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot
    );

NTSTATUS
SmbConstructNetRootExchangeStart(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbConstructNetRootExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL       pCopyDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize);

VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

NTSTATUS
MRxSmbInitializeSmbCe();

NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange);

VOID
SmbCeSerializeSessionSetupRequests(
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

VOID
SmbCeUnblockSerializedSessionSetupRequests(
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

NTSTATUS
SmbCeReferenceSession(
    PSMB_EXCHANGE   pExchange);

NTSTATUS
SmbCeReferenceNetRoot(
    PSMB_EXCHANGE   pExchange);

NTSTATUS
SmbCeInitiateExchange(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       EnableCompletionHandlerInMasterExchange);

NTSTATUS
SmbCeExchangeAbort(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE     pExchange,
    IN OUT PVOID             pBuffer,
    IN     ULONG             BufferLength,
    OUT    PULONG            pBufferConsumed,
    OUT    PUCHAR            pLastCommandInHeader,
    OUT    PUCHAR            *pNextCommandPtr);

NTSTATUS
SmbCeResumeExchange(
    PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

NTSTATUS
SmbCePrepareExchangeForReuse(
    PSMB_EXCHANGE                 pExchange);


NTSTATUS
SmbCeUpdateSessionEntryAndVNetRootContext(
    PSMB_EXCHANGE pExchange);

VOID
SmbCeDiscardExchange(PVOID pExchange);

VOID
SmbCeDiscardExchangeWorkerThreadRoutine(PVOID pExchange);

NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext);

VOID
SmbCeFinalizeExchangeWorkerThreadRoutine(
    PSMB_EXCHANGE  pExchange);

VOID
SmbCepFinalizeExchange(
    PSMB_EXCHANGE pExchange);

BOOLEAN
SmbCeCanExchangeBeFinalized(
    PSMB_EXCHANGE pExchange,
    PSMBCE_EXCHANGE_STATUS pExchangeStatus);

VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange);

VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange);

BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

NTSTATUS
DefaultSmbExchangeIndError(
    IN PSMB_EXCHANGE pExchange);

NTSTATUS
DefaultSmbExchangeIndReceive(
    IN PSMB_EXCHANGE    pExchange);

NTSTATUS
DefaultSmbExchangeIndSendCallback(
    IN PSMB_EXCHANGE    pExchange);

VOID
MRxSmbBindTransportCallback(
    IN PUNICODE_STRING pTransportName
);

VOID
MRxSmbUnbindTransportCallback(
    IN PUNICODE_STRING pTransportName
);

NTSTATUS
MRxSmbRegisterForPnpNotifications();

VOID
MRxSmbpBindTransportCallback(
    IN struct _TRANSPORT_BIND_CONTEXT_ *pTransportContext);

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN struct _TRANSPORT_BIND_CONTEXT_ *pTransportContext);

VOID
MRxSmbpUnbindTransportCallback(
    PSMBCE_TRANSPORT pTransport);

NTSTATUS
MRxSmbDeregisterForPnpNotifications();

NTSTATUS
SmbCePnpBindBrowser( PUNICODE_STRING pTransportName, BOOLEAN IsBind);

NTSTATUS
SmbCeDereferenceTransportArray(
    PSMBCE_TRANSPORT_ARRAY pTransportArray);

NTSTATUS
SmbCeInitializeTransactionParameters(
   PVOID  pSetup,
   USHORT SetupLength,
   PVOID  pParam,
   ULONG  ParamLength,
   PVOID  pData,
   ULONG  DataLength,
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
);

VOID
SmbCeUninitializeTransactionParameters(
   PSMB_TRANSACTION_PARAMETERS pTransactionParameters
);

VOID
SmbCeDiscardTransactExchange(PSMB_TRANSACT_EXCHANGE pTransactExchange);

NTSTATUS
SmbCeSubmitTransactionRequest(
    PRX_CONTEXT                           RxContext,
    PSMB_TRANSACTION_OPTIONS              pOptions,
    PSMB_TRANSACTION_PARAMETERS           pSendParameters,
    PSMB_TRANSACTION_PARAMETERS           pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT   pResumptionContext );

NTSTATUS
_SmbCeTransact(
   PRX_CONTEXT                         RxContext,
   PSMB_TRANSACTION_OPTIONS            pOptions,
   PVOID                               pInputSetupBuffer,
   ULONG                               InputSetupBufferLength,
   PVOID                               pOutputSetupBuffer,
   ULONG                               OutputSetupBufferLength,
   PVOID                               pInputParamBuffer,
   ULONG                               InputParamBufferLength,
   PVOID                               pOutputParamBuffer,
   ULONG                               OutputParamBufferLength,
   PVOID                               pInputDataBuffer,
   ULONG                               InputDataBufferLength,
   PVOID                               pOutputDataBuffer,
   ULONG                               OutputDataBufferLength,
   PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbTransactBuildHeader(
    PSMB_TRANSACT_EXCHANGE  pTransactExchange,
    UCHAR                   SmbCommand,
    PSMB_HEADER             pHeader);

NTSTATUS
SmbTransactExchangeStart(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbTransactExchangeAbort(
      PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbTransactExchangeErrorHandler(
    IN PSMB_EXCHANGE pExchange);

NTSTATUS
SmbTransactExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbTransactExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbCeInitializeTransactExchange(
    PSMB_TRANSACT_EXCHANGE              pTransactExchange,
    PRX_CONTEXT                         RxContext,
    PSMB_TRANSACTION_OPTIONS            pOptions,
    PSMB_TRANSACTION_SEND_PARAMETERS    pSendParameters,
    PSMB_TRANSACTION_RECEIVE_PARAMETERS pReceiveParameters,
    PSMB_TRANSACTION_RESUMPTION_CONTEXT pResumptionContext);

NTSTATUS
SmbTransactExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize);

NTSTATUS
SendSecondaryRequests(PVOID pContext);

NTSTATUS SmbMmInit();

VOID SmbMmTearDown();

VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pContext);

VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot);

VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext);

VOID
SmbCeDecrementNumberOfActiveVNetRootOnSession(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext
    );

NTSTATUS
SmbCeScavenger(
    PVOID pContext);

NTSTATUS
SmbCeScavengeRelatedContexts(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

NTSTATUS
SmbCeRemoteBootReconnect(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    RxContext);

BOOLEAN
SmbCeIsReconnectionRequired(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    pRxContext);

NTSTATUS
SmbCeSyncExchangeForSecuritySignature(
     PSMB_EXCHANGE pExchange
     );

NTSTATUS
SmbCeAllocateBufferForServerResponse(
    PSMB_EXCHANGE pExchange);

VOID
SmbCeFreeBufferForServerResponse(
     PSMB_EXCHANGE pExchange);

NTSTATUS
SmbCepRemoteBootReconnect(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    RxContext);

NTSTATUS
SmbCeRemoteBootReconnect(
    PSMB_EXCHANGE  pExchange,
    PRX_CONTEXT    RxContext);

VOID
MRxSmbCreateFileInfoCache(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    NTSTATUS                Status);

VOID
MRxSmbCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    NTSTATUS                Status);

VOID
MRxSmbCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    NTSTATUS                   Status);

VOID
MRxSmbCreateInternalFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_INTERNAL_INFORMATION Internal,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    NTSTATUS                   Status);

VOID
MRxSmbUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status);

VOID
MRxSmbInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateInternalFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize);

VOID
MRxSmbUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime);

VOID
MRxSmbUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic);

VOID
MRxSmbUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory);

BOOLEAN
MRxSmbIsFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PSMBPSE_FILEINFO_BUNDLE FileInfo,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName);

BOOLEAN
MRxSmbIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName);

BOOLEAN
MRxSmbIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName);

BOOLEAN
MRxSmbIsInternalFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_INTERNAL_INFORMATION Internal,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName);

NTSTATUS
MRxSmbGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext);

BOOLEAN
MRxSmbIsFileNotFoundCached(
    PRX_CONTEXT RxContext);

VOID
MRxSmbCacheFileNotFound(
    PRX_CONTEXT RxContext);

VOID
MRxSmbInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext);

VOID
MRxSmbInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    );

BOOLEAN
MRxSmbIsStreamFile(
    PUNICODE_STRING FileName,
    PUNICODE_STRING AdjustFileName);

VOID
MRxSmbUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext);

NTSTATUS
MRxSmbQueryFileInformationFromPseudoOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    FILE_INFORMATION_CLASS FileInformationClass);

BOOLEAN
MRxSmbIsLongFileName(
    PRX_CONTEXT     RxContext);

VOID
SmbInitializeSmbSecuritySignature(
    IN OUT PSMBCE_SERVER Server,
    IN PUCHAR            SessionKey,
    IN PUCHAR            ChallengeResponse,
    IN ULONG             ChallengeResponseLength);

NTSTATUS
MRxSmbAreFilesAliased(
    IN PFCB Fcb1,
    IN PFCB Fcb2);

NTSTATUS
MRxSmbPreparseName(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name
    );

NTSTATUS
MRxSmbGetConnectionId(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PRX_CONNECTION_ID RxConnectionId
    );


#endif   // _SMBMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbpse.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SmbPse.h

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Revision History:

--*/

#ifndef _SMBPSE_H_
#define _SMBPSE_H_

IMPORTANT_STRUCTURE(SMB_PSE_ORDINARY_EXCHANGE);

//CODE.IMPROVEMENT is this the right place for this?
#define StorageType(co) ((co) & FILE_STORAGE_TYPE_MASK)
#define StorageFlag(co) ((co) & FILE_STORAGE_TYPE_SPECIFIED)
#define IsStorageTypeSpecified(co)  (StorageFlag(co) == FILE_STORAGE_TYPE_SPECIFIED)

#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

//CODE.IMPROVEMENT The following should get fixed - use Tom's literal!
#define CLUSTER_SIZE 0x1000

//CODE.IMPROVEMENT.STACKSPACE we could save a dword of stack space
//                            by not passing rxcontext
//                 and by retrieving it from ordinaryexchange
#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE \
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange, \
    PRX_CONTEXT RxContext

//CODE.IMPROVEMENT this is not used consistently. in particular, it is not used in the OE start wrapper
//                 in order to not have any extra variables on the stack....a good idea but it breaks
//                 this encapsulation. on a risc machine, they would be in registers anyway. so, it makes
//                 sense to put in a comment there (and maybe the x86-specific code.......)
#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS \
    OrdinaryExchange,RxContext

#if DBG
#define OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    );
#define SmbPseOEAssertConsistentLinkage(a) {\
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,RxContext,OrdinaryExchange,StufferState,0);\
   }
#define SmbPseOEAssertConsistentLinkageFromOE(a) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,0);  \
   }
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,FLAGS) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,FLAGS);  \
   }
#else
#define SmbPseOEAssertConsistentLinkage(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOE(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,b) {NOTHING;}
#endif

typedef
NTSTATUS
(*PSMB_PSE_OE_START_ROUTINE) (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

typedef
NTSTATUS
(*PSMB_PSE_CONTINUATION_ROUTINE) (
    PSMB_PSE_ORDINARY_EXCHANGE
    );

#define SMBPSE_OE_HISTORY_SIZE 32
typedef struct _SMBPSE_HISTORY {
    ULONG Next;
    ULONG Submits; //could be shortened....
    struct {
        ULONG Longs[2];
    } Markers[SMBPSE_OE_HISTORY_SIZE];
} SMBPSE_HISTORY;

#if DBG
VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    );
#define UPDATE_OE_HISTORY_LONG(a) {SmbPseUpdateOEHistory(OrdinaryExchange,a,0);}
#define UPDATE_OE_HISTORY_2SHORTS(a,b) {SmbPseUpdateOEHistory(OrdinaryExchange,a,b);}
#else
#define UPDATE_OE_HISTORY_LONG(a)
#define UPDATE_OE_HISTORY_2SHORTS(a,b)
#endif //if DBG


typedef enum _SMB_PSE_ORDINARY_EXCHANGE_TYPE {
    SMBPSE_OETYPE_LATENT_HEADEROPS,
    SMBPSE_OETYPE_CREATE,
    SMBPSE_OETYPE_COREOPEN,
//    SMBPSE_OETYPE_CLEANUP,
    SMBPSE_OETYPE_FINDCLOSE,
    SMBPSE_OETYPE_READ,
    SMBPSE_OETYPE_WRITE, SMBPSE_OETYPE_EXTEND_WRITE, SMBPSE_OETYPE_CORETRUNCATE,
    SMBPSE_OETYPE_LOCKS, SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
    SMBPSE_OETYPE_FLUSH,
    SMBPSE_OETYPE_CLOSE, SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
    //SMBPSE_OETYPE_SEARCH,
    SMBPSE_OETYPE_RENAME,
    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,  //MUST BE FIRST T2
    SMBPSE_OETYPE_T2_FOR_NT_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL,
    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,  //MUST BE LAST T2
    SMBPSE_OETYPE_GFA,
//    SMBPSE_OETYPE_GFA2,
    SMBPSE_OETYPE_COREINFO,
    SMBPSE_OETYPE_CORECREATE,
    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE, SMBPSE_OETYPE_DELETE_FOR_RENAME,
    SMBPSE_OETYPE_CORECREATEDIRECTORY,
    SMBPSE_OETYPE_CORECHECKDIRECTORY,
    SMBPSE_OETYPE_SFA,
    SMBPSE_OETYPE_SFA2,
    SMBPSE_OETYPE_COREQUERYLABEL, SMBPSE_OETYPE_CORESEARCH, SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
    SMBPSE_OETYPE_CREATEPRINTFILE,
    SMBPSE_OETYPE_IOCTL,
    SMBPSE_OETYPE_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_TYPE;

typedef enum _SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS {
    SMBPSE_OE_FROM_QUERYDIRECTORY,
    SMBPSE_OE_FROM_QUERYFILEINFO,
    SMBPSE_OE_FROM_SETFILEINFO,
    SMBPSE_OE_FROM_QUERYVOLUMEINFO,
    SMBPSE_OE_FROM_EXTENDFILEFORCACHEING,
    SMBPSE_OE_FROM_LOCKS,
    SMBPSE_OE_FROM_FLUSH,
    SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
    SMBPSE_OE_FROM_CLEANUPFOBX,
    SMBPSE_OE_FROM_CLOSESRVCALL,
    SMBPSE_OE_FROM_CLOSECOPYCHUNKSRVCALL,
    SMBPSE_OE_FROM_GETFILEINFOFORCSHADOW,
    SMBPSE_OE_FROM_CREATE,
    SMBPSE_OE_FROM_RENAME,
    SMBPSE_OE_FROM_READ,
    SMBPSE_OE_FROM_WRITE,
    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
    SMBPSE_OE_FROM_GETPRINTJOBID,
    SMBPSE_OE_FROM_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS;

#define SMBPSE_DEFINE_OE_FLAG(a,c) RX_DEFINE_FLAG(SMBPSE_OE_FLAG_##a,c,0xffff)

typedef enum {
    SMBPSE_DEFINE_OE_FLAG(HEADER_ALREADY_PARSED, 0)
    SMBPSE_DEFINE_OE_FLAG(OE_ALREADY_RESUMED, 1)
    SMBPSE_DEFINE_OE_FLAG(VALIDATE_FID, 2)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_PARTIAL_INITIALIZED, 3)
    SMBPSE_DEFINE_OE_FLAG(OE_ALLOCATED_DATA_PARTIAL, 4)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_LOCKED, 5)
    //SMBPSE_DEFINE_OE_FLAG(SMBBUF_IS_A_MDL, 6)
    SMBPSE_DEFINE_OE_FLAG(NO_RESPONSE_EXPECTED, 7)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_OE, 8)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_SMBBUF, 9)
    SMBPSE_DEFINE_OE_FLAG(OE_AWAITING_DISPATCH, 10)
    SMBPSE_DEFINE_OE_FLAG(TURNON_DFS_FLAG, 11)
    //SMBPSE_DEFINE_OE_FLAG(NETROOT_GOOD, 15)
} SMBPSE_OE_FLAGS;

typedef enum _SMB_PSE_OE_INNERIO_STATE {
    SmbPseOEInnerIoStates_Initial = 0,
    SmbPseOEInnerIoStates_ReadyToSend,
    SmbPseOEInnerIoStates_OperationOutstanding,
    SmbPseOEInnerIoStates_OperationCompleted
} SMB_PSE_OE_INNERIO_STATE;

typedef enum _SMB_PSE_OE_READWRITE_STATE {
    SmbPseOEReadWriteIoStates_Initial = 0,
    SmbPseOEReadWriteIoStates_OperationOutstanding,
    SmbPseOEReadWriteIoStates_OperationCompleted,
    SmbPseOEReadWriteIoStates_OperationAbandoned
} SMB_PSE_OE_READWRITE_STATE;


#define MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL (20)
#define MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL (2)

#define MAX_PARTIAL_DATA_MDL_BUFFER_SIZE    \
    (MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL * PAGE_SIZE)

#define MAX_PARTIAL_EXCHANGE_MDL_BUFFER_SIZE \
    (MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL * PAGE_SIZE)

extern FAST_MUTEX MRxSmbReadWriteMutex;

typedef struct _SMB_PSE_OE_READWRITE {
    union {
    	PBYTE UserBufferBase;
    	PLOWIO_LOCK_LIST LockList;
    };

    ULONG         RemainingByteCount;
    ULONG         ThisBytesRequested;
    ULONG         ThisByteCount;
    ULONG         ThisBufferOffset;
    LARGE_INTEGER ByteOffsetAsLI;
    ULONG         BytesReturned;

    BOOLEAN PartialExchangeMdlInUse;
    BOOLEAN PartialDataMdlInUse;
    BOOLEAN CompressedRequestInProgress;
    BOOLEAN CompressedReadOrWrite;
    BOOLEAN WriteToTheEnd;
    BOOLEAN ReadWriteFinalized;

    ULONG   CompressedDataInfoLength;
    PBYTE   pCompressedDataBuffer;

    ULONG   UserBufferPortionLength;
    ULONG   ExchangeBufferPortionLength;

    union {
        MDL                   PartialDataMdl;
        COMPRESSED_DATA_INFO  CompressedDataInfo;
        BYTE    ByteBuffer1[
                    sizeof(MDL) +
                    sizeof(ULONG) * MAX_PAGES_SPANNED_BY_PARTIAL_DATA_MDL];
    };

    union {
        MDL     PartialExchangeMdl;
        BYTE    PartialExchangeMdlBuffer[
                    sizeof(MDL) +
                    sizeof(ULONG) * MAX_PAGES_SPANNED_BY_PARTIAL_EXCHANGE_MDL];
    };

    ULONG      TotalNumOfSections;
    ULONG      NumOfOutstandingOperations;
    ULONG      MaximumBufferSize;
    ULONG      CurrentSection;
    ULONG      RefCount;
    KEVENT     CompletionEvent;
    NTSTATUS   CompletionStatus;
    SMBFCB_HOLDING_STATE SmbFcbHoldingState;
    SMB_PSE_OE_READWRITE_STATE SectionState[];
} SMB_PSE_OE_READWRITE, *PSMB_PSE_OE_READWRITE;

#define OE_RW_FLAG_SUCCESS_IN_COPYHANDLER (0x01)
#define OE_RW_FLAG_REDUCE_RETURNCOUNT     (0x20) //used in pipewrites to track rawmode
#define OE_RW_FLAG_SUBSEQUENT_OPERATION   (0x40) //used in pipewrites to distinguish the first
#define OE_RW_FLAG_MSGMODE_PIPE_OPERATION (0x80) //MAX VALUE, it's just a byte.....


#define SMB_PSE_OE_HDR_MDL_PAGES (2 + (ADDRESS_AND_SIZE_TO_SPAN_PAGES( (ULONG) 0, MAXIMUM_SMB_BUFFER_SIZE )))

typedef struct _SMB_PSE_ORDINARY_EXCHANGE{
   union {
       SMB_EXCHANGE  Exchange;
       SMB_EXCHANGE;
   };
   SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
   SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint;
   ULONG SmbBufSize;
   ULONG StartEntryCount;
   PMDL  DataPartialMdl;
   USHORT Flags;
   UCHAR  OpSpecificFlags;
   UCHAR  OpSpecificState;
   UCHAR  LastSmbCommand;
   ULONG  SendOptions;
   GENERIC_ANDX ParseResumeState;
   NTSTATUS NoCopyFinalStatus;
   NTSTATUS SendCompletionStatus;
   ULONG MessageLength;
   SMBFCB_HOLDING_STATE SmbFcbHoldingState; //plenty of pad....only 2 bits used

   PSMB_PSE_OE_START_ROUTINE        AsyncResumptionRoutine;
   PSMB_PSE_OE_START_ROUTINE        StartRoutine;
   PSMB_PSE_CONTINUATION_ROUTINE    ContinuationRoutine;

   union {
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
           RX_FILE_TYPE StorageTypeFromGFA;
           ///DO NOT CHANGE ABOVE HERE UNLESS YOU CHANGE THE INFO ARM AS WELL
           MRXSMB_CREATE_PARAMETERS SmbCp;
           BOOLEAN MustRegainExclusiveResource;
           BOOLEAN CreateWithEasSidsOrLongName;
           ULONG FidReturnedFromCreate;
           ULONG FidReturnedFromOpen;
           ULONG FileSizeReturnedFromOpen;
           BOOLEAN FileWasCreated;
           BOOLEAN FileWasTruncated;
           //UNICODE_STRING PathNameForCoreOperation;
       } Create;
       SMB_PSE_OE_READWRITE ReadWrite;    //also used for locks
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
           RX_FILE_TYPE StorageTypeFromGFA;
           ///DO NOT CHANGE ABOVE HERE UNLESS YOU CHANGE THE CREATE ARM AS WELL
    	   PVOID Buffer;
    	   PULONG pBufferLength;
           ULONG InfoClass;
           union {
               struct {
                   UCHAR CoreLabel[13];    //right from smb.h
               } QFSVolInfo;
               struct {
                   ULONG CountRemaining;
                   ULONG CountRemainingInSmbbuf;
                   PSMB_DIRECTORY_INFORMATION NextDirInfo;
                   //there should be a union here
                   PSMB_RESUME_KEY EmptyCheckResumeKey;
                   SMB_RESUME_KEY EmptyCheckResumeKeyBuffer;
               } CoreSearch;
           };
       } Info;
       struct {
           LARGE_INTEGER AllocationSize;
       } Transact2;
       struct {
           PUCHAR PtrToLockType;   //this must be here because the beginning of the
                                   //lockstart code sets the locklist to zero which will be this
                                   //CODE.IMPROVEMENT.ASHAMED fix this up so that assert locks uses readwrite
           PMRX_SRV_OPEN SrvOpen;
           PRX_LOCK_ENUMERATOR LockEnumerator;
           PVOID ContinuationHandle;
           ULONG NumberOfLocksPlaced;
           LARGE_INTEGER NextLockOffset;
           LARGE_INTEGER NextLockRange;
           BOOLEAN NextLockIsExclusive;
           BOOLEAN LockAreaNonEmpty;
           BOOLEAN EndOfListReached;
       } AssertLocks;
   } ;
   
   PSMB_PSE_OE_READWRITE GlobalReadWrite;

   PUNICODE_STRING   pPathArgument1;  // Unicode path
   union {
       PUNICODE_STRING   pPathArgument2;  // secondary unicode path
       PVOID             Find32WithinSmbbuf;
   };
   PSMBSTUFFER_BUFFER_STATE StufferStateDbgPtr; //this is just for the debugger....get rid of it
   SMBSTUFFER_BUFFER_STATE AssociatedStufferState;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderMdl;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderPartialMdl;
//#if DBG      CODE.IMPROVEMENT we should get rid of what we don't really, really need
   ULONG SerialNumber;
   SMBPSE_HISTORY History;
   PIRP RxContextCapturedRequestPacket;
   PMDL  SaveDataMdlForDebug;
   ULONG SaveLengthForDebug;
   PMDL  SaveIrpMdlForDebug;
//#endif
   ULONG BytesAvailableCopy;
   ULONG BytesIndicatedCopy;
} SMB_PSE_ORDINARY_EXCHANGE, *PSMB_PSE_ORDINARY_EXCHANGE;

// CODE.IMPROVEMENT actually, we have to get rid of a message...we need to know the length in the long term
// in the short term this will be okay. i think that what i really have to do is to return error_discard
// or something like that
#define SmbPseDiscardProtocol(__STATUS__) { \
    *pBytesTaken = BytesAvailable; \
    pExchange->Status = (__STATUS__); \
}

NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    );

NTSTATUS
SmbPseResumeOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    );

#define ASSERT_ORDINARY_EXCHANGE(__p) ASSERT(NodeType(__p)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE))


NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState OPTIONAL,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    );
#define SmbPseCreateOrdinaryExchange(__rxcontext,__vnetroot,__entrypoint,__start,__ordinaryexchangeptr) \
      __SmbPseCreateOrdinaryExchange(__rxcontext,__vnetroot,__entrypoint,__start,NULL,__ordinaryexchangeptr)

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

#define SmbPseInitiateOrdinaryExchange(OrdinaryExchange) (SmbCeInitiateExchange(&OrdinaryExchange->Exchange))

// this macro is used to do the async completion for read/write/locks. Note that the call to lowiocompletion
// will try to complete the irp thereby freeing the user's mdl. so, we better get rid of the partial first.
// we use this macro so that there will be only one version of this code. when we combine start routines,
// this will be un macroed
#define SmbPseAsyncCompletionIfNecessary(OE,RXCONTEXT) {                           \
    if (StartEntryCount>1) {                                                       \
    	BOOLEAN FinalizationComplete;                                              \
        if (FALSE) {DbgBreakPoint(); }                                             \
    	if ( (OE)->DataPartialMdl ) {                                              \
            if (FlagOn((OE)->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)){\
                MmPrepareMdlForReuse((OE)->DataPartialMdl);                        \
            } else {                                                               \
        	    IoFreeMdl((OE)->DataPartialMdl);                                   \
        	    (OE)->DataPartialMdl = NULL;                                       \
        	    ClearFlag((OE)->Flags,SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL);   \
            }                                                                      \
    	}                                                                          \
    	(RXCONTEXT)->StoredStatus = Status;                                        \
    	                                                                           \
        RxLowIoCompletion((RXCONTEXT));                                            \
    	FinalizationComplete = SmbPseFinalizeOrdinaryExchange((OE));               \
    	ASSERT(!FinalizationComplete);                                             \
        Status = STATUS_PENDING;                                                   \
    }}


/* ------------------------------------------
   ------------------------------------------
   Receive Handler Stuff
   ------------------------------------------
   ------------------------------------------
*/

VOID
SmbPseInitializeTables(
    void
    );

typedef
NTSTATUS
(*PSMBPSE_RECEIVE_HANDLER) (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PBYTE                        Response
    );


//boy, talk about a load of arguments
typedef
UCHAR
(*PSMBPSE_NOCOPY_RECEIVE_HANDLER) (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PBYTE       Response
    );
#define SMBPSE_NOCOPYACTION_NORMALFINISH  0x00
#define SMBPSE_NOCOPYACTION_MDLFINISH     0x01
#define SMBPSE_NOCOPYACTION_DISCARD 0x02
#define SMBPSE_NOCOPYACTION_COPY_FOR_RESUME 0x03


#define SMBPSE_RMP_MODELED        (0x00000001)
#define SMBPSE_RMP_THIS_IS_ANDX   (0x00000002)
#define SMBPSE_RMP_WARNINGS_OK    (0x00000004)
#define SMBPSE_RMP_NOCOPY_HANDLER (0x00000008)

typedef enum _SMBPSE_RECEIVE_HANDLER_TOKEN {
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER = 0,
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,  //also close_print_file
    SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,  //also create_new
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_IOCTL_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM
} SMBPSE_RECEIVE_HANDLER_TOKEN;

PSMBPSE_RECEIVE_HANDLER SmbPseReceiveHandlers[SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM];
typedef struct _SMBPSE_RECEIVE_MODEL_PARAMETERS {
    UCHAR Flags;
    UCHAR ReceiveHandlerToken;
#if DBG
    USHORT Dummy;
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler;
    PBYTE IndicationString;
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,HighType;
#endif
} SMBPSE_RECEIVE_MODEL_PARAMETERS, *PSMBPSE_RECEIVE_MODEL_PARAMETERS;

SMBPSE_RECEIVE_MODEL_PARAMETERS SmbPseReceiveModelParameters[256]; //there are 256 possible smbs


typedef struct _SMBPSE_VESTIGIAL_SMBBUF {
    NT_SMB_HEADER Header;
    union {
        REQ_WRITE Write;
        REQ_NT_WRITE_ANDX WriteAndX;
        REQ_FLUSH Flush;
        struct {
            REQ_LOCKING_ANDX LockingAndX;
            NTLOCKING_ANDX_RANGE Locks[20]; //CODE.IMPROVEMENT.ASHAMED see locks.c
        };
        REQ_FIND_CLOSE2 FindClose;
        REQ_CLOSE Close;
    };
    ULONG Pad;
} SMBPSE_VESTIGIAL_SMBBUF;


// Finishing routines - these are all cast into the correct procedure type
//                      so that the response will already have the correct SMB format
//                      on entry to the routine

//CODE.IMPROVEMENT the names of these routines should be changed from FinishX to X_Handler
//CODE.IMPROVEMENT also, any routine that doesn't retrieve data should be changed over to a nocopy handler

NTSTATUS
MRxSmbFinishNTCreateAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_NT_CREATE_ANDX        Response
      );
#define MRxSmbReceiveHandler_NTCreateAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishNTCreateAndX)

NTSTATUS
MRxSmbFinishOpenAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN_ANDX             Response
      );
#define MRxSmbReceiveHandler_OpenAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishOpenAndX)

NTSTATUS
MRxSmbFinishClose (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CLOSE                 Response
      );
//use the close finsh routine for closeprintfile as well
#define MRxSmbReceiveHandler_Close ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishClose)

NTSTATUS
MRxSmbFinishGFA (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PVOID                       Response
      );
#define MRxSmbReceiveHandler_GetFileAttributes ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishGFA)

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      );
#define MRxSmbReceiveHandler_Transact2 ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishTransaction2)

NTSTATUS
MRxSmbFinishCoreOpen (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN                  Response
      );
#define MRxSmbReceiveHandler_CoreOpen ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreOpen)

NTSTATUS
MRxSmbFinishCoreCreate (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CREATE                Response
      );
#define MRxSmbReceiveHandler_CoreCreate ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreCreate)

NTSTATUS
MRxSmbFinishCoreIoCtl(
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_IOCTL                 Response
      );
#define MRxSmbReceiveHandler_Ioctl ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreIoCtl)

//NTSTATUS
//MRxSmbFinishRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ_ANDX             Response
//      );
//#define MRxSmbReceiveHandler_ReadAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishRead)

//NTSTATUS
//MRxSmbFinishCoreRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ                  Response
//      );
//#define MRxSmbReceiveHandler_CoreRead ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreRead)

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
    );
#define MRxSmbReceiveHandler_Read_NoCopy ((PSMBPSE_RECEIVE_HANDLER)MRxSmbReadHandler_NoCopy)

NTSTATUS
MRxSmbFinishCreatePrintFile (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN_PRINT_FILE       Response
      );
#define MRxSmbReceiveHandler_OpenPrintFile ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCreatePrintFile)

NTSTATUS
MRxSmbFinishWrite (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PBYTE                       Response
      );

#define MRxSmbReceiveHandler_WritePrintFile ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)
#define MRxSmbReceiveHandler_WriteAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)
#define MRxSmbReceiveHandler_CoreWrite ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)

NTSTATUS
MRxSmbFinishLocks (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_LOCKING_ANDX          Response
      );
#define MRxSmbReceiveHandler_LockingAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishLocks)

#if 0
NTSTATUS
MRxSmbFinishFlush (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_FLUSH                 Response
      );
#endif //if 0

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );
#define MRxSmbReceiveHandler_Search ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishSearch)
NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );
#define MRxSmbReceiveHandler_QueryDiskInfo ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishQueryDiskInfo)


//CODE.IMPROVEMENT.ASHAMED it would be so much better if
//    __MRxSmbSimpleSyncTransact2were divided into two routines.....one for
//    building and another for submitting. it would save some stack space.
typedef
NTSTATUS
(*PSMB_PSE_OE_T2_FIXUP_ROUTINE) (
    PSMB_PSE_ORDINARY_EXCHANGE
    );

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    );
#define MRxSmbSimpleSyncTransact2(a,b,c,d,e,f,g) \
    __MRxSmbSimpleSyncTransact2(a,b,c,d,e,f,g,NULL);

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      );
NTSTATUS
MRxSmbConstructDeferredOpenContext (
      IN OUT PRX_CONTEXT RxContext
      );

//downlevel stuff....
NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType         //CODE.IMPROVEMENT this should be a RDBSS_STORAGE_TYPE
      );

NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    );

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      );

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    );

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    );

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    );

USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    );

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    );

ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    IN ULONG Disposition
    );

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );


BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    );


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    );

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PLARGE_INTEGER CurrentTime
    );


VOID
MRxSmbResumeAsyncReadWriteRequests(
    PRX_CONTEXT RxContext);

#endif // _SMBPSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbsecur.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsecur.c

Abstract:

    This module implements all functions related to enforce the SMB security signature on
    transmitting and recieving SMB packages.

Revision History:

    Yun Lin     [YunLin]    23-December-1997

Notes:


--*/

#include "precomp.h"

extern LONG NumOfBuffersForServerResponseInUse;
extern LIST_ENTRY ExchangesWaitingForServerResponseBuffer;

// this varible defines the maximum number of large buffer allowed to be pre-allocated for the
// server responses that contain the security signature, which prevents it drains all system
// resource under heavy network traffic situation and large read request
LONG MaxNumOfLargeBuffersForServerResponse = 3;

// the buffer size for most of the SMB server responses which don't contain much data
ULONG MinimumBufferSizeForServerResponse = 0x100;

BOOLEAN
SmbCheckSecuritySignature(
    IN PSMB_EXCHANGE  pExchange,
    IN PSMBCE_SERVER  Server,
    IN ULONG          MessageLength,
    IN PVOID          pBuffer
    );

LIST_ENTRY SmbSecurityMdlWaitingExchanges;

NTSTATUS
SmbCeCheckMessageLength(
      IN  ULONG         BytesIndicated,
      IN  ULONG         BytesAvailable,
      IN  PVOID         pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PULONG        pMessageLength
     )
/*++

Routine Description:

    This routine calculates the server message length based on the SMB response command and data.

Arguments:

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   UCHAR            SmbCommand;
   PGENERIC_ANDX    pSmbBuffer;
   PSMB_HEADER      pSmbHeader = (PSMB_HEADER)pTsdu;
   ULONG            ByteCount;
   LONG             WordCount;
   LONG             ByteLeft = BytesIndicated - sizeof(SMB_HEADER);

   if (ByteLeft < 0) {
       return STATUS_INVALID_NETWORK_RESPONSE;
   }

   *pMessageLength = sizeof(SMB_HEADER);

   SmbCommand = pSmbHeader->Command;

   pSmbBuffer = (PGENERIC_ANDX)(pSmbHeader + 1);

   do {

       switch (SmbCommand) {
       case SMB_COM_LOCKING_ANDX:
       case SMB_COM_WRITE_ANDX:
       case SMB_COM_SESSION_SETUP_ANDX:
       case SMB_COM_LOGOFF_ANDX:
       case SMB_COM_TREE_CONNECT_ANDX:
       case SMB_COM_NT_CREATE_ANDX:
       case SMB_COM_OPEN_ANDX:

           SmbCommand = pSmbBuffer->AndXCommand;

           *pMessageLength = pSmbBuffer->AndXOffset;
           pSmbBuffer = (PGENERIC_ANDX)((PUCHAR)pTsdu + pSmbBuffer->AndXOffset);

           break;

       case SMB_COM_READ_ANDX:
       {
           PRESP_READ_ANDX ReadAndX = (PRESP_READ_ANDX)pSmbBuffer;

           WordCount = (ULONG)pSmbBuffer->WordCount;

           if (ReadAndX->DataLengthHigh > 0) {
               ByteCount = ReadAndX->DataLengthHigh << 16;
               ByteCount += ReadAndX->DataLength;
           } else {
               ByteCount = *(PUSHORT)((PCHAR)pSmbBuffer + 1 + WordCount*sizeof(USHORT));
           }

           *pMessageLength += (WordCount+1)*sizeof(USHORT) + ByteCount + 1;
           SmbCommand = SMB_COM_NO_ANDX_COMMAND;
           break;
       }

       default:

           WordCount = (ULONG)pSmbBuffer->WordCount;

           if (ByteLeft > (signed)sizeof(USHORT)*WordCount) {
               ByteCount = *(PUSHORT)((PCHAR)pSmbBuffer + 1 + WordCount*sizeof(USHORT));
           } else {
               ByteCount = 0;
           }

           *pMessageLength += (WordCount+1)*sizeof(USHORT) + ByteCount + 1;
           SmbCommand = SMB_COM_NO_ANDX_COMMAND;
       }

       ByteLeft = BytesIndicated - *pMessageLength;

       if (ByteLeft < 0) {
           Status = STATUS_MORE_PROCESSING_REQUIRED;
           break;
       }
   } while (SmbCommand != SMB_COM_NO_ANDX_COMMAND);

   return Status;
}

NTSTATUS
SmbCeReceiveIndWithSecuritySignature(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,
    OUT PMDL                 *pDataBufferPointer,
    OUT PULONG               pDataBufferSize,
    IN ULONG                 ReceiveFlags
    )
/*++

Routine Description:

    This routine handles the SMB server response that contains the security signature. There are 3
    scenaorios handled in this routine.

    1. TDI indicates the entire SMB message, and SmbCeReceiveInd returns STATUS_SUCCESS;
    2. TDI indicates the entire SMB message, and SmbceReceiveInd returns STATUS_MORE_PROCESSING_REQUIRED;
    3. TDI indicates partial SMB message.

    For corresponding solution are:

    1. Check the security signature and calls SmbCeReceiveInd
    2. Check the security signature and calls SmbCeReceiveInd, then call SmbCeDataReadyInd for the
       rest of the message
    3. Use the pre-allocated buffer for the entir SMB message and return to TDI

    In case of bad security signatre, an error status is set on the SMB header and the receive exchange
    routine will drop the message.

Arguments:

    pServerEntry       - the server entry

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - pointer describing this TSDU, typically a lump of bytes

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS      Status;

   PSMB_HEADER   pSmbHeader = (PSMB_HEADER)pTsdu;
   PSMB_EXCHANGE pExchange;
   ULONG         MessageLength;

   // Perform the quick tests by which ill formed SMB's, mangled SMB's can be rejected.
   // e.g., any indication which is of non zero length whihc is less then the length of
   // a SMB_HEADER cannot be a valid SMB.

   if ((BytesAvailable < sizeof(SMB_HEADER) + 3) ||
       (SmbGetUlong(((PULONG )pSmbHeader->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL) ||
       (pSmbHeader->Command == SMB_COM_NO_ANDX_COMMAND)  ) {
      RxLog(("SmbCeReceiveInd: Invalid Response for %lx\n",pServerEntry));
      SmbLogError(STATUS_UNSUCCESSFUL,
                  LOG,
                  SmbCeReceiveInd,
                  LOGPTR(pServerEntry)
                  LOGUSTR(pServerEntry->Name));
      *pBytesTaken = BytesIndicated;
      return STATUS_SUCCESS;
   }

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   if (pSmbHeader->Command == SMB_COM_ECHO) {
       Status = SmbCeReceiveInd(
                    pServerEntry,
                    BytesIndicated,
                    BytesAvailable,
                    pBytesTaken,
                    pTsdu,
                    pDataBufferPointer,
                    pDataBufferSize,
                    ReceiveFlags);

       return Status;
   }

   //RxLog(("Smb (Rece) %lx %lx %lx\n",pServerEntry,pSmbHeader->Command,pSmbHeader->Mid));

   // Perform the tests for detecting oplock break SMB's. These are SMB's with the
   // command SMB_COM_LOCKING_ANDX with the LOCKING_ANDX_OPLOCK_RELEASE bit set.
   // These SMB's are transformed into buffering state change requests which are
   // processed by the RDBSS.
   // CODE.IMPROVEMENT -- raw mode handling needs to be incorporated
   //

   if (pSmbHeader->Command == SMB_COM_LOCKING_ANDX) {
      if (BytesIndicated == LOCK_BROKEN_SIZE) {
         PREQ_LOCKING_ANDX pOplockBreakRequest = (PREQ_LOCKING_ANDX)(pSmbHeader + 1);

         if (SmbGetUshort(&pOplockBreakRequest->LockType) & LOCKING_ANDX_OPLOCK_RELEASE) {
             Status = SmbCeReceiveInd(
                          pServerEntry,
                          BytesIndicated,
                          BytesAvailable,
                          pBytesTaken,
                          pTsdu,
                          pDataBufferPointer,
                          pDataBufferSize,
                          ReceiveFlags);

             return Status;
         }
      }
   }

   // Handle the cases when the server responds to the oplock break response.
   if ((pSmbHeader->Mid == SMBCE_MAILSLOT_OPERATION_MID) ||
       (pSmbHeader->Mid == SMBCE_OPLOCK_RESPONSE_MID)) {
       Status = SmbCeReceiveInd(
                    pServerEntry,
                    BytesIndicated,
                    BytesAvailable,
                    pBytesTaken,
                    pTsdu,
                    pDataBufferPointer,
                    pDataBufferSize,
                    ReceiveFlags);

       return Status;
   }

   pExchange = SmbCeMapMidToExchange(pServerEntry,pSmbHeader->Mid);

   // some exchange might have been initiated before the security signature is enabled.
   // In this case, we should avoid security signature check.
   if (pExchange != NULL && pExchange->IsSecuritySignatureEnabled) {
       if (BytesAvailable > BytesIndicated ||
           !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE)) {
           ASSERT(pExchange->MdlForServerResponse != NULL &&
                  pExchange->MdlForServerResponse->ByteCount >= BytesAvailable);

           *pBytesTaken = 0;
           *pDataBufferPointer = pExchange->MdlForServerResponse;
           *pDataBufferSize = pExchange->MdlForServerResponse->ByteCount;

           Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,*pDataBufferPointer);

           if (Status == STATUS_SUCCESS) {
               SmbCeIncrementPendingCopyDataOperations(pExchange);
               Status = STATUS_MORE_PROCESSING_REQUIRED;
           } else {
               DbgPrint("MRxSmb:Fail to associate MDL witn exchange. %lx\n",Status);

               pExchange->Status = Status;
               *pBytesTaken = BytesIndicated;
               Status = STATUS_SUCCESS;
           }
       } else {
           if (!SmbCheckSecuritySignature(pExchange,
                                         &pServerEntry->Server,
                                         BytesIndicated,
                                         pTsdu)) {

               pSmbHeader->ErrorClass = SMB_ERR_CLASS_SERVER;
               SmbPutUshort(&pSmbHeader->Error, ERROR_UNEXP_NET_ERR);
               RxLog(("SmbCeReceiveInd: Invalid Security Signature\n"));
               SmbLogError(STATUS_UNSUCCESSFUL,
                           LOG,
                           SmbCeReceiveIndWithSecuritySignature,
                           LOGPTR(pServerEntry)
                           LOGUSTR(pServerEntry->Name));
           }

           Status = SmbCeReceiveInd(
                        pServerEntry,
                        BytesIndicated,
                        BytesAvailable,
                        pBytesTaken,
                        pTsdu,
                        pDataBufferPointer,
                        pDataBufferSize,
                        ReceiveFlags);

           if (Status==STATUS_MORE_PROCESSING_REQUIRED) {
               ULONG    BytesCopied;

               Status = TdiCopyBufferToMdl(
                            pTsdu,
                            *pBytesTaken,
                            BytesIndicated,
                            *pDataBufferPointer,
                            0,
                            &BytesCopied);

               SmbCeDataReadyInd(pServerEntry,
                                 *pDataBufferPointer,
                                 BytesCopied,
                                 Status);
           }

           Status = STATUS_SUCCESS;
           *pBytesTaken = BytesIndicated;
       }
   } else {
       if (pExchange != NULL) {
           Status = SmbCeReceiveInd(
                        pServerEntry,
                        BytesIndicated,
                        BytesAvailable,
                        pBytesTaken,
                        pTsdu,
                        pDataBufferPointer,
                        pDataBufferSize,
                        ReceiveFlags);
       } else {
           RxLog(("SmbCeReceiveInd:No resumption context %lx\n",pServerEntry));
           Status = STATUS_SUCCESS;
           *pBytesTaken = BytesIndicated;
       }
   }

   return Status;
}


NTSTATUS
SmbCeDataReadyIndWithSecuritySignature(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL                  pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus
   )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied which contains security
    signature. In case of bad security signature, an error is set on SMB message header and the receive
    exchange routine will drop the message.

Arguments:

    pServerEntry  - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS      Status;
   ULONG         BytesTaken;
   PMDL          pDataBufferPointer;
   ULONG         DataBufferSize;
   PSMB_EXCHANGE pExchange = SmbCeGetExchangeAssociatedWithBuffer(pServerEntry,pBuffer);

   // some exchange might have been initiated before the security signature is enabled.
   // In this case, we should avoid security signature check.
   if (pExchange != NULL && pExchange->IsSecuritySignatureEnabled) {
       if (CopyDataStatus == STATUS_SUCCESS) {
           PSMB_HEADER pSmbHeader = (PSMB_HEADER)pExchange->BufferForServerResponse;

           if (!SmbCheckSecuritySignature(pExchange,
                                          &pServerEntry->Server,
                                          DataSize,
                                          pExchange->BufferForServerResponse)) {

               pSmbHeader->ErrorClass = SMB_ERR_CLASS_SERVER;
               SmbPutUshort(&pSmbHeader->Error, ERROR_UNEXP_NET_ERR);
               RxLog(("SmbCeDataReadyInd: Invalid Security Signature\n"));
               SmbLogError(STATUS_UNSUCCESSFUL,
                           LOG,
                           SmbCeDataReadyIndWithSecuritySignature,
                           LOGPTR(pServerEntry)
                           LOGUSTR(pServerEntry->Name));
           }

           Status = SmbCeReceiveInd(
                        pServerEntry,
                        DataSize,
                        DataSize,
                        &BytesTaken,
                        pExchange->BufferForServerResponse,
                        &pDataBufferPointer,
                        &DataBufferSize,
                        TDI_RECEIVE_ENTIRE_MESSAGE);

           if (Status==STATUS_MORE_PROCESSING_REQUIRED) {
               ULONG BytesCopied;

               ASSERT(DataBufferSize >= DataSize - BytesTaken);

               Status = TdiCopyBufferToMdl(
                            pExchange->BufferForServerResponse,
                            BytesTaken,
                            DataSize,
                            pDataBufferPointer,
                            0,
                            &BytesCopied);

               SmbCeDataReadyInd(pServerEntry,
                                 pDataBufferPointer,
                                 BytesCopied,
                                 Status);
           }
       } else {
           // Resume the exchange that was waiting for the receive.
           pExchange->Status    = STATUS_CONNECTION_DISCONNECTED;
           pExchange->SmbStatus = STATUS_CONNECTION_DISCONNECTED;

           SmbCeDecrementPendingReceiveOperationsAndFinalize(pExchange);
       }

       // Resume the exchange that was waiting for the data.
       SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange);
   } else {
       if (pExchange != NULL) {
           if (CopyDataStatus == STATUS_SUCCESS) {
              // Notify the exchange of the completion
              //ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
              ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,DataSize);
              SMB_EXCHANGE_DISPATCH(
                                pExchange,
                                CopyDataHandler,
                                (pExchange,pBuffer,DataSize));
           } else {
               pExchange->Status    = CopyDataStatus;
               pExchange->SmbStatus = CopyDataStatus;
           }

           // Resume the exchange that was waiting for the data.
           SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange);
       } else {
           // The data MDL is part of the exchange, which should be freed with the exchange.
           ASSERT(FALSE);
       }
   }

   return STATUS_SUCCESS;
}

NTSTATUS
SmbCeSyncExchangeForSecuritySignature(
     PSMB_EXCHANGE pExchange
     )
/*++

Routine Description:

    This routines puts the exchange on the list waiting for the previous extended session
    setup to finish in order to serialize the requests sent to the server with security
    signature enabled.
Arguments:

    pExchange     - the smb exchange

Return Value:

    STATUS_SUCCESS - the exchange can be initiated.
    STATUS_PENDING - the exchange can be resumed after the extended session setup finishes

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    KEVENT                  SmbCeSynchronizationEvent;
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry = NULL;

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

    if (!pSessionEntry->SessionRecoverInProgress) {
        if (!pServerEntry->ExtSessionSetupInProgress) {
            if (pExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) {
                // if this is the first extended session setup, let it proceed
                pServerEntry->ExtSessionSetupInProgress = TRUE;
            }

            return Status;
        }
    } else {
        if (pExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) {
            // if this is the extended session setup, let it proceed
            return Status;
        }
    }

    // We are performing an operation that does not attempt reconnects, so it will
    // not recover from the disconnect/lack of session.  We should simply abort here.
    if( !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) )
    {
        return STATUS_CONNECTION_DISCONNECTED;      
    }

    pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

    if (pRequestEntry != NULL) {
        pRequestEntry->Request.pExchange = pExchange;

        SmbCeIncrementPendingLocalOperations(pExchange);
        SmbCeAddRequestEntry(&pServerEntry->SecuritySignatureSyncRequests,pRequestEntry);

        if (pExchange->pSmbCeSynchronizationEvent != NULL) {
            Status = STATUS_PENDING;
        } else {
            KeInitializeEvent(
                &SmbCeSynchronizationEvent,
                SynchronizationEvent,
                FALSE);

           pExchange->pSmbCeSynchronizationEvent = &SmbCeSynchronizationEvent;

           SmbCeReleaseResource();
           KeWaitForSingleObject(
               &SmbCeSynchronizationEvent,
               Executive,
               KernelMode,
               FALSE,
               NULL);
           SmbCeAcquireResource();
           pExchange->pSmbCeSynchronizationEvent = NULL;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
SmbCeAllocateBufferForServerResponse(
    PSMB_EXCHANGE pExchange
    )
/*++

Routine Description:

    This routine allocates the buffer for server response in case that the TDI doesn't indicates the
    entire message once. The security siganture cannot be checked until entire message is indicated.
    Normally, we allocate 0x100 for the short message from the server. In case of read and transact
    exchanges, we allocate the buffer large enough to handle the message that server might return.
    Since the large buffer will consum a lot of system memory, we only allow a certain amount of this
    kind pre-allocated buffers outstanding, which cannot exceed the MaxNumOfLargeBuffersForServerResponse
    defined at beginning of this module. If the request exceeds the limitation, the exchange acquiring
    the buffer is put onto sleep until and existing large buffer is freed by another exchange.

Arguments:

    pExchange     - the smb exchange

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    BufferSize = MinimumBufferSizeForServerResponse;
    PVOID    Buffer = NULL;
    PMDL     Mdl = NULL;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    PSMBCE_SERVER         pServer = &pServerEntry->Server;

    switch (pExchange->Type) {
    case ORDINARY_EXCHANGE:
        {
        PLOWIO_CONTEXT             LowIoContext = &pExchange->RxContext->LowIoContext;
        PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
        PSMBCE_NET_ROOT            pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);


        switch(OrdinaryExchange->EntryPoint) {
        case SMBPSE_OE_FROM_READ:
            BufferSize +=  min(LowIoContext->ParamsFor.ReadWrite.ByteCount,
                               pNetRoot->MaximumReadBufferSize);
            break;

        case SMBPSE_OE_FROM_QUERYDIRECTORY:
        case SMBPSE_OE_FROM_QUERYFILEINFO:
        case SMBPSE_OE_FROM_QUERYVOLUMEINFO:

            BufferSize +=  min(LowIoContext->ParamsFor.FsCtl.OutputBufferLength,
                               pNetRoot->MaximumReadBufferSize);
            break;
        }
        }

        break;

    case TRANSACT_EXCHANGE:
        {
        PSMB_TRANSACT_EXCHANGE TransactExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;

        BufferSize += TransactExchange->ReceiveDataBufferSize +
                      TransactExchange->ReceiveParamBufferSize +
                      TransactExchange->ReceiveSetupBufferSize;
        }

        break;

    case CONSTRUCT_NETROOT_EXCHANGE:
    case EXTENDED_SESSION_SETUP_EXCHANGE:
        // for netroot and session setup request, we cannot predict how many bytes
        // the server is going to return. For doscore, the MaximumBufferSize is 0.
        BufferSize = max(pServer->MaximumBufferSize,MinimumBufferSizeForServerResponse);
        break;

    case ADMIN_EXCHANGE:
        break;

    default:
        break;
    }

    if ((BufferSize > MinimumBufferSizeForServerResponse) &&
        (pExchange->Type != EXTENDED_SESSION_SETUP_EXCHANGE) &&
        FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION)) {
        LONG NumOfBuffers;

        SmbCeAcquireResource();
        NumOfBuffers = InterlockedIncrement(&NumOfBuffersForServerResponseInUse);

        if (NumOfBuffers > MaxNumOfLargeBuffersForServerResponse) {
            if (!IsListEmpty(&pExchange->ExchangeList)) {
                RemoveEntryList(&pExchange->ExchangeList);
            }

            InsertTailList(
                &ExchangesWaitingForServerResponseBuffer,
                &pExchange->ExchangeList);

            SmbCeIncrementPendingLocalOperations(pExchange);
            InterlockedDecrement(&NumOfBuffersForServerResponseInUse);
            Status = STATUS_PENDING;
        }
        else
        {
            // We incremented the NumOfBuffers counter, mark it
            pExchange->SmbCeFlags |= SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED;
        }

        SmbCeReleaseResource();
    }

    if (Status == STATUS_SUCCESS) {
        Buffer = RxAllocatePoolWithTag(PagedPool,BufferSize,MRXSMB_MISC_POOLTAG);

        if (Buffer != NULL) {
            Mdl = RxAllocateMdl(Buffer, BufferSize);

            if (Mdl != NULL) {
                RxProbeAndLockPages(Mdl,KernelMode,IoModifyAccess,Status);

                if (Status == STATUS_SUCCESS) {
                    if (MmGetSystemAddressForMdlSafe(Mdl,LowPagePriority) == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_SUCCESS &&
            FlagOn( pExchange->SmbCeFlags, SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED) ) {
            InterlockedDecrement(&NumOfBuffersForServerResponseInUse);
        }
    }

    ASSERT(pExchange->MdlForServerResponse == NULL);
    ASSERT(pExchange->BufferForServerResponse == NULL);

    if (Status == STATUS_SUCCESS) {
        pExchange->BufferForServerResponse = Buffer;
        pExchange->MdlForServerResponse = Mdl;

        pExchange->SmbCeState = SMBCE_EXCHANGE_SECURITYBUFFER_INITIALIZED;
    } else {
        if (Buffer != NULL) {
            RxFreePool(Buffer);
        }

        if (Mdl != NULL) {
            IoFreeMdl(Mdl);
        }

        // We did not succeed, so make sure its not marked as having incremented the counter
        pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED;
    }

    return Status;
}

VOID
SmbCeFreeBufferForServerResponse(
     PSMB_EXCHANGE pExchange
     )
/*++

Routine Description:

    This routine frees the buffer for server response and resume one exchange, if exists,
    that is waiting for allocating the large buffer.

Arguments:

    pExchange - the smb exchange

Return Value:

    none

--*/
{
    PSMB_EXCHANGE pWaitingExchange = NULL;

    if (pExchange->MdlForServerResponse != NULL) {
        if ( FlagOn(pExchange->SmbCeFlags, SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED) ) {
            PLIST_ENTRY pListHead = &ExchangesWaitingForServerResponseBuffer;

            SmbCeAcquireResource();
            InterlockedDecrement(&NumOfBuffersForServerResponseInUse);
            ClearFlag( pExchange->SmbCeFlags, SMBCE_EXCHANGE_SIGNATURE_BUFFER_ALLOCATED );

            if (!IsListEmpty(pListHead)) {
                PLIST_ENTRY   pListEntry;

                pListEntry = pListHead->Flink;
                RemoveHeadList(pListHead);

                pWaitingExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
            }
            SmbCeReleaseResource();
        }

        RxUnlockHeaderPages(pExchange->MdlForServerResponse);
        IoFreeMdl(pExchange->MdlForServerResponse);
        pExchange->MdlForServerResponse = NULL;
    }

    if (pExchange->BufferForServerResponse != NULL) {
        RxFreePool(pExchange->BufferForServerResponse);
        pExchange->BufferForServerResponse = NULL;
    }

    if (pWaitingExchange != NULL) {
        NTSTATUS      Status = STATUS_SUCCESS;

        InitializeListHead(&pWaitingExchange->ExchangeList);

        if (pWaitingExchange->pSmbCeSynchronizationEvent == NULL) {
            SmbCeResumeExchange(pWaitingExchange);
            SmbCeDecrementPendingLocalOperationsAndFinalize(pWaitingExchange);
        } else {
            SmbCeDecrementPendingLocalOperations(pWaitingExchange);
            KeSetEvent(
                pWaitingExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }
    }
}

VOID
SmbInitializeSmbSecuritySignature(
    IN OUT PSMBCE_SERVER Server,
    IN PUCHAR            SessionKey,
    IN PUCHAR            ChallengeResponse,
    IN ULONG             ChallengeResponseLength
    )
/*++

Routine Description:

    Initializes the security signature generator for a session by calling MD5Update
    on the session key, challenge response

Arguments:

    SessionKey - Either the LM or NT session key, depending on which
        password was used for authentication, must be at least 16 bytes
    ChallengeResponse - The challenge response used for authentication, must
        be at least 24 bytes

--*/
{
    //DbgPrint( "MRxSmb: Initialize Security Signature Intermediate Contex\n");

    RtlZeroMemory(&Server->SmbSecuritySignatureIntermediateContext, sizeof(MD5_CTX));
    MD5Init(&Server->SmbSecuritySignatureIntermediateContext);

    if (SessionKey != NULL) {
        MD5Update(&Server->SmbSecuritySignatureIntermediateContext,
                  (PCHAR)SessionKey,
                  MSV1_0_USER_SESSION_KEY_LENGTH);
    }

    MD5Update(&Server->SmbSecuritySignatureIntermediateContext,
              (PCHAR)ChallengeResponse,
              ChallengeResponseLength);

    Server->SmbSecuritySignatureIndex = 0;
}

BOOLEAN DumpSecuritySignature = FALSE;

NTSTATUS
SmbAddSmbSecuritySignature(
    IN PSMBCE_SERVER Server,
    IN OUT PMDL      Mdl,
    IN OUT ULONG     *ServerIndex,
    IN ULONG         SendLength
    )
/*++

Routine Description:

    Generates the next security signature

Arguments:

    WorkContext - the context to sign

Return Value:

    none.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    MD5_CTX     Context;
    PSMB_HEADER Smb;
    PCHAR       SysAddress;
    ULONG       MessageLength = 0;

    Smb = MmGetSystemAddressForMdlSafe(Mdl,LowPagePriority);

    if (Smb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //SmbPutUshort(&Smb->Gid,(USHORT)Server->SmbSecuritySignatureIndex+1);

    SmbPutUlong(Smb->SecuritySignature,Server->SmbSecuritySignatureIndex);
    *ServerIndex = Server->SmbSecuritySignatureIndex+1; //Index of server response

    RtlZeroMemory(Smb->SecuritySignature + sizeof(ULONG),
                  SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG));

    //
    // Start out with our initial context
    //
    RtlCopyMemory( &Context, &Server->SmbSecuritySignatureIntermediateContext, sizeof( Context ) );

    //
    // Compute the signature for the SMB we're about to send
    //
    do {
        SysAddress = MmGetSystemAddressForMdlSafe(Mdl,LowPagePriority);

        if (SysAddress == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Mdl->ByteCount >= SendLength) {
            MD5Update(&Context, SysAddress, SendLength);
            MessageLength += SendLength;
            SendLength = 0;
            ASSERT(Mdl->Next == NULL);
            break;
        } else {
            MD5Update(&Context, SysAddress, Mdl->ByteCount);
            SendLength -= Mdl->ByteCount;
            MessageLength += Mdl->ByteCount;
            ASSERT(Mdl->Next != NULL);
        }
    } while( (Mdl = Mdl->Next) != NULL );

    MD5Final( &Context );


    // Put the signature into the SMB

    RtlCopyMemory(
        Smb->SecuritySignature,
        Context.digest,
        SMB_SECURITY_SIGNATURE_LENGTH
        );

    if (DumpSecuritySignature) {
        DbgPrint("Add Signature: index %u length %u\n", *ServerIndex-1,MessageLength);
    }

    return STATUS_SUCCESS;
}

VOID
SmbDumpSignatureError(
    IN PSMB_EXCHANGE pExchange,
    IN PUCHAR ExpectedSignature,
    IN PUCHAR ActualSignature,
    IN ULONG  Length
    )
/*++

Routine Description:

    Print the mismatched signature information to the debugger

Arguments:


Return Value:

    none.

--*/
{
    PWCHAR p;
    DWORD i;
    PSMBCEDB_SERVER_ENTRY pServerEntry = (PSMBCEDB_SERVER_ENTRY)SmbCeGetExchangeServerEntry(pExchange);

    //
    // Security Signature Mismatch!
    //

    //DbgPrint("MRXSMB: Bad security signature from %wZ ", &pServerEntry->Name);

    DbgPrint("\n\t  Wanted: ");
    for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
        DbgPrint( "%X ", ExpectedSignature[i] & 0xff );
    }
    DbgPrint("\n\tReceived: ");
    for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
        DbgPrint( "%X ", ActualSignature[i] & 0xff );
    }
    DbgPrint("\n\tLength %u, Expected Index Number %X\n", Length, pExchange->SmbSecuritySignatureIndex);
}

BOOLEAN
SmbCheckSecuritySignature(
    IN PSMB_EXCHANGE  pExchange,
    IN PSMBCE_SERVER  Server,
    IN ULONG          MessageLength,
    IN PVOID          pBuffer
    )
/*++

Routine Description:

    This routine checks whether the security signature on the server response matches the one that is
    calculated on the client machine.

Arguments:


Return Value:

    A BOOLEAN value is returned to indicated whether the security signature matches.

--*/
{
    MD5_CTX     Context;
    CHAR        SavedSignature[ SMB_SECURITY_SIGNATURE_LENGTH ];
    PSMB_HEADER Smb = (PSMB_HEADER)pBuffer;
    ULONG       ServerIndex;
    BOOLEAN     Correct;

    //
    // Initialize the Context
    //
    RtlCopyMemory(&Context, &Server->SmbSecuritySignatureIntermediateContext, sizeof(Context));

    //
    // Save the signature that's presently in the SMB
    //
    RtlCopyMemory( SavedSignature, Smb->SecuritySignature, sizeof( SavedSignature ));

    //
    // Put the correct (expected) signature index into the buffer
    //
    SmbPutUlong( Smb->SecuritySignature, pExchange->SmbSecuritySignatureIndex );
    RtlZeroMemory(  Smb->SecuritySignature + sizeof(ULONG),
                    SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG));

    //
    // Compute what the signature should be
    //
    MD5Update(&Context, (PUCHAR)pBuffer, (UINT)MessageLength);

    MD5Final(&Context);

    //
    // Put the signature back
    //
    //RtlCopyMemory( Smb->SecuritySignature, SavedSignature, sizeof( Smb->SecuritySignature ));

    //
    // Now compare them!
    //
    if( RtlCompareMemory( Context.digest, SavedSignature, sizeof( SavedSignature ) ) !=
        sizeof( SavedSignature ) ) {

        //SmbDumpSignatureError(pExchange,
        //                      Context.digest,
        //                      SavedSignature,
        //                      MessageLength);

        DbgPrint("MRXSMB: SS mismatch command %X,  Length %X, Expected Index Number %X\n",
                 Smb->Command, MessageLength, pExchange->SmbSecuritySignatureIndex);
        DbgPrint("        server send length %X, mdl length %X index %X\n",
                 SmbGetUshort(&Smb->PidHigh), SmbGetUshort(&Smb->Pid), SmbGetUshort(&Smb->Gid));

        //DbgBreakPoint();

        SmbCeTransportDisconnectIndicated(pExchange->SmbCeContext.pServerEntry);

        RxLogFailure(
            MRxSmbDeviceObject,
            NULL,
            EVENT_RDR_SECURITY_SIGNATURE_MISMATCH,
            STATUS_UNSUCCESSFUL);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbpse.c ===
/*++ Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    SmbPse.c

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Author:

    Joe Linn        [JoeLi] -- Implemented Ordinary Exchange

Notes:

    The Ordinary exchange bridges the mismatch between the connection engine exchange
    which is oriented towards sending a single SMB request to the server and processing
    the response from the server and the requests recieved from RDBSS.

    The requests from RDBSS come in one of two flavours -- synchronous and asynchronous.
    There are requests which often translate into multiple SMB's being sent to the
    server and the associated response processing. There is no one to one mapping
    between the requests and the SMBs that need to be sent. In some cases a reconnection
    attempt needs to be made and in others a delayed open needs to be sent before the
    associated request can be processed. There are instances of requests which are
    inherently multi SMB, e.g., large read and write requests.

    The ordinary exchange provides the framework for dealing with all these variations.
    The ORDINARY_EXCHANGE wraps a connection engine exchange and extends it with
    different hooks for customization. The custromization of ORDINARY_EXCHANGE is
    possible both from the data and control viewpoint. The data portion is provided
    by a union at the tail end of the ORDINARY_EXCHANGE which provides for the
    appropriate state to be captured.

    The code customization consists of three routines that can be specified as
    part of the ORDIANRY_EXCHANGE. These are the Asynchronous Resumption routine
    (AsyncResumptionRoutine), the continuation routine (ContinuationRoutine) and
    the start routine (StartRoutine).

    The SmbPseCreateOrdinaryExchange, SmbPseSubmitOrdinaryExchange and
    SmbPseFinalizeOrdinaryExchange provide the necessay mechanism for creating an
    ordinary exchange, triggering the action and finalizing it upon completion.

    The ordinary exchange implementation tailors the dispatch vector associated
    with the underlying connection engine exchange using extensive tables. All
    the routines suffixed with _default are the default routines for the
    underlying connection engine exchange.

    The typical course of exchange in response to a request from the RDBSS is to

        1) create an ordinary exchange (SmbPseCreateOrdinaryExchange)

        2) submit it for processing (SmbPseSubmitOrdinaryExchange)

            2.1) The Ordinary exchange completes the initialization w.r.t the state
                associated with it and initiates the processing in the connection
                engine (SmbCeInitiateExchange)

            2.2) The connection engine completes the initialization associated
            with the connection engine and invokes the Start routine provided in
            the dispatch vector.

            2.3) This results in the Start routine provided to the Ordinary exchange
            being invoked. The request specific initialization is carried out followed
            by a call to SmbCeTranceive or SmbCeSend.

            2.4) The resulting exchange is suspended while the underlying connection
            engine interfaces with the transport to ship the packet over and receive
            the response.

            2.5) Once the connection engine quiesces the SMbPseContinueOrdinaryExchange
            is called. This routine either invokes the continuation routine to resume
            processing or wrap up the ordianry exchange processing and return to
            the caller. this involves either setting the event for synchronous
            requests or invoking the AsyncResumption routine for asynchronous requests.

    The request for read/write which involve multiple packets use the continuation
    routine to spin up further requests. These can be network exchanges which are wired
    to the original exchange and are referred to as associated exchanges. On completion
    of all associated exchanges the connection engine invokes the
    AssociatedExchangeCompletionHandler which results in the resumption of
    ORDINARY_EXCHANGE processing in 2.5.

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, __SmbPseDbgCheckOEMdls)
#pragma alloc_text(PAGE, SmbPseContinueOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseOrdinaryExchange)
#pragma alloc_text(PAGE, __SmbPseCreateOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseFinalizeOrdinaryExchange)
#pragma alloc_text(PAGE, SmbPseExchangeStart_default)
#pragma alloc_text(PAGE, SmbPseExchangeCopyDataHandler_Read)
#pragma alloc_text(PAGE, __SmbPseRMTableEntry)
#pragma alloc_text(PAGE, SmbPseInitializeTables)
#pragma alloc_text(PAGE, MRxSmbQueryDosVolumeInformation)
#endif

RXDT_DefineCategory(SMBPSE);
#define Dbg                              (DEBUG_TRACE_SMBPSE)

#define MINIMUM_SEND_SIZE 512

PVOID LastOE;

#define MIN(x,y) ((x) < (y) ? (x) : (y))

#define IM_THE_LAST_GUY (*Response==0)

//
// Generic AndX request
//

GENERIC_ANDX NullGenericAndX = {
            //    typedef struct _GENERIC_ANDX {
      0,    //        UCHAR WordCount;                    // Count of parameter words
            //        UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
      SMB_COM_NO_ANDX_COMMAND,
      0,    //        UCHAR AndXReserved;                 // Reserved
      0     //        _USHORT( AndXOffset );              // Offset (from SMB header start)
            //    } GENERIC_ANDX;
    };

NTSTATUS
SmbPseExchangeStart_default(
    IN OUT PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeCopyDataHandler_Read(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeReceive_default(
    IN struct _SMB_EXCHANGE *pExchange,
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG  pDataSize,
    IN ULONG    ReceiveFlags);

NTSTATUS
SmbPseExchangeFinalize_default(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostFinalize);

SMB_EXCHANGE_DISPATCH_VECTOR
SmbPseOEDispatch = {
    SmbPseExchangeStart_default,
    SmbPseExchangeReceive_default,
    SmbPseExchangeCopyDataHandler_default,
    SmbPseExchangeSendCallbackHandler_default,
    SmbPseExchangeFinalize_default,
    NULL
    };

#if DBG
#define P__ASSERT(exp) {             \
    if (!(exp)) {                    \
        DbgPrint("NOT %s\n",#exp);   \
        errors++;                    \
    }}

VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between the rxcontext, the OE, and
   the stufferstate is correct and that various fields have correct values. if anything is bad....print stuff out and brkpoint;

Arguments:

     MsgPrefix          an identifying msg
     RxContext           duh
     OrdinaryExchange    .
     StufferState        .

Return Value:

    none

Notes:

--*/
{

    ULONG errors = 0;

    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PSMB_EXCHANGE Exchange = &OrdinaryExchange->Exchange;

    pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    if (Exchange->CancellationStatus != SMBCE_EXCHANGE_CANCELLED) {
        P__ASSERT( OrdinaryExchange->SerialNumber == RxContext->SerialNumber );
        P__ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );
    }

    P__ASSERT( NodeType(OrdinaryExchange)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE) );
    P__ASSERT( OrdinaryExchange->RxContext == RxContext );
    P__ASSERT( NodeType(StufferState) == SMB_NTC_STUFFERSTATE );
    P__ASSERT( Exchange == StufferState->Exchange);
    P__ASSERT( StufferState->RxContext == RxContext );

    if(StufferState->HeaderMdl!=NULL){
        P__ASSERT( !RxMdlIsPartial(StufferState->HeaderMdl) );
    }

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        P__ASSERT( RxMdlIsPartial(StufferState->HeaderPartialMdl) );
    }

    if (errors==0) {
        return;
    }

    DbgPrint("%s INCONSISTENT OE STATE: %d errors at %s line %d\n",
                 MsgPrefix,errors,File,Line);
    //DbgBreakPoint();

    return;
}

VOID
__SmbPseDbgRunMdlChain(
    PMDL MdlChain,
    ULONG CountToCompare,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG i,total;

    RxDbgTrace(0,Dbg,("__SmbPseRunMdlChain: -------------%08lx\n",MdlChain));
    for (total=i=0;MdlChain!=NULL;i++,MdlChain=MdlChain->Next) {
        total+=MdlChain->ByteCount;
        RxDbgTrace(0,Dbg,("--->%02d %08lx %08lx %08lx %6d %6d\n",i,MdlChain,MdlChain->MdlFlags,
               MmGetMdlVirtualAddress(MdlChain),MdlChain->ByteCount,total));
    }

    if (total == CountToCompare) return;

    DbgPrint("%s: MdlChain.Count!=CountToCompart c1,c2,xch.st=%08lx %08lx %08lx\n",
                             MsgPrefix,
                             total,CountToCompare,OrdinaryExchange->Status,

                             File,Line);
    //DbgBreakPoint();
}

#define SmbPseDbgRunMdlChain(a,b,c,d) {\
   __SmbPseDbgRunMdlChain(a,b,c,d,__FILE__,__LINE__);\
   }

VOID
__SmbPseDbgCheckOEMdls(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG errors = 0;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl = StufferState->HeaderPartialMdl;

    PAGED_CODE();

    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == SubmitMdl->Next);
    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == StufferState->DataMdl);
    P__ASSERT (SubmitMdl != NULL);

    if (errors==0) {
        return;
    }

    DbgPrint("%s CheckOEMdls failed: %d errors at %s line %d: OE=%08lx\n",
                 MsgPrefix,errors,File,Line,OrdinaryExchange);
    //DbgBreakPoint();

    return;
}

#define SmbPseDbgCheckOEMdls(a,b) {\
   __SmbPseDbgCheckOEMdls(a,b,__FILE__,__LINE__);\
   }

ULONG SmbPseShortStatus(ULONG Status)
{
    ULONG ShortStatus;

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >>16);
    return(ShortStatus);
}

VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    )
{
    ULONG MyIndex,Long0,Long1;

    MyIndex = InterlockedIncrement(&OrdinaryExchange->History.Next);
    MyIndex = (MyIndex-1) & (SMBPSE_OE_HISTORY_SIZE-1);
    Long0 = (Tag1<<16) | (Tag2 & 0xffff);
    Long1 = (SmbPseShortStatus(OrdinaryExchange->SmbStatus)<<16) | OrdinaryExchange->Flags;
    OrdinaryExchange->History.Markers[MyIndex].Longs[0] = Long0;
    OrdinaryExchange->History.Markers[MyIndex].Longs[1] = Long1;
}

VOID SmbPseVerifyDataPartialAllocationPerFlags(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
{
    BOOLEAN FlagsSayPartialAllocated,TheresADataPartial;
    ULONG t = OrdinaryExchange->Flags & (SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL|SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF);

    FlagsSayPartialAllocated = (t!=0)?TRUE:FALSE;   //the compiler is getting confused
    TheresADataPartial = (OrdinaryExchange->DataPartialMdl != NULL)?TRUE:FALSE;  //the compiler is getting confused
    if ( FlagsSayPartialAllocated != TheresADataPartial){
        DbgPrint("Flags %08lx datapartial %08lx t %08lx fspa %08lx tadp %08lx\n",
                     OrdinaryExchange->Flags, OrdinaryExchange->DataPartialMdl,
                     t, FlagsSayPartialAllocated, TheresADataPartial);
        ASSERT ( FlagsSayPartialAllocated == TheresADataPartial);
    }
}

#else

#define SmbPseDbgRunMdlChain(a,b,c,d) {NOTHING;}
#define SmbPseDbgCheckOEMdls(a,b) {NOTHING;}
#define SmbPseVerifyDataPartialAllocationPerFlags(a) {NOTHING;}

#endif

#define UPDATE_OE_HISTORY_WITH_STATUS(a) \
            UPDATE_OE_HISTORY_2SHORTS(a,SmbPseShortStatus(OrdinaryExchange->Status))




VOID
MRxSmbResumeAsyncReadWriteRequests(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    Asynchronous read write requests can be deferred because of SMB FCB resource
    acquistion. In all such cases this routine resumes the request. We
    cannot directly reume execution with MRxSmbRead/MRxSmbWrite routine because
    we need to invoke LowIoCompletion in certain failure cases. We have two choices
    to do so .... either we can include this logic in the MRxSmbRead/MRxSmbWrite
    routine or consolidate it in pne place. This routine implements the later
    approach.

Arguments:

    RxContext - the RDBSS context

Notes:

--*/
{
    NTSTATUS Status;

    PMRX_CALLDOWN ResumptionRoutine;

    switch (RxContext->MajorFunction) {
    case IRP_MJ_READ:
        ResumptionRoutine = MRxSmbRead;
        break;
    case IRP_MJ_WRITE:
        ResumptionRoutine = MRxSmbWrite;
        break;
    default:
        ASSERT(!"Valid IRP Major Function code for CscResumeReadWrite");
        return;
    }

    Status = (ResumptionRoutine)(RxContext);

    if (Status != STATUS_PENDING) {
        if (Status != STATUS_SUCCESS) {
            DbgPrint("RxContext Async CSC Status %lx\n",Status);
            RxContext->StoredStatus = Status;
            RxContext->InformationToReturn = 0;
        }
        // Invoke the Low Io Resumption routine
        RxLowIoCompletion(RxContext);
    }
}

NTSTATUS
SmbPseContinueOrdinaryExchange(
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation if asynchronous and
   there maybe more work to be done.

   The two cases are regularized by delaying the parse if we know that we're
   going to post: this is indicated by the presense of a resume routine.

Arguments:

    RxContext  - the context of the operation. .

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl, HeaderFullMdl;

    BOOLEAN InvokeContinuationRoutine = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseContinueOrdinaryExchange entering........OE=%08lx\n",OrdinaryExchange));

    Status = Exchange->Status;

    if (OrdinaryExchange->OpSpecificState !=
            SmbPseOEInnerIoStates_OperationCompleted) {

        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);

        SmbPseOEAssertConsistentLinkageFromOE("SmbPseContinueOrdinaryExchange:");

        UPDATE_OE_HISTORY_WITH_STATUS('0c');

        SubmitMdl = StufferState->HeaderPartialMdl;
        HeaderFullMdl = StufferState->HeaderMdl;

        ASSERT(FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED));

        SmbPseOEAssertConsistentLinkage("Top of OE continue: ");

        RxUnprotectMdlFromFree(SubmitMdl);
        RxUnprotectMdlFromFree(HeaderFullMdl);

        SmbPseDbgCheckOEMdls(
            OrdinaryExchange,"SmbPseContinueOrdinaryExchange(top)");

        SmbPseDbgRunMdlChain(
            SubmitMdl,
            OrdinaryExchange->SaveLengthForDebug,
            OrdinaryExchange,
            "SmbPseContinueOrdinaryExchange(top)");

        MmPrepareMdlForReuse(SubmitMdl);

        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

        SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);

        if ( OrdinaryExchange->DataPartialMdl ) {
            MmPrepareMdlForReuse( OrdinaryExchange->DataPartialMdl );
        }

        RxDbgTrace( 0, Dbg, ("  --> P4Reuse %08lx, full %08lx is no longer unlocked here\n"
                             ,SubmitMdl,HeaderFullMdl));
    }

    if (OrdinaryExchange->ContinuationRoutine == NULL) {
        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            ULONG BytesTaken;
            ULONG DataSize = 0;
            ULONG MessageLength = OrdinaryExchange->MessageLength;
            PMDL  DataBufferPointer = NULL;
            PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;

            Status = SMB_EXCHANGE_DISPATCH(
                         Exchange,
                         Receive,
                         (
                            Exchange,           // IN struct SMB_EXCHANGE *pExchange,
                            MessageLength,      // IN ULONG  BytesIndicated,
                            MessageLength,      // IN ULONG  BytesAvailable,
                            &BytesTaken,        // OUT ULONG *pBytesTaken,
                            SmbHeader,          // IN  PSMB_HEADER pSmbHeader,
                            &DataBufferPointer, // OUT PMDL *pDataBufferPointer,
                            &DataSize,          // OUT PULONG  pDataSize)
                            TDI_RECEIVE_ENTIRE_MESSAGE
                         ));

            if (Status == STATUS_SUCCESS) {
                Status = Exchange->Status;
                UPDATE_OE_HISTORY_WITH_STATUS('2c');
            } else {
                UPDATE_OE_HISTORY_WITH_STATUS('dd');
            }

            if (DataSize != 0 ||
                DataBufferPointer != NULL ||
                BytesTaken != MessageLength ||
                Status == STATUS_MORE_PROCESSING_REQUIRED) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            InvokeContinuationRoutine = TRUE;
        }
    } else {
        InvokeContinuationRoutine = TRUE;
    }


    if (InvokeContinuationRoutine) {
        if ( OrdinaryExchange->ContinuationRoutine != NULL ) {
            if ( Status == STATUS_MORE_PROCESSING_REQUIRED){
                Exchange->Status = STATUS_SUCCESS;
            }

            Status = OrdinaryExchange->ContinuationRoutine( OrdinaryExchange );

            UPDATE_OE_HISTORY_WITH_STATUS('1c');

            if (Status != STATUS_PENDING) {
                Exchange->Status = Status;
                OrdinaryExchange->ContinuationRoutine = NULL;
            }
        }
    }

    if (Status != STATUS_PENDING) {
        if (Status != STATUS_SUCCESS) {
            if (RxContext->MajorFunction != IRP_MJ_CLOSE) {
                // There is no point in transitioning CLOSE operations since
                // the context is lost anycase.
                Status = CscTransitionVNetRootForDisconnectedOperation(
                             RxContext,
                             SmbCeGetExchangeVNetRoot(
                                (PSMB_EXCHANGE)OrdinaryExchange),
                                Status);
            }

            OrdinaryExchange->Status = OrdinaryExchange->SmbStatus = Status;
        }

        if (OrdinaryExchange->AsyncResumptionRoutine ) {

            //call the continuation is it's async
            Status = OrdinaryExchange->AsyncResumptionRoutine(
                         OrdinaryExchange,
                         RxContext );

            UPDATE_OE_HISTORY_WITH_STATUS('3c');
        }

        //remove my references, if i'm the last guy then do the putaway...
        UPDATE_OE_HISTORY_WITH_STATUS('4c');
        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseContinueOrdinaryExchange returning %08lx.\n", Status));
    return(Status);
} // SmbPseContinueOrdinaryExchange


NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN     SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    )
/*++

Routine Description:

   This routine implements an ordinary exchange as viewed by the protocol
   selection routines.

Arguments:

    OrdinaryExchange  - the exchange to be conducted.
    OEType            - Ordinary Exchange Type

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    RxCaptureFcb;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_PSE_OE_START_ROUTINE Continuation;
    ULONG   SmbLength;
    PMDL    SubmitMdl,HeaderFullMdl;
    ULONG   SendOptions;
    DEBUG_ONLY_DECL( ULONG LengthP; ULONG LengthF; )
    KEVENT SyncEvent;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseOrdinaryExchange entering.......OE=%08lx\n",OrdinaryExchange));

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseOrdinaryExchange:");

    OrdinaryExchange->OEType = OEType;
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    KeInitializeEvent(
        &SyncEvent,
        NotificationEvent,
        FALSE );

    HeaderFullMdl = StufferState->HeaderMdl;
    ASSERT( HeaderFullMdl != NULL );
    SmbLength = (ULONG)(StufferState->CurrentPosition - StufferState->BufferBase);

    SubmitMdl = StufferState->HeaderPartialMdl;

    ASSERT(RxMdlIsOwned(SubmitMdl));

    RxBuildPartialHeaderMdl(
        StufferState->HeaderMdl,
        SubmitMdl,
        StufferState->BufferBase,
        SmbLength );

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

    //
    // If there is a data MDL associated with this request, then
    // we'll have to chain it.
    //

    SubmitMdl->Next = StufferState->DataMdl;

    if (StufferState->DataMdl) {
        SmbLength += StufferState->DataSize;
    }

    DbgDoit(
        SmbPseDbgRunMdlChain(
            SubmitMdl,
            SmbLength,
            OrdinaryExchange,
            "SmbPseOrdinaryExchange(before)");

        OrdinaryExchange->SaveDataMdlForDebug = SubmitMdl->Next;
        OrdinaryExchange->SaveLengthForDebug = SmbLength;

        if (OrdinaryExchange->RxContextCapturedRequestPacket != NULL) {
            OrdinaryExchange->SaveIrpMdlForDebug =
                OrdinaryExchange->RxContextCapturedRequestPacket->MdlAddress;
        }
    )

    RxDbgTrace(
        0,
        Dbg,
        ("  --> mdllength/smblength %08lx/%08lx headermdl %08lx\n",
         MmGetMdlByteCount(SubmitMdl), SmbLength, StufferState->HeaderMdl) );

    ClearFlag(
        OrdinaryExchange->Flags,
        (SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED |
         SMBPSE_OE_FLAG_OE_ALREADY_RESUMED) );

    SendOptions = OrdinaryExchange->SendOptions;

    SmbCeReferenceExchange( Exchange );  //this one is taken away in ContinueOE
    SmbCeReferenceExchange( Exchange );  //this one is taken away below...
                                                       //i must NOT finalize before SmbCe returns
    SmbCeResetExchange(Exchange);

    Continuation = OrdinaryExchange->AsyncResumptionRoutine;
    
    if (((OrdinaryExchange->OEType == SMBPSE_OETYPE_WRITE) ||
         (OrdinaryExchange->OEType == SMBPSE_OETYPE_READ)  ||
         (OrdinaryExchange->OEType == SMBPSE_OETYPE_LOCKS)) &&
        BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)
       ) {
        ASSERT(Continuation!=NULL);
    }

    if (Continuation == NULL) {
        OrdinaryExchange->pSmbCeSynchronizationEvent = &SyncEvent;
    }

    DbgDoit((LengthP = MmGetMdlByteCount(SubmitMdl),LengthF = MmGetMdlByteCount(HeaderFullMdl)));

    RxProtectMdlFromFree(SubmitMdl);
    RxProtectMdlFromFree(HeaderFullMdl);

    SmbPseOEAssertConsistentLinkage("just before transceive: ");

    UPDATE_OE_HISTORY_2SHORTS('eo',(Continuation!=NULL)?'!!':0);

    DbgDoit( InterlockedIncrement(&OrdinaryExchange->History.Submits); )

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID)) {
       PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
       PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
       PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);

       if (smbSrvOpen->Version == pServerEntry->Server.Version) {
          Status = STATUS_SUCCESS;
       } else {
          Exchange->Status = Exchange->SmbStatus = Status = STATUS_CONNECTION_DISCONNECTED;
          capFcb->fShouldBeOrphaned = TRUE;
       }

       IF_DEBUG {
           PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(SubmitMdl,LowPagePriority);
           USHORT Flags2 = 0;

           if (pSmbHeader) {
               Flags2 = SmbGetUshort(&pSmbHeader->Flags2);
           }

           RxDbgTrace(0, Dbg, ("Flags2 Value for Exchange %lx is %lx\n",Exchange,Flags2));
       }
    } else {
       Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED)) {
            Status = SmbCeSend(
                         Exchange,
                         SendOptions,
                         SubmitMdl,
                         SmbLength);
        } else {
            PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);

            Status = SmbCeTranceive(
                         Exchange,
                         SendOptions,
                         SubmitMdl,
                         SmbLength);
        }
    }

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);  //okay to finalize now that we're back

    if ( Status == STATUS_PENDING) {
        if ( Continuation != NULL ) {
            goto FINALLY;
        }
        
        UPDATE_OE_HISTORY_WITH_STATUS('1o');
        KeWaitForSingleObject(&SyncEvent,Executive, KernelMode, FALSE, NULL );
        OrdinaryExchange->pSmbCeSynchronizationEvent = NULL;

        ASSERT(RxMdlIsOwned(SubmitMdl));

        DbgDoit (
            //variables in the assert are only declared for DBG
            //asserts can be enabled separately
            ASSERT(
                LengthP == MmGetMdlByteCount(SubmitMdl) &&
                LengthF == MmGetMdlByteCount(HeaderFullMdl) );
        )
    } else {
        RxDbgTrace (0, Dbg, ("  -->Status after transceive %08lx\n",Status));
        DbgDoit (
            //variables in the assert are only declared for DBG
            //asserts can be enabled separately
            ASSERT(
                LengthP == MmGetMdlByteCount(SubmitMdl) &&
                LengthF == MmGetMdlByteCount(HeaderFullMdl) );
        )

        RxUnprotectMdlFromFree(SubmitMdl);
        RxUnprotectMdlFromFree(HeaderFullMdl);
        SmbPseOEAssertConsistentLinkage("nonpending return from transceive: ");

        // if it's an error, remove the references that i placed and get out
        if (NT_ERROR(Status)) {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            goto FINALLY;
        }
    }

    //at last, call the continuation........

    SmbPseOEAssertConsistentLinkage("just before continueOE: ");
    UPDATE_OE_HISTORY_WITH_STATUS('9b');

    Status = SmbPseContinueOrdinaryExchange( OrdinaryExchange );

    UPDATE_OE_HISTORY_WITH_STATUS('9o');

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseOrdinaryExchange returning %08lx.\n", Status));

    return(Status);

} // SmbPseOrdinaryExchange

NTSTATUS
__SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine,
    IN OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState OPTIONAL,
    OUT PSMB_PSE_ORDINARY_EXCHANGE *OrdinaryExchangePtr
    )
/*++

Routine Description:

   This routine allocates and initializes an SMB header buffer. Currently,
   we just allocate them from pool except when must_succeed is specified.

Arguments:

    RxContext       - the RDBSS context
    VNetRoot        -
    DispatchVector  -

Return Value:

    A buffer ready to go, OR NULL.

Notes:

--*/
{
    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;
    PCHAR SmbBuffer = NULL;
    PMDL HeaderFullMdl = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;
    SMBFCB_HOLDING_STATE TempHoldingState = SmbFcb_NotHeld;

    PAGED_CODE();

/*
Other size improvement stuff:     //CODE.IMPROVEMENT
     finalize renamed to transitiontoquiescent
     big fix - remove unwanted capture macros
     longname - delete top part of routine by using the studcode
     smbutils - we could reduce the table size by a factor of 2-3 by storing s 16bit representation of the ntstatus
*/

    RxDbgTrace(+1, Dbg, ("SmbPseCreateOrdinaryExchange\n") );

    if (SmbFcbHoldingState == NULL) {
        SmbFcbHoldingState = &TempHoldingState;
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }

    OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)SmbMmAllocateExchange(ORDINARY_EXCHANGE,NULL);
    
    //we rely on the fact that SmbMmAllocate Zeros the exchange.............
    if (OrdinaryExchange == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    } 

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    StufferState->NodeTypeCode = SMB_NTC_STUFFERSTATE;
    StufferState->NodeByteSize = sizeof(SMBSTUFFER_BUFFER_STATE);
    StufferState->Exchange = &OrdinaryExchange->Exchange;

    DbgDoit(OrdinaryExchange->SerialNumber = RxContext->SerialNumber);  //CODE.IMPROVEMENT should this be in the SMB_EXCHANGE?

    //
    // Initialize the exchange packet
    //

    Status = SmbCeInitializeExchange(
                &StufferState->Exchange,
                RxContext,
                (PMRX_V_NET_ROOT)VNetRoot,
                ORDINARY_EXCHANGE,
                &SmbPseOEDispatch);

    if (StufferState->Exchange != NULL) {
        SmbCeReferenceExchange(StufferState->Exchange);

        RxDbgTrace(0, Dbg, ("  exchng=%08lx,type=%08lx\n",&StufferState->Exchange,StufferState->Exchange->Type));
    }

    StufferState->RxContext = RxContext;

    //place a reference on the rxcontext until we are finished
    InterlockedIncrement( &RxContext->ReferenceCount );

    OrdinaryExchange->StufferStateDbgPtr = StufferState;
    OrdinaryExchange->RxContext = RxContext;
    OrdinaryExchange->EntryPoint = EntryPoint;
    OrdinaryExchange->StartRoutine = StartRoutine;
    OrdinaryExchange->SmbBufSize = MAXIMUM_SMB_BUFFER_SIZE;

    DbgDoit(OrdinaryExchange->RxContextCapturedRequestPacket = RxContext->CurrentIrp;);

    //note: create path must turn this flag on.
    OrdinaryExchange->SmbCeFlags &= ~(SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    ASSERT( (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_OE))
                       ||  (OrdinaryExchange->Flags == 0) );
    ASSERT( OrdinaryExchange->SendOptions == 0 );
    ASSERT( OrdinaryExchange->DataPartialMdl == NULL );

    pMRxSmbContext->pExchange     = &OrdinaryExchange->Exchange;
    pMRxSmbContext->pStufferState = StufferState;

    if (capFobx != NULL) {
        if (BooleanFlagOn(capFobx->Flags,FOBX_FLAG_DFS_OPEN)) {
            SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
        }
    } else if (BooleanFlagOn(VNetRoot->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT) &&
               (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))) {
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
    }

    if (Status != STATUS_SUCCESS) {
        goto UNWIND;
    }

    //
    // Allocate the SmbBuffer
    //

    if (SmbBuffer == NULL) {
        SmbBuffer = (PCHAR)RxAllocatePoolWithTag(
                               PagedPool,
                               OrdinaryExchange->SmbBufSize +
                               TRANSPORT_HEADER_SIZE,
                               'BMSx' );
    }

    if ( SmbBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    }

    RxDbgTrace(0, Dbg, ("  smbbuf=%08lx,stfstate=%08lx\n",SmbBuffer,StufferState));

    StufferState->ActualBufferBase =  SmbBuffer;

    (PBYTE) SmbBuffer += TRANSPORT_HEADER_SIZE;

    StufferState->BufferBase       =  SmbBuffer;
    StufferState->BufferLimit      =  SmbBuffer + OrdinaryExchange->SmbBufSize;

    //
    // Init the HeaderMdl
    //

    HeaderFullMdl = StufferState->HeaderMdl = &OrdinaryExchange->HeaderMdl.Mdl;
    RxInitializeHeaderMdl(HeaderFullMdl,SmbBuffer, OrdinaryExchange->SmbBufSize);

    RxDbgTrace(
        0,
        Dbg,
        ("  --> smbbufsize %08lx, mdllength %08lx\n",
         OrdinaryExchange->SmbBufSize,
         MmGetMdlByteCount(HeaderFullMdl)));

    //finally, lock down the smbbuf taking different paths according to whether
    // we are must-succeed or not

    ASSERT( !RxMdlIsLocked(HeaderFullMdl) );
    ASSERT( HeaderFullMdl->Next == NULL );

    RxDbgTrace( 0, Dbg, ("  --> LOCKING %08lx\n",HeaderFullMdl));

    RxProbeAndLockHeaderPages(
        HeaderFullMdl,
        KernelMode,
        IoModifyAccess,
        Status );

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("  --> LOCKING FAILED\n"));
        goto UNWIND;
    }

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);

    if (MmGetSystemAddressForMdlSafe(HeaderFullMdl,LowPagePriority) == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UNWIND;
    }

    //
    // No initialization is required for the partial...just set the pointer

    StufferState->HeaderPartialMdl = &OrdinaryExchange->HeaderPartialMdl.Mdl;

    RxDbgTrace( -1, Dbg, ("  --> exiting w!\n") );

    *OrdinaryExchangePtr = OrdinaryExchange;
    return Status;


UNWIND:
    RxDbgTrace( -1, Dbg, ("  --> exiting w/o!\n") );

    if (OrdinaryExchange != NULL ) {
        SmbPseFinalizeOrdinaryExchange( OrdinaryExchange );
    }

    *OrdinaryExchangePtr = NULL;
    return Status;

} // SmbPseCreateOrdinaryExchange



#if DBG
ULONG MRxSmbFinalizeStfStateTraceLevel = 1200;
#define FINALIZESS_LEVEL MRxSmbFinalizeStfStateTraceLevel
#define FINALIZE_TRACKING_SETUP() \
    struct {                    \
        ULONG marker1;          \
        ULONG finalstate;       \
        ULONG marker2;          \
    } Tracking = {'ereh',0,'ereh'};
#define FINALIZE_TRACKING(x) {\
    Tracking.finalstate |= x; \
    }

#define FINALIZE_TRACE(x) SmbPseFinalizeOETrace(x,Tracking.finalstate)
VOID
SmbPseFinalizeOETrace(PSZ text,ULONG finalstate)
{
    PAGED_CODE();

    RxDbgTraceLV(0, Dbg, FINALIZESS_LEVEL,
                   ("MRxSmbFinalizeSmbStufferState  --> %s(%08lx)\n",text,finalstate));
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
/*++

Routine Description:

    This finalizes an OE.

Arguments:

    OrdinaryExchange - pointer to the OE to be dismantled.

Return Value:

    TRUE if finalization occurs otherwise FALSE.

Notes:

--*/
{
    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PSMBSTUFFER_BUFFER_STATE StufferState;
    LONG result;
    ULONG OrdinaryExchangeFlags = OrdinaryExchange->Flags;

    FINALIZE_TRACKING_SETUP()

    PAGED_CODE();

    SmbPseOEAssertConsistentLinkageFromOEwithFlags(
        "SmbPseFinalizeOrdinaryExchange:",
        OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK);

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    pMRxSmbContext = MRxSmbGetMinirdrContext(StufferState->RxContext);

    RxDbgTraceLV(+1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState\n"));

    result =  SmbCeDereferenceExchange(&OrdinaryExchange->Exchange);

    if ( result != 0 ) {
        RxDbgTraceLV(
            -1,
            Dbg,
            1000,
            ("MRxSmbFinalizeSmbStufferState -- returning w/o finalizing (%d)\n",
             result));

        return FALSE;
    }

#if 0
    RxLog((">>>OE %lx %lx %lx %lx %lx",
            OrdinaryExchange,
            OrdinaryExchange->DataPartialMdl,
            StufferState->HeaderPartialMdl,
            StufferState->HeaderMdl,
            OrdinaryExchange->Flags
         ));
#endif

    FINALIZE_TRACKING( 0x10000000 );
    FINALIZE_TRACE("ready to freedatapartial");

    if (OrdinaryExchange->CopyDataPendingOperations != 0 ||
        OrdinaryExchange->SendCompletePendingOperations != 0) {
        DbgBreakPoint();
    }

    SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);

    if ( OrdinaryExchange->DataPartialMdl ) {
        if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
            IoFreeMdl( OrdinaryExchange->DataPartialMdl );
            FINALIZE_TRACKING( 0x8000000 );
        }
    }

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED)) {
        RxUnlockHeaderPages(StufferState->HeaderMdl);
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);
        MmPrepareMdlForReuse( StufferState->HeaderMdl );
        FINALIZE_TRACKING( 0x4000000 );
    }

    FINALIZE_TRACE("ready to uninit hdr partial");

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        MmPrepareMdlForReuse( StufferState->HeaderPartialMdl ); //no harm in calling this multiple times
        FINALIZE_TRACKING( 0x300000 );
    } else {
        FINALIZE_TRACKING( 0xf00000 );
    }

    if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
        FINALIZE_TRACE("ready to freepool actualbuffer");
        if ( StufferState->ActualBufferBase != NULL ) {

            RxFreePool( StufferState->ActualBufferBase );

            FINALIZE_TRACKING( 0x5000 );
        } else {
            FINALIZE_TRACKING( 0xf000 );
        }
    }

    if ( StufferState->RxContext != NULL ) {
        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( StufferState->RxContext );//CODE.IMPROVEMENT Capture rxcontext earlier
        FINALIZE_TRACKING( 0x600 );
    } else {
        FINALIZE_TRACKING( 0xf00 );
    }

    FINALIZE_TRACE("ready to discard exchange");
    SmbCeDiscardExchange(OrdinaryExchange);
    FINALIZE_TRACKING( 0x2000000 );

    FINALIZE_TRACKING( 0x8 );
    RxDbgTraceLV(-1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState  --> exit finalstate=%x\n",Tracking.finalstate));
    return(TRUE);

} // MRxSmbFinalizeSmbStufferState

NTSTATUS
SmbPseExchangeFinalize_default(
    IN OUT PSMB_EXCHANGE  pExchange,
    OUT    BOOLEAN        *pPostFinalize
    )
/*++

Routine Description:


Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                        (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    UPDATE_OE_HISTORY_WITH_STATUS('ff');
    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeFinalize_default: ");

    if (OrdinaryExchange->SmbStatus != STATUS_SUCCESS) {
        OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;
    }

    if (OrdinaryExchange->AsyncResumptionRoutine != NULL) {
        NTSTATUS PostStatus;
        RxDbgTraceLV(0, Dbg, 1000, ("Resume with post-to-async\n"));
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(OrdinaryExchange->WorkQueueItem);i+=sizeof(ULONG)) {
                //*((PULONG)(((PBYTE)&OrdinaryExchange->WorkQueueItem)+i)) = 0xdeadbeef;
                PBYTE BytePtr = ((PBYTE)&OrdinaryExchange->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &OrdinaryExchange->WorkQueueItem,
                         SmbPseContinueOrdinaryExchange,
                         OrdinaryExchange);

        ASSERT(PostStatus == STATUS_SUCCESS);
    } else {
        RxDbgTraceLV(0, Dbg, 1000, ("sync resume\n"));
        KeSetEvent(OrdinaryExchange->pSmbCeSynchronizationEvent, 0, FALSE);
    }

    *pPostFinalize = FALSE;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE 	pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus
    )
/*++

Routine Description:

    This is the send call back indication handling routine for ordinary
    exchanges.

Arguments:

    pExchange            - the exchange instance
    pXmitBuffer          - pointer to the transmit buffer MDL
    BytesSent            - number of bytes transmitted
    SendCompletionStatus - status for the send

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeSendCallbackHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('cs');

    OrdinaryExchange->SendCompletionStatus = SendCompletionStatus;

    if (!NT_SUCCESS(SendCompletionStatus)) {
        //sometimes we use exchange-status, sometimes exchange->smbstatus
        //set them both
        pExchange->Status = SendCompletionStatus;
        pExchange->SmbStatus = SendCompletionStatus;
    }

    SmbPseDbgRunMdlChain(
        OrdinaryExchange->AssociatedStufferState.HeaderPartialMdl,
        OrdinaryExchange->SaveLengthForDebug,
        OrdinaryExchange,
        "SmbPseExchangeSendCallbackHandler_default");

    return STATUS_SUCCESS;

} // SmbPseExchangeSendCallbackHandler_default

NTSTATUS
SmbPseExchangeStart_default(
    IN PSMB_EXCHANGE 	pExchange
    )
/*++

Routine Description:

    This is the start routine for ordinary exchanges. irght now this is just a simple wrapper.

Arguments:

    pExchange - the exchange instance NOT an Ordinary Exchange

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    PAGED_CODE();

    return OrdinaryExchange->StartRoutine(
               (PSMB_PSE_ORDINARY_EXCHANGE)pExchange,
               pExchange->RxContext);

} // SmbPseExchangeStart_default


NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE 	pExchange,
    IN PMDL             pCopyDataBuffer,
    IN ULONG            CopyDataSize
    )
/*++

Routine Description:

    This is the copy data handling routine for ordinary exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeCopyDataHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('dd');

    OrdinaryExchange->MessageLength = CopyDataSize;
    pExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;

    return STATUS_SUCCESS;
} // SmbPseExchangeCopyDataHandler_default

NTSTATUS
SmbPseExchangeReceive_default(
    IN  struct _SMB_EXCHANGE *pExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
    IN ULONG        ReceiveFlags)
/*++

Routine Description:

    This is the receive indication handling routine for ordinary exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - pointer to the data buffer

    pDataBufferPointer - pointer to the buffer Mdl into which the remaining
                         data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level directly from the tdi receive event
    handler. BUT, it is also called at task time from SmbPseContinueOrdinaryExchange.
    Often, we cannot complete processing from DPClevel because fileobjects, fcbs,
    srvopens, and fobx are pageable and not locked.

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    NTSTATUS SmbStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PGENERIC_ANDX CommandState;
    UCHAR Command;
    ULONG CopyBufferLength;
    BOOLEAN ThisIsAReenter = BooleanFlagOn(OrdinaryExchange->Flags,
                                        SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);
    PLOWIO_CONTEXT LowIoContext;
    ULONG ByteCount;
    ULONG Remain;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PCHAR startVa;

    SmbPseOEAssertConsistentLinkage("SmbPseExchangeReceive_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS(ThisIsAReenter?'00':'01');

    RxDbgTrace (0, Dbg, ("SmbPseExchangeReceive_default av/ind=%08lx/%08lx\n",
                           BytesAvailable,BytesIndicated)
                );
    RxDbgTrace (0, Dbg, ("  -->headermdl %08lx\n",StufferState->HeaderMdl));
    ASSERT_ORDINARY_EXCHANGE( OrdinaryExchange );

    CommandState = &OrdinaryExchange->ParseResumeState;

    if ( !ThisIsAReenter ) {

        OrdinaryExchange->BytesIndicatedCopy = BytesIndicated;
        OrdinaryExchange->BytesAvailableCopy = BytesAvailable;

        pExchange->Status = SmbCeParseSmbHeader(
                                pExchange,
                                pSmbHeader,
                                CommandState,
                                &OrdinaryExchange->SmbStatus,
                                BytesAvailable,
                                BytesIndicated,
                                pBytesTaken);

        UPDATE_OE_HISTORY_WITH_STATUS('22');

        if ( pExchange->Status == STATUS_MORE_PROCESSING_REQUIRED) {
            goto COPY_FOR_RESUME;
        }

        if ( (pExchange->Status != STATUS_SUCCESS) ||
             ((Command = OrdinaryExchange->ParseResumeState.AndXCommand) == SMB_COM_NO_ANDX_COMMAND) ) {
            goto FINALLY;
        }

        if (Command == SMB_COM_WRITE_ANDX) {
            if (!FlagOn(pSmbHeader->Flags2,SMB_FLAGS2_COMPRESSED)) {
                if (OrdinaryExchange->ReadWrite.CompressedRequestInProgress) {
                    OrdinaryExchange->ReadWrite.CompressedReadOrWrite = FALSE;
                }
            }
        }

        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);
    } else {

        OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;

        RxDbgTrace (0, Dbg, ("  -->this is a reenter\n"));

        Command = CommandState->AndXCommand;
    }

    SmbStatus = OrdinaryExchange->SmbStatus;

    if ( (SmbStatus!=RX_MAP_STATUS(SUCCESS)) ) {
        RxDbgTrace (0, Dbg, ("  STATUS NOT SUCCESS = %08lx\n", SmbStatus));
    }

    for ( ; Command != SMB_COM_NO_ANDX_COMMAND ; ) {
        PSMBPSE_RECEIVE_MODEL_PARAMETERS ReceiveModelParams = &SmbPseReceiveModelParameters[Command];
        ULONG ReceiveModelParamsFlags;
        UCHAR mappedCommand = Command;
        PCHAR Response = (PCHAR)pSmbHeader + SmbGetUshort(&CommandState->AndXOffset);

        if( Response > (PCHAR)pSmbHeader + BytesAvailable )
        {
            // Invalid Command
            *pBytesTaken = BytesAvailable;
            *pDataBufferPointer = NULL;
            *pDataSize = 0;

            Status = STATUS_SUCCESS;
            pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            goto FINALLY;
        }

        OrdinaryExchange->LastSmbCommand = Command; //this is used to multiplex in finish routines
        UPDATE_OE_HISTORY_WITH_STATUS('88');

        //
        // Case on the Smb Command Type
        //

        ReceiveModelParamsFlags = ReceiveModelParams->Flags;
        if (ReceiveModelParamsFlags!=0) {

            //map this onto read_andx....which is the arm of the switch that implements the model
            mappedCommand = SMB_COM_READ_ANDX;

        } else {

            //
            // If there's a continuation, then copy&post. it used to always do this.
            // now, we're going to do it unless the command is modeled.
            // the modeling code will take care of correctly deciding to post/nopost.
            //

            if ( (OrdinaryExchange->AsyncResumptionRoutine != NULL) &&
                 !ThisIsAReenter) {
                goto COPY_FOR_RESUME;
            }

        }

        switch (mappedCommand) {
        case SMB_COM_READ_ANDX:
            {
                NTSTATUS FinishStatus = RX_MAP_STATUS(SUCCESS);
                NTSTATUS FinalStatus = RX_MAP_STATUS(SUCCESS);
                BOOLEAN ThisIsAnAndX = BooleanFlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_THIS_IS_ANDX);
                BOOLEAN ThisWouldBeMyError = (IM_THE_LAST_GUY || !ThisIsAnAndX);

                RxDbgTrace( 0, Dbg, ("  *(ind) %s, smbstatus=%08lx\n",ReceiveModelParams->IndicationString,SmbStatus) );

                IF_DEBUG {
                    BOOLEAN BadType = FALSE;
                    DbgDoit(BadType = (OrdinaryExchange->OEType < ReceiveModelParams->LowType)
                                    ||  (OrdinaryExchange->OEType > ReceiveModelParams->HighType) );
                    if (BadType) {
                        DbgPrint("Bad OEType....%u,Cmd=%02lx,Exch=%08lx\n",OrdinaryExchange->OEType,Command,OrdinaryExchange);
                        ASSERT(!"proceed???");
                    }
                }

                // If this is an error and it's an error for this guy of the AndX
                // chain then finishup If it's a warning tho, continue according
                // to the Flags

                if ( NT_ERROR(SmbStatus) && ThisWouldBeMyError ) {

                    SmbPseDiscardProtocol( SmbStatus );
                    RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                    goto FINALLY;

                } else if ( (SmbStatus != RX_MAP_STATUS(SUCCESS)) && ThisWouldBeMyError ) {

                    if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_WARNINGS_OK)) {
                        SmbPseDiscardProtocol(SmbStatus);
                        RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                        goto FINALLY;
                    } else {
                        FinalStatus = SmbStatus;
                    }

                }

                // if there's no nocopy handler then do things the old way

                if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_NOCOPY_HANDLER)) {
                    // TEMPORARY!!!!!!
                    // If there's a continuation, then copy&post. it used to always do this. now, we're
                    // going to do it unless the command is modeled. the modeling code will take care of
                    // correctly deciding to post/nopost.
                    //

                    if ((OrdinaryExchange->AsyncResumptionRoutine != NULL) &&
                        !ThisIsAReenter ) {
                        goto COPY_FOR_RESUME;
                    }


                    //eventually, we'll finish from here but for now copy
                    //CODE.IMPROVEMENT.ASHAMED....this is really mandatory.......
                    if (RxShouldPostCompletion()) {
                        goto COPY_FOR_RESUME;
                    }

                    if (ReceiveModelParams->ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
                        PSMBPSE_RECEIVE_HANDLER ReceiveHandler = SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken];
                        FinishStatus = ReceiveHandler( OrdinaryExchange, Response);
                    }
                } else {
                    PSMBPSE_NOCOPY_RECEIVE_HANDLER NoCopyReceiveHandler =
                          (PSMBPSE_NOCOPY_RECEIVE_HANDLER)(SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken]);
                    UCHAR Action;

                    OrdinaryExchange->NoCopyFinalStatus = FinalStatus;
                    Action = NoCopyReceiveHandler(
                                 OrdinaryExchange,
                                 BytesIndicated,
                                 BytesAvailable,
                                 pBytesTaken,
                                 pSmbHeader,
                                 pDataBufferPointer,
                                 pDataSize,
#if DBG
                                 ThisIsAReenter,
#endif
                                 Response );

                    switch(Action) {
                    case SMBPSE_NOCOPYACTION_NORMALFINISH:
                        NOTHING;
                        break;

                    case SMBPSE_NOCOPYACTION_MDLFINISH:
                        Status = STATUS_MORE_PROCESSING_REQUIRED;
                        //note that whatever does this must be the last command in the
                        // packet unless we make continueOE more complicated
                        goto FINALLY;

                    case SMBPSE_NOCOPYACTION_COPY_FOR_RESUME:
                        goto COPY_FOR_RESUME;

                    case SMBPSE_NOCOPYACTION_DISCARD:
                        *pBytesTaken = BytesAvailable;
                        RxDbgTrace( 0, Dbg, ("--->discardX\n"));
                        goto FINALLY;
                    }
                }

                pExchange->Status =  (FinishStatus==RX_MAP_STATUS(SUCCESS))
                                     ? FinalStatus : FinishStatus;

                if (!ThisIsAnAndX) {
                    Response = (PCHAR)&NullGenericAndX;
                }

            }//this corresponds to the top level of the switch
            break;

        default:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

            RxDbgTrace( 0, Dbg, ("  *(ind) Unimplemented cmd=%02lx,wct=%02lx\n",
                                              Command,*Response) );


            SmbCeTransportDisconnectIndicated(pServerEntry);
            *pBytesTaken = BytesAvailable;
            *pDataBufferPointer = NULL;
            *pDataSize = 0;

            Status = STATUS_SUCCESS;
            pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            goto FINALLY;
        }
        }

        CommandState = (PGENERIC_ANDX)Response;
        Command = CommandState->AndXCommand;
    }

    //
    // If we get here then we're done.
    // Make everyone happy by taking all the bytes.
    //
    //CODE.IMPROVEMENT: it is not clear to me that this is enough. some servers may send extra bytes
    //                  on the end.
    //

    *pBytesTaken = BytesAvailable;
    goto FINALLY;


COPY_FOR_RESUME:
    //CODE.IMPROVEMENT even if we are taking by copy (as opposed to tail-MDL
    // which is how reads should work) we shouldn't copy the whole packet -
    // just the residue. of course, this is really only an issue when we have
    // significant andXing.

    CopyBufferLength = MmGetMdlByteCount(StufferState->HeaderMdl);

    ASSERT( BytesAvailable <= CopyBufferLength );

    if (!FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE) ||
        (BytesAvailable > BytesIndicated) || 
        (BytesAvailable > 127)) {

        RxDbgTrace( 0, Dbg, ("Taking data through MDL\n") );
        // Pass an MDL back in for copying the data
        *pDataBufferPointer = StufferState->HeaderMdl;
        *pDataSize    = CopyBufferLength;
        *pBytesTaken  = 0;
        Status = STATUS_MORE_PROCESSING_REQUIRED;

    } else {

        // Copy the data and resume the exchange
        ASSERT( BytesAvailable == BytesIndicated );
        RxDbgTrace( 0, Dbg, ("Taking data through copying\n") );
        *pBytesTaken = OrdinaryExchange->MessageLength = BytesAvailable;
        
        RtlCopyMemory(StufferState->BufferBase,
                      pSmbHeader,BytesIndicated);

        ASSERT(SmbGetUlong((PULONG)pSmbHeader->Protocol) == (ULONG)SMB_HEADER_PROTOCOL);

        pExchange->Status = RX_MAP_STATUS(MORE_PROCESSING_REQUIRED);
    }

    if (ThisIsAReenter) {
        pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

FINALLY:
    OrdinaryExchange->ParseResumeState = *CommandState;
    UPDATE_OE_HISTORY_WITH_STATUS('99');
    return Status;

} // SmbPseExchangeReceive_default


#define SmbPseRIStringsBufferSize 500
CHAR SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferSize];
ULONG SmbPseRIStringsBufferUsed = 0;

VOID
__SmbPseRMTableEntry(
    UCHAR SmbCommand,
    UCHAR Flags,
    SMBPSE_RECEIVE_HANDLER_TOKEN ReceiveHandlerToken,
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler
#if DBG
    ,
    PBYTE IndicationString,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE HighType
#endif
    )
{
    PSMBPSE_RECEIVE_MODEL_PARAMETERS r = &SmbPseReceiveModelParameters[SmbCommand];
#if DBG
    ULONG ISlength = strlen(IndicationString)+1;
#endif

    PAGED_CODE();

    r->Flags = SMBPSE_RMP_MODELED | Flags;
    r->ReceiveHandlerToken = (UCHAR)ReceiveHandlerToken;
    if (ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
        ASSERT((SmbPseReceiveHandlers[ReceiveHandlerToken] == ReceiveHandler)
                   || (SmbPseReceiveHandlers[ReceiveHandlerToken] == NULL));
        SmbPseReceiveHandlers[ReceiveHandlerToken] = ReceiveHandler;
    }

#if DBG
    r->ReceiveHandler = ReceiveHandler;
    r->LowType = LowType;
    r->HighType = HighType;
    if (SmbPseRIStringsBufferUsed+ISlength<=SmbPseRIStringsBufferSize) {
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
        RtlCopyMemory(r->IndicationString,IndicationString,ISlength);
    } else {
        if (SmbPseRIStringsBufferUsed<SmbPseRIStringsBufferSize) {
            DbgPrint("Overflowing the indicationstringarray...%s\n",IndicationString);
            ASSERT(!"fix it please");
        }
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
    }
    SmbPseRIStringsBufferUsed += ISlength;
#endif
}
#if DBG
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           ,#__smbcommand,b,c)
#else
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           )
#endif


VOID
SmbPseInitializeTables(
    void
    )
/*++

Routine Description:

    This routine initializes tables that are used at various points by the
    smbpse mechanisms. The must succeed structure(s) is(are) also initialized.

Arguments:

    none

Return Value:

    none

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i=0;i<256;i++) {
        SmbPseReceiveModelParameters[i].Flags = 0;
        SmbPseReceiveModelParameters[i].ReceiveHandlerToken =
            SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;
    }

    for (i=0;i<SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;i++) {
        SmbPseReceiveHandlers[i] = NULL;
    }

    SmbPseRMTableEntry(
        READ_ANDX,
        SMBPSE_OETYPE_READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,
        MRxSmbReceiveHandler_Read_NoCopy,
        SMBPSE_RMP_THIS_IS_ANDX|SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);

    SmbPseRMTableEntry(
        READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_OETYPE_READ,
        SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,
        MRxSmbReceiveHandler_Read_NoCopy,
        SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);

    SmbPseRMTableEntry(
        WRITE_ANDX,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_OETYPE_EXTEND_WRITE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,
        MRxSmbReceiveHandler_WriteAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        WRITE,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_OETYPE_CORETRUNCATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,
        MRxSmbReceiveHandler_CoreWrite,
        0);

    SmbPseRMTableEntry(
        WRITE_PRINT_FILE,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_OETYPE_WRITE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_PRINTFILE_HANDLER,
        MRxSmbReceiveHandler_WritePrintFile,
        0);

    SmbPseRMTableEntry(
        LOCKING_ANDX,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,
        MRxSmbReceiveHandler_LockingAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        UNLOCK_BYTE_RANGE,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        LOCK_BYTE_RANGE,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_OETYPE_LOCKS,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        OPEN_PRINT_FILE,
        SMBPSE_OETYPE_CREATEPRINTFILE,
        SMBPSE_OETYPE_CREATEPRINTFILE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_PRINTFILE_HANDLER,
        MRxSmbReceiveHandler_OpenPrintFile,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION2,
        SMBPSE_OETYPE_GFA,
        SMBPSE_OETYPE_GFA,
        SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
        MRxSmbReceiveHandler_GetFileAttributes,
        0);

    SmbPseRMTableEntry(
        CLOSE_PRINT_FILE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,
        MRxSmbReceiveHandler_Close,
        0);

    SmbPseRMTableEntry(
        NT_CREATE_ANDX,
        SMBPSE_OETYPE_LATENT_HEADEROPS,
        SMBPSE_OETYPE_CREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,
        MRxSmbReceiveHandler_NTCreateAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        OPEN_ANDX,
        SMBPSE_OETYPE_LATENT_HEADEROPS,
        SMBPSE_OETYPE_CREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,
        MRxSmbReceiveHandler_OpenAndX,
        SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry(
        OPEN,
        SMBPSE_OETYPE_COREOPEN,
        SMBPSE_OETYPE_COREOPEN,
        SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,
        MRxSmbReceiveHandler_CoreOpen,
        0);

    SmbPseRMTableEntry(
        CREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,
        MRxSmbReceiveHandler_CoreCreate,
        0);

    SmbPseRMTableEntry(
        CREATE_NEW,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_OETYPE_CORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,
        MRxSmbReceiveHandler_CoreCreate,
        0);

    SmbPseRMTableEntry(
        CLOSE,
        SMBPSE_OETYPE_CLOSE,
        SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,
        MRxSmbReceiveHandler_Close,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION,
        0,
        SMBPSE_OETYPE_MAXIMUM,
        SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
        MRxSmbReceiveHandler_GetFileAttributes,
        0);

    SmbPseRMTableEntry(
        TRANSACTION2,
        SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
        SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
        MRxSmbReceiveHandler_Transact2,
        0);

    SmbPseRMTableEntry(
        TRANSACTION2_SECONDARY,
        SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
        SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
        MRxSmbReceiveHandler_Transact2,
        0);

    SmbPseRMTableEntry(
        SEARCH,
        SMBPSE_OETYPE_COREQUERYLABEL,
        SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,
        MRxSmbReceiveHandler_Search,
        0);

    SmbPseRMTableEntry(
        QUERY_INFORMATION_DISK,
        SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
        SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
        SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,
        MRxSmbReceiveHandler_QueryDiskInfo,
        0);

    SmbPseRMTableEntry(
        DELETE,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_OETYPE_DELETE_FOR_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        DELETE_DIRECTORY,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        CHECK_DIRECTORY,
        SMBPSE_OETYPE_CORECHECKDIRECTORY,
        SMBPSE_OETYPE_CORECHECKDIRECTORY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        SET_INFORMATION,
        SMBPSE_OETYPE_SFA,
        SMBPSE_OETYPE_SFA,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        SET_INFORMATION2,
        SMBPSE_OETYPE_SFA2,
        SMBPSE_OETYPE_SFA2,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        CREATE_DIRECTORY,
        SMBPSE_OETYPE_CORECREATEDIRECTORY,
        SMBPSE_OETYPE_CORECREATEDIRECTORY,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        FLUSH,
        SMBPSE_OETYPE_FLUSH,
        SMBPSE_OETYPE_FLUSH,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        FIND_CLOSE2,
        SMBPSE_OETYPE_FINDCLOSE,
        SMBPSE_OETYPE_FINDCLOSE,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        NT_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_OETYPE_RENAME,
        SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,
        NULL,
        0);

    SmbPseRMTableEntry(
        IOCTL,
        SMBPSE_OETYPE_IOCTL,
        SMBPSE_OETYPE_IOCTL,
        SMBPSE_RECEIVE_HANDLER_TOKEN_IOCTL_HANDLER,
        MRxSmbReceiveHandler_Ioctl,
        0);
}


#ifdef WIN9X

NTSTATUS
MRxSmbQueryDosVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

   PAGED_CODE();

   TURN_BACK_ASYNCHRONOUS_OPERATIONS();
   return MRxSmbVolumeInformation(RxContext, 0, pBuffer, pBufferLength);

}
#endif


#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG SmbPseOeField_##x = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG SmbPseOeField_##x##y = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x.y);

DECLARE_FIELD_HLPR(RxContext);
DECLARE_FIELD_HLPR(ReferenceCount);
DECLARE_FIELD_HLPR(AssociatedStufferState);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(ReadWrite);
DECLARE_FIELD_HLPR(Transact2);
DECLARE_FIELD_HLPR2(Create,FileInfo);
DECLARE_FIELD_HLPR2(Create,smbSrvOpen);
DECLARE_FIELD_HLPR2(ReadWrite,RemainingByteCount);
DECLARE_FIELD_HLPR2(Info,FileInfo);
DECLARE_FIELD_HLPR2(Info,Buffer);
#endif





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbutils.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbutils.h

Abstract:

    This module defines the prototypes for various functions which aid in the assembly and
    disassembly of SMB's.

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

--*/

#ifndef _SMBUTILS_H_
#define _SMBUTILS_H_

extern
NTSTATUS
SmbPutString(
         PBYTE   *pBufferPointer,
         PSTRING pString,
         PULONG  pSize);

extern
NTSTATUS
SmbPutUnicodeString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);


extern
NTSTATUS
SmbPutUnicodeStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

BOOLEAN
IsValidShortFileName(
    PUNICODE_STRING FileName
    );

#endif // _SMBUTILS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbwmi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mupwml.h

Abstract:

    This file defines macro for use by the Rdbss driver

Author:

    yunlin

Revision History:

--*/

#ifndef __SMB_SMBWML_H__
#define __SMB_SMBWML_H__

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;
    
#ifndef _WMIKM_
#define _WMIKM_
#endif

#include "..\..\wmi\wmlkm.h"
#include "..\..\wmi\wmlmacro.h"
// Streams 

#define _SMB_TRACE_STREAM               0x00
#define _SMB_PERF_STREAM                0x01
#define _SMB_INSTR_STREAM               0x02

#define _SMB_ENABLE_ERROR               0x0001
#define _SMB_ENABLE_LOG                 0x0002
#define _SMB_ENABLE_TRACE               0x0004
#define _SMB_ENABLE_SERVER              0x0008
#define _SMB_ENABLE_NETROOT             0x0010
#define _SMB_ENABLE_VNETROOT            0x0020
#define _SMB_ENABLE_FCB                 0x0040
#define _SMB_ENABLE_SRVOPEN             0x0080
#define _SMB_ENABLE_FOBX                0x0100
#define _SMB_ENABLE_TRANSPORT           0x0200
#define _SMB_ENABLE_RXCONTEXT           0x0400
#define _SMB_ENABLE_SESSION             0x0800
#define _SMB_ENABLE_SECURITY            0x1000
#define _SMB_ENABLE_EXCHANGE            0x2000
#define _SMB_ENABLE_UNUSED2             0x4000
#define _SMB_ENABLE_UNUSED1             0x8000

#define _SMB_LEVEL_DETAIL               0x1
#define _SMB_LEVEL_NORM                 0x2
#define _SMB_LEVEL_BRIEF                0x4

#define SMB_LOG_STREAM(_stream)   _SMB_ ## _stream ## _STREAM
#define SMB_LOG_FLAGS(_flag)      _SMB_ENABLE_ ## _flag
#define SMB_LOG_LEVEL(_level)     _SMB_LEVEL_ ## _level

#define SMB_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(MRxSmb_, SMB_LOG_STREAM(_why), SMB_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,

#define SmbTrace(_flag, _type, _arg)              \
            SMB_LOG(TRACE, DETAIL, SMB_LOG_FLAGS(_flag), _type, _arg)

#define SmbLog(_flag, _type, _arg)              \
            SMB_LOG(TRACE, BRIEF, SMB_LOG_FLAGS(_flag), _type, _arg)

#define SmbTraceError(_status, _flag, _type, _arg)    \
            SMB_LOG(TRACE, DETAIL, (SMB_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : SMB_LOG_FLAGS(ERROR))), _type, _arg)

#define SmbLogError(_status, _flag, _type, _arg)    \
            SMB_LOG(TRACE, BRIEF, (SMB_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : SMB_LOG_FLAGS(ERROR))), _type, _arg)

#if 0
#define SMB_PERF(_flag, _type, _arg)                    \
            SMB_LOG (PERF, HIGH, SMB_LOG_FLAGS(_flag), _type, _arg)

#define SMB_INSTR(_flag, _type, _arg)                   \
            SMB_LOG (INSTR, HIGH, SMB_LOG_FLAGS(_flag), _type, _arg)

#define SMB_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, SMB_LOG_STREAM(_why), SMB_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define SMB_DBG_PRINT(_flag, _fmtstr, _arg)             \
            SMB_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define SMB_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                SMB_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }
#endif

enum SMB_WMI_ENUM {
  MSG_ID_SmbDefault = 1,
  MSG_ID_MRxSmbFsdDispatch_Entry = 2,
  MSG_ID_MRxSmbRefServerEntry,
  MSG_ID_MRxSmbRefNetRootEntry,
  MSG_ID_MRxSmbRefSessionEntry = 5,
  MSG_ID_MRxSmbRefVNetRootContext,
  MSG_ID_MRxSmbDerefServerEntry,
  MSG_ID_MRxSmbDerefNetRootEntry,
  MSG_ID_MRxSmbDerefSessionEntry,
  MSG_ID_MRxSmbDerefVNetRootContext = 10,
  MSG_ID_MRxSmbCreate,
  MSG_ID_SmbPseExchangeStart_CoreInfo,
  MSG_ID_MRxSmbExtendForCache,
  MSG_ID_MRxSmbCoreDeleteForSupercedeOrClose,
  MSG_ID_MRxSmbAllocateSideBuffer = 15,
  MSG_ID_MRxSmbDeallocateSideBuffer,
  MSG_ID_MrxSmbUnalignedDirEntryCopyTail,
  MSG_ID_MRxSmbQueryDirectory,
  MSG_ID_SmbCeGetConfigurationInformation,
  MSG_ID_UninitializeMidMap = 20,
  MSG_ID_MRxSmbDeferredCreate_1,
  MSG_ID_MRxSmbDeferredCreate_2,
  MSG_ID_SmbPseExchangeStart_Read,
  MSG_ID_BuildNtLanmanResponsePrologue,
  MSG_ID_BuildExtendedSessionSetupResponsePrologue = 25,
  MSG_ID_ValidateServerExtendedSessionSetupResponse,
  MSG_ID_BuildExtendedSessionSetupResponsePrologueFake,
  MSG_ID_SmbCeProbeServers,
  MSG_ID_SmbCeTransportDisconnectIndicated,
  MSG_ID_SmbCeResumeAllOutstandingRequestsOnError = 30,
  MSG_ID_SmbCeFinalizeAllExchangesForNetRoot,
  MSG_ID_SmbCeReceiveInd,
  MSG_ID_SmbCeReceiveIndWithSecuritySignature,
  MSG_ID_SmbCeDataReadyIndWithSecuritySignature,
  MSG_ID_SmbCeParseSmbHeader = 35,
  MSG_ID_SmbCeDetectExpiredExchanges,
  MSG_ID_RxMiniSniffer,
  MSG_ID_SmbCeReceiveInd_2,
  MSG_ID_SmbCeReceiveInd_3,
  MSG_ID_SmbCeErrorInd = 40,
  MSG_ID_MRxSmbSetInitialSMB,
  MSG_ID_SmbTransactExchangeReceive_1,
  MSG_ID_SmbTransactExchangeReceive_2,
  MSG_ID_SmbTransactExchangeReceive_3,
  MSG_ID_SmbTransactExchangeReceive_4 = 45,
  MSG_ID_SmbTransactExchangeReceive_5,
  MSG_ID_SmbTransactExchangeFinalize,
  MSG_ID_SendSecondaryRequests,
  MSG_ID_SmbExtSecuritySessionSetupExchangeStart,
  MSG_ID_MRxSmbCreateVNetRoot = 50,
  MSG_ID_SmbConstructNetRootExchangeFinalize,
  MSG_ID_MRxSmbInitializeRecurrentServices,
  MSG_ID_UninitializeSecurityContextsForSession,
  MSG_ID_DeleteSecurityContextForSession,
  MSG_ID_SmbCeFindOrConstructServerEntry_1 = 55,
  MSG_ID_SmbCeFindOrConstructServerEntry_2,
  MSG_ID_SmbCeTearDownServerEntry,
  MSG_ID_SmbCeFindOrConstructSessionEntry_1,
  MSG_ID_SmbCeFindOrConstructSessionEntry_2,
  MSG_ID_SmbCeTearDownSessionEntry = 60,
  MSG_ID_SmbCeFindOrConstructNetRootEntry_1,
  MSG_ID_SmbCeFindOrConstructNetRootEntry_2,
  MSG_ID_SmbCeTearDownNetRootEntry,
  MSG_ID_SmbCeCancelExchange_1,
  MSG_ID_SmbCeCancelExchange_2 = 65,
  MSG_ID_SmbCeFindVNetRootContext,
  MSG_ID_SmbCeFindOrConstructVNetRootContext_1,
  MSG_ID_SmbCeFindOrConstructVNetRootContext_2,
  MSG_ID_SmbCepDereferenceVNetRootContext,
  MSG_ID_SmbCeTearDownVNetRootContext = 70,
  MSG_ID_SmbCeScavengeRelatedContexts,
  MSG_ID_MRxSmbWrite,
  MSG_ID_CscPrepareServerEntryForOnlineOperation_1,
  MSG_ID_CscPrepareServerEntryForOnlineOperation_2,
  MSG_ID_CscPrepareServerEntryForOnlineOperation_3 = 75,
  MSG_ID_CscTransitionServerToOnline_1,
  MSG_ID_CscTransitionServerToOnline_2,
  MSG_ID_CscTransitionServerToOnline_3,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_1,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_2 = 80,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_3,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_4,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_5,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_6,
  MSG_ID_CscpTransitionServerEntryForDisconnectedOperation_7 = 85,
  MSG_ID_CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_1,
  MSG_ID_CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_2,
  MSG_ID_CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_3,
  MSG_ID_CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_4,
  MSG_ID_CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_5 = 90,
  MSG_ID_CscTransitionVNetRootForDisconnectedOperation_1,
  MSG_ID_CscTransitionVNetRootForDisconnectedOperation_2,
  MSG_ID_CscTransitionVNetRootForDisconnectedOperation_3,
  MSG_ID_CscTransitionServerEntryForDisconnectedOperation_1,
  MSG_ID_CscTransitionServerEntryForDisconnectedOperation_2 = 95,
  MSG_ID_CscTransitionServerEntryForDisconnectedOperation_3,
  MSG_ID_MRxSmbCscNotifyChangeDirectory,
  MSG_ID_MRxSmbCscCleanupFobx,
  MSG_ID_FCleanupAllNotifyees,
  MSG_ID_BuildNtLanmanResponsePrologue_1 = 100,
  MSG_ID_BuildNtLanmanResponsePrologue_2,
  MSG_ID_BuildNtLanmanResponsePrologue_3,
  MSG_ID_BuildExtendedSessionSetupResponsePrologue_1,
  MSG_ID_BuildExtendedSessionSetupResponsePrologue_2,
  MSG_ID_BuildExtendedSessionSetupResponsePrologue_3 = 105,
  MSG_ID_ValidateServerExtendedSessionSetupResponse_1,
  MSG_ID_ValidateServerExtendedSessionSetupResponse_2,
  MSG_ID_BuildExtendedSessionSetupResponsePrologueFake_1,
  MSG_ID_BuildExtendedSessionSetupResponsePrologueFake_2,
  MSG_ID_BuildExtendedSessionSetupResponsePrologueFake_3 = 110,
  MSG_ID_BuildExtendedSessionSetupResponsePrologueFake_4,
  MSG_ID_MRxSmbpBindTransportCallback_1,
  MSG_ID_MRxSmbpBindTransportCallback_2,
  MSG_ID_SmbExtSecuritySessionSetupExchangeCopyDataHandler,
  MSG_ID_VctpCreateConnectionCallback = 115,
  MSG_ID_BuildSessionSetupSecurityInformation,
}; 

            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)

extern WML_CONTROL_GUID_REG MRxSmb_ControlGuids[];

#endif /* __SMB_SMBWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbutils.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbutils.c

Abstract:

    This module implements the routines that aid in the assembly/disassembly of SMB's

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)

#include "lmerr.h"
#include "nb30.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbPutString)
#pragma alloc_text(PAGE, SmbPutUnicodeString)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAndUpcase)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAsOemString)
#pragma alloc_text(PAGE, SmbPutUnicodeStringAsOemStringAndUpcase)
#endif


NTSTATUS
SmbPutString(
    PBYTE   *pBufferPointer,
    PSTRING pString,
    PULONG  pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize > pString->Length) {
        RtlCopyMemory(
            pBuffer,
            pString->Buffer,
            pString->Length);

        *pSize -= pString->Length;
        *pBufferPointer = pBuffer + pString->Length;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeString(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
        WCHAR NullChar = L'\0';

        RtlCopyMemory(
            pBuffer,
            pUnicodeString->Buffer,
            pUnicodeString->Length);

        RtlCopyMemory(
            (pBuffer + pUnicodeString->Length),
            &NullChar,
            sizeof(WCHAR));

        *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
        *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAndUpcase(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS Status;
    PBYTE    pBuffer = *pBufferPointer;

    PAGED_CODE();

    if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
        UNICODE_STRING BufferAsUnicode;
        WCHAR          NullChar = L'\0';

        BufferAsUnicode.Buffer = (PWCHAR)pBuffer;
        BufferAsUnicode.Length = pUnicodeString->Length;
        BufferAsUnicode.MaximumLength = BufferAsUnicode.Length;

        RtlUpcaseUnicodeString(
            &BufferAsUnicode,
            pUnicodeString,
            FALSE);

        RtlCopyMemory(
            (pBuffer + pUnicodeString->Length),
            &NullChar,
            sizeof(WCHAR));

        *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
        *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemString(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS   Status;
    OEM_STRING OemString;
    PBYTE      pBuffer = *pBufferPointer;

    PAGED_CODE();

    OemString.MaximumLength = (USHORT)*pSize;
    OemString.Buffer        = pBuffer;

    // The Rtl routine pads the converted string with a NULL.
    Status = RtlUnicodeStringToOemString(
                 &OemString,             // destination string
                 pUnicodeString,         // source string
                 FALSE);                 // No memory allocation for destination

    if (NT_SUCCESS(Status)) {
        if (OemString.Length < *pSize) {
            // put the null
            pBuffer += (OemString.Length + 1);
            *pBufferPointer = pBuffer;
            *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
        } else {
            Status = RX_MAP_STATUS(BUFFER_OVERFLOW);
        }
    }

    return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
    PBYTE           *pBufferPointer,
    PUNICODE_STRING pUnicodeString,
    PULONG          pSize)
{
    NTSTATUS   Status;
    OEM_STRING OemString;
    PBYTE      pBuffer = *pBufferPointer;

    PAGED_CODE();

    OemString.MaximumLength = (USHORT)*pSize;
    OemString.Buffer        = pBuffer;

    // The Rtl routine pads the converted string with a NULL.
    Status = RtlUpcaseUnicodeStringToOemString(
                 &OemString,             // destination string
                 pUnicodeString,         // source string
                 FALSE);                 // No memory allocation for destination

    if (NT_SUCCESS(Status)) {
        if (OemString.Length < *pSize) {
            // put the null
            pBuffer += (OemString.Length + 1);
            *pBufferPointer = pBuffer;
            *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    return Status;
}

//
// The maps for mapping various error codes into NTSTATUSs
//

typedef struct _STATUS_MAP {
    USHORT ErrorCode;
    NTSTATUS ResultingStatus;
} STATUS_MAP, *PSTATUS_MAP;

STATUS_MAP
SmbErrorMap[] = {
    { SMB_ERR_BAD_PASSWORD, STATUS_WRONG_PASSWORD },
    { SMB_ERR_ACCESS, STATUS_NETWORK_ACCESS_DENIED },
    { SMB_ERR_BAD_TID, STATUS_NETWORK_NAME_DELETED },
    { SMB_ERR_BAD_NET_NAME, STATUS_BAD_NETWORK_NAME }, // Invalid network name
    { SMB_ERR_BAD_DEVICE, STATUS_BAD_DEVICE_TYPE }, // Invalid device request
    { SMB_ERR_QUEUE_FULL, STATUS_PRINT_QUEUE_FULL }, // Print queue full
    { SMB_ERR_QUEUE_TOO_BIG, STATUS_NO_SPOOL_SPACE }, // No space on print dev
    { SMB_ERR_BAD_PRINT_FID, STATUS_PRINT_CANCELLED }, // Invalid printfile FID
    { SMB_ERR_SERVER_PAUSED, STATUS_SHARING_PAUSED }, // Server is paused
    { SMB_ERR_MESSAGE_OFF, STATUS_REQUEST_NOT_ACCEPTED }, // Server not receiving msgs
    { SMB_ERR_BAD_TYPE, STATUS_BAD_DEVICE_TYPE },           // Reserved
    { SMB_ERR_BAD_SMB_COMMAND, STATUS_NOT_IMPLEMENTED }, // SMB command not recognized
    { SMB_ERR_BAD_PERMITS, STATUS_NETWORK_ACCESS_DENIED }, // Access permissions invalid
    { SMB_ERR_NO_ROOM, STATUS_DISK_FULL }, // No room for buffer message
    { SMB_ERR_NO_RESOURCE, STATUS_REQUEST_NOT_ACCEPTED }, // No resources available for request
    { SMB_ERR_TOO_MANY_UIDS, STATUS_TOO_MANY_SESSIONS }, // Too many UIDs active in session
    { SMB_ERR_BAD_UID, STATUS_USER_SESSION_DELETED }, // UID not known as a valid UID
    { SMB_ERR_USE_MPX, STATUS_SMB_USE_MPX }, // Can't support Raw; use MPX
    { SMB_ERR_USE_STANDARD, STATUS_SMB_USE_STANDARD }, // Can't support Raw, use standard r/w
    { SMB_ERR_INVALID_NAME, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_INVALID_NAME_RANGE, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_NO_SUPPORT,STATUS_NOT_SUPPORTED }, // Function not supported
    { NERR_PasswordExpired, STATUS_PASSWORD_EXPIRED },
    { NERR_AccountExpired, STATUS_ACCOUNT_DISABLED },
    { NERR_InvalidLogonHours, STATUS_INVALID_LOGON_HOURS },
    { NERR_InvalidWorkstation, STATUS_INVALID_WORKSTATION },
    { NERR_DuplicateShare, STATUS_LOGON_FAILURE }

//    { SMB_ERR_QUEUE_EOF, STATUS_UNEXPECTED_NETWORK_ERROR },// EOF on print queue dump
//    { SMB_ERR_SERVER_ERROR, STATUS_UNEXPECTED_NETWORK_ERROR}, // Internal server error
//    { SMB_ERR_FILE_SPECS, STATUS_UNEXPECTED_NETWORK_ERROR },    // FID and pathname were incompatible
//    { SMB_ERR_BAD_ATTRIBUTE_MODE, STATUS_UNEXPECTED_NETWORK_ERROR }, // Invalid attribute mode specified
//    { SMB_ERR_NO_SUPPORT_INTERNAL,STATUS_UNEXPECTED_NETWORK_ERROR }, // Internal code for NO_SUPPORT--
//                                                // allows codes to be stored in a byte
//    { SMB_ERR_ERROR, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_CONTINUE_MPX, STATUS_UNEXPECTED_NETWORK_ERROR }, // Reserved
//    { SMB_ERR_TOO_MANY_NAMES, STATUS_UNEXPECTED_NETWORK_ERROR }, // Too many remote user names
//    { SMB_ERR_TIMEOUT, STATUS_UNEXPECTED_NETWORK_ERROR }, // Operation was timed out
//    { SMB_ERR_RESERVED2, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED3, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED4, STATUS_UNEXPECTED_NETWORK_ERROR },
//    { SMB_ERR_RESERVED5, STATUS_UNEXPECTED_NETWORK_ERROR },

};

ULONG
SmbErrorMapLength = sizeof(SmbErrorMap) / sizeof(SmbErrorMap[0]);

STATUS_MAP
Os2ErrorMap[] = {
    { ERROR_INVALID_FUNCTION,   STATUS_NOT_IMPLEMENTED },
    { ERROR_FILE_NOT_FOUND,     STATUS_NO_SUCH_FILE },
    { ERROR_PATH_NOT_FOUND,     STATUS_OBJECT_PATH_NOT_FOUND },
    { ERROR_TOO_MANY_OPEN_FILES,STATUS_TOO_MANY_OPENED_FILES },
    { ERROR_ACCESS_DENIED,      STATUS_ACCESS_DENIED },
    { ERROR_INVALID_HANDLE,     STATUS_INVALID_HANDLE },
    { ERROR_NOT_ENOUGH_MEMORY,  STATUS_INSUFFICIENT_RESOURCES },
    { ERROR_INVALID_ACCESS,     STATUS_ACCESS_DENIED },
    { ERROR_INVALID_DATA,       STATUS_DATA_ERROR },

    { ERROR_CURRENT_DIRECTORY,  STATUS_DIRECTORY_NOT_EMPTY },
    { ERROR_NOT_SAME_DEVICE,    STATUS_NOT_SAME_DEVICE },
    { ERROR_NO_MORE_FILES,      STATUS_NO_MORE_FILES },
    { ERROR_WRITE_PROTECT,      STATUS_MEDIA_WRITE_PROTECTED},
    { ERROR_NOT_READY,          STATUS_DEVICE_NOT_READY },
    { ERROR_CRC,                STATUS_CRC_ERROR },
    { ERROR_BAD_LENGTH,         STATUS_DATA_ERROR },
    { ERROR_NOT_DOS_DISK,       STATUS_DISK_CORRUPT_ERROR }, //***
    { ERROR_SECTOR_NOT_FOUND,   STATUS_NONEXISTENT_SECTOR },
    { ERROR_OUT_OF_PAPER,       STATUS_DEVICE_PAPER_EMPTY},
    { ERROR_SHARING_VIOLATION,  STATUS_SHARING_VIOLATION },
    { ERROR_LOCK_VIOLATION,     STATUS_FILE_LOCK_CONFLICT },
    { ERROR_WRONG_DISK,         STATUS_WRONG_VOLUME },
    { ERROR_NOT_SUPPORTED,      STATUS_NOT_SUPPORTED },
    { ERROR_REM_NOT_LIST,       STATUS_REMOTE_NOT_LISTENING },
    { ERROR_DUP_NAME,           STATUS_DUPLICATE_NAME },
    { ERROR_BAD_NETPATH,        STATUS_BAD_NETWORK_PATH },
    { ERROR_NETWORK_BUSY,       STATUS_NETWORK_BUSY },
    { ERROR_DEV_NOT_EXIST,      STATUS_DEVICE_DOES_NOT_EXIST },
    { ERROR_TOO_MANY_CMDS,      STATUS_TOO_MANY_COMMANDS },
    { ERROR_ADAP_HDW_ERR,       STATUS_ADAPTER_HARDWARE_ERROR },
    { ERROR_BAD_NET_RESP,       STATUS_INVALID_NETWORK_RESPONSE },
    { ERROR_UNEXP_NET_ERR,      STATUS_UNEXPECTED_NETWORK_ERROR },
    { ERROR_BAD_REM_ADAP,       STATUS_BAD_REMOTE_ADAPTER },
    { ERROR_PRINTQ_FULL,        STATUS_PRINT_QUEUE_FULL },
    { ERROR_NO_SPOOL_SPACE,     STATUS_NO_SPOOL_SPACE },
    { ERROR_PRINT_CANCELLED,    STATUS_PRINT_CANCELLED },
    { ERROR_NETNAME_DELETED,    STATUS_NETWORK_NAME_DELETED },
    { ERROR_NETWORK_ACCESS_DENIED, STATUS_NETWORK_ACCESS_DENIED },
    { ERROR_BAD_DEV_TYPE,       STATUS_BAD_DEVICE_TYPE },
    { ERROR_BAD_NET_NAME,       STATUS_BAD_NETWORK_NAME },
    { ERROR_TOO_MANY_NAMES,     STATUS_TOO_MANY_NAMES },
    { ERROR_TOO_MANY_SESS,      STATUS_TOO_MANY_SESSIONS },
    { ERROR_SHARING_PAUSED,     STATUS_SHARING_PAUSED },
    { ERROR_REQ_NOT_ACCEP,      STATUS_REQUEST_NOT_ACCEPTED },
    { ERROR_REDIR_PAUSED,       STATUS_REDIRECTOR_PAUSED },

    { ERROR_FILE_EXISTS,        STATUS_OBJECT_NAME_COLLISION },
    { ERROR_INVALID_PASSWORD,   STATUS_WRONG_PASSWORD },
    { ERROR_INVALID_PARAMETER,  STATUS_INVALID_PARAMETER },
    { ERROR_NET_WRITE_FAULT,    STATUS_NET_WRITE_FAULT },

    { ERROR_BROKEN_PIPE,        STATUS_PIPE_BROKEN },

    { ERROR_OPEN_FAILED,        STATUS_OPEN_FAILED },
    { ERROR_BUFFER_OVERFLOW,    STATUS_BUFFER_OVERFLOW },
    { ERROR_DISK_FULL,          STATUS_DISK_FULL },
    { ERROR_SEM_TIMEOUT,        STATUS_IO_TIMEOUT },
    { ERROR_INSUFFICIENT_BUFFER,STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_NAME,       STATUS_OBJECT_NAME_INVALID },
    { ERROR_INVALID_LEVEL,      STATUS_INVALID_LEVEL },
    { ERROR_BAD_PATHNAME,       STATUS_OBJECT_PATH_INVALID },   //*
    { ERROR_BAD_PIPE,           STATUS_INVALID_PARAMETER },
    { ERROR_PIPE_BUSY,          STATUS_PIPE_NOT_AVAILABLE },
    { ERROR_NO_DATA,            STATUS_PIPE_EMPTY },
    { ERROR_PIPE_NOT_CONNECTED, STATUS_PIPE_DISCONNECTED },
    { ERROR_MORE_DATA,          STATUS_BUFFER_OVERFLOW },
    { ERROR_VC_DISCONNECTED,    STATUS_VIRTUAL_CIRCUIT_CLOSED },
    { ERROR_INVALID_EA_NAME,    STATUS_INVALID_EA_NAME },
    { ERROR_EA_LIST_INCONSISTENT,STATUS_EA_LIST_INCONSISTENT },
//    { ERROR_EA_LIST_TOO_LONG, STATUS_EA_LIST_TO_LONG },
    { ERROR_EAS_DIDNT_FIT,      STATUS_EA_TOO_LARGE },
    { ERROR_EA_FILE_CORRUPT,    STATUS_EA_CORRUPT_ERROR },
    { ERROR_EA_TABLE_FULL,      STATUS_EA_CORRUPT_ERROR },
    { ERROR_INVALID_EA_HANDLE,  STATUS_EA_CORRUPT_ERROR }
//    { ERROR_BAD_UNIT,           STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_BAD_COMMAND,        STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_SEEK,               STATUS_UNSUCCESSFUL },// ***
//    { ERROR_WRITE_FAULT,        STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_READ_FAULT,         STATUS_UNSUCCESSFUL}, // ***
//    { ERROR_GEN_FAILURE,        STATUS_UNSUCCESSFUL }, // ***

};

ULONG
Os2ErrorMapLength = sizeof(Os2ErrorMap) / sizeof(Os2ErrorMap[0]);


NTSTATUS
GetSmbResponseNtStatus(
    PSMB_HEADER     pSmbHeader,
    PSMB_EXCHANGE   pExchange
    )
{
    NTSTATUS Status;
    USHORT Error;
    USHORT i;

    ASSERT( pSmbHeader != NULL );

    //  If this SMB contains an NT status for the operation, return
    //  that, otherwise map the resulting error.
    if (SmbGetUshort(&pSmbHeader->Flags2) & SMB_FLAGS2_NT_STATUS) {

        Status = SmbGetUlong( & ((PNT_SMB_HEADER)pSmbHeader)->Status.NtStatus );

        if ((Status == STATUS_SUCCESS) || NT_ERROR(Status) || NT_WARNING(Status)) {
            return Status;
        }
        // else fall through and treat it as an SMB error ..
        // This needs to be done because in certain cases NT servers return SMB
        // specific error codes eventhough the NTSTATUS flag is set
    }

    if (pSmbHeader->ErrorClass == SMB_ERR_SUCCESS) {
        return STATUS_SUCCESS;
    }

    Error = SmbGetUshort(&pSmbHeader->Error);
    if (Error == SMB_ERR_SUCCESS) {
        // Umm, non success ErrorClass but success Error code.
        Status = STATUS_UNEXPECTED_NETWORK_ERROR;
    } else {
        // Map the error code depending on Error Class
        switch (pSmbHeader->ErrorClass) {
        case SMB_ERR_CLASS_DOS:
        case SMB_ERR_CLASS_HARDWARE:
            Status = BASE_DOS_ERROR + Error;
            for (i = 0; i < Os2ErrorMapLength; i++) {
                if (Os2ErrorMap[i].ErrorCode == Error) {
                    Status = Os2ErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        case SMB_ERR_CLASS_SERVER:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            for (i = 0; i < SmbErrorMapLength; i++) {
                if (SmbErrorMap[i].ErrorCode == Error) {
                    //The error of STATUS_NETWORK_ACCESS_DENIED should be mapped as STATUS_NO_SUCH_FILE for
                    //the non-NT servers in case it tries to access the PIPE.
                    if (SmbErrorMap[i].ResultingStatus == STATUS_NETWORK_ACCESS_DENIED) {
                        SMBCE_SERVER Server = pExchange->SmbCeContext.pServerEntry->Server;
                        NET_ROOT_TYPE NetRootType = pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type;

                        if (NetRootType == NET_ROOT_PIPE) {
                            if ( (Server.Dialect != NTLANMAN_DIALECT) ||
                                 !FlagOn(Server.DialectFlags,DF_NT_STATUS) ) {
                                Status = STATUS_NO_SUCH_FILE;
                                break;
                            }
                        }
                    }
                    Status = SmbErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        default:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            break;
        }
    }

    return Status;
}

BOOLEAN
IsValidShortFileName(
    PUNICODE_STRING Name
    )
{
    BOOLEAN IsValidName = TRUE;
    int NumberOfChars;
    int CurrentNameStart = 0;
    int CurrentNameEnd = 0;
    int CurrentDot = 0;
    int i;

    if (Name == NULL) {
        return TRUE;
    }

    NumberOfChars = Name->Length/sizeof(UNICODE_NULL);

    while(IsValidName && CurrentNameStart < NumberOfChars) {
        CurrentNameEnd = NumberOfChars;

        for (i=CurrentNameStart+1;i<NumberOfChars;i++) {
            if (Name->Buffer[i] == L'\\') {
                CurrentNameEnd = i;
                break;
            }
        }

        if (CurrentNameEnd - CurrentNameStart > 13) {
            IsValidName = FALSE;
        }

        if (IsValidName) {
            CurrentDot = CurrentNameEnd;

            for (i=CurrentNameStart;i<CurrentNameEnd;i++) {
                if (Name->Buffer[i] == L'.') {
                    if (CurrentDot == CurrentNameEnd) {
                        CurrentDot = i;
                    } else {
                        IsValidName = FALSE;
                    }
                }
            }

            if (IsValidName) {
                if (CurrentDot - CurrentNameStart > 9 ||
                    CurrentNameEnd - CurrentDot > 4) {
                    IsValidName = FALSE;
                }
            }
        }

        CurrentNameStart = CurrentNameEnd;
    }

    return IsValidName;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\smbxchng.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effect
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.c

Abstract:

    This is the include file that implements the SMB_*_EXCHANGE creation, deletion and
    dispatch routines.

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

Notes:

    The exchange engine supports two kinds of changes, timed and untimed exhanges.
    The timed exchanges are distinguished by the SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION.

    In addition all exchanges are finalized if the transport is not able to push out
    the data within a specific period of time. This enables us to throttle back
    traffic to a overloaded server. Currently this is a global constant for all exchanges
    and is set to 300 seconds.

    This time limit only comes into play only when a send complete operation is outstanding

    The exchanges are put on a timed exchange list ( one for each type of exchange)
    when it is initiated. When a network operation, i.e., tranceive/send/copydata is
    initiated the corresponding expiry time in the exchange is updated by invoking the
    routine SmbCeSetExpiryTime.

    The echo probes are initiated is invoked through the context of a recurrent service
    (recursvc.c/recursvc.h). Every time this service is invoked (SmbCeProbeServers) it
    in turn invokes SmbCeDetectAndResumeExpiredExchanges. This routine detects those
    exchanges for which the wait for a response has exceeded the time limit and marks
    them for finalization.

    The finalization is done by SmbCeScavengeTimedOutExchanges in the context of a worker
    thread. Notice that due to the granularity mismatch we treat timeout intervals as
    soft deadlines.

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbInitializeSmbCe)
#pragma alloc_text(PAGE, SmbCeSerializeSessionSetupRequests)
#pragma alloc_text(PAGE, SmbCeUnblockSerializedSessionSetupRequests)
#pragma alloc_text(PAGE, SmbCeUnblockSerializedSessionSetupRequests)
#pragma alloc_text(PAGE, SmbCeInitiateExchange)
#pragma alloc_text(PAGE, SmbCeInitiateAssociatedExchange)
#pragma alloc_text(PAGE, SmbCeExchangeAbort)
#pragma alloc_text(PAGE, SmbCeBuildSmbHeader)
#pragma alloc_text(PAGE, SmbCeResumeExchange)
#pragma alloc_text(PAGE, SmbCepInitializeExchange)
#pragma alloc_text(PAGE, SmbCeInitializeAssociatedExchange)
#pragma alloc_text(PAGE, SmbCeTransformExchange)
#pragma alloc_text(PAGE, SmbCePrepareExchangeForReuse)
#pragma alloc_text(PAGE, SmbCeDiscardExchange)
#pragma alloc_text(PAGE, SmbCeFinalizeExchangeWorkerThreadRoutine)
#pragma alloc_text(PAGE, SmbCeFinalizeExchangeOnDisconnect)
#pragma alloc_text(PAGE, SmbCeDetectExpiredExchanges)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndError)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndReceive)
#pragma alloc_text(PAGE, DefaultSmbExchangeIndSendCallback)
#endif

#define CANCEL_BUFFER_SIZE (sizeof(SMB_HEADER) + sizeof(REQ_NT_CANCEL))

ULONG SmbCeTraceExchangeReferenceCount = 0;
extern BOOLEAN MRxSmbSecuritySignaturesRequired;
extern BOOLEAN MRxSmbSecuritySignaturesEnabled;

RXDT_DefineCategory(SMBXCHNG);
#define Dbg        (DEBUG_TRACE_SMBXCHNG)

// The exchange engine in the mini redirector requires to maintain enough state
// to ensure that all the active exchanges are completed correctly when a shut down
// occurs. Since the exchanges can be finalized by different threads, including
// posted completions the exchange engine on startup initializes an event upon startup
// which is subsequently used to signal the terminating condition.
//
// The count of active changes has to be tracked continously and the signalling
// of the event depends upon the number of active exchanges reaching the count of
// zero and the exchange engine being in a stopped state.

SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

NTSTATUS
MRxSmbInitializeSmbCe()
/*++

Routine Description:

   This routine initializes the connection engine

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    LONG i;

    PAGED_CODE();

    KeInitializeEvent(
        &SmbCeStartStopContext.StopEvent,
        NotificationEvent,
        FALSE);

    SmbCeStartStopContext.ActiveExchanges = 0;
    SmbCeStartStopContext.State = SMBCE_STARTED;
    SmbCeStartStopContext.pServerEntryTearDownEvent = NULL;

    InitializeListHead(
        &SmbCeStartStopContext.SessionSetupRequests);

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbTearDownSmbCe()
/*++

Routine Description:

   This routine tears down the connection engine

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    BOOLEAN fWait;

    if (SmbCeStartStopContext.State == SMBCE_STARTED) {
        SmbCeAcquireSpinLock();
        SmbCeStartStopContext.State = SMBCE_STOPPED;
        fWait = (SmbCeStartStopContext.ActiveExchanges > 0);
        SmbCeReleaseSpinLock();

        if (fWait) {
            KeWaitForSingleObject(
                &SmbCeStartStopContext.StopEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeIncrementActiveExchangeCount()
/*++

Routine Description:

   This routine increments the active exchange count

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();
    if (SmbCeStartStopContext.State != SMBCE_STARTED) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        InterlockedIncrement(&SmbCeStartStopContext.ActiveExchanges);
    }
    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeDecrementActiveExchangeCount()
/*++

Routine Description:

   This routine decrements the active exchange count

Return Value:

    NXSTATUS - The return status for the operation

Notes:

--*/
{
    LONG FinalRefCount;

    ASSERT(SmbCeStartStopContext.ActiveExchanges > 0);
    if (InterlockedDecrement(&SmbCeStartStopContext.ActiveExchanges) == 0) {
        SmbCeAcquireSpinLock();
        if (SmbCeStartStopContext.State == SMBCE_STOPPED) {
            KeSetEvent(&SmbCeStartStopContext.StopEvent,0,FALSE);
        }
        SmbCeReleaseSpinLock();
    }
}


NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine initializes the server associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitialising it.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG     CscState;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    ASSERT(SmbCeIsResourceOwned());
    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIALIZATION_START);

    if (SmbCeGetServerType(pServerEntry) == SMBCEDB_MAILSLOT_SERVER &&
        !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
        // if the serve entry was created for mailslot operation, and a non-maislot operation
        // comes, the server entry needs to establish a VC transport. Therefore we invalidate
        // the server entry and set it to FILE SERVER.

        pServerEntry->Header.State = SMBCEDB_INVALID;
        SmbCeSetServerType(pServerEntry,SMBCEDB_FILE_SERVER);
        SetFlag(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);
    }

    if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) &&
        (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER)) {
        CscState = InterlockedCompareExchange(
                       &pServerEntry->Server.CscState,
                       ServerCscShadowing,
                       ServerCscTransitioningToShadowing);

        if (CscState == ServerCscTransitioningToShadowing) {
            ASSERT(!pServerEntry->NegotiateInProgress);
            pServerEntry->Header.State = SMBCEDB_INVALID;
        }
    }

    if (pServerEntry->Header.State != SMBCEDB_ACTIVE) {
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) {
            switch (pServerEntry->Header.State) {
            case SMBCEDB_INVALID:
                {
                    BOOLEAN              ServerInDisconnectedModeBeforeInit;
                    SMBCEDB_OBJECT_STATE State;

                    ServerInDisconnectedModeBeforeInit = SmbCeIsServerInDisconnectedMode(
                                                            pServerEntry);

                    ASSERT(!pServerEntry->NegotiateInProgress);
                    pServerEntry->NegotiateInProgress = TRUE;

                    SmbCeUpdateServerEntryState(
                        pServerEntry,
                        SMBCEDB_CONSTRUCTION_IN_PROGRESS);

                    SmbCeReleaseResource();

                    // Initialize the transport associated with the server
                    Status = SmbCeInitializeServerTransport(pServerEntry,NULL,NULL);

                    if (Status == STATUS_SUCCESS) {
                        if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                            if (!ServerInDisconnectedModeBeforeInit) {
                                // A transition has occurred from connected mode of
                                // operation to a disconnected mode. retry the
                                // operation
                                Status = STATUS_RETRY;
                            }
                        } else {
                            if (ServerInDisconnectedModeBeforeInit) {
                                DbgPrint("Transitioning SE %lx from DC to CO\n",pServerEntry);
                            }
                        }
                    }

                    if (Status == STATUS_SUCCESS) {

                        PSMBCEDB_SESSION_ENTRY pSessionEntry =
                            SmbCeGetExchangeSessionEntry(pExchange);
                        BOOLEAN RemoteBootSession;

                        if ((pSessionEntry != NULL) &&
                            (FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                             MRxSmbUseKernelModeSecurity)) {
                            RemoteBootSession = TRUE;
                        } else {
                            RemoteBootSession = FALSE;
                        }

                        Status = SmbCeNegotiate(
                                     pServerEntry,
                                     pServerEntry->pRdbssSrvCall,
                                     RemoteBootSession
                                     );
                    }

                    SmbCeCompleteServerEntryInitialization(pServerEntry,Status);

                    if (Status != STATUS_SUCCESS) {
                        // Either the transport initialization failed or the NEGOTIATE
                        // SMB could not be sent ....

                        InterlockedIncrement(&MRxSmbStatistics.Reconnects);
                    }

                    SmbCeAcquireResource();
                }
                break;

            case SMBCEDB_CONSTRUCTION_IN_PROGRESS :
                {
                    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

                    pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                                    SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
                    if (pRequestEntry != NULL) {
                        // Enqueue the request entry.
                        pRequestEntry->ReconnectRequest.Type      = RECONNECT_REQUEST;
                        pRequestEntry->ReconnectRequest.pExchange = pExchange;

                        SmbCeIncrementPendingLocalOperations(pExchange);
                        SmbCeAddRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

                        Status = STATUS_PENDING;
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            default :
                Status = STATUS_CONNECTION_DISCONNECTED;
                break;
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SERVER_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());

    return Status;
}

VOID
SmbCeSerializeSessionSetupRequests(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine serializes the session setup requests to a server

Arguments:

    pSessionEntry  - the session entry.

Notes:

    The session setup request with a VC number of zero has a special significance
    for the server. It is the clue for the server to tear down any existing
    data structures and rebuild ( client reboot ). When two aliased connections to
    a server are established it is important to ensure that no connections with VC
    number zero are outstanding while a non zero VC numbered session is sent. This
    is because of the potential for out of order request processing that exists
    on the server.

    In order to garantee the sequence of session setup, we put the outstanding session
    setup requests on a waiting list. If there is a new sesstion setup against the
    aliased server, it will be held until the first session setup finished.

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    BOOLEAN DelayedRequest = FALSE;

    PAGED_CODE();

    RemoveEntryList(&pSessionEntry->SerializationList);
    InitializeListHead(&pSessionEntry->SerializationList);

    pServerEntry = pSessionEntry->pServerEntry;
    pSessionEntry->SessionVCNumber = 0;

    if ((pServerEntry->Server.Dialect >= NTLANMAN_DIALECT)  &&
        (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_STATUS))) {
        PSMBCEDB_SESSION_ENTRY pTempSessionEntry;

        pTempSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);

        while (pTempSessionEntry != NULL) {
            if ((pTempSessionEntry != pSessionEntry) &&
                (pTempSessionEntry->Header.State != SMBCEDB_INVALID) &&
                (pTempSessionEntry->Header.State != SMBCEDB_MARKED_FOR_DELETION)) {
                pSessionEntry->SessionVCNumber = 1;
                break;
            }
            pTempSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pTempSessionEntry);
        }

        if (pServerEntry->Server.AliasedServers) {
            PLIST_ENTRY            pListEntry;
            BOOLEAN                DelaySessionSetupRequest = FALSE;
            PSMBCEDB_SERVER_ENTRY  pTempServerEntry;

            // Figure out the VC number for aliased servers by walking
            // through the list of server entries

            pTempServerEntry = SmbCeGetFirstServerEntry();

            while ((pTempServerEntry != NULL) &&
                   (pSessionEntry->SessionVCNumber == 0)) {

                if (SmbCeAreServerEntriesAliased(pServerEntry,pTempServerEntry)) {
                    pTempSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);

                    while (pTempSessionEntry != NULL) {
                        if ((pTempSessionEntry->Header.State != SMBCEDB_INVALID) &&
                            (pTempSessionEntry->Header.State != SMBCEDB_MARKED_FOR_DELETION)) {
                            pSessionEntry->SessionVCNumber = 1;
                            break;
                        }
                        pTempSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pTempSessionEntry);
                    }
                }

                pTempServerEntry = SmbCeGetNextServerEntry(pTempServerEntry);
            }

            pListEntry = SmbCeStartStopContext.SessionSetupRequests.Flink;

            while (pListEntry != &SmbCeStartStopContext.SessionSetupRequests) {
                PSMBCEDB_SESSION_ENTRY pTempSessionEntry;

                pTempSessionEntry = (PSMBCEDB_SESSION_ENTRY)
                                    CONTAINING_RECORD(
                                        pListEntry,
                                        SMBCEDB_SESSION_ENTRY,
                                        SerializationList);

                pTempServerEntry = pTempSessionEntry->pServerEntry;

                if (SmbCeAreServerEntriesAliased(pServerEntry,pTempServerEntry) &&
                    (pTempSessionEntry->SessionVCNumber == 0)) {
                    DelaySessionSetupRequest = TRUE;
                    break;
                } else {
                    pListEntry = pListEntry->Flink;
                }
            }

            if (DelaySessionSetupRequest) {
                KEVENT Event;

                KeInitializeEvent(
                    &Event,
                    NotificationEvent,
                    FALSE);

                pSessionEntry->pSerializationEvent = &Event;

                InsertTailList(
                    &SmbCeStartStopContext.SessionSetupRequests,
                    &pSessionEntry->SerializationList);

                SmbCeReleaseResource();

                KeWaitForSingleObject(
                    &Event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                SmbCeAcquireResource();

                pSessionEntry->pSerializationEvent = NULL;

                DelayedRequest = TRUE;
            }
        }
    } else {
        pSessionEntry->SessionVCNumber = 0;
    }

    if (!DelayedRequest) {
        InsertTailList(
            &SmbCeStartStopContext.SessionSetupRequests,
            &pSessionEntry->SerializationList);
    }
}

VOID
SmbCeUnblockSerializedSessionSetupRequests(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine unblocks non zero VC number session setup requests on completion
    of zero VC number session setup requests

Arguments:

    pSessionEntry  - the session entry.

Notes:

    The session setup request with a VC number of zero has a special significance
    for the server. It is the cure for the server to tear down any existing
    data structures and rebuild ( cliet reboot ). When two aliased connections to
    a server are established it is important to ensure that no connections with VC
    number zero are outstanding while a non zero VC numbered session is sent. This
    is because of the potential for out of order request processing that exists
    on the server.

--*/
{
    PLIST_ENTRY pListEntry;

    PAGED_CODE();

    RemoveEntryList(&pSessionEntry->SerializationList);
    InitializeListHead(&pSessionEntry->SerializationList);

    pListEntry = SmbCeStartStopContext.SessionSetupRequests.Flink;

    while (pListEntry != &SmbCeStartStopContext.SessionSetupRequests) {
        PSMBCEDB_SESSION_ENTRY pTempSessionEntry;

        pTempSessionEntry = (PSMBCEDB_SESSION_ENTRY)
                            CONTAINING_RECORD(
                                pListEntry,
                                SMBCEDB_SESSION_ENTRY,
                                SerializationList);

        pListEntry = pListEntry->Flink;

        if (SmbCeAreServerEntriesAliased(
                pSessionEntry->pServerEntry,
                pTempSessionEntry->pServerEntry)) {

            RemoveEntryList(&pTempSessionEntry->SerializationList);
            InitializeListHead(&pTempSessionEntry->SerializationList);

            if (pTempSessionEntry->pSerializationEvent != NULL) {
                KeSetEvent(
                    pTempSessionEntry->pSerializationEvent,
                    0,
                    FALSE);
            }
        }
    }
}

NTSTATUS
SmbCeReferenceSession(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the session associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReestablishSession;
    BOOLEAN  UnInitializeSecurityContext = FALSE;

    PMRX_V_NET_ROOT        pVNetRoot;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    pVNetRoot     = SmbCeGetExchangeVNetRoot(pExchange);
    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

    fReestablishSession = (pSessionEntry->Header.State == SMBCEDB_RECOVER) |
        BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    for (;;) {

        ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
        ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SERVER_INITIALIZED);
        ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);
        ASSERT(SmbCeIsResourceOwned());

        Status = STATUS_USER_SESSION_DELETED;

        if (pSessionEntry == NULL) {
            break;
        }

        switch (pSessionEntry->Header.State) {
        case SMBCEDB_ACTIVE:
            Status = STATUS_SUCCESS;
            break;

        case SMBCEDB_INVALID:
            if (!fReestablishSession) {
                break;
            }

            pSessionEntry->Session.UserId = 0;
            // fall thru ...

        case SMBCEDB_RECOVER:
            UnInitializeSecurityContext = TRUE;

            if (pSessionEntry->Header.State == SMBCEDB_RECOVER) {
                ASSERT(pSessionEntry->SessionRecoverInProgress == FALSE);
                pSessionEntry->SessionRecoverInProgress = TRUE;
                RxLog(("Mark Sess Rec %lx\n",pSessionEntry));
            }

            if (pSessionEntry->Session.Type == EXTENDED_NT_SESSION){
                pSessionEntry->Header.State = SMBCEDB_START_CONSTRUCTION;

                if (pExchange->Type != EXTENDED_SESSION_SETUP_EXCHANGE) {
                    break;
                }
            }

            RxDbgTrace( 0, Dbg, ("SmbCeReferenceSession: Reestablishing session\n"));
            // fall thru ...

        case SMBCEDB_START_CONSTRUCTION:
            if (pSessionEntry->Session.Type != EXTENDED_NT_SESSION ||
                pExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) {

                RxDbgTrace( 0, Dbg, ("SmbCeReferenceSession: Reestablishing session\n"));

                ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);
                pExchange->SmbCeFlags |= SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
                pSessionEntry->pExchange = pExchange;
                pSessionEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
                SmbCeSerializeSessionSetupRequests(
                    pSessionEntry);
                Status = STATUS_SUCCESS;

                if (pExchange->Type == EXTENDED_SESSION_SETUP_EXCHANGE) {
                    PSMB_EXTENDED_SESSION_SETUP_EXCHANGE pExtSSExchange;

                    pExtSSExchange = (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pExchange;
                    pExtSSExchange->FirstSessionSetup = TRUE;
                }

                break;
            }
            // fall thru ...

        case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
            if (fReestablishSession) {
                // The construction of the session is already in progress ....
                // Queue up the request to resume this exchange when the session
                // construction is complete.

                PSMBCEDB_REQUEST_ENTRY pRequestEntry;

                ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);

                pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                                 SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

                if (pRequestEntry != NULL) {
                    pRequestEntry->Request.pExchange = pExchange;

                    SmbCeIncrementPendingLocalOperations(pExchange);
                    SmbCeAddRequestEntry(&pSessionEntry->Requests,pRequestEntry);

                    Status = STATUS_PENDING;
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                fReestablishSession = FALSE;
            }
            break;

        case SMBCEDB_MARKED_FOR_DELETION:
            Status = STATUS_USER_SESSION_DELETED;
            break;

        default:
            ASSERT(!"Valid Session State, SmbCe database corrupt");
            Status = STATUS_USER_SESSION_DELETED;
        }

        if (fReestablishSession &&
            (pSessionEntry->Session.Type == EXTENDED_NT_SESSION) &&
            (pExchange->Type != EXTENDED_SESSION_SETUP_EXCHANGE) &&
            (pSessionEntry->Header.State == SMBCEDB_START_CONSTRUCTION)) {
            // Reestablishing a NT50 session cannot be compounded currently. Therefor
            // this exchange is suspended till we can reestablish the session. Therefore
            PSMB_EXCHANGE pSessionSetupExchange;
            SMBCE_RESUMPTION_CONTEXT ExchangeResumptionContext;

            RxDbgTrace(0 , Dbg, ("Reestablishing an Extended session %lx\n",pSessionEntry));

            pSessionSetupExchange = SmbMmAllocateExchange(EXTENDED_SESSION_SETUP_EXCHANGE,NULL);

            SmbCeReleaseResource();

            ExchangeResumptionContext.SecuritySignatureReturned = FALSE;

            if (pSessionSetupExchange != NULL) {
                UninitializeSecurityContextsForSession(&pSessionEntry->Session);
                SmbCeInitializeResumptionContext(&ExchangeResumptionContext);

                Status = SmbCeInitializeExtendedSessionSetupExchange(
                                     &pSessionSetupExchange,
                                     pExchange->SmbCeContext.pVNetRoot);

                if (Status == STATUS_SUCCESS) {
                    // Attempt to reconnect( In this case it amounts to establishing the
                    // connection/session)
                    pSessionSetupExchange->SmbCeFlags |= SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
                    pSessionSetupExchange->RxContext = pExchange->RxContext;

                    ((PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pSessionSetupExchange)->pResumptionContext
                        = &ExchangeResumptionContext;

                    Status = SmbCeInitiateExchange(pSessionSetupExchange);

                    if (Status == STATUS_PENDING) {
                        SmbCeSuspend(&ExchangeResumptionContext);
                        Status = ExchangeResumptionContext.Status;
                    } else {
                        SmbCeDiscardExtendedSessionSetupExchange(
                            (PSMB_EXTENDED_SESSION_SETUP_EXCHANGE)pSessionSetupExchange);
                    }
                } else {
                    SmbMmFreeExchange(pSessionSetupExchange);
                }

                RxDbgTrace(0, Dbg, ("Reestablishing a NT50 Session %lx returning STATUS %lx\n",pSessionEntry,Status));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            SmbCeReferenceSessionEntry(pSessionEntry);

            ASSERT(Status != STATUS_SUCCESS ||
                   pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS);

            pVNetRoot->ConstructionStatus = Status;

            SmbCeCompleteSessionEntryInitialization(
                pSessionEntry,
                Status,
                ExchangeResumptionContext.SecuritySignatureReturned);

            SmbCeAcquireResource();

            if (Status != STATUS_RETRY) {
                break;
            }
        } else {
            if (UnInitializeSecurityContext) {
                SmbCeReleaseResource();
                UninitializeSecurityContextsForSession(&pSessionEntry->Session);
                SmbCeAcquireResource();
            }

            break;
        }
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SESSION_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());
    //ASSERT(Status != STATUS_USER_SESSION_DELETED);

    return Status;
}

NTSTATUS
SmbCeReferenceNetRoot(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the net root associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReconnectNetRoot;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pExchange->SmbCeContext.pVNetRoot);

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SESSION_INITIALIZED);
    ASSERT(SmbCeIsResourceOwned());

    Status            = STATUS_CONNECTION_DISCONNECTED;
    fReconnectNetRoot = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    switch (pVNetRootContext->Header.State) {
    case SMBCEDB_ACTIVE:
        ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
        ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_INVALID:
        RxDbgTrace( 0, Dbg, ("SmbCeReferenceNetRoot: Reestablishing net root\n"));
        if (!fReconnectNetRoot) {
            break;
        }
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        pVNetRootContext->TreeId = 0;
        // fall thru

    case SMBCEDB_START_CONSTRUCTION:
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
        pVNetRootContext->pExchange = pExchange;
        pVNetRootContext->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
        if (fReconnectNetRoot) {
            // The construction of the net root is already in progress ....
            // Queue up the request to resume this exchange when the session
            // construction is complete.
            PSMBCEDB_REQUEST_ENTRY pRequestEntry;

            pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                             SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

            if (pRequestEntry != NULL) {
                pRequestEntry->Request.pExchange = pExchange;

                SmbCeIncrementPendingLocalOperations(pExchange);
                SmbCeAddRequestEntry(&pVNetRootContext->Requests,pRequestEntry);

                Status = STATUS_PENDING;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SMBCEDB_MARKED_FOR_DELETION:
        break;

    default:
        ASSERT(!"Valid NetRoot State, SmbCe database corrupt");
        break;
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;
    }

    ASSERT(SmbCeIsResourceOwned());

    return Status;
}

NTSTATUS
SmbCeInitiateExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine inititaes a exchange.

Arguments:

    pExchange  - the exchange to be initiated.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PKEVENT                 pSmbCeSynchronizationEvent;

    PAGED_CODE();

    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    ASSERT(pServerEntry != NULL);
    ASSERT(!FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    switch (SmbCeGetServerType(pServerEntry)) {
    case SMBCEDB_FILE_SERVER:
        // If this is a mailslot write, then don't abort......
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MAILSLOT_OPERATION) {
            break;
        }
        // Admin exchanges do not have these fields filled in. All the three
        // entries must be valid for all other exchanges.
        if ((pExchange->NodeTypeCode != SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)) &&
            ((pNetRootEntry == NULL) ||
             (pSessionEntry == NULL))) {
            Status = STATUS_REQUEST_ABORTED;
            break;
        }
    case SMBCEDB_MAILSLOT_SERVER:
        break;
    default:
        // Prepare for aborting the request if either the server type is invalid
        // or if the netroot entry or the session entry is invalid.
        Status = STATUS_REQUEST_ABORTED;
    }

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx Status %lx\n",pExchange,Status));
        return Status;
    }

    pSmbCeSynchronizationEvent = pExchange->pSmbCeSynchronizationEvent;
    if (pSmbCeSynchronizationEvent != NULL) {
        KeInitializeEvent(
            pSmbCeSynchronizationEvent,
            SynchronizationEvent,
            FALSE);
    }

    for (;;) {
        SmbCeAcquireResource();

        switch (pExchange->SmbCeState) {
        case SMBCE_EXCHANGE_INITIALIZATION_START:
            {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                Status = SmbCeReferenceServer(pExchange);
                if (Status != STATUS_SUCCESS) {
                    // this covers the case when the SERVER_ENTRY is under construction
                    // and RxStatus(PENDING) is returned.
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceServer returned %lx\n",Status));
                    break;
                }
            }
            // fall through

        case SMBCE_EXCHANGE_SERVER_INITIALIZED:
            if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MAILSLOT_OPERATION) {
                // Mailslot servers do not have any netroot/session associated with them.
                pExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
                Status                = STATUS_SUCCESS;
                break;
            } else {
                if (pSessionEntry->SessionRecoverInProgress ||
                    pServerEntry->SecuritySignaturesEnabled &&
                    !pServerEntry->SecuritySignaturesActive) {
                    // if security signature is enabled and not yet turned on, exchange should wait for
                    // outstanding extended session setup to finish before resume in order to avoid index mismatch.
                    RxLog(("Sync for Sess %lx\n",pExchange));
                    Status = SmbCeSyncExchangeForSecuritySignature(pExchange);
                }

                if (Status == STATUS_SUCCESS) {
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                    Status = SmbCeReferenceSession(pExchange);
                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceSession returned %lx\n",Status));
                        break;
                    } if ((Status == STATUS_PENDING) &&
                          !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR)) {
                        break;
                    }
                } else {
                    break;
                }
            }
            // fall through

        case SMBCE_EXCHANGE_SESSION_INITIALIZED:
            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
            if (pExchange->Type != EXTENDED_SESSION_SETUP_EXCHANGE) {
                Status = SmbCeReferenceNetRoot(pExchange);
                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceNetRoot returned %lx\n",Status));
                    break;
                } else if ((Status == STATUS_PENDING) &&
                           !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
                    break;
                }
            }
            // else fall through

        case SMBCE_EXCHANGE_NETROOT_INITIALIZED:
            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));

            if (pServerEntry->SecuritySignaturesEnabled &&
                !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
                Status = SmbCeAllocateBufferForServerResponse(pExchange);
                if (Status != STATUS_SUCCESS) {
                    // this covers the case when the buffer for server response cannot be allocated
                    // and RxStatus(PENDING) is returned.
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeAllocateBufferForServerResponse returned %lx\n",Status));
                    break;
                }
            }

            // else fall throungh

        case SMBCE_EXCHANGE_SECURITYBUFFER_INITIALIZED:
            {
                PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

                pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

                // Exchange should have timeout flag set unless this is a pipe operation
                // or the SMBCE_ECXCHANGE_INDEFINITE_DELAY_IN_RESPONSE flag is set
                if(((pNetRootEntry == NULL) || (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_PIPE)) &&
                   !BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE)) {
                    pExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;
                }

                pExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
                Status                = STATUS_SUCCESS;
            }
            break;

        default:
            ASSERT(!"Valid State for a SMB exchange, exchange Initiation aborted");
            break;
        }

        SmbCeReleaseResource();

        if ((pSmbCeSynchronizationEvent != NULL)     &&
            (pExchange->SmbCeState != SMBCE_EXCHANGE_INITIATED) &&
            (Status == STATUS_PENDING)) {

            KeWaitForSingleObject(
                pSmbCeSynchronizationEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL );

            ASSERT(pExchange->Status != RX_MAP_STATUS(PENDING));
            Status = pExchange->Status;
            if (Status != RX_MAP_STATUS(SUCCESS)) {
                break;
            }
        } else {
            break;
        }
    }

    ASSERT((Status != STATUS_PENDING) ||
           (pSmbCeSynchronizationEvent == NULL));

    RxDbgTrace(0,Dbg,("Exchange (%lx) Type (%lx) State(%lx) Status %lx \n",pExchange,pExchange->Type,pExchange->SmbCeState,Status));
    RxDbgTrace(0,Dbg,
        ("ServerEntry(%lx) SessionEntry(%lx) NetRootEntry(%lx) \n",
        pServerEntry,
        pSessionEntry,
        pNetRootEntry));

    // Note: Once the exchange has been initiated no further reference of the exchange
    // can be done since the state of the exchange is non-deterministic, i.e., depends upon
    // the scheduler.
    if (Status == STATUS_SUCCESS) {
        BOOLEAN ResourceReleased = FALSE;

        // Start the exchange
        ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED);

        SmbCeAcquireResource();

        if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) ||
            (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)) ||
            (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION))) {
            Status = SmbCeInitializeExchangeTransport(pExchange);
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        if (Status == STATUS_SUCCESS) {
            if (pExchange->RxContext != NULL) {
                PMRXSMB_RX_CONTEXT pMRxSmbContext;

                // Set up the cancellation routine ..

                pMRxSmbContext = MRxSmbGetMinirdrContext(pExchange->RxContext);
                pMRxSmbContext->pCancelContext = pExchange;

                Status = RxSetMinirdrCancelRoutine(
                             pExchange->RxContext,
                             SmbCeCancelExchange);
            }

            if (Status == STATUS_SUCCESS) {
                if (!IsListEmpty(&pExchange->ExchangeList)) {
                    RemoveEntryList(&pExchange->ExchangeList);
                }

                InsertTailList(
                    &pServerEntry->ActiveExchanges,
                    &pExchange->ExchangeList);

                SmbCeReleaseResource();
                ResourceReleased = TRUE;

                pExchange->SmbStatus = STATUS_SUCCESS;
                pExchange->ServerVersion = pServerEntry->Server.Version;
                Status = SMB_EXCHANGE_DISPATCH(pExchange,Start,((PSMB_EXCHANGE)pExchange));
            }

            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SMB_EXCHANGE_DISPATCH(Start) returned %lx\n",Status));
        }

        if (!ResourceReleased) {
            SmbCeReleaseResource();
        }
    } else if (Status != STATUS_PENDING) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange(%lx) Initiation failed %lx \n",pExchange,Status));
    }

    return Status;
}

NTSTATUS
SmbCeInitiateAssociatedExchange(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       EnableCompletionHandlerInMasterExchange)
/*++

Routine Description:

   This routine inititaes an associated exchange.

Arguments:

    pExchange  - the exchange to be initiated.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PSMB_EXCHANGE           pMasterExchange;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PAGED_CODE();

    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED);
    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    pMasterExchange = pExchange->Associated.pMasterExchange;
    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    ASSERT(pServerEntry != NULL);

    // Note: Once the exchange has been initiated no further reference of the exchange
    // can be done since the state of the exchange is non-deterministic, i.e., depends upon
    // the scheduler.

    Status = SmbCeInitializeExchangeTransport(pExchange);

    SmbCeAcquireResource();

    if (!IsListEmpty(&pExchange->ExchangeList)) {
        RemoveEntryList(&pExchange->ExchangeList);
    }

    InsertTailList(
        &pServerEntry->ActiveExchanges,
        &pExchange->ExchangeList);

    if (EnableCompletionHandlerInMasterExchange) {
        ASSERT(!FlagOn(
                    pMasterExchange->SmbCeFlags,
                    SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED));
        SetFlag(
            pMasterExchange->SmbCeFlags,
            SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED);
    }

    pExchange->SmbStatus = STATUS_SUCCESS;
    pExchange->ServerVersion = pServerEntry->Server.Version;

    SmbCeReleaseResource();

    if (Status == STATUS_SUCCESS) {
        Status = SMB_EXCHANGE_DISPATCH(pExchange,Start,((PSMB_EXCHANGE)pExchange));
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SMB_EXCHANGE_DISPATCH(Start) returned %lx\n",Status));
    } else {
        SmbCeFinalizeExchange(pExchange);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
SmbCeExchangeAbort(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine aborts an exchange.

Arguments:

    pExchange  - the exchange to be aborted.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeExchangeAbort: Exchange %lx aborted\n",pExchange));
    SmbCeDiscardExchange(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE     pExchange,
    IN OUT PVOID             pBuffer,
    IN     ULONG             BufferLength,
    OUT    PULONG            pBufferConsumed,
    OUT    PUCHAR            pLastCommandInHeader,
    OUT    PUCHAR            *pNextCommandPtr)
/*++

Routine Description:

   This routine constructs the SMB header associated with any SMB sent as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pBuffer    - the buffer in whihc the SMB header is to be constructed

    BufferLength - length of the buffer

    pBufferConsumed - the buffer consumed

    pLastCommandInHeader - the last command in header, SMB_COM_NO_ANDX_COMMAND if none

    pNextCommandPtr - the ptr to the place in the buffer where the next command
                      code should be copied.


Return Value:

    STATUS_SUCCESS  - if the header construction was successful

Notes:

    This routine is called to build the SMB header. This centralization allows us to
    compound the SMB operation with other SMB's required for the maintenance of the
    SMB connection engine data structures. It also provides us with a centralized facility
    for profiling SMB's as well as a one place mechanism for filling in all the header
    fields associated with a SMB.

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_HEADER   pSmbHeader = (PSMB_HEADER)pBuffer;
    PGENERIC_ANDX pSmbBuffer;
    ULONG         SmbBufferUnconsumed = BufferLength;
    PUCHAR        pSmbCommand;
    PRX_CONTEXT   RxContext;

    UCHAR         LastCommandInHeader = SMB_COM_NO_ANDX_COMMAND;
    UCHAR         Flags = SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;
    USHORT        Flags2 = 0;

    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    PSMBCE_SERVER         pServer;

    PAGED_CODE();

    if (BufferLength < sizeof(SMB_HEADER)) {
        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: BufferLength too small %d\n",BufferLength));
        ASSERT(!"Buffer too small");
        return STATUS_BUFFER_TOO_SMALL;
    }

    SmbBufferUnconsumed = BufferLength - sizeof(SMB_HEADER);

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);

    pServer = SmbCeGetExchangeServer(pExchange);

    RxContext = pExchange->RxContext;

    if (pServer->Dialect == NTLANMAN_DIALECT) {

        if (FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
            Flags2 |= (SMB_FLAGS2_KNOWS_EAS | SMB_FLAGS2_EXTENDED_SECURITY);

            if ((pSessionEntry != NULL) &&
                (FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) ||
                 MRxSmbUseKernelModeSecurity)) {
                Flags2 &= ~SMB_FLAGS2_EXTENDED_SECURITY;
            }
        }

        if (FlagOn(pServer->DialectFlags,DF_NT_STATUS)) {
            Flags2 |= SMB_FLAGS2_NT_STATUS;
        }

        if( RxContext &&
            (RxContext->pFcb) &&
            (RxContext->pFcb->FcbState & FCB_STATE_SPECIAL_PATH) )
        {
            Flags2 |= SMB_FLAGS2_REPARSE_PATH;
        }
    }

    if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
        if (FlagOn(pServer->DialectFlags,DF_UNICODE)) {
            Flags2 |= SMB_FLAGS2_UNICODE;
        }
    }

    if (FlagOn(pServer->DialectFlags,DF_LONGNAME)) {
        Flags2 |= SMB_FLAGS2_KNOWS_LONG_NAMES;
    }

    if (FlagOn(pServer->DialectFlags,DF_SUPPORTEA)) {
        Flags2 |= SMB_FLAGS2_KNOWS_EAS;
    }

    if (MRxSmbSecuritySignaturesEnabled) {
        Flags2 |= SMB_FLAGS2_SMB_SECURITY_SIGNATURE;
    }

    //DOWNLEVEL.NOTCORE flags for lanman10

    RtlZeroMemory(pSmbHeader,sizeof(SMB_HEADER));

    *((PULONG)&pSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    pSmbHeader->Flags      = Flags;
    pSmbHeader->Flags2     = Flags2;
    pSmbHeader->Pid        = MRXSMB_PROCESS_ID;
    pSmbHeader->Uid        = 0;
    pSmbHeader->Tid        = 0;
    pSmbHeader->ErrorClass = 0;
    pSmbHeader->Reserved   = 0;
    pSmbCommand            = &pSmbHeader->Command;
    SmbPutUshort(&pSmbHeader->Error,0);

    switch (SmbCeGetServerType(pServerEntry)) {
    case SMBCEDB_MAILSLOT_SERVER :
        break;

    case SMBCEDB_FILE_SERVER:
        {
            BOOLEAN fValidTid;

            if (pSessionEntry != NULL) {
                pSmbHeader->Uid = pSessionEntry->Session.UserId;
            }

            if (pExchange->SmbCeContext.pVNetRoot != NULL) {
                PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

                pVNetRootContext = SmbCeGetAssociatedVNetRootContext(
                                       pExchange->SmbCeContext.pVNetRoot);

                fValidTid = BooleanFlagOn(
                                pVNetRootContext->Flags,
                                SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                pSmbHeader->Tid = pVNetRootContext->TreeId;
            } else {
                fValidTid = TRUE;
            }

            pSmbBuffer = (PGENERIC_ANDX)(pSmbHeader + 1);

            if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) ||
                (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
                // There is an oppurtunity to compound some SessionSetup/TreeConnect SMB with the
                // given SMB command.
                if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
                    (pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS)) {
                    if (( pServer->DialectFlags & DF_EXTENDNEGOT) ||
                        ( pServer->DialectFlags & DF_NTNEGOTIATE)) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Session setup And X\n"));

                        *pSmbCommand = SMB_COM_SESSION_SETUP_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                        pSmbCommand = &pSmbBuffer->AndXCommand;
                        pSmbHeader->Tid = 0;

                        Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                     pServer,
                                     BuildSessionSetup,
                                     (pExchange,
                                      pSmbBuffer,
                                      &SmbBufferUnconsumed));
                        if (NT_SUCCESS(Status)) {
                            // Update the buffer for the construction of the following SMB.
                            SmbPutUshort(
                                &pSmbBuffer->AndXOffset,
                                (USHORT)(BufferLength - SmbBufferUnconsumed));
                            pSmbBuffer = (PGENERIC_ANDX)((PBYTE)pBuffer + BufferLength - SmbBufferUnconsumed);

                            if (pServerEntry->SecuritySignaturesEnabled &&
                                !pServerEntry->SecuritySignaturesActive) {
                                RtlCopyMemory(pSmbHeader->SecuritySignature,InitialSecuritySignature,SMB_SECURITY_SIGNATURE_LENGTH);
                            }
                        }
                    }
                } else {
                    NOTHING; //no sess for share level AT LEAST NOT FOR CORE!!!
                }

                if (NT_SUCCESS(Status) &&
                    (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) &&
                    !fValidTid) {
                    BOOLEAN BuildingTreeConnectAndX = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN10);
                    //CODE.IMPROVEMENT this is not wholly satisfactory....we have encapsulated which smb we're building
                    //        in the dialect dispatch vector and yet we're setting the smb externally.
                    if (BuildingTreeConnectAndX) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect And X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                    } else {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect No X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT;
                        LastCommandInHeader = *pSmbCommand;
                    }

                    Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                 pServer,
                                 BuildTreeConnect,
                                 (pExchange,
                                  pSmbBuffer,
                                  &SmbBufferUnconsumed));

                    if (NT_SUCCESS(Status)) {
                        // Update the buffer for the construction of the following SMB.
                        if (BuildingTreeConnectAndX) {
                            pSmbCommand = &pSmbBuffer->AndXCommand;
                            SmbPutUshort(&pSmbBuffer->AndXOffset,(USHORT)(BufferLength - SmbBufferUnconsumed));
                        } else {
                            pSmbCommand = NULL;
                        }
                    }
                }
            }
        }
        break;

    default:
        {
            ASSERT(!"Valid Server Type");
            Status = STATUS_INVALID_HANDLE;
        }
        break;
    }

    *pNextCommandPtr      = pSmbCommand;
    *pBufferConsumed      = BufferLength - SmbBufferUnconsumed;
    *pLastCommandInHeader = LastCommandInHeader;

    RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Buffer Consumed %lx\n",*pBufferConsumed));

    if (Status != STATUS_SUCCESS) {
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) {
            pExchange->SessionSetupStatus = Status;
        }

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) {
            PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

            pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

            SmbCeUpdateVNetRootContextState(
                pVNetRootContext,
                SMBCEDB_INVALID);
        }
    }

    return Status;
}

typedef struct __Service_Name_Entry {
    NET_ROOT_TYPE NetRootType;
    USHORT NameLength;
    PBYTE  Name;
};
struct __Service_Name_Entry ServiceNameTable[] = {
    {NET_ROOT_DISK,sizeof(SHARE_TYPE_NAME_DISK),SHARE_TYPE_NAME_DISK},
    {NET_ROOT_PIPE,sizeof(SHARE_TYPE_NAME_PIPE),SHARE_TYPE_NAME_PIPE},
    {NET_ROOT_PRINT,sizeof(SHARE_TYPE_NAME_PRINT),SHARE_TYPE_NAME_PRINT},
    {NET_ROOT_COMM,sizeof(SHARE_TYPE_NAME_COMM),SHARE_TYPE_NAME_COMM}  //COMM must be last
    };

UNICODE_STRING FileSystem_NTFS_UNICODE = {8,8,L"NTFS"};
UNICODE_STRING FileSystem_FAT_UNICODE = {6,6,L"FAT"};
CHAR FileSystem_NTFS[] = "NTFS";
CHAR FileSystem_FAT[] = "FAT";

NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed)
/*++

Routine Description:

   This routine validates the SMB header associated with any SMB received as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pSmbHeader - the header of the SMB received

    pCommandToProcess - the SMB command to be processed after the header ( Can be NULL )

    pSmbResponseStatus - the status in the SMB response header (Can be NULL)

    BytesAvailable - the bytes available for processing but not necesarily indicated.

    BytesIndicated - the length of the SMB buffer avcailable for perusal

    pBytesConsumed - the buffer consumed

Return Value:

    RXSTATUS - The return status for the operation
          STATUS_MORE_PROCESSING_REQUIRED -- if a copy of the data needs to be done before
          processing can be completed. This occurs because sufficient data was not
          indicated to process the header.
          STATUS_SUCCESS -- the header was processed succesfully. In such cases the GENERIC_ANDX
          if not NULL will contain the offset from the start of the buffer and the command
          to be processed.
          STATUS_* -- They indicate an error which would normally lead to the abortion of the
          exchange.

Notes:

    This routine is called to parse the SMB header. This centralization allows us to
    implement a one stop mechanism for updateing/validating the header fields as well as
    resuming the exchanges waiting for the construction of session/net root entry
    associated with this exchange

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SmbResponseStatus;

    PBYTE    pSmbBuffer = (PBYTE)pSmbHeader;
    UCHAR    SmbCommand;

    BOOLEAN  fUpdateVNetRootContext  = FALSE;

    SMBCEDB_OBJECT_STATE SessionState;
    SMBCEDB_OBJECT_STATE NetRootState;

    PMRX_V_NET_ROOT           pVNetRoot;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    pVNetRoot     = SmbCeGetExchangeVNetRoot(pExchange);
    pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

    pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

    // Return Immediately if bytes indicated is less then the size of a SMB header.
    if (BytesIndicated < sizeof(SMB_HEADER)) {
        *pBytesConsumed = BytesIndicated;
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    SmbResponseStatus = GetSmbResponseNtStatus(pSmbHeader,pExchange);

    if (!NT_SUCCESS(SmbResponseStatus)) {
        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::SMB Response Error %lx\n",SmbResponseStatus));
    }

    SmbCommand      = pSmbHeader->Command;
    *pBytesConsumed = sizeof(SMB_HEADER);
    pSmbBuffer     += *pBytesConsumed;

    if (SmbResponseStatus == STATUS_NETWORK_SESSION_EXPIRED) {
        // if the session has been timed out on the server, establish the session and retry the operation
        SmbResponseStatus = STATUS_RETRY;
        InterlockedCompareExchange(&(pSessionEntry->Header.State),
                                   SMBCEDB_RECOVER,
                                   SMBCEDB_ACTIVE);

        //DbgPrint("Session timed out on request %x\n", SmbCommand);
    }

    // There are certain SMB's that effect the connection engine data structures as
    // well as the exchange that has been suspended. These are the SMB's used for tree
    // connect and session setup.
    // In all the other cases no special action is required for the maintenance of the
    // connection engine data structures. The Exchange that was suspended needs to be
    // resumed.
    if (SmbCommand == SMB_COM_SESSION_SETUP_ANDX) {
        if (SmbResponseStatus != RX_MAP_STATUS(SUCCESS)) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }

                pExchange->SessionSetupStatus = SmbResponseStatus;
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == STATUS_SUCCESS) &&
            (FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            PRESP_SESSION_SETUP_ANDX pSessionSetupResponse;
            ULONG                    SessionSetupResponseLength,ByteCount;

            RxDbgTrace( 0, Dbg, ("Processing Session Setup ANd X\n"));
            pSessionSetupResponse = (PRESP_SESSION_SETUP_ANDX)(pSmbBuffer);

            ByteCount = SmbGetUshort(&pSessionSetupResponse->ByteCount);
            if (pSessionSetupResponse->WordCount == 3) {
                SmbCommand = pSessionSetupResponse->AndXCommand;
                if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                    SessionSetupResponseLength =
                        FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + ByteCount;
                    Status = SmbResponseStatus;
                } else {
                    SessionSetupResponseLength =
                        SmbGetUshort(&pSessionSetupResponse->AndXOffset) - *pBytesConsumed;
                }

                //if (ByteCount == 0) {
                //    //bytecount==0 and NTDIALECT means that this is really w95...change the flags
                //    PSMBCE_SERVER pServer   = &pExchange->SmbCeContext.pServerEntry->Server;
                //    if (FlagOn(pServer->DialectFlags,DF_NTPROTOCOL)) {
                //        pServer->DialectFlags &= ~(DF_MIXEDCASEPW);
                //        pServer->DialectFlags |= DF_W95;
                //    }
                //}
            } else {
                // NT session setup is handled by another routine.
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            if (NT_SUCCESS(Status)) {
                if (SessionSetupResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += SessionSetupResponseLength;
                    pSmbBuffer += SessionSetupResponseLength;
                    pSessionEntry->Session.UserId = pSmbHeader->Uid;

                    if (FlagOn(SmbGetUshort(&pSessionSetupResponse->Action), SMB_SETUP_USE_LANMAN_KEY)) {
                        pSessionEntry->Session.Flags |=
                            SMBCE_SESSION_FLAGS_LANMAN_SESSION_KEY_USED;
                    }

                    if (FlagOn(SmbGetUshort(&pSessionSetupResponse->Action), SMB_SETUP_GUEST)) {
                        pSessionEntry->Session.Flags |=
                            SMBCE_SESSION_FLAGS_GUEST_SESSION;
                    }

                    if (pServerEntry->SecuritySignaturesEnabled &&
                        !pServerEntry->SecuritySignaturesActive &&
                        RtlCompareMemory(pSmbHeader->SecuritySignature,
                                         InitialSecuritySignature,
                                         SMB_SECURITY_SIGNATURE_LENGTH) != SMB_SECURITY_SIGNATURE_LENGTH) {
                        pExchange->SecuritySignatureReturned = TRUE;
                    }

                    InterlockedIncrement(&MRxSmbStatistics.Sessions);
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Session setup and X Response %lx\n",Status));
                pExchange->SessionSetupStatus = Status;

                InterlockedIncrement(&MRxSmbStatistics.FailedSessions);

                if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) ||
                    (SmbCommand == SMB_COM_TREE_CONNECT)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: Tearing down a tree connection\n"));
                    fUpdateVNetRootContext = TRUE;
                    NetRootState = SMBCEDB_INVALID;
                }
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) &&
        NT_SUCCESS(Status)) {
        if (SmbResponseStatus != RX_MAP_STATUS(SUCCESS)) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }

                fUpdateVNetRootContext  = TRUE;
                NetRootState          = SMBCEDB_INVALID;
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == RX_MAP_STATUS(SUCCESS)) &&
            (FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == RX_MAP_STATUS(SUCCESS)) {
            USHORT ResponseWordCount;
            ULONG TreeConnectResponseLength,TreeConnectByteCount,ServiceStringLength;
            PUCHAR pShareTypeResponseString = NULL;
            PRESP_21_TREE_CONNECT_ANDX p21TreeConnectAndXResponse;
            PUCHAR NativeFileSystem = NULL;

            p21TreeConnectAndXResponse = (PRESP_21_TREE_CONNECT_ANDX)(pSmbBuffer);
            SmbCommand = p21TreeConnectAndXResponse->AndXCommand;
            TreeConnectByteCount = 0;

            RxDbgTrace( 0, Dbg, ("Processing Tree Connect and X\n"));

            // case out based on the actual response length. Lanman 21 clients or NT clients
            // have a longer response.....win95 negotiates NT dialect but uses a <lm21 response format
            ResponseWordCount = p21TreeConnectAndXResponse->WordCount;

            switch (ResponseWordCount) {
            case 0:
                Status = SmbResponseStatus;
                break;

            case 3:
            case 7:
                {
                    PRESP_EXTENDED_TREE_CONNECT_ANDX pExtendedTreeConnectAndXResponse;

                    if (ResponseWordCount == 7) {
                        pExtendedTreeConnectAndXResponse = (PRESP_EXTENDED_TREE_CONNECT_ANDX)(pSmbBuffer);

                        pNetRootEntry->MaximalAccessRights =
                            SmbGetUlong(
                                &pExtendedTreeConnectAndXResponse->MaximalShareAccessRights);

                        pNetRootEntry->GuestMaximalAccessRights =
                            SmbGetUlong(
                                &pExtendedTreeConnectAndXResponse->GuestMaximalShareAccessRights);

                        ASSERT(FIELD_OFFSET(RESP_EXTENDED_TREE_CONNECT_ANDX,AndXCommand)
                               ==FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,AndXCommand));

                        pShareTypeResponseString = (PUCHAR)&pExtendedTreeConnectAndXResponse->Buffer;
                        TreeConnectByteCount  = SmbGetUshort(&pExtendedTreeConnectAndXResponse->ByteCount);
                        TreeConnectResponseLength =
                            FIELD_OFFSET(RESP_EXTENDED_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                        pNetRootEntry->NetRoot.ChunkShift = 0xC;
                        pNetRootEntry->NetRoot.ChunkSize  =
                            (1 << pNetRootEntry->NetRoot.ChunkShift);
                        pNetRootEntry->NetRoot.ClusterShift = 0x9;
                        pNetRootEntry->NetRoot.CompressionUnitShift = 0xD;
                        pNetRootEntry->NetRoot.CompressionFormatAndEngine =
                            COMPRESSION_FORMAT_LZNT1;

                        NativeFileSystem = &pExtendedTreeConnectAndXResponse->Buffer[3];
                    } else {
                        pNetRootEntry->MaximalAccessRights = FILE_ALL_ACCESS;
                        pNetRootEntry->GuestMaximalAccessRights = 0;

                        pShareTypeResponseString = (PUCHAR)&p21TreeConnectAndXResponse->Buffer;

                        TreeConnectByteCount  = SmbGetUshort(&p21TreeConnectAndXResponse->ByteCount);

                        TreeConnectResponseLength =
                            FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                        NativeFileSystem = &p21TreeConnectAndXResponse->Buffer[3];
                    }

                    pNetRootEntry->NetRoot.UpdateCscShareRights = TRUE;

                    // Parse and update the optional support bits returned by
                    // the server

                    if (pServerEntry->Server.Dialect >= NTLANMAN_DIALECT ) {
                        USHORT OptionalSupport;
                        PMRX_NET_ROOT pNetRoot = pVNetRoot->pNetRoot;

                        OptionalSupport = SmbGetUshort(
                                             &p21TreeConnectAndXResponse->OptionalSupport);

                        if (FlagOn(OptionalSupport,SMB_SHARE_IS_IN_DFS)) {
                            pNetRootEntry->NetRoot.DfsAware = TRUE;
                            SetFlag(pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT);
                        }

                        if (FlagOn(OptionalSupport,SMB_UNIQUE_FILE_NAME)) {
                            SetFlag(pNetRoot->Flags,NETROOT_FLAG_UNIQUE_FILE_NAME);
                        }

                        pNetRootEntry->NetRoot.CscFlags = (OptionalSupport & SMB_CSC_MASK);

                        switch (pNetRootEntry->NetRoot.CscFlags) {
                        case SMB_CSC_CACHE_AUTO_REINT:
                        case SMB_CSC_CACHE_VDO:
                            pNetRootEntry->NetRoot.CscEnabled = TRUE;
                            pNetRootEntry->NetRoot.CscShadowable = TRUE;
                            break;

                        case SMB_CSC_CACHE_MANUAL_REINT:
                            pNetRootEntry->NetRoot.CscEnabled    = TRUE;
                            pNetRootEntry->NetRoot.CscShadowable = FALSE;
                            break;

                        case SMB_CSC_NO_CACHING:
                            pNetRootEntry->NetRoot.CscEnabled = FALSE;
                            pNetRootEntry->NetRoot.CscShadowable = FALSE;
                        }
                    }

                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&p21TreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }
                }
                break;

            case 2:
                {
                    PRESP_TREE_CONNECT_ANDX pTreeConnectAndXResponse;

                    pTreeConnectAndXResponse = (PRESP_TREE_CONNECT_ANDX)(pSmbBuffer);

                    ASSERT(FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,AndXCommand)
                           ==FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,AndXCommand));

                    pShareTypeResponseString = (PUCHAR)&pTreeConnectAndXResponse->Buffer;
                    TreeConnectByteCount  = SmbGetUshort(&pTreeConnectAndXResponse->ByteCount);
                    TreeConnectResponseLength =
                        FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&pTreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }

                    // win9x server, returns wordcount of 2 yet has the dialect of NTLANMAN
                    // which is a bug, but we will work around it.
                    if (pServerEntry->Server.Dialect >= NTLANMAN_DIALECT ) {
                        pNetRootEntry->NetRoot.UpdateCscShareRights = TRUE;
                        pNetRootEntry->MaximalAccessRights = FILE_ALL_ACCESS;
                        pNetRootEntry->GuestMaximalAccessRights = 0;

                        // make it look like a MANUAL_REINT guy
                        pNetRootEntry->NetRoot.CscEnabled    = TRUE;
                        pNetRootEntry->NetRoot.CscShadowable = FALSE;
                    }

                }
                break;

            default :
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect and X Response %lx\n",Status));
            if (NT_SUCCESS(Status)) {
                PSMBCE_NET_ROOT psmbNetRoot = &(pNetRootEntry->NetRoot);
                PSMBCE_SERVER psmbServer = &(pServerEntry->Server);

                if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += TreeConnectResponseLength;

                    // Update the NetRoot fields based on the response.
                    SetFlag(
                        pVNetRootContext->Flags,
                        SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                    RtlCopyMemory(
                        &pVNetRootContext->TreeId,
                        &pSmbHeader->Tid,
                        sizeof(pSmbHeader->Tid));

                    {   struct __Service_Name_Entry *i;
                        for (i=ServiceNameTable;;i++) {
                            ServiceStringLength = i->NameLength;
                            if (TreeConnectByteCount >= ServiceStringLength) {
                                if (RtlCompareMemory(
                                        pShareTypeResponseString,
                                        i->Name,
                                        ServiceStringLength)
                                    == ServiceStringLength) {
                                    psmbNetRoot->NetRootType = i->NetRootType;
                                    if (FALSE) DbgPrint("FoundServiceStrng %s len %d type %d\n",i->Name,i->NameLength,i->NetRootType);
                                    break;
                                }
                            }

                            if (i->NetRootType==NET_ROOT_COMM) {
                                ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
                                psmbNetRoot->NetRootType = NET_ROOT_DISK;
                                ServiceStringLength = TreeConnectByteCount;
                                break;
                            }
                        }
                    }

                    if (psmbNetRoot->NetRootType == NET_ROOT_DISK) {
                        if (NativeFileSystem != NULL) {
                            if (BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                                if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_NTFS_UNICODE.Buffer,
                                        FileSystem_NTFS_UNICODE.Length)
                                    == FileSystem_NTFS_UNICODE.Length) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_NTFS;
                                } else if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_FAT_UNICODE.Buffer,
                                        FileSystem_FAT_UNICODE.Length)
                                    == FileSystem_FAT_UNICODE.Length) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_FAT;
                                }
                            } else {
                                if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_NTFS,
                                        4*sizeof(CHAR))
                                    == 4*sizeof(CHAR)) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_NTFS;
                                } else if (RtlCompareMemory(
                                        NativeFileSystem,
                                        FileSystem_FAT,
                                        3*sizeof(CHAR))
                                    == 3*sizeof(CHAR)) {
                                    psmbNetRoot->NetRootFileSystem = NET_ROOT_FILESYSTEM_FAT;
                                }
                            }
                        }

                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumDiskFileReadBufferSize;
                        psmbNetRoot->MaximumWriteBufferSize = psmbServer->MaximumDiskFileWriteBufferSize;
                    } else {
                        psmbNetRoot->MaximumWriteBufferSize = psmbServer->MaximumNonDiskFileWriteBufferSize;
                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumNonDiskFileReadBufferSize;
                    }

                    //if !(NT was negotiated) and bytecount>servicelength, we may have a NativeFs name
                    if (!FlagOn(psmbServer->DialectFlags,DF_NTNEGOTIATE)
                        && (TreeConnectByteCount>ServiceStringLength)) {
                        PBYTE NativeFs = pShareTypeResponseString+ServiceStringLength;
                        if (*NativeFs != 0) {
                            ULONG i;
                            ULONG maxlenpersmb = TreeConnectByteCount-ServiceStringLength;
                            ULONG maxlenperarraysize = SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL;
                            PCHAR p = (PCHAR)(&psmbNetRoot->FileSystemNameA[0]);  //dont write into the 0th char
                            //DbgPrint("we may have one...\n");
                            for (i=1;;i++){
                                if (i==maxlenpersmb) {
                                    break;
                                }
                                if (i==maxlenperarraysize) {
                                    break;
                                }
                                if (NativeFs[i]==0) {
                                    break;
                                }
                            }
                            //save away the name for processing later

                            RtlCopyMemory(p,NativeFs,i);
                            p[i] = 0;
                            //DbgPrint("NativeFs = %s (%d)\n",p,i);
                            psmbNetRoot->FileSystemNameALength = (UCHAR)i;
                        }
                    }

                    pSmbBuffer += TreeConnectResponseLength;
                    fUpdateVNetRootContext = TRUE;
                    NetRootState         = SMBCEDB_ACTIVE;
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                fUpdateVNetRootContext  = TRUE;
                NetRootState          = SMBCEDB_INVALID;
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT) &&
        NT_SUCCESS(Status)) {
        PRESP_TREE_CONNECT   pTreeConnectResponse;
        ULONG                TreeConnectResponseLength;

        RxDbgTrace( 0, Dbg, ("Processing Tree Connect\n"));
        pTreeConnectResponse      = (PRESP_TREE_CONNECT)pSmbBuffer;
        TreeConnectResponseLength = FIELD_OFFSET(RESP_TREE_CONNECT,Buffer);

        SmbCommand = SMB_COM_NO_ANDX_COMMAND;

        if (NT_SUCCESS(SmbResponseStatus)) {
            PSMBCE_NET_ROOT psmbNetRoot = &(pNetRootEntry->NetRoot);
            PSMBCE_SERVER psmbServer = &(pServerEntry->Server);

            if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                // Update the NetRoot fields based on the response.
                SetFlag(
                    pVNetRootContext->Flags,
                    SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

                RtlCopyMemory(
                    &pVNetRootContext->TreeId,
                    &pTreeConnectResponse->Tid,
                    sizeof(pTreeConnectResponse->Tid));

                if (psmbServer->Dialect == PCNET1_DIALECT) {
                    psmbNetRoot->NetRootType = NET_ROOT_DISK;
                }
                else {
                    psmbNetRoot->NetRootType = NET_ROOT_WILD;
                }

                if (psmbServer->MaximumBufferSize == 0){
                    ULONG MaxBuf = SmbGetUshort(&pTreeConnectResponse->MaxBufferSize);
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: setting srvmaxbufsize %ld\n", MaxBuf));
                    psmbServer->MaximumBufferSize = MaxBuf;
                    //psmbServer->MaximumDiskFileReadBufferSize =
                    psmbNetRoot->MaximumWriteBufferSize =
                    psmbNetRoot->MaximumReadBufferSize =
                                MaxBuf -
                                QuadAlign(
                                    sizeof(SMB_HEADER) +
                                    FIELD_OFFSET(
                                        RESP_READ,
                                        Buffer[0]));
                }

                *pBytesConsumed += TreeConnectResponseLength;

                pSmbBuffer += *pBytesConsumed;

                fUpdateVNetRootContext = TRUE;
                NetRootState         = SMBCEDB_ACTIVE;

                //for CORE, this counts as a successful session setup as well!
                pSessionEntry->Session.UserId = pSmbHeader->Uid;
            } else {
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            }
        } else {
            Status = SmbResponseStatus;
            fUpdateVNetRootContext  = TRUE;
            NetRootState          = SMBCEDB_MARKED_FOR_DELETION;
        }

        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect Response %lx\n",Status));
    }

    if ((SmbResponseStatus == STATUS_USER_SESSION_DELETED) ||
        (SmbResponseStatus == STATUS_NETWORK_NAME_DELETED)) {
        ClearFlag(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID);

        InterlockedCompareExchange(
            &(pVNetRootContext->Header.State),
            SMBCEDB_INVALID,
            SMBCEDB_ACTIVE);

        InterlockedCompareExchange(
            &(pSessionEntry->Header.State),
            SMBCEDB_INVALID,
            SMBCEDB_ACTIVE);

        fUpdateVNetRootContext  = TRUE;
        NetRootState            = SMBCEDB_INVALID;
    }

    // Initiate further action if the status of the exchange/conenction engine can be
    // updated based on the data available.

    if (fUpdateVNetRootContext) {
        PMRX_NET_ROOT pNetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            NetRootState);

        switch (NetRootState) {
        case SMBCEDB_ACTIVE:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
             break;
        case SMBCEDB_INVALID:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_DISCONNECTED;
             break;
        case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_RECONN;
             break;
        default:
             pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
             break;
        }

        RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));
    }

    if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
        !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
        if ((pSmbHeader->Uid != pSessionEntry->Session.UserId) ||
            (pSmbHeader->Tid != pVNetRootContext->TreeId)) {
            RxLog(("Srvr %lx Xchg %lx RUid %ld RTid %ld\n SUid %ld STid %ld\n",
                   pServerEntry,pExchange,
                   pSmbHeader->Uid,pSmbHeader->Tid,
                   pSessionEntry->Session.UserId,pVNetRootContext->TreeId));
            SmbLogError(STATUS_UNSUCCESSFUL,
                        LOG,
                        SmbCeParseSmbHeader,
                        LOGPTR(pServerEntry)
                        LOGPTR(pExchange)
                        LOGXSHORT(pSmbHeader->Uid)
                        LOGXSHORT(pSmbHeader->Tid)
                        LOGXSHORT(pSessionEntry->Session.UserId)
                        LOGXSHORT(pVNetRootContext->TreeId));
        }
    }

    pExchange->SmbStatus = SmbResponseStatus;     //N.B. no spinlock!
    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        *pBytesConsumed = 0;
    } else if (!NT_SUCCESS(Status)) {
        *pBytesConsumed = BytesAvailable;
    } else {
        if (pSmbResponseStatus != NULL) {
            *pSmbResponseStatus = SmbResponseStatus;
        }

        if (pCommandToProcess != NULL) {
            PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)((PBYTE)pSmbHeader + *pBytesConsumed);

            pCommandToProcess->AndXCommand = SmbCommand;
            SmbPutUshort(&pCommandToProcess->AndXOffset, (USHORT)*pBytesConsumed);

            if ((sizeof(GENERIC_ANDX) + *pBytesConsumed) <= BytesAvailable) {
                pCommandToProcess->WordCount   = pGenericAndX->WordCount;
            } else {
                pCommandToProcess->WordCount = 0;
            }
        }
    }

    return Status;
}

NTSTATUS
SmbCeResumeExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine resumes an exchange that was suspended in the connection
   engine

Arguments:

    pExchange - the exchange Instance

Return Value:

    The return status for the operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    SmbCeIncrementPendingLocalOperations(pExchange);

    // Initiate the exchange
    Status = SmbCeInitiateExchange(pExchange);

    SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

    return Status;
}

NTSTATUS
SmbCepInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PRX_CONTEXT                   pRxContext,
    PSMBCEDB_SERVER_ENTRY         pServerEntry,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine initializes the given exchange instanece

Arguments:

    pExchangePointer  - the placeholder for the exchange instance. If it is NULL a new one
    is allocated.

    pRxContext        - the associated RxContext

    pServerEntry      - the associated server entry

    pVirtualNetRoot   - the virtual net root

    Type              - the type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_EXCHANGE pExchange = NULL;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeInitializeExchange: Invoked\n"));

    if (*pExchangePointer == NULL) {
        // Allocate a new exchange instance.
        pExchange = SmbMmAllocateExchange(Type,NULL);
        if (pExchange == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        *pExchangePointer = pExchange;
    }

    if ((Status = SmbCeIncrementActiveExchangeCount()) == STATUS_SUCCESS) {
        PSMB_EXCHANGE             LocalExchangePointer = *pExchangePointer;
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

        LocalExchangePointer->CancellationStatus = SMBCE_EXCHANGE_NOT_CANCELLED;
        LocalExchangePointer->RxContext = pRxContext;

        if (Status == STATUS_SUCCESS) {
            if (pVNetRoot != NULL) {
                pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);

                LocalExchangePointer->SmbCeContext.pVNetRoot = pVNetRoot;
                pServerEntry = SmbCeGetAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
            } else {
                ASSERT(pServerEntry != NULL);
                pVNetRootContext = NULL;
            }

            if (pVNetRootContext != NULL) {
                SmbCeReferenceVNetRootContext(pVNetRootContext);

                LocalExchangePointer->SmbCeContext.pVNetRootContext =
                    pVNetRootContext;
                LocalExchangePointer->SmbCeContext.pServerEntry =
                    pVNetRootContext->pServerEntry;
            } else {
                SmbCeReferenceServerEntry(pServerEntry);

                LocalExchangePointer->SmbCeContext.pServerEntry  =
                    pServerEntry;

                LocalExchangePointer->SmbCeContext.pVNetRootContext = NULL;
            }

            LocalExchangePointer->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
            LocalExchangePointer->pDispatchVector = pDispatchVector;
            LocalExchangePointer->SmbCeFlags &= (SMBCE_EXCHANGE_FLAGS_TO_PRESERVE);
            LocalExchangePointer->SmbCeFlags |= (SMBCE_EXCHANGE_REUSE_MID | SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);
        }

        if (Status != STATUS_SUCCESS) {
            SmbCeDecrementActiveExchangeCount();
        }
    } else {
        (*pExchangePointer)->SmbCeFlags |= SMBCE_EXCHANGE_SMBCE_STOPPED;
    }

    if ((Status == STATUS_SUCCESS) &&
        (pRxContext != NULL)) {
        PFOBX             pFobx = (PFOBX)(pRxContext->pFobx);
        PMRX_FCB           pFcb = (pRxContext->pFcb);
        PSMBCE_SESSION pSession = SmbCeGetExchangeSession(*pExchangePointer);

        if ((pSession != NULL) &&
            FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
            (pRxContext->MajorFunction != IRP_MJ_CREATE) &&
            (pRxContext->MajorFunction != IRP_MJ_CLOSE) &&
            (pFobx != NULL) &&
            (pFcb->pNetRoot != NULL) &&
            (pFcb->pNetRoot->Type == NET_ROOT_DISK)) {
            PMRX_SRV_OPEN SrvOpen = pFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            if ((smbSrvOpen != NULL) &&
                (smbSrvOpen->Version != pServerEntry->Server.Version)) {
                if (smbSrvOpen->DeferredOpenContext != NULL) {
                    Status = SmbCeRemoteBootReconnect(*pExchangePointer, pRxContext);
                } else {
                    Status = STATUS_CONNECTION_DISCONNECTED;
                    pFcb->fShouldBeOrphaned = TRUE;
                }
            }
        }
    }

    if (pRxContext != NULL &&
        pRxContext->MajorFunction != IRP_MJ_CREATE &&
        pRxContext->pFcb->Attributes & FILE_ATTRIBUTE_OFFLINE) {
        (*pExchangePointer)->IsOffLineFile = TRUE;
    }

    if (!NT_SUCCESS(Status)) {
        if (pExchange != NULL) {
            SmbMmFreeExchange(pExchange);
            *pExchangePointer = NULL;
        }
    }

    return Status;
}

NTSTATUS
SmbCeInitializeAssociatedExchange(
    PSMB_EXCHANGE                 *pAssociatedExchangePointer,
    PSMB_EXCHANGE                 pMasterExchange,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine initializes the given exchange instanece

Arguments:

    pAssociatedExchangePointer  - the placeholder for the exchange instance. If it is NULL a new one
    is allocated.

    pMasterExchange      - the master exchange

    Type              - the type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    NTSTATUS - The return status for the operation

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if ((pMasterExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED) &&
        !FlagOn(pMasterExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE)) {
        Status = SmbCeInitializeExchange(
                     pAssociatedExchangePointer,
                     NULL,
                     pMasterExchange->SmbCeContext.pVNetRoot,
                     Type,
                     pDispatchVector);

        if (Status == STATUS_SUCCESS) {
            PSMB_EXCHANGE pAssociatedExchange;

            pAssociatedExchange = *pAssociatedExchangePointer;

            pAssociatedExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
            pAssociatedExchange->SmbCeFlags |= SMBCE_ASSOCIATED_EXCHANGE;

            SmbCeIncrementPendingLocalOperations(pMasterExchange);
            InterlockedIncrement(&pMasterExchange->Master.PendingAssociatedExchanges);
            pAssociatedExchange->Associated.pMasterExchange = pMasterExchange;

            InitializeListHead(&pAssociatedExchange->WorkQueueItem.List);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange         - the exchange instance.

    Type              - the new type of the exchange

    pDispatchVector   - the dispatch vector asscoiated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    As it is currently implemented no restrictions are imposed. Once the number of exchanges
    have been established further restrictions will be imposed barring certain kinds of
    transformations. The transformation merely switches the dispatch vector associated
    with the exchange but the context is left intact.

--*/
{
    PAGED_CODE();

    pExchange->Type = (UCHAR)NewType;
    pExchange->pDispatchVector = pDispatchVector;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeUpdateSessionEntryAndVNetRootContext(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

    This routine updates the session entry and/or vnetrootcontext if this exchange has
    been marked as a constructor for a session and/or netroot.

Arguments:

    pExchange  - the exchange instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PMRX_V_NET_ROOT           pVNetRoot = SmbCeGetExchangeVNetRoot(pExchange);
    PSMBCEDB_SESSION_ENTRY    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

    if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) {
        ASSERT(pSessionEntry != NULL);
        RxDbgTrace( 0, Dbg, ("Dispatching Session Entry Finalization\n"));

        SmbCeReferenceSessionEntry(pSessionEntry);

//        ASSERT(pExchange->SessionSetupStatus != STATUS_SUCCESS ||
//               pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS);

        pVNetRoot->ConstructionStatus = pExchange->SessionSetupStatus;

        SmbCeCompleteSessionEntryInitialization(pSessionEntry,
                                                pExchange->SessionSetupStatus,
                                                pExchange->SecuritySignatureReturned);

        pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
    }

    if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) {
        ASSERT(pVNetRootContext != NULL);
        RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));

        SmbCeReferenceVNetRootContext(pVNetRootContext);
        SmbCeCompleteVNetRootContextInitialization(pVNetRootContext);
        pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCePrepareExchangeForReuse(
    PSMB_EXCHANGE                 pExchange)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange  - the exchange instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SERVER_ENTRY     pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCePrepareExchangeForReuse: Invoked\n"));

    if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_SMBCE_STOPPED)) {
        pNetRootEntry    = SmbCeGetExchangeNetRootEntry(pExchange);
        pSessionEntry    = SmbCeGetExchangeSessionEntry(pExchange);
        pServerEntry     = SmbCeGetExchangeServerEntry(pExchange);
        pVNetRootContext = SmbCeGetExchangeVNetRootContext(pExchange);

        if (pServerEntry != NULL) {
            // Disassociate the MID associated with the exchange
            if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                SmbCeDissociateMidFromExchange(pServerEntry,pExchange);
            }

            // Tear down all the copy data requests associated with this exchange
            SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,pExchange);

            // Uninitialize the transport associated with the exchange
            SmbCeUninitializeExchangeTransport(pExchange);
        }

        // If this exchange has been marked as a constructor for either a
        // session or netroot finalize the appropriate entries. ( mark
        // them for deletion so that other exchanges can be resumed )

        SmbCeUpdateSessionEntryAndVNetRootContext(pExchange);

        if (pVNetRootContext != NULL) {
            SmbCeDereferenceVNetRootContext(pVNetRootContext);
         } else {
            if (pServerEntry != NULL) {
                SmbCeDereferenceServerEntry(pServerEntry);
            }
        }
    }

    SmbCeFreeBufferForServerResponse(pExchange);

    if (FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE)) {
        PSMB_EXCHANGE pMasterExchange;
        LONG AssociatedExchangeCount;

        pMasterExchange = pExchange->Associated.pMasterExchange;

        AssociatedExchangeCount = InterlockedDecrement(
                                      &pMasterExchange->Master.PendingAssociatedExchanges);

        if (FlagOn(
                pMasterExchange->SmbCeFlags,
                SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED) &&
            (AssociatedExchangeCount == 0)){
            NTSTATUS Status;
            BOOLEAN  PostRequest;

            ClearFlag(
                pMasterExchange->SmbCeFlags,
                SMBCE_ASSOCIATED_EXCHANGES_COMPLETION_HANDLER_ACTIVATED);

            Status = SMB_EXCHANGE_DISPATCH(
                         pMasterExchange,
                         AssociatedExchangesCompletionHandler,
                         (pMasterExchange,&PostRequest));

            RxDbgTrace(0,Dbg,("Master Exchange %lx Assoc. Completion Status %lx\n",pMasterExchange,Status));
        }

        SmbCeDecrementPendingLocalOperationsAndFinalize(pMasterExchange);
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeDiscardExchangeWorkerThreadRoutine(PVOID pExchange)
/*++

Routine Description:

   This routine discards an exchange.

Arguments:

    pExchange  - the exchange to be discarded.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Even though this is simple, it cannot be inlined since the destruction of an
    exchange instance can be posted to a waorker thread.

--*/
{
    PSMB_EXCHANGE pSmbExchange = pExchange;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SmbCeDiscardExchange: Invoked\n"));

    //RxLog((">>>Discard %lx",pSmbExchange));

    // Destory the context
    if (pSmbExchange->ReferenceCount == 0) {
        SmbCeAcquireResource();

        RemoveEntryList(&pSmbExchange->ExchangeList);

        SmbCeReleaseResource();

        SmbCePrepareExchangeForReuse(pSmbExchange);

        SmbCeDecrementActiveExchangeCount();

        // Discard the memory associated with the exchange
        SmbMmFreeExchange(pSmbExchange);
    } else {
        RxDbgTrace(
            0,
            Dbg,
            ("SmbCeDiscardExchange: Exchange %lx not discarded %ld\n",
              pSmbExchange,pSmbExchange->ReferenceCount)
            );
    }
}

VOID
SmbCeDiscardExchange(PVOID pExchange)
/*++

Routine Description:

   This routine discards an exchange.

Arguments:

    pExchange  - the exchange to be discarded.

Notes:

    The destruction of an exchange instance is posted to a worker thread in order to
    avoid deadlock in transport.

--*/
{
    PSMB_EXCHANGE pSmbExchange = pExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pSmbExchange);

    // Disassociate the MID associated with the exchange
    if (pSmbExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
        SmbCeDissociateMidFromExchange(pServerEntry,pSmbExchange);
    }

    RxPostToWorkerThread(
        MRxSmbDeviceObject,
        CriticalWorkQueue,
        &((PSMB_EXCHANGE)pExchange)->WorkQueueItem,
        SmbCeDiscardExchangeWorkerThreadRoutine,
        (PSMB_EXCHANGE)pExchange);
}

NTSTATUS
SmbCeCancelExchange(
    PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine initiates the cancellation of an exchange.

Arguments:

    pRxContext  - the RX_CONTEXT instance for which cancellation needs to be
    initiated.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The cancellation policy that has been implemented is a "best effort" policy.
    Since the server has already committed resources to an operation at its end
    the best that we can do within the scope of the SMB protocol is to initiate
    a cancellation operation by sending the appropriate SMB_COM_NT_CANCEL command

    Not all dialects of SMB support this command. For the downlevel dialects the
    best that we can do is to ensure that the MID is not reused during the lifetime
    of the connection. This will result in a gradual degradation of performance.

    The difficulty in detecting the end of operations is that there are MIDS

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_EXCHANGE pExchange;
    LIST_ENTRY    CancelledExchanges;
    PLIST_ENTRY   pListEntry;

    PMRXSMB_RX_CONTEXT pMRxSmbContext;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pRxContext->pFcb->pNetRoot);
    PSMBCEDB_SERVER_ENTRY pServerEntry = pNetRootEntry->pServerEntry;

    SmbCeLog(("SmbCe Cancel %lx\n",pRxContext));
    SmbLog(LOG,
           SmbCeCancelExchange_1,
           LOGPTR(pRxContext));

    InitializeListHead(&CancelledExchanges);

    SmbCeAcquireSpinLock();

    pListEntry = pServerEntry->ActiveExchanges.Flink;

    //
    // With the pipeline write, multiple exchanges can be outstanding for a single RxContext.
    // We need to walk through the active exchanges list to find and cancel all of them.
    //

    while (pListEntry != &pServerEntry->ActiveExchanges) {
        PLIST_ENTRY pNextListEntry;

        pNextListEntry = pListEntry->Flink;
        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);
        pListEntry = pNextListEntry;

        if (pExchange->RxContext == pRxContext) {
            if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
                if (pExchange->ReceivePendingOperations > 0) {

                    // This exchange is awaiting a response from the server. In all
                    // these cases a CANCEL command needs to be sent to the server
                    // This command can only be sent to NT servers. For non NT
                    // servers this exchange can be terminated with the detrimental
                    // side effect of reducing the maximum number of commands by 1.

                    InsertTailList(&CancelledExchanges,&pExchange->CancelledList);
                    InterlockedIncrement(&pExchange->LocalPendingOperations);

                    //DbgPrint("Exchange to be cancelled %x %x\n",pExchange,pRxContext);

                    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
                        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
                            NTSTATUS LocalStatus;

                            LocalStatus = SmbCepDiscardMidAssociatedWithExchange(
                                              pExchange);

                            ASSERT(LocalStatus == STATUS_SUCCESS);
                        }
                    }
                } else {
                    InterlockedCompareExchange(
                        &pExchange->CancellationStatus,
                        SMBCE_EXCHANGE_CANCELLED,
                        SMBCE_EXCHANGE_NOT_CANCELLED);
                }
            }
        }
    }

    SmbCeReleaseSpinLock();

    pListEntry = CancelledExchanges.Flink;

    while (pListEntry != &CancelledExchanges) {
        PLIST_ENTRY pNextListEntry;

        pNextListEntry = pListEntry->Flink;
        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,CancelledList);
        RemoveEntryList(&pExchange->CancelledList);
        pListEntry = pNextListEntry;

        //DbgPrint("Exchange cancelled %x %x\n",pExchange,pRxContext);
        SmbCeLog(("SmbCeCancel Initiate %lx\n",pExchange));
        SmbLog(LOG,
               SmbCeCancelExchange_2,
               LOGPTR(pExchange));

        if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            UCHAR  LastCommandInHeader;
            PUCHAR pCommand;
            PSMB_HEADER pSmbHeader;
            PNT_SMB_HEADER pNtSmbHeader;

            BYTE  SmbBuffer[TRANSPORT_HEADER_SIZE + CANCEL_BUFFER_SIZE];
            PBYTE  CancelRequestBuffer = SmbBuffer + TRANSPORT_HEADER_SIZE;
            ULONG CancelRequestBufferSize = CANCEL_BUFFER_SIZE;

            pSmbHeader = (PSMB_HEADER)CancelRequestBuffer;
            pNtSmbHeader = (PNT_SMB_HEADER)pSmbHeader;

            // Before issuing the cancel request ensure that if this exchange
            // is set as a timed receive operation. This will ensure that if
            // the cancel is delayed at the server we will initiate a tear down
            // of the connection.

            if (!FlagOn(
                    pExchange->SmbCeFlags,
                    SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION)) {

                SmbCeAcquireResource();

                SmbCeSetExpiryTime(pExchange);

                pExchange->SmbCeFlags |= SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION;

                SmbCeReleaseResource();
            }

            // Build the Cancel request and send it across to the server.
            Status = SmbCeBuildSmbHeader(
                         pExchange,
                         CancelRequestBuffer,
                         CancelRequestBufferSize,
                         &CancelRequestBufferSize,
                         &LastCommandInHeader,
                         &pCommand);

            ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);

            if (Status == STATUS_SUCCESS) {
                PREQ_NT_CANCEL pCancelRequest = (PREQ_NT_CANCEL)(&CancelRequestBuffer[sizeof(SMB_HEADER)]);
                PMDL     pCancelSmbMdl;

                *pCommand = SMB_COM_NT_CANCEL;

                SmbPutUshort(&pSmbHeader->Mid,pExchange->Mid);

                if (BooleanFlagOn(
                        pExchange->SmbCeFlags,
                        SMBCE_EXCHANGE_FULL_PROCESSID_SPECIFIED)) {

                    ULONG ProcessId;

                    ProcessId = RxGetRequestorProcessId(pRxContext);

                    SmbPutUshort(&pNtSmbHeader->Pid, (USHORT)((ProcessId) & 0xFFFF));
                    SmbPutUshort(&pNtSmbHeader->PidHigh, (USHORT)((ProcessId) >> 16));
                }

                SmbPutUshort(&pCancelRequest->WordCount,0);
                pCancelRequest->ByteCount = 0;
                CancelRequestBufferSize   = CANCEL_BUFFER_SIZE;

                RxAllocateHeaderMdl(
                    CancelRequestBuffer,
                    CancelRequestBufferSize,
                    pCancelSmbMdl
                    );

                if (pCancelSmbMdl != NULL) {
                    RxProbeAndLockHeaderPages(
                        pCancelSmbMdl,
                        KernelMode,
                        IoModifyAccess,
                        Status);

                    if (Status == STATUS_SUCCESS) {
                        Status = SmbCeSendToServer(
                                     pServerEntry,
                                     RXCE_SEND_SYNCHRONOUS,
                                     pCancelSmbMdl,
                                     CancelRequestBufferSize);

                        RxUnlockHeaderPages(pCancelSmbMdl);
                    }

                    IoFreeMdl(pCancelSmbMdl);
                }
            }
        } else {
            SmbCeFinalizeExchangeOnDisconnect(pExchange);
        }


        InterlockedCompareExchange(
            &pExchange->CancellationStatus,
            SMBCE_EXCHANGE_CANCELLED,
            SMBCE_EXCHANGE_NOT_CANCELLED);

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
    }

    return Status;
}

NTSTATUS
SmbCeIncrementPendingOperations(
   PSMB_EXCHANGE pExchange,
   ULONG         PendingOperationMask,
   PVOID         FileName,
   ULONG         FileLine)
/*++

Routine Description:

   This routine increments the appropriate pending operation count

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be incremented

Return Value:

    RxStatus(SUCCESS) if successful

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    SmbCeAcquireSpinLock();

    if (!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
        if ((pServerEntry != NULL) &&
            ((pServerEntry->ServerStatus == STATUS_SUCCESS) ||
             (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)) ||
             FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION))) {

            if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
                pExchange->LocalPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
                pExchange->SendCompletePendingOperations++;
            }

            if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
                pExchange->CopyDataPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_RECEIVE_OPERATION) {
                pExchange->ReceivePendingOperations++;
            }

            Status = STATUS_SUCCESS;
        } else {
            if ((PendingOperationMask & SMBCE_LOCAL_OPERATION) &&
                (PendingOperationMask & ~SMBCE_LOCAL_OPERATION) == 0) {

                pExchange->LocalPendingOperations++;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeFinalizeExchangeWorkerThreadRoutine(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This is the worker thread exchange finalization routine.

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    BOOLEAN  fPostFinalize;
    NTSTATUS Status;

    PAGED_CODE();

    Status = SMB_EXCHANGE_DISPATCH(
                 pExchange,
                 Finalize,
                 (pExchange,&fPostFinalize));

    ASSERT(!fPostFinalize && (Status == STATUS_SUCCESS));
}

VOID
SmbCepFinalizeExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This is the common finalization routine used by both the routines below

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    BOOLEAN fAssociatedExchange;

    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));
    fAssociatedExchange = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE);

    if (fAssociatedExchange) {
        PSMB_EXCHANGE pMasterExchange;

        // The local operation will be decremented on resumption of
        // the finalization routine
        pMasterExchange = pExchange->Associated.pMasterExchange;
        SmbCeIncrementPendingLocalOperations(pMasterExchange);

        RxPostToWorkerThread(
            MRxSmbDeviceObject,
            CriticalWorkQueue,
            &pExchange->WorkQueueItem,
            SmbCepFinalizeAssociatedExchange,
            pExchange);
    } else {
        NTSTATUS Status;
        BOOLEAN fPostFinalize = FALSE;

        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

        pExchange->ExpiryTime.QuadPart = 0;

        if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_RETAIN_MID)) {
            SmbCeDissociateMidFromExchange(
                pServerEntry,
                pExchange);
        }

        Status = SMB_EXCHANGE_DISPATCH(
                     pExchange,
                     Finalize,
                     (pExchange,&fPostFinalize));

        if ((Status == STATUS_SUCCESS) &&
            fPostFinalize)  {
            // Post the request to a worker thread so that the finalization can be completed
            // at a lower IRQL.
            RxPostToWorkerThread(
                MRxSmbDeviceObject,
                CriticalWorkQueue,
                &pExchange->WorkQueueItem,
                SmbCeFinalizeExchangeWorkerThreadRoutine,
                pExchange);
        }
    }
}

#define SENTINEL_ENTRY ((PSINGLE_LIST_ENTRY)IntToPtr(0xffffffff))

VOID
SmbCepFinalizeAssociatedExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This is the common finalization routine used by both the routines below

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    PSMB_EXCHANGE       pMasterExchange;
    PSMB_EXCHANGE       pAssociatedExchange;
    SINGLE_LIST_ENTRY   AssociatedExchangeList;

    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE));

    pMasterExchange = pExchange->Associated.pMasterExchange;

    ASSERT(pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next != NULL);

    for (;;) {
        BOOLEAN fAllAssociatedExchangesFinalized = FALSE;

        SmbCeAcquireSpinLock();

        if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next == SENTINEL_ENTRY) {
            pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next = NULL;
            fAllAssociatedExchangesFinalized = TRUE;
        } else if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next == NULL) {
            fAllAssociatedExchangesFinalized = TRUE;
        } else {
            AssociatedExchangeList.Next =
                pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next;

            pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next =
                SENTINEL_ENTRY;
        }

        SmbCeReleaseSpinLock();

        if (!fAllAssociatedExchangesFinalized) {
            for (;;) {
                PSINGLE_LIST_ENTRY pAssociatedExchangeEntry;

                pAssociatedExchangeEntry = AssociatedExchangeList.Next;

                if ((pAssociatedExchangeEntry != NULL) &&
                    (pAssociatedExchangeEntry != SENTINEL_ENTRY)) {
                    NTSTATUS Status;
                    BOOLEAN  fPostFinalize = FALSE;

                    AssociatedExchangeList.Next = pAssociatedExchangeEntry->Next;

                    pAssociatedExchange = (PSMB_EXCHANGE)
                                          CONTAINING_RECORD(
                                              pAssociatedExchangeEntry,
                                              SMB_EXCHANGE,
                                              Associated.NextAssociatedExchange);

                    ASSERT(IsListEmpty(&pAssociatedExchange->WorkQueueItem.List));

                    Status = SMB_EXCHANGE_DISPATCH(
                                 pAssociatedExchange,
                                 Finalize,
                                 (pAssociatedExchange,&fPostFinalize));
                } else {
                    break;
                }
            };
        } else {
            break;
        }
    }

    SmbCeDecrementPendingLocalOperationsAndFinalize(pMasterExchange);
}

BOOLEAN
SmbCeCanExchangeBeFinalized(
    PSMB_EXCHANGE pExchange,
    PSMBCE_EXCHANGE_STATUS pExchangeStatus)
/*++

Routine Description:

   This routine determines if the exchange instance can be finalized.

Arguments:

    pExchange  - the exchange to be finalized.

    pExchangeStatus - the finalization status

Return Value:

    TRUE if the exchange can be finalized

Notes:

    As a side effect it also sets the SMBCE_EXCHANGE_FINALIZED flag

    The SmbCe spin lock must have been acquire on entry

--*/
{
    BOOLEAN fFinalizeExchange = FALSE;
    BOOLEAN fAssociatedExchange;

    fAssociatedExchange = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_ASSOCIATED_EXCHANGE);

    if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_FINALIZED)) {
        if ((pExchange->ReceivePendingOperations == 0) &&
            (pExchange->CopyDataPendingOperations == 0) &&
            (pExchange->SendCompletePendingOperations == 0) &&
            (pExchange->LocalPendingOperations == 0)) {

            fFinalizeExchange = TRUE;
            *pExchangeStatus = SmbCeExchangeFinalized;
            pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FINALIZED;

            if (fAssociatedExchange) {
                PSMB_EXCHANGE pMasterExchange = pExchange->Associated.pMasterExchange;

                if (pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next != NULL) {
                    fFinalizeExchange = FALSE;
                }

                pExchange->Associated.NextAssociatedExchange.Next =
                    pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next;
                pMasterExchange->Master.AssociatedExchangesToBeFinalized.Next =
                    &pExchange->Associated.NextAssociatedExchange;
            }
        } else {
            *pExchangeStatus = SmbCeExchangeNotFinalized;
        }
    } else {
        *pExchangeStatus = SmbCeExchangeAlreadyFinalized;
    }

    if (fFinalizeExchange &&
        (pExchange->RxContext != NULL)) {
        NTSTATUS Status;
        PMRXSMB_RX_CONTEXT pMRxSmbContext;

        pMRxSmbContext = MRxSmbGetMinirdrContext(pExchange->RxContext);
        pMRxSmbContext->pCancelContext = NULL;

        Status = RxSetMinirdrCancelRoutine(
                     pExchange->RxContext,
                     NULL);
    }

    return fFinalizeExchange;
}

SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine finalizes an exchange instance.

Arguments:

    pExchange  - the exchange to be finalized.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;

    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    fFinalizeExchange = SmbCeCanExchangeBeFinalized(
                            pExchange,
                            &ExchangeStatus);

    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}

NTSTATUS
SmbCeDecrementPendingOperations(
    PSMB_EXCHANGE pExchange,
    ULONG         PendingOperationMask,
    PVOID         FileName,
    ULONG         FileLine)
/*++

Routine Description:

   This routine decrements the corresponding pending operation count
   and finalizes an exchange instance if required

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be decremented.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    SmbCeAcquireSpinLock();

    ASSERT(!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
        ASSERT(pExchange->LocalPendingOperations > 0);
        pExchange->LocalPendingOperations--;
    }

    if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
        ASSERT(pExchange->SendCompletePendingOperations > 0);
        pExchange->SendCompletePendingOperations--;
    }

    if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
        ASSERT(pExchange->CopyDataPendingOperations > 0);
        pExchange->CopyDataPendingOperations--;
    }

    if ((PendingOperationMask & SMBCE_RECEIVE_OPERATION) &&
        (pExchange->ReceivePendingOperations > 0)) {
        pExchange->ReceivePendingOperations--;
    }
    SmbCeReleaseSpinLock();

    return STATUS_SUCCESS;
}

SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE pExchange,
    ULONG         PendingOperationMask,
    PVOID         FileName,
    ULONG         FileLine)
/*++

Routine Description:

   This routine decrements the corresponding pending operation count
   and finalizes an exchange instance if required

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be decremented.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;
    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    ASSERT(!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
        ASSERT(pExchange->LocalPendingOperations > 0);
        pExchange->LocalPendingOperations--;
    }

    if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
        ASSERT(pExchange->SendCompletePendingOperations > 0);
        pExchange->SendCompletePendingOperations--;
    }

    if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
        ASSERT(pExchange->CopyDataPendingOperations > 0);
        pExchange->CopyDataPendingOperations--;
    }

    if ((PendingOperationMask & SMBCE_RECEIVE_OPERATION) &&
        (pExchange->ReceivePendingOperations > 0)) {
        pExchange->ReceivePendingOperations--;
    }

    fFinalizeExchange = SmbCeCanExchangeBeFinalized(
                            pExchange,
                            &ExchangeStatus);


    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}

VOID
SmbCeFinalizeExchangeOnDisconnect(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

    This routine handles the finalization of an exchange instance during transport disconnects

Arguments:

    pExchange  - the exchange instance

--*/
{
    PAGED_CODE();

    if (pExchange != NULL) {
        pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
        pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
        pExchange->ReceivePendingOperations = 0;

        SmbCeFinalizeExchange(pExchange);
    }
}

extern ULONG OffLineFileTimeoutInterval;
extern ULONG ExtendedSessTimeoutInterval;

VOID
SmbCeSetExpiryTime(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine sets the expiry time for a timed exchange,
   i.e., SMBCE_EXCHANGE_TIMED_OPERATION must be set

Arguments:

    pExchange  - the exchange instance.

Notes:

--*/
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ExpiryTimeInTicks;

    KeQueryTickCount( &CurrentTime );

    ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

    if (pExchange->IsOffLineFile) {
        ExpiryTimeInTicks.QuadPart = OffLineFileTimeoutInterval * ExpiryTimeInTicks.QuadPart;
    } else if (pExchange->SmbCeContext.pServerEntry->Server.ExtendedSessTimeout) {
        ExpiryTimeInTicks.QuadPart = ExtendedSessTimeoutInterval * ExpiryTimeInTicks.QuadPart;
        //DbgPrint("Set extended sesstimeout for %x %d\n",pExchange,ExtendedSessTimeoutInterval);
    } else {
        ExpiryTimeInTicks.QuadPart = MRxSmbConfiguration.SessionTimeoutInterval * ExpiryTimeInTicks.QuadPart;
    }

    pExchange->ExpiryTime.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;
}

BOOLEAN
SmbCeDetectExpiredExchanges(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine periodically walks the list of timed exchanges and chooses the
    instances for finalization.

    A timed exchange choosen by this routine will have waited for some network
    response for the given time interval

Arguments:

    pServerEntry -- the server entry for which this needs to be done

Notes:

--*/
{
    BOOLEAN       ExpiredExchangesDetected = FALSE;
    PSMB_EXCHANGE pExchange;
    PLIST_ENTRY   pListHead;
    PLIST_ENTRY   pListEntry;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    KeQueryTickCount( &CurrentTime );

    SmbCeAcquireResource();

    pListHead = &pServerEntry->ActiveExchanges;
    pListEntry = pListHead->Flink;

    while (pListEntry != pListHead) {
        PLIST_ENTRY pNextListEntry;

        pNextListEntry = pListEntry->Flink;
        pExchange = (PSMB_EXCHANGE)CONTAINING_RECORD(pListEntry,SMB_EXCHANGE,ExchangeList);

        // There are two kinds of exchanges that are candidates for
        // time out finalization.
        // (1) Any exchange which has a outstanding send complete
        // operation which has not completed.
        // (2) timed network operation exchanges which have a
        // receive or copy data operation pending.
        //
        // In all such cases the associated server entry is marked
        // for tear down and further processing is terminated.
        //

        if ((pExchange->SendCompletePendingOperations > 0) ||
            (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION) &&
             ((pExchange->CopyDataPendingOperations > 0) ||
              (pExchange->ReceivePendingOperations > 0)))) {
            if ((pExchange->ExpiryTime.QuadPart != 0) &&
                (pExchange->ExpiryTime.QuadPart < CurrentTime.QuadPart) &&
                !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {

                RxLog(("Marking server for tear down %lx \n",pServerEntry));
                SmbLogError(STATUS_UNSUCCESSFUL,
                            LOG,
                            SmbCeDetectExpiredExchanges,
                            LOGPTR(pExchange)
                            LOGPTR(pServerEntry)
                            LOGUSTR(pServerEntry->Name));
                ExpiredExchangesDetected = TRUE;

                RxLogRetail(("Exp Exch on %x (Com %x State %x)\n", pServerEntry, pExchange->SmbCommand, pExchange->SmbCeState ));
                RxLogRetail(("Rcv %x Loc %x SnCo %x Copy %x\n", pExchange->ReceivePendingOperations, pExchange->LocalPendingOperations,
                                             pExchange->SendCompletePendingOperations, pExchange->CopyDataPendingOperations ));
                if( pExchange->Type == TRANSACT_EXCHANGE )
                {
                    PSMB_TRANSACT_EXCHANGE pTransExchange = (PSMB_TRANSACT_EXCHANGE)pExchange;
                    PRX_CONTEXT RxContext = pTransExchange->RxContext;
                    RxLogRetail(("TrCmd %x NtTrans %x FID Flags %x Setup %x\n", pTransExchange->TransactSmbCommand,
                                      pTransExchange->NtTransactFunction, pTransExchange->Flags, pTransExchange->SendSetupBufferSize ));
                    RxLogRetail(("Transact %x (%x,%x)\n", RxContext->ResumeRoutine, RxContext->MajorFunction, RxContext->MinorFunction ));

                }
                break;
            }
        }

        pListEntry = pNextListEntry;
    }

    SmbCeReleaseResource();

    return ExpiredExchangesDetected;
}

//
// Default handler implementation of exchange handler functions.
//

NTSTATUS
DefaultSmbExchangeIndError(
    IN PSMB_EXCHANGE pExchange)     // the SMB exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndReceive(
    IN PSMB_EXCHANGE    pExchange)    // The exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndSendCallback(
    IN PSMB_EXCHANGE    pExchange)    // The exchange instance
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\sndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on
    all transports. The functionality common to all transports are handled in this
    module while transport specific functionality are handled in the appropriate
    ??sndrcv.c modules.

      mssndrcv.c  -- mailslot related send/receive functionality
      vcsndrcv.c  -- virtual circuit(connection) related send/receive functionality

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeSend)
#pragma alloc_text(PAGE, SmbCeSendToServer)
#endif

RXDT_DefineCategory(SMBSNDRCV);
#define Dbg        (DEBUG_TRACE_SMBSNDRCV)

extern ERESOURCE s_SmbSecuritySignatureResource;

NTSTATUS
SmbAddSmbSecuritySignature(
    IN PSMBCE_SERVER Server,
    IN OUT PMDL      Mdl,
    IN OUT ULONG     *ServerIndex,
    IN ULONG           SendLength);

char MRxSmbMiniSniff_SurrogateFormat[] = "%S%S%N%N%N%N%N%N%N";
                            ////                     2       3       4       5       6         7        8        9
char MRxSmbMiniSniff_ActualFormat[]    = "Minisniff (%s) srv %lx cmd/mid %lx status %lx len %04lx flg %06lx xc %08lx rx %08lx";

char MRxSmbMiniSniffTranceive[] = "Tranceive";
char MRxSmbMiniSniffReceive[] = "Receive";
char MRxSmbMiniSniffReceiveEcho[] = "RcvEcho";
char MRxSmbMiniSniffReceiveDiscard[] = "RcvDiscard";
char MRxSmbMiniSniffReceiveDiscardOplock[] = "RcvDiscardOplock";
char MRxSmbMiniSniffReceiveIndicateOplock[] = "RcvIndicateOplock";
char MRxSmbMiniSniffSend[] = "Send";
char MRxSmbMiniSniffSendSrv[] = "SendToServer";

VOID
RxMiniSniffer(
    IN PSZ TagString,
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG Length,
    IN PSMB_EXCHANGE pExchange,
    IN PSMB_HEADER   pSmbHeader
    )
{
    PRX_CONTEXT RxContext = NULL;
    USHORT Mid = SmbGetUshort(&pSmbHeader->Mid);
    ULONG  Status = SmbGetUlong(&((PNT_SMB_HEADER)pSmbHeader)->Status.NtStatus);
    USHORT Flags2 = SmbGetUshort(&pSmbHeader->Flags2);

    if (pExchange!=NULL) {
        RxContext = pExchange->RxContext;
    }
    RxLog((MRxSmbMiniSniff_SurrogateFormat, MRxSmbMiniSniff_ActualFormat,
                    TagString,
                    pServerEntry,
                    (ULONG)(pSmbHeader->Command<<24) | Mid,
                    Status,
                    Length,
                    (pSmbHeader->Flags<<16)|Flags2,
                    pExchange,RxContext));
    SmbLog(LOG,
           RxMiniSniffer,
           LOGPTR(pServerEntry)
           LOGUCHAR(pSmbHeader->Command)
           LOGXSHORT(Mid)
           LOGULONG(Status)
           LOGULONG(Length)
           LOGUCHAR(pSmbHeader->Flags)
           LOGXSHORT(Flags2)
           LOGPTR(pExchange)
           LOGPTR(RxContext)
           LOGARSTR(TagString));
}


NTSTATUS
SmbCeTranceive(
      PSMB_EXCHANGE   pExchange,
      ULONG           SendOptions,
      PMDL            pSmbMdl,
      ULONG           SendLength)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_PENDING - the transmit/receive request has been passed on successfully to the underlying
                     connection engine.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                Status = STATUS_SUCCESS;

   PSMBCEDB_SERVER_ENTRY   pServerEntry  = SmbCeGetExchangeServerEntry(pExchange);

   PSMB_HEADER             pSmbHeader   = MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
   USHORT                  Mid;

   PVOID                   pSendCompletionContext = NULL;

   if (pSmbHeader == NULL) {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   } else {
       Status = SmbCeIncrementPendingOperations(
                      pExchange,
                      (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION | SMBCE_RECEIVE_OPERATION),
                      __FILE__,
                      __LINE__);
   }

   if (Status == STATUS_SUCCESS) {
       PSMBCE_SERVER_TRANSPORT pTransport;

      // Ensure that the transport associated with the exchange is valid.
      // It is not always possible to make decisions w.r.t changing
      // transports since it is a function of the protocol choosen at the
      // higher level. Therefore no attempts to reconnect are made at this
      // level.

       if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
           pTransport = pServerEntry->pMailSlotTransport;
       } else {
           pTransport = pServerEntry->pTransport;
       }

      if (pTransport == NULL) {
          Status = STATUS_CONNECTION_DISCONNECTED;
      }

      if (Status == STATUS_SUCCESS &&
          !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
         // Associate the exchange with a mid
         Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
      }

      if (Status == STATUS_SUCCESS) {
         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);

            if (Status == STATUS_SUCCESS) {
               pSendCompletionContext = pSmbMdl;
            }
         }

         // If there is no send completion handling associated with this tranceive
         // decrement the count.
         if (pSendCompletionContext == NULL) {
            SmbCeDecrementPendingSendCompleteOperations(pExchange);
         }

         if (Status == STATUS_SUCCESS) {
            // Stamp the MID allocated for the request and send the SMB.
            pSmbHeader->Mid = pExchange->Mid;

            RxMiniSniffer(MRxSmbMiniSniffTranceive,pServerEntry,SendLength,pExchange,pSmbHeader);

            // Update the expiry time on the exchange if required.
            SmbCeSetExpiryTime(pExchange);

            if (InterlockedCompareExchange(
                    &pExchange->CancellationStatus,
                    SMBCE_EXCHANGE_NOT_CANCELLED,
                    SMBCE_EXCHANGE_NOT_CANCELLED) == SMBCE_EXCHANGE_NOT_CANCELLED) {
                BOOLEAN ResourceAcquired = FALSE;

                if (pServerEntry->SecuritySignaturesActive &&
                    !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
                    PSMBCE_SERVER Server = SmbCeGetExchangeServer(pExchange);

                    // The resource should be released after return from TDI to ensure serialization
                    // of sending SMB message with security signature.
                    SmbCeAcquireSecuritySignatureResource();
                    ResourceAcquired = TRUE;

                    Status = SmbAddSmbSecuritySignature(
                                 Server,
                                 pSmbMdl,
                                 &pExchange->SmbSecuritySignatureIndex,
                                 SendLength);

                    pExchange->IsSecuritySignatureEnabled = TRUE;
                
                    // the index for next request. Notice index+1 is reserved for the response
                    Server->SmbSecuritySignatureIndex += 2;
                }

                if (Status == STATUS_SUCCESS) {
                    pExchange->SmbCommand = pSmbHeader->Command;

                    // Update the operation counts for the exchange instance.
                    // Refer to Header for detailed explanation
                    Status = (pTransport->pDispatchVector->Tranceive)(
                                    pTransport,
                                    pServerEntry,
                                    pExchange,
                                    SendOptions,
                                    pSmbMdl,
                                    SendLength,
                                    pSendCompletionContext);
                }

                if (ResourceAcquired == TRUE) {
                    SmbCeReleaseSecuritySignatureResource();
                }
            } else {
                if (pSendCompletionContext != NULL) {
                    SmbCeDecrementPendingSendCompleteOperations(pExchange);
                }
                Status = STATUS_CANCELLED;
            }

            if ((Status != STATUS_PENDING) &&
                (Status != STATUS_SUCCESS)) {
               pExchange->Status = Status;
               SmbCeDecrementPendingReceiveOperations(pExchange);
               InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
            } else {
                ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
                ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
            }
         } else {
             pExchange->Status = Status;
             SmbCeDecrementPendingReceiveOperations(pExchange);
             InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
         }
      } else {
         SmbCeDecrementPendingReceiveOperations(pExchange);
         SmbCeDecrementPendingSendCompleteOperations(pExchange);
      }

      if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
          pExchange->SmbStatus = Status;
      }

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
      Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
SmbCeReceive(
   PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This routine receives a SMB for a give exchange

Arguments:

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_SUCCESS - the exchange has been setup for receiving an SMB

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   ASSERT(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID);

   Status = SmbCeIncrementPendingOperations(pExchange, (SMBCE_RECEIVE_OPERATION),__FILE__,__LINE__);

   if (Status == STATUS_SUCCESS) {
       // Update the expiry time on the exchange if required.
       SmbCeSetExpiryTime(pExchange);
   }

   return Status;
}


NTSTATUS
SmbCeSend(
   PSMB_EXCHANGE pExchange,
   ULONG         SendOptions,
   PMDL          pSmbMdl,
   ULONG         SendLength)
/*++

Routine Description:

    This routine transmits a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

For asynchronous sends ....

    STATUS_PENDING - the request was passed onto the underlying transport and
                     the quiescent state routine will be called in the future.

    any other status code -- indicates an error in passing the request and the
                     quiescent state routine will never be called in the future.


For synchronous sends

    the appropriate status but will never return STATUS_PENDING.

Notes:

    This routine always expects an exchange with the appropriate SendCompletionHandler.

--*/
{
    NTSTATUS              Status       = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    PSMB_HEADER           pSmbHeader   = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
    PVOID                 pSendCompletionContext = NULL;

    PAGED_CODE();

    ASSERT(pExchange != NULL);

    if (pSmbHeader == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        Status = SmbCeIncrementPendingOperations(
                     pExchange,
                     (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION),
                     __FILE__,
                     __LINE__);
    }

    if (Status == STATUS_SUCCESS) {
        PSMBCE_SERVER_TRANSPORT pTransport;

        // Ensure that the transport associated with the exchange is valid.
        // It is not always possible to make decisions w.r.t changing
        // transports since it is a function of the protocol choosen at the
        // higher level. Therefore no attempts to reconnect are made at this
        // level.

        if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            pTransport = pServerEntry->pMailSlotTransport;
        } else {
            pTransport = pServerEntry->pTransport;
        }

        ASSERT(pTransport != NULL);

        if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
            if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
                // Associate the exchange with a mid if it does not already have a valid mid.
                Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
            }

            if (Status == STATUS_SUCCESS) {
                // if the MID association was successful copy the MID onto the SMB and setup
                // a send completion context if required
                pSmbHeader->Mid = pExchange->Mid;
                if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
                    ASSERT(pExchange->pDispatchVector->SendCompletionHandler != NULL);
                    Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);
                    if (Status == STATUS_SUCCESS) {
                        pSendCompletionContext = pSmbMdl;
                    }
                }
            }
        }

        if ((pSendCompletionContext == NULL) ||
            (Status != STATUS_SUCCESS)) {
            SmbCeDecrementPendingSendCompleteOperations(pExchange);
        }

        if (Status == STATUS_SUCCESS) {
            // Update the expiry time on the exchange if required.
            SmbCeSetExpiryTime(pExchange);

            if (InterlockedCompareExchange(
                    &pExchange->CancellationStatus,
                    SMBCE_EXCHANGE_NOT_CANCELLED,
                    SMBCE_EXCHANGE_NOT_CANCELLED) == SMBCE_EXCHANGE_NOT_CANCELLED) {
                BOOLEAN ResourceAcquired = FALSE;

                if (pServerEntry->SecuritySignaturesActive &&
                    !FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
                    PSMBCE_SERVER Server = SmbCeGetExchangeServer(pExchange);

                    if (Server != NULL) {
                        // The resource should be released after return from TDI to ensure serialization
                        // of sending SMB message with security signature.
                        SmbCeAcquireSecuritySignatureResource();
                        ResourceAcquired = TRUE;

                        Status = SmbAddSmbSecuritySignature(
                                     Server,
                                     pSmbMdl,
                                     &pExchange->SmbSecuritySignatureIndex,
                                     SendLength);
                    
                        pExchange->IsSecuritySignatureEnabled = TRUE;

                        // the index for next request
                        Server->SmbSecuritySignatureIndex += 2;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    pExchange->SmbCommand = pSmbHeader->Command;

                    Status = (pTransport->pDispatchVector->Send)(
                                 pTransport,
                                 pServerEntry,
                                 SendOptions,
                                 pSmbMdl,
                                 SendLength,
                                 pSendCompletionContext);
                }

                if (ResourceAcquired == TRUE) {
                    SmbCeReleaseSecuritySignatureResource();
                }
            } else {
                if (pSendCompletionContext != NULL) {
                    SmbCeDecrementPendingSendCompleteOperations(pExchange);
                }
                Status = STATUS_CANCELLED;
            }
        }

        RxMiniSniffer(MRxSmbMiniSniffSend,pServerEntry,SendLength,pExchange,pSmbHeader);

        if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
            pExchange->SmbStatus = Status;
            InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
        } else {
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
        }

        SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

        if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
            Status = STATUS_PENDING;
        } else {
            ASSERT(Status != STATUS_PENDING);
        }
    }

    return Status;
}

NTSTATUS
SmbCeSendToServer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   ULONG                 SendOptions,
   PMDL                  pSmbMdl,
   ULONG                 SendLength)
/*++

Routine Description:

    This routine transmits a SMB to a given server synchronously.

Arguments:

    pServerEntry - the server entry

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_SUCCESS if successful

    otherwise appropriate error code

--*/
{
   NTSTATUS    Status = STATUS_SUCCESS;
   PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
   PVOID       pSendCompletionContext = NULL;

   PAGED_CODE();

   if (pSmbHeader == NULL) {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   } else {
       if (pServerEntry->pTransport != NULL) {
           BOOLEAN ResourceAcquired = FALSE;

           if (pServerEntry->SecuritySignaturesActive) {
               PSMBCE_SERVER Server = &pServerEntry->Server;
               ULONG Index;

               if (Server != NULL) {
                   // The resource should be released after return from TDI to ensure serialization
                   // of sending SMB message with security signature.
                   SmbCeAcquireSecuritySignatureResource();
                   ResourceAcquired = TRUE;

                   Status = SmbAddSmbSecuritySignature(
                                Server,
                                pSmbMdl,
                                &Index,
                                SendLength);
               
                   // the index for next request
                   Server->SmbSecuritySignatureIndex ++;
               }
           }
           
           Status = (pServerEntry->pTransport->pDispatchVector->Send)(
                        pServerEntry->pTransport,
                        pServerEntry,
                        (SendOptions | RXCE_SEND_SYNCHRONOUS),
                        pSmbMdl,
                        SendLength,
                        pSendCompletionContext);

           if (ResourceAcquired == TRUE) {
               SmbCeReleaseSecuritySignatureResource();
           }
           
           if (!NT_SUCCESS(Status)) {
               InterlockedIncrement(&MRxSmbStatistics.InitiallyFailedOperations);
           } else {
               ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsTransmitted,1);
               ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesTransmitted,SendLength);
              
               RxMiniSniffer(MRxSmbMiniSniffSendSrv,pServerEntry,SendLength,NULL,pSmbHeader);
           }
       } else {
           Status = RX_MAP_STATUS(CONNECTION_DISCONNECTED);
       }
   }

   ASSERT(Status != STATUS_PENDING);
   return Status;
}


NTSTATUS
SmbCeReceiveInd(
      IN PSMBCEDB_SERVER_ENTRY pServerEntry,
      IN ULONG                 BytesIndicated,
      IN ULONG                 BytesAvailable,
      OUT ULONG                *pBytesTaken,
      IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
      OUT PULONG               pDataBufferSize,        // amount of data to copy
      IN ULONG                 ReceiveFlags
     )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pServerEntry       - the server entry

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status;

   BYTE                     *pSmbCommand;
   PSMB_EXCHANGE            pExchange;
   PSMB_HEADER              pSmbHeader = (PSMB_HEADER)pTsdu;

   // Perform the quick tests by which ill formed SMB's, mangled SMB's can be rejected.
   // e.g., any indication which is of non zero length which is less then the length of
   // a SMB_HEADER plus the minimum SMB message body length of 3 bytes cannot be a valid
   // SMB.

   if ((BytesAvailable < sizeof(SMB_HEADER) + 2) ||
       (SmbGetUlong(((PULONG )pSmbHeader->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL) ||
       (pSmbHeader->Command == SMB_COM_NO_ANDX_COMMAND)  ) {
      RxLog(("SmbCeReceiveInd: Invalid Response for %lx\n",pServerEntry));
      SmbLogError(STATUS_UNSUCCESSFUL,
                  LOG,
                  SmbCeReceiveInd,
                  LOGPTR(pServerEntry)
                  LOGUSTR(pServerEntry->Name));
      *pBytesTaken = BytesIndicated;
      return STATUS_SUCCESS;
   }

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   if (pSmbHeader->Command == SMB_COM_ECHO) {
       PSMBCE_RESUMPTION_CONTEXT pResumptionContext = NULL;

       InterlockedExchange(
           &pServerEntry->Server.EchoProbeState,
           ECHO_PROBE_IDLE);
       pServerEntry->Server.EchoExpiryTime.QuadPart = 0;

       *pBytesTaken = BytesIndicated;
       RxMiniSniffer(MRxSmbMiniSniffReceiveEcho,pServerEntry,BytesIndicated,NULL,pSmbHeader);

       ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
       ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);

       return STATUS_SUCCESS;
   }

   // Perform the tests for detecting oplock break SMB's. These are SMB's with the
   // command SMB_COM_LOCKING_ANDX with the LOCKING_ANDX_OPLOCK_RELEASE bit set.
   // These SMB's are transformed into buffering state change requests which are
   // processed by the RDBSS.
   // CODE.IMPROVEMENT -- raw mode handling needs to be incorporated
   //

   if (pSmbHeader->Command == SMB_COM_LOCKING_ANDX) {
      if (BytesIndicated == LOCK_BROKEN_SIZE) {
         PREQ_LOCKING_ANDX pOplockBreakRequest = (PREQ_LOCKING_ANDX)(pSmbHeader + 1);

         if (SmbGetUshort(&pOplockBreakRequest->LockType) & LOCKING_ANDX_OPLOCK_RELEASE) {
            ULONG NewOplockLevel;

            switch (pOplockBreakRequest->OplockLevel) {
            case OPLOCK_BROKEN_TO_II:
               NewOplockLevel = SMB_OPLOCK_LEVEL_II;
               break;
            case OPLOCK_BROKEN_TO_NONE:
            default:
               NewOplockLevel = SMB_OPLOCK_LEVEL_NONE;
            }

            RxMiniSniffer(MRxSmbMiniSniffReceiveIndicateOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
            ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);

            if (pServerEntry->pRdbssSrvCall != NULL) {
                RxIndicateChangeOfBufferingState(
                         pServerEntry->pRdbssSrvCall,
                         MRxSmbMakeSrvOpenKey(pSmbHeader->Tid,pOplockBreakRequest->Fid),
                         ULongToPtr(NewOplockLevel));
            }

            RxDbgTrace(0,Dbg,("SmbCeReceiveInd: OPLOCK Break Request TID(%lx) FID(%lx)\n",
                                               pSmbHeader->Tid,pOplockBreakRequest->Fid));

            RxLog(("OPLOCK Break: FID %lx Level %x\n",pOplockBreakRequest->Fid,pOplockBreakRequest->OplockLevel));
            SmbLog(LOG,
                   SmbCeReceiveInd_2,
                   LOGXSHORT(pOplockBreakRequest->Fid)
                   LOGUCHAR(pOplockBreakRequest->OplockLevel)
                   LOGPTR(pServerEntry)
                   LOGUSTR(pServerEntry->Name));
            //DbgPrint("OPLOCK Break: FID %lx Level %x\n",pOplockBreakRequest->Fid,pOplockBreakRequest->OplockLevel);

            *pBytesTaken = BytesIndicated;
            return STATUS_SUCCESS;
         }
      }
   }

   // Handle the cases when the server responds to the oplock break response.
   if ((pSmbHeader->Mid == SMBCE_MAILSLOT_OPERATION_MID) ||
       (pSmbHeader->Mid == SMBCE_OPLOCK_RESPONSE_MID)) {
      *pBytesTaken = BytesIndicated;
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,BytesIndicated);
      RxMiniSniffer(MRxSmbMiniSniffReceiveDiscardOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
      return STATUS_SUCCESS;
   }

   InterlockedIncrement(&pServerEntry->Server.SmbsReceivedSinceLastStrobe);

   // Initialize the copy data buffer and size to begin with.
   *pDataBufferPointer = NULL;
   *pDataBufferSize    = 0;

   // Map the MID to the associated exchange.
   if (pSmbHeader->Command == SMB_COM_NEGOTIATE) {
       pExchange = SmbResetServerEntryNegotiateExchange(pServerEntry);
       if (pExchange != NULL) {
           SmbCeDecrementPendingLocalOperations(pExchange);
       }
   } else {
       pExchange = SmbCeMapMidToExchange(pServerEntry,pSmbHeader->Mid);
   }

   RxMiniSniffer(MRxSmbMiniSniffReceive,pServerEntry,BytesIndicated,pExchange,pSmbHeader);

   // check if the return command matches the send command, or command+1 on secondary transact case
   if ((pExchange != NULL) &&
       (pSmbHeader->Command != SMB_COM_NT_CANCEL) &&
       (pExchange->SmbCommand != pSmbHeader->Command) &&
       (pExchange->SmbCommand != pSmbHeader->Command + 1)) {
       ASSERT(FALSE);

       RxLog(("SmbCeReceiveInd: Invalid Response for %lx\n",pServerEntry));
       SmbLogError(STATUS_UNSUCCESSFUL,
                   LOG,
                   SmbCeReceiveInd,
                   LOGPTR(pServerEntry)
                   LOGUSTR(pServerEntry->Name));
       *pBytesTaken = BytesIndicated;
       return STATUS_SUCCESS;
   }
   
   // Note that the absence of a request entry cannot be asserted. It is conceivable that
   // requests could have been cancelled.
   if ((pExchange != NULL) &&
       (SmbCeIncrementPendingOperations(
               pExchange,
               (SMBCE_LOCAL_OPERATION | SMBCE_COPY_DATA_OPERATION),
               __FILE__,
               __LINE__) == STATUS_SUCCESS)) {
      // Invoke the receive indication handler
      Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                     Receive,
                                     (pExchange,
                                      BytesIndicated,
                                      BytesAvailable,
                                      pBytesTaken,
                                      pTsdu,
                                      pDataBufferPointer,
                                      pDataBufferSize,
                                      ReceiveFlags));

      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,*pBytesTaken);

      RxDbgTrace(0, Dbg, ("SmbCeReceiveInd: SMB_EXCHANGE_DISPATCH returned %lx,taken/mdl=%08lx/%08lx\n",
                                          Status,*pBytesTaken,*pDataBufferPointer));
      ASSERT ( (Status==RX_MAP_STATUS(MORE_PROCESSING_REQUIRED))==((*pDataBufferPointer)!=NULL));

      if (Status == RX_MAP_STATUS(MORE_PROCESSING_REQUIRED)) {
         Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,*pDataBufferPointer);
         if (Status != STATUS_SUCCESS) {
            DbgPrint("VctIndReceive:Error handling copy data request %lx\n",Status);
            pExchange->Status = Status;
            *pBytesTaken = BytesAvailable;
            Status = STATUS_SUCCESS;
         } else {
            Status = RX_MAP_STATUS(MORE_PROCESSING_REQUIRED);
         }
      }

      if (Status != RX_MAP_STATUS(MORE_PROCESSING_REQUIRED)) {
         SmbCeDecrementPendingCopyDataOperations(pExchange);
      } else {
          // Update the expiry time on the exchange if required.
          SmbCeSetExpiryTime(pExchange);
      }

      SmbCeDecrementPendingReceiveOperations(pExchange);

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

      if (((*pBytesTaken + *pDataBufferSize) < BytesAvailable)  &&
          (Status != RX_MAP_STATUS(MORE_PROCESSING_REQUIRED))) {
         RxDbgTrace(0,Dbg,("SmbCeReceiveInd:Not consuming all indicated data\n"));
         *pBytesTaken = BytesAvailable;
      }
   } else {
      // Should we change over to a strategy in which the transport pipeline is kept
      // open by consuming all indicated data
      // DbgBreakPoint();
      RxLog(("SmbCeReceiveInd:No resumption context %lx\n",pServerEntry));
      SmbLogError(STATUS_UNSUCCESSFUL,
                  LOG,
                  SmbCeReceiveInd_3,
                  LOGXSHORT(pSmbHeader->Mid)
                  LOGPTR(pServerEntry)
                  LOGUSTR(pServerEntry->Name));
      Status = STATUS_SUCCESS;
      *pBytesTaken = BytesAvailable;
   }

   ASSERT((*pBytesTaken + *pDataBufferSize) >= BytesAvailable);
   //ASSERT(*pBytesTaken <= BytesIndicated);

   ASSERT(Status == STATUS_SUCCESS ||
          Status == STATUS_DATA_NOT_ACCEPTED ||
          Status == STATUS_MORE_PROCESSING_REQUIRED);
   return Status;
}


NTSTATUS
SmbCeDataReadyInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL                  pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus
   )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pServerEntry  - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS      Status;
   PSMB_EXCHANGE pExchange;

   // Map the buffer to the exchange
   pExchange = SmbCeGetExchangeAssociatedWithBuffer(pServerEntry,pBuffer);

   RxDbgTrace(0, Dbg, ("VctIndDataReady: Processing Exchange %lx\n",pExchange));
   if (pExchange != NULL) {
      if (CopyDataStatus == STATUS_SUCCESS) {
         // Notify the exchange of the completion
         //ExInterlockedAddLargeStatistic(&MRxSmbStatistics.SmbsReceived,1);
         ExInterlockedAddLargeStatistic(&MRxSmbStatistics.BytesReceived,DataSize);
         SMB_EXCHANGE_DISPATCH(
                           pExchange,
                           CopyDataHandler,
                           (pExchange,pBuffer,DataSize));
      } else {
          pExchange->Status    = CopyDataStatus;
          pExchange->SmbStatus = CopyDataStatus;
      }

      // Resume the exchange that was waiting for the data.
      SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange);
   } else {
      // The data MDL is part of the exchange, which should be freed with the exchange.
      ASSERT(FALSE);
   }

   return STATUS_SUCCESS;
}

NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
   NTSTATUS                 Status;
   PSMB_EXCHANGE            pExchange;

   DbgPrint("@@@@@@ Error Indication for %lx @@@@@\n",pServerEntry);
   SmbLogError(IndicatedStatus,
               LOG,
               SmbCeErrorInd,
               LOGULONG(IndicatedStatus)
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));
   InterlockedIncrement(&MRxSmbStatistics.NetworkErrors);
   // Post to the worker queue to resume all the outstanding requests
   pServerEntry->ServerStatus = IndicatedStatus;
   SmbCeReferenceServerEntry(pServerEntry);
   Status = RxDispatchToWorkerThread(
                  MRxSmbDeviceObject,
                  CriticalWorkQueue,
                  SmbCeResumeAllOutstandingRequestsOnError,
                  pServerEntry);
   if (Status != STATUS_SUCCESS) {
      DbgPrint("Error Indication not dispatched\n");
      RxLog(("SmbCeErrorInd(SE) %lx\n", pServerEntry));
   }

   return STATUS_SUCCESS;
}


NTSTATUS
SmbCeSendCompleteInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PVOID                 pCompletionContext,
   IN NTSTATUS              SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pServerEntry - the server instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
   NTSTATUS      Status;

   PSMB_EXCHANGE pExchange;
   PVOID         pSendBuffer = pCompletionContext;

   if (pCompletionContext != NULL) {
      // Map the MID to the associated exchange
      pExchange = SmbCeGetExchangeAssociatedWithBuffer(
                        pServerEntry,
                        pSendBuffer);

      if (pExchange != NULL) {
         // Resume the exchange which was waiting for this response
         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: Send Completion Status %lx\n",SendCompletionStatus));

         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                           SendCompletionHandler,
                                           (pExchange,
                                            pSendBuffer,
                                            SendCompletionStatus));
         }

         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: SMB_EXCHANGE_DISPATCH returned %lx\n",Status));

         SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange);
      }
   }

   return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

RDR2=$(PROJECT_ROOT)\fs\rdr2
!INCLUDE $(RDR2)\rdbss\master.src

MAJORCOMP=ntos
MINORCOMP=mrxsmb

TARGETNAME=mrxsmb
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

!if "$(DS_BUILD)" == "1"
#DSINC=..
!endif
INCLUDES=\
    $(INCLUDES);\
    $(RDR2)\inc;\
    $(RDR2)\rdbss\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    ..;\
    $(RDR2)\bowser;\
    $(DS_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(NET_INC_PATH);\
    $(IFSKIT_INC_PATH)

TARGETLIBS=\
    ..\..\..\bowser\$(O)\bowser.lib \
    $(RDR2)\rdbss\daytona\$(O)\rdbss.lib  \
    $(DDK_LIB_PATH)\ksecdd.lib \
    $(DDK_LIB_PATH)\tdi.lib \
    $(RDR2)\rdbss\smb.mrx\rdrssp\$(O)\rdrssp.lib\
    $(DS_LIB_PATH)\rsa32k.lib \
    $(RDR2)\wmi\$(O)\wmlkm.lib


NTLAYGO=1

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS -DDS_BUILD -D_PNP_POWER_
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF

# merge RSA32K.LIB paged code & data into non-paged sections.
LINKER_FLAGS=$(LINKER_FLAGS) -merge:PAGER32C=.text -merge:PAGER32D=.data -merge:PAGER32R=.rdata


MOST_SOURCES=       \
    ..\devfcb.c   \
    ..\ea.c       \
    ..\exsessup.c \
    ..\fileinfo.c \
    ..\downlvli.c \
    ..\fsctl.c    \
    ..\init.c     \
    ..\locks.c    \
    ..\midatlas.c \
    ..\mm.c \
    ..\mssndrcv.c \
    ..\netroot.c  \
    ..\ntsecure.c \
    ..\openclos.c \
    ..\downlvlo.c \
    ..\read.c     \
    ..\rename.c   \
    ..\recursvc.c \
    ..\sessetup.c \
    ..\smb64.c    \
    ..\smbadmin.c \
    ..\smbcedb.c  \
    ..\smbcemid.c \
    ..\smbsecur.c \
    ..\smbutils.c \
    ..\smbxchng.c \
    ..\sndrcv.c   \
    ..\srvcall.c  \
    ..\smbpse.c   \
    ..\stuffer.c  \
    ..\stfftest.c \
    ..\transprt.c \
    ..\transact.c \
    ..\vcsndrcv.c \
    ..\write.c    \
    ..\manipmdl.c \
    ..\3connect.c \
    ..\ntbowsif.c \
    ..\usrcnnct.c \
    ..\vnrcntxt.c \
    ..\reconnct.c \
    ..\infocach.c \


PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=$(O)\mrxsmb.def
MISCFILES=smbrdr.sld

!if "$(NO_BUILD_SMBMINI_FOR_CSC)" != "1"
CSC=$(RDR2)\csc
RECORD_MAN=$(CSC)\record.mgr

TARGETLIBS=$(TARGETLIBS)\
    $(RDR2)\rdbss\smb.mrx\csc.nt5\$(O)\nt5csc.lib\
    $(RECORD_MAN)\daytona\$(O)\rec_mngr.lib

C_DEFINES=$(C_DEFINES) -DMRXSMB_BUILD_FOR_CSC


!if "$(NO_BUILD_SMBMINI_FOR_CSC_DCON)" != "1"
C_DEFINES=$(C_DEFINES) -DMRXSMB_BUILD_FOR_CSC_DCON
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\smb.mrx\srvcall.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeCreateSrvCall)
#pragma alloc_text(PAGE, MRxSmbCreateSrvCall)
#pragma alloc_text(PAGE, MRxSmbFinalizeSrvCall)
#pragma alloc_text(PAGE, MRxSmbSrvCallWinnerNotify)
#pragma alloc_text(PAGE, MRxSmbInitializeEchoProbeService)
#pragma alloc_text(PAGE, MRxSmbTearDownEchoProbeService)
#pragma alloc_text(PAGE, MRxSmbMaskNegotiateSmb)
#pragma alloc_text(PAGE, BuildNegotiateSmb)
#endif

RXDT_DefineCategory(SRVCALL);
#define Dbg        (DEBUG_TRACE_SRVCALL)

extern BOOLEAN MRxSmbSecuritySignaturesEnabled;
extern BOOLEAN MRxSmbSecuritySignaturesRequired;

VOID
SmbCeCreateSrvCall(
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure;
    PMRX_SRV_CALL pSrvCall;

    PAGED_CODE();

    SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    SmbCeInitializeServerEntry(
        pSrvCall,
        pCallbackContext,
        SrvCalldownStructure->RxContext->Create.TreeConnectOpenDeferred);
}


NTSTATUS
MRxSmbCreateSrvCall(
    PMRX_SRV_CALL                  pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Certain transport related interfaces require handle to be passed in. This
    implies that the SRV_CALL instances need to be initialized in the context
    of a well known process, i.e., the RDBSS process.

    In the normal course of event is this request was issued within the context
    of the system process we should continue without having to post. However
    there are cases in MIPS  when stack overflows. In order to avoid such situations
    the request is posted in all cases.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING ServerName;

    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCa