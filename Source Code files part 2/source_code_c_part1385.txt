ESULT hr;
    VARIANT var;

    // get the control's property
    VariantInit(&var);
    hr = GetProperty(uGetOffset, dispid, VT_UNKNOWN, &var);
    if (hr || (var.vt != VT_UNKNOWN && var.vt != VT_DISPATCH) || var.punkVal==0)
    {
        if (hr)
            VariantInit(&var);      // control might mess with var before failing
        goto Cleanup;
    }

    // get the desired interface
    hr = var.punkVal->QueryInterface(riid, (void**)ppunk);

Cleanup:
    VariantClear(&var);
    return hr;
}


#define VALID_VTABLE_OFFSET(off) ((off) && (off)!=~0UL)

//+-------------------------------------------------------------------------
// Function:    Get Property (protected helper)
//
// Synopsis:    fetch a property value
//
// Arguments:   uVTableOffsetGet    VTable offset for Get method (or "invalid")
//              dispidGet           dispid for property
//              vtType              type of property
//              pvar                variant into which value is placed
//
// Returns:     HRESULT

HRESULT
COleSite::GetProperty(UINT uVTableOffsetGet, DISPID dispidGet, VARTYPE vtType,
                        VARIANT* pVar)
{
    Assert(pVar);
    HRESULT hr;

    VariantInit(pVar);

    if (VALID_VTABLE_OFFSET(uVTableOffsetGet) && IsVTableValid())
    {   // use the VTable binding to read from the control.
        hr = VTableDispatch(_pDisp, vtType, VTBL_PROPGET,
                            (vtType == VT_VARIANT) ?
                                (void *) pVar :
                                (void *) &pVar->iVal,
                            uVTableOffsetGet);
        if (!hr && vtType != VT_VARIANT)
        {
            pVar->vt = vtType;
        }
    }
    
    else
    {   // use Invoke to read from the control
        EXCEPINFO   except;

        // If the dispatch isn't valid then we can't even begin to bind.
        CacheDispatch();
        if (!_pDisp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        InitEXCEPINFO(&except);
        hr = THR(GetDispProp(_pDisp,
                             dispidGet,
                             g_lcidUserDefault,
                             pVar,
                             &except));
        FreeEXCEPINFO(&except);
    }

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Set Property (public helper)
//
// Synopsis:    store a property value
//
// Arguments:   uVTableOffsetSet    VTable offset for Set method (or "invalid")
//              dispidSet           dispid for property
//              var                 variant into which value is placed
//
// Returns:     HRESULT

HRESULT
COleSite::SetProperty(UINT uVTableOffsetSet, DISPID dispidSet,
                     VARTYPE vtType, VARIANT *pVar)
{
    HRESULT hr;

    if (VALID_VTABLE_OFFSET(uVTableOffsetSet) && IsVTableValid())
    {   // use the VTable binding to write to the control.
        VARIANT     vCopy;
        VARIANT *   pVarPass = pVar;

        // Ensure the value in the variant (pVar) is the same type as the
        // property expects.
        if ((vtType != VT_VARIANT) && (vtType != pVarPass->vt))
        {
            vCopy.vt = VT_EMPTY;
            pVarPass = &vCopy;
            VariantChangeTypeEx(pVarPass, pVar, g_lcidUserDefault, 0, vtType);
        }

        // send the value to the control
        hr = VTableDispatch(_pDisp, vtType, VTBL_PROPSET,
                            (vtType == VT_VARIANT) ?
                                (void *) pVarPass :
                                (void *) &pVarPass->iVal,
                            uVTableOffsetSet);

         // free variant if we made a copy.
        if (pVarPass != pVar)
        {
            THR(VariantClear(pVarPass));
        }
    }
    
    else
    {   // use Invoke to read from the control
        EXCEPINFO   except;

        // If the dispatch isn't valid then we can't even begin to bind.
        CacheDispatch();
        if (!_pDisp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        InitEXCEPINFO(&except);
        hr = THR(SetDispProp(_pDisp,
                             dispidSet,
                             g_lcidUserDefault,
                             pVar,
                             &except));
        FreeEXCEPINFO(&except);
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::IsVTableValid
//
//  Synopsis:   If the control offers a default (dual) interface, replace
//              my _pDisp with a pointer to the default interface.
//
//  Returns:    TRUE        _pDisp can be used for vtable-style interface
//              FALSE       _pDisp cannot be used for vtable, only for IDispatch
//
//  Note:       This function loads the control's typeinfo.  Don't call it unless
//              you really plan to use vtable offsets.
//
//-------------------------------------------------------------------------

BOOL
COleSite::IsVTableValid()
{
    HRESULT     hr;
    CLASSINFO * pci = GetClassInfo();
    IDispatch * pDisp;

    if (pci == NULL)
        goto Cleanup;
    
    if (!_fVTableCached && _pUnkCtrl)
    {
        hr = QueryControlInterface(pci->iidDefault, (void **)&pDisp );
        if (SUCCEEDED(hr))
        {
            ReplaceInterface(&_pDisp, pDisp);
            ReleaseInterface(pDisp);
            _fDispatchCached = TRUE;
        }
        else
        {
            // If we can't actually get the default interface, then we shouldn't
            // consider this control to be DUAL interface anymore.
            // This is probably because we're dealing with a control that's not
            // threadsafe.
            pci->ClearFDualInterface();
        }
    }

    _fVTableCached = TRUE;

Cleanup:
    return pci ? pci->FDualInterface() : FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     VTableDispatch
//
//  Synopsis:   Set/Get the control property of the current object
//              via dual interface VTable binding.
//
//  Arguments:  propType        - the VT_nnn property type -- this had better
//                                be the correct proptype for this control
//                                property.
//              propDirection   - set the property or get the property
//              pData           - pointer to Data of a type that better match
//                                the propType argument
//                                assumed to have inspected CLASSINFO).
//              uVTblOffset     - v-table offset from pDispatch in bytes
//
//  Returns:    S_OK                    everything is fine
//              E_xxxx                  other errors from the property function
//                                      being called
//

typedef HRESULT (STDMETHODCALLTYPE *OLEVTblFunc)(IDispatch *, void*);

HRESULT
COleSite::VTableDispatch (IDispatch *pDisp,
                            VARTYPE propType,
                            VTBL_PROP propDirection,
                            void *pvData,
                            unsigned int uVTblOffset)
{
    OLEVTblFunc             pVTbl;
    HRESULT                 hr = E_FAIL;

    if (pDisp==NULL)
        goto Cleanup;

    Assert((propDirection == VTBL_PROPSET) || (propDirection == VTBL_PROPGET));
    Assert(VALID_VTABLE_OFFSET(uVTblOffset));
    Assert(pvData);
    if (!pvData)                         // in case we proceed past asssertion.
        goto Cleanup;

    pVTbl = *(OLEVTblFunc *)(((BYTE *)(*(DWORD_PTR *)pDisp)) + uVTblOffset);

    if (propDirection == VTBL_PROPSET)
    {
        AssertSz(!(propType & ~VT_TYPEMASK) ||
                    ((propType & VT_BYREF) && (VT_VARIANT == (propType & VT_TYPEMASK))),
                "Unsupported by-ref property put - base type isn't VARIANT");

        switch (propType & VT_TYPEMASK)
        {
            case VT_I2:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, short)) pVTbl)
                    (pDisp, *(short*)pvData);
                break;
            case VT_I4:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, long)) pVTbl)
                    (pDisp, *(long *)pvData);
                break;
            case VT_R4:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, float)) pVTbl)
                    (pDisp, *(float *)pvData);
                break;
            case VT_R8:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, double)) pVTbl)
                    (pDisp, *(double *)pvData);
                break;
            case VT_CY:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, CY)) pVTbl)
                    (pDisp, *(CY *)pvData);
                break;
            case VT_DATE:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, DATE)) pVTbl)
                    (pDisp, *(DATE *)pvData);
                break;
            case VT_BSTR:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, BSTR)) pVTbl)
                    (pDisp, *(BSTR *)pvData);
                break;
            case VT_BOOL:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, boolean)) pVTbl)
                    (pDisp, *(boolean *)pvData);
                break;
            case VT_VARIANT:
                if (propType & VT_BYREF)
                {
                    hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, VARIANT*)) pVTbl)
                        (pDisp, (VARIANT *)pvData);
                }
                else
                {
                    hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, VARIANT)) pVTbl)
                        (pDisp, *(VARIANT *)pvData);
                }
                break;
            case VT_UNKNOWN:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, IUnknown*)) pVTbl)
                    (pDisp, *(IUnknown **)pvData);
                break;
            case VT_DISPATCH:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, IDispatch*)) pVTbl)
                    (pDisp, *(IDispatch **)pvData);
                break;
            case VT_ERROR:
            case VT_EMPTY:
            case VT_NULL:
            default:
                Assert(!"Unsupported dual interface type.");
                hr = E_FAIL;
                break;
        }
    }
    else    // propDirection == VTBL_PROPGET
    {
        switch (propType & VT_TYPEMASK)
        {
        default:
            hr = (*pVTbl) (pDisp, pvData);
            break;
            
        // Following types not supported.
        case VT_ERROR:
        case VT_EMPTY:
        case VT_NULL:
            hr = E_FAIL;
            break;
        }
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\olecpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       olecpc.cxx
//
//  Contents:   Connection point container implementation for COleSite.
//
//  History:
//              5-22-95     KFL     stubbed MAC functions/macros ForwardToOutSink and
//                                  SINK_METHOD
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

extern "C" const IID IID_IDATASRCListener;
extern "C" const IID IID_IDatasrcChangeEvents;

//+---------------------------------------------------------------------------
//
//  Member:     COleSiteCPC::COleSiteCPC
//
//  Synopsis:   ctor.  Makes a local copy of the CONNECTION_POINT_INFO,
//              inserting the control's source event interfaces.
//
//  Arguments:  [pOleSite]    -- The site.
//              [pUnkPrivate] -- The private unknown of the control.
//
//----------------------------------------------------------------------------

COleSiteCPC::COleSiteCPC(COleSite *pOleSite, IUnknown *  pUnkPrivate)
        :
        super(pOleSite, NULL)
{
    const CBase::CLASSDESC *        pclassdesc;
    const CONNECTION_POINT_INFO *   pcpi;
    long                            i;

    pclassdesc = pOleSite->BaseDesc();
    
    for (i = 0, pcpi = pclassdesc->_pcpi; pcpi && pcpi->piid; i++, pcpi++)
    {
        _acpi[i].piid = pcpi->piid;
        _acpi[i].dispid = pcpi->dispid;
    }

    //
    // If this assert fires, then the classdescs for things derived from
    // COleSite are messed up. (anandra)
    //
    
    Assert(i == 6 || _acpi[CPI_OFFSET_OLESITECONTROL].piid == NULL);                     
    
    //
    // Assert that the last entry in the acpi array is IID_NULL
    //

    if (_acpi[CPI_OFFSET_OLESITECONTROL].piid)
    {
        Assert(IsEqualIID(IID_NULL, *(_acpi[CPI_OFFSET_OLESITECONTROL].piid)));
        _acpi[CPI_OFFSET_OLESITECONTROL].piid = pOleSite->GetpIIDDispEvent();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::EnsurePrivateSink
//
//  Synopsis:   Ensures that we are sinking events on the control's
//              primary event interface.
//
//----------------------------------------------------------------------------

// after COleSite::EnsureControlSink is executed, COleSiteEventSink OSES, which
// is allocated on stack, goes away. However, the sink is supposed to be alive as
// event will be firing in it, namely using it's vtable. The code below still works
// because the only thing used of OSES is it's vtable pointer, and the object does not
// have any state (data memebers) at all. Should COleSiteEventSink get any state, the code
// below should be changed such that OSES does not go away.

StartupAssert(sizeof(void *) == sizeof(COleSiteEventSink));

void
COleSite::EnsurePrivateSink()
{
    HRESULT             hr = S_OK;
    COleSiteEventSink   OSES;
    DWORD_PTR           dwSink;
    BOOL                fScriptEnabled = FALSE;
    
    // If the control isn't yet created, or if isn't in a markup, don't
    // connect the event sink yet.
	if (!_pUnkCtrl || !IsInMarkup())
		return;

    // If scripting is disabled, don't hook up the private event sink.
    IGNORE_HR(GetMarkupPtr()->ProcessURLAction( 
        URLACTION_SCRIPT_RUN, 
        &fScriptEnabled));

    if (!fScriptEnabled)
        return;

    SetEventsShouldFire();

    dwSink = *(DWORD_PTR *)&OSES;

    //
    // Assert that either we've not initialized the event sink yet
    // or if we have then the event sink vtable is the same as the old
    // event sink.
    //
    
    Assert(!_dwEventSinkIn || _dwEventSinkIn == dwSink);

    if (_dwEventSinkIn)
        return;
        
    _dwEventSinkIn |= dwSink;

    Assert(_pUnkCtrl);

    hr = THR(ConnectSink(
            _pUnkCtrl,
            *GetpIIDDispEvent(),
            (IUnknown *) &_dwEventSinkIn,
            &_dwEventSinkCookie));

    if (OK(hr))
    {
        _fPrimaryConnection = TRUE;
    }

    if (!OK(hr))
    {
        //
        // Failed with primary iid, try IDispatch.
        //

        hr = THR(ConnectSink(
                _pUnkCtrl,
                IID_IDispatch,
                (IUnknown *) &_dwEventSinkIn,
                &_dwEventSinkCookie));

        if (hr)
            _dwEventSinkIn = 0;
    }
}


//+------------------------------------------------------------------------
//
//  Connection point sinks implementations.
//
//-------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(COleSiteEventSink, COleSite, _dwEventSinkIn)

//+---------------------------------------------------------------------------
//
//  Member:     COleSiteEventSink::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSiteEventSink::QueryInterface(REFIID iid, void ** ppv)
{
    IID* pIIDDispEvent;

    if (ppv)
        *ppv = NULL;

    if (MyCOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown  ||
        iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else
    {
        pIIDDispEvent = MyCOleSite()->GetpIIDDispEvent();
        if (pIIDDispEvent && iid == *pIIDDispEvent)
        {
            *ppv = (IDispatch *) this;
        }
        else
        {
            *ppv = NULL;
            RRETURN_NOTRACE(E_NOINTERFACE);
        }
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSiteEventSink::Invoke
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------
#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif

STDMETHODIMP
COleSiteEventSink::Invoke(
        DISPID              dispidMember,
        REFIID              riid,
        LCID                lcid,
        WORD                wFlags,
        DISPPARAMS FAR*     pdispparams,
        VARIANT FAR*        pvarResult,
        EXCEPINFO FAR*      pexcepinfo,
        UINT FAR*           puArgErr)
{
    HRESULT         hr = S_OK;
    CMessage        Message(NULL, 0, 0, 0);
    POINT           pt;
    CTreeNode *     pNodeParent;
    ITypeInfo *     pTIEvent;

#if DBG==1
    COleSite *  pMyCOleSiteDbg = MyCOleSite();
#endif

    if (MyCOleSite()->IllegalSiteCall(0))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!MyCOleSite()->IsSafeToScript())
        goto Cleanup;


    //
    // Refire event to any listening sinks out there.  Includes any hooked up
    // function pointers.
    //

    // Find the event name that corresponds to this event (used for fast event hookup).
    pTIEvent = MyCOleSite()->GetClassInfo()->_pTypeInfoEvents;

    IGNORE_HR(MyCOleSite()->InvokeEvent(
        dispidMember,
        dispidMember,
        NULL,
        pvarResult,
        pdispparams,
        pexcepinfo,
        puArgErr,
        pTIEvent));

    //
    // For the standard events, we will recalculate parameters to send
    // because arbitrary objects may use different coordinates than the
    // ones that we want.
    //

    switch (dispidMember)
    {
    case DISPID_CLICK:
    case DISPID_DBLCLICK:
        goto FireStdMessage;

    case DISPID_MOUSEMOVE:
        Message.message = WM_MOUSEMOVE;
        goto FireStdMessage;

    case DISPID_MOUSEDOWN:
        Message.message = 
            (Message.dwKeyState & MK_LBUTTON) ? WM_LBUTTONDOWN :
                (Message.dwKeyState & MK_RBUTTON) ? WM_RBUTTONDOWN : 
                    WM_MBUTTONDOWN;
        goto FireStdMessage;

    case DISPID_MOUSEUP:
        Message.message = 
            (Message.dwKeyState & MK_LBUTTON) ? WM_LBUTTONUP :
                (Message.dwKeyState & MK_RBUTTON) ? WM_RBUTTONUP : 
                    WM_MBUTTONUP;
        goto FireStdMessage;

FireStdMessage:
        hr = THR( Message.SetNodeHit( MyCOleSite()->GetFirstBranch() ) );
        if( hr )
            goto Cleanup;
        GetCursorPos(&pt);
        ScreenToClient(MyCOleSite()->Doc()->_pInPlace->_hwnd, &pt);
        Message.pt = pt;
        Message.wParam = Message.dwKeyState;
        Message.lParam = MAKELPARAM(Message.pt.x, Message.pt.y);

        //
        // Find the first element parent which can fire events
        //
        
        if (MyCOleSite()->GetFirstBranch())
        {
            pNodeParent = MyCOleSite()->GetFirstBranch()->Parent();
        
            if (pNodeParent)
            {
                if (DISPID_CLICK == dispidMember)
                {
                    IGNORE_HR(pNodeParent->Element()->Fire_onclick(pNodeParent));
                }
                else if (DISPID_DBLCLICK == dispidMember)
                {
                    IGNORE_HR(pNodeParent->Element()->Fire_ondblclick(pNodeParent));
                }
                else
                {
                    IGNORE_HR(pNodeParent->Element()->FireStdEventOnMessage(pNodeParent, &Message, pNodeParent));
                }
            }
        }
        break;
    }

Cleanup:
    RRETURN( hr );
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\olebindh.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

ExternTag(tagOleSiteClient);

MtDefine(CProgressBindStatusCallback, Dwn, "CProgressBindStatusCallback")

//+---------------------------------------------------------------------------
//
//  Member:     CLock::CLock
//
//  Synopsis:   ctor/dtor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::CLock::CLock(CProgressBindStatusCallback *pBSC)
{
    _pBSC = pBSC;
    _pBSC->AddRef();
}


CProgressBindStatusCallback::CLock::~CLock()
{
    _pBSC->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::CProgressBindStatusCallback
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::CProgressBindStatusCallback()
{
    _ulRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::~CProgressBindStatusCallback
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::~CProgressBindStatusCallback()
{
    if (_dwProgCookie)
    {
        Assert( _pProgSink );
        _pProgSink->DelProgress(_dwProgCookie);
    }

    if (_pMarkup)
    {
        _pMarkup->SubRelease();
    }
    ReleaseInterface(_pProgSink);
    ReleaseInterface(_pBSCChain);
    ReleaseInterface(_pBCtx);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::Init
//
//  Synopsis:   initializer
//
//----------------------------------------------------------------------------

HRESULT
CProgressBindStatusCallback::Init(
    CMarkup *               pMarkup, 
    DWORD                   dwCompatFlags,
    IBindStatusCallback *   pBSCChain,
    IBindCtx *              pBCtx)
{
    HRESULT hr = S_OK;

    Assert( pMarkup );
    if (!pMarkup->GetDwnDoc())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    _pMarkup = pMarkup;
    _pMarkup->SubAddRef();
    
    _dwCompatFlags = dwCompatFlags;
    _dwBindf = pMarkup->GetDwnDoc()->GetBindf();
    
    ReplaceInterface(&_pBCtx, pBCtx);
    ReplaceInterface(&_pBSCChain, pBSCChain);
    
    _pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
    if( _pProgSink )
    {
        _pProgSink->AddRef();
    
        //
        // If we failed to add this to the progress loader, it's ok to
        // continue loading.
        //
    
        IGNORE_HR(_pProgSink->AddProgress(PROGSINK_CLASS_OTHER, &_dwProgCookie));
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::Terminate
//
//  Synopsis:   Kills the download.
//
//----------------------------------------------------------------------------

void
CProgressBindStatusCallback::Terminate()
{
    CLock   Lock(this);

    if (_pBinding)
    {
        _pBinding->Abort();
    }
    ClearInterface(&_pBinding);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::QueryInterface
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;        
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    
    RRETURN(E_NOINTERFACE);
}


STDMETHODIMP
CProgressBindStatusCallback::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;
    IServiceProvider *pServiceProvider = NULL;

    // The CProgressBindStatusCallback doesn't have any interesting service to
    // offer here (yet), but our client might.
    if (_pBSCChain)
    {
        hr = _pBSCChain->QueryInterface(IID_IServiceProvider,
                                        (void **)&pServiceProvider);
        if (S_OK == hr)
        {
            hr = pServiceProvider->QueryService(guidService, iid, ppv);
        }
        ReleaseInterface(pServiceProvider);
    }

    if( FAILED( hr ) && _pMarkup)
    {
        CDocument * pDocument;

        // Try the CDocument and the CDoc.  
        // This is here specifically so that javascript:
        // URLs will work from plugins.  This also provides handy
        // connectivity that may be useful elsewhere.
        // Since CDocument delegates to CDoc if it does not handle the
        // guidService, we don't have to have additional logic here.

        hr = _pMarkup->EnsureDocument(&pDocument);
        if (hr)
            goto Cleanup;

        Assert(pDocument);

        hr = pDocument->QueryService(guidService, iid, ppv);
    }

Cleanup:
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnStartBinding
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnStartBinding(
    DWORD dwReserved, 
    IBinding *pBinding)
{
    ReplaceInterface(&_pBinding, pBinding);

    IGNORE_HR(pBinding->SetPriority(THREAD_PRIORITY_BELOW_NORMAL));

    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnStartBinding(dwReserved, pBinding)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::GetPriority
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP        
CProgressBindStatusCallback::GetPriority(LONG *pnPriority)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->GetPriority(pnPriority)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnLowResource
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnLowResource(dwReserved)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnProgress
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnProgress(
    ULONG   ulProgress,
    ULONG   ulProgressMax,
    ULONG   ulStatusCode,
    LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if ((ulStatusCode == BINDSTATUS_REDIRECTING) &&  
        (_dwCompatFlags & COMPAT_SECURITYCHECKONREDIRECT) &&
        _pMarkup && !_pMarkup->AccessAllowed(szStatusText))
    {
        static const IID IID_IAmTheTDC = {0x3050f6c2,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
        IUnknown *pTDC;
        if (_pBSCChain && S_OK == _pBSCChain->QueryInterface(IID_IAmTheTDC, (void**)&pTDC))
        {
            // bug 85290 - TDC control handles its own cross-domain security,
            // so downloads on its behalf should not be aborted
            ReleaseInterface(pTDC);
        }
        else
        {
            if (_pBinding)
                _pBinding->Abort();
            _fAbort = TRUE;
        }
    }

    if (_dwProgCookie && ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)
    {
        Assert( _pProgSink );
        hr = THR(_pProgSink->SetProgress( 
                _dwProgCookie, 
                PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_MAX | PROGSINK_SET_TEXT,
                PROGSINK_STATE_LOADING, 
                szStatusText,
                0,
                ulProgress, 
                ulProgressMax));
        if (hr)
            goto Cleanup;
    }

    if (_pBSCChain)
    {
        hr = THR(_pBSCChain->OnProgress(
                ulProgress, 
                ulProgressMax, 
                ulStatusCode, 
                szStatusText));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnStopBinding
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    HRESULT hr;
    
    CLock   Lock(this);

    ClearInterface(&_pBinding);
    if (_pMarkup && _pMarkup->Doc())
    {
        _pMarkup->Doc()->_aryChildDownloads.DeleteByValue(this);
    }
    
    hr = _pBSCChain ? 
        THR(_pBSCChain->OnStopBinding(hresult, szError)) :
        S_OK;
    if (hr)
        goto Cleanup;

    hr = THR(RevokeBindStatusCallback(_pBCtx, this));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::GetBindInfo
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo)
{
    HRESULT     hr = S_OK;
    
    if (!pbindinfo)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Prime the BINDF flags from our Doc's bind ctx flags.  This informs the 
    // object what BINDF we are using.
    *grfBINDF |= _dwBindf; 

    if (_pBSCChain)
    {
        hr = THR(_pBSCChain->GetBindInfo(grfBINDF,pbindinfo));
        if (hr)
            goto Cleanup;
            
        if (_dwCompatFlags & COMPAT_NO_BINDF_OFFLINEOPERATION)
        {
            //
            // The powerpoint animation viewer always passes in offline 
            // operation.  Obviously this will fail if the requested file
            // is not available in the cache.
            //
            
            *grfBINDF &= ~BINDF_OFFLINEOPERATION;
        }

        // Reapply our BINDF flags just in case they cleared any out.
        *grfBINDF |= _dwBindf; 
    
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnDataAvailable
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC *pformatetc,
    STGMEDIUM *pstgmed)
{
    RRETURN1(_pBSCChain && !_fAbort ? 
        THR(_pBSCChain->OnDataAvailable(grfBSCF, dwSize, pformatetc, pstgmed)) :
        S_OK, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnObjectAvailable
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnObjectAvailable(riid, punk)) :
        S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CreateMoniker, IBindHost
//
//  Synopsis:   Parses display name and returns a URL moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CreateMoniker(LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved)
{
    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED|VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchUrl = cBuf;
    HRESULT     hr;

    hr = THR(CMarkup::ExpandUrl(
            MyOleSite()->IsInMarkup() ? MyOleSite()->GetMarkup()->GetFrameOrPrimaryMarkup() : NULL,
                szName, ARRAY_SIZE(cBuf), pchUrl, MyOleSite()));
    if (hr)
        goto Cleanup;

    TraceTag((tagOleSiteClient, 
        "COleSite::CClient::CreateMoniker SSN=0x%x url=%ls", 
        MyOleSite()->_ulSSN,
        pchUrl));

    hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   MonikerBind
//
//  Synopsis:   Helper routine contains the common code for BindToObject() and
//              BindToStorage().
//
//----------------------------------------------------------------------------

HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk, 
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc, 
    REFIID                  riid, 
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags)
{
    IBindCtx *                      pbcNew = NULL;
    CProgressBindStatusCallback *   pBSCWrap = NULL;
    HRESULT                         hr = S_OK;

    Assert( pMarkup );

    if (!pbc)
    {
        hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pbcNew, 0));
        if (hr)
            goto Cleanup;

        pbc = pbcNew;
    }

    //
    // Create a wrapper bsc which will update our status bar appropriately.
    //
    
    pBSCWrap = new CProgressBindStatusCallback;
    if (!pBSCWrap)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pBSCWrap->Init(
            pMarkup, 
            dwCompatFlags,
            pbsc,
            pbc));
    if (hr)
        goto Cleanup;

    //
    // Register our wrapper bsc into the bind ctx.  This addrefs
    // the bscwrap.  
    //

    hr = THR(RegisterBindStatusCallback(pbc, pBSCWrap, NULL, NULL));
    if (!OK(hr))
        goto Cleanup;
    
    // Add pBSCWrap to the _aryChildDownloads.  If the bind
    // ends up happening synchronous, then it will be removed
    // further down the stack.
    IGNORE_HR(pMarkup->Doc()->_aryChildDownloads.Append(pBSCWrap));

    hr = fObject ? 
        THR(pmk->BindToObject(pbc, NULL, riid, ppv)) :
        THR(pmk->BindToStorage(pbc, NULL, riid, ppv));
    if (!OK(hr))
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pbcNew);

    if (hr != S_ASYNCHRONOUS)
    {
        pMarkup->Doc()->_aryChildDownloads.DeleteByValue(pBSCWrap);
    }
    
    if (pBSCWrap)
    {
        pBSCWrap->Release();
    }
    RRETURN1(hr, S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::MonikerBindToStorage, IBindHost
//
//  Synopsis:   Calls BindToStorage on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::MonikerBindToStorage(
    IMoniker * pmk, 
    IBindCtx * pbc,
    IBindStatusCallback * pbsc, 
    REFIID riid, 
    void ** ppvObj)
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::MonikerBindToStorage SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(
            COleSite::VALIDATE_ATTACHED|COleSite::VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    pici = MyOleSite()->GetInstantClassInfo();
    
    RRETURN1(MonikerBind(
        MyOleSite()->GetWindowedMarkupContext(), 
        pmk, 
        pbc, 
        pbsc, 
        riid, 
        ppvObj, 
        FALSE,
        pici ? pici->dwCompatFlags : 0), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::MonikerBindToObject, IBindHost
//
//  Synopsis:   Calls BindToObject on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::MonikerBindToObject(
    IMoniker * pmk, 
    IBindCtx * pbc,
    IBindStatusCallback * pbsc, 
    REFIID riid, 
    void ** ppvObj)
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::MonikerBindToObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(
            COleSite::VALIDATE_ATTACHED|COleSite::VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    pici = MyOleSite()->GetInstantClassInfo();
    
    RRETURN1(MonikerBind(
        MyOleSite()->GetWindowedMarkupContext(), 
        pmk, 
        pbc, 
        pbsc, 
        riid, 
        ppvObj, 
        TRUE,
        pici ? pici->dwCompatFlags : 0), S_ASYNCHRONOUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\olesite.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       olesite.cxx
//
//  Contents:   Implementation of COleSite class
//
//  Classes:    COleSite
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CODELOAD_HXX_
#define X_CODELOAD_HXX_
#include "codeload.hxx"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef X_OCIDL_H_
#define X_OCIDL_H_
#include <ocidl.h>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx" // for drawplaceholder
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include "vbcursor/ocdb.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"                     // for quickmimegetcsetinfo
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include <dbtask.hxx>       // for CDatabindTask
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_PLUGIN_I_H_
#define X_PLUGIN_I_H_
#include "plugin_i.h"   // IActiveXPlugin interface definition.
#endif

#define _cxx_
#include "olesite.hdl"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#include "shpriv.h"
#include "winspool.h"

MtDefine(COleSiteCLock, Locals, "COleSite::CLock")

#define IDM_BORDERSTYLEFIXED 1000       
#define IDM_BORDERSTYLENO    1001



BEGIN_TEAROFF_TABLE(COleSite, IProvideMultipleClassInfo)
    TEAROFF_METHOD(COleSite, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(COleSite, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(COleSite, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(COleSite, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

DeclareTag(tagIgnoreAWV, "OleSite", "Ignore ActiveWhenVisible bit on controls");
DeclareTag(tagOleSiteRect, "OleSite", "Olesite position trace");
DeclareTag(tagOleSiteAssert, "OleSite", "Former compat list assert; wmp problem");

BEGIN_TEAROFF_TABLE_(COleSite, IServiceProvider)
        TEAROFF_METHOD(COleSite, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

extern TCHAR g_szPropertiesVerb[];
extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

extern BOOL OLECMDIDFromIDM(int idm, ULONG *pulCmdID);
extern HRESULT GetCategoryManager(ICatInformation **ppCat);


#ifndef NO_PROPERTY_PAGE
const CLSID * const COleSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

EXTERN_C CLSID CLSID_AppletOCX;
EXTERN_C const IID IID_IActiveDesigner;
EXTERN_C const CLSID CLSID_Scriptlet;
EXTERN_C const IID IID_IVB5Control = { 0xFCFB3D26, 0xA0FA, 0x1068, 0xA7, 0x38, 0x08, 0x00, 0x2B, 0x33, 0x71, 0xB5 };
EXTERN_C const IID IID_IVB6Control = { 0xe93ad7c1, 0xc347, 0x11d1, 0xa3, 0xe2, 0x00, 0xa0, 0xc9, 0x0a, 0xea, 0x82 };

//
// misc helper functions
//

HRESULT
CLSIDFromHtmlString(TCHAR *pchClsid, CLSID *pclsid)
{
    const TCHAR achClsidPrefix [] = _T("clsid:");
    HRESULT     hr = S_OK;
    TCHAR       achClsid[CLSID_STRLEN + 1];

    // if begins with "clsid:" prefix
    if (pchClsid &&
        _tcsnipre(achClsidPrefix, ARRAY_SIZE(achClsidPrefix)-1, pchClsid, -1))
    {
        achClsid[0] = _T('{');
        _tcsncpy(
            achClsid + 1,
            pchClsid + ARRAY_SIZE(achClsidPrefix) - 1,
            CLSID_STRLEN - 2);
        achClsid[CLSID_STRLEN - 1] = _T('}');
        achClsid[CLSID_STRLEN] = 0;

        hr = THR(CLSIDFromString(achClsid, pclsid));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     OLECREATEINFO::~OLECREATEINFO
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------

COleSite::OLECREATEINFO::~OLECREATEINFO()
{
    MemFreeString(pchSourceUrl);
    MemFreeString(pchDataUrl);
    MemFreeString(pchMimeType);
    MemFreeString(pchClassid);
    MemFreeString(pchFileName);
    ReleaseInterface(pStream);
    ReleaseInterface(pStorage);
    ReleaseInterface(pPropBag);
    ReleaseInterface(pDataObject);
    ReleaseInterface(pStreamHistory);
    ReleaseInterface(pBindCtxHistory);
    ReleaseInterface(pShortCutInfo);
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::COleSite, protected
//
//  Synopsis:   used internally by the static Create methods to
//              initialize site object to a default state
//
//  Arguments:  [pUnkOuter] --  Controlling unknown for this site
//              [pParent]   --  Site that's our parent
//
//  Notes:      can not fail
//
//---------------------------------------------------------------

COleSite::COleSite(ELEMENT_TAG etag, CDoc *pDoc)
    : super(etag, pDoc)
{
    TraceTag((tagCDoc, "constructing COleSite"));
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pAtomTable = NULL;
    _wclsid = 0;
    _fDataSameDomain = TRUE;

#if DBG == 1
    _Client._pMyOleSite = this;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_TEAROFF(this,  IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF((CBase *)this, IOleCommandTarget, NULL)
        QI_TEAROFF_DISPEX(this,  NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            if (_pUnkCtrl)
            {
                COleSiteCPC *   pOleCPC;

                pOleCPC = new COleSiteCPC(this, _pUnkCtrl);
                if (!pOleCPC)
                    RRETURN(E_OUTOFMEMORY);

                (*(IConnectionPointContainer **)ppv) = pOleCPC;

                //
                // Since we just created an ole cpc, it's time to start
                // sinking events from the ocx.
                //

                EnsurePrivateSink();
            }
            break;
        }

        default:
            hr = THR_NOTRACE(super::PrivateQueryInterface(iid, ppv));
            if (OK(hr))
                return S_OK;

            if (_pUnkCtrl)
            {
                void * pvObject;

                if (_fXAggregate)
                {
                    RRETURN(_pUnkCtrl->QueryInterface(iid, ppv));
                }

                hr = THR_NOTRACE(QueryControlInterface(iid, &pvObject));
                if (OK(hr))
                {
                    hr = THR(CreateTearOffThunk(
                            pvObject,
                            *(void **)pvObject,
                            NULL,
                            ppv,
                            (IUnknown *)this,
                            *(void **)(IUnknown *)this,
                            1,      // Call QI on object 2.
                            NULL));
                    ((IUnknown *)pvObject)->Release();
                }
            }
            break;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method : COleSite :: QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//          first QI for IServiceProvider on the control, and pass the QS to that.
//          if it fails, then pass the QS to our super's implementation
//
//-----------------------------------------------------------------------------

HRESULT
COleSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    if (_pUnkCtrl)
    {
        IServiceProvider * pISP = NULL;

        hr = THR_NOTRACE(_pUnkCtrl->QueryInterface(IID_IServiceProvider,
                                                   (void**)&pISP));
        if (hr)
            goto TryElement;

        hr = THR_NOTRACE(pISP->QueryService(guidService, riid, ppvObject));
        ReleaseInterface(pISP);
        if (hr)
            goto TryElement;

        goto Cleanup;
    }


TryElement:
    hr = THR_NOTRACE(super::QueryService(guidService,riid, ppvObject));

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::QueryControlInterface
//
//  Synopsis:   Query the control for an interface.
//              The purpose of this function is to reduce code size.
//
//  Arguments:  iid     Interface to query for
//              ppv     Returned interface
//
//-------------------------------------------------------------------------

HRESULT
COleSite::QueryControlInterface(REFIID iid, void **ppv)
{
    if (_pUnkCtrl)
        return _pUnkCtrl->QueryInterface(iid, ppv);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

#ifdef WIN16
#pragma code_seg( "OLESITE_2_TEXT" )
#endif // WIN16

//+------------------------------------------------------------------------
//
//  Member:     COleSite::InvalidCall
//
//  Synopsis:   Return TRUE if call to client site is illegal.
//
//-------------------------------------------------------------------------

BOOL
COleSite::IllegalSiteCall(DWORD dwFlags)
{
    CDoc *  pDoc = Doc();

    //
    // Step 1: Check to see if object is alive and call is on correct thread.
    //

    if (GetRefs() == 0)
        return TRUE;

    Assert(pDoc);  // Should be set if _pUnkOuter != NULL.

    if (pDoc->_dwTID != GetCurrentThreadId())
    {
        TraceTag((tagError, "ActiveX control called MSHTML across apartment thread boundary (not an MSHTML bug)"));
        return TRUE;
    }

    //
    // Step 2:  Check state of COleSite.
    //

    switch (dwFlags & 0xFF)
    {
    case VALIDATE_WINDOWLESSINPLACE:
        if (!_fWindowlessInplace)
        {
            TraceTag((tagError, "Illegal call to windowless interface by ActiveX control (not an MSHTML bug)"));
            return TRUE;
        }
        break;

    case VALIDATE_INPLACE:
        if (State() < OS_INPLACE)
            return TRUE;
        break;

    case VALIDATE_LOADED:
        if (State() < OS_LOADED || !IsInMarkup())
            return TRUE;
        break;

    case VALIDATE_ATTACHED:
        if (!IsInMarkup())
            return TRUE;
        break;

    case VALIDATE_NOTRENDERING:
        {
            CLayout * pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

            if (pLayout && (   pLayout->GetView()->IsInState(CView::VS_INRENDER)
                            || !!(pLayout->GetView()->GetState() & CView::VS_INLAYOUT)
                           )
                )
                return TRUE;
        }
    }

    //
    // Step 3: Check state of document.
    //

    switch (dwFlags & (0xFF << 8))
    {
    case VALIDATE_DOC_INPLACE:
        if (pDoc->State() < OS_INPLACE)
            return TRUE;
        break;

    case VALIDATE_DOC_SITE:
        if (!pDoc->_pUnkOuter || !pDoc->_pClientSite)
            return TRUE;
        break;

    case VALIDATE_DOC_ALIVE:
        if (!pDoc->_pUnkOuter)
            return TRUE;
        break;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CObjectElement::Init2
//
//  Synopsis:   2nd phase of initialization
//
//-------------------------------------------------------------------------

HRESULT
COleSite::Init2(CInit2Context * pContext)
{
    CDoc *  pDoc = Doc();
    ELEMENT_TAG etag = Tag();

    pDoc->_fHasOleSite = TRUE;
    pDoc->_fBroadcastInteraction = TRUE;
    pDoc->_fBroadcastStop = TRUE;

    // should we post a createobject call?

    if ((etag == ETAG_EMBED) || (pContext->_dwFlags & INIT2FLAG_EXECUTE))
    {
        IGNORE_HR(GWPostMethodCall(this, 
                                    ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0, FALSE, 
                                    "COleSite::DeferredCreateObject"));
    }

    // TODO: load any <OBJECT>-specific state (must match saved data in :Notify)

    RRETURN(super::Init2(pContext));
}


//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Handle notification
//
//-------------------------------------------------------------------------

void
COleSite::Notify(CNotification *pnf)
{
    HRESULT hr = S_OK;
    INSTANTCLASSINFO * pici;

    Assert(pnf);

    super::Notify(pnf);

    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        pici = GetInstantClassInfo();
        
        ((CQueryFocus *)pnf->DataAsPtr())->_fRetVal =
                            _fObjAvailable
                        &&  !_fActsLikeLabel

                            // Hack for #68793
                        &&  pici && !(pici->dwCompatFlags & COMPAT_NEVERFOCUSSABLE);
        break;

    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        if (_fActsLikeLabel)
        {
            FOCUS_ITEM fi;

            fi.pElement = NULL;
            fi.lSubDivision = 0;

            if (S_OK == Doc()->FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, this, 0, &fi.pElement, &fi.lSubDivision))
            {
                *(FOCUS_ITEM*)pnf->DataAsPtr() = fi;
            }
        }
        break;

    case NTYPE_ELEMENT_SETTINGFOCUS:
        {
            OLE_SERVER_STATE    baseState;
            CDoc *              pDoc = Doc();
            CSetFocus *         pSetFocus = (CSetFocus *)pnf->DataAsPtr();

            _fInBecomeCurrent = TRUE;

            if (pDoc->_fDontUIActivateOleSite && (pDoc->State() < OS_UIACTIVE))
            {
                // if the call is coming from DeferSetCurrency, and the document
                // is not UI activated, do not UI activate the olesite, since that
                // would cause the document to be UI activated prematurely.
                baseState = OS_INPLACE;
            }
            else
            {
                // If the call is not coming from the DeferSetCurrency, or the document
                // is already UI activated, then UI activate the olesite.
                baseState = OS_UIACTIVE;
            }

            pSetFocus->_hr = THR(TransitionTo(baseState, pSetFocus->_pMessage));

            if (S_OK == pSetFocus->_hr && _state != (unsigned)baseState)
            {
                pSetFocus->_hr = S_FALSE;                
            }
            else if (E_NOTIMPL == pSetFocus->_hr)
            {
                Assert(_state != (unsigned)baseState);
                pSetFocus->_hr = S_FALSE;                
            }
            _fInBecomeCurrent = FALSE;
        }
        break;

    case NTYPE_ELEMENT_SETFOCUSFAILED:
        IGNORE_HR(TransitionToBaselineState(Doc()->State()));
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        {
            CDoc * pDoc = Doc();

            //
            // If this flag is set, then we did not UI activate the olesite
            // and left it inplace activated. So, we can not tell the document
            // that it has an active element.
            if (!pDoc->_fDontUIActivateOleSite)
            {
                Assert(OS_UIACTIVE == _state);

                // Update our state
                pDoc->_pInPlace->_fChildActive = TRUE;

                //  The user might open-edit something in the embedding,
                //  so pass along the host names.
                IGNORE_HR(SetHostNames());
            }
        }
        break;

    case NTYPE_UPDATE_DOC_DIRTY:
        if (S_FALSE == IsClean())
        {
            Doc()->_lDirtyVersion = MAXLONG;
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
        break;

    case NTYPE_RELEASE_EXTERNAL_OBJECTS:
        ReleaseObject();
        break;

    case NTYPE_FREEZE_EVENTS:
        //
        // This code is needed to compensate for a problem with 
        // the Alpha version of the VM.
        //
        if (OlesiteTag() != OSTAG_APPLET)
        {
            IOleControl * pControl = NULL;

            if (OK(THR_OLE(QueryControlInterface(
                    IID_IOleControl,
                    (void **) &pControl))))
            {
                BOOL    fFreeze;
                pnf->Data(&fFreeze);

                THR_OLE(pControl->FreezeEvents(fFreeze));
                pControl->Release();
            }
        }
        break;

    case NTYPE_AMBIENT_PROP_CHANGE:
        {
            DISPID          dispid;
            IOleControl *   pControl;

            pnf->Data(&dispid);
            if (OK(QueryControlInterface(IID_IOleControl, (void **)&pControl)))
            {
                IGNORE_HR(pControl->OnAmbientPropertyChange(dispid));
                pControl->Release();
            }
        }
        break;

    case NTYPE_UPDATE_VIEW_CACHE:
        {
            IOleObject *pObj;

            if (OK(QueryControlInterface(IID_IOleObject, (void **)&pObj)))
            {
                IGNORE_HR(pObj->Update());
                pObj->Release();
            }
        }
        break;

    case NTYPE_UPDATE_DOC_UPTODATE:
        {
            IOleObject *pObj;

            if (OK(QueryControlInterface(IID_IOleObject, (void **)&pObj)))
            {
                if (S_FALSE == THR_OLE(pObj->IsUpToDate()))
                {
                    pnf->SetFlag(NFLAGS_SENDENDED);
                    Doc()->_fIsUpToDate = FALSE;
                }
                pObj->Release();
            }
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_1:
    case NTYPE_DOC_STATE_CHANGE_2:
        {
            DWORD   dw;
            CDoc *  pDoc = Doc();
            BOOL    fDown = FALSE;
            
            pnf->Data(&dw);

            // Our parent form is broadcasting a state change, transition
            // ourself correspondingly if the Doc's state is falling.

            if (pDoc->State() < (OLE_SERVER_STATE)dw)
            {
                fDown = TRUE;
            }
            
            pici = GetInstantClassInfo();
            
            if (pici && fDown ||  
                (pDoc->State() >= OS_INPLACE && 
                 (pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE)))
            {
                if (pnf->IsSecondChance())
                {
                    //
                    // If it's a down transition and the state is already at the max,
                    // nothing more to do.
                    //
                    
                    if (fDown && State() <= pDoc->State())
                        break;
                        
                    IGNORE_HR(TransitionToBaselineState(pDoc->State()));
                }
                else
                    pnf->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:

        if(_fClipViaHwndOnly && _pInPlaceObject)
        {
            HWND hwnd;

            // For some VB controls we need to hook the window messages to remove a
            //  user message that is causing window clip problems (IE6 bug 13321).
            // Here we are removing the hooks
        
            _pInPlaceObject->GetWindow(&hwnd);
            CView *     pView     = Doc()->GetView();

            Assert(pView && hwnd);

            // Check if the control window has hooks attached and detach them
            if(pView != NULL && hwnd != NULL && GetProp(hwnd, VBCTRLHOOK_PROPNAME))
            {
                pView->RemoveVBControlClipHook(hwnd);
            }
        }
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        ClearRefresh();

        ReleaseCodeLoad();

        if (_fViewLinkedWebOC && pnf->Type() == NTYPE_MARKUP_UNLOAD_2)
        {
            CVariant cvarDisplayErrorPage(VT_BOOL);

            V_BOOL(&cvarDisplayErrorPage) = VARIANT_FALSE;

            OnCommand(NULL, OLECMDID_STOP, 0, &cvarDisplayErrorPage);
        }
        else
        {
            OnCommand(NULL, OLECMDID_STOP);
        }

        break;

    case NTYPE_ENABLE_INTERACTION_1:
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        {
            VARIANT varargIn;

            varargIn.vt = VT_I4;
            varargIn.lVal = Doc()->_fEnableInteraction;
            OnCommand(NULL, OLECMDID_ENABLE_INTERACTION, 0, &varargIn);
        }
        break;

    case NTYPE_BEFORE_UNLOAD:
        {
            BOOL *pfContinue;

            pnf->Data((void **)&pfContinue);
            if (*pfContinue)
            {
                VARIANT varOut = {0};
                OnCommand (NULL, OLECMDID_ONUNLOAD, 0,
                        NULL, &varOut);
                if (varOut.vt == VT_BOOL && varOut.boolVal == FALSE)
                    *pfContinue = FALSE;
            }
        }
        break;

    case NTYPE_BEFORE_REFRESH:
        {
            VARIANTARG varargIn;
            varargIn.vt = VT_I4;
            pnf->Data(&varargIn.lVal);
            OnCommand (NULL, OLECMDID_PREREFRESH, MSOCMDEXECOPT_DONTPROMPTUSER,
                    &varargIn, NULL);
        }
        break;

    case NTYPE_COMMAND:
        {
            COnCommandExecParams* pParm;

            pnf->Data((void **)&pParm);
            Assert(pParm);
            hr = THR(OnCommand(pParm->pguidCmdGroup, pParm->nCmdID,
                               pParm->nCmdexecopt, pParm->pvarargIn,
                               pParm->pvarargOut));
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_SAVE_HISTORY_2:
        {
            IStream *           pStream = NULL;
            CHistorySaveCtx *   phsc = NULL;

            pnf->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream(GetSourceIndex(), HistoryCode(), &pStream));
            if (hr)
                goto CleanupHistory;

            hr = THR(SaveHistoryStream(pStream));
            if (hr)
                goto CleanupHistory;

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto CleanupHistory;

        CleanupHistory:
            ReleaseInterface(pStream);
        }
        break;

    case NTYPE_END_PARSE:
#ifndef NO_DATABINDING
        if (    (OlesiteTag() == OSTAG_ACTIVEX || OlesiteTag() == OSTAG_APPLET)
            &&  HasMarkupPtr())
        {
            AssertSz( !GetMarkupPtr()->_fDataBindingEnabled, "Databinding enabled in NTYPE_END_PARSE, talk to jharding" );
            DYNCAST(CObjectElement, this)->AttachDataBindings();
            Assert( HasMarkupPtr() );
            if (HasMarkupPtr())
                GetMarkup()->GetDataBindTask()->SetWaiting();
        }
#endif // ndef NO_DATABINDING
        break;

    case NTYPE_ELEMENT_EXITVIEW_1:
        if (State() > OS_RUNNING)
        {
            pnf->SetSecondChanceRequested();
        }
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        pnf->SetData( pnf->DataAsDWORD() | EXITTREE_DELAYRELEASENEEDED );
        if (State() > OS_RUNNING)
        {
            pnf->SetSecondChanceRequested();
        }
        UnregisterForRelease();
        break;

    case NTYPE_ELEMENT_EXITVIEW_2:
    case NTYPE_ELEMENT_EXITTREE_2:
        // If it is inplace-active or greater, transition to the running state.
        // The object shouldn't display after it leaves the tree.
        if (State() > OS_RUNNING)
           TransitionTo(OS_RUNNING);

        if (_fViewLinkedWebOC)
        {
            CMarkup * pMarkup = GetMarkup();

            if (pMarkup && pMarkup->HasWindow())
            {
                CWindow * pWindow = pMarkup->Window()->Window();
                
                if (!pWindow->_pMarkupPending)
                    pMarkup->Window()->Window()->ReleaseViewLinkedWebOC();
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::OnCommand
//
//  Note:       propagates a given notification down to doc living in the
//              WB control
//
//-------------------------------------------------------------------------

HRESULT
COleSite::OnCommand(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT                 hr;
    IOleCommandTarget *     pCmdTarget = NULL;

    hr = THR_NOTRACE(QueryControlInterface(
            IID_IOleCommandTarget,
            (void**)&pCmdTarget));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pCmdTarget->Exec(
            pguidCmdGroup,
            nCmdID,
            nCmdexecopt,
            pvarargIn,
            pvarargOut));

Cleanup:
    ReleaseInterface(pCmdTarget);

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SetMiscStatusFlags
//
//  Synopsis:   Set members from ole misc status flags
//
//  Arguments:  dwMiscStats     the flags
//
//----------------------------------------------------------------------------

void
COleSite::SetMiscStatusFlags(DWORD dwMiscStatus)
{
    INSTANTCLASSINFO * pici = GetInstantClassInfo();
    
    //  We may have to add in some flags from our compatability class table
    // since some controls' record their flags wrong and IE3 did not fully
    // enforce the meaning of missing flags such as INSIDEOUT.
    if (pici)
        dwMiscStatus |= pici->dwMiscStatusFlags;

    //  If a control acts like a label, we default it's TabStop
    //    property to FALSE, rather than the normal TRUE default

    if (dwMiscStatus & OLEMISC_ACTSLIKELABEL)
    {
        _fActsLikeLabel = TRUE;
    }

    if (dwMiscStatus & OLEMISC_ACTSLIKEBUTTON)
        _fActsLikeButton = TRUE;

    if (dwMiscStatus & OLEMISC_NOUIACTIVATE)
        _fNoUIActivate = TRUE;

    if (dwMiscStatus & OLEMISC_INSIDEOUT)
        _fInsideOut = TRUE;

    if (dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)
        _fInvisibleAtRuntime = TRUE;

    if (dwMiscStatus & OLEMISC_ALWAYSRUN)
        _fAlwaysRun = TRUE;

    // A control is activate when visible if
    //      the flag is set AND
    //      the ignore flag is not set AND
    //      the control is not iconic and invisible at runtime.
    //
    // The last part of this check is required because some controls
    // marked as activiate when visible and invisible at runtime do
    // not correctly handle being active. In the case of the VB4 common
    // dialog control, it will not paint its window correctly.

    if ((dwMiscStatus &
            (OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_IGNOREACTIVATEWHENVISIBLE)) ==
                OLEMISC_ACTIVATEWHENVISIBLE &&
        (dwMiscStatus &
            (OLEMISC_ONLYICONIC|OLEMISC_INVISIBLEATRUNTIME)) !=
                (OLEMISC_ONLYICONIC|OLEMISC_INVISIBLEATRUNTIME))
    {
#if DBG == 1
        if (!IsTagEnabled(tagIgnoreAWV))
#endif
        _fActivateWhenVisible = TRUE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SetViewStatusFlags
//
//  Synopsis:   Set members from view object status flags
//
//  Arguments:  dwViewStatus     the flags
//
//----------------------------------------------------------------------------

void
COleSite::SetViewStatusFlags(DWORD dwViewStatus)
{
    SetSurfaceFlags(dwViewStatus & VIEWSTATUS_SURFACE, dwViewStatus & VIEWSTATUS_3DSURFACE);

    _fDVAspectOpaque = !!(dwViewStatus & VIEWSTATUS_DVASPECTOPAQUE);
    _fDVAspectTransparent = !!(dwViewStatus & VIEWSTATUS_DVASPECTTRANSPARENT);

    // send a REmeaseure notification, which on the layout will PostLayoutRequest
    // this will cause a ensureDispNode to be called, and that in turn will
    // set the opacity flag
    RemeasureElement();
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ConnectControl1
//
//  Synopsis:   Establish connection between control and client site
//              and set status bits.  Call this function before calling
//              IPersist*::InitNew or IPersist*::Load.
//
//  Arguments:  pdwInitFlags  In/out argument. Taken from the
//                            FSI_ enumeration.  Pass result to ConnectControl.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------

HRESULT
COleSite::ConnectControl1(DWORD *pdwInitFlags)
{
    HRESULT         hr = S_OK;
    DWORD           dwMiscStatus;
    QACONTROL       qacontrol;
    QACONTAINER     qacontainer;
    IQuickActivate *pQA = NULL;
    IOleObject *    pOleObject = NULL;
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    // Make sure we have an undo manager to hand to our embeddings.  If we
    // haven't gotten our undo manager by now, then our container better not
    // be providing one.  If they are providing one they have to support
    // SETCLIENTSITEFIRST, which means we would have gotten it before loading.

#ifndef NO_EDIT
    if (pDoc->UndoManager() == &g_DummyUndoMgr)
    {
        hr = THR(pDoc->CreateUndoManager());
        if (hr)
            goto Cleanup;
    }
#endif // NO_EDIT

    //
    // Only use QuickActivate if the following conditions are met:
    //
    //  1)  The COMPAT_NO_QUICKACTIVATE flag is not set.
    //  2)  _pUnkCtrl is not an ole proxy (i.e. it is apartment modelled)
    //      There's an OLE bug in the marshalling for IQuickActivate which
    //      causes E_UNEXPECTED to be returned on win95 and nt versions
    //      < SP3.  (anandra)
    //  3)  _pUnkCtrl supports the QI for IQuickActivate.
    //
    pici = GetInstantClassInfo();

    // If pici is NULL, don't try to quick activate the control.
    // We don't try to quick activate it because if pici is NULL,
    // SetOC96 won't be called and the control will never be drawn.
    //
    if (pici && !(pici->dwCompatFlags & COMPAT_NO_QUICKACTIVATE) &&
        !IsOleProxy() &&
        OK(THR_NOTRACE(QueryControlInterface(
            IID_IQuickActivate, (void **)&pQA))))
    {
        *pdwInitFlags |= FSI_QUICKACTIVATE|FSI_CLIENTSITESET;

        memset(&qacontrol, 0, sizeof(qacontrol));
        qacontrol.cbSize = sizeof(qacontrol);

        memset(&qacontainer, 0, sizeof(qacontainer));
        qacontainer.cbSize = sizeof(qacontainer);
        qacontainer.pAdviseSink = &_Client;
        qacontainer.pClientSite = &_Client;
        qacontainer.pPropertyNotifySink = &_Client;

#if DBG==1
        qacontainer.pAdviseSink->AddRef();
        DbgTrackItf(IID_IAdviseSink, "CClient", FALSE, (void **)&qacontainer.pAdviseSink);

        qacontainer.pClientSite->AddRef();
        DbgTrackItf(IID_IOleClientSite, "CClient", FALSE, (void **)&qacontainer.pClientSite);

        qacontainer.pPropertyNotifySink->AddRef();
        DbgTrackItf(IID_IPropertyNotifySink, "PNS", FALSE, (void **)&qacontainer.pPropertyNotifySink);
#endif

        VARIANT v;
        VariantInit(&v);

        // Ambient foregound color
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_FORECOLOR, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.colorFore = V_I4(&v);

        // Ambient backgound color
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_BACKCOLOR, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.colorBack = V_I4(&v);

        // Ambient locale
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_LOCALEID, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.lcid = V_I4(&v);

        // Ambient Font...
        hr = THR(GetAmbientProp(DISPID_AMBIENT_FONT, &v));
        if (OK(hr) && V_DISPATCH(&v))
        {
            // Since the ambient font property is an LPFONTDISP, we need
            // to ask for IFont.
            LPDISPATCH pFontDisp = V_DISPATCH(&v);
            pFontDisp->QueryInterface(IID_IFont, (void **) &qacontainer.pFont);
            VariantClear(&v);   // will release the LPFONTDISP interface
        }

#ifndef NO_EDIT
        qacontainer.pUndoMgr = (pDoc->_pUndoMgr != &g_DummyUndoMgr) ?
                                       pDoc->_pUndoMgr : NULL;
#endif // NO_EDIT

        //
        // The quick-activate of event sink is disabled below because
        // the olesite event sink does not know how to correctly
        // return from events when there is not an event sink
        // hooked up to the control.
        //
        // qacontainer.pUnkEventSink     = pUnkEventSink;

        //
        // Initialize all current mode behaviors.
        //
        qacontainer.dwAmbientFlags =
                QACONTAINER_MESSAGEREFLECT |
                QACONTAINER_SUPPORTSMNEMONICS;

        if (IsDesignMode())
        {
            qacontainer.dwAmbientFlags |=
                    QACONTAINER_SHOWHATCHING |
                    QACONTAINER_SHOWGRABHANDLES;
        }
        else
        {
            qacontainer.dwAmbientFlags |= QACONTAINER_USERMODE;
        }

        if (_fDefault)
        {
            //  Note that the _fActsLikeButton flag is not set until
            //    we call SetMiscStatusFlags below

            if (!CheckDisplayAsDefault(pDoc->_pElemCurrent))
            {
                qacontainer.dwAmbientFlags |= QACONTAINER_DISPLAYASDEFAULT;
            }
        }

        hr = THR_OLE(pQA->QuickActivate(&qacontainer, &qacontrol));
#if DBG==1
        qacontainer.pAdviseSink->Release();
        qacontainer.pClientSite->Release();
        qacontainer.pPropertyNotifySink->Release();
#endif
        ReleaseInterface(qacontainer.pFont);
        if (hr)
            goto Cleanup;

        SetMiscStatusFlags(qacontrol.dwMiscStatus);
        SetViewStatusFlags(qacontrol.dwViewStatus);
        *pdwInitFlags |= FSI_PNSCONNECTED;

        pici->SetOC96(TRUE);
    }
    else if (OK(THR_OLE(QueryControlInterface(
                IID_IOleObject, (void **)&pOleObject))))
    {
        hr = THR_OLE(pOleObject->GetMiscStatus(
                DVASPECT_CONTENT,
                &dwMiscStatus));
        if (hr)
        {
            dwMiscStatus = 0;  // this is how IE3 behaves.
            hr = S_OK;         // this happens with the Interactive Music Control, 11/18/96
        }

        SetMiscStatusFlags(dwMiscStatus);
        if (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
        {
            *pdwInitFlags |= FSI_CLIENTSITESET;
            hr = THR_OLE(SetClientSite(&_Client));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pOleObject);
    ReleaseInterface(pQA);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ConnectControl2
//
//  Synopsis:   Establish connection between control and client site
//              and get extent.  Call this function after calling
//              IPersist*::InitNew or IPersist*::Load.
//
//  Arguments:  dwInitFlags     Some combination of:
//
//                  FSI_NONE            No special behavior.
//                  FSI_QUICKACTIVATE   ConnectControl1 used IQuickActivate.
//                  FSI_CLIENTSITESET   ConnectControl1 set the client site.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ConnectControl2(DWORD *pdwInitFlags)
{
    HRESULT             hr = S_OK;
    DWORD               dwViewStatus;
    IActiveScript *     pScript = NULL;
    CNotification       nf;
    CDoc *              pDoc = Doc();
    CMarkup *           pMarkup;
    ICatInformation *   pCatInfo = NULL;
    CScriptCollection * pScriptCollection;

    _state = OS_LOADED;

    // Cache a pointer to the object's IViewObject implementation

    if (OK(THR_NOTRACE(QueryControlInterface(IID_IViewObjectEx,
            (void **)&_pVO))))
    {
        _fUseViewObjectEx = TRUE;
    }
    else
    {
        THR_OLE(QueryControlInterface(IID_IViewObject, (void **) &_pVO));
    }

    // Set the client site if not already set.

    if (!(*pdwInitFlags & FSI_CLIENTSITESET))
    {
        *pdwInitFlags |= FSI_CLIENTSITESET;
        hr = THR_OLE(SetClientSite(&_Client));
        if (hr)
            goto Cleanup;
    }

    if (!(*pdwInitFlags & FSI_QUICKACTIVATE))
    {
        // Setup stuff handled by quick activate.

        if (_pVO)
        {
#if DBG==1
            IAdviseSink *pAdviseSink = &_Client;
            pAdviseSink->AddRef();
            DbgTrackItf(IID_IAdviseSink, "CClient", FALSE, (void **)&pAdviseSink);
#endif
            IGNORE_HR(_pVO->SetAdvise(DVASPECT_CONTENT, 0, &_Client));
#if DBG==1
            pAdviseSink->Release();
#endif
        }

        // Parse view status flags.

        if (_fUseViewObjectEx)
        {
            hr = THR_OLE(((IViewObjectEx*)_pVO)->GetViewStatus(&dwViewStatus));
            if (hr)
                goto Cleanup;

            SetViewStatusFlags(dwViewStatus);
        }

        //
        // Some down-level controls don't like to be UI-activated
        // in design mode. Therefore, if the control does not support
        // IQuickActivate we assume it's down-level and prevent transitioning
        // it to UI-active state except through its verb menu (if it provides it).
        // If it does not support IOleControl then it's not a control and
        // we don't set the _fNoUIActivateInDesign flag.
        // (LyleC)
        //
        // Note that it _is_ possible to get into this codepath (with
        // FSI_QUICKACTIVATE not set) but still have the control support
        // IQuickActivate.
        //

        // TODO: Remove the OSTAG_APPLET check below when the Java VM supports IQuickActivate.
        if (IsDesignMode() && OlesiteTag() != OSTAG_APPLET)
        {
            HRESULT             hr2;
            IQuickActivate *    pQA    = NULL;
            IOleControl *       pCtrl  = NULL;

            hr2 = THR_NOTRACE(QueryControlInterface(IID_IQuickActivate,
                                                  (LPVOID*)&pQA));
            if (hr2)
                pQA = NULL;

            hr2 = THR_NOTRACE(QueryControlInterface(IID_IOleControl,
                                                  (LPVOID*)&pCtrl));
            if (hr2)
                pCtrl = NULL;

            if (!pQA && pCtrl)
            {
                _fNoUIActivateInDesign  = TRUE;
            }

            ReleaseInterface (pQA);
            ReleaseInterface (pCtrl);

        }

        // Don't require the component to support IConnectionPointContainer or
        // a connection point for IPropertyNotifySink.  Since all errors are clamped
        // to E_FAIL anyway, ignore the return value  (philco).

        IPropertyNotifySink *pPNS = &_Client;

#if DBG==1
        pPNS->AddRef();
        DbgTrackItf(IID_IPropertyNotifySink, "cclient", FALSE, (void **)&pPNS);
#endif

        if (OK(THR(ConnectSink(
                _pUnkCtrl,
                IID_IPropertyNotifySink,
                pPNS,
                &_dwPropertyNotifyCookie))))
        {
            *pdwInitFlags |= FSI_PNSCONNECTED;
        }

#if DBG==1
        pPNS->Release();
#endif
    }

    //
    // Set _fNoUIActivateInDesign flag for Design Time Controls,
    // Java Applets or other OLE Controls based on host preferences
    //   
  
    if ( IsDesignMode() &&
        (pDoc->_fNoActivateNormalOleControls ||
         pDoc->_fNoActivateDesignTimeControls ||
         pDoc->_fNoActivateJavaApplets))
    {
        HRESULT           hr2;
        IUnknown *        pAD = NULL;
        BOOL              fDesignTimeControl = FALSE;
        BOOL              fJavaApplet = (OlesiteTag() == OSTAG_APPLET);

        hr2 = THR_NOTRACE(QueryControlInterface(IID_IActiveDesigner,
                                          (LPVOID*)&pAD));
        if (S_OK == hr2)
            fDesignTimeControl = TRUE;

        ReleaseInterface (pAD);

        if (pDoc->_fNoActivateDesignTimeControls && fDesignTimeControl)
            _fNoUIActivateInDesign = TRUE;

        if (pDoc->_fNoActivateJavaApplets && fJavaApplet)
            _fNoUIActivateInDesign = TRUE;

        if (pDoc->_fNoActivateNormalOleControls && !fDesignTimeControl && !fJavaApplet)
            _fNoUIActivateInDesign = TRUE;
    }

    //
    // If _fNoUIActivateInDesign is set, then override this if they support 
    // CATID_DesignTimeUIActivatableControl. Note that anything with an appropriate
    // CATID will be UI active even if the HOST tells us not to do so.
    //

    if (_fNoUIActivateInDesign)
    {
        //
        // Get the category manager
        //
        
        hr = THR(GetCategoryManager(&pCatInfo));
        if (hr)
            goto Cleanup;

        //
        // Check if control supports CATID_DesignTimeUIActivatableControl
        //
        CATID rgcatid[1];
        rgcatid[0] = CATID_DesignTimeUIActivatableControl;

        CLSID * pCLSID = GetpCLSID();
        
        if (pCLSID)
        {
            _fNoUIActivateInDesign = 
                (pCatInfo->IsClassOfCategories(*pCLSID, 1, rgcatid, 0, NULL) != S_OK);        
        }
        else
        {
            _fNoUIActivateInDesign = TRUE;
        }
    }    

    //
    // Query for the scripting interfaces.  If available then add
    // a holder for them.
    //

    QueryControlInterface(IID_IActiveScript, (void **)&pScript);

    if (pScript)
    {
        pMarkup = GetWindowedMarkupContext();
        Assert(pMarkup);
        
        pScriptCollection = pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->AddHolderForObject(pScript, GetpCLSID()));

            if (hr)
                goto Cleanup;
        }
    }

    //
    // If we just created the license manager and no license manager
    // currently exists, cache pointer to license manager.
    //
    {
        pMarkup = GetWindowedMarkupContext();
        CWindow* pWindow = pMarkup ? pMarkup->GetWindowedMarkupContextWindow() : NULL;
        
        if ( pWindow &&
             ! pWindow->_pLicenseMgr )
        {
            QueryControlInterface(IID_ILocalRegistry,(void**)& pWindow->_pLicenseMgr );
        }
    }
    
    //
    // Check for support for the new palette notification
    //

    if ((Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME) &&
        SUCCEEDED(OnCommand(&CGID_ShellDocView, SHDVID_CANDOCOLORSCHANGE)))
    {
        _fCanDoShColorsChange = TRUE;
    }

    //
    // Freeze events if the doc's freeze count is > 0
    //

    if (pDoc->_cFreeze)
    {
        //
        // Will be unfrozen when doc's freezecount drops to zero.
        //

        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }
    
    //
    // Freeze events again if the doc is not fully loaded
    //
    if (GetWindowedMarkupContext()->LoadStatus() < LOADSTATUS_DONE)
    {
        //
        // Will be unfrozen when the doc is fully loaded.
        //
        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }

    nf.EnableInteraction1(this);
    Notify(&nf);

    if (nf.IsSecondChanceRequested())
    {
        nf.EnableInteraction2(this);
        Notify(&nf);
    }

Cleanup:
    ReleaseInterface(pScript);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::AssignWclsidFromControl
//
//  Synopsis:   Assign _wclsid using IPersist* interface on control.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::AssignWclsidFromControl()
{
    HRESULT     hr;
    IPersist *  pPers = NULL;
    CLSID       clsid;
    CDoc *      pDoc = Doc();

    hr = THR_OLE(QueryControlInterface(IID_IPersist, (void **) &pPers));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pPers->GetClassID(&clsid));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, clsid, &_wclsid));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPers);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InitNewObject
//
//  Synopsis:   Initializes embedded object from scratch.
//              Assumes _wclsid is initialized.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InitNewObject()
{
    HRESULT                 hr;
    IPersistStreamInit *    pPStm = NULL;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;
    IPersistStorage         *pStorage = NULL;

    if (!QueryControlInterface (IID_IPersistPropertyBag2, (void**)&pPPBag2))
    {
        hr = THR_OLE(pPPBag2->InitNew());
        if (hr)
            goto Cleanup;
    }
    else if (!QueryControlInterface(IID_IPersistPropertyBag,(void**)&pPPBag))
    {
        hr = THR_OLE(pPPBag->InitNew());
        if (hr)
            goto Cleanup;
    }
    else
    {   // control does not support IPersistPropertyBag

        hr = THR_OLE(QueryControlInterface(
                IID_IPersistStreamInit,
                (void **) &pPStm));

        if (!hr)
        {
            hr = THR_OLE(pPStm->InitNew());
            if (hr)
                goto Cleanup;
        }
        else
        {

            hr = THR_OLE(QueryControlInterface(
                IID_IPersistStorage,
                (void **) &pStorage ));

            if (!hr)
            {
                // we do not support controls who require storage....
                hr = E_FAIL;
                goto Cleanup;
            }
            // The control does not support IPersist
            hr = S_OK; // we allow such controls
        }
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPPBag2);
    ReleaseInterface(pPStm);
    ReleaseInterface(pStorage);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a stream.
//
//  Arguments:  [pStm] -- Stream to load from
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IStream * pStm)
{
    HRESULT                 hr      = S_FALSE;
    IPersistStreamInit *    pPStm   = NULL;

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStreamInit, (void **) &pPStm));
    if (OK(hr) && pPStm)
    {
        hr = THR_OLE(pPStm->Load(pStm));
        goto Cleanup;
    }
    else
    {
        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStream, (void **) &pPStm));
        if (OK(hr) && pPStm)
        {
            hr = THR_OLE(pPStm->Load(pStm));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pPStm);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a storage
//
//  Arguments:  [pStg] -- Storage to load from.
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IStorage * pStg)
{
    HRESULT             hr          = S_FALSE;
    IPersistStorage *   pPStg       = NULL;

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStorage, (void **) &pPStg));
    if (OK(hr) && pPStg)
    {
        hr = THR_OLE(pPStg->Load(pStg));
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pPStg);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Initializes embedded object from a PropertyBag
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IPropertyBag * pPropBag)
{
    HRESULT                 hr = S_FALSE;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;
    IPropertyBag2 *         pPBag2 = NULL;

    //
    // Ensure the VB standard _ExtentX and _ExtentY properties are
    // available.  Some controls like SurroundVideoCtrl Object
    // choke if those properties are not available.
    //
    if (IsInMarkup())
    {
        {   const static TCHAR tchExtentX[] = _T("_ExtentX");
            CVariant Var( VT_EMPTY );
            if( pPropBag->Read( tchExtentX, &Var, NULL ) == E_INVALIDARG)
            {
                // Property does not exist:
                CUnitValue  uvWidth      = GetFirstBranch()->GetCascadedwidth();
                if( !uvWidth.IsNull() )
                {
                    Var.vt = VT_I4;
                    Var.lVal = HimetricFromHPix(uvWidth.GetPixelValue());
                    // We do not concern ourselves with failures here
                    // since this whole operation is just a convenience
                    // for some controls and not strictly neccessary.
                    pPropBag->Write( tchExtentX, &Var );
                }
            }
        }
        {   const static TCHAR tchExtentY[] = _T("_ExtentY");
            CVariant Var( VT_EMPTY );
            if( pPropBag->Read( tchExtentY, &Var, NULL ) == E_INVALIDARG)
            {
                // Property does not exist:
                CUnitValue  uvHeight     = GetFirstBranch()->GetCascadedheight();
                if( !uvHeight.IsNull() )
                {
                    Var.vt = VT_I4;
                    Var.lVal = HimetricFromVPix(uvHeight.GetPixelValue());
                    // We do not concern ourselves with failures here
                    // since this whole operation is just a convenience
                    // for some controls and not strictly neccessary.
                    pPropBag->Write( tchExtentY, &Var );
                }
            }
        }
    }


    //
    // First try IPersistPropertyBag2.
    //

    hr = THR_NOTRACE(QuerySafeLoadInterface(IID_IPersistPropertyBag2, (void **) &pPPBag2));
    if (OK(hr) && pPPBag2)
    {
        Verify(OK(pPropBag->QueryInterface(IID_IPropertyBag2, (void **)&pPBag2)));
        hr = THR_OLE(pPPBag2->Load(pPBag2, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // Then IPersistPropertyBag
        //

        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistPropertyBag, (void **) &pPPBag));
        if (OK(hr) && pPPBag)
        {
            hr = THR_OLE(pPPBag->Load(pPropBag, NULL));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPBag2);
    ReleaseInterface(pPPBag2);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a file name
//
//  Arguments:  [pchFileName] -- Filename to load from.
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(TCHAR *pchDataUrl, TCHAR *pchFileName)
{
    HRESULT             hr = S_OK;
    IPersistFile *      pPF = NULL;
    IPersistMoniker *   pPMk = NULL;
    IStream *           pStm = NULL;
    IStorage *          pStg = NULL;
    IBindCtx *          pBCtx = NULL;
    IMoniker *          pMk = NULL;

    //
    // First try IPersistMoniker if we have a data url
    //

    if (pchDataUrl)
    {
        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistMoniker, (void **)&pPMk));
        if (OK(hr) && pPMk)
        {
            hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
            if (hr)
                goto Cleanup;

            hr = THR(CreateURLMoniker(NULL, pchDataUrl, &pMk));
            if (hr)
                goto Cleanup;

            hr = THR(pPMk->Load(FALSE, pMk, pBCtx, 0));
            goto Cleanup;
        }
    }

    if (!pchFileName || hr == S_FALSE)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistFile, (void **) &pPF));
    if (OK(hr) && pPF)
    {
        hr = THR(pPF->Load(pchFileName, 0));
        if (hr)
            goto Cleanup;
    }
#ifndef WIN16
    else if (hr == S_FALSE)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    else
    {
        //
        // Try the stream approach on this file
        //

        hr = THR(CreateStreamOnFile(
                pchFileName,
                STGM_READ | STGM_SHARE_DENY_WRITE,
                &pStm));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(LoadObject(pStm));
        if (!hr)
            goto Cleanup;

        //
        // Finally try to create a storage on the file
        //

        ClearInterface(&pStm);
        hr = THR(StgOpenStorage(
          pchFileName,
          NULL,
          STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE,
          NULL,
          0,
          &pStg));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(LoadObject(pStg));
        if (hr)
            goto Cleanup;
    }
#endif //ndef WIN16

Cleanup:
    ReleaseInterface(pPMk);
    ReleaseInterface(pBCtx);
    ReleaseInterface(pPF);
    ReleaseInterface(pMk);
    ReleaseInterface(pStm);
    ReleaseInterface(pStg);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadHistoryStream, public
//
//  Synopsis:   Loads our embedded object from a history stream
//
//  Arguments:  [pStream] - the history stream to load from
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadHistoryStream(IStream *pStream, IBindCtx *pbc)
{
    CDataStream ds(pStream);

    HRESULT             hr = S_FALSE;
    HRESULT             hr2;
    IPersistHistory *   pPH = NULL;
    IStream *           pStm = NULL;

    hr = THR_NOTRACE(QuerySafeLoadInterface(IID_IPersistHistory, (void **) &pPH));
    if (OK(hr) && pPH)
    {
        hr = THR(ds.LoadDword((DWORD*)&hr2));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadSubstream(&pStm));
        if (hr)
            goto Cleanup;

        if (!hr2)
            hr2 = THR_OLE(pPH->LoadHistory(pStm, pbc));

        if (hr2)
            hr = hr2;
    }

Cleanup:
    ReleaseInterface(pPH);
    ReleaseInterface(pStm);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveHistoryStream, public
//
//  Synopsis:   Saves our embedded object to a history stream
//
//  Arguments:  [pStream] - the history stream to save to
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::SaveHistoryStream(IStream *pStream)
{
    CDataStream ds;
    IStream *pSubstream = NULL;
    IPersistHistory *pPH = NULL;
    DWORD dwPosition;
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

    if (OK(QueryControlInterface(IID_IPersistHistory, (void **)&pPH)))
    {
        ds.Init(pStream);

        hr = THR(ds.SaveDataLater(&dwPosition, sizeof(hr2)));
        if (hr)
            goto Cleanup;

        hr = THR(ds.BeginSaveSubstream(&pSubstream));
        if (hr)
            goto Cleanup;

        hr2 = THR_OLE(pPH->SaveHistory(pSubstream));

        hr = THR(ds.EndSaveSubstream());
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDataNow(dwPosition, &hr2, sizeof(hr2)));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    ReleaseInterface(pSubstream);
    ReleaseInterface(pPH);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CreateObject
//
//  Synopsis:   selects a way to instantiate object or launch download;
//              actual instantiation always happens in CreateObjectNow
//              called from this function or in the end of download
//
//  Arguments:  pinfo       Creation info
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#define REGACTIVEXCOMPATIBILITY _T("Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility\\")

HRESULT  
COleSite::CheckForAlternateGUID(LPTSTR *pclsid)
{

    CDoc * pDoc = Doc();

    for(int i = 0; i< 10; i++)
    {
        TCHAR  szKey[MAX_PATH] = REGACTIVEXCOMPATIBILITY;
        CLSID  clsid;
        INSTANTCLASSINFO * pici = NULL;
        lstrcat(szKey, *pclsid);

        DWORD dwType, dwSize = 40 * sizeof(TCHAR);

        if(ERROR_SUCCESS != SHRegGetUSValue(szKey, _T("AlternateCLSID"),
                                         &dwType, (LPVOID)*pclsid, &dwSize,
                                         TRUE, NULL, 0)
          || FAILED(CLSIDFromString(*pclsid, &clsid)))                                         
                            
        {
            return E_ACCESSDENIED;
        }


        if (FAILED(pDoc->_clsTab.AssignWclsid(pDoc, clsid, &_wclsid)))
        {
            return E_ACCESSDENIED;
        }

        pici = GetInstantClassInfo();

        if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
        {
            continue;
        }

        return S_OK;

    }

    return E_ACCESSDENIED;
}


HRESULT
COleSite::CreateObject(OLECREATEINFO *pinfo)
{
    HRESULT         hr = S_OK;
    CMarkup *       pMarkup = GetMarkup();
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    Assert(!_pUnkCtrl);

    // 
    //  During the creation of a control, we may make sycnhronous calls
    //  to that component. There are some cases, where the component pushes 
    //  a message loop, and the browser window is closed in that time frame.
    //  If that ever happens, we risk not having a document at the end of this
    //  function.
    //  We addref here and release at the end of this function to guarantee.
    //  Bug#IE573270 (ferhane)
    //
    Assert(pDoc);
    pDoc->AddRef();


    // init2 is called at the begin tag parse time, since this element is not
    // in the tree yet, we can't call GetLoadHistoryStream().  This is safe to
    // do here since _pStreamHistory isn't used until CreateObjectNow() (below) and 
    // in CFrameSite::CreatObject (which doesn't call super); plugins can now leverage
    // this (bug in previous logic)
    if (!_pStreamHistory && pMarkup)
    {
        THR(pMarkup->GetLoadHistoryStream(GetSourceIndex(), HistoryCode(), &_pStreamHistory));
    }

    if (_pStreamHistory)
    {
        Assert(!pinfo->pStreamHistory);

        pinfo->pStreamHistory = _pStreamHistory;
        _pStreamHistory->AddRef();
    }

    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, pinfo->clsid, &_wclsid));
    if (hr)
        goto Error;

    pici = GetInstantClassInfo();
    
    if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
    {
        //
        // The registry says that this control is not allowed to run at all
        // in IE4.
        //
        hr = E_ACCESSDENIED;

        TCHAR  pstrClsid[40];
        LPTSTR lpsz = pstrClsid;

        if(!StringFromGUID2( pinfo->clsid, pstrClsid, ARRAY_SIZE(pstrClsid) ))
        {
            goto Error;
        }

        if(FAILED(CheckForAlternateGUID(&lpsz)))
        {
            hr = E_ACCESSDENIED;
            goto Error;
        }

          
        if(FAILED(CLSIDFromString(pstrClsid, &pinfo->clsid)))                                                                                 
        {
            goto Error;
        }

        hr = S_OK;
    }

    //
    // If we have a data object, instantiate immediately without
    // code loader.
    //

    if (pinfo->pDataObject)
    {
        hr = THR(CreateObjectNow(IID_IDataObject, pinfo->pDataObject, pinfo));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // If we have any attributes whatsoever with which code-download
        // can do its thang, start the codeloader.  Otherwise, just fail
        // immediately.
        //

#ifndef WIN16
        if (!IsEqualGUID(pinfo->clsid, g_Zero.guid) ||
            !FormsIsEmptyString(pinfo->pchMimeType) ||
            !FormsIsEmptyString(pinfo->pchClassid) ||
            !FormsIsEmptyString(pinfo->pchDataUrl))
        {
            //
            // instantiate immediately through CCodeLoadCtx or launch download
            //

            _pCodeLoad = new CCodeLoad;
            if (!_pCodeLoad)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            hr = THR(_pCodeLoad->Init(this, pinfo));
            if (S_OK != hr && MK_S_ASYNCHRONOUS != hr)
                goto Error;

            hr = S_OK;
        }
        else
#endif // ndef WIN16
        {
            // this will be a very empty olesite
            Assert (!_pUnkCtrl);
            _state = OS_LOADED;
            OnFailToCreate();
            hr = S_OK;
        }
    }

Cleanup:
    ClearInterface(&_pStreamHistory);

    if (hr && _dwProgCookie)
    {
        //
        // If there was some failure and a progress cookie still exists
        // delete progress sink
        //
        IGNORE_HR(CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup())->DelProgress(_dwProgCookie));
        _dwProgCookie = 0;
    }

    pDoc->Release();

    RRETURN(hr);

Error:
    ReleaseCodeLoad();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::AllowCreate
//
//  Synopsis:   Returns whether it's ok to create this object after checking
//              permissions on doc, etc.
//
//----------------------------------------------------------------------------

BOOL
COleSite::AllowCreate(REFCLSID clsid)
{
    DWORD   dwAction = 0;
    HRESULT hr;
    BOOL    fAllowed = TRUE;

    if (_fViewLinkedWebOC)
        return TRUE;

    if (OlesiteTag() == OSTAG_APPLET)
    {
        dwAction = URLACTION_JAVA_PERMISSIONS;
    }
    else if (OlesiteTag() == OSTAG_ACTIVEX || Tag() == ETAG_EMBED)
    {
        dwAction = URLACTION_ACTIVEX_RUN;
    }

    if (dwAction)
    {
        // KTam): We may not be in a markup yet (e.g.
        // if we were created via createElement -- script.js does this)
        // What then?  Default to primary markup.
        CMarkup *pMU = GetMarkupPtr();
        if ( !pMU )
            pMU = Doc()->PrimaryMarkup();

        Assert( pMU );

        hr = THR(pMU->ProcessURLAction(
                dwAction,
                &fAllowed,
                0,
                NULL,
                NULL,
                (BYTE *)&clsid,
                sizeof(CLSID)));

        if (hr || !fAllowed)
        {
            //
            // The control was not allowed to create itself.  Treat page
            // as if control doesn't exist.  This creates no layout
            // space for this site.
            //
            _fInvisibleAtRuntime = TRUE;
        }

    }


       return fAllowed;

}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CreateObjectNow
//
//  Synopsis:   Creates, connects and initializes embedded object from
//              a class factory.
//
//  Arguments:  pCF     The class factory (can be null if intializing from an
//                      IDataObject)
//              pinfo   OLE initialization info
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CreateObjectNow(
    REFIID          riidObject,
    IUnknown *      punkObject,
    OLECREATEINFO * pinfo)
{
    HRESULT hr = S_OK;
    DWORD   dwFlags = 0;
    BOOL    fNoLoad = FALSE;
    CDoc *  pDoc = Doc();
    INSTANTCLASSINFO * pici;
    CMarkup * pMarkupContext = NULL;

    Assert(!_dwProgCookie);
    //
    // instantiate object
    //

    if (IsEqualGUID(IID_IDataObject, riidObject))
    {
        hr = THR(InstantiateObjectFromDataObject((IDataObject *)punkObject));
        if (hr)
        {
            goto Error;
        }
    }
    else if (IsEqualGUID(IID_IClassFactory, riidObject))
    {
        hr = THR(InstantiateObjectFromCF((IClassFactory*)punkObject, pinfo));
        if (hr)
            goto Error;
    }
    else
    {
        //
        // No need to perform IPersist*::Load because that has already
        // happened as a result of the BindToObject.
        //

        fNoLoad = TRUE;
        _pUnkCtrl = punkObject;
        _pUnkCtrl->AddRef();
    }

    if (!_pUnkCtrl)
        goto Error;

#if DBG==1
    _clsid = pinfo->clsid;
#endif

    // Register for release object notifications from the Doc.
    RegisterForRelease();

    //
    // If we think the clsid is GUID_NULL, try and get a real wclsid from
    // the control.
    //

    if (pinfo->clsid == g_Zero.clsid)
    {
        IGNORE_HR(AssignWclsidFromControl());
    }

    //
    // Turn off events for the duration of creation
    //

    {
        CNotification   nf;

        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }

    //
    // First stage control creation.
    //

    hr = THR(ConnectControl1(&dwFlags));
    if (hr)
        goto Error;

    //
    // Load/InitNew the control
    //

    if (!fNoLoad)
    {
        if (!pinfo->pStreamHistory ||
            !OK(THR(LoadHistoryStream(
                pinfo->pStreamHistory,
                pinfo->pBindCtxHistory))))
        {
            if (pinfo->pStream)
            {
                hr = THR(LoadObject(pinfo->pStream));

                pici = GetInstantClassInfo();
                
                if (pici && (pici->dwCompatFlags & COMPAT_USE_PROPBAG_AND_STREAM) &&
                    pinfo->pPropBag)
                {
                    //
                    // If this is one of those nasty controls that want both
                    // IPersistPropertyBag::Load and IPersistStreamInit::Load,
                    // honor them.
                    //

                    hr = THR(LoadObject(pinfo->pPropBag));
                }
            }
            else if (pinfo->pPropBag)
            {
                hr = THR(LoadObject(pinfo->pPropBag));
            }
            else if (pinfo->pStorage)
            {
                hr = THR(LoadObject(pinfo->pStorage));
            }
            else if (pinfo->pchDataUrl || pinfo->pchFileName)
            {
                hr = THR(LoadObject(pinfo->pchDataUrl, pinfo->pchFileName));
            }
            else
            {
                hr = THR(InitNewObject());
            }
        }

        //
        // S_FALSE is used in this context to indicate that initialization
        // failed because of a safety problem.  In this case, we use InitNew
        // to initialize to a default state - ignoring any potentially unsafe
        // persistent data.
        if (hr == S_FALSE || hr == E_NOINTERFACE)
        {
            hr = THR(InitNewObject());
            if (hr)
                goto Error;
        }
    }

    if (pinfo->clsid == CLSID_ActiveXPlugin)
    {
        CMarkup *    pMarkup = GetMarkup();
        if (pMarkup)
        {
            IActiveXPlugin *    pIActiveXPlugin = NULL;
            CMarkup *    pMarkup = GetMarkup();
            CDoc *              pDoc;
            LPTSTR  pszFullUrl = NULL;
            TCHAR   cBuf[pdlUrlLen];

            pDoc = pMarkup->Doc();

            VARIANT  vSrc;
            VariantInit(&vSrc);        

            hr = pinfo->pPropBag->Read(TEXT("src"), &vSrc, NULL);
            if(!hr)
            {
                pszFullUrl = V_BSTR(&vSrc);
            }


            if (pDoc->_fFullWindowEmbed && pMarkup->GetDwnPost())
            {
                pszFullUrl = pDoc->_cstrPluginCacheFilename;
            }

            if(pszFullUrl)
            {
                CMarkup::ExpandUrl(NULL, pszFullUrl, ARRAY_SIZE(cBuf), cBuf, this);

                if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    // If unsecure, NULLify URL
                    pszFullUrl = NULL;
                }
                else
                {
                    pszFullUrl = cBuf;
                }
            }

            hr = QueryControlInterface(IID_IActiveXPlugin, (LPVOID*)&pIActiveXPlugin);
            if (hr)
                goto Cleanup;
            pIActiveXPlugin->Load( pszFullUrl, FALSE );
            ReleaseInterface(pIActiveXPlugin);
        }
    }
    else
    {    
        // Give derived classes a chance to perform special processing after the object has
        // been loaded in the normal way...
        PostLoad();
    }
    
    //
    // Second stage control creation
    //

    hr = THR(ConnectControl2(&dwFlags));
    if (hr)
        goto Error;

    //
    // Finally transition control to the loaded state.
    //

    hr = THR(TransitionTo(OS_LOADED));
    if (hr)
        goto Error;

    //
    // Set bit informing world that the control is downloaded and
    // ready.
    //

    _fObjAvailable = TRUE;

    OnControlReadyStateChanged(!(dwFlags & FSI_PNSCONNECTED));

    //
    // For certain controls we must add a Progsink until they inplace
    // activate so that the OnLoad() script event won't fire until the
    // control is ready for scripting
    //
    pici = GetInstantClassInfo();
    
    if (pici && (pici->dwCompatFlags & COMPAT_PROGSINK_UNTIL_ACTIVATED))
    {
        Assert( _dwProgCookie == 0 );  // these controls had better not support readystate.

        // FerhanE : We may be executing this call, in which case we will not have a progsink.
        //           We call GetFrameOrPrimarymarkup since it will return us a markup 
        //           that can have a progsink. ( inthis case hopefully the parser contextmarkup)
        //
        pMarkupContext = GetFrameOrPrimaryMarkup();

        IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->AddProgress(
            PROGSINK_CLASS_OTHER,
            &_dwProgCookie));
    }

Cleanup:

    //
    // Now that we've actually created the object, its size could have changed.
    // Also, the way a object initially gets put in its baseline state
    // (inplace active or whatever) is via a SetPos().  Thus we must ensure
    // the size is updated and SetPos() is called sending a ResizeElement notification.
    // If this olesite is being parented to the rootsite directly, there's
    // no need to call RequestResize because this ocx will never be drawn.
    //

    if (    GetFirstBranch()
        &&  GetUpdatedParentLayoutNode()
        &&  GetFirstBranch()->GetCascadeddisplay() != styleDisplayNone)
    {
        ResizeElement();
        pici = GetInstantClassInfo();
        
        if (pici && (pDoc->State() >= OS_INPLACE)
            && ((pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE) || 
                (pici->dwCompatFlags & COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE) ))
        {
            IGNORE_HR(TransitionToBaselineState(pDoc->State()));
        }
    }
    else
    {
        TransitionToBaselineState(pDoc->State());
    }


    //
    // Turn events back on
    //

    {
        CNotification   nf;

        nf.FreezeEvents(this, (void *)FALSE);
        Notify(&nf);
    }

    //
    // If an error occurred make for darn sure that any progsink
    // we created is deleted.
    //
    if (hr && _dwProgCookie)
    {
        Assert(pMarkupContext);
        IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->DelProgress(_dwProgCookie));
        _dwProgCookie = 0;
    }

    ReleaseCodeLoad();
 
    RRETURN(hr);

Error:
    //
    // this codepath completely aborts creation process
    //

    // Revoke client site (if set)
    if (dwFlags & FSI_CLIENTSITESET)
    {
        SetClientSite(NULL);
    }
    ClearInterface(&_pUnkCtrl);

    _state = OS_LOADED;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InstantitateObjectFromCF, public
//
//  Synopsis:   Creates a control using a license manager or class factory.
//
//  Arguments:  [pCF] -- Class Factory to use if license manager not available.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InstantiateObjectFromCF(
    IClassFactory * pCF,
    OLECREATEINFO * pinfo)
{
    HRESULT             hr;
    DWORD               dwCompatFlags;
    CDoc *              pDoc = Doc();
    IClassFactoryEx *   pCFEx = NULL;
    INSTANTCLASSINFO *  pici;
    CMarkup*            pMarkup = NULL;
    CWindow*            pWindow = NULL;
    
    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, pinfo->clsid, &_wclsid));
    if (hr)
        goto Cleanup;
        
    pici = GetInstantClassInfo();
    
    dwCompatFlags = pici ? pici->dwCompatFlags : 0;

    // Create the control.  If a license manager exists, use it.
    // Otherwise use provided class factory.
    //
    pMarkup = GetWindowedMarkupContext();
    pWindow = pMarkup ? pMarkup->GetWindowedMarkupContextWindow() : NULL;
    
    if ( pWindow &&
         pWindow->_pLicenseMgr )         
    {
        hr = THR_OLE(pWindow->_pLicenseMgr->CreateInstance(
                pinfo->clsid,
                (dwCompatFlags & COMPAT_AGGREGATE) ?
                        PunkInner() : NULL,
                IID_IUnknown,
                CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                (void **)&_pUnkCtrl));
    }
    else
    {
        //
        // Try IClassFactory3 first
        //

        if (OK(pCF->QueryInterface(IID_IClassFactoryEx, (void **)&pCFEx)))
        {
            hr = THR(pCFEx->CreateInstanceWithContext(
                (IOleClientSite *)&_Client, 
                (dwCompatFlags & COMPAT_AGGREGATE) ?
                    PunkInner() : NULL,
                IID_IUnknown, 
                (void **)&_pUnkCtrl));
        }
        else
        {
            hr = THR_OLE(pCF->CreateInstance(
                    (dwCompatFlags & COMPAT_AGGREGATE) ?
                            PunkInner() : NULL,
                    IID_IUnknown,
                    (void **)&_pUnkCtrl));
        }
    }
    if (hr)
        goto Cleanup;

    if (ETAG_OBJECT == Tag())
    {
        CDoc * pDoc2;
        CObjectElement * pOE;
        LPCTSTR pchType;
        pOE = DYNCAST(CObjectElement, this);
        Assert(_pUnkCtrl);
        HRESULT hr2 = _pUnkCtrl->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc2);
        if (!hr2)
        {
            pchType = pOE->GetAAtype();
            if (CompareString((LCID)NULL, NORM_IGNORECASE, _T("image/"), 6, pchType, 6))
            {
                pDoc2->_fInImageObject = 1;
            }
        }
    }

    if (dwCompatFlags & COMPAT_AGGREGATE)
    {
#if DBG == 1
    //
    // Debug mode check to verify that when we aggregate controls
    // we really get the private unknown of the control.  Even though
    // we're really selective about what we aggregate there have been
    // cases of certain unnamed controls which don't aggregate correctly.
    //

        IUnknown *  pUnk = NULL;

        hr = THR_OLE(QueryControlInterface(IID_IUnknown, (void **)&pUnk));
        if (OK(hr))
        {
            Assert(pUnk == _pUnkCtrl && "Control did not aggregate correctly");
            ReleaseInterface(pUnk);
        }
#endif
        _fXAggregate = TRUE;
    }

    MemSetName((this, "%s _pUnkCtrl=%08x", MemGetName(this), _pUnkCtrl));

    DbgTrackItf(GUID_NULL,
            "pUnkCtrl",
            TRUE,
            (void **)&_pUnkCtrl);

Cleanup:
    ReleaseInterface(pCFEx);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveFormatSupported
//
//  Synopsis:   Returns TRUE if the embedded control supports a save format
//              we can use.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
COleSite::SaveFormatSupported()
{
    HRESULT                hr;
    IPersistPropertyBag *  pPropBag = NULL;
    IPersistPropertyBag2 * pPropBag2 = NULL;
    IPersistStreamInit *   pStm = NULL;

    hr = THR_OLE(QueryControlInterface(IID_IPersistPropertyBag,
                                       (void **)&pPropBag));
    if (!hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IPersistPropertyBag2,
                                       (void **)&pPropBag2));
    if (!hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IPersistStreamInit,
                                       (void **)&pStm));

    if (!hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPropBag);
    ReleaseInterface(pPropBag2);
    ReleaseInterface(pStm);

    return hr == S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InstantitateObjectFromDataObject, public
//
//  Synopsis:   Creates a control from a data object.
//
//  Arguments:  [pDataObject] -- Data object to load from.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InstantiateObjectFromDataObject(IDataObject * pDataObject)
{
    HRESULT     hr = E_FAIL;
#ifndef WIN16
    static FORMATETC s_formatetcContent =
    {
        0,                  //CLIPFORMAT
        NULL,               //DVTARGETDEVICE FAR*
        DVASPECT_CONTENT,   //dwAspect
        -1,                 //lindex
        TYMED_NULL          //tymed
    };


    IStorage *  pStg = NULL;

    hr = THR(StgCreateDocfile(
                NULL,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                0, &pStg));

    if (hr)
        goto Cleanup;


    hr = THR_OLE(OleCreateFromData(pDataObject, IID_IOleObject, OLERENDER_DRAW,
                                   &s_formatetcContent,
                                   NULL,
                                   pStg,
                                   (void **)&_pUnkCtrl));

    if (hr)
        goto Cleanup;

    if (!SaveFormatSupported())
    {
        // If we can not persist the object, it is misleading to instantiate
        // it from the data.
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(AssignWclsidFromControl());
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStg);
#endif // ndef WIN16

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::RegisterForRelease
//
//  Synopsis:   Adds this element to the Doc array to recieve notifications when
//              it should release the contained OLE object
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
COleSite::RegisterForRelease()
{
    CMarkup * pMarkup = GetMarkup();

    if (!_fRegisteredForRelease && pMarkup)
    {
        pMarkup->RequestReleaseNotify(this);
        _fRegisteredForRelease = TRUE;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::UnregisterForRelease
//
//  Synopsis:   Removes this element from the Doc array to recieve notifications when
//              it should release the contained OLE object
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
COleSite::UnregisterForRelease()
{
    CMarkup * pMarkup = GetMarkup();

    if (_fRegisteredForRelease && pMarkup)
    {
        pMarkup->RevokeRequestReleaseNotify(this);
        _fRegisteredForRelease = FALSE;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::SetHostNames
//
//  Synopsis:   Passes along to this control the host name object
//              provided to the form.  Since the form is always
//              embedded, it is never the original source of the
//              names.  It can only pass along the strings passed
//              to its IOleObject::SetHostNames method.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::SetHostNames( )
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (!_fSetHostNames && ((LPTSTR)pDoc->_cstrCntrApp != NULL))
    {
        IOleObject * pObj;

        // Note: it's legal for the container object name to be NULL.

        hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
        if (!hr)
        {
            hr = THR_OLE(pObj->SetHostNames(
                    pDoc->_cstrCntrApp,
                    pDoc->_cstrCntrObj));

            ReleaseInterface(pObj);
        }

        _fSetHostNames = TRUE;
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::SetClientSite
//
//  Synopsis:   Sets the client site to whatever pointer is passed.  Supports
//                both IOleObject::SetClientSite and IObjectWithSite::SetSite
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::SetClientSite(IOleClientSite *pClientSite)
{
    IOleObject *pOleObject = NULL;
    IObjectWithSite *pObjSite = NULL;

#if DBG==1
    if (pClientSite)
    {
        pClientSite->AddRef();
        DbgTrackItf(IID_IOleClientSite, "CClient", FALSE, (void **)&pClientSite);
    }
#endif

    HRESULT hr = QueryControlInterface(IID_IOleObject, (void **)&pOleObject);

    if (OK(hr) && pOleObject)
    {
        hr = pOleObject->SetClientSite(pClientSite);
        ReleaseInterface(pOleObject);
    }
    else
    {
        hr = QueryControlInterface(IID_IObjectWithSite, (void **)&pObjSite);

        if (OK(hr) && pObjSite)
        {
            hr = pObjSite->SetSite(pClientSite);
            ReleaseInterface(pObjSite);
        }
        else
        {
            hr = S_OK;
        }
    }

    // We need the ViewLinkedWebOC flag of the WebOC set before it is initialized.

    if (_fViewLinkedWebOC)
    {
        IBrowserService* pBrowserSvc      = NULL;
        IWebBrowser2*    pWebBrowserFrame = NULL;

        IInitViewLinkedWebOC* pInitViewLinkedWebOC = NULL;


        HRESULT hr3 = E_FAIL;

        hr3 = IUnknown_QueryService(_pUnkCtrl,
                                    SID_SShellBrowser,
                                    IID_IBrowserService,
                                    (void**)&pBrowserSvc);
        if (SUCCEEDED(hr3))
        {
            hr3 = pBrowserSvc->QueryInterface(IID_IInitViewLinkedWebOC, 
                                              (void**)&pInitViewLinkedWebOC);
            if (SUCCEEDED(hr3))
            {              
                BOOL fIsAlreadyViewLinked;

                pInitViewLinkedWebOC->IsViewLinkedWebOC(&fIsAlreadyViewLinked);

                if (!fIsAlreadyViewLinked)
                {
                    CMarkup * pMarkup = GetMarkup();
                    Assert(pMarkup);

                    COmWindowProxy * pProxy = pMarkup->GetWindowPending();
                    Assert(pProxy);

                    CWindow * pWindow = pProxy->Window();
                    Assert(pWindow);

                    hr3 = pWindow->QueryService(SID_SWebBrowserApp,
                                                IID_IWebBrowser2,
                                                (void**)&pWebBrowserFrame);
                    if (SUCCEEDED(hr3))
                    {
                        pInitViewLinkedWebOC->SetViewLinkedWebOC(TRUE);
                        pInitViewLinkedWebOC->SetViewLinkedWebOCFrame(pWebBrowserFrame);

                        if (pWindow->_cstrName)
                        {
                            BSTR bstrFrameName = SysAllocString(pWindow->_cstrName);

                            pInitViewLinkedWebOC->SetFrameName(bstrFrameName);

                            SysFreeString(bstrFrameName);
                        }

                        ReleaseInterface(pWebBrowserFrame);
                    }

                    ReleaseInterface(pInitViewLinkedWebOC);
                }
            }
            
            ReleaseInterface(pBrowserSvc);
        }
    }

#if DBG==1
    if (pClientSite)
    {
        pClientSite->Release();
    }
#endif

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::TransitionTo, public
//
//  Synopsis:   Manage internal state transitions.
//
//  Arguments:  [state] -- the target state
//
//  Returns:    NOERROR iff sucessful
//
//  Notes:      This method manages "push" requests to
//              get us into a desired state. There are
//              a number of important "pull" requests that
//              change our state without going through here:
//              for example, OnUIDeactivate
//
//              IPD = IOleInPlaceObject::InPlaceDeactivate
//              UID = IOleInPlaceObject::UIDeactivate
//              + means that the state transition is incomplete
//
//   (from)
//           | PASSIVE | LOADED | RUNNING | INPLACE  | UIACTIVE | OPEN
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// PASSIVE   | Illegal |  SHN   |   Err   |    Err   |   Err    |  Err
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// LOADED    | Illegal |  NOP   | OleRun  |  DoVerb  |  DoVerb  |  DoVerb
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// RUNNING   | Illegal | Close  |   NOP   |  DoVerb  |  DoVerb  |  DoVerb
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// INPLACE   | Illegal |  IPD+  |   IPD   |   NOP    |  DoVerb  |   IPD+
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// UIACTIVE  | Illegal |  IPD+  |   IPD   |   UID    |   NOP    |   IPD+
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// OPEN      | Illegal | DoVerb+| DoVerb  |  DoVerb+ |  DoVerb+ |   NOP
//           |         |        |         |          |          |
//------------------------------------------------------------------------

HRESULT
COleSite::TransitionTo(OLE_SERVER_STATE state, LPMSG pMsg)
{
    HRESULT         hr;
    HWND            hWndCntr;
    IOleObject *    pObj;
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    // If we are not in a tree anymore and someone is trying to increase our
    // state, do not allow. If we allocate the olelayout with the line below,
    // we will end up leaking it since we are out of the tree.
    if (_fObjectReleased && ((OLE_SERVER_STATE)_state) < state)
    {
        return E_FAIL;
    }

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));

    Assert(state >= OS_LOADED && state <= OS_OPEN);
    Assert(_state <= OS_OPEN);

    //
    // It's ok to try to transition a site to >= OS_INPLACE even
    // if it's _fSizeThis or _fPositionThis is true because it just
    // means that it will be sized and SetObjectRects at sometime later.
    //      Assert(state < OS_INPLACE || _fPositionThis);
    //

    Assert(_cLockInPlaceActive == 0 ||
           (state == OS_INPLACE || state == OS_UIACTIVE));
    Assert(!(state == OS_UIACTIVE && _fNoUIActivate));

    //  Early exit if we're already in the requested state.
    if (state == State())
        return S_OK;

    //
    // If the object is not yet available, bail out now.
    // We could get into this situation if the safety confirmation
    // dialog is up for initializing a control
    //

    if (!_fObjAvailable)
        return S_OK;

    //
    // If the transition lock is on, bail out right now.  This means
    // we're in the middle of an ocx requested state change and some
    // document change is causing a transitionTo.
    //

    if (TestLock(OLESITELOCK_TRANSITION))
        return S_OK;

    //  Get state required by multiple state transitions

    hr = THR_NOTRACE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
    if (!OK(hr))
    {
        if (E_NOINTERFACE == hr)
            hr = S_OK;
        RRETURN(hr);
    }

    hWndCntr = (pDoc->_pInPlace) ? pDoc->_pInPlace->_hwnd : NULL;

    //  Loop until we're in the correct state or an error occurs

    while (state != State() && OK(hr))
    {
        switch(_state)
        {

#if DBG == 1
        //
        //  We don't use the TransitionTo method to get out of
        //  the OS_PASSIVE state.  Use the various IPersist*::Load
        //  methods instead.
        //

        case OS_PASSIVE:
            Assert(0 && "Transitioning a passive olesite");
            hr = E_FAIL;
            break;
#endif
        case OS_LOADED:
            switch (state)
            {
            case OS_RUNNING:
                hr = THR_OLE(OleRun(pObj));
                if (!hr)
                    _state = OS_RUNNING;

                break;

            // in the rest of the cases we can go direct (recall that DoVerb
            // will automatically run!)

            case OS_INPLACE:
                if (_fInsideOut)
                {
                    if (!_hemfSnapshot)
                    {
                        hr = THR(InPlaceActivate(pObj, hWndCntr, pMsg));
                    }
                }
                if (_state != OS_INPLACE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_UIACTIVE:
                if (!NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_UIACTIVATE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }
                if (_state != OS_UIACTIVE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_OPEN:
                hr = THR(SetHostNames());
                if (!hr && !NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_OPEN,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                    if (_state != OS_OPEN && OK(hr))
                    {
                        hr = E_NOTIMPL;
                    }
                }
                break;
            }
            break;

        case OS_RUNNING:
            switch(state)
            {
            case OS_LOADED:

                //  NOTE it is legal to close an object merely
                //    by letting go of all pointers to it; however,
                //    in practice we've encountered objects which
                //    do not cope with this usage.  So, we explicitly
                //    close everything.  (garybu, chrisz)

                hr = THR_OLE(pObj->Close(OLECLOSE_NOSAVE));
                switch (hr)
                {
                case S_OK:
                case E_NOTIMPL: // MS License Manager returns E_NOTIMPL
                case RPC_E_DISCONNECTED:
                    _state = OS_LOADED;
                    hr = S_OK;
                    break;
                }
                break;

            case OS_INPLACE:
            case OS_UIACTIVE:
                if (_fInsideOut)
                {   
                    // Hide local object when a print delegate is available.
                    // The local object can participate in measurement, but all drawing
                    // is done by print delegate via IViewObject::Draw
                    if (!_hemfSnapshot) // TODO PRINT 112553: do we still need this?
                    {
                        hr = THR(InPlaceActivate(pObj, hWndCntr, pMsg));
                    }
                }
                if (_state != OS_INPLACE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_OPEN:
                hr = THR(SetHostNames());
                if (!hr && !NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_OPEN,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                    if (_state != OS_OPEN && OK(hr))
                    {
                        hr = E_NOTIMPL;
                    }
                }
                break;
            }
            break;

        case OS_INPLACE:
            switch(state)
            {
            case OS_UIACTIVE:
                if (!NoUIActivate() && pLayout)
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_UIACTIVATE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }
                if (_state != OS_UIACTIVE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            default:
                if (_cLockInPlaceActive)
                {
                    hr = E_FAIL;
                }
                else
                {   // Some controls count on being hidden before deactivating:
                    pici = GetInstantClassInfo();
                    
                    if (pici && (pici->dwCompatFlags & COMPAT_SEND_HIDE))
                    {
                        CRect   rc;

                        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                        hr = THR_OLE(pObj->DoVerb(
                                OLEIVERB_HIDE,
                                pMsg,
                                &_Client,
                                0,
                                hWndCntr,
                                ENSUREOLERECT(&rc)));
                    }
                    // That OLEIVERB_HIDE above may have put us in a different
                    // state....
                    if( _state >= OS_INPLACE && NULL != _pInPlaceObject )
                    {
                        if(_fClipViaHwndOnly)
                        {
                            // For some VB controls we need to hook the window messages to remove a
                            //  user message that is causing window clip problems (IE6 bug 13321).
                            // Here we are removing the hooks
                            CView *     pView     = Doc()->GetView();
                            HWND        hwndControl;
                            _pInPlaceObject->GetWindow(&hwndControl);

                            Assert(pView);

                            // Check if the control window has hooks attached and detach them
                            if(pView != NULL && hwndControl != NULL && GetProp(hwndControl, VBCTRLHOOK_PROPNAME))
                            {
                                pView->RemoveVBControlClipHook(hwndControl);
                            }
                        }

                        // The following pulls us to OS_RUNNING
                        hr = THR_OLE(_pInPlaceObject->InPlaceDeactivate());
                    }
                }

                // if everything went well then our state should already be
                // in the running state.  Otherwise, something went wrong
                if (_state != OS_RUNNING && !hr)
                {
                    hr = E_FAIL;
                }
                break;
            }
            break;

        case OS_UIACTIVE:
            switch(state)
            {
            case OS_INPLACE:
                Assert(_fInsideOut);

                if (_pInPlaceObject)
                    hr = THR_OLE(_pInPlaceObject->UIDeactivate());
                else 
                    hr = E_UNEXPECTED;

                if (_state != OS_INPLACE && !hr)
                {
                    hr = E_FAIL;
                }
                break;

            default:
                // Some controls count on being hidden before deactivating:
                pici = GetInstantClassInfo();
                
                if (pici && (pici->dwCompatFlags & COMPAT_SEND_HIDE))
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_HIDE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }

                // That OLEIVERB_HIDE above may have put us in a different
                // state....
                if( _state >= OS_INPLACE && NULL != _pInPlaceObject )
                {
                    if(_fClipViaHwndOnly)
                    {
                        // For some VB controls we need to hook the window messages to remove a
                        //  user message that is causing window clip problems (IE6 bug 13321).
                        // Here we are removing the hooks
                        CView *     pView     = Doc()->GetView();
                        HWND        hwndControl;
                        _pInPlaceObject->GetWindow(&hwndControl);

                        Assert(pView);

                        // Check if the control window has hooks attached and detach them
                        if(pView != NULL && hwndControl != NULL && GetProp(hwndControl, VBCTRLHOOK_PROPNAME))
                        {
                            pView->RemoveVBControlClipHook(hwndControl);
                        }
                    }
                    hr = THR_OLE(_pInPlaceObject->InPlaceDeactivate());
                }
                if (_state != OS_RUNNING && !hr)
                {
                    hr = E_FAIL;
                }
                break;
            }
            break;

        case OS_OPEN:
            {
                CRect   rc;

                pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                hr = THR_OLE(pObj->DoVerb(
                        OLEIVERB_HIDE,
                        pMsg,
                        &_Client,
                        0,
                        hWndCntr,
                        ENSUREOLERECT(&rc)));
            }
            if (!hr)
            {
                pLayout->Invalidate();
                _state = OS_RUNNING;
                ::SetFocus(hWndCntr);
            }
            break;
        }
    }

    ReleaseInterface(pObj);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::TransitionToBaselineState
//
//  Synopsis:   Transitions this object to its proper baseline state,
//              given a maximum state allowed to the object
//
//  Arguments:  [osMax]     --  Maximum state allowed
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::TransitionToBaselineState(OLE_SERVER_STATE osMax)
{
    HRESULT hr;

    osMax = BaselineState(osMax);

    if (State() != osMax)
    {
        // prevent WM_ERASEBKGND flash
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
        hr = THR(TransitionTo(osMax));
    }
    else
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::TransitionToCorrectState
//
//  Synopsis:   In some circumstances, the object's baseline state may
//              change.  This method transitions the object to its new
//              baseline state, unless the object is currently the UI
//              Active object, in which case it is unaffected.
//
//  Arguments:  [osMax]     --  Maximum state allowed
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::TransitionToCorrectState()
{
    HRESULT hr;

    if (_state == OS_UIACTIVE)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(TransitionToBaselineState(Doc()->State()));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::InPlaceActivate
//
//  Synopsis:   Helper to encapsulate the inplace activation process
//
//  Arguments:  [pOleObject]    --  Ptr to the IOleObject
//              [hwnd]          --  Hwnd of the container
//              [pMsg]          --  Message to send while inplace activating
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::InPlaceActivate(IOleObject *pOleObject, HWND hwnd, LPMSG pMsg)
{
    CDoc *      pDoc            = Doc();

    AssertSz(!_hemfSnapshot, "InPlaceActivate must not be called on a snapshot");

    CRect   rc;
    HRESULT hr;
    CLock   Lock(this, OLESITELOCK_INPLACEACTIVATE);

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    INSTANTCLASSINFO * pici = GetInstantClassInfo();

    if (pici && pLayout && (pici->dwCompatFlags & COMPAT_SEND_SHOW))
    {
        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

        hr = THR_OLE(pOleObject->DoVerb(
                OLEIVERB_SHOW,
                pMsg,
                &_Client,
                0,
                hwnd,
                ENSUREOLERECT(&rc)));

        // Some buggy controls return S_FALSE instead of S_OK when they succeed.  This is
        // normally caused by returning the value of a boolean function which succeeds.  Treat
        // this scode as S_OK.  -- philco
        
        hr = (hr == S_FALSE) ? S_OK : hr;
            
        if (hr)
            goto Cleanup;
    }

    if (pLayout)
        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

    // Set up _hwndPrivate during inplace--activation.
    // Hack for PhotoSuite3 (#94834)
    Assert(!_hwndPrivate);

    if (pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE))
    {
        pDoc->_pElemOleSiteActivating = this;
    }
    hr = THR_OLE(pOleObject->DoVerb(
            OLEIVERB_INPLACEACTIVATE,
            pMsg,
            &_Client,
            0,
            hwnd,
            ENSUREOLERECT(&rc)));

    if (pDoc->_pElemOleSiteActivating)
    {
        pDoc->_pElemOleSiteActivating = NULL;
        Assert(pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE));
        Assert(GetHwnd() == NULL);
    }

    // Some buggy controls return S_FALSE instead of S_OK when they succeed.  This is
    // normally caused by returning the value of a boolean function which succeeds.  Treat
    // this scode as S_OK.  -- philco
    
    hr = (hr == S_FALSE) ? S_OK : hr;
            
    if (hr)
        goto Cleanup;
        
    pici = GetInstantClassInfo();
    
    if (pici && _dwProgCookie &&
        (pici->dwCompatFlags & COMPAT_PROGSINK_UNTIL_ACTIVATED))
    {
        CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup())->DelProgress(_dwProgCookie);
        _dwProgCookie = 0;
    }

    //
    // After inplace-activation also send down a SetObjectRects.  It
    // should not be necessary to do this, but unfortunately the marcwan
    // basectl framework has a bug where it does not clip correctly
    // if it's only inplace-activated without a subsequent SetObjectRects.
    // The bug is that the basectl framework does not go through its
    // SetWindowRgn code if it's only inplace-activated.  A SetObjectRects
    // after inplace-activation forces it down that code path. (anandra)
    //

    if (State() >= OS_INPLACE && _pInPlaceObject)
    {
        CView *     pView     = Doc()->GetView();
        CDispNode * pDispNode = (pView->IsActive() && pLayout)
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (pDispNode)
        {
            //  (bug #108313) this should prevent display tree from closing during 
            //  call HandleViewChange later in this block. 
            CView::CEnsureDisplayTree edt(pView);

            // make sure our deferred calls get processed later
            pView->OpenView();

            // set opacity on display node
            // (donmarsh) - being pessimistic here, because it's only a
            // small perf hit if the window is opaque and the display node is
            // transparent.  On the other hand, it is a rendering
            // bug if the window is transparent and the display node is opaque.
            pDispNode->SetOpaque(FALSE);
            
            DWORD       grfFlags = pDispNode->IsInView()
                                        ? VCF_INVIEW | VCF_INVIEWCHANGED | VCF_POSITIONCHANGED
                                        : VCF_INVIEWCHANGED | VCF_POSITIONCHANGED;
            CRect       rc;
            CRect       rcClip;

            pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);
            pLayout->GetClippedClientRect(&rcClip, COORDSYS_GLOBAL);

            pLayout->HandleViewChange(grfFlags, &rc, &rcClip, pDispNode);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetHwnd, CSite
//
//  Synopsis:   Return control's window, if any
//
//----------------------------------------------------------------------------

HWND
COleSite::GetHwnd()
{
    HWND hwnd = NULL;
    HWND hwndParent;
    CDoc *  pDoc = Doc();

    if (!_fObjAvailable || !_pInPlaceObject || !pDoc->_pInPlace)
        return NULL;

    // pretend there is no window if a delegate is supposed to draw
    // NOTE: we are assuming here that if a delegate exists, the local
    //       object should not be involved in drawing under any circumstances
    if (_hemfSnapshot)
        return NULL;

    _pInPlaceObject->GetWindow(&hwnd);
    if (!hwnd)
        return NULL;

    // the first time we notice that the control has an HWND (even a bogus one),
    // mark its display node for ViewChange.  This ensures that the HWND
    // participates in the "obscuring element" feature.
    // Don't do this if the controls's hwnd isn't a descendant of the main
    // window (IE6 13819).
    if (!_fHasHwnd && IsChild(pDoc->_pInPlace->_hwnd, hwnd))
    {
        _fHasHwnd = TRUE;

        // now that we know the control has an HWND, decide how to clip it.
        // Some controls behave better if we never set a clip rect in SetObjectRects,
        // but instead rely on SetWindowRgn to clip the window.
        IUnknown *punk1 = NULL;
        IUnknown *punk2 = NULL;

        if (S_OK == QueryControlInterface(IID_IVB5Control, (void**)&punk1) ||
            S_OK == QueryControlInterface(IID_IVB6Control, (void**)&punk2) )
        {
            _fClipViaHwndOnly = TRUE;

            ReleaseInterface(punk1);
            ReleaseInterface(punk2);
        }

        CView *     pView     = Doc()->GetView();
        CLayout *   pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        CDispNode * pDispNode = (pView->IsActive() && pLayout)
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (_fClipViaHwndOnly)
        {
            // We need to set a getmeesage hook, because the vb controls are sending
            // themselves a WM_USER+3202 (0x1082) message after which the reset their
            // window clip. This interferes with the way we clip them (IE6 bug 13321)
            if(!GetProp(hwnd, VBCTRLHOOK_PROPNAME))
            {
                pView->CreateVBControlClipHook(hwnd);
            }
        }

        // ask for ViewChange
        if (pDispNode)
        {
            CView::CEnsureDisplayTree edt(pView);
            pDispNode->RequestViewChange();
        }
    }

    hwndParent = ::GetParent(hwnd);
    if (hwndParent == pDoc->_pInPlace->_hwnd)
        return hwnd;

    // The object is being tricky and has inserted some windows
    // between the form and the window it returns from
    // IOleInPlaceActiveObject::GetWindow.  Find out what the
    // window handle that is a direct descendant of us is.

    if (!IsChild(pDoc->_pInPlace->_hwnd, hwnd))
    {
        TraceTag((tagError, "Window handle returned from object not a child of the Form!"));
        return hwnd;
    }

    while (hwndParent != pDoc->_pInPlace->_hwnd)
    {
        hwnd = hwndParent;
        hwndParent = ::GetParent(hwnd);
    }

    return hwnd;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::Passivate
//
//  Synopsis:   Called when main CSite reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use
//              IUnknown::Release instead.
//
//---------------------------------------------------------------

void
COleSite::Passivate()
{
#if defined(UNIX) && defined(ux10)
//  IEUNIX:  Ensure that the this object is not deleted before the
//  end of the function. (ReleaseObject results in deletion of this.

    CLock  lock(this);
#endif
    ReleaseObject();

    Assert(_cLockInPlaceActive == 0);
    Assert(!_pInPlaceObject);

    if (_pAtomTable)
    {
        _pAtomTable->Free();
        delete _pAtomTable;
        _pAtomTable = NULL;
    }

    if (_pci)
    {
        ReleaseInterface(_pci->_pTypeInfoEvents);
        delete _pci;
    }

    // Release control's private unknown.
    ClearInterface(&_pUnkCtrl);

    ClearInterface(&_pStreamHistory);
    if (_hemfSnapshot)
    {
        DeleteEnhMetaFile(_hemfSnapshot);
        _hemfSnapshot = NULL;
    }

    ClearRefresh();
    super::Passivate();
}

void
COleSite::ClearRefresh()
{
    FormsKillTimer(this, REFRESH_TIMER_ID);
    FormsFreeString(_pstrRefreshURL);
    _pstrRefreshURL = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::EnterTree
//
//  Synopsis:   Notification that this object is entering the tree.
//
//---------------------------------------------------------------
void
COleSite::EnterTree()
{
    // Since we are entering the tree, this object should transition
    // to the correct state.
    if (_fObjAvailable)
        IGNORE_HR(TransitionToBaselineState(Doc()->State()));

#ifndef NO_DATABINDING
    GetMarkup()->GetDataBindTask()->SetWaiting();
#endif // ndef NO_DATABINDING

}

//+---------------------------------------------------------------
//
//  Member:     COleSite::ReleaseObject
//
//  Synopsis:   Disconnect from the form.
//
//---------------------------------------------------------------

void
COleSite::ReleaseObject()
{

    // Ensure this object stays alive until the function returns.
    CLock lock(this);

    // if the underlying OLE object is already released, simply return.
    if (_fObjectReleased)
        return;

    _fObjectReleased = TRUE;

#ifndef NO_DATABINDING
    DetachDataBindings();
#endif // ndef NO_DATABINDING

    //         Temporary hack for controls built with MFC 4.0 (VC 3.0).
    //         COleControl::~COleControl does not release our advise
    //         sink, so we force COleControl to release it explicitly
    //         here.  We check for IViewObjectEx to avoid hurting the
    //         performance of our own controls.
    if (_pVO && !_fUseViewObjectEx)
    {
        IGNORE_HR(_pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL));
    }

    // If we are still holding onto the param bag, release it now.
    ReleaseParamBag();

    // Break reference count loop when control is aggregated
    // by releasing cached object pointers.

    ClearInterface(&_pDisp);
    ClearInterface(&_pVO);
    _fUseViewObjectEx = FALSE;

    // Since site's are generic non-ole things, we have to explicitly
    // ensure that we're at most in the loaded state.
    if (_state > OS_LOADED)
    {
        IGNORE_HR(TransitionTo(OS_LOADED));
    }

    Assert(_state <= OS_LOADED && "Object did not shutdown correctly.");

    // The above transitions the site from states above OS_LOADED
    // to OS_LOADED.  If all went well, the site should now be in either
    // the OS_LOADED or OS_PASSIVE state.  No matter what happened,
    // we now assume the site is in the OS_PASSIVE state.  This assumption
    // simplifies checks for unexpected calls in the client interfaces.

    _state = OS_PASSIVE;
    _fWindowlessInplace = FALSE;
    _fUseInPlaceObjectWindowless = FALSE;

    ReleaseCodeLoad();

    if (_dwProgCookie)
    {

        CMarkup *pMarkupContext = GetFrameOrPrimaryMarkup();
#if DBG==1
        if (!(!pMarkupContext || CMarkup::GetProgSinkHelper(pMarkupContext) || _lReadyState < READYSTATE_LOADED))
        {
            TraceTag((tagOleSiteAssert, "Possible update of a control we have in the compat list."));
        }        
#endif

        if (CMarkup::GetProgSinkHelper(pMarkupContext))
            IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->DelProgress(_dwProgCookie));

        _dwProgCookie = 0;
    }

    // Revoke the client site.
    SetClientSite(NULL);

    // Disconnect property notify sink.  Shouldn't need to do this,
    // but MSN controls will leak if we do not.

    if (_dwPropertyNotifyCookie)
    {
        DisconnectSink(_pUnkCtrl, IID_IPropertyNotifySink, &_dwPropertyNotifyCookie);
    }

    if (_dwEventSinkCookie)
    {
        DisconnectSink(_pUnkCtrl, 
            _fPrimaryConnection ? *GetpIIDDispEvent() : IID_IDispatch, 
            &_dwEventSinkCookie);
    }

    if (_fViewLinkedWebOC)
    {
        CMarkup * pMarkup = GetMarkup();

        if (pMarkup && pMarkup->HasWindow())
        {
            CWindow * pWindow = pMarkup->Window()->Window();
            
            if (pWindow && 
                ((!pWindow->_fDelegatedSwitchMarkup) || pMarkup->Doc()->_fActiveDesktop))
                pWindow->ReleaseViewLinkedWebOC();
        }
    }

    UnregisterForRelease();
}

HRESULT
COleSite::GetColors(CColorInfo *pCI)
{
    HRESULT hr;

    if (_pVO)
        hr = pCI->AddColors(_pVO);
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COleSite::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
COleSite::YieldCurrency(CElement * pElemNew)
{
    HRESULT hr;
    CDoc *  pDoc = Doc();

    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    // IE5 #62775. The control needs to yield UI. Remaining ui-active while not having
    // focus/currency is bad.
    if (_state >= OS_UIACTIVE)
    {
        // First, reset _pElemUIActive, in order to prevent the call to BecomeCurrentAndActive
        // on the parent in COleSite::CClient::OnUIDeactivate()
        pDoc->_pElemUIActive = NULL;

        YieldUI(pDoc->PrimaryRoot());
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::YieldUI
//
//  Synopsis:   Relinquish UI
//
//  Arguments:  pSiteNew    New site that wants UI
//
//--------------------------------------------------------------------------

void
COleSite::YieldUI(CElement *pElemNew)
{
    Assert(OS_UIACTIVE == _state);
    IGNORE_HR(TransitionToBaselineState(OS_INPLACE));
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::BecomeUIActive
//
//  Synopsis:   Force ui activity on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::BecomeUIActive()
{
    // Nothing to do here.  Controls are responsible for getting
    // into the UI active state if that's what they want.
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ActivationChangeRequiresRedraw
//
//  Synopsis:   Determine if change in activation requires redraw.
//
//----------------------------------------------------------------------------

BOOL
COleSite::ActivationChangeRequiresRedraw()
{
#if 0
    // TODO: Fix this! (brendand)

    BOOL fAbove = FALSE;

    Assert(!_fWindowlessInplace);

    // If the site's window will be positioned above some other site
    // with a window, or if the site will pop above a windowless site,
    // then redraw is required.

    return Doc()->_pSiteRoot->GetCurLayout()->CheckLayoutIntersect(
                            GetCurLayout(),
                            &fAbove,
                            SI_ABOVE | SI_BELOW | SI_BELOWWINDOWED);
#else
    return FALSE;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::BaselineState
//
//  Synopsis:   Returns the OLE state this object should be in, barring
//              other special circumstances, and subject to a "maximum"
//              state the object is allowed
//
//  Parameters: [osMax]     --  Maximum state allowed to the object;
//                              usually determined by the state of the
//                              enclosing form
//
//  Returns:    OLE_SERVER_STATE
//
//-------------------------------------------------------------------------

OLE_SERVER_STATE
COleSite::BaselineState(OLE_SERVER_STATE osMax)
{
    OLE_SERVER_STATE    os;
    INSTANTCLASSINFO *  pici = GetInstantClassInfo();
    
#if DBG == 1
    Assert(!g_Zero.ab[0]);
#endif

    // If we're locked in the inplace-active state, that's our baseline.
    //

    if (_cLockInPlaceActive > 0)
    {
        os = OS_INPLACE;
    }
    else if (pici && !IsDesignMode()
             && (   pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE
                 || pici->dwCompatFlags & COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE
                 || (_fActivateWhenVisible && (IsVisible(TRUE)))))
    {
        //
        // The baseline is inplace if the following conditions are met:
        //  1)  the doc is in browse mode           AND
        //  2)  the ocx is visible                  AND
        //  3)  we're an activate-when-visible ocx  OR
        //  4)  it's one which requires inplace
        //      activation *all* the time.

        //  The visibility check is defined as the ocx's visible property
        //  should be set to true (hidden is not set) and the site is
        //  in the doc's current view rect.  However, if all these conditions
        //  are met except for the view rect one, we look at the current state.
        //  If this is > INPLACE, then we stay right here.
        //

        os = OS_INPLACE;
    }
    else if (_fAlwaysRun || _state >= OS_RUNNING || 
            (GetMarkup() && GetMarkup()->SearchBranchForTagInStory(GetFirstBranch(), ETAG_HEAD)))
    {
        //
        // Otherwise if this control is marked to be always running
        // or if we're already greater than running, the base-line
        // is running.
        //

        os = OS_RUNNING;
    }
    else
    {
        //
        // Otherwise, the baseline is just plain old OS_LOADED.
        //

        os = OS_LOADED;
    }

    if (os > osMax)
        os = osMax;

    return os;
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::CacheDispatch
//
//  Synopsis:   Fill in our pointer to the control's IDispatch, if it
//              has one.
//
//-------------------------------------------------------------------------

void
COleSite::CacheDispatch()
{
    if (_fDispatchCached || !_pUnkCtrl)
        return;

    INSTANTCLASSINFO * picti = GetInstantClassInfo();

    // if we havne' determined if the control is IDispatchEx yet, then
    // call this.
    if (picti && !picti->HasIDex2BeenCalled())
    {
        IDispatchEx * pDispEx2 = NULL;

        THR_NOTRACE(QueryControlInterface(IID_IDispatchEx,
                                               (void **)&pDispEx2));
        picti->SetIsDispatchEx2( !!pDispEx2 );
        ReleaseInterface(pDispEx2);
    }

    IGNORE_HR(QueryControlInterface(IID_IDispatch, (void **)&_pDisp ));

    _fDispatchCached = TRUE;
}

HRESULT
COleSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = super::Save ( pStreamWrBuff, fEnd );
    if ( !hr )
    {
        _fDirty = FALSE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsClean, COleSite
//
//  Synopsis:   Return S_OK if contained object is clean.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::IsClean(void)
{
    HRESULT hr = S_FALSE;

    // If we are an HTML control site don't use the control's dirty state
    // because we are setting properties in it from HTML

    if (_fDirty)
        return S_FALSE;

    IPersistStreamInit * pPSI;

    if (OK(THR_OLE(QueryControlInterface(IID_IPersistStreamInit, (void **)&pPSI))))
    {
        hr = THR_OLE(pPSI->IsDirty());
        pPSI->Release();
    }

    hr = (hr == S_FALSE) ? S_OK : S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::GetReadyState
//
//  Synopsis:   Returns the readystate of the object.  If not supported
//              an error is returned
//
//  Arguments:  plReadyState    Resultant readystate
//
//  Returns:    S_OK if control supports ReadyState natively.
//              S_FALSE if control doesn't support ReadyState.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::GetReadyState(long *plReadyState)
{
    HRESULT     hr = S_OK;
    CVariant    Var;

    CacheDispatch();
    if (!_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR_NOTRACE(GetDispProp(
            _pDisp,
            DISPID_READYSTATE,
            g_lcidUserDefault,
            &Var,
            NULL));
    if (hr)
        goto Cleanup;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        *plReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        *plReadyState = V_I2(&Var);
    }
    else
    {
        hr = E_FAIL;
    }

#if DBG==1
    if (hr == S_OK)
    {
        VerifyReadyState(*plReadyState);
    }
#endif

Cleanup:

    // If the control doesn't support the readystate property, that's ok.
    // Just return S_FALSE to indicate that.
    if (DISP_E_MEMBERNOTFOUND == hr)
        hr = S_FALSE;

    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::GetBoolPropertyOnObject
//
//  Synopsis:   Returns TRUE if the property is not a member of the control or
//              if the property exists it's value is TRUE.  Returns FALSE only
//              if the property exists and it's value is FALSE.
//
//  Arguments:  dispid -- dispatch ID of property to read.
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
COleSite::GetBoolPropertyOnObject(DISPID dispid)
{
    HRESULT hr;
    BOOL    fBoolean = TRUE;            // Any failure with the one exception
                                        // will return TRUE (see below).

    CacheDispatch();

    // Does the object support IDispatch?
    if (_pDisp)
    {
        // Yes, try to get the property?
        CVariant var;

        hr = THR_NOTRACE(GetDispProp(_pDisp,
                                     dispid,
                                     LOCALE_SYSTEM_DEFAULT,
                                     &var));
        if (!hr)
        {
            if (var.vt == VT_BOOL)
                fBoolean = var.boolVal;
            else
                hr = DISP_E_MEMBERNOTFOUND;
        }

        // Did we get a problem accessing the property?
        if (hr && !DISPID_NOT_FOUND(hr))
        {
            // some other error: the DISPID_ENABLED property will disable the
            // control 

            // Yes, and it wasn't because the property wasn't there so set it to
            // false.
            TraceTag((tagWarning, "COleSite::GetBoolPropertyOnObject -- %l "
                                     "via Dispatch returns %hr", dispid, hr));

            fBoolean = FALSE;
        }
    }

    return fBoolean;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
COleSite::HandleMessage(CMessage * pMessage)
{
    HRESULT         hr      = S_FALSE;
    IOleControl *   pCtrl   = NULL;
    LRESULT         lr;
    CDoc *          pDoc = Doc();
    BOOL fBranchTaken = FALSE;
    BOOL fEditable = IsEditable(/*fCheckContainerOnly*/FALSE);

    if ( !_fObjAvailable )
    {
        RRETURN1(hr, S_FALSE);
    }
    
    // Note: WM_SETCURSOR and WM_CONTEXTMENU messages can arrive
    // here after bubbling up from a windowed control in another
    // thread.  We are careful about calling the control methods
    // in this scenario because OLE does not allow it.

#if !defined(WINCE) && !defined(_MAC)
    if (pMessage->message != WM_ERASEBKGND &&
        pMessage->message != WM_SETCURSOR &&
        InSendMessage())
    {
        //
        // If the message is not erasebkgnd or setcursor and
        // we're in the middle of some ole thread synchronization
        // then re-post this message so that the control thread
        // is no longer waiting on us.  Add other messages here on
        // a case-by-case basis.
        //

        PostMessage(
            pDoc->_pInPlace->_hwnd,
            pMessage->message,
            pMessage->wParam,
            pMessage->lParam);
        hr = S_OK;  // To signify that we handled the message.
        goto Cleanup;
    }
#endif // GAL_VERSION

    // Check for special internal messages first.

    if (pMessage->message == WM_MOUSELEAVE)
    {
        fBranchTaken = TRUE;
        if (_fWindowlessInplace)
        {
            hr = THR_OLE(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                OnWindowMessage(
                    pMessage->message,
                    pMessage->wParam,
                    pMessage->lParam,
                    &lr));
        }

        if (_fDeactivateOnMouseExit)
        {
            IGNORE_HR(TransitionToCorrectState());
        }
    }

    if (!fBranchTaken )        
    {
        if (_fWindowlessInplace)
        {
            //
            // Otherwise, if the control we're holding is windowless
            // inplace, let it handle the message.
            //
#ifdef _MAC
            pMessage->lParam = MAKELPARAM(pMessage->ptContent.x, pMessage->ptContent.y);
#endif
            hr = THR_OLE(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                    OnWindowMessage(
                        pMessage->message,
                        pMessage->wParam,
                        pMessage->lParam,
                        &lr));

        }
        else if (pMessage->message == WM_CONTEXTMENU)
        {
            //
            // Show context menu on behalf of the control.
            // A number of control don't handle themselves context
            // menus upon reception of WM_CONTEXTMENU, but do it
            // instead upon reception of WM_RBUTTONUP. To compensate,
            // in browse mode, eat up the context menu message and never
            // show a context menu on behalf of the ocx. (anandra)
            //

            //
            // Certain OLE Sites can "eat" WM_RBUTTONUP messages.
            // We hence pass the WM_CONTEXTMENU to mshtmled where we can set 
            // state saying we got an RBUTTONUP
            if (fEditable)
            {
                hr = THR(OnContextMenu(
                        (short) LOWORD(pMessage->lParam),
                        (short) HIWORD(pMessage->lParam),
                        CONTEXT_MENU_CONTROL));
            }
            else
            {
                hr = S_OK;
            }
        }
        else if (_state < OS_INPLACE)
        {
            // Otherwise, the form is in run-mode and the control is inactive
            // Pass messages to inactive control as appropriate.
            switch (pMessage->message)
            {
                //
                // marka - we used to always go UI Active on Mouse Down.
                // we now want to go UI Active on Mouse UP in design mode
                // this allows single click dragging of site selected controls 
                // ( because control wont go UI Active on Mouse Down ).
                //
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));
                }
                break;

                //
                // Always go UI Active on double click
                //
            case WM_LBUTTONDBLCLK:  
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));                                    
                }                
                else
                {
                    //
                    // At design time - the decision to go Active is up tot hte tracker
                    //
                    hr = S_FALSE;
                }
                break;

            case WM_SETCURSOR:
                if ( ! fEditable && ! IsMasterParentEditable() )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));
                }
                else 
                {
                    hr = super::HandleMessage(pMessage);
                    if (hr == S_FALSE)
                    {
                       SetCursorStyle(IDC_SIZEALL);
                    }
                }
                hr = S_OK;
                break;
                
            case WM_MOUSEMOVE:
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMousePtrMessage(pMessage, GetFirstBranch(), &lr));
                }
                else
                {
                    hr = S_FALSE;
                }                    
                break;

#ifndef NO_MENU
            case WM_INITMENUPOPUP:
                hr = THR(OnInitMenuPopup(
                        (HMENU) pMessage->wParam,
                        (int) LOWORD(pMessage->lParam),
                        (BOOL) HIWORD(pMessage->lParam)));
                break;
#endif // NO_MENU

            default:
                hr = THR(super::HandleMessage(pMessage));
                break;
            }
        }
        else if (!((pMessage->dwKeyState & FALT) &&
                (pMessage->message == WM_KEYDOWN ||
                pMessage->message == WM_SYSKEYDOWN ||
                pMessage->message == WM_CHAR ||
                pMessage->message == WM_SYSCHAR) &&
                pMessage->wParam != VK_MENU))
        {
            //
            // Handle WM_SETCURSOR & WM_ERASEBKGND right here due to
            // the ole synchronization problem with multiple threads, where
            // the ctrl thread is waiting on processing of these messages.
            //

            if (pMessage->message == WM_ERASEBKGND ||
                pMessage->message == WM_SETCURSOR)
            {
                hr = S_FALSE;
            }
            else
            {
                // Otherwise, if the message is not an accelerator, as signified
                // by the alt key not being held down, pass it to default processing.
                hr = super::HandleMessage(pMessage);
                // No bubbling up to parent here.
                goto Cleanup;
            }
        }
        else
        {
            hr = THR(super::HandleMessage(pMessage));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pCtrl);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnMnemonic, public
//
//  Synopsis:   Indicates that our mnemonic has been pressed by the user.
//
//  Arguments:  [pMsg] -- Message corresponding to our mnemonic
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::OnMnemonic(LPMSG lpmsg)
{
    HRESULT         hr      = S_FALSE;
    IOleControl *   pCtrl   = NULL;

    if (!THR_OLE(QueryControlInterface(IID_IOleControl, (void **) &pCtrl)))
    {
        hr = THR_OLE(pCtrl->OnMnemonic(lpmsg));
        pCtrl->Release();
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnMenuEvent, public
//
//  Synopsis:   Handles context menu items for this site.
//
//  Arguments:  [id]   -- Menu item ID
//              [code] -- Menu code
//
//  Returns:    TRUE if the message is handled.  FALSE if we want the form
//              to provide default behavior for that menu item.
//
//----------------------------------------------------------------------------

BOOL
COleSite::OnMenuEvent(int id, UINT code)
{

    if (IsDesignMode())
    {
        //
        //  Embedded object verbs on the context menu.  All other context menu
        //  items are handled by the form.
        //

        if (id >= IDM_OBJECTVERBLIST0 && id <= IDM_OBJECTVERBLISTLAST)
        {
            DoEmbedVerbs(id - IDM_OBJECTVERBLIST0);
            return TRUE;
        }

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleSite::OnControlChanged
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnChanged notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnChanged forwarding.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::OnControlChanged(DISPID dispid)
{
    HRESULT             hr          = S_OK;

    if (dispid != DISPID_READYSTATE)
        _fDirty = TRUE;

    // handle changes in readystate
    if (dispid == DISPID_READYSTATE || dispid == DISPID_UNKNOWN)
    {
        OnControlReadyStateChanged();
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COleSite::OnControlReadyStateChanged
//
//  Synopsis:   Handle readystate change notifications from control
//
//--------------------------------------------------------------------------

void
COleSite::OnControlReadyStateChanged(BOOL fForceComplete)
{
    long    lReadyState;
    long    lReadyStateOrig = _lReadyState;
    HRESULT hr;
    BOOL    fNativeSupport = FALSE;

    fNativeSupport = (THR_NOTRACE(GetReadyState(&lReadyState)) == S_OK);

    if (fForceComplete || (!fNativeSupport))
    {
        // If we have trouble getting the readystate, assume it's complete.
        lReadyState = READYSTATE_COMPLETE;
    }

    if (lReadyState == READYSTATE_COMPLETE)
    {
        if (_iRefreshTime > 0)
        {
            FormsSetTimer(this,
                          ONTICK_METHOD(COleSite, RefreshCallback, refreshcallback),
                          REFRESH_TIMER_ID,
                          _iRefreshTime);
            _iRefreshTime = 0; // in case we become READYSTATE_COMPLETE again
        }
    }

    TraceTagEx((tagOLEWatch,
        TAG_NONAME,
        "COleSite::OnControlReadyStateChange SSN=0x%x, _lreadystate=0x%x lreadystate=0x%x",
        _ulSSN,
        _lReadyState,
        lReadyState));

    // change by cfranks 8 May 1997:
    // We now allow controls that are in the complete state to transition
    // as far back as loaded, but not further back. (Example: data source
    // controls can have a new query run against them, in which case they
    // might go COMPLETE -> LOADED -> INTERACTIVE -> COMPLETE again.)
    if (_lReadyState == READYSTATE_COMPLETE && lReadyState < READYSTATE_LOADED)
    {
        return;                         // not further back than LOADED
    }

    if (_lReadyState != lReadyState ||
        _lReadyState == READYSTATE_UNINITIALIZED)
    {
        IProgSink * pProgSink = CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup());

        if (pProgSink)
        {
            if (lReadyState < READYSTATE_LOADED)
            {
                if (_dwProgCookie == 0)
                {
                    // Until we're in the loaded state, we need to add progress on
                    // the PROSINK_CLASS_CONTROL class.

                    IGNORE_HR(pProgSink->AddProgress(GetProgSinkClass(),
                        &_dwProgCookie));
                }
            }
            else if (lReadyState < READYSTATE_COMPLETE)
            {
                if (_lReadyState < READYSTATE_LOADED)
                {
                    DWORD dwProgCookie = _dwProgCookie;
                    _dwProgCookie = 0;

                    // Until we're in the complete state, we need to add progress
                    // on the PROGSINK_CLASS_OTHER class.

                    hr = THR(pProgSink->AddProgress(GetProgSinkClassOther(),
                            &_dwProgCookie));

                    if (hr)
                    {
                        _dwProgCookie = dwProgCookie;
                        goto Cleanup;
                    }

                    if (dwProgCookie)
                    {
                        pProgSink->DelProgress(dwProgCookie);
                    }
                }
            }
            else if (_dwProgCookie)
            {
                // We're all done.  Remove the progress from the document.

                pProgSink->DelProgress(_dwProgCookie);
                _dwProgCookie = 0;
            }
        }

        _lReadyState = lReadyState;

#ifndef NO_DATABINDING
        if (    lReadyStateOrig < READYSTATE_LOADED
            &&  lReadyState >= READYSTATE_LOADED
            &&  Tag() != ETAG_IFRAME   &&  Tag() != ETAG_FRAME
            &&  !_fFailedToCreate)
        {
            // the control/applet can now respond to more questions;
            // try doing more databinding
            AttachDataBindings();
        }
#endif // ndef NO_DATABINDING

        if (    Tag() == ETAG_FRAME
            &&  _lReadyState >= LOADSTATUS_INTERACTIVE
            &&  GetMarkup()->LoadStatus() < LOADSTATUS_INTERACTIVE)
        {
            GetMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
        }
    }

Cleanup:
    // If ready state has changed, fire the READYSTATECHANGE event on behalf
    // of the control (but only if it doesn't fire the event itself).
    if (_lReadyState != lReadyStateOrig)
    {
        if (_lReadyState == READYSTATE_COMPLETE)
            hr = THR(Doc()->CommitScripts(GetMarkup(), this));

        if (!fNativeSupport)
        {
            OLESITE_TAG ostag = OlesiteTag();

            if (ostag == OSTAG_ACTIVEX || ostag == OSTAG_APPLET)
            {
                DYNCAST(CObjectElement, this)->Fire_onreadystatechange();
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   LooksLikePropertiesVerb
//
//  Synopsis:   Return true if the given string is likely to be the
//              properties verb.
//
//              We are forced to use this disgusting hack because we don't
//              know of a more reliable mechanism to determine if an object
//              has a properites verb.
//
//  Arguments:  pstrVerb    String to examine
//
//
//-------------------------------------------------------------------------
BOOL
LooksLikePropertiesVerb(TCHAR *pstrVerb)
{
    TCHAR achPropertiesVerb[FORMS_MAXVERBNAMLEN + 1];
    TCHAR *pch1 = pstrVerb;
    TCHAR *pch2 = achPropertiesVerb;
    TCHAR s_achNoise[] = _T("&.");

    if (!pch1)
    {
        return FALSE;
    }

    LoadString(GetResourceHInst(),
               IDS_PROPVERB,
               achPropertiesVerb,
               ARRAY_SIZE(achPropertiesVerb));

    for (;;)
    {
        // Skip over noise characters

        while (*pch1 && _tcschr(s_achNoise, *pch1))
            pch1 += 1;

        while (*pch2 && _tcschr(s_achNoise, *pch2))
            pch2 += 1;

        // CONSIDER: do comparison in lowercase.

        if (*pch1 != *pch2)
            return FALSE;

        if (*pch1 == 0)
            return TRUE;

        Assert(*pch1 != 0 && *pch2 != 0);

        pch1 += 1;
        pch2 += 1;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::DoEmbedVerbs, public
//
//  Synopsis:   Invokes a verb on an embedding when the user selects it from
//              the context menu.
//
//  Arguments:  [usVerbIndex] -- 0-based index of the verb as returned from
//                               the enumerator.
//
//----------------------------------------------------------------------------

void
COleSite::DoEmbedVerbs(USHORT usVerbIndex)
{
    USHORT        i          = 0;
    long          lVerb      = 0;
    IOleObject *  pObj       = NULL;
    IEnumOLEVERB *pEnumVerb  = NULL;
    HRESULT       hr;
    OLEVERB       verb;
    CRect         rc;

    // We should never have been able to get here if the number of selected
    // sites wasn't one.
    //
    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);

    Assert(Doc()->GetSelectionType() == SELECTION_TYPE_Control );

    hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pObj->EnumVerbs(&pEnumVerb));
    if (hr)
        goto Cleanup;

    // Get the verb number (lVerb)

    while(pEnumVerb->Next(1, &verb, NULL) == S_OK)
    {
        CoTaskMemFree(verb.lpszVerbName);
        if ((verb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU) &&
                verb.lVerb != OLEIVERB_PROPERTIES &&
                !LooksLikePropertiesVerb(verb.lpszVerbName))
        {
            if (i == usVerbIndex)
            {
                lVerb = verb.lVerb;
                break;
            }
            i++;
        }
    }

    Assert(i == usVerbIndex);

     // Set the host names just in case it's opening.
    IGNORE_HR(SetHostNames());

    Assert(Doc()->_pInPlace);

    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

    IGNORE_HR(pObj->DoVerb(lVerb,
                           NULL,
                           &_Client,
                           0,
                           Doc()->_pInPlace->_hwnd,
                           ENSUREOLERECT(&rc)));

Cleanup:
    ReleaseInterface(pObj);
    ReleaseInterface(pEnumVerb);
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetControlInfo, public
//
//  Synopsis:   Returns a filled in CONTROLINFO struct for this object.
//
//  Arguments:  [pci] -- Struct to fill in.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetControlInfo(CONTROLINFO *pci)
{
    IOleControl *   pCtrl;
    HRESULT         hr;

    // Can't just do a memset because of pci->cb

    pci->hAccel = NULL;
    pci->cAccel = 0;
    pci->dwFlags = 0;

    hr = THR_OLE(QueryControlInterface(IID_IOleControl, (void **) &pCtrl));
    if (!hr)
    {
        hr = THR_OLE(pCtrl->GetControlInfo(pci));

        pCtrl->Release();

        if (pci->dwFlags & CTRLINFO_EATS_RETURN)
            _fEatsReturn = TRUE;
        else
            _fEatsReturn = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnInactiveMousePtrMessage
//
//  Synopsis:   Handle WM_SETCURSOR, WM_MOUSEMOVE on inactive control.
//
//----------------------------------------------------------------------------
HRESULT
COleSite::OnInactiveMousePtrMessage(CMessage *pMessage, CTreeNode * pNodeContext, LRESULT *plResult)
{
    HRESULT             hr;
    IPointerInactive *  pPI = NULL;
    DWORD               dwPolicy;
    RECT                rc;
    POINT               pt;

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);
    Assert( ! IsEditable(/*fCheckContainerOnly*/FALSE) );
    
    if (THR_NOTRACE(QueryControlInterface(
                IID_IPointerInactive, (void **) &pPI)))
    {
        hr = THR(super::HandleMessage(pMessage));
        goto Cleanup;
    }

    hr = THR(pPI->GetActivationPolicy(&dwPolicy));
    if (hr)
        goto Cleanup;

    if (dwPolicy & POINTERINACTIVE_DEACTIVATEONLEAVE)
    {
        _fDeactivateOnMouseExit = TRUE;
    }

    if (dwPolicy & POINTERINACTIVE_ACTIVATEONENTRY)
    {
        hr = THR(TransitionTo(OS_INPLACE, NULL));
        if (hr)
            goto Cleanup;
    }

    // If the control became windowless inplace in TransitionTo, then
    // pass the message along to the control. Otherwise, use
    // IPointerInactive.
    if ( _fWindowlessInplace )
    {

        hr = THR(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                OnWindowMessage(
                        pMessage->message,
                        pMessage->wParam,
                        pMessage->lParam,
                        plResult));
    }
    else
    {
        if (pMessage->message == WM_MOUSEMOVE)
        {
            CRect   rc;

            pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

            hr = THR_NOTRACE(pPI->OnInactiveMouseMove(
                                        &rc,
                                        MAKEPOINTS(pMessage->lParam).x,
                                        MAKEPOINTS(pMessage->lParam).y,
                                        pMessage->wParam));
        }
        else
        {
            GetCursorPos(&pt);
            ScreenToClient(Doc()->_pInPlace->_hwnd, &pt);

            // See if the control wants to set the cursor
            hr = THR(pPI->OnInactiveSetCursor(
                &rc,
                pt.x,
                pt.y,
                HIWORD(pMessage->lParam),
                FALSE));

            //
            //(ferhane) The spec says that we can only receive an S_FALSE, but ATL 
            // returns E_NOTIMPL for the default case. We are accomodating the vast 
            // number of NT ATL controls here.
            //
            if ( (hr == S_FALSE) || (hr == E_NOTIMPL) )
            {
                CTreeNode * pNodeParent = pNodeContext->GetUpdatedParentLayoutNode();
                Assert(pNodeParent);

                // Control did not set the cursor, give the container a chance
                // Call HandleMessage directly because we do not want bubbling here.
                hr = THR(pNodeParent->Element()->HandleMessage(pMessage));

                // The container did not set the cursor
                // Force the control to do it
                if (*plResult == FALSE)
                {
                    hr = THR(pPI->OnInactiveSetCursor(
                        &rc,
                        pt.x,
                        pt.y,
                        HIWORD(pMessage->lParam),
                        TRUE));
                    if (hr == S_FALSE)
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pPI);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnInactiveButtonMessage
//
//  Synopsis:   Handle WM_xBUTTONDOWN, WM_LBUTTONDBLCLK on inactive control.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::OnInactiveMouseButtonMessage(CMessage *pMessage, LRESULT *plResult)
{
    HRESULT      hr = S_OK;
    int          iVerb;
    MSG          msg;
    UINT         message;
    IOleObject * pObj = NULL;
    CRect        rc;
    INSTANTCLASSINFO * pici;

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);
    Assert( ! IsEditable(/*fCheckContainerOnly*/FALSE) );

    if (OK(THR_OLE(QueryControlInterface(IID_IOleObject, (void  **)&pObj))))
    {
        CDoc *  pDoc = Doc();

        message = pMessage->message;
        if (pMessage->message == WM_LBUTTONDBLCLK)
        {
            // Use 0 == default verb for double click.
            iVerb = 0;

            // Make double click look like single click.
            message = WM_LBUTTONDOWN;

            // Set the host names in case control opens in default verb.
            IGNORE_HR(SetHostNames());
        }
        else
        {
            //
            // Temp fix for IE5 bug 45562.  (anandra) Too risky to make this change
            // in full right now, should do this post beta2. BUG 48041 has been
            // raided about this.  
            //

            if (IsDesignMode() &&
                (pDoc->_fNoActivateNormalOleControls ||
                 pDoc->_fNoActivateDesignTimeControls ||
                 pDoc->_fNoActivateJavaApplets))
            {
                // Only vid sets these bits so we should only come here for them.
                hr = S_OK;
                if (!NoUIActivate())
                {
                    hr = THR(TransitionTo(OS_UIACTIVE, pMessage));
                }
                goto Cleanup;
            }

            pici = GetInstantClassInfo();
            
            // inplace activate in all cases, except:
            // in design mode, controls which do not do menu merge
            iVerb = (IsDesignMode() && pici &&
                     !(OLEMISC_WANTSTOMENUMERGE & pici->dwMiscStatusFlags)) ?
                        OLEIVERB_UIACTIVATE :
                        OLEIVERB_INPLACEACTIVATE;
        }

        msg = *(MSG *)pMessage;
        msg.message = message;

        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

        hr = THR_OLE(pObj->DoVerb(
                iVerb,
                &msg,
                &_Client,
                0,
                pDoc->_pInPlace->_hwnd,
                ENSUREOLERECT(&rc)));

        if (!hr && _state < OS_RUNNING)
        {
            _state = OS_RUNNING;
        }
    }

Cleanup:
    ReleaseInterface(pObj);
    RRETURN(hr);
}


#ifndef NO_MENU
//+------------------------------------------------------------------------
//
//  Member:     COleSite::InitMenuPopup
//
//  Synopsis:   Handles WM_CONTEXTMENU message after default handling occurs.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::OnInitMenuPopup(HMENU hmenu, int item, BOOL fSystemMenu)
{
    IOleObject *    pObj = NULL;
    IEnumOLEVERB *  pEnumVerb = NULL;
    OLEVERB         verb;
    HRESULT         hr;
    UINT            i;
    ULONG           cFetched;
    CDoc *          pDoc = Doc();

    hr = super::OnInitMenuPopup(hmenu, item, fSystemMenu);
    if (hr)
        goto Cleanup;

    // Clean up the verbs on the context menu from last time

    if (pDoc->_usNumVerbs)
    {
        for (i=0; i < pDoc->_usNumVerbs; i++)
        {
            DeleteMenu(hmenu, IDM_OBJECTVERBLIST0+i, MF_BYCOMMAND);
        }

        pDoc->_usNumVerbs = 0;
    }

    //
    // If we're the only site selected, then add the verbs of the embedding
    // to the context menu.
    //

    if (pDoc->GetSelectionType() == SELECTION_TYPE_Control )
    {
        hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(pObj->EnumVerbs(&pEnumVerb));
        if (hr)
            goto Cleanup;

        while (pEnumVerb->Next(1, &verb, &cFetched) == S_OK)
        {
            if (verb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU)
            {
                // If it is the properties verb or it looks like the
                // properties verb, then add a menu item for our own
                // properites command.  This insures that our own
                // properties command will always be available, but
                // has the potential for hiding an object verb that just
                // happens to look like the property verb.

                if (verb.lVerb == OLEIVERB_PROPERTIES ||
                        LooksLikePropertiesVerb(verb.lpszVerbName))
                {
#ifdef NEVER
                    fHasPropertiesVerb = TRUE;
                    AppendMenu(hmenu,
                           MF_STRING | MF_ENABLED,
                           IDM_PROPERTIES,
                           verb.lpszVerbName);
#endif
                }
                else
                {
                    AppendMenu(hmenu,
                               MF_STRING | verb.fuFlags,
                               IDM_OBJECTVERBLIST0+pDoc->_usNumVerbs,
                               verb.lpszVerbName);

                    pDoc->_usNumVerbs += 1;

                    if (pDoc->_usNumVerbs > (IDM_OBJECTVERBLISTLAST - IDM_OBJECTVERBLIST0 + 1))
                        break;
                }
            }

            CoTaskMemFree(verb.lpszVerbName);
        }
    }

#ifdef NEVER
    // Add a properties verb if object didn't have one or it's multi-select.

    if (!fHasPropertiesVerb)
    {
       AppendMenu(hMenu,
               MF_STRING | MF_ENABLED,
               IDM_PROPERTIES,
               g_szPropertiesVerb);
    }
#endif // NEVER

Cleanup:
    ReleaseInterface(pObj);
    ReleaseInterface(pEnumVerb);

    RRETURN(hr);
}
#endif // NO_MENU


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::ReleaseCodeLoad
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

void
COleSite::ReleaseCodeLoad()
{
#ifndef WIN16
    if (_pCodeLoad)
    {
        CCodeLoad * pCodeLoad = _pCodeLoad;
        _pCodeLoad = NULL;
        pCodeLoad->Terminate();
        pCodeLoad->Release();
    }
#endif
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::GetNaturalExtent
//
//  Synopsis:   Get the extent of the site.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::GetNaturalExtent(DWORD dwMode, SIZEL *psizel)
{
    HRESULT hr;

    if (!_fUseViewObjectEx)
        return E_FAIL;

    DVEXTENTINFO extinfo;

    memset(&extinfo, 0, sizeof(extinfo));
    extinfo.cb = sizeof(DVEXTENTINFO);
    extinfo.sizelProposed = *psizel;
    extinfo.dwExtentMode = dwMode;

    hr = THR_OLE(((IViewObjectEx *)_pVO)->GetNaturalExtent(
            DVASPECT_CONTENT,
            -1,
            NULL,
            TLS(hdcDesktop),
            &extinfo,
            psizel));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   COleSite::SizeToFit
//
//  Synopsis:   Do sizetoFit on.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::SizeToFit()
{
    IOleObject *pObject = NULL;
    RECT        rc;
    HRESULT     hr = S_OK;
    SIZEL       sizel = { 0, 0 };

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);

    if (!_fUseViewObjectEx)
        goto Cleanup;

    DVEXTENTINFO extinfo;
    memset(&extinfo, 0, sizeof(extinfo));
    extinfo.cb = sizeof(extinfo);
    extinfo.dwExtentMode = DVEXTENT_CONTENT;
    extinfo.sizelProposed = sizel;

    hr = THR_OLE(((IViewObjectEx *)_pVO)->GetNaturalExtent(
            DVASPECT_CONTENT,
            -1,
            NULL,
            NULL,
            &extinfo,
            &sizel));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IOleObject, (void **)&pObject));
    if (hr)
        goto Cleanup;

    // Control must be at least running to set the extent.

    if (_state < OS_RUNNING)
    {
        IGNORE_HR(TransitionTo(OS_RUNNING));
    }

    // The CDK implementation of IOleObject::SetExtent calls
    // IOleInplaceSite::OnPosRectChange with the old position
    // of the control.  We note that we are setting the extent
    // in order to give OnPosRectChange a reasonable answer.

    pLayout->_sizelLast = sizel;

    {
        CLock   Lock(this, OLESITELOCK_SETEXTENT);

        hr = THR_OLE(pObject->SetExtent(DVASPECT_CONTENT, &sizel));
    }

    pLayout->GetPosition((CPoint *)&rc);
    rc.right    = -1;
    rc.bottom   = -1;

    hr = THR(pLayout->Move(&rc, 0));

Cleanup:
    ReleaseInterface(pObject);

    // Ignore errors if the object does not want to resize.
    return S_OK;
}

//+-------------------------------------------------------------------
//
// Member :   COleSite::QueryStatus
//
// Synopsis :
//
//--------------------------------------------------------------------

HRESULT COleSite::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD * pCmd = NULL;
    HRESULT hr = S_OK;
    UINT        uPropName;
    VARTYPE     vt = VT_EMPTY;
    int         c;
    int         idm;
    GUID *      pguidControl;
    ULONG       ulCmdID;

    #if 0
            if (InSendMessage())
            {
                ReplyMessage(0);
            }
    #endif

    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        Assert(!pCmd->cmdf);

        // Disable Office documents in frameset from showing/hiding toolbars.
        if (pguidCmdGroup == NULL && pCmd->cmdID == OLECMDID_HIDETOOLBARS)
        {
            pCmd->cmdID = MSOCMDSTATE_DISABLED;
            continue;
        }

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);

        uPropName = 0;

        switch (idm)
        {
        case IDM_OBJECTVERBLIST0:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_FONTNAME:
            uPropName = IDS_DISPID_FONTNAME;
            vt = VT_BSTR;
            break;

        case IDM_FONTSIZE:
            uPropName = IDS_DISPID_FONTSIZE;
            vt = VT_CY;
            break;

        case IDM_SUPERSCRIPT:
            uPropName = IDS_DISPID_FONTSUPERSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_SUBSCRIPT:
            uPropName = IDS_DISPID_FONTSUBSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_BOLD:
            uPropName = IDS_DISPID_FONTBOLD;
            vt = VT_BOOL;
            break;

        case IDM_ITALIC:
            uPropName = IDS_DISPID_FONTITAL;
            vt = VT_BOOL;
            break;

        case IDM_UNDERLINE:
            uPropName = IDS_DISPID_FONTUNDER;
            vt = VT_BOOL;
            break;

        case IDM_BACKCOLOR:
            uPropName = IDS_DISPID_BACKCOLOR;
            vt = VT_I4;
            break;

        case IDM_FORECOLOR:
            {
            // TODO: (jenlc) this is just a transition code, will be 
            // changed later for QueryStatus/Exec architecture rework.
            //
            CVariant varargOut;
            DISPID     dispidProp;
            HRESULT    hr;

            dispidProp = DISPID_A_COLOR;
            vt         = VT_I4;
            V_VT(&varargOut) = VT_I4;
            hr = THR_NOTRACE(ExecSetGetKnownProp(NULL, &varargOut, dispidProp, vt));
            pCmd->cmdf = (hr) ? (MSOCMDSTATE_DISABLED) : (MSOCMDSTATE_UP);
            break;
            }

        case IDM_BORDERCOLOR:
            uPropName = IDS_DISPID_BORDERCOLOR;
            vt = VT_I4;
            break;

        case IDM_BORDERSTYLEFIXED:
        case IDM_BORDERSTYLENO:
            uPropName = IDS_DISPID_BORDERSTYLE;
            vt = VT_I4;
            break;

        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_JUSTIFYGENERAL:
        case IDM_JUSTIFYFULL:
            uPropName = IDS_DISPID_TEXTALIGN;
            vt = VT_I4;
            break;

        case IDM_FLAT:
        case IDM_RAISED:
        case IDM_SUNKEN:
            uPropName = IDS_DISPID_SPECIALEFFECT;
            vt = VT_I4;
            break;

        default:
            //
            // Do a reverse lookup to try and match into the standard cmd set.
            //

            if (OLECMDIDFromIDM(idm, &ulCmdID))
            {
                pguidControl = NULL;
                pCmd->cmdID = ulCmdID;
            }
            else
            {
                pguidControl = pguidCmdGroup;
            }

            if (!pguidControl ||
                (IsEqualGUID(CGID_MSHTML, *pguidControl) &&
                    (Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME)))
            {
                // Only call control if not locked and the command guid
                // is the standard one.  (Forms3 specific commands are
                // never passed down.)
                //

// WINCEREVIEW - cut call to InSendMessage
#ifndef WINCE
                if (_pUnkCtrl && ! this->TestLock(OLESITELOCK_QUERYSTATUS) && !InSendMessage())
                {
                    CLock   Lock(this, OLESITELOCK_QUERYSTATUS);
                    
                    hr = THR_OLE(CTQueryStatus(
                            _pUnkCtrl,
                            pguidControl,
                            1,
                            pCmd,
                            pcmdtext));
                }
                else
#endif // WINCE
                {
                    pCmd->cmdf = MSOCMDSTATE_DISABLED;
                }
                continue;
           }

        }

        if(uPropName)
        {
            Assert(vt != VT_EMPTY);
            hr = THR_NOTRACE(QueryStatusProperty(pCmd, uPropName, vt));
        }

        if ((hr == S_OK || hr == OLECMDERR_E_NOTSUPPORTED) && !pCmd->cmdf)
        {
            hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }

    }

    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------
//
// Member :   COleSite::Exec
//
// Synopsis :
//
//--------------------------------------------------------------------

HRESULT
COleSite::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    UINT            uPropName;
    VARTYPE         vt = VT_EMPTY;
    DWORD           dwValue;
    int             idm;
    DISPID          dispidProp;
    CParentUndoUnit *pCPUU = NULL;
    GUID *          pguidControl;
    ULONG           ulCmdID;

    // Disable Office documents in frameset from showing/hiding toolbars.
    if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        RRETURN(OLECMDERR_E_DISABLED);
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // If the idm represents an undoable property change, open
    // a parent undo unit.

#ifndef NO_EDIT
    if (idm != IDM_UNDO && idm != IDM_REDO)
    {
        pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
    }
#endif // NO_EDIT
    switch (idm)
    {

    case IDM_SIZETOFIT:
        hr = THR(SizeToFit());
        break;

    case IDM_OBJECTVERBLIST0:
        break;

    case IDM_FONTNAME:
        uPropName = IDS_DISPID_FONTNAME;
        vt = VT_BSTR;
        goto ExecSetGetProperty;

    case IDM_FONTSIZE:
        {
            CVariant varTemp;
            CY      cy;

             V_VT(&varTemp) = VT_CY;
            // Need to do convert from long (twips) to CURRENCY for font size
            if (pvarargIn)
            {
                cy.Lo = V_I4(pvarargIn)/20 * 10000;
                cy.Hi = 0;
                V_CY(&varTemp) = cy;
            }

            hr = THR_NOTRACE(ExecSetGetProperty(
                    pvarargIn ? &varTemp: NULL,
                    pvarargOut ? &varTemp : NULL ,
                    IDS_DISPID_FONTSIZE,
                    VT_CY));

            if (!hr && pvarargOut)
            {
                V_VT(pvarargOut) = VT_I4;
                cy = V_CY(&varTemp);
                V_I4(pvarargOut) = cy.Lo /10000*20;
            }
            goto Cleanup;
        }

    case IDM_SUPERSCRIPT:
        uPropName = IDS_DISPID_FONTSUPERSCRIPT;
        goto ExecToggleCmd;

    case IDM_SUBSCRIPT:
        uPropName = IDS_DISPID_FONTSUBSCRIPT;
        goto ExecToggleCmd;

    case IDM_BOLD:
        uPropName = IDS_DISPID_FONTBOLD;
        goto ExecToggleCmd;

    case IDM_ITALIC:
        uPropName = IDS_DISPID_FONTITAL;
        goto ExecToggleCmd;

    case IDM_UNDERLINE:
        uPropName = IDS_DISPID_FONTUNDER;
        goto ExecToggleCmd;

    case IDM_BACKCOLOR:
        uPropName = IDS_DISPID_BACKCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_FORECOLOR:
        dispidProp = DISPID_A_COLOR;
        // for this color we need to swap
        if (pvarargIn)
        {
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;
        }
        vt = VT_I4;
        goto ExecKnownDispidProperty;

    case IDM_BORDERCOLOR:
        uPropName = IDS_DISPID_BORDERCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_BORDERSTYLEFIXED:
        uPropName = IDS_DISPID_BORDERSTYLE;
        dwValue = fmBorderStyleSingle;
        goto ExecSetPropertyCmd;

    case IDM_BORDERSTYLENO:
        uPropName = IDS_DISPID_BORDERSTYLE;
        dwValue = fmBorderStyleNone;
        goto ExecSetPropertyCmd;

    case IDM_RAISED:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleRaised;
        goto ExecSetPropertyCmd;

    case IDM_SUNKEN:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleSunken;
        goto ExecSetPropertyCmd;

    case IDM_GETPUNKCONTROL:
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_UNKNOWN;
            pvarargOut->punkVal = _pUnkCtrl;
            hr = S_OK;
        }
        goto Cleanup;

    default:
        //
        // Do a reverse lookup to try and match into the standard cmd set.
        //

        if (OLECMDIDFromIDM(idm, &ulCmdID))
        {
            pguidControl = NULL;
        }
        else
        {
            pguidControl = pguidCmdGroup;
            ulCmdID = nCmdID;
        }


        if (_pUnkCtrl && 
            (!pguidCmdGroup ||
                (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup) &&
                    (Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME))))
        {
            OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
            
            if (_pDisp &&
                (idm == IDM_IMAGE || 
                 ((idm == IDM_PASTE || idm == IDM_CUT || idm == IDM_COPY) &&
                  (!pos || !pos->fAllowCutCopyPaste))) && 
                !AccessAllowed(_pDisp))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            hr = THR_OLE(CTExec(
                    _pUnkCtrl,
                    pguidControl,
                    ulCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));
        }
        break;
    }

    // When user cancel saveas, Excel returns OLECMDERR_E_NOTSUPPORTED
    if (idm == IDM_SAVEAS && hr == OLECMDERR_E_NOTSUPPORTED)
    {
        hr = S_OK;
    }

    // Some controls return DISP_E_MEMBERNOTFOUND even though they should return OLECMDERR_E_NOTSUPPORTED
    // instead.  This safety valve catches those cases:    -Tom
    if( DISPID_NOT_FOUND(hr) || hr == E_NOINTERFACE ||
            hr == OLE_E_NOCONNECTION || hr == OLECMDERR_E_UNKNOWNGROUP)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
        hr = THR_NOTRACE(super::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn,
                pvarargOut));
    goto Cleanup;

ExecKnownDispidProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(ExecSetGetKnownProp(pvarargIn,pvarargOut,dispidProp, vt));
    goto Cleanup;

ExecSetGetProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(ExecSetGetProperty(pvarargIn,pvarargOut,uPropName,vt));
    goto Cleanup;

ExecToggleCmd:
    hr = THR_NOTRACE(ExecToggleCmd(uPropName));
    goto Cleanup;

ExecSetPropertyCmd:
    hr = THR_NOTRACE(ExecSetPropertyCmd(uPropName, dwValue));
    goto Cleanup;

Cleanup:
#ifndef NO_EDIT
    CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    RRETURN_NOTRACE(hr);
}





BOOL
COleSite::CheckDisplayAsDefault(CElement * pElem)
{
     return (pElem && pElem->TestClassFlag(ELEMENTDESC_OLESITE) &&
      (DYNCAST(COleSite, pElem)->_fActsLikeButton ||
       DYNCAST(COleSite, pElem)->_fEatsReturn));
}
//+---------------------------------------------------------------------------
//
//  Member:     COleSite::EnsureParamBag()
//
//  Synopsis:   creates param bag if not yet
//
//----------------------------------------------------------------------------

HRESULT
COleSite::EnsureParamBag()
{
    if (!_pParamBag)
    {
        _pParamBag = new CPropertyBag();
        if (!_pParamBag)
            RRETURN (E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ReleaseParamBag()
//
//  Synopsis:   releases param bag if not yet; sets _pParamBag to NULL
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ReleaseParamBag()
{
    if (_pParamBag)
    {
        _pParamBag->Release();
        _pParamBag = NULL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ExchangeParamBag()
//
//  Synopsis:   exchanges properties between control and param bag using
//              IPersistProperyBag interface
//
//  Parameters  dir:    if (dir == UPLOADPARAMBAG)
//                          uploads parameters from param bag of CObjectElement
//                          to control maintained in this site
//                      else if (dir == DOWNLOADPARAMBAG)
//                          downloads parameters to param bag of CObjectElement
//                          from control maintained in this site
//
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ExchangeParamBag(ExchangeParamBagDir dir)
{
    HRESULT                 hr = S_OK;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;

    if (QueryControlInterface(IID_IPersistPropertyBag2, (void **)&pPPBag2))
    {
        hr = QueryControlInterface(IID_IPersistPropertyBag, (void**)&pPPBag);
        if (hr)
            goto Cleanup;
    }

    Assert(pPPBag || pPPBag2);

    switch (dir)
    {
    case TOCONTROL:
        Assert(_pParamBag);
        hr = (pPPBag2) ?
                THR_OLE(pPPBag2->Load(_pParamBag, NULL)) :
                THR_OLE(pPPBag->Load(_pParamBag, NULL));
        break;

    case FROMCONTROL:
        hr = EnsureParamBag();
        if (hr)
            goto Cleanup;

        hr = (pPPBag2) ?
                THR_OLE(pPPBag2->Save(_pParamBag, TRUE, TRUE)) :
                THR_OLE(pPPBag->Save(_pParamBag, TRUE, TRUE));
        break;

    default:
        Assert (0 && "invalid argument");
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPPBag2);
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsOleProxy
//
//  Returns:    BOOL      True if _pUnkCtrl is actually an OLE proxy.
//
//  Notes:      It performs this check by QI'ing for IClientSecurity.
//              Typically only ole proxies implement this interface.  An
//              arbitrary ocx has no use for it.
//
//----------------------------------------------------------------------------

BOOL
COleSite::IsOleProxy()
{
    IClientSecurity *   pCL;
    BOOL                fRet = FALSE;

#ifndef WIN16       //BUGWIN16 deal with this when do code download
    if (OK(QueryControlInterface(IID_IClientSecurity, (void **)&pCL)))
    {
        ReleaseInterface(pCL);
        // Only proxy objects should support this interface.
        fRet = TRUE;
    }
#endif

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::QuerySafeLoadInterface
//
//  Returns:    HRESULT     E_NOINTERFACE if not verifiably safe to initialize via
//                          the requested interface.  Otherwise, the result
//                          returned from QueryInterface.
//
//  Notes:      Queries for the interface, then determines safety of initialization
//              via that interface.  If not verifiable safe, clears the interface
//              and returns E_NOINTERFACE even if the control implements it.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::QuerySafeLoadInterface(REFIID riid, void ** ppOut)
{
    HRESULT hr = THR_NOTRACE(QueryControlInterface(riid, ppOut));

    if (OK(hr) && *ppOut)
    {
        if (!IsSafeToInitialize(riid))
        {
            ClearInterface((IUnknown **)ppOut);
            hr = S_FALSE;
            goto Cleanup;
        }
        else
        {
            //  Loading data into a control on a print doc is always safe since the
            //  data was saved by this control and wouldn't have been loaded originally
            //  unless it was safe to do so.
            if (Doc()->IsPrintDialogNoUI())
            {
                goto Cleanup;
            }    
            else if ( riid == IID_IPersistMoniker ||
                      riid == IID_IPersistStream ||
                      riid == IID_IPersistFile ||
                      riid == IID_IPersistStreamInit)
            {
                //  For certain interfaces, deny access to x-domain data if the user
                //  has not explicitly allowed it.

                CLSID * pCLSID = GetpCLSID();

                if (!pCLSID || (!_fDataSameDomain && !IsEqualCLSID(CLSID_Scriptlet, *pCLSID)))
                {
                    BOOL fAllowXDomain = FALSE;

                    THR(GetMarkupPtr()->ProcessURLAction(
                        URLACTION_CROSS_DOMAIN_DATA,
                        &fAllowXDomain));

                    // if user has chosen not to allow x-domain data access, honor that.
                    if (!fAllowXDomain)
                    {
                        ClearInterface((IUnknown **)ppOut);
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    return hr;
}


HRESULT
COleSite::GetAmbientProp(DISPID dispid, VARIANT *pvarResult)
{
    Assert(pvarResult);

    HRESULT hr = S_OK;
    BOOL    fBoolValue;

    switch (dispid)
    {
        case DISPID_AMBIENT_BACKCOLOR:
            {
                OLE_COLOR backColor = (OLE_COLOR)(GetInheritedBackgroundColor() & 0x00ffffff);
                V_VT(pvarResult) = VT_I4;
                V_I4(pvarResult) = backColor;
            }
            break;

        case DISPID_AMBIENT_FORECOLOR:
            {
                CColorValue ccvTextColor;
                OLE_COLOR foreColor;

                if (GetFirstBranch())
                    ccvTextColor = GetFirstBranch()->GetCascadedcolor();

                if (ccvTextColor.IsDefined())
                {
                    // If ForeColor is available from character formatting info...
                    foreColor = ccvTextColor.GetOleColor();
                }
                else
                {
                    // otherwise get ForeColor from document settings.
                    foreColor = Doc()->_pOptionSettings->colorText;
                }

                V_VT(pvarResult) = VT_I4;
                V_I4(pvarResult) = foreColor;
            }
            break;

        case DISPID_AMBIENT_FONT:
            {
                const CCharFormat *pCF = GetFirstBranch() ? GetFirstBranch()->GetCharFormat() : NULL;
                LPDISPATCH pFontDisp = NULL;

                if (pCF)
                {
                    FONTDESC fontDesc;

                    CStr sFaceName;
                    sFaceName.Set(pCF->GetFaceName());

                    fontDesc.cbSizeofstruct = sizeof (FONTDESC);
                    fontDesc.lpstrName = sFaceName;
                    fontDesc.cySize.Hi = 0;
                    fontDesc.cySize.Lo = MulDivQuick(pCF->GetHeightInTwips(Doc()), 10000, TWIPS_PER_POINT);
                    fontDesc.sWeight = pCF->_wWeight;
                    fontDesc.sCharset = pCF->_bCharSet;
                    fontDesc.fItalic = pCF->_fItalic;
                    fontDesc.fUnderline = pCF->_fUnderline;
                    fontDesc.fStrikethrough = pCF->_fStrikeOut;
                    hr = THR(OleCreateFontIndirect(&fontDesc, IID_IFontDisp, (void **)&pFontDisp));
                }

                V_VT(pvarResult) = VT_DISPATCH;
                if (OK(hr) && pFontDisp)
                    V_DISPATCH(pvarResult) = pFontDisp;  // Consumer must Release...
                else
                    V_DISPATCH(pvarResult) = NULL;
            }
            break;

        case DISPID_AMBIENT_DISPLAYNAME:
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(GetIdentifier(), &V_BSTR(pvarResult)));
            break;

        case DISPID_AMBIENT_UIDEAD:
            fBoolValue = FALSE;
            goto StoreBool;

        case DISPID_AMBIENT_USERMODE:
            fBoolValue = !IsDesignMode();
            goto StoreBool;

        case DISPID_AMBIENT_SHOWGRABHANDLES:
        case DISPID_AMBIENT_SHOWHATCHING:
            fBoolValue = FALSE; // Never allow clients to show hatching
            goto StoreBool;

        case DISPID_AMBIENT_LOCALEID:
            {
                V_VT(pvarResult) = VT_I4;
                const CCharFormat *pCF = GetFirstBranch() ? GetFirstBranch()->GetCharFormat() : NULL;
                if (pCF)
                {
                    V_I4(pvarResult) = pCF->_lcid;
                }
                else
                {
                    V_I4(pvarResult) = g_lcidUserDefault;
                }
            }
            break;

#ifndef WIN16
            // michaelw - temporary fix until ambient palette is implemented by CDoc
        case DISPID_AMBIENT_PALETTE:
            V_VT(pvarResult) = VT_HANDLE;
            V_I4(pvarResult) = HandleToLong(Doc()->GetPalette());
            break;
#endif //!WIN16

        case DISPID_AMBIENT_MESSAGEREFLECT:
        case DISPID_AMBIENT_SUPPORTSMNEMONICS:
            fBoolValue = TRUE;
            goto StoreBool;

        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            {
                CElement * pElemCurrent = Doc()->_pElemCurrent;

                if (pElemCurrent == this)
                {
                    fBoolValue = TRUE;
                }
                else if (_fDefault &&
                        !CheckDisplayAsDefault(pElemCurrent))
                {
                    fBoolValue = TRUE;
                }
                else
                {
                    fBoolValue = FALSE;
                }
            }
            goto StoreBool;

        case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED :
            fBoolValue = ((Doc()->_dwLoadf & DLCTL_OFFLINEIFNOTCONNECTED) ? TRUE : FALSE);
            goto StoreBool;

        case DISPID_AMBIENT_SILENT :
            fBoolValue = ((Doc()->_dwLoadf & DLCTL_SILENT) ? TRUE : FALSE);
            goto StoreBool;

        case DISPID_AMBIENT_USERAGENT:
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(Doc()->_bstrUserAgent, &V_BSTR(pvarResult)));
            break;

        case DISPID_AMBIENT_DLCONTROL:
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = Doc()->_dwLoadf;
            break;

        case DISPID_AMBIENT_RIGHTTOLEFT:
        {
            fBoolValue = FALSE;
            if (IsInMarkup())
            {
                if (GetMarkup()->Document())
                {
                    hr = THR(GetMarkup()->Document()->GetDocDirection(&fBoolValue));
                }
            }
            fBoolValue = ENSURE_BOOL(fBoolValue);
            goto StoreBool;

StoreBool:
            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)-fBoolValue;
            break;
        }
        case DISPID_AMBIENT_CODEPAGE:
            V_VT(pvarResult) = VT_UI4;
            V_UI4(pvarResult) = GetMarkup()->GetCodePage();
            break;

        case DISPID_AMBIENT_CHARSET:
            {
                TCHAR tszCharset[MAX_MIMECSET_NAME] = {0};
                V_VT(pvarResult) = VT_BSTR;
                IGNORE_HR(GetMlangStringFromCodePage(GetMarkup()->GetCodePage(), tszCharset,
                                                     ARRAY_SIZE(tszCharset)));
                hr = THR(FormsAllocString(tszCharset, &V_BSTR(pvarResult)));
            }
            break;

        default:
            hr = THR_NOTRACE(Doc()->GetAmbientVariant(dispid, pvarResult));
            break;

    }   // switch

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OlesiteTag
//
//  Synopsis:   Return type of thingy that's really running in this site
//
//----------------------------------------------------------------------------

COleSite::OLESITE_TAG
COleSite::OlesiteTag()
{
    OLESITE_TAG ostag;
    INSTANTCLASSINFO * pici;

    // TODO: For now just look at my tag.  Replace this with a more sophisticated
    // test that drills down to the thing that's really running.
    switch (Tag())
    {
    case ETAG_OBJECT:
    case ETAG_APPLET:
        pici = GetInstantClassInfo();

        if (!pici)
        {
            ostag = OSTAG_UNKNOWN;
        }
        else if ((Tag() == ETAG_APPLET && IsEqualGUID((REFGUID)pici->clsid, (REFGUID)g_Zero.guid)) || 
                  IsEqualGUID((REFGUID)pici->clsid, (REFGUID)CLSID_AppletOCX))
        {
           ostag = OSTAG_APPLET;
        }
        else
        {
           ostag = OSTAG_ACTIVEX;
        }
        break;

    case ETAG_EMBED:
        ostag = OSTAG_PLUGIN;
        break;

    case ETAG_FRAME:
        ostag = OSTAG_FRAME;
        break;

    case ETAG_IFRAME:
        ostag = OSTAG_IFRAME;
        break;

    default:
        AssertSz(0, "Unknown tag");
        ostag = OSTAG_UNKNOWN;
        break;
    }

    return ostag;
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::RefreshCallback(UINT uTimerID)
//
//  Synopsis:   refresh our control which can only be a CDoc by
//              potentially bashing it's _cstrUrl
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT BUGCALL
COleSite::RefreshCallback(UINT uTimerID)
{
    HRESULT hr = S_OK;
    FormsKillTimer(this, REFRESH_TIMER_ID);
    DWORD dwRefreshFlags = OLECMDIDF_REFRESH_NO_CACHE;

    CDoc *pDoc = (CDoc*)(void*)_pUnkCtrl;
    Assert( (*(void**)pDoc) == *(void**)Doc()); // This *should* always be a CDoc.
    if (_pstrRefreshURL)
    {
        dwRefreshFlags |= OLECMDIDF_REFRESH_CLEARUSERINPUT;
        hr = THR(pDoc->SetPrimaryUrl(_pstrRefreshURL));
        // _pstrRefreshURL must be NULL before we ExecRefresh
        // since the ExecRefresh may free the string
        FormsFreeString(_pstrRefreshURL);
        _pstrRefreshURL = NULL;
        if (hr)
            goto Cleanup;
        
    }
    GetMarkup()->Window()->ExecRefresh(dwRefreshFlags);

Cleanup:
    return hr;
}

HRESULT COleSite::OnFailToCreate()
{
    _fFailedToCreate = TRUE;
    _fNoUIActivateInDesign = TRUE;
    return S_OK;
}

void
COleSite::DeferredCreateObject( DWORD_PTR dwContext )
{
    ELEMENT_TAG etag = Tag();

    if ((etag == ETAG_APPLET) || (etag == ETAG_OBJECT))
    {
        IGNORE_HR((DYNCAST(CObjectElement, this))->CreateObject());
    }
    else if (etag == ETAG_EMBED)
    {
        IGNORE_HR((DYNCAST(CPluginSite, this))->CreateObject());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveMetaFileSnapshot
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              a metafile image of the element
//
//  Arguments:  pchTempFileName - returns the name of temporary used for save
//
//----------------------------------------------------------------------------
HRESULT COleSite::SaveMetaFileSnapshot(TCHAR *pchTempFileName)
{
    HRESULT hr = E_FAIL;
    CLayout * pLayout;
    CSize size;

    // Get layout. If there is no layout, or if the size is zero, 
    // return fake file name to suppress object instantiation in print doc.
    // NOTE: at this point, we don't care which layout we get - 
    //       we hope the size is same everywhere.
    pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
    if (NULL == pLayout || (pLayout->GetContentSize(&size), size.IsZero()))
    {
        // if this olesite is being used as a class factory for elemente 
        // behaviors we need to do something special.  This object actually
        // needs to be instantiated in the print template document, as a 
        // precondition, we can't put "ZERO" into the filename, and we 
        // do need a sentinal to say "hey I need to be instantiated.
        if (!_fElementBehaviorFactory)
        {
            _tcscpy(pchTempFileName, _T("_ZERO"));
        }
        else
        {
            _tcscpy(pchTempFileName, _T("_EB_FACTORY"));
        }

        hr = S_OK;
        goto Cleanup;
    }

    // Get temp file name    
    if (!Doc()->GetTempFilename(_T("\0"), _T("emf"), pchTempFileName))
    {
        goto Cleanup;
    }
    
    // Draw to metafile
    hr = SaveMetaFileSnapshotCore(pLayout, size, pchTempFileName);

Cleanup:
    if (hr != S_OK)
        *pchTempFileName = 0;
        
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Routine:    IsMoney2000
//
//  Synopsis:   Detect whether client object is implemented by
//              MSMoney2000. Considered "yes" if it have property
//              "hwndMoney" and have not "ie55compatible" property.
//              The last one is supposed to be added to MSMoney2001
//              and next msmoney versions.
//
//----------------------------------------------------------------------------
static bool IsMoney2000(IViewObject* pVO)
{
    if (!g_fInMoney98 || !pVO)
        return false;

    IDispatch* pDispatch;
    HRESULT hr = pVO->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    if (FAILED(hr))
        return false;

    DISPID rgDispId[2];
           rgDispId[0] =
           rgDispId[1] = DISPID_UNKNOWN;
    static OLECHAR* propNames[2] =
    {
        _T("hwndMoney"),
        _T("ie55compatible")
    };

    hr = pDispatch->GetIDsOfNames(IID_NULL,
                                  propNames, 2,
                                  g_lcidUserDefault, rgDispId);

    pDispatch->Release();

    return (hr == DISP_E_UNKNOWNNAME || SUCCEEDED(hr))
        && rgDispId[0] != DISPID_UNKNOWN
        && rgDispId[1] == DISPID_UNKNOWN;
}

//+---------------------------------------------------------------------------
//
//  Routine:    CreatePrinterIC
//
//  Synopsis:   Create information context for printer device,
//              using our best guess as a printer device.  This is, in descending order:
//              1. the last printer used to print from this app (_hDevNames)
//              2. the system default printer
//              Note that we may not actually use this printer in the final draw, which
//              can cause issues with things like colour depth...
//
//  Return:     HDC or 0 on any error
//
//  Note:       this hack reproduces old-style mshtml behavior that
//              required for already shipped applications like Money2000
//
//----------------------------------------------------------------------------
static HDC CreatePrinterIC(CDoc *pDoc)
{
    HDC hDC = NULL;

    // We have stored the DEVNAMES of the last our successful print.
    // Best guess: the user probably will print to the same device this time.
    if (pDoc && pDoc->_hDevNames)
    {
        DEVNAMES * pDevNames = (DEVNAMES *)::GlobalLock(pDoc->_hDevNames);           
        if (pDevNames)
        {
            hDC = CreateIC((TCHAR *)pDevNames + pDevNames->wDriverOffset,
                           (TCHAR *)pDevNames + pDevNames->wDeviceOffset,
                           NULL,
                           NULL);

            ::GlobalUnlock(pDoc->_hDevNames);
        }
    }

    // 2. If an IC is still needed, check for a system default printer
    if (!hDC)
    {
        // A better way to do this on NT5+ is to use ::GetDefaultPrinter.
        PRINTDLG printdlg;

        ::ZeroMemory(&printdlg, sizeof(PRINTDLG));
        printdlg.lStructSize    = sizeof(PRINTDLG);
        printdlg.hwndOwner      = pDoc->GetHWND();       
        printdlg.Flags          |= PD_RETURNDEFAULT | PD_RETURNIC;

        if (PrintDlg(&printdlg))
        {
            hDC = printdlg.hDC;
            if (printdlg.hDevMode)
                ::GlobalFree(printdlg.hDevMode);
            if (printdlg.hDevNames)
                ::GlobalFree(printdlg.hDevNames);
        }
    }
    
    return hDC;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveMetaFileSnapshotCore
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              a metafile image of the element
//
//  Arguments:  pLayout - current layout
//              sizeCurrent - logical size of layout (not apparent)
//              pchTempFileName - the name of temporary used for save
//
//  Return:     S_OK on success
//              S_FALSE on no API failures, but unusable metafile
//              E_FAIL on other failures.
//
//----------------------------------------------------------------------------
//
// this is the list of controls that have been identified as CLAIMING to support IVO, but in actually do
// NOTHING when called to draw. They all have HWNDS, so we can apphack them.  Bad control. Bad.
//
EXTERN_C const GUID CLSID_MS_PROJ_GRID_CTRL    = {0xBE194B4A, 0x6063, 0x11D1, {0xBE, 0x5C, 0x00, 0xC0, 0x4F, 0xB9, 0x07, 0x59}};
EXTERN_C const GUID CLSID_MS_SYSTEMINFORMATION = {0x273380e8, 0x1438, 0x4b2c, {0x95, 0xb0, 0x71, 0x32, 0x84, 0xfb, 0xc3, 0x02}};
EXTERN_C const GUID CLSID_PRINTSHOP_PHOTO_BTN  = {0xADB880A6, 0xD8FF, 0x11CF, {0x93, 0x77, 0x00, 0xAA, 0x00, 0x3B, 0x7A, 0x11}};


HRESULT COleSite::SaveMetaFileSnapshotCore(CLayout *pLayout, 
                                           CSize sizeCurrent, 
                                           TCHAR const *pchTempFileName)
{
    HENHMETAFILE    hemf = NULL;
    HRESULT         hr = S_OK;
    HDC             hdcEmf = NULL;
    CSize           sizeCurrentHM;

    
    // Use display as target device.
    //
    // NOTE: we really should be using some kind of universal standard device, with 
    //       resolution set to our hi-res units, but I don't know if we can cook up
    //       an information context for it without having a driver.
    //       More issues to consider for choice of target device:
    //       * From metafile point of ciew, screen pixels are not always square. 
    //         My screen has 4x4.27 ratio (although it doesn't look like that to me) 
    //         and that affects subsequent metafile rendering unless we make adjustments
    //       * printer pixels are usually square. Hovever, if a bitmap is output for 
    //         printer resolution, it may get huge, without becoming higher quality (alexmog 10/13/99)
    //
    // NOTE: we can't hook up the IC without a driver, and we need to do this in
    //      order to avoid driver problems when they try to dither a bitmap drawn to screen colordepth
    //      to their grayscale or limited colors.  This has been a source of regular complaints during
    //      ie 5.5 (carled 03/01/00)
    //

    // NOTE: MSMoney2000 refuses to draw if hicTargetDev corresponds to display-type device.
    //       They use to compare GetDeviceCaps(*, TECHNOLOGY) with DT_RASDISPLAY value.
    //       We consider this incorrect, but unfortunately money is shipped already so we need
    //       to provide compatibility. Following patch can be removed if we'll dare to develop
    //       drivers for all platforms (mikhaill  4/29/00).

    HDC hicTargetDev = 0;

    if (IsMoney2000(_pVO))
        hicTargetDev = CreatePrinterIC(Doc());

    if (hicTargetDev == 0)
        hicTargetDev = CreateIC(_T("DISPLAY"), NULL, NULL, NULL);

    // NOTE: if you want to initialize hicTargetDev for default printer, refer
    //       to source history of this file.

    // Use default measuring device (unless we use a specific target DC)
    CDocInfo const *pdciTarget = Doc()->GetView()->GetMeasuringDevice(mediaTypeNotSet);

    // We need to find object size to initialize metafile bounds properly
    // The size we are getting from layout may have been calculated for a different resolution.
    // Use layout's media to convert to himetric
    {
        mediaType mediaLayout = pLayout->LayoutContext() ? pLayout->LayoutContext()->GetMedia() : mediaTypeNotSet;
        CDocInfo const *pdciLayout = Doc()->GetView()->GetMeasuringDevice(mediaLayout);

        // Calculate size in himetric
        pdciLayout->HimetricFromDevice(sizeCurrentHM, sizeCurrent);

        // Convert layout size to target size if devices are different
        pdciLayout->TargetFromDevice(sizeCurrent, *pdciTarget->GetUnitInfo());
    }
            
    // This rectangle will determine the element's size when we print
    CRect rcMetafileBounds(sizeCurrentHM);

    //
    // create metafile
    //
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        // Use Unicode for file name
        hdcEmf = CreateEnhMetaFile(hicTargetDev,                    // hdcRef
                                   pchTempFileName,                 // lpFilename
                                   &rcMetafileBounds,               // lpRect
                                   _T("MSHTML\0OLE object image\0\0"));  // lpDescription
    }
    else
    {
        // Use ANSI for file name
        char achTempFileA[MAX_PATH];
        if (WideCharToMultiByte(CP_OEMCP, 0, pchTempFileName, -1, achTempFileA, MAX_PATH, NULL, NULL))
        {
            hdcEmf = CreateEnhMetaFileA(hicTargetDev,                // hdcRef
                                    achTempFileA,                    // lpFilename
                                    &rcMetafileBounds,               // lpRect
                                    "MSHTML\0OLE object image\0\0"); // lpDescription
        }
    }

    if (hdcEmf != NULL)
    {
        INSTANTCLASSINFO *  pici;

        // For controls that use the fUseBMP hack
        HDC                 hdcBmp  = NULL;
        HBITMAP             hbmp    = NULL;
        HDC                 hdcToUse = NULL;

        pici = GetInstantClassInfo();

        //
        // this test is for known controls that say they support IVO, but do nothing on the 
        // IVO::Draw call. for these we can only print them by using the sendMessage codepath
        //
        BOOL fNoIVODraw =   (   pici 
                             && (   IsEqualGUID((REFGUID)pici->clsid,
                                                (REFGUID)CLSID_MS_PROJ_GRID_CTRL)
                                 || IsEqualGUID((REFGUID)pici->clsid, 
                                                (REFGUID)CLSID_MS_SYSTEMINFORMATION)
                                 || IsEqualGUID((REFGUID)pici->clsid, 
                                                (REFGUID)CLSID_PRINTSHOP_PHOTO_BTN)
                             ));
        //
        // This test is for controls that can't (for whatever reason) use a metafile.
        // We render them to a memory DC (with bitmap enabled), and just bitblt over the contents.
        // Yes, this should cause dithering weirdness depending on the color depth of the DISPLAY driver & printers.
        // This includes:
        // (1)  Applets under Win9x with FE characters crash when rendering to a metafile due to JVM/GDI bugs.
        //      We can't tell if an applet has such characters, so we use the heuristic to identify risk applets:
        //      (a) Applet is not on an AsciiLatin codepage
        //      (b) We are running on an FE build of Win9x.
        //      In these cases we trade font fidelity/size for safety.
        //        
        BOOL fUseBMP    =   (   !g_fUnicodePlatform   
                             && OlesiteTag() == OSTAG_APPLET
                             && (   GetMarkup()->GetCodePage() != 1252
                                 ||  g_fFarEastWin9X
                            ));
                                             
        //
        // Initialize non-inplace draw info
        //
        CDispClipTransform cliptransform;
        cliptransform.SetToIdentity();

        // Render directly to the metafile DC in most cases
        hdcToUse = hdcEmf;
        if (fUseBMP)
        {
            // Create a screen-compatible DC for rendering
            hdcBmp = CreateCompatibleDC(hicTargetDev);
            if (hdcBmp)
            {
                // QUINMARK: Need non-memory DC for colors!
                hbmp =  CreateCompatibleBitmap(hicTargetDev, sizeCurrent.cx, sizeCurrent.cy);
                if (hbmp)
                {
                    // Render the metafile into the bitmap    
                    SelectObject(hdcBmp, hbmp);     
            
                    // Render to the bitmap DC, then bitblt the bitmap to the metafile DC.
                    hdcToUse = hdcBmp;
                }
                else
                {
                    DeleteDC(hdcBmp);
                }
            }
        }

        CDispSurface        *pSurface;
        pSurface = new CDispSurface(hdcToUse);
        if(pSurface)
        {
            //
            // Initialize surface. 
            // note: we don't need to clip anything here. 
            //       if we did, we would have to initialize clip rectangle.
            //
            pSurface->PrepareClientSurface(&cliptransform);
            pSurface->SetNeverClip(TRUE); 
    
            CFormDrawInfo DI;
            DI.Init(this, pSurface);
            DI._pSurface = pSurface;
            DI._fIsMetafile = TRUE;     // Do we want this on for fUseBMP?  It does a SetViewportOrg in the Draw...
            DI._fInplacePaint = FALSE;

            DI.CDocScaleInfo::Copy(*pdciTarget);
            DI._hic = XHDC(hicTargetDev, NULL);

            //
            // rectangle in DI should be exactly the bounding rectangle of layout,
            // but positioned at (0,0).
            //
            DI._rc = CRect(sizeCurrent);

            //
            // We don't need to set rcWBounds.
            // Note: I know at least one applet that resets itself if asked to draw with WBounds -- alexmog
            //
            DI._prcWBounds = NULL;

            //
            // Do the actual draw
            // 
            if (_pUnkCtrl && _pVO && !fNoIVODraw)
            {
                //
                // we have an IVO ptr and this control is not in the
                // apphack list of badly implemented IVO::Draw's
                //
                pLayout->Draw(&DI);
            }
            else if ( GetHwnd())
            {
                // We have an HWND but do not support IVO, (or an apphack control)
                // inorder to save we need to do special work.
                SaveMetaFileWithoutIVO( &DI );
            }

            // If we're hacking around a problem by rendering to a BMP, then bitblting to the metafile,
            // now is the time to finish up with the BitBlt.
            if (fUseBMP)
            {
                BitBlt(hdcEmf, 0, 0, sizeCurrent.cx, sizeCurrent.cy,    // dest DC & Rect
                       hdcBmp, 0, 0,                                    // source DC
                       SRCCOPY);                                        // raster mode

                if (hbmp)
                    DeleteObject(hbmp);
                if (hdcBmp)
                    DeleteDC(hdcBmp);        
            }

            //
            // close metafile - this also deallocates hdcEmf
            //
            hemf = CloseEnhMetaFile(hdcEmf);

        }
        delete pSurface;
    }


    if (hicTargetDev)
        DeleteDC(hicTargetDev);

    if (hemf)
    {
        // metafile is ready to use. Release memory, we only need the file.
        DeleteEnhMetaFile(hemf);

        // If it is not a success, proceed to deleting the file.
        if (hr == S_OK)
            return hr;
    }
    else
        hr = E_FAIL;
    
    // We have failed. Delete temp file.
    if (*pchTempFileName)
        DeleteFile(pchTempFileName);

    return hr;
}       


//+----------------------------------------------------------------
//
//  Member : SaveMetaFileWithoutIVO
//
//  Synopsis : Windowed controls that do not implement IViewObject
//      still need to be printed.  Since we cannot simply call
//      Layout()->Draw, we need to be a little more clever here
//      and call SendMessage(WM_PAINT)
//
//  Warning - we still cannot protect a control from being badly authored.
//      the wparam of WM_PAINT is the DC to paint to, if the control 
//      doesn't honor this, they won't print (grid control from office 97 e.g.)
//
//+----------------------------------------------------------------
MtDefine(CDataAry_aryHWND, Locals, "aryHWND")

BOOL CALLBACK enumchildWindowProc ( HWND hwndChild, LPARAM lparam )
{
    CDataAry<HWND>  * paryWindows = (CDataAry<HWND> *)lparam;
    HWND            * pwnd        = paryWindows->Append();

    if (!pwnd)
        return FALSE;  // out of memory

    *pwnd = hwndChild;

    return TRUE;
}

void
COleSite::SaveMetaFileWithoutIVO( CFormDrawInfo *pDI )
{
    Assert(pDI);

    XHDC      hdc    = pDI->GetGlobalDC(!GetMarkupPtr()->IsPrintMedia());
    HDC       rawHDC = hdc.GetOleDC();            // CAUTION: getting raw DC. We must be 
                                                  //          careful with what we do to it.
    POINT     ptViewportOrigin  = g_Zero.pt;
    POINT     ptBrushOriginSave = g_Zero.pt;
    BOOL      fBrushOrgChanged  = GetViewportOrgEx(hdc, &ptViewportOrigin);

    AssertSz(pDI->_fIsMetafile, "Warning! Fx is only safe for Metafile drawing");
    Assert(!pDI->_prcWBounds);
    AssertSz(GetHwnd(), "No window for the control");


    //
    // Prepare the DC to be drawn into. and Save DC - who knows what the control 
    //        will do to the DC?
    //---------------------------------------------------------------------------
    int nSavedDC = ::SaveDC(rawHDC);
    Assert(nSavedDC);

    // Set the brush Origin
    if (fBrushOrgChanged)
    {
        POINT   ptNewBrushOrigin;

        ptNewBrushOrigin.x = (ptViewportOrigin.x + pDI->_rc.left) % 8;
        if( ptNewBrushOrigin.x < 0 )
            ptNewBrushOrigin.x += 8;

        ptNewBrushOrigin.y = (ptViewportOrigin.y + pDI->_rc.top) % 8;
        if( ptNewBrushOrigin.x < 0 )
            ptNewBrushOrigin.y += 8;

        fBrushOrgChanged = SetBrushOrgEx(hdc,
                                         ptNewBrushOrigin.x,
                                         ptNewBrushOrigin.y,
                                         &ptBrushOriginSave );
    }

    // Set the origin of the ViewPort
    ::SetViewportOrgEx(hdc, 0, 0, NULL);


    //
    // Transform the bounds so that we have a rect to draw into:
    //-------------------------------------------------------------------
    // Note - we might need to do more work here, see COleLayout::Draw.
    //      - pDI->_rc is the size in target device coordinates.

    if (   hdc.HasTransform()
        && !pDI->_rc.IsEmpty())
    {
        CRect rcBounds = pDI->_rc;

        // Note: for rotation, ie5.5 only rotates in 90 degree increments
        AssertSz(hdc.transform().GetAngle() % 900 == 0, "Non-trivial rotation in COleSite::SaveMetaFileWithoutIVO");
    
        hdc.transform().Transform(&rcBounds);

        pDI->_rc = rcBounds;
    }


    //
    // Send the paint message to the window:
    //         The lparam of WM_PAINT is not defined. However Office's GridControl
    //         expects it to be the rectangle to draw into.
    //-----------------------------------------------------------------------------

    {
        WPARAM  wParam      = (WPARAM)rawHDC;
        HWND    hwndControl = GetHwnd();
        int     i;
        CDataAry<HWND> aryWindows(Mt(CDataAry_aryHWND));
        HWND  * pwnd        = aryWindows.Append();

        if (!pwnd)
            goto Cleanup;   // out of memory

        *pwnd = hwndControl;

        // this call recursively visits all descendant windows and lets them 
        // add themselves to the array
        ::EnumChildWindows(hwndControl, enumchildWindowProc, (LPARAM)&aryWindows);

        // because we are not drawing in z-order we are getting different results
        // depending on how we process this array.
        for(i =0; i < aryWindows.Size(); i++)
        {
            CRect   rectTemp    = g_Zero.rc;
            LPARAM  lParam      = (LPARAM)&rectTemp;

            // get that child window's rect. some controls from ie5.0 era look for this
            // in the LPARAM eventhough the lparam is undefined for these messages.
            ::GetWindowRect(aryWindows[i], &rectTemp);

            if (::SendMessage(aryWindows[i], WM_PAINT, wParam, lParam))
            {
                // the paint was not handled, so try to get it to invalidate and draw
                if (::RedrawWindow(aryWindows[i], NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE ))
                    ::SendMessage(aryWindows[i], WM_PAINT, wParam, lParam);
            }
        }
    }

Cleanup:
    // Restore DC (this restores viewport and brush origins)
    Verify(::RestoreDC(rawHDC, nSavedDC));
}


HRESULT
COleSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr     = S_OK;
    IOleControl *    pControl;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if(hr)
        goto Cleanup;

    // In theory, we only want to let the ole controller know about this property change
    // if it's an ambient property. However, there are two problems.
    // 1) There is no DISPID_AMBIENT_{FIRST,LAST}, so there's no generic way of telling
    //    whether or not the dispid is for an ambient property.
    // 2) For legacy reasons, we need to fire this with DISPID_UNKNOWN every time. The 
    //    OnAmbientPropertyChange used to be called in COleLayout::OnFormatsChange, which
    //    was in turn called from CMarkup::ClearRunCaches. There is a function on 
    //    CControlledFormatter which is called from CControlledFormatter::Init which 
    //    determines whether or not the caches need to be cleared. CControlledFormatter::Init
    //    is always called from CElement::OnPropertyChange, and the function that tells it whether
    //    or not to recompute formats currently always returns TRUE. 
    //
    //    In other words, this was being called with DISPID_UNKNOWN on every property change, and so
    //    we do that here to maintain compat.

    if (OK(QueryControlInterface(IID_IOleControl, (void **)&pControl)))
    {
        IGNORE_HR(pControl->OnAmbientPropertyChange(DISPID_UNKNOWN));
        pControl->Release();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\olexobj.cxx ===
//+------------------------------------------------------------------------
//
//  File:       OLEXOBJ.CXX
//
//  Contents:   X-Object Implementation
//
//  Classes:    COleSite
//
//  Notes:      The Ole X object (attempts to) aggregate OLE controls and add
//              to them properties (and methods) specific to the container.
//
//              This XObject delegates the IDispatch implementation to the
//              control for properties and methods it doesn't know about.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include <typenav.hxx>
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

HRESULT
InvokeDispatchWithNoThis (
    IDispatch *         pDisp,
    DISPID              dispidMember,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo)
{
    HRESULT         hr;
    BOOL            fThis = FALSE;
    VARIANTARG *    rgOldVarg = NULL;
    DISPID     *    rgdispidOldNamedArgs = NULL;

    // Any invoke call from a script engine might have the named argument
    // DISPID_THIS.  If so then we'll not include this argument in the
    // list of parameters because oleaut doesn't know how to deal with this
    // argument.
    if (pdispparams->cNamedArgs && (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS))
    {
        fThis = TRUE;
    
        pdispparams->cNamedArgs--;
        pdispparams->cArgs--;

        rgOldVarg = pdispparams->rgvarg;
        rgdispidOldNamedArgs = pdispparams->rgdispidNamedArgs;

        pdispparams->rgvarg++;
        pdispparams->rgdispidNamedArgs++;

        if (pdispparams->cNamedArgs == 0)
            pdispparams->rgdispidNamedArgs = NULL;

        if (pdispparams->cArgs == 0)
            pdispparams->rgvarg = NULL;
    }

    hr = THR_NOTRACE(pDisp->Invoke(
            dispidMember,
            IID_NULL,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL));


    // restore the named DISPID_THIS argument.
    if (fThis)
    {
        pdispparams->cNamedArgs++;
        pdispparams->cArgs++;

        pdispparams->rgvarg = rgOldVarg;
        pdispparams->rgdispidNamedArgs = rgdispidOldNamedArgs;
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::IE3XObjInvoke, IDispatch
//
// Synopsis:    supports IE3 xobj props by dispid
//
//---------------------------------------------------------------

HRESULT
COleSite::IE3XObjInvoke(
    DISPID       dispidMember,
    REFIID       riid,
    LCID         lcid,
    WORD         wFlags,
    DISPPARAMS * pdispparams,
    VARIANT *    pvarResult,
    EXCEPINFO *  pexcepinfo,
    UINT *       puArgErr)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    if (STDPROPID_IE3XOBJ_OBJECTALIGN == dispidMember)
    {
        htmlControlAlign    htmlAlign;
        CVariant            varAlign;

        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            htmlAlign = GetAAalign();

            V_VT(pvarResult) = VT_I4;
            switch (htmlAlign)
            {
                case htmlControlAlignTop:       V_I4(pvarResult) = 1;   break;
                case htmlControlAlignBottom:    V_I4(pvarResult) = 2;   break;
                case htmlControlAlignLeft:      V_I4(pvarResult) = 3;   break;
                case htmlControlAlignRight:     V_I4(pvarResult) = 4;   break;
                default:                        V_I4(pvarResult) = 0;   break;
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pdispparams || !pdispparams->rgvarg || 1 != pdispparams->cArgs)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            hr = THR(VariantChangeTypeSpecial(&varAlign, pdispparams->rgvarg, VT_I4));
            if (hr)
                goto Cleanup;

            if (V_I4(&varAlign) < 0 || 4 < V_I4(&varAlign))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            Assert (VT_I4 == V_VT(&varAlign));

            switch (V_I4(&varAlign))
            {
                case 1:    htmlAlign = htmlControlAlignTop;    break;
                case 2:    htmlAlign = htmlControlAlignBottom; break;
                case 3:    htmlAlign = htmlControlAlignLeft;   break;
                case 4:    htmlAlign = htmlControlAlignRight;  break;
                default:   Assert (0); htmlAlign = htmlControlAlignBottom;  break;
            }

            hr = THR(SetAAalign(htmlAlign));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = S_OK;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::ContextThunk_InvokeEx, IDispatch
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//---------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
COleSite::ContextThunk_InvokeEx(
        DISPID       dispidMember,
        LCID         lcid,
        WORD         wFlags,
        DISPPARAMS * pdispparams,
        VARIANT *    pvarResult,
        EXCEPINFO *  pexcepinfo,
        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    return ContextInvokeEx(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider,
            pUnkContext ? pUnkContext : (IUnknown*)this);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+---------------------------------------------------------------
//
//  Member:     COleSite::ContextInvokeEx
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//              [pUnkContext]  - IUnknown to pass all calls to
//
//---------------------------------------------------------------

HRESULT
COleSite::ContextInvokeEx(
        DISPID       dispidMember,
        LCID         lcid,
        WORD         wFlags,
        DISPPARAMS * pdispparams,
        VARIANT *    pvarResult,
        EXCEPINFO *  pexcepinfo,
        IServiceProvider *pSrvProvider,
        IUnknown *   pUnkContext)
{
    HRESULT         hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *   pDispEx = NULL;
    
    if (IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    CacheDispatch();

    hr = THR_NOTRACE(IE3XObjInvoke(
        dispidMember,
        IID_NULL,
        lcid,
        wFlags,
        pdispparams,
        pvarResult,
        pexcepinfo,
        NULL));
    if (DISP_E_MEMBERNOTFOUND != hr) // if S_OK or error other then DISP_E_MEMBERNOTFOUND
        goto Cleanup;

    // Don't pass on a property get for DISPID_VALUE to CBase. CBase will always
    // return a default [object] string.

    if (!((wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE))
    {
        // Invoke any HTML element properties OR expando
        hr = THR_NOTRACE(super::ContextInvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider,
                    pUnkContext));
    }

    // If we're NOT an XObject DISPID AND we have a _pDisp AND it is safe to
    // delegate to the underlying object...
    if (hr == DISP_E_MEMBERNOTFOUND &&
        ((ULONG)dispidMember < DISPID_XOBJ_MIN || DISPID_XOBJ_MAX < (ULONG)dispidMember ) &&
        _pDisp &&
        IsSafeToScript())
    {
        if (!AccessAllowed(_pDisp))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        //
        // Try IDispatchEx2 first.
        //

        if (OK(THR_NOTRACE(QueryControlInterface(
                IID_IDispatchEx, 
                (void **)&pDispEx))))
        {
            hr = THR_NOTRACE(pDispEx->InvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
        }
        else
        {
            hr = THR_NOTRACE(InvokeDispatchWithNoThis (
                _pDisp,
                dispidMember,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo));
        }

        if (SUCCEEDED(hr) && pvarResult)
        {
            CDoc *pDoc = NULL;
            IDispatch *pDispResult = V_VT(pvarResult) == VT_DISPATCH ? V_DISPATCH(pvarResult) : NULL;
            if (pDispResult && SUCCEEDED(pDispResult->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc)))
            {
                IDispatch *pDisp = NULL;
                CDocument *pDocument = pDoc->_pWindowPrimary->Document();
                if (pDocument && SUCCEEDED(pDocument->QueryInterface(IID_IDispatch, (void **)&pDisp)))
                {
                    ReleaseInterface(pDispResult);
                    V_DISPATCH(pvarResult) = pDisp;
                }
            }
        }

#if 0
// Some activex controls like the IHammer controls will erroneously get an fp error
// w/o clearing the fp status codes.  This results in the script engines returning
// a fp error where none actually occured.  To bullet proof IE4 from from other
// errant apps like this we'll clear all exception flags prior to invoking an
// engine call.
#if (defined(_X86_))
#if DBG==1
__asm {
        fstsw	ax                  ;; Get error flags
        test	al,0DH              ;; See if any errors (Overflow, zero divide, invalid errs)
        jz      NoFPError           ;; No errors.
       }

    Assert(!"OleSite InvokeEx: Floating point status has errors.");
#endif  // DBG==1

    __asm { fnclex }                // Clear fp exception flags.
#endif // _X86_
#endif // 0
    }

#if 0
#if (defined(_X86_))
#if DBG==1
NoFPError:
#endif  // DBG==1
#endif // _X86_
#endif // 0

    // If we didn't find the default property on the OBJECT, retuin the
    // default object->string conversion
    if ( DISPID_NOT_FOUND(hr) && (wFlags & DISPATCH_PROPERTYGET) 
        && dispidMember == DISPID_VALUE && pvarResult &&
        pdispparams->cArgs == 0)
    {
        V_VT(pvarResult) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("[object]"),&V_BSTR(pvarResult) ) );
    }

Cleanup:
    ReleaseInterface(pDispEx);
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::GetDispID, IDispatchEx
//
//  Synopsis:   First try GetDispID, then try expando version.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    INSTANTCLASSINFO * pici;

    if (IllegalSiteCall(0))
        RRETURN (E_UNEXPECTED);

    //
    // try to resolve the name using the element
    //

    hr = THR_NOTRACE(super::GetDispID(
        bstrName,
        grfdex & (~fdexNameEnsure),     // (don't allow it to create new expandos just yet)
        pid));

    if (S_OK == hr)
    {
        hr = THR(RemapActivexExpandoDispid(pid));
        goto Cleanup;
    }
    else if (DISP_E_MEMBERNOTFOUND != hr && DISP_E_UNKNOWNNAME != hr)   // if S_OK or error other than
    {                                                                   // DISP_E_MEMBERNOTFOUND or DISP_E_UNKNOWNNAME
        goto Cleanup;
    }

    //
    // try to resolve the name using dispatch interfaces the control exposes
    //

    CacheDispatch();
    if (_pDisp)
    {
        pici = GetInstantClassInfo();

        if (pici && pici->IsDispatchEx2())
        {
            // try to resolve the name using IDispatchEx

            IDispatchEx *   pDispEx = NULL;

            hr = THR(_pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));

            if (S_OK == hr && pDispEx)
            {
                hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, grfdex, pid));

                ReleaseInterface(pDispEx);
            }
	    }
        else
        {
            // try to resolve the name using IDispatch

            hr = THR_NOTRACE(_pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, 0, pid));
        }

        if (S_OK == hr && *pid != DISPID_UNKNOWN)     // don't check for DISP_E_MEMBERNOTFOUND or DISP_E_UNKNOWNNAME here - 
        {                   // the control might not follow conventions strictly enough
            goto Cleanup;   // done
        }
    }

    //
    // neither element nor control supports the name; so try to ensure expando
    //

    hr = THR_NOTRACE(GetExpandoDispID(bstrName, pid, grfdex));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::RemapActivexExpandoDispid
//
//----------------------------------------------------------------------------

HRESULT
COleSite::RemapActivexExpandoDispid(DISPID * pid)
{
    HRESULT     hr = S_OK;

    if (IsExpandoDispid (*pid))
    {
        *pid = (*pid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE;

        // Too many activeX expandos?
        if (*pid > DISPID_ACTIVEX_EXPANDO_MAX)
        {
            // Don't allow it.
            *pid = DISPID_UNKNOWN;
            hr = DISP_E_UNKNOWNNAME;
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetNextDispID (IDispatchEx)
//
//  Synopsis:   Enumerates through all properties and html attributes.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    CacheDispatch();

    hr = THR(GetInternalNextDispID(grfdex, id, prgid, &bstr, _pDisp));
    SysFreeString(bstr);
    RRETURN1(hr, S_FALSE);
}

HRESULT
COleSite::GetMemberName(DISPID id, BSTR *pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;
    
    if (super::GetMemberName(id, pbstrName))
    {
        CacheDispatch();
        if (_pDisp)
        {
            UINT            cNames = 0;
            ITypeInfo      *pTI = NULL;
            CTypeInfoNav    tin;
            INSTANTCLASSINFO * pici = GetInstantClassInfo();

            if (pici && pici->IsDispatchEx2())
            {
                IDispatchEx *pDispEx = NULL;

                HRESULT hr = THR(_pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
                if (S_OK == hr && pDispEx)
                {
                    hr = THR(pDispEx->GetMemberName(id, pbstrName));
                    ReleaseInterface(pDispEx);
                    goto Cleanup;
                }
            }

            if (tin.InitIDispatch(_pDisp, &pTI, 0))
                goto Cleanup;

            if (pTI->GetNames(id, pbstrName, 1, &cNames))
                goto Cleanup;
            
            Assert(cNames == 1);
        }
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

HRESULT
COleSite::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    // TODO: (alexz) (terrylu) this needs to consider control's name space additionally
    // to implementation provided by super

    hr = THR(super::GetNameSpaceParent(ppunk));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite:InterfaceSupportsErrorInfo, ISupportErrorInfo
//
//  Synopsis:   Return true if given interface supports error info.
//
//  Arguments:  iid the interface
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::InterfaceSupportsErrorInfo(REFIID iid)
{
    HRESULT             hr = S_FALSE;
    ISupportErrorInfo * psei;

    hr = THR(super::InterfaceSupportsErrorInfo(iid));
    if (S_OK == hr)
        goto Cleanup;

    // S_FALSE means that the interface is not supported by the x-object.
    // Try the aggregated control.

    if (OK(THR_NOTRACE(QueryControlInterface(
            IID_ISupportErrorInfo, (void**) &psei))))
    {
        hr = THR(psei->InterfaceSupportsErrorInfo(iid));
        ReleaseInterface(psei);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetPages, ISpecifyPropertyPagse
//
//  Synopsis:   Return property pages supported
//
//  Arguments:  [pPages] -- return Pages here
//
//  Returns:    HRESULT
//
//  Notes:      Since the CSite aggregates the control, the set of pages
//              returned is obtained by appending the XObject property page to
//              the list of pages that the control says it supports.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetPages(CAUUID * pPages)
{
#ifdef NO_PROPERTY_PAGE
    pPages->pElems = NULL;
    pPages->cElems = 0;
    return S_OK;
#else
    HRESULT hr;

    hr = THR(AddPages(
            _pUnkCtrl,
            BaseDesc()->_apclsidPages,
            pPages));
    RRETURN(hr);
#endif // NO_PROPERTY_PAGE
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite:GetClassInfo, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::GetClassInfo(ITypeInfo ** ppTI)
{
    RRETURN(THR(super::GetClassInfo(ppTI)));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite:GetGUID, IProvideMultipleClassInfo
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    RRETURN(THR(super::GetGUID(dwGuidKind, pGUID)));
}


//---------------------------------------------------------------------------
//
//  Member:     COleSite::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
COleSite::GetMultiTypeInfoCount(ULONG *pc)
{
    RRETURN(GetAggMultiTypeInfoCount(pc, _pUnkCtrl));
}


//---------------------------------------------------------------------------
//
//  Member:     COleSite::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
COleSite::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    RRETURN(GetAggInfoOfIndex(
        iTI,
        dwFlags,
        ppTICoClass,
        pdwTIFlags,
        pcdispidReserved,
        piidPrimary,
        piidSource,
        _pUnkCtrl));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetBaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//				Helper used by CPluginSite and CObjectElement.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetBaseHref(BSTR *pbstr)
{
    HRESULT hr;
    TCHAR * pchUrl = NULL;

    *pbstr = NULL;
    
    hr = THR(CMarkup::GetBaseUrl(NULL, &pchUrl, this));
    if (hr)
        goto Cleanup;
        
    hr = THR(FormsAllocString(pchUrl, pbstr));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     COleSite::attachEvent
//
//  Synopsis:   Attach the event
//
//---------------------------------------------------------------------------

HRESULT 
COleSite::attachEvent(BSTR bstrEvent, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    DISPID      dispid;
    HRESULT     hr = S_OK;
    ITypeInfo * pTIEvent;

    if (!bstrEvent || !pDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //
    // First see if the event coming in is an event on the ocx.
    // If so, use it's dispid.  Otherwise just use the base implementation
    //

    EnsurePrivateSink();
    pTIEvent = GetClassInfo()->_pTypeInfoEvents;
    if (pTIEvent)
    {
        hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                &bstrEvent,
                1,
                &dispid));
        if (!hr)
        {
            hr = THR(AddDispatchObjectMultiple(
                    dispid,
                    pDisp,
                    CAttrValue::AA_AttachEvent,
                    CAttrValue::AA_Extra_OldEventStyle));
            goto Cleanup;
        }
    }
    
    hr = THR(super::attachEvent(bstrEvent, pDisp, pResult));

Cleanup:
    if (pResult)
    {
        *pResult = hr ? VARIANT_FALSE : VARIANT_TRUE;
    }

    RRETURN(SetErrorInfo(hr));
}
        

//+--------------------------------------------------------------------------
//
//  Member:     COleSite::detachEvent
//
//  Synopsis:   Detach the event
//
//---------------------------------------------------------------------------

HRESULT
COleSite::detachEvent(BSTR bstrEvent, IDispatch* pDisp)
{
    DISPID      dispid;
    HRESULT     hr = S_OK;
    ITypeInfo * pTIEvent;
    AAINDEX     aaidx = AA_IDX_UNKNOWN;
    IDispatch * pThisDisp = NULL;
    
    if (!bstrEvent || !pDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //
    // First see if the event coming in is an event on the ocx.
    // If so, use it's dispid.  Otherwise just use the base implementation
    //

    pTIEvent = GetClassInfo()->_pTypeInfoEvents;
    if (pTIEvent)
    {
        hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                &bstrEvent,
                1,
                &dispid));
        if (!hr)
        {
            // Find event that has this function pointer.
            for (;;)
            {
                aaidx = FindNextAAIndex(dispid, CAttrValue::AA_AttachEvent, aaidx);
                if (aaidx == AA_IDX_UNKNOWN)
                    break;

                ClearInterface(&pThisDisp);
                if (GetDispatchObjectAt(aaidx, &pThisDisp))
                    continue;

                if (IsSameObject(pDisp, pThisDisp))
                    break;
            };

            // Found item to delete?
            if (aaidx != AA_IDX_UNKNOWN)
            {
                DeleteAt(aaidx);
            }
            goto Cleanup;
        }
    }
    
    hr = THR(super::detachEvent(bstrEvent, pDisp));

Cleanup:
    ReleaseInterface(pThisDisp);
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\pluginst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       pluginst.cxx
//
//  Contents:   CPluginSite
//
//  Netscape plugin site code.  Works closely with plugin.ocx.
//
//  FYI:  A plugin is recorded in the HTML as:
//
//      <embed src="empty.vts" width=550 height=295 othername=otherval> 
//
//  Thus the plugin parameters are all recorded as tag attributes.  Contrast
//  this with an ActiveX imbedding which is stored as:
//     <OBJECT CLASSID = "clsid:01000000-840E-11CE-99BF-00AA0047D4FD">
//         <PARAM NAME="_Version" VALUE="65536">
//         <PARAM NAME="_ExtentX" VALUE="4445">
//         <PARAM NAME="_ExtentY" VALUE="3196">
//         <PARAM NAME="_StockProps" VALUE="13"></OBJECT>
//
//  Here is the IActiveXPlugin interface we use to communicate with plugin.ocx
//     interface IActiveXPlugin : IDispatch 
//     {
//        // Properties
//        // Methods
//        void Load([in]BSTR bstrUrl, [in]int bDeleteRegistry);
//        void AddParam([in]BSTR bstrName, [in]BSTR bstrValue);
//        void Show(void);
//        void Hide(void);
//        void Clear(void);
//        // get the Plugin's IDispatch, if any, otherwise return NULL
//        [propget] HRESULT dispatch([out, retval] IDispatch** retval);
//  
//     };
/*  Here is the plugin HTML spec from www.netscape.com:

Embedded plug-ins are loaded by Navigator when the user encounters an HTML page 
with an embedded object with a MIME type registered by a plug-in. When loaded, 
an embedded plug-in is displayed as part of the HTML document in a rectangular 
subpart of the page. This is similar to how a GIF or JPEG image is embedded, 
except that the plug-in can be live and respond to user events (such as mouse
 clicks). 

Plug-in objects are embedded in an HTML page by using the EMBED tag. The syntax
 of the EMBED tag is: 

<EMBED attributes> ... </EMBED>      [**** Tomsn note: the </EMBED> is often omitted]


Use the following attributes with the EMBED tag: 

HEIGHT="value" defines the horizontal location of the plug-in in the HTML page. 
    The unit of measurement is optionally defined by the UNITS attribute. 

HIDDEN="value" indicates whether the plug-in is visible on the page. 
    The value can be either true (the default) or false. A value of true 
    overrides the values of HEIGHT and WIDTH, making the plug-in zero-sized. 
    Always explicitly set HIDDEN=true to make an invisible plug-in (rather 
    than simply setting the HEIGHT and WIDTH to zero). 

PALETTE="value" indicates the mode of the plug-in's color palette. 
    The value can be either foreground or background (the default). 
    The palette mode is only relevant on the Windows platform. 

PLUGINSPAGE="URL" indicates the location of instructions on installing 
    the plug-in. The value URL is a standard uniform resource locator. 
    The URL is used by the assisted installation process if the plug-in 
    registered for the MIME type of this EMBED tag is not found. 

SRC="URL" optionally indicates the location of the plug-in data file.
    The value URL is a standard uniform resource locator. The MIME type of 
    the file (typically based on the file-name suffix) determines which 
    plug-in is loaded to handle this EMBED tag. Either the SRC attribute 
    or the TYPE attribute is required in an EMBED tag. 

TYPE="type" optionally indicates the MIME type of the EMBED tag, which 
    in turn determines which plug-in is loaded to handle this EMBED tag. 
    Either the SRC attribute or the TYPE attribute is required in an EMBED tag. 
    Use TYPE instead of SRC for plug-ins that require no data (for example, 
    a plug-in that draws an analog clock) or plug-ins that fetch all their 
    data dynamically. 

WIDTH="value " optionally defines the vertical location of the plug-in in 
    the HTML page. The unit of measurement is optionally defined by the 
    UNITS attribute. 

UNITS="value" defines the measurement unit used by the HEIGHT and WIDTH 
    attributes. The value can be either pixels (the default) or en 
    (half the point size). 

In addition to these standard attributes, plug-ins may optionally have private 
attributes to communicate specialized information between the HTML page and 
the plug-in code. Navigator ignores all non-standard attributes when parsing 
the HTML, but passes all attributes to the plug-in, allowing the plug-in to 
examine the attribute list for any private attributes that may modify its behavior. 

For example, a plug-in that displays video could have private attributes 
to determine whether the plug-in should automatically start playing the video, 
and whether the video should automatically loop on playback. Thus an example 
EMBED tag could be: 

<EMBED SRC="myavi.avi" WIDTH=320 HEIGHT=200 AUTOSTART=true LOOP=true>

Navigator would interpret the SRC tag to load the data file and determine the 
MIME type of the data, and the WIDTH and HEIGHT tags to size the area of the 
page handled by the plug-in to be 320 by 200 pixels. Navigator would simply 
ignore private attributes AUTOSTART and LOOP and pass them to the plug-in with 
the rest of the attributes. The plug-in could then scan its list of attributes 
to see if it should automatically start the video and loop it on playback. 
 */
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_INETREG_H_
#define X_INETREG_H_
#include "inetreg.h"    // for REGSTR_VAL_CODEDOWNLOAD & stuff
#endif

#ifndef X_PLUGIN_I_H_
#define X_PLUGIN_I_H_
#include "plugin_i.h"   // IActiveXPlugin interface definition.
#endif

#define _cxx_
#include "pluginst.hdl"

MtDefine(CPluginSite, Elements, "CPluginSite")
MtDefine(MapExtnToKnownControl, CPluginSite, "MapExtnToKnownControl (code base)")
MtDefine(CPluginSiteCreateObject, CPluginSite, "CPluginSite::CreateObject");

// These are the clsids for the actual plugin.ocx control:
const GUID CDECL IID_IActiveXPlugin =
{  0x06DD38D1L,0xD187,0x11CF,{ 0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8}};

const GUID CDECL CLSID_ActiveXPlugin =
  { 0x06DD38D3L,0xD187,0x11CF, {0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8}};

const CElement::CLASSDESC CPluginSite::s_classdesc =
{
    {
        &CLSID_HTMLEmbed,              // _pclsid
        0,                             // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                        // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_OLESITE,           // _dwFlags
        &IID_IHTMLEmbedElement,        // _piidDispinterface
        &s_apHdlDescs,                 // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLEmbedElement, // _pfnTearOff
    NULL                               // _pAccelsRun
};


HRESULT 
CPluginSite::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CPluginSite(pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::get_BaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//              Uses the helper provided by COleSite.
//              BTW, this is the only abstract property in pluginst.pdl,
//              therefore this is the only get/set routine in this src file.
//
//----------------------------------------------------------------------------

HRESULT
CPluginSite::get_BaseHref(BSTR *pbstr)
{
    RRETURN( SetErrorInfo(GetBaseHref( pbstr )) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::CreateObject
//
//  Synopsis:   Called by our super when it comes time to actually create
//              the ActiveX Plugin control.
//
//              We gather the parameters from two places: 1) CUnknownPair
//              list which hase the <embed unknown1=this unknown2=that>
//              type pairs, and 2) _pAA attributes list is is accessed via
//              all our custom get_XXX() routines.  This list contains all the
//              known properties such as <embed width=4444 src=a_plugin.vts>.
//              These properties are available to vbscript code.
//
//              We transmit the properties to plugin.ocx via two routes: 1)
//              Load( pPropertyBag ).  This way the control gets all the known
//              properties up front at load time.  Eventially we may support
//              IPersistPropertyBag2 which will let the control find *all* properties,
//              known and unknown, at load time.  2) Call pActiveXPlugin->Load()
//              for every propety, know and unknown.
//
//              What this gives us is a uniform presentation of properties to 
//              plugin.ocx.  It can choose to use them at the Load( pPropertyBag ) time,
//              at the pActiveXPlugin->Load() time, or a mixture of the two.
//----------------------------------------------------------------------------

BOOL TryAsActiveXControl(CDoc *pDoc, LPCTSTR pszFile, LPTSTR pszClassId, 
 LPTSTR *ppszCodeBase, LPCTSTR szMimeTypeIn);

// This routine is exported by urlmon and should appear in a public header
// someday:
STDAPI FindMimeFromData(
                        LPBC pBC,                   // bind context - can be NULL
                        LPCWSTR pwzUrl,             // url - can be null 
                        LPVOID pBuffer,             // buffer with data to sniff - can be null (pwzUrl must be valid)
                        DWORD cbSize,               // size of buffer
                        LPCWSTR pwzMimeProposed,    // proposed mime if - can be null
                        DWORD dwMimeFlags,          // will be determined
                        LPWSTR *ppwzMimeOut,        // the suggested mime
                        DWORD dwReserved);          // must be 0

BOOL GetMimeTypeFromUrl(LPCTSTR url, TCHAR *mime);

HRESULT
CPluginSite::CreateObject()
{
    HRESULT             hr = E_FAIL;
    LPCTSTR             pszSrc = NULL;
    OLECREATEINFO       info;
    TCHAR               szClassId[2*CLSID_STRLEN];
    TCHAR               szMime[MAX_PATH];
    LPCTSTR             pszMime = NULL;
    LPTSTR              pszCodeBase = NULL;
    CMarkup *           pMarkup = GetMarkup();
    CDoc *              pDoc;

    if (pMarkup == NULL)
    {
        AssertSz(FALSE, "Should have a markup");
        RRETURN(hr);
    }
    pDoc = pMarkup->Doc();

    GWKillMethodCall((COleSite *)this, ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0);

    pDoc->AddRef();
    
    //
    // If user settings or other factors outside us prohibit
    // ActiveX controls and Plugins from running, then we
    // fail this create entirely:
    //

    if (!AllowCreate(CLSID_ActiveXPlugin))
        goto Cleanup;

    // See if this is printing and we've got a snapshot
    // TODO PRINT 112553: Can we share implementation with CObjectElement in COleSite ?
    if (pMarkup->IsPrintMedia())
    {
        DISPID dispid;
        LPTSTR pchEMF = NULL;
        
        if (S_OK == THR(GetExpandoDispID(_T("_Snapshot_EMF"), &dispid, 0))
            && (*GetAttrArray())->FindString(dispid, (LPCTSTR*)&pchEMF, CAttrValue::AA_Expando)
            && pchEMF)
        {
            // "_ZERO" means that the original didn't have layout, or had zero size.
            // We don't need it at all.
            if (0 !=_tcscmp(pchEMF, _T("_ZERO")))
            {
                // Open the metafile and hold on to it
                if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
                {
                    // Use Unicode file name
                    _hemfSnapshot = GetEnhMetaFile(pchEMF);
                }
                else
                {
                    // Use ANSI file name
                    char achFileNameA[MAX_PATH];
                    if (WideCharToMultiByte(CP_OEMCP, 0, pchEMF, -1, achFileNameA, MAX_PATH, NULL, NULL))
                    {
                        _hemfSnapshot = GetEnhMetaFileA(achFileNameA);
                    }
                }
            }
            
            // Supply a dummy object to pretend we've loaded it. It will fail all QIs and do nothing.
            _pUnkCtrl = (IUnknown *) new CDummyUnknown;
            _pUnkCtrl->AddRef();

            // we are done. we don't need to load anytning else, metafile is all we need.
            goto Cleanup;
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // winse 24131 a-naande 5-2-02
    // adapted from CMarkup::LoadFromInfo, when the plugin is being reloaded, it doesn't get named
    // which can mess up navigation in frames, so check if it should be named and then set the name
    BSTR bstrName = NULL;
    if (pDoc->_fViewLinkedInWebOC && pMarkup->IsPrimaryMarkup())
    {
        COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

        if (pOmWindowProxy)
            IGNORE_HR(pOmWindowProxy->Window()->get_name(&bstrName));
    }

    if ((pMarkup->IsPrimaryMarkup() || (pMarkup->HasWindowPending() && pMarkup->GetWindowPending()->Markup()->IsPrimaryMarkup())) 
        && bstrName 
        && *bstrName)
    {
        hr = pDoc->_pWindowPrimary->put_name(bstrName);
    }

    if(bstrName)FormsFreeString(bstrName);
    // end 24131
    ///////////////////////////////////////////////////////////////////////////////////////////////

    // If this is a full-window embed, try to use the content type
    // reported to the binding via IMonikerProp for the plugin data file.
    if (pDoc->_fFullWindowEmbed)
    {
        pszMime = pDoc->_cstrPluginContentType;
        if (pszMime)
            SetAAtype(pszMime);
    }


    // If current document was obtained by POST action, the src attribute is
    // incorrect.  Use path to the cached data file instead.
    //
    // TODO:    What if the cached file is still being downloaded??  Can we
    //          still hand this to the plugin/control?  Or should we wait until
    //          the file is fully downloaded?  (philco)
    if (pDoc->_fFullWindowEmbed && pMarkup->GetDwnPost())
    {
        if(!pDoc->_fUseSrcURL)
            SetAAsrc(pDoc->_cstrPluginCacheFilename);
    }


    _fHidden = GetAAhidden();

    pszSrc = GetAAsrc();
    pszMime = GetAAtype();  // 'type' attribute is the mime type.

    if( !pszSrc && !pszMime )
        goto Cleanup;

    // Make sure we have at least an empty param bag allocated:
    hr = THR(EnsureParamBag());
    if (hr)
        goto Cleanup;

    Assert(_pParamBag);
    info.pPropBag = _pParamBag;
    info.pPropBag->AddRef();

#if 0
    // This URLMON call does not do a thorough enough job - it stops
    // just short of contacting the server to dertermine the mime type.
    // Thus we do the call just below this.
    FindMimeFromData( NULL, pszSrc, NULL, 0, NULL, 0, &pszMime, 0 );
#endif

    // Give the plugin the fully qualified URL of the plugin src file:
    if( pszSrc )
    {
        TCHAR   cBuf[pdlUrlLen];
        CMarkup::ExpandUrl(NULL, pszSrc, ARRAY_SIZE(cBuf), cBuf, this);

        if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
        {
            // If unsecure, NULLify URL
            pszSrc = NULL;
            Assert(!_pszFullUrl);
        }
        else
        {
            MemAllocString(Mt(CPluginSiteCreateObject), cBuf, &_pszFullUrl);
            if (_pszFullUrl == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }

    // Track down the mime type.
    // If it is not given explicitly via an attribute of the <embed> tag, 
    // then query the server about what it thinks the mime type is.
    if( !pszMime && GetMimeTypeFromUrl(_pszFullUrl, szMime) )
    {
        // Some servers lie about the mime type and return "text/plain" to
        // confuse us.  Therefore we ignore such uninformative returns.
        if( StrCmpIC( szMime, _T("text/plain") ) && StrCmpIC( szMime, _T("text/html") ))
        {
            pszMime = szMime;
            hr = SetAAtype(pszMime);
            if( FAILED( hr ) )
                goto Cleanup;
        }
        else
        {
            // One last chance.  If this is a full-window embed, use the 
            // content type reported to the binding used for the plugin data file.
            if (pDoc->_fFullWindowEmbed)
            {
                pszMime = pDoc->_cstrPluginContentType;
                hr = SetAAtype(pszMime);
                if( FAILED( hr ) )
                    goto Cleanup;
            }
        }
    }


    // First decide if we should actually create an ActiveX control
    // to handle this data.  Notice pszCodeBase is an OUT param which
    // if allocated gets freed in the Cleanup.
    if( TryAsActiveXControl( pDoc, pszSrc, szClassId, &pszCodeBase, pszMime ) )
    {   //
        // Create ActiveX control directly code path....
        //
        hr = CLSIDFromHtmlString( szClassId, &info.clsid );
        if (FAILED(hr))
        {
            hr = THR(CLSIDFromString(szClassId, &info.clsid));
            if (FAILED(hr))
                goto Cleanup;
        }
        
        MemReplaceString(Mt(OleCreateInfo), pszCodeBase, &info.pchSourceUrl);

        // Set particular parameters based on what we know from other
        // places:
        if( pszCodeBase )
        {
            hr = SetAAcodeBase(pszCodeBase);
            if( FAILED( hr ) )
                goto Cleanup;
        }

        // Save them again so all that new stuff gets propagated to the
        // property bag:
        hr = THR(SaveAttributes(_pParamBag, FALSE));
        if (hr)
            goto Cleanup;
    
        // Right now super:: is COleSite.  If that ever changes you'd
        // better eyeball this whole routine closely.
        _fUsingActiveXControl = TRUE;
        hr = super::CreateObject( &info );
        // Be aware that that CreateObject() call is asynchronous and
        // COleSite will finish creating the object on the CreateObjectNow()
        // callback from CCodeLoad.
    }
    else if(Doc()->_pOptionSettings->fUsePlugin ) 
    {   //
        // Normal plugin.ocx plugin handling code path...
        //
        info.clsid = CLSID_ActiveXPlugin;
    
        // This saves all, known & unknown attributes into the property bag:
        hr = THR(SaveAttributes(_pParamBag, FALSE));
        if (hr)
            goto Cleanup;
    
        _fUsingActiveXControl = FALSE;
        hr = THR(super::CreateObject(&info));
        if (hr)
            goto Cleanup;
        // Be aware that that CreateObject() call is asynchronous and
        // WE will finish creating the object on the CreateObjectNow()
        // callback from CCodeLoad.
    }
    
Cleanup:
    pDoc->Release();
    MemFreeString(pszCodeBase);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPluginSite::PostLoad
//
//  Synopsis:   Called after the OLE site loads it's component in the normal
//              way.  Used to perform special actions after loading.
//
//---------------------------------------------------------------
HRESULT
CPluginSite::PostLoad()
{
    IActiveXPlugin *    pIActiveXPlugin = NULL;
    HRESULT             hr = S_OK;

    if( !_fUsingActiveXControl ) 
    {
        hr = QueryControlInterface(IID_IActiveXPlugin, (LPVOID*)&pIActiveXPlugin);
        if (hr)
            goto Cleanup;

        // _pszFullUrl may be NULL & that's OK.
        pIActiveXPlugin->Load( _pszFullUrl, FALSE );
    }

  Cleanup:
    ReleaseInterface(pIActiveXPlugin);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPluginSite::Passivate
//
//  Synopsis:   Called when main CSite reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use
//              IUnknown::Release instead.
//
//---------------------------------------------------------------

void
CPluginSite::Passivate()
{
    MemFree( _pszFullUrl );
    _pszFullUrl = NULL;

    ReleaseParamBag();

    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::Save
//
//  Synopsis:   Call PLUGIN.OCX to save its parambag, and look for special printing keyword
//              IE5/60771
//
//----------------------------------------------------------------------------

HRESULT
CPluginSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DISPID  expandoDISPID = DISPID_UNKNOWN;

    
    if (!fEnd && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CDoc * pDoc = Doc();

        // Only create expando if no other print jobs are pending, so we don't have to
        // freeze the document for too long.
        if (!pDoc || !pDoc->_fSaveTempfileForPrinting || pDoc->PrintJobsPending())
            goto Cleanup;

        // Save metafile snapshot for printing 
        BOOL fSnapshotSucceeded = FALSE;
        if (_pUnkCtrl)
        {
            TCHAR   achTempFileName[MAX_PATH];
            
            if (S_OK == SaveMetaFileSnapshot(achTempFileName))
            {
                // Create an expando
                hr = THR_NOTRACE(AddExpando(L"_Snapshot_EMF", &expandoDISPID));
                if (hr)
                    goto Cleanup;

                expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                    DISPID_ACTIVEX_EXPANDO_BASE;

                hr = THR(AddString(
                        expandoDISPID,
                        achTempFileName,
                        CAttrValue::AA_Expando));
                if (hr)
                    goto Cleanup;

                AssertSz(TRUE, "Plugin: metafile snapshot succeeded!");
                fSnapshotSucceeded = TRUE;
            }
            else
            {
                // Snapshot failed. We may need to marshall a pointer if it doesn't work
                AssertSz(0, "Failed to save metafile shapshot");
            }
        }

#if 0   // TODO PRINT 112553: There is still code in plugin.ocx (in Controls project) that supports
        //                    IE5-style marshalled pointers. That code should be cleaned up too.
        //                    Use this to guide you to the obsolete code in control.cpp (or search for "alexmog" there).
        
        // If snapshot was not successful, marshal pUnknown
        if (!fSnapshotSucceeded && 
            OK(ExchangeParamBag(FROMCONTROL)))
        {
            // If we have a marshaled punk, add an expando for it.
            //
            VARIANT   var;
            PROPBAG2  propbag;
            TCHAR     szBuf[16];

            memset(&propbag, 0, sizeof(PROPBAG2));
            propbag.vt = VT_I4;
            propbag.pstrName = L"_Marshaled_pUnk";

            // Look for a parameter named "_Marshaled_pUnk"
            //
            VariantInit(&var);
            if (OK(_pParamBag->Read(1, &propbag, NULL, &var, &hr)) && OK(hr))
            {
                // I think we need it to be a string?
                //
                if (var.vt == VT_I4)
                {
                    wsprintf(szBuf, L"%d", var.ulVal);
                    VariantClear(&var);

                    // Create an expando

                    hr = THR_NOTRACE(AddExpando(L"_Marshaled_pUnk", &expandoDISPID));
                    if (hr)
                        goto Cleanup;

                    expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                        DISPID_ACTIVEX_EXPANDO_BASE;

                    hr = THR(AddString(
                            expandoDISPID,
                            szBuf,
                            CAttrValue::AA_Expando));
                    if (hr)
                        goto Cleanup;

                    // Let DoPrint know we now rely on the original document to stick around.
                    pDoc->_fPrintedDocSavedPlugins = TRUE;
                }
            }
        }
#endif
    }

Cleanup:
        hr = THR(super::Save(pStreamWrBuff, fEnd));

    // If we added an expando to save the punk, remove it now.
    if (expandoDISPID != DISPID_UNKNOWN)
        FindAAIndexAndDelete(expandoDISPID, CAttrValue::AA_Expando);
    
    ReleaseParamBag();
    RRETURN1(hr, S_FALSE);
}


//=================================================================
//===== THIS HELPER CODE STOLEN FROM IE3.0 PLUGIN.OCX FILE DIALOGS.CPP
//=================================================================

//////////////////////////////////////////////////////////////////////////
//
//    GetMimeTypeFromUrl                                         [PUBLIC]
//
//  Ideally we would not have synchronous calls like this into wininet
// on the GUI thread.  They should be made asynchronous and use a callback
// to return the data when available.  The callback support in wininet, 
// however, makes cross thread calls to the callback function.  We can not
// use that.  The asynchronous support in urlmon.dll, which does the correct
// same-thread callback behavior, does not have an interface for just querying
// the mime type.  You must download the data and you then get the mime type
// as a side effect.  We don't want to download the data at this time.
//
// To work around the possibility of freezing the GUI thread while waiting for
// a response from the internet server, we set the timeout to be a relatively
// low 10 seconds.  
//
BOOL GetMimeTypeFromUrl(LPCTSTR url, TCHAR *mime)
{
   BOOL        bRet = FALSE;
#ifdef WIN16
   // BUGWIN16
   TraceTag((tagError, "GetMimeTypeFromUrl - pluginst.cxx, need to plugin ours !!"));
#else
   HINTERNET   hInternet=NULL;                 // opened connection
   HINTERNET   hRequest=NULL;                  // opened request
   DWORD       dwSize  = MAX_PATH;        // size of buffer returned
   DWORD       dwTimeout = 10000;   // 10 seconds.

   Assert( mime );

   if (NULL == url)
      goto Cleanup;

   if (NULL == (hInternet = InternetOpen(_T("contype"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)))
      goto Cleanup;

   InternetSetOption( hInternet, INTERNET_OPTION_CONNECT_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_DATA_RECEIVE_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_SEND_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_RECEIVE_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );

   if (NULL == (hRequest  = InternetOpenUrl(hInternet, url, _T("Accept: */*"), (ULONG)-1, 0, 0)))
      goto Cleanup;

   if (!HttpQueryInfo(hRequest, HTTP_QUERY_CONTENT_TYPE, mime, &dwSize, NULL))
      goto Cleanup;

   if (dwSize > 0)
      bRet = TRUE;

  Cleanup:
   if( hRequest )
      InternetCloseHandle(hRequest);
   if( hInternet )
      InternetCloseHandle(hInternet);

#endif
   return (bRet);
}

//=================================================================
//===== THIS DIALOG CODE STOLEN FROM IE3.0 SOURCE FILES DLG_PLUG.*
//=================================================================

typedef struct {
    LPCTSTR  szExt;
    LPCTSTR  szMIMEtype;
} DLGPLUGDATA, *LPDLGPLUGDATA;

INT_PTR CALLBACK OCXOrPluginDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            LPDLGPLUGDATA lpPlug;
            lpPlug = (LPDLGPLUGDATA) lParam;

            // turn checkbox on
            CheckDlgButton(hDlg, IDC_PLUGIN_UPGRADE_CHECK, TRUE);

            // set dialog text for MIME and Extention
            SetDlgItemText(hDlg, IDC_PLUGIN_UPGRADE_MIME_TYPE, 
                lpPlug->szMIMEtype);
            SetDlgItemText(hDlg, IDC_PLUGIN_UPGRADE_EXTENSION, 
                lpPlug->szExt);
        }
        return FALSE;

    case WM_DESTROY:
        return TRUE;
/*
    case WM_HELP:            // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
        HELP_WM_HELP, (DWORD)(LPSTR)mapIDCsToIDHs);
        break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
        HELP_CONTEXTMENU, (DWORD)(LPSTR)mapIDCsToIDHs);
        break;
*/
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {

            case IDYES:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    EndDialog(hDlg, IDYES);
                    return TRUE;
                }
                break;

            case IDCANCEL:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
                }
                break;

            case IDNO:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    if (IsDlgButtonChecked(hDlg, IDC_PLUGIN_UPGRADE_CHECK))
                        EndDialog(hDlg, IDCANCEL );
                    else
                        EndDialog(hDlg, IDNO);
                    return TRUE;
                }
                break;
        }

    }

    return FALSE;
}

//=================================================================
//===== THIS CODE STOLEN FROM IE3.0 SOURCE FILE HTML.C
//=================================================================

const static TCHAR * szKNOWNCONTROLS = 
    _T("Software\\Microsoft\\Internet Explorer\\EmbedExtnToClsidMappings\\");

const static TCHAR * szKNOWNCONTROLSOVER = 
    _T("Software\\Microsoft\\Internet Explorer\\EmbedExtnToClsidMappingOverride\\");
    
// MapExtnToKnownControl
// Looks up a registry mapping for Extn to Clsid + CODEBASE (if available)
// Returns: 
//  TRUE: if found a clsid for extn
//  FALSE: not found or any error
BOOL MapExtnToKnownControl(TCHAR *fileExt, TCHAR *szClassId, TCHAR **ppszCodeBase)
{
    DWORD Size = MAX_PATH;
    DWORD dwType =0;
    LONG lResult = ERROR_SUCCESS;

    const static TCHAR * szCODEBASE = _T("CODEBASE");

    TCHAR szKey[pdlUrlLen];
    TCHAR szCodeBase[pdlUrlLen];
    HKEY hKeyExt = 0;

    BOOL fRet = FALSE;

    wcscpy(szKey, szKNOWNCONTROLS);
    wcsncat(szKey, fileExt, sizeof(szKey)/sizeof(TCHAR) - lstrlen(szKNOWNCONTROLS));    
    
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, 
                        KEY_READ, &hKeyExt);

    if (lResult == ERROR_SUCCESS) {

        Size = MAX_PATH;
        lResult = RegQueryValueEx(hKeyExt, NULL, NULL, &dwType, 
                            (LPBYTE)szClassId, &Size);

        if (lResult == ERROR_SUCCESS) {

            fRet = TRUE;

            Size = pdlUrlLen;
            lResult = RegQueryValueEx(hKeyExt, szCODEBASE, NULL, &dwType, 
                                (LPBYTE)szCodeBase, &Size);

            if (lResult == ERROR_SUCCESS) {
                HRESULT hr = MemAllocString( Mt(MapExtnToKnownControl), szCodeBase, ppszCodeBase );
                if( hr )
                    fRet = FALSE;
            }
        }

        if (hKeyExt)
        {
            RegCloseKey(hKeyExt);
            hKeyExt = NULL; 
        }            
    }

    //
    // Also check for Override key path...
    //
    if ( ! fRet )
    {
        wcscpy(szKey, szKNOWNCONTROLSOVER);     
        wcsncat(szKey, fileExt, sizeof(szKey)/sizeof(TCHAR) - lstrlen(szKNOWNCONTROLSOVER));
        
        Assert( ! hKeyExt ); 
        
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, 
                            KEY_READ, &hKeyExt);

        if (lResult == ERROR_SUCCESS) {

            Size = MAX_PATH;
            lResult = RegQueryValueEx(hKeyExt, NULL, NULL, &dwType, 
                                (LPBYTE)szClassId, &Size);

            if (lResult == ERROR_SUCCESS) {

                fRet = TRUE;

                Size = pdlUrlLen;
                lResult = RegQueryValueEx(hKeyExt, szCODEBASE, NULL, &dwType, 
                                    (LPBYTE)szCodeBase, &Size);

                if (lResult == ERROR_SUCCESS) {
                    HRESULT hr = MemAllocString( Mt(MapExtnToKnownControl), szCodeBase, ppszCodeBase );
                    if( hr )
                        fRet = FALSE;
                }
            }

            if (hKeyExt)
                RegCloseKey(hKeyExt);
        }
    }
    
    return fRet;
}

BOOL UserPrefersControlOverPlugin(CDoc *pDoc, TCHAR const *szName, TCHAR *fileExt)
{

    BOOL fRet;
    TCHAR szKey[MAX_PATH];
    int Choice;
    DLGPLUGDATA   Plug;
    HWND hwndParent;

    Plug.szExt = fileExt;
    Plug.szMIMEtype = szName;

    {
        CDoEnableModeless   dem(pDoc, NULL);
        
        hwndParent = dem._hwnd;
        Choice = DialogBoxParam(GetResourceHInst(),
                              MAKEINTRESOURCE(IDD_PLUGIN_UPGRADE),
                              hwndParent,
                              &OCXOrPluginDlgProc,
                              (LPARAM)&Plug);
    }
    
    switch (Choice) {

    case IDYES:
        fRet = TRUE;
        break;
        
    case IDNO:

        // never ask again for this data type/extn
        // remove the entry from the known controls list in the registry
        wcscpy(szKey, szKNOWNCONTROLS);
        wcscat(szKey, fileExt);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
        
    case IDCANCEL:
    default:

        fRet = FALSE;
        break;
    }

    return fRet;
}

#ifndef WIN16
#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"  // for string conversions.
#endif
#endif // !WIN16

//
// FindPlugin - delegates this call to the plugin OCX
//
BOOL FindPlugin(TCHAR *szFileExt, TCHAR *szName, TCHAR const *szMime)
{
   typedef (WINAPI *PFN_FINDPLUGIN)(char *ext, char *name, char *mime);
   PFN_FINDPLUGIN pfnFindPlugin;
   BOOL fRet = FALSE;

   HMODULE hLib = LoadLibraryEx(_T("plugin.ocx"), NULL, 0);
   if (hLib == NULL)
   {
       goto Exit;
   }

    // Wowza - I wish there was a FindPluginW() available....
   pfnFindPlugin = (PFN_FINDPLUGIN)GetProcAddress(hLib, "FindPluginA");
   if (pfnFindPlugin == NULL)
   {
       goto Exit;
   }

   //BUGWIN16: shortcut, CStrIn is not defined for several reasons.
   // we need to fix that before enabling this.
#ifndef WIN16
   {
        CStrIn strinFileExt(szFileExt), strinName(szName), strinMime(szMime);
        fRet = pfnFindPlugin(strinFileExt, strinName, strinMime);
   }
#endif // !WIN16
Exit:
   if (hLib)
      FreeLibrary(hLib);

   return fRet;
}

//
// Checks the registry to see if we should prefer a plugin over a certain
// control for a certain file extension. This was put in because some ActiveX
// controls do not fully support rendering the file extensions they claim.
//
// For example ActiveMovie doesn't support QuickTime VR .mov files.
//
BOOL PreferPluginOverControl(TCHAR *szFileExt, TCHAR *szClassId)
{
    HKEY hk;
    TCHAR szKeyName[MAX_PATH];
    TCHAR *pszRealClassId;

    //
    // The real classid name begins at szClassId + strlen("clsid:")
    //
    Assert(szClassId && wcslen(szClassId) > 6);
    pszRealClassId = szClassId + 6;

    // notice tricky braces '}' below due to bizarre look of the
    // pszRealClsid we get:
    Format( 0, szKeyName, MAX_PATH, _T("CLSID\\{<0s>\\EnablePlugin\\<1s>"), pszRealClassId, szFileExt);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKeyName, 0, KEY_READ, &hk) ==
        ERROR_SUCCESS)
    {
        RegCloseKey(hk); // Close the key immediately, just test for existance
        
        //
        // Now we know we have a control that doesn't handle this file extension
        // fully. So we make the expensive call to find out if there is a 
        // plugin that can handle this file extension. The sad assumption is 
        // that any plugins will handle this file type better than this control
        //
        if (FindPlugin(szFileExt, NULL, NULL))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL PreferControlOverPlugin(CDoc *pDoc, TCHAR *fileExt, TCHAR const *pszMime)
{
    TCHAR name[MAX_PATH];
    HKEY hkey = NULL;
    TCHAR szDoCodeDownload[10]; // should only be "yes" or "no"
    DWORD cb;
    BOOL fRet = TRUE;

    name[0] = _T('\0');  // start out fresh and clean.

    if (!FindPlugin(fileExt, name, pszMime))
    {
        goto Exit;
    }

    // check to see if the user has set codedown load to "no"
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TSZWININETPATH, (DWORD) NULL,
            KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(szDoCodeDownload);
        if (RegQueryValueEx(hkey, REGSTR_VAL_CODEDOWNLOAD, NULL,
                NULL, (LPBYTE)szDoCodeDownload, &cb) == ERROR_SUCCESS)
        {
            goto SkipDefault;
        }
    }

    // something went wrong... use default
    wcscpy(szDoCodeDownload, REGSTR_VAL_CODEDOWNLOAD_DEF);

SkipDefault:
    
    if (hkey)
        RegCloseKey(hkey);

    // if "no" codedownload... don't ask the question
    if (!_tcsicmp(szDoCodeDownload, TEXT("no")))
    {
        fRet = FALSE;
        goto Exit;  // return FALSE
    }

    // there is a plugin for this extn/mime on the system
    // we have to pop up a courtesy dialog to the user to check if they 
    // want to use the plugin or download the control

    fRet = UserPrefersControlOverPlugin(pDoc, pszMime, fileExt);

Exit:
    return fRet;
}


// TryAsActiveXControl
//
// try to locate an activeX control 
// if absent, check for known control extension to clsid mapping
// if absent or present and user wanted to use a plugin anyway
// fall to the plugin. Otherwise we go to the 
// object code with the clsid/codebase form the registry
#define REGKEY_DISABLEACTIVEX \
 _T("Software\\Microsoft\\Internet Explorer\\Plugins\\DisableActiveXControls")

int GetFileExtension(LPCTSTR szFilename, TCHAR **szExtension);
BOOL IsActiveXControl(LPCTSTR szFile, TCHAR *szClassId, TCHAR *fileExt, LPCTSTR szMimeTypeIn);

BOOL TryAsActiveXControl(CDoc *pDoc, LPCTSTR pszFile, LPTSTR pszClassId, 
 LPTSTR *ppszCodeBase, LPCTSTR szMimeTypeIn)
{
    TCHAR    *fileExt = NULL;    // file extension
    BOOL    fRet     = FALSE;    // return value
    HKEY    hKey     = NULL;     // reg key
    LONG    cbData     = 0;      // bytes to read
    TCHAR   szKey[MAX_PATH];
    HRESULT    hr;               // return code

    // Determine if searching for activex controls has been disabled...
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_DISABLEACTIVEX, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == hr)
    {
       cbData = MAX_PATH;
       RegQueryValue(hKey, NULL, szKey, &cbData);
       RegCloseKey(hKey);
       if (StrCmpIC(szKey, _T("true")) == 0)
          return (FALSE);
    }

    // Need to parse the szFile to get the extension.
    // If this fails we carry on since we can also use the mimetype below.
    if( pszFile )
        GetFileExtension(pszFile, &fileExt);

    if (fileExt && _tcslen(fileExt) > 50)
    {
        //Qfe8503:If we have a szMimeTypeIn, then continue to search 
        // for ActiveX control by MimeType otherwise exit.    
        if ( ! szMimeTypeIn )
        {
            fRet = FALSE;
            goto exit;
        }
    }
    
    fRet = IsActiveXControl(pszFile, pszClassId,fileExt,szMimeTypeIn);

    // If we have no file extension then the processing below is not
    // applicable and we return the fRet just obtained.
    if (!fileExt)
        goto exit;

    //
    // If there is an ActiveXControl that we might want to use for this EMBED
    // tag, we check if there is a plugin that can handle this file extension
    // and if we prefer this plugin over this control. If so return FALSE;
    //
    if (fRet)
    {
        if(PreferPluginOverControl(fileExt, pszClassId))
        {
            fRet = FALSE; // set return value to FALSE so will use the PLUGIN
        }
        else
        {
            ;    // Do nothing as fRet is already TRUE so will use the CONTROL
        }

        //
        // Return result in fRet as we know we have a control or plugin to use.
        //
        goto exit;
    }

    // check for a Known control availabe

    fRet = MapExtnToKnownControl(fileExt, pszClassId, ppszCodeBase);

    if (!fRet)
        goto exit;    // if not found then use the plugin if any

    //
    // nolonger ask for courtesy dialog
    //
#if 0 
    // check for a plugin, and if found then
    // put up a courtesy dialog before proceeding
    fRet = PreferControlOverPlugin(pDoc, fileExt, szMimeTypeIn);
#endif

exit:
    if (fileExt)
        FormsFreeString(fileExt);

    return fRet;
}

//////////////////////////////////////////////////////////////////////////
//
//    ClsidFromMime  - Look up a mime type in the registry and find the
//                     activeX control's clsid.
//
//         szMimeType  - IN points at obj mime type, MAY BE NULL.
//         szClassId   - [RETURN] String pointing to the class id.
//   ----------->BEWARE: string contains a leading '{' char as is found
//                       in the registry.  Caller must get rid of it.
//                       We do null out the trailing '}' char. 
//
//       HRESULT        - [RETURN] If we mapped to control.
//
//    Looks up mimetype->clsid

HRESULT ClsidFromMime( TCHAR *szClassId, LPCTSTR szMimeType)
{
    HKEY     hKeyProgId  = NULL;  // registry key for prog id
    LONG     cbData;              // buffer size
    HRESULT  hr;                  // last return from Reg*** function
    DWORD    dwRet;
    TCHAR    pszRegKey[MAX_PATH];   // class id for the object

    Assert( szMimeType );

    hr = Format(0,pszRegKey,MAX_PATH,_T("MIME\\Database\\Content Type\\<0s>"), szMimeType); 
    if (FAILED(hr))
        goto CleanupHR;

    // Open the registry entry for the prog id
    dwRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszRegKey, 0, KEY_READ, &hKeyProgId);
    if (ERROR_SUCCESS != dwRet )
        goto Cleanup;

    cbData = MAX_PATH;
    dwRet = RegQueryValueEx(hKeyProgId, _T("CLSID"), NULL, NULL, (LPBYTE)szClassId, (DWORD*)&cbData);

    // Get rid of the trailing '}'
    if ( ERROR_SUCCESS == dwRet && cbData >= 2 )
        szClassId[cbData - 2] = _T('\0');

  Cleanup:
    hr = HRESULT_FROM_WIN32( dwRet );

  CleanupHR:
    if (hKeyProgId != NULL)
        RegCloseKey(hKeyProgId);

    return( hr );
}
 
//////////////////////////////////////////////////////////////////////////
//
//    IsActiveXControl - only used by EMBED tag.
//
//       szFile      - The file to check to determine if we have a control. MAY BE NULL.
//       szClassId   - [RETURN] String pointing to the class id.
//       fileExt     - IN points at extn in szFile MAY BE NULL.
//       szMimeTypeIn- IN points at obj mime type, MAY BE NULL.
//
//       BOOL        - [RETURN] If we mapped to control.
//
//    Given a source URL or file to look at, we will search to determine
//    if the object is an ActiveX Control.
//
//    Looks up file extension->mimetype->clsid then if that fails
//                  extension->progid->clsid then if that fails
//                  mimetype->clsid
//    We give priority to the file extension mime type mapping over the
//    passed in mime type since this is closer to the original IE3
//    behavior which only used the file extension.
//
BOOL IsActiveXControl(LPCTSTR szFile, TCHAR *szClassId, TCHAR *fileExt, LPCTSTR szMimeTypeIn)
{
   HKEY     hKeyFileExt = NULL;  // opened registry key
   HKEY     hKeyProgId  = NULL;  // registry key for prog id
   HKEY     hKeyClassId = NULL;  // registry key for class id
   LONG     cbData;              // buffer size
   HRESULT  hr;                  // last return from Reg*** function
   HKEY     hKeyControl = NULL;  // registry key for control under clsid
   TCHAR    pszControl[MAX_PATH];   // path to control key
   TCHAR    pszMimeTypeOrProgId[MAX_PATH];  // prog id for the object
   TCHAR    pszClassId[MAX_PATH];   // class id for the object

    *pszMimeTypeOrProgId = _T('\0');

    if (fileExt)
    {
        // Try to open the key HKEY_CLASSES_ROOT\fileExt. to get mime type.
        //    Example HKEY_CLASSES_ROOT\.xls
        hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, fileExt, 0, KEY_READ, &hKeyFileExt);
        if (ERROR_SUCCESS == hr)
        {
            cbData     = MAX_PATH;

            // We found the file extension in the registry... now, we
            // want to get the mime type, if present
            hr = RegQueryValueEx(hKeyFileExt, _T("Content Type"), NULL, NULL, (LPBYTE)pszMimeTypeOrProgId, (DWORD*)&cbData);
            if (ERROR_SUCCESS == hr)
            {
                hr = ClsidFromMime( pszClassId, pszMimeTypeOrProgId );
                if( !hr ) 
                    goto GotCLSID;
            }
        }
    }

    //
    // just fall thru and try the ext->progid->clsid lookup
    //
    cbData = MAX_PATH;   
    // now, try the progid for the object.
    hr = RegQueryValue(hKeyFileExt, NULL, pszMimeTypeOrProgId, &cbData);
    if (ERROR_SUCCESS != hr || cbData <= 0)
        goto TryMime;
   
    // Now that we have the prog id, let's go and get the CLSID.
    pszMimeTypeOrProgId[cbData-1] = _T('\0'); // append the NULL character to our string

    // Open the registry entry for the prog id
    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszMimeTypeOrProgId, 0, KEY_READ, &hKeyProgId);
    if (ERROR_SUCCESS != hr)
        goto TryMime;

    // Check to see if the object has a CLSID key.
    hr = RegOpenKeyEx(hKeyProgId, _T("CLSID"), 0, KEY_READ, &hKeyClassId);
    if (ERROR_SUCCESS != hr)
        goto TryMime;

    cbData = MAX_PATH;
    hr = RegQueryValue(hKeyClassId, NULL, pszClassId, &cbData);
    if (ERROR_SUCCESS != hr || cbData <= 0)
        goto TryMime;

    // In the object tag, the class id can not have the { }. So, we will remove the
    // brackets when we return the value of the class id.
    Format(0, pszControl, MAX_PATH, _T("CLSID\\<0s>\\Control"), pszClassId);
    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszControl, 0, KEY_READ, &hKeyControl);
    if (ERROR_SUCCESS == hr)
    {
        // The classid does refer to a control.  Get rid of the { } brackets in
        // the classid string:
        if( cbData >= 2 )
            pszClassId[cbData-2] = _T('\0');     // add the null to the end of the string where the }
    }
    else
    {
  TryMime:  
        // Try the passed in mime type directly.
        // if we don't have a mime type, then don't try to execute
        // the GotCLSID piece below, since pszClassId never gets set
        if (!szMimeTypeIn)
            goto Cleanup;   // hr is already an error code, so we'll return FALSE.

        hr = ClsidFromMime( pszClassId, szMimeTypeIn );
        if( hr ) 
            goto Cleanup;
    }

  GotCLSID:
    wcscpy(szClassId, _T("clsid:"));    // need to preface with "clsid:"
    wcscat(szClassId, pszClassId+1);  // copy the value to our out param
 
  Cleanup:
    // Close all open reg keys
    if (hKeyFileExt != NULL)
        RegCloseKey(hKeyFileExt);

    if (hKeyProgId != NULL)
        RegCloseKey(hKeyProgId);

    if (hKeyClassId != NULL)
        RegCloseKey(hKeyClassId);

    if (hKeyControl != NULL)
        RegCloseKey(hKeyControl);

    if (hr == ERROR_SUCCESS)
        return (TRUE);
    else
        return (FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
//    GetFileExtension
//
//       szFilename     - [in] string containing the file name
//       szExtension    - [out] the file extension found
//                        WARNING - caller must free memory for szExtension
//
//       int            - [return] the number of characters in file extension
//
//    This function will return the file extension (including the .). And it 
//    will return the number of characters in the file extension.
//
int GetFileExtension(LPCTSTR szFilename, TCHAR **szExtension)
{
   int  count   = 0;          // number of characters in extension
   LPCTSTR szTemp = NULL;       // temp pointer to filename string
   LPCTSTR szEnd = NULL;

   Assert(szFilename);
   Assert(szExtension);

   if (szFilename == NULL || szExtension == NULL)
      return (count);

   // move temp pointer to end
   szTemp = szFilename + wcslen(szFilename);
   szEnd = szTemp;

   while (szTemp != szFilename)
   {
      // This function is essentially duplicated in at least
      // two other components.  The search behavior here is different
      // (RTL as opposed to the typical LTR), but I'm not going
      // to clean this up in a hotfix.
      // Consequently, when a query or bookmark char is found,
      // update it as our new end point for the extension string.
      if ((*szTemp == _T('?')) || (*szTemp == _T('#')))
      {
          szEnd = szTemp;
      }

      // when we have a period, we found the extension
      else if (*szTemp == _T('.'))
      {
        HRESULT hr = FormsAllocStringLen( szTemp, szEnd-szTemp, szExtension );
        if( FAILED( hr ) )
            count = 0;
        return (count);
      }
      --szTemp;
      ++count;
   }
   return (0);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CPluginSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    switch (dispid)
    {
        case DISPID_CPluginSite_hidden:
        {
            _fHidden = GetAAhidden();
            break;
        }
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\scrptlet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scriptlet.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptlet implementation
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVENTOBJ_H_
#define X_EVENTOBJ_H_
#include "eventobj.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

extern class CBaseLockCF g_cfDoc;

#define _cxx_
#include "scrptlet.hdl"

MtDefine(Scriptlet, Mem, "Scriptlet")
MtDefine(CScriptlet, Scriptlet, "CScriptlet")
MtDefine(CScriptlet_aryDR_pv, CScriptlet, "CScriptlet::_aryDR::_pv")
MtDefine(CSortedAtomTable, Scriptlet, "CSortedAtomTable")
MtDefine(CSortedAtomTable_pv, CSortedAtomTable, "CSortedAtomTable::_pv")
MtDefine(CSortedAtomTable_aryIndex_pv, CSortedAtomTable, "CSortedAtomTable::_aryIndex::_pv")

BEGIN_TEAROFF_TABLE(CScriptlet, IOleObject)
    TEAROFF_METHOD(CScriptlet, SetClientSite, setclientsite, (LPOLECLIENTSITE pClientSite))
    TEAROFF_METHOD(CScriptlet, GetClientSite, getclientsite, (LPOLECLIENTSITE FAR* ppClientSite))
    TEAROFF_METHOD(CScriptlet, SetHostNames, sethostnames, (LPCTSTR szContainerApp, LPCTSTR szContainerObj))
    TEAROFF_METHOD(CScriptlet, Close, close, (DWORD dwSaveOption))
    TEAROFF_METHOD(CScriptlet, SetMoniker, setmoniker, (DWORD dwWhichMoniker, LPMONIKER pmk))
    TEAROFF_METHOD(CScriptlet, GetMoniker, getmoniker, (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk))
    TEAROFF_METHOD(CScriptlet, InitFromData, initfromdata, (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved))
    TEAROFF_METHOD(CScriptlet, GetClipboardData, getclipboarddata, (DWORD dwReserved, LPDATAOBJECT * ppDataObject))
    TEAROFF_METHOD(CScriptlet, DoVerb, doverb, (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCOLERECT lprcPosRect))
    TEAROFF_METHOD(CScriptlet, EnumVerbs, enumverbs, (LPENUMOLEVERB FAR* ppenumOleVerb))
    TEAROFF_METHOD(CScriptlet, Update, update, ())
    TEAROFF_METHOD(CScriptlet, IsUpToDate, isuptodate, ())
    TEAROFF_METHOD(CScriptlet, GetUserClassID, getuserclassid, (CLSID FAR* pClsid))
    TEAROFF_METHOD(CScriptlet, GetUserType, getusertype, (DWORD dwFormOfType, LPTSTR FAR* pszUserType))
    TEAROFF_METHOD(CScriptlet, SetExtent, setextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CScriptlet, GetExtent, getextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CScriptlet, Advise, advise, (IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CScriptlet, Unadvise, unadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CScriptlet, EnumAdvise, enumadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
    TEAROFF_METHOD(CScriptlet, GetMiscStatus, getmiscstatus, (DWORD dwAspect, DWORD FAR* pdwStatus))
    TEAROFF_METHOD(CScriptlet, SetColorScheme, setcolorscheme, (LPLOGPALETTE lpLogpal))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IOleControl)
    TEAROFF_METHOD(CScriptlet, GetControlInfo, getcontrolinfo, (CONTROLINFO * pCI))
    TEAROFF_METHOD(CScriptlet, OnMnemonic, onmnemonic, (LPMSG pMsg))
    TEAROFF_METHOD(CScriptlet, OnAmbientPropertyChange, onambientpropertychange, (DISPID dispid))
    TEAROFF_METHOD(CScriptlet, FreezeEvents, freezeevents, (BOOL fFreeze))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IOleInPlaceObject)
    TEAROFF_METHOD(CScriptlet, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CScriptlet, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CScriptlet, InPlaceDeactivate, inplacedeactivate, ())
    TEAROFF_METHOD(CScriptlet, UIDeactivate, uideactivate, ())
    TEAROFF_METHOD(CScriptlet, SetObjectRects, setobjectrects, (LPCRECT prcPos, LPCRECT prcClip))
    TEAROFF_METHOD(CScriptlet, ReactivateAndUndo, reactivateandundo, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IPersistPropertyBag)
    TEAROFF_METHOD(CScriptlet, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CScriptlet, InitNew, initnew, ())
    TEAROFF_METHOD(CScriptlet, Load, LOAD, (LPPROPERTYBAG pBag, LPERRORLOG pErrLog))
    TEAROFF_METHOD(CScriptlet, Save, SAVE, (LPPROPERTYBAG pBag, BOOL fClearDirty, BOOL fSaveAllProperties))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IPersistStreamInit)
    TEAROFF_METHOD(CScriptlet, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CScriptlet, IsDirty, isdirty, ())
    TEAROFF_METHOD(CScriptlet, Load, LOAD, (LPSTREAM pStm))
    TEAROFF_METHOD(CScriptlet, Save, SAVE, (LPSTREAM pStm, BOOL fClearDirty))
    TEAROFF_METHOD(CScriptlet, GetSizeMax, GETSIZEMAX, (ULARGE_INTEGER FAR * pcbSize))
    TEAROFF_METHOD(CScriptlet, InitNew, initnew, ())
END_TEAROFF_TABLE()

/////////////////////////////////////////////////////////////////////////////
// CScriptlet

const CONNECTION_POINT_INFO CScriptlet::s_acpi[] =
{
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY(DIID_DWebBridgeEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CScriptlet::s_classdesc =
{
    &CLSID_Scriptlet,               // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IWebBridge,                // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     CreateScriptlet
//
//  Synopsis:   Creates a new scriptlet doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//-------------------------------------------------------------------------

CBase * STDMETHODCALLTYPE
CreateScriptlet(IUnknown *pUnkOuter)
{
    CBase *pBase;
    pBase = new CScriptlet(pUnkOuter);
    return(pBase);
}

CScriptlet::CScriptlet(IUnknown *pUnkOuter)
    : _aryDR(Mt(CScriptlet_aryDR_pv))
{
    _pUnkOuter  = pUnkOuter ? pUnkOuter : PunkInner();
    VariantInit(&_varOnVisChange);
    _dispidCur = DISPID_VECTOR_BASE;
}

CScriptlet::~CScriptlet()
{
    _cstrUrl.Free();
    VariantClear(&_varOnVisChange);
    _aryDR.DeleteAll();
    _aryDispid.Free();
}

void CScriptlet::Passivate()
{
    ReleaseInterface(_pScriptCtrl);
    ReleaseInterface(_pDescription);

    super::Passivate();

    // (sramani) Trident will rel its propnotify sink when its attr array is destroyed in the destructor thus
    // subrel'ing us, causing the scriptlet to be destroyed.
    // This will also rel the doc host handler associated with this scriptlet!
    ReleaseInterface(_pTrident); 
}

HRESULT
CScriptlet::Init()
{
    HRESULT hr;

    // Create And Aggregate Trident
    hr = THR(g_cfDoc.CreateInstance(_pUnkOuter, IID_IUnknown, (void**)&_pTrident));
    if (hr)
        goto Cleanup;

    hr = _pTrident->QueryInterface(CLSID_HTMLDocument, (void **)&_pDoc);
    if (hr)
        goto Cleanup;

    _pDoc->_fScriptletDoc = TRUE;

    hr = E_OUTOFMEMORY;

    _pScriptCtrl = new CScriptControl(this);
    if (!_pScriptCtrl)
        goto Cleanup;

    // (sramani) The doc holds a ref on to the doc host handler at SetDocHostUI time. This causes a subaddref on us,
    // the corresponding subrelease happening when the doc is destroyed. 
    _pDoc->SetUIHandler((IDocHostUIHandler *)&_ScriptletSubObjects);
    
    hr = ConnectSink(_pTrident, IID_IPropertyNotifySink, (IPropertyNotifySink *)&_ScriptletSubObjects, NULL);
    if (hr)
        goto Cleanup;
    // (sramani) Note:Trident now holds a subAddref on the scriptlet. This will be released when Trident destroys its attr
    // array on the passivate call of the scriptlet.

Cleanup:
    if (hr)
    {
        _pDoc->SetUIHandler(NULL);
        ReleaseInterface(_pScriptCtrl);
        ReleaseInterface(_pTrident);
    }
    return hr;
}

// IOleObject

HRESULT CScriptlet::SetClientSite(IOleClientSite *pClientSite)
{ 
    // (sramani) No need to addref this as the COleSite's clientsite will always outlive the 
    // scriptlet that it contains. This is so because the outer doc's olesite will hold on to the scriptlet.
    _pOCS = pClientSite;

    if (pClientSite)
    {
        CWindow *pWindow;
        HRESULT hr;

        hr = pClientSite->QueryInterface(CLSID_HTMLWindow2, (void **)&pWindow);
        if (!hr)
        {
            Assert(_pDoc->_pWindowPrimary);
            Assert(_pDoc->_pWindowPrimary->Window());
            Assert(!_pDoc->_pWindowPrimary->Window()->_pWindowParent);
            _pDoc->_pWindowPrimary->Window()->_pWindowParent = pWindow;
            _pDoc->_pWindowPrimary->Window()->_pWindowParent->SubAddRef();
        }
    }

    return _pDoc->SetClientSite(pClientSite);
}

HRESULT CScriptlet::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    BOOL fExtentSet = FALSE;

    // (sramani) Need to SetExtent as some container's like VB don't do so b4 inplace activating us.
    if (!_fExtentSet && (iVerb == OLEIVERB_INPLACEACTIVATE))
    {
        SIZEL sizel;
        GetExtent(DVASPECT_CONTENT, &sizel);
        fExtentSet = TRUE;
    }

    HRESULT hr = _pDoc->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
    
    if (iVerb == OLEIVERB_INPLACEACTIVATE)
    {
        SIZEL sizeHiMetric;

        // NOTE(sramani): This will break VB as this is the only time this will be
        // called with an lprcPosRect, but we don't care, at least you will have the 
        // default size.
        if (!fExtentSet)
        {
            _sizePixExtent.cx = lprcPosRect->right - lprcPosRect->left;
            _sizePixExtent.cy = lprcPosRect->bottom - lprcPosRect->top;
            _fValidCx = _fValidCy = TRUE;
        }

        sizeHiMetric.cx = HimetricFromHPix(_sizePixExtent.cx);
        sizeHiMetric.cy = HimetricFromVPix(_sizePixExtent.cy);
        hr = SetExtent(DVASPECT_CONTENT, &sizeHiMetric);
        OnVisibilityChange();
    }
    return hr;
}

HRESULT CScriptlet::GetUserClassID(CLSID *pClsid)
{
    *pClsid = *BaseDesc()->_pclsid;
    return S_OK;
}

HRESULT CScriptlet::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return OleRegGetUserType(*BaseDesc()->_pclsid, dwFormOfType, pszUserType);
}

HRESULT CScriptlet::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT     hr;
    IHTMLStyle *pStyle = NULL;

    _sizePixExtent.cx = HPixFromHimetric(psizel->cx);
    _sizePixExtent.cy = VPixFromHimetric(psizel->cy);
    _fValidCx = _fValidCy = TRUE;
    _fExtentSet = TRUE;

    hr = _pDoc->SetExtent(dwDrawAspect, psizel);
    if (hr)
	    goto Cleanup;

    hr = GetStyleProperty(&pStyle);
    if (hr)
        goto Cleanup;

    if (pStyle)
    {
        pStyle->put_pixelWidth(_sizePixExtent.cx);
        pStyle->put_pixelHeight(_sizePixExtent.cy);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

HRESULT CScriptlet::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    if (!_fValidCx)
    {
        _sizePixExtent.cx = WEBBRIDGE_DEFAULT_WIDTH;
        _fValidCx = TRUE;
    }

    if (!_fValidCy)
    {
        _sizePixExtent.cy = WEBBRIDGE_DEFAULT_HEIGHT;
        _fValidCy = TRUE;
    }

    psizel->cx = HimetricFromHPix(_sizePixExtent.cx);
    psizel->cy = HimetricFromVPix(_sizePixExtent.cy);

    // (sramani) Need to SetExtent as some container's like VB don't do so b4 inplace activating us.
    if (!_fExtentSet)
    {
        _fExtentSet = TRUE;
        _pDoc->SetExtent(DVASPECT_CONTENT, psizel);
    }

    return S_OK;
}

// IOleControl

HRESULT CScriptlet::FreezeEvents(BOOL fFreeze)
{
    if (fFreeze)
        ++_cFreezes;
    else
        --_cFreezes;

    Assert(_cFreezes >= 0);
    if (!_cFreezes && _fDelayOnReadyStateFiring)
    {
        FireEvent(_pDoc, NULL, _pDoc->_pWindowPrimary->Markup(), DISPID_READYSTATECHANGE, DISPID_UNKNOWN, _T("readystatechange"));
        _fDelayOnReadyStateFiring = FALSE;
    }

    return _pDoc->FreezeEvents(fFreeze);
}

// IOleInPlaceObject

HRESULT CScriptlet::InPlaceDeactivate()
{
    HRESULT hr;
    hr = _pDoc->InPlaceDeactivate();
    OnVisibilityChange();
    return hr;
}

HRESULT CScriptlet::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    HRESULT hr;
    hr = _pDoc->SetObjectRects(prcPos, prcClip);
    OnVisibilityChange();
    return hr;
}

// Scriptlet helpers

HRESULT
CScriptlet::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, _pUnkOuter)
        QI_TEAROFF(this, IWebBridge, _pUnkOuter)
        QI_TEAROFF(this, IOleObject, _pUnkOuter)
        QI_TEAROFF(this, IOleControl, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceObject, _pUnkOuter)
        QI_TEAROFF(this, IPersistStreamInit, _pUnkOuter)
        QI_TEAROFF(this, IPersistPropertyBag, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo2, IProvideMultipleClassInfo, _pUnkOuter)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(this, NULL);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }

        QI_FALLTHRU(IPersistMoniker, IHTMLDocument)
        QI_FALLTHRU(IViewObject, IHTMLDocument)
        QI_FALLTHRU(IViewObjectEx, IHTMLDocument)
        QI_FALLTHRU(IViewObject2, IHTMLDocument)
        QI_FALLTHRU(IOleInPlaceActiveObject, IHTMLDocument)
        QI_FALLTHRU(IOleInPlaceObjectWindowless, IHTMLDocument)
        QI_FALLTHRU(IOleWindow, IHTMLDocument)
        QI_FALLTHRU(IQuickActivate, IHTMLDocument)
        QI_FALLTHRU(IOleCommandTarget, IHTMLDocument)
        QI_FALLTHRU(IObjectSafety, IHTMLDocument)
        QI_FALLTHRU(IOleContainer, IHTMLDocument)
        QI_FALLTHRU(IDataObject, IHTMLDocument)
        QI_CASE(IHTMLDocument)
            // (sramani): This is equivalent to calling _pTrident->QI, but faster!
            RRETURN(_pDoc->PrivateQueryInterface(iid, ppv));

    default:
        return E_NOINTERFACE;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

// IDispatchEx over-rides

STDMETHODIMP 
CScriptlet::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT                 hr;
    long                    lIndex;
    DispidRecord            dr;
    BSTR                    bstrCopy = NULL;
    CStr                    cstrName;

    // Check to see if the Names are implemented directly by the Scriptlet. If so, intercept them
    // immediately.

    hr = CBase::GetInternalDispID(bstrName, pid, grfdex);
    if (!hr)
        goto Cleanup;

    // Assume failure.
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;

    if (_pDoc->PrimaryMarkup()->GetReadyState() < READYSTATE_COMPLETE || !bstrName)
        goto Cleanup;

    if (!StrCmpNIC(_T("get_"), bstrName, 4) ||
        !StrCmpNIC(_T("put_"), bstrName, 4) ||
        !StrCmpNIC(_T("event_"), bstrName, 6))    // NOTE (sramani) : why shud this last check be there?
        goto Cleanup;

    // See if we've found this particular name before. 
    if (_aryDispid.Find(bstrName, pid, !!(grfdex & fdexNameCaseSensitive)))
    {
        *pid += DISPID_VECTOR_BASE;
        hr = S_OK;
        goto Cleanup;
    }

    // If these are NULL, there is no public_description object,
    // so we need to look for public_ prefixes.
    if (!_pDescription)
    {
        hr = cstrName.Set(_T("public_get_"));
        if (hr)
            goto Cleanup;
        hr = cstrName.Append(bstrName);
        if (hr)
            goto Cleanup;
        hr = cstrName.AllocBSTR(&bstrCopy);
        if (hr)
            goto Cleanup;

        hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispid_get);
        if (hr)
            dr.dispid_get = DISPID_UNKNOWN;

        bstrCopy[7] = _T('p');
        bstrCopy[8] = _T('u');
        hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispid_put);
        if (hr)
            dr.dispid_put = DISPID_UNKNOWN;

        // If neither a get or put method exists for this name, look for a bare name

        if (dr.dispid_get == DISPID_UNKNOWN &&
            dr.dispid_put == DISPID_UNKNOWN)
        {
            hr = cstrName.Set(_T("public_"));
            if (hr)
                goto Cleanup;
            hr = cstrName.Append(bstrName);
            if (hr)
                goto Cleanup;
            FormsFreeString(bstrCopy);
            hr = cstrName.AllocBSTR(&bstrCopy);
            if (hr)
                goto Cleanup;

            hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispidBare);
            if (hr)
                goto Cleanup;
        }
        else
            dr.dispidBare = DISPID_UNKNOWN;
    }
    else
    {
        hr = cstrName.Set(_T("get_"));
        if (hr)
            goto Cleanup;
        hr = cstrName.Append(bstrName);
        if (hr)
            goto Cleanup;
        hr = cstrName.AllocBSTR(&bstrCopy);
        if (hr)
            goto Cleanup;

        Assert(_pDescription);
        hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrCopy, 1, LOCALE_USER_DEFAULT, &dr.dispid_get);
        if (hr)
            dr.dispid_get = DISPID_UNKNOWN;

        bstrCopy[0] = _T('p');
        bstrCopy[1] = _T('u');

        hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrCopy, 1, LOCALE_USER_DEFAULT, &dr.dispid_put);
        if (hr)
            dr.dispid_put = DISPID_UNKNOWN;

        // If neither a get or put method exists for this name, look for a bare name

        if (dr.dispid_get == DISPID_UNKNOWN &&
            dr.dispid_put == DISPID_UNKNOWN)
        {
            hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, &dr.dispidBare);
            if (hr)
                goto Cleanup;
        }
        else
            dr.dispidBare = DISPID_UNKNOWN;
    }

    // Otherwise, we got a keeper! 
    hr = _aryDR.AppendIndirect(&dr);
    if (hr)
        goto Cleanup;

    hr = _aryDispid.Insert(bstrName, *pid, &lIndex);
    if (hr)
    {
        _aryDR.Delete(_aryDR.Size() - 1);
        goto Cleanup;
    }

    Assert(lIndex == _aryDR.Size() - 1);

    _dispidCur = lIndex + DISPID_VECTOR_BASE + 1;
    Assert(_dispidCur < 0x7FFFFFF);
    *pid = lIndex + DISPID_VECTOR_BASE;

Cleanup:
    cstrName.Free();
    FormsFreeString(bstrCopy);
    return hr;
}

STDMETHODIMP
CScriptlet::InvokeEx(DISPID dispid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT         hr;
    DispidRecord *  pDR;
    DISPPARAMS      dispparams;

    // (sramani) CScriptlet's own DISPIDs have first priority.

    if ((0 <= dispid && dispid < DISPID_VECTOR_BASE) ||
        dispid == DISPID_ABOUTBOX ||
        dispid == DISPID_IHTMLWINDOW2_EVENT)
    {
        return CBase::InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);
    }

    if (PassThruDISPID(dispid))
        return _pDoc->_pWindowPrimary->Document()->InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    if (dispid < 0)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (dispid < _dispidCur)
    {
        pDR = _aryDR + (dispid - DISPID_VECTOR_BASE);

        // Check how they want to call this thing.

        if (wFlags & DISPATCH_PROPERTYGET)
        {
            // try function property get 
            Assert((wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) == 0);
            dispid = pDR->dispid_get;
            if (dispid == DISPID_UNKNOWN)
                dispid = pDR->dispidBare;               // could be member property get
            else
                wFlags = DISPATCH_METHOD;               // calling a get_XXX method.
        }
        else if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
        {
            // try function property put 
            dispid = pDR->dispid_put;
            if (dispid == DISPID_UNKNOWN)
                dispid = pDR->dispidBare;               // could be member property put
            else
            {
                wFlags = DISPATCH_METHOD;               // calling a put_XXX method.
                // (sramani) Nuke the named parameters!. This is reqd. as the original call
                // came in as a propput and the script engine passes a named param for it. but
                // the actual invoke is really a method call. The script engine will fail the
                // invoke if we dont do this as it will be unable to find a named param for
                // public_put_foo, as it thinks it really belongs to foo (which is how it was
                // called from script)
                dispparams = *pdispparams;
                dispparams.cNamedArgs = 0;
                pdispparams = &dispparams;
            }
        }
        else
        {
            // try method call
            dispid = pDR->dispidBare;
        }

        if (dispid == DISPID_UNKNOWN)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
         
        if (_pDescription)
        {
            hr = _pDescription->Invoke(dispid,  IID_NULL,  lcid,  wFlags,  pdispparams,  pvarResult,  pexcepinfo,  NULL);
        }
        else
        {
            hr = _pDoc->_pWindowPrimary->InvokeEx(dispid,  lcid,  wFlags,  pdispparams,  pvarResult,  pexcepinfo,  pSrvProvider);
        }
    }
    else
        hr = DISP_E_MEMBERNOTFOUND;

Cleanup:
    return hr;
}

BOOL
CScriptlet::PassThruDISPID(DISPID dispid)
{
    switch (dispid)
    {
        case    DISPID_SECURITYDOMAIN:
        case    DISPID_SECURITYCTX:
        case    DISPID_READYSTATE:
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL
CScriptlet::InDesignMode()
{
    HRESULT    hr;
    VARIANT    var;
    IDispatch *pDispOCS = NULL;

    if (!_pOCS)
        return FALSE;

    hr = _pOCS->QueryInterface(IID_IDispatch, (void **)&pDispOCS);
    if (hr)
        return FALSE;

    hr = Property_get(pDispOCS, DISPID_AMBIENT_USERMODE, &var);

    ReleaseInterface(pDispOCS);
    return (hr == S_OK && var.vt == VT_BOOL && var.boolVal == VARIANT_FALSE);
}


// IWebBridge properties and methods //////////////////////////////////

STDMETHODIMP CScriptlet::get_URL(BSTR * pVal)
{
    return FormsAllocString(_pDoc->GetPrimaryUrl(), pVal);
}

STDMETHODIMP CScriptlet::put_URL(BSTR newVal)
{
    HRESULT hr;

    // We only expose this as a write property at design time.
    if (!InDesignMode() || _fHardWiredURL)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    _fRequiresSave = 1;
    hr = LoadScriptletURL(newVal);

Cleanup:
    return hr;
}

STDMETHODIMP
CScriptlet::get_Scrollbar(VARIANT_BOOL *pfShow)
{
    *pfShow = _vbScrollbar;
    return S_OK;
}

STDMETHODIMP
CScriptlet::put_Scrollbar(VARIANT_BOOL fShow)
{
    _vbScrollbar = fShow ? VARIANT_TRUE : VARIANT_FALSE;
    return _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
}

STDMETHODIMP
CScriptlet::get_embed(VARIANT_BOOL * pfEmbedded)
{
    // 'embed' is a design-time only property.
    if (!InDesignMode())
        return DISP_E_MEMBERNOTFOUND;

    *pfEmbedded = _vbEmbedded;
    return S_OK;
}

STDMETHODIMP
CScriptlet::put_embed(VARIANT_BOOL fEmbed)
{
    if (!InDesignMode())
        return DISP_E_MEMBERNOTFOUND;

    _vbEmbedded = fEmbed ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP
CScriptlet::get_readyState(long * pReadyState)
{
    *pReadyState = _pDoc->PrimaryMarkup()->GetReadyState();
    return S_OK;
}

STDMETHODIMP
CScriptlet::get_event(IDispatch **ppEvent)
{
    HRESULT          hr = S_OK;
    IHTMLWindow2    *pHW = NULL;
    IHTMLEventObj   *pEO = NULL;

    *ppEvent = NULL;

    pHW = _pDoc->_pWindowPrimary;
    pHW->AddRef();
    if (hr)
        goto Cleanup;

    hr = pHW->get_event(&pEO);
    if (hr)
        goto Cleanup;

    if (pEO)
    {
        *ppEvent = pEO;
        (*ppEvent)->AddRef();
    }

Cleanup:
    ReleaseInterface(pHW);
    ReleaseInterface(pEO);
    return hr;
}

STDMETHODIMP
CScriptlet::AboutBox()
{
    HRESULT hr;
    HWND    hwnd;
    RECT    rcPos;
    RECT    rcClip;
    OLEINPLACEFRAMEINFO oipfi;
    IOleInPlaceSite *pOIPS = NULL;
    IOleInPlaceFrame *pFrame = NULL;
    IOleInPlaceUIWindow *pDoc = NULL;

    // We only expose this as a method at design time.
    if (!InDesignMode())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = _pOCS->QueryInterface(IID_IOleInPlaceSite, (void **) &pOIPS);
    if (hr)
        goto Cleanup;

    hr = pOIPS->GetWindowContext(&pFrame, &pDoc, &rcPos, &rcClip, &oipfi);
    if (hr)
        goto Cleanup;

    hr = pFrame->GetWindow(&hwnd);
    if (hr)
        goto Cleanup;
    
    pFrame->EnableModeless(FALSE);
    MessageBoxA(hwnd, "Copyright (C) 1997 Microsoft\r\nhttp://www.microsoft.com", "Scriptlet Component", MB_OK);
    pFrame->EnableModeless(TRUE);

Cleanup:
    ReleaseInterface(pOIPS);
    ReleaseInterface(pFrame);
    ReleaseInterface(pDoc);
    return hr;
}

HRESULT CScriptlet::LoadScriptletURL(TCHAR *pchUrl)
{
    CStr cstrBlank;
    CWindow *pCWindow = NULL;

    if (_fHardWiredURL && !pchUrl)
        pchUrl = _cstrUrl;
        
    if (!pchUrl || !_pOCS)
        return E_POINTER;

    if (!*pchUrl || UnescapeAndTruncateUrl(pchUrl) != S_OK)
    {
        cstrBlank.Set(_T("about:blank"));
        pchUrl = cstrBlank;
    }

    // Do a local machine access check.  Can't do much if there is no window
    // parent.  For IE, there should always be one.
    pCWindow = _pDoc->_pWindowPrimary->Window()->_pWindowParent;
    if (pCWindow)
    {
        if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pCWindow->Markup(), NULL, pchUrl))
        {
            cstrBlank.Set(_T("about:blank"));
            pchUrl = cstrBlank;
        }
    }
    else
    {
        // The site doesn't have a window.
        Assert(_pOCS->QueryInterface(CLSID_HTMLWindow2, (void **)&pCWindow));
    }

    HRESULT hr;
    IMoniker           *pMoniker = NULL;
    IServiceProvider   *pSP = NULL;
    IBindHost          *pBH = NULL;

    // Try getting the IBindHost service first.

    hr = _pOCS->QueryInterface(IID_IServiceProvider, (void **)&pSP);
    if (!hr)
    {
        hr = pSP->QueryService(SID_IBindHost, IID_IBindHost, (void **)&pBH);
        if (!hr)
        {
            hr = pBH->CreateMoniker(pchUrl, NULL, &pMoniker, 0);
        }
    }

    // If we failed to create the moniker that way, make  an absolute moniker.

    if (!pMoniker)
    {
        hr = CreateURLMoniker(NULL, pchUrl, &pMoniker);
    }

    if (!hr)
    {
        hr = _pDoc->Load(FALSE, pMoniker, NULL, 0);
    }

    ReleaseInterface(pMoniker);
    ReleaseInterface(pBH);
    ReleaseInterface(pSP);
    return hr;
}

HRESULT CScriptlet::GetStyleProperty(IHTMLStyle **ppHTMLStyle)
{
    HRESULT                 hr;
    VARIANT                 varArg1;
    VARIANT                 varArg2;
    IHTMLElementCollection *pHEC = NULL;
    IHTMLElementCollection *pHEC2 = NULL;
    IDispatch              *pDispHtmlElement = NULL;
    IDispatch              *pDispCollection = NULL;

    *ppHTMLStyle = NULL;
    
    {
        hr = _pDoc->_pWindowPrimary->Document()->get_all(&pHEC);
        if (hr)
            goto Cleanup;

        varArg1.vt = VT_BSTR;
        hr = FormsAllocString(_T("HTML"), &varArg1.bstrVal);
        if (hr)
            goto Cleanup;

        hr = pHEC->tags(varArg1, &pDispCollection);
        if (hr)
            goto Cleanup;

        hr = pDispCollection->QueryInterface(IID_IHTMLElementCollection, (void **)&pHEC2);
        if (hr)
            goto Cleanup;

        VariantClear(&varArg1);
        varArg1.vt = VT_I4;
        varArg1.lVal = 0;
        varArg2.vt = VT_ERROR;
        hr = pHEC2->item(varArg1, varArg2, &pDispHtmlElement);
        if (hr)
            goto Cleanup;

        if (pDispHtmlElement)
        {
            hr = pDispHtmlElement->QueryInterface(IID_IHTMLElement, (void **)&_pHTMLElement);
            if (hr)
                goto Cleanup;
        }
        else
            goto Cleanup;
    }

    Assert(_pHTMLElement);
    hr = _pHTMLElement->get_style(ppHTMLStyle);

    ClearInterface(&_pHTMLElement);

Cleanup:
    ReleaseInterface(pHEC);
    ReleaseInterface(pHEC2);
    ReleaseInterface(pDispHtmlElement);
    ReleaseInterface(pDispCollection);
    return hr;
}

HRESULT CScriptlet::Resize()
{
    HRESULT                 hr = E_FAIL;
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     oipfi;
    IOleInPlaceSite        *pOIPS = NULL;
    IOleInPlaceFrame       *pOIPF = NULL;
    IOleInPlaceUIWindow    *pOIPUIW = NULL;

    if (!_pOCS)
        goto Cleanup;

    if (_pDoc->State() >= OS_INPLACE)
    {
        hr = _pOCS->QueryInterface(IID_IOleInPlaceSite, (void **)&pOIPS);
        if (hr)
            goto Cleanup;

        hr = pOIPS->GetWindowContext(&pOIPF, &pOIPUIW, &rcPos, &rcClip, &oipfi);
        if (hr)
            goto Cleanup;

        rcPos.right = rcPos.left + _sizePixExtent.cx;
        rcPos.bottom = rcPos.top + _sizePixExtent.cy;

        hr = pOIPS->OnPosRectChange(&rcPos);
    }
    else
        hr = _pOCS->RequestNewObjectLayout();

Cleanup:
    ReleaseInterface(pOIPS);
    ReleaseInterface(pOIPF);
    ReleaseInterface(pOIPUIW);
    return hr;
}

void CScriptlet::OnReadyStateChange()
{
    HRESULT hr;
    BSTR bstrName = NULL;
    IHTMLStyle *pStyle = NULL;

    if (_pDoc->PrimaryMarkup()->GetReadyState() == READYSTATE_COMPLETE)
    {
        // Discover if script name space contains the "public_description" object.
        DISPID dispidED;
        VARIANT v;

        if (THR(FormsAllocString(EXTERNAL_DESCRIPTION, &bstrName)))
            goto Cleanup;

        hr = THR(_pDoc->_pWindowPrimary->GetDispID(bstrName, fdexFromGetIdsOfNames, &dispidED));
        if (!hr)
        {
            Assert(dispidED != DISPID_UNKNOWN);
            DISPPARAMS dispparams = { NULL, NULL, 0, 0 };

            hr = _pDoc->_pWindowPrimary->InvokeEx(dispidED, LOCALE_USER_DEFAULT,
                              DISPATCH_METHOD|DISPATCH_PROPERTYGET, &dispparams, &v, NULL, NULL);
            if (!hr && v.vt == VT_DISPATCH)
            {
                _pDescription = v.pdispVal;
            }
        }
    }
    else if (_pDoc->PrimaryMarkup()->GetReadyState() == READYSTATE_INTERACTIVE)
    {
        // Need to recache the HTML element if doc gets blown away;
        ClearInterface(&_pHTMLElement);
        if (_fValidCx || _fValidCy)
        {
            hr = THR(GetStyleProperty(&pStyle));
            if (hr)
                goto Cleanup;
            if (!pStyle)
                goto Cleanup;
            if (_fValidCx)
                pStyle->put_pixelWidth(_sizePixExtent.cx);
            if (_fValidCy)
                pStyle->put_pixelHeight(_sizePixExtent.cy);
        }
    }

Cleanup:
    ReleaseInterface(pStyle);
    FormsFreeString(bstrName);

    // Fire the event on the ole site (<OBJECT>) and whoever else might be listening, if the
    // container is ready to handle events
    if (!_cFreezes)
        FireEvent(_pDoc, NULL, _pDoc->_pWindowPrimary->Markup(), DISPID_READYSTATECHANGE, DISPID_UNKNOWN, _T("readystatechange"));
    else
        _fDelayOnReadyStateFiring = TRUE;

    return;
}

void CScriptlet::SetWidth(DISPID dispid)
{
    long cpixels;
    IHTMLStyle *pStyle = NULL;

    if (GetStyleProperty(&pStyle))
        goto Cleanup;
    if (!pStyle)
        goto Cleanup;
    if (!pStyle->get_pixelWidth(&cpixels))
    {
        if (!_fValidCx || cpixels != _sizePixExtent.cx)
        {
            // HACK to avoid infinite scale factor error, if current size is 0
            if (_fValidCx && !_sizePixExtent.cx)
            {
                SIZEL sizel;
                if (!_sizePixExtent.cy)
                    _sizePixExtent.cy = 1;
                sizel.cx = HimetricFromHPix(cpixels);
                sizel.cy = HimetricFromVPix(_sizePixExtent.cy);
                _pDoc->SetExtent(DVASPECT_CONTENT, &sizel);
            }

            _sizePixExtent.cx = cpixels;
            _fValidCx = TRUE;
            Resize();
        }

        FireOnChanged(dispid);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return;
}

void CScriptlet::SetHeight(DISPID dispid)
{
    long cpixels;
    IHTMLStyle *pStyle = NULL;
    
    if (GetStyleProperty(&pStyle))
        goto Cleanup;
    if (!pStyle)
        goto Cleanup;
    if (!pStyle->get_pixelHeight(&cpixels))
    {
        if (!_fValidCy || cpixels != _sizePixExtent.cy)
        {
            // HACK to avoid infinite scale factor error, if current size is 0
            if (_fValidCy && !_sizePixExtent.cy)
            {
                SIZEL sizel;
                if (!_sizePixExtent.cx)
                    _sizePixExtent.cx = 1;
                sizel.cx = HimetricFromHPix(_sizePixExtent.cx);
                sizel.cy = HimetricFromVPix(cpixels);
                _pDoc->SetExtent(DVASPECT_CONTENT, &sizel);
            }

            _sizePixExtent.cy = cpixels;
            _fValidCy = TRUE;
            Resize();
        }

        FireOnChanged(dispid);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return;
}

void CScriptlet::OnVisibilityChange()
{
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     oipfi;
    IOleInPlaceSite        *pOIPS = NULL;
    IOleInPlaceFrame       *pOIPF = NULL;
    IOleInPlaceUIWindow    *pOIPUIW = NULL;
    IDispatchEx            *pDispEx = NULL;
    BOOL                    fNewVisible = _fIsVisible;
    HRESULT                 hr;
    
    if (_pDoc->State() < OS_INPLACE)
    {
        fNewVisible = FALSE;
        // NOTE: (anandra) Not quite correct.  Will do the right thing
        // in design mode in trident/vb because it's not inplace-active
        // but not quite correct because it might be visible. IE4 bug 59988.
    }
    else if (_pOCS)
    {
        hr = _pOCS->QueryInterface(
                IID_IOleInPlaceSite, 
                (void **) &pOIPS);
        if (hr)
            goto Cleanup;
            
        hr = pOIPS->GetWindowContext(
                &pOIPF,
                &pOIPUIW,
                &rcPos,
                &rcClip,
                &oipfi);
        if (hr)
            goto Cleanup;

        fNewVisible = IntersectRect(&rcPos, &rcPos, &rcClip) != 0;
    }

Cleanup:
    if ((unsigned)fNewVisible != _fIsVisible)
    {
        _fIsVisible = (unsigned)fNewVisible;
        
        if (V_VT(&_varOnVisChange) == VT_DISPATCH)
        {
            DISPPARAMS  dp = { 0 };

            if (SUCCEEDED(V_DISPATCH(&_varOnVisChange)->QueryInterface(
                    IID_IDispatchEx, (void **)&pDispEx)))
            {
                hr = pDispEx->InvokeEx(
                        DISPID_VALUE,
                        LOCALE_USER_DEFAULT,
                        DISPATCH_METHOD,
                        &dp,
                        NULL,
                        NULL,
                        NULL);
            }
            else
            {
                hr = V_DISPATCH(&_varOnVisChange)->Invoke(
                    DISPID_VALUE, 
                    IID_NULL,  
                    LOCALE_USER_DEFAULT,
                    DISPATCH_METHOD,  
                    &dp,  
                    NULL,  
                    NULL,  
                    NULL);
            }
        }
    }

    ReleaseInterface(pOIPS);
    ReleaseInterface(pOIPF);
    ReleaseInterface(pOIPUIW);
    ReleaseInterface(pDispEx);
}

HRESULT
Property_get(IDispatch * pDisp, DISPID dispid, VARIANT * pvar)
{
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };

    return pDisp->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                         &dispparams, pvar, NULL, NULL);
}

// IPersistPropertyBag

STDMETHODIMP CScriptlet::GetClassID(CLSID *pClassID)
{
    *pClassID = *BaseDesc()->_pclsid;
    return S_OK;
}

STDMETHODIMP CScriptlet::InitNew()
{
    HRESULT hr; 

    if (_fHardWiredURL)
    {
        hr = LoadScriptletURL();
    }
    else
    {
        hr = _pDoc->InitNew();
    }
    
    return hr;
}

STDMETHODIMP CScriptlet::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    VARIANT var;
    TCHAR *pchUrl = NULL;
    
    VariantInit(&var);
    hr = THR(pPropBag->Read(_T("Scrollbar"), &var, pErrorLog));
    if (!hr && !VariantChangeType(&var, &var, 0, VT_BOOL))
        _vbScrollbar = var.boolVal;
    VariantClear(&var);

    if (!_fHardWiredURL)
    {
        hr = THR(pPropBag->Read(_T("URL"), &var, pErrorLog));
        if (hr == E_INVALIDARG)
        {
            // No URL property was saved in the property bag. We force the update
            // of the scrollbar and go home.

            hr = THR(_pDoc->InitNew());
            if (hr)
                goto Cleanup;

            _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
            hr = S_OK;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        hr = THR(VariantChangeType(&var, &var, 0, VT_BSTR));
        if (hr)
            goto Cleanup;

        pchUrl = var.bstrVal;
    }

    // Force Trident to update its UI
    _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);

    hr = THR(LoadScriptletURL(pchUrl));

Cleanup:
    VariantClear(&var);
    RRETURN(hr);  
}

STDMETHODIMP CScriptlet::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BOOL;
    var.boolVal = _vbScrollbar;
    hr = pPropBag->Write(_T("Scrollbar"), &var);
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        var.vt = VT_BSTR;
        hr = THR(FormsAllocString(_pDoc->GetPrimaryUrl(), &var.bstrVal));
        if (hr)
            goto Cleanup;

        hr = THR(pPropBag->Write(_T("URL"), &var));
        if (hr)
            goto Cleanup;
    }

    if (fClearDirty)
        _fRequiresSave = 0;

Cleanup:
    VariantClear(&var);
    RRETURN(hr); 
}

// IPersistStreamInit

STDMETHODIMP CScriptlet::IsDirty(void)
{
    if (_fRequiresSave)
        return S_OK;
    else
        return _pDoc->IsDirty();
}

STDMETHODIMP CScriptlet::Load(LPSTREAM pStm)
{
    HRESULT hr;
    CStr cstrUrl;

    hr = THR(pStm->Read(&_vbScrollbar, sizeof(_vbScrollbar), NULL));
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        hr = THR(cstrUrl.Load(pStm));
        if (hr)
            goto Cleanup;
    }

    _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
    hr = THR(LoadScriptletURL(cstrUrl));

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScriptlet::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    HRESULT hr;

    if (fClearDirty)
        _fRequiresSave = 0;

    hr = THR(pStm->Write(&_vbScrollbar, sizeof(_vbScrollbar), NULL));
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        CStr cstrUrl;
        
        hr = cstrUrl.Set(_pDoc->GetPrimaryUrl());
        if (hr)
            goto Cleanup;

        hr = cstrUrl.Save(pStm);
    }

Cleanup:
    RRETURN(hr);
}

BOOL CSortedAtomTable::Find(LPCTSTR pch, LONG *plIndex, BOOL fCaseSensitive)
{
    int r;
    long iLow  = 0;
    long iMid  = 0;
    long iHigh = Size() - 1;
    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;
    long lIndex;
    TCHAR *pchCur;

    // Binary search for atom name
    while (iHigh >= iLow)
    {
        iMid = (iHigh + iLow) >> 1;
        lIndex = (long)_aryIndex[iMid];
        pchCur = (LPTSTR)(*(CStr *)Deref(sizeof(CStr), lIndex));
        r = pfnCompareString(pch, pchCur);
        if (r < 0)
        {
            iHigh = iMid - 1;
        }
        else if (r > 0)
        {
            iLow = iMid + 1;
        }
        else
        {
            *plIndex = lIndex;
            return TRUE;
        }
    }

    *plIndex = iHigh + 1;
    return FALSE;
}

HRESULT
CSortedAtomTable::Insert(LPCTSTR pch, LONG lInsertAt, LONG *plIndex)
{
    HRESULT hr = S_OK;
    WORD    wIndex;
    long    lIndex;
    CStr    cstrCopy;
    CStr   *pcstr;

    // Not found, so add atom(name) to end of array, so that the lIndex given out
    // is always the same (this could be a dispid that needs to be the same.
    hr = THR(AppendIndirect(&cstrCopy));
    if (hr)
        goto Cleanup;

    lIndex = Size() - 1;
    pcstr = (CStr *)Deref(sizeof(CStr), lIndex);
    hr = THR(pcstr->Set(pch));
    if (hr)
    {
        Delete(lIndex);
        goto Cleanup;
    }

    wIndex = (WORD)lIndex;

    // Insert the index of the new atom so that the sort order is maintained.
    hr = _aryIndex.InsertIndirect(lInsertAt, &wIndex);
    if (hr)
    {
        Delete(lIndex);
        goto Cleanup;
    }

    if (plIndex)
        *plIndex = lIndex;

Cleanup:
    RRETURN(hr);
}

void
CSortedAtomTable::Free()
{
    CStr *pcstr;
    long  i;
    
    for (i = 0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        pcstr->Free();
    }

    _aryIndex.DeleteAll();
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\safety.cxx ===
//+------------------------------------------------------------------------
//
//  File:       SAFETY.CXX
//
//  Contents:   Test safety options for embedded objects.
//
//  Notes:      Contains functions to determine safety of scripting and
//              initialization operations for embedded objects.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CLSTAB_HXX_
#define X_CLSTAB_HXX_
#include "clstab.hxx"
#endif

DeclareTag(tagObjectSafety, "OleSite", "Object safety information");

EXTERN_C const CLSID CLSID_AppletOCX;
HRESULT GetSIDOfDispatch(IDispatch *pDisp, BYTE *pbSID, DWORD *pcbSID, BOOL *pfDomainExist = NULL);
HRESULT GetCategoryManager(ICatInformation **ppCat);


//+-------------------------------------------------------------------------
//
//  Function:   DeinitCategoryInfo
//
//  Synopsis:   Clear out the thread local cached component category mgr.
//
//--------------------------------------------------------------------------

void 
DeinitCategoryInfo(THREADSTATE *pts)
{
    Assert(pts);
    ClearInterface(&pts->pCatInfo);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetCategoryManager
//
//  Synopsis:   Retrieve thread local cached component category mgr.
//              or create a new one and put it in there if not. 
//
//--------------------------------------------------------------------------

HRESULT
GetCategoryManager(ICatInformation **ppCat)
{
    HRESULT hr = S_OK;

    Assert(GetThreadState());
    
    if (!TLS(pCatInfo))
    {
        ICatInformation *   pCatInfo = NULL;
        
        hr = THR(CoCreateInstance(
                CLSID_StdComponentCategoriesMgr, 
                NULL, 
                CLSCTX_INPROC_SERVER, 
                IID_ICatInformation, 
                (void **) &pCatInfo));
        if (hr) // couldn't get the category manager--
            goto Cleanup;

        Assert(pCatInfo);
        TLS(pCatInfo) = pCatInfo;   // Take over the ref of pCatInfo
    }

    *ppCat = TLS(pCatInfo);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::AccessAllowed
//
// Synopsis:    Return TRUE if it's ok to access the object model
//              of the dispatch passed in.
//
//---------------------------------------------------------------

BOOL
COleSite::AccessAllowed(IDispatch *pDisp)
{
    BOOL            fAllowed = FALSE;
    BOOL            fDomainChanged = FALSE;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = ARRAY_SIZE(abSID);
    
    if (OK(THR_NOTRACE(GetSIDOfDispatch(pDisp, abSID, &cbSID, &fDomainChanged))))
    {
        COmWindowProxy *    pProxy;

        pProxy = GetWindowedMarkupContext()->Window();

        fAllowed = cbSID == pProxy->_cbSID &&
                    !memcmp(abSID, pProxy->_pbSID, cbSID) && fDomainChanged == (BOOL)pProxy->_fDomainChanged;
    }
    else
    {
        fAllowed = TRUE;
    }
    
    return fAllowed;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsSafeToScript, COleSite::IsSafeToInitialize, 
//
//  Returns:    BOOL      TRUE if operation is safe, otherwise FALSE.
//
//----------------------------------------------------------------------------

BOOL
COleSite::IsSafeToScript()
{
    BOOL    fSafe = FALSE;    

    INSTANTCLASSINFO * pici;
    
    if (_fKnowSafeToScript)
    {
        fSafe = !!_fSafeToScript;
    }
    else
    {
        HRESULT hr;

        _fKnowSafeToScript = TRUE;
        // (KTam): We may not be in a markup yet (e.g.
        // if we were created via createElement -- script.js does this)
        // What then?  Default to primary markup.
        CMarkup *pMU = GetMarkupPtr();
        if ( !pMU )
            pMU = Doc()->PrimaryMarkup();

        Assert( pMU );

        if (OlesiteTag() == OSTAG_APPLET)
        {
            //
            // If we're an applet, determine if we're even allowed
            // to script to them.
            //
            hr = THR(pMU->ProcessURLAction(
                    URLACTION_SCRIPT_JAVA_USE,
                    &fSafe));
            //
            // We don't want to prompt about activex controls so go to Cleanup directly
            // If we had failed we would return unsafe anyway
            //
            _fSafeToScript = !!fSafe;
            goto Cleanup;
        }

        hr = THR(pMU->ProcessURLAction(
                URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY, 
                &fSafe));
        if (hr)
            goto Cleanup;

        if (fSafe)
        {
            _fSafeToScript = !!fSafe;
            goto Cleanup;
        }
        
        else
        {
            pici = GetInstantClassInfo();

            if (pici)
            {
                if (_fViewLinkedWebOC)
                    fSafe = TRUE;
                else
                    fSafe = IsSafeTo(
                                SAFETY_SCRIPT, 
                                IID_IDispatch, 
                                pici->clsid, 
                                _pUnkCtrl, 
                                pMU);
            }
            else
            {
                fSafe = FALSE;
            }
        }

        _fSafeToScript = !!fSafe;

        if (!fSafe)
        {
            NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_PROTECTEDFROMUNSAFEOCX);
        }
    }
    
Cleanup:
    return fSafe;
}    


BOOL
COleSite::IsSafeToInitialize(REFIID riid)
{
    BOOL    fSafe;
    HRESULT hr;
    CDoc *  pDoc = Doc();
    INSTANTCLASSINFO * pici;

#ifdef NO_SECURITY
    return TRUE;
#else

    // (KTam): We may not be in a markup yet (e.g.
    // if we were created via createElement -- script.js does this)
    // What then?  Default to primary markup.
    CMarkup *pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = pDoc->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(
            URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY, 
            &fSafe));
    if (hr)
        goto Cleanup;

    if (!fSafe)
    {
        pici = GetInstantClassInfo();

        if (pici)
        {
            fSafe = IsSafeTo(
                        SAFETY_INIT, 
                        riid, 
                        pici->clsid, 
                        _pUnkCtrl, 
                        pMU);
        }
    }

    if (!fSafe)
    {
        NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_PROTECTEDFROMOCXINIT);
    }
    
Cleanup:
    return fSafe;

#endif // NO_SECURITY
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Brings up the unsafe content protection dialog.
//
//----------------------------------------------------------------------------

void 
NotifyHaveProtectedUserFromUnsafeContent(CMarkup *pMarkup, UINT uResId)
{
    if (pMarkup)
    {
        CDoc * pDoc = pMarkup->Doc();

        if (!pMarkup->_fSafetyInformed && 
            !(pDoc->_dwLoadf & DLCTL_SILENT) &&
            pDoc->_pInPlace &&
            pDoc->_pInPlace->_hwnd)
        {
            CDoc::CLock Lock(pDoc);

            pMarkup->_fSafetyInformed = TRUE;
            IGNORE_HR(pDoc->ShowMessage(NULL, MB_OK | MB_ICONWARNING, 0, uResId));
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Verifies safety for a particular action (on a particular 
//              interface).
//
//  Arguments:  sOperation:     The operation being validated for safety.
//              riid:           The interface this operation will use.
//
//  Returns:    BOOL            TRUE if operation is safe, otherwise FALSE.
//
//----------------------------------------------------------------------------

BOOL 
IsSafeTo(
    SAFETYOPERATION sOperation, 
    REFIID          riid, 
    CLSID           clsid, 
    IUnknown *      pUnk, 
    CMarkup *       pMarkup)       // if NULL, we don't confirm with user
{
    BOOL    fSafe = FALSE;
    HRESULT hr = E_FAIL;
    DWORD   dwCompat = 0;
    DWORD   dwMisc;
    CATID   catid = GUID_NULL;  // category of safety
    DWORD   dwXSetMask = 0; // options to set
    DWORD   dwXOptions = 0; // options to make safe for
                            // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                            // INTERFACESAFE_FOR_UNTRUSTED_DATA)

#if defined(WINCE) || defined(UNIX)
	// Temp overide any security on CE 
	return TRUE;
#else

    IObjectSafety *     posafe = NULL;
    ICatInformation *   pCatInfo = NULL;

    // Only these three operations are handled here. That's why we
    // can get away with not initializing catid.
    AssertSz(sOperation==SAFETY_INIT ||
             sOperation==SAFETY_SCRIPT ||
             sOperation==SAFETY_SCRIPTENGINE, "Illegal operation param to IsSafeTo.");

    switch (sOperation)
    {
    case SAFETY_INIT:
        catid = CATID_SafeForInitializing;
        dwXSetMask = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        dwXOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        break;

    case SAFETY_SCRIPT:
        catid = CATID_SafeForScripting;
        dwXSetMask = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        dwXOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        break;
        
    case SAFETY_SCRIPTENGINE:
        catid = GUID_NULL;  // Registry check is not sufficient for script engines
        dwXOptions = dwXSetMask =   INTERFACESAFE_FOR_UNTRUSTED_DATA
                                  | INTERFACE_USES_DISPEX 
                                  | INTERFACE_USES_SECURITY_MANAGER;
    }

    // 
    // Check compat flags first.  If no object safety is allowed, go 
    // straight to confirm because we don't believe what this control
    // says about it's safety.  Effectively the control is lying to us,
    // or implemented IObjectSafety incorrectly.
    //

    hr = THR(CompatFlagsFromClsid(clsid, &dwCompat, &dwMisc));
    if (!OK(hr))
        goto Cleanup;

    if (dwCompat & COMPAT_EVIL_DONT_LOAD)
    {
        Assert (!fSafe);
        goto Cleanup;
    }
        
    if (dwCompat & COMPAT_NO_OBJECTSAFETY)
        goto Confirm;
        
    hr = pUnk->QueryInterface(IID_IObjectSafety, (void **) &posafe);

    // If IObjectSafety is supported, ask the object to make itself safe
    if (posafe)
    {
        //
        // If we're trying to make it safe to script, ask object
        // if it knows about dispex2 & sec mgr.  If not, then bail out
        // if it's a script engine, continue otherwise.
        //

        if (sOperation == SAFETY_SCRIPTENGINE)
        {
            DWORD   dwMask = 0;
            DWORD   dwEnabled;
            
            hr = THR(posafe->GetInterfaceSafetyOptions(
                    riid,
                    &dwMask,
                    &dwEnabled));
            if (hr || !(dwMask & INTERFACE_USES_DISPEX))
                goto Cleanup;
        }

        //
        // If we're going for safe for scripting, try making the object
        // safe on IDispatchEx first, then drop to IDispatch.
        //

        hr = E_FAIL;
        if (sOperation == SAFETY_SCRIPT)
        {
            DWORD dwMask = 0;
            DWORD dwEnabled;

            // use security manager for controls if supported
            hr = THR(posafe->GetInterfaceSafetyOptions(
                    IID_IDispatchEx,
                    &dwMask,
                    &dwEnabled));

            if(OK(hr) && (dwMask & INTERFACE_USES_SECURITY_MANAGER)) {
                hr = THR(posafe->
                    SetInterfaceSafetyOptions(IID_IDispatchEx, 
                            dwXSetMask | INTERFACE_USES_SECURITY_MANAGER, 
                            dwXOptions | INTERFACE_USES_SECURITY_MANAGER));
            } 
            else
            {
                hr = THR(posafe->
                    SetInterfaceSafetyOptions(IID_IDispatchEx, dwXSetMask, dwXOptions));
            }
        }
        if (!OK(hr))
        {
            hr = THR(posafe->
                    SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions));
        }
        
        if (!OK(hr))
        {
            // Give user an opportunity to override.
            goto Confirm;
        }

        // Don't check registry if object supports IObjectSafety.
        goto EnsureSafeForScripting;
    }

    // otherwise looking in the registry to see if the object
    // belongs to the appropriate component category

    hr = THR(GetCategoryManager(&pCatInfo));
    if (hr)
        goto Cleanup;
        
    CATID rgcatid[1];
    rgcatid[0] = catid;

    // Ask if the object belongs to the specified category
    hr = THR(pCatInfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL));
    if (hr)
        goto Confirm;

    // Object is safe on this interface!

EnsureSafeForScripting:

    //
    // Though object appears to be safe, we still need to
    // see if scripting to objects is allowed at all.
    //

    if (sOperation == SAFETY_SCRIPT && pMarkup)
    {
        IGNORE_HR(pMarkup->ProcessURLAction( 
            URLACTION_SCRIPT_SAFE_ACTIVEX, 
            &fSafe));
    }
    else
    {
        fSafe = TRUE;
    }

    goto Cleanup;

Cleanup:
#if DBG==1
    if (!fSafe)
        TraceTag((tagObjectSafety, "Safety check failed!!"));
#endif

    ReleaseInterface(posafe);
    return fSafe;

Confirm:
    if (pMarkup)
    {
        IGNORE_HR(pMarkup->ProcessURLAction( 
            URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY, 
            &fSafe));
    }

    goto Cleanup;

#endif // WINCE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\scrpctrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scrpctrl.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptControl implementation
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_DOCUMENT_H_
#define X_DOCUMENT_H_
#include <document.h>
#endif

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

MtDefine(CScriptControl, Scriptlet, "CScriptControl")

const CBase::CLASSDESC CScriptControl::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IWBScriptControl,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

HRESULT
CScriptControl::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (IsEqualIID(iid, IID_IWBScriptControl))
            *ppv = (IWBScriptControl *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IWBScriptControl

STDMETHODIMP
CScriptControl::raiseEvent(BSTR name, VARIANT eventData)
{
    HRESULT hr;
    IHTMLEventObj *pEventObj = NULL;
    BYTE byParamTypes[3] = {VT_BSTR, VT_VARIANT, 0};
    CDoc * pDoc = _pScriptlet->_pDoc;
    EVENTPARAM param(pDoc, NULL, pDoc->_pWindowPrimary->Markup(), TRUE);

    param.SetType(_T("scriptletevent"));

    // Get the eventObject.
    Assert(pDoc->_pparam);
    CEventObj::Create(&pEventObj, pDoc, NULL, pDoc->_pWindowPrimary->Markup());

    hr = THR(_pScriptlet->FireEventV(1, DISPID_UNKNOWN, pEventObj, NULL, byParamTypes, name, eventData));
    
    ReleaseInterface(pEventObj);
    
    RRETURN(hr);
}

const struct
{
    LPOLESTR    pstrEventName;
    DISPID      dispidEvent;
} mppstreventinfo [] =
{
    { _T("click"),      DISPID_HTMLDOCUMENTEVENTS_ONCLICK },
    { _T("dblclick"),   DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK },
    { _T("keydown"),    DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN },
    { _T("keypress"),   DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS },
    { _T("keyup"),      DISPID_HTMLDOCUMENTEVENTS_ONKEYUP },
    { _T("mousedown"),  DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN },
    { _T("mousemove"),  DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE },
    { _T("mouseup"),    DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP }
};                   

STDMETHODIMP
CScriptControl::bubbleEvent()
{
    int              i;
    DISPID           dispidEvent;
    BSTR             bstrType;
    IHTMLWindow2    *pHW = NULL;
    IHTMLEventObj   *pEO = NULL;
    CDoc *           pDoc = _pScriptlet->_pDoc;

    // Look at the Window object to see whether it has an event posted.

    pHW = pDoc->_pWindowPrimary;
    pHW->AddRef();
    if (pHW->get_event(&pEO))
        goto Cleanup;
    if (!pEO)
        goto Cleanup;
 
    // They did. Find the flavour of the event and do the appropriate thing:

    if (pEO->get_type(&bstrType))
        goto Cleanup;

    dispidEvent = DISPID_UNKNOWN;
    for (i = 0; i < ARRAY_SIZE(mppstreventinfo); ++i)
    {
        if (!_tcscmp(mppstreventinfo[i].pstrEventName, bstrType))
        {
            dispidEvent = mppstreventinfo[i].dispidEvent;
            break;
        }
    }
    if (dispidEvent == DISPID_UNKNOWN)
        goto Cleanup;

    _pScriptlet->FireEvent(pDoc, NULL, pDoc->_pWindowPrimary->Markup(), dispidEvent, DISPID_UNKNOWN);

Cleanup:
    ReleaseInterface(pHW);
    ReleaseInterface(pEO);
    return S_OK;
}

STDMETHODIMP
CScriptControl::setContextMenu(VARIANT var)
{
    return _pScriptlet->_ScriptletSubObjects.SetContextMenu(var);
}


STDMETHODIMP
CScriptControl::get_selectableContent(VARIANT_BOOL * vbSelectable)
{
    *vbSelectable = _pScriptlet->_vbSelectable;
    return S_OK;
}

STDMETHODIMP
CScriptControl::put_selectableContent(VARIANT_BOOL vbSelectable)
{
    _pScriptlet->_vbSelectable = vbSelectable ? VARIANT_TRUE : VARIANT_FALSE;
    return _pScriptlet->_pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
}

STDMETHODIMP
CScriptControl::get_frozen(VARIANT_BOOL * pvbFrozen)
{
    HRESULT hr = S_OK;
    if (!pvbFrozen)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pvbFrozen = _pScriptlet->_cFreezes > 0 ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    return hr;
}

STDMETHODIMP
CScriptControl::get_scrollbar(VARIANT_BOOL * pvbShow)
{
    return _pScriptlet->get_Scrollbar(pvbShow);
}

STDMETHODIMP
CScriptControl::put_scrollbar(VARIANT_BOOL vbShow)
{
    return _pScriptlet->put_Scrollbar(vbShow);
}

STDMETHODIMP
CScriptControl::get_version(BSTR * pbstr)
{
    return (FormsAllocString(_T("5.0 Win32"), pbstr));
}

STDMETHODIMP
CScriptControl::get_visibility(VARIANT_BOOL *pvbVisibility)
{
    if (!pvbVisibility)
        return E_POINTER;
    
    *pvbVisibility = _pScriptlet->_fIsVisible ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}


STDMETHODIMP
CScriptControl::get_onvisibilitychange(VARIANT *pvar)
{
    if (!pvar)
        return E_POINTER;
        
    return VariantCopy(pvar, &_pScriptlet->_varOnVisChange);
}


STDMETHODIMP
CScriptControl::put_onvisibilitychange(VARIANT var)
{
    return VariantCopy(&_pScriptlet->_varOnVisChange, &var);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\scrsbobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scrsbobj.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptletSubObjects: CScriptlet subobject implementation for 
//              IDocHostUIHandler and IPropertyNotifySink Support
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CScriptletSubObjects, Scriptlet, "CScriptletSubObjects")
MtDefine(CScriptletSubObjects_aryDispid_pv, CScriptletSubObjects, "CScriptletSubObjects::_aryDispid::_pv")
MtDefine(CScriptletSubObjectsSetContextMenu_aryDispid_pv, Locals, "CScriptletSubObjects::SetContextMenu aryDispid::_pv")

enum { MENUID_OFFSET = 1 };

IMPLEMENT_SUBOBJECT_IUNKNOWN(CScriptletSubObjects, CScriptlet, Scriptlet, _ScriptletSubObjects)

CScriptletSubObjects::~CScriptletSubObjects()
{
    if (_hmenuCtx)
        DestroyMenu(_hmenuCtx);
    
    _aryDispid.DeleteAll();
}

// IUnknown methods

STDMETHODIMP CScriptletSubObjects::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
        AddRef();
        return S_OK;
    }
    else if (riid==IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// IDocHostUIHandler interface ////////////////////////////////////

STDMETHODIMP
CScriptletSubObjects::ShowContextMenu(DWORD dwID, POINT * ppt, IUnknown *, IDispatch *)
{
    HWND            hwnd = NULL;
    MSG             msg;
    DISPPARAMS      dispparams = { NULL, 0, NULL, 0 };

    // If we have no ctx menu, we're out of a job!

    if (!_hmenuCtx)
        goto Cleanup;

    // Create a small window to show what we've got. 

    hwnd = CreateWindowA(
                "STATIC",
                "",
                WS_POPUP,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInstCore,
                NULL);
    if (hwnd == NULL)
        goto Cleanup;

    // Show the context menu, funneling its command into the queue of hwnd.

    if (TrackPopupMenu(
            _hmenuCtx, TPM_LEFTALIGN, 
            ppt->x,
            ppt->y,
            0,
            hwnd,
            NULL) == 0)
    {
        goto Cleanup;
    }

    // The WM_COMMAND is in the message queue for the HWND. Get it.

    if (PeekMessage(&msg, hwnd, WM_COMMAND, WM_COMMAND, PM_REMOVE) == 0)
        goto Cleanup;

    // We have a dispid, now call the script object with it.

    Scriptlet()->_pDoc->_pWindowPrimary->InvokeEx(
                _aryDispid[LOWORD(msg.wParam) - MENUID_OFFSET],
                LOCALE_USER_DEFAULT,
                DISPATCH_METHOD,
                &dispparams, 
                NULL, NULL, NULL);
Cleanup:
    if (hwnd)
        DestroyWindow(hwnd);

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::GetHostInfo(DOCHOSTUIINFO * pDHUI)
{
    pDHUI->cbSize = sizeof(*pDHUI);
    pDHUI->dwFlags =
            DOCHOSTUIFLAG_NO3DBORDER | 
            DOCHOSTUIFLAG_DISABLE_HELP_MENU;
    if (!Scriptlet()->_vbSelectable)
        pDHUI->dwFlags |= DOCHOSTUIFLAG_DIALOG;
    if (!Scriptlet()->_vbScrollbar) 
        pDHUI->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
    pDHUI->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::ShowUI(DWORD dwID, IOleInPlaceActiveObject *, IOleCommandTarget *, IOleInPlaceFrame *, IOleInPlaceUIWindow *)
{
    // We have no UI to show, Trident will do that for itself.
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::HideUI()
{
    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::UpdateUI()
{
    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::EnableModeless(BOOL fEnable)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::OnDocWindowActivate(BOOL fActive)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::OnFrameWindowActivate(BOOL fActive)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::ResizeBorder(LPCRECT, IOleInPlaceUIWindow *, BOOL fFrameWindow)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::TranslateAccelerator(MSG * pmsg,const GUID * pguidCmdGroup, DWORD nCmdID)
{
    // disable F5 as a refresh tool.

    if (pmsg->message == WM_KEYDOWN || pmsg->message == WM_KEYUP)
    {
        if (pmsg->wParam == VK_F5)
            return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::GetOptionKeyPath(LPOLESTR * pchKey,  DWORD dwReserved)
{
    // User preferences are the same as those of Default Trident
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::GetDropTarget(IDropTarget *, IDropTarget ** )
{
    // We don't interfere with Trident's drag/drop stuff.
    return S_FALSE;
}

/*
 *  IDocHostUIHandler::GetExternal
 *
 *  The IDispatch asked for will be used to resolve any references to 
 *  window.external from script. In our case, we want the object
 *  to be the CScriptControl.
 */

STDMETHODIMP
CScriptletSubObjects::GetExternal(IDispatch ** ppDisp)
{
    Assert(Scriptlet()->_pScriptCtrl);

    *ppDisp = Scriptlet()->_pScriptCtrl;
    (*ppDisp)->AddRef();

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::TranslateUrl(DWORD dwTranslate, OLECHAR *, OLECHAR ** )
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::FilterDataObject(IDataObject *, IDataObject ** )
{
    return S_FALSE;
}


// IPropertyNotifySink

STDMETHODIMP CScriptletSubObjects::OnRequestEdit(DISPID dispid)
{
    if (dispid < 0)     // no Trident properties make it out.
        return S_OK;

    return Scriptlet()->FireRequestEdit(dispid);
}

STDMETHODIMP CScriptletSubObjects::OnChanged(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_READYSTATE:
        Scriptlet()->FireOnChanged(DISPID_READYSTATE);
        Scriptlet()->OnReadyStateChange();
        break;

    case STDPROPID_XOBJ_WIDTH:
        Scriptlet()->SetWidth(dispid);
        break;

    case STDPROPID_XOBJ_HEIGHT:
        Scriptlet()->SetHeight(dispid);
        break;

    default:
        if (dispid >= 0)     // no Trident properties make it out.
            Scriptlet()->FireOnChanged(dispid);
        break;
    }

    return S_OK;
}

// CScriptletSubObjects helper methods /////////////////////////////////////////

HRESULT
CScriptletSubObjects::SetContextMenu(VARIANT varArray)
{
    HRESULT                  hr;
    int                      i;
    DISPID                   dispid;
    char                     achCaption[256];
    HMENU                    hmenu = NULL;
    VARIANT                  varCaption;
    VARIANT                  varFunction;
    CDataAry<DISPID>         aryDispid(Mt(CScriptletSubObjectsSetContextMenu_aryDispid_pv));
    HRESULT                (*pfnGetItem)(const VARIANT & varArray, long i, VARIANT * pvar);

    VariantInit(&varCaption);
    VariantInit(&varFunction);

    // Determine the way to unpack the array.
    
    hmenu = CreatePopupMenu();
    if (!hmenu)
        goto Cleanup;

    switch (varArray.vt)
    {
    case VT_VARIANT | VT_ARRAY | VT_BYREF:
        // Access the data in a safearray (thank *you*, VBScript!)
        pfnGetItem = CScriptletSubObjects::GetVBScriptItem;
        break;
    case VT_DISPATCH:
        pfnGetItem = CScriptletSubObjects::GetJavaScriptItem;
        break;
    default:
        // Can't safely handle your data, mister.
        hr = E_FAIL;
        goto Cleanup;
    }

    // Unpack the array and store items in the menu and dynarray

    for (i = 0; ; i += 2)
    {
        hr = pfnGetItem(varArray, i, &varCaption);
        if (hr)
            break;
        hr = VariantChangeType(&varCaption, &varCaption, 0, VT_BSTR);
        if (hr)
            break;
        if (varCaption.bstrVal && varCaption.bstrVal[0])
        {
            WideCharToMultiByte(CP_ACP, 0, 
                                varCaption.bstrVal, -1, 
                                achCaption, sizeof(achCaption), 
                                NULL, NULL);

            hr = pfnGetItem(varArray, i+1, &varFunction);
            if (hr)
                break;
            hr = VariantChangeType(&varFunction, &varFunction, 0, VT_BSTR);
            if (hr)
                break;
            
            hr = Scriptlet()->_pDoc->_pWindowPrimary->GetDispID(varFunction.bstrVal, fdexFromGetIdsOfNames, &dispid);
            if (hr)
                break;
        }
        else
        {
            achCaption[0] = '\0';
            dispid = DISPID_UNKNOWN;
        }

        // The menu ID's are going to be 1+the offset into the arydispid array.
        // A menu ID of 0 is hard to distinguish from Windows error codes.

        Assert(aryDispid.Size() == i/2);

        hr = aryDispid.AppendIndirect(&dispid);
        if (hr)
            break;

        if (!AppendMenuA(
                hmenu,
                (achCaption[0]) ? MF_STRING : MF_SEPARATOR,
                i/2 + MENUID_OFFSET, 
                achCaption))
            break;

        VariantClear(&varCaption);
        VariantClear(&varFunction);
    }

    if (i == 0)
        goto Cleanup;

    hr = _aryDispid.EnsureSize(aryDispid.Size());
    if (hr)
        goto Cleanup;

    // All went well! Now destroy the old context menu and keep 
    // the new one.

    if (_hmenuCtx)
        DestroyMenu(_hmenuCtx);

    _hmenuCtx = hmenu;
    hmenu = NULL;

    memcpy((char *)(DISPID *)_aryDispid,
           (char *)(DISPID *)aryDispid,
           aryDispid.Size() * sizeof(DISPID));

    _aryDispid.SetSize(aryDispid.Size());

Cleanup:
    if (hmenu)
        DestroyMenu(hmenu);

    return S_OK;
}

HRESULT
CScriptletSubObjects::GetJavaScriptItem(const VARIANT & varArray, long i, VARIANT * pvar)
{
    HRESULT hr;
    DISPID  dispid;
    TCHAR   ach[30];

    // JScript returns a dispatch object with items named "0", "1", ....

    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), i);
    if (hr)
        goto Cleanup;

    hr = IdFromName(varArray.pdispVal, ach, &dispid);
    if (hr)
        goto Cleanup;
    
    hr = Property_get(varArray.pdispVal, dispid, pvar);

Cleanup:
    return hr;
}

HRESULT
CScriptletSubObjects::GetVBScriptItem(const VARIANT & varArray, long i, VARIANT * pvar)
{
    long cElements;

    // Convert to closest even number.
    cElements = ((*varArray.pparray)->rgsabound[0].cElements) & ~1;
    if (i >= cElements)
        return DISP_E_BADINDEX;
    return SafeArrayGetElement(*varArray.pparray, &i, pvar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\atblocks.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       AtBlocks.cxx
//
//  Contents:   Support for Cascading Style Sheets "atblocks" - e.g., "@page" and "@media" definitions.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

MtDefine(CAtPage, StyleSheets, "CAtPage")
MtDefine(CAtMedia, StyleSheets, "CAtMedia")
MtDefine(CAtFontFace, StyleSheets, "CAtFontFace")
MtDefine(CAtNamespace, StyleSheets, "CAtNamespace")
MtDefine(CAtUnknown, StyleSheets, "CAtUnknown")
MtDefine(CAtUnknownInfo, StyleSheets, "CAtUnknownInfo")

DeclareTag(tagCSSAtBlocks, "Stylesheets", "Dump '@' blocks")



EMediaType CSSMediaTypeFromName (LPCTSTR szMediaName)
{
    if(!szMediaName || !(*szMediaName))
        return MEDIA_NotSet;

    for(int i = 0; i < ARRAY_SIZE(cssMediaTypeTable); i++)
    {
        if(_tcsiequal(szMediaName, cssMediaTypeTable[i]._szName))
            return cssMediaTypeTable[i]._mediaType;
    }

    return MEDIA_Unknown;
}


//+----------------------------------------------------------------------------
//
//  Class:  CAtPage
//
//-----------------------------------------------------------------------------

CAtPage::CAtPage (CCSSParser *pParser, Tokenizer &tok)
                : CAtBlockHandler(pParser)
{
    Assert(pParser && pParser->GetStyleSheet());

    CStyleSheet *pStyleSheet = pParser->GetStyleSheet();

    // NOTE (KTam): Compat issue -- we are no longer preserving the content
    // between '@page' and the first '{'.  Does anyone care? (I haven't seen
    // an Office doc that actually uses page selectors).

    // Beginning of a page rule:
    //  PAGE_SYM S* IDENT? [':' IDENT]? S* '{'

    // Parse up to the { (or EOF).  We start by looking for a page selector,
    // switching to look for a pseudoclass if we see a ':'.
    BOOL fLookForSelector = TRUE;
    CStr cstrSelector, cstrPseudoClass;

    Tokenizer::TOKEN_TYPE tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
    {
        if (tok.IsIdentifier(tt))
        {
            if ( fLookForSelector )
                cstrSelector.Set( tok.GetStartToken(), tok.GetTokenLength() );
            else
                cstrPseudoClass.Set( tok.GetStartToken(), tok.GetTokenLength() );
        }
        else if ( tt == Tokenizer::TT_Colon )
        {
            fLookForSelector = FALSE;
        }

        tt = tok.NextToken();
    }

    // Create the "pages" array if we don't already have one.
    if ( !pStyleSheet->_pPageRules )
    {
        pStyleSheet->_pPageRules = new CStyleSheetPageArray( pStyleSheet );
        // The stylesheet owns the ref on the page array that it will release when it passivates.
        // The page array holds a subref back on the stylesheet.
    }

    // Create the page rule object corresponding to this @block.
    if ( pStyleSheet->_pPageRules )
    {
        HRESULT hr =  CStyleSheetPage::Create(&_pPage, pStyleSheet, cstrSelector, cstrPseudoClass );
        // Each page in the array holds a subref back on the stylesheet.
        if (!hr)
        {
            pStyleSheet->_pPageRules->Append(_pPage);  // array refs page if append is successful.
        }
        // We'll hang onto our ref on the page until we go out of scope (dtor).
    }
}

CAtPage::~CAtPage ()
{
    if ( _pPage )
        _pPage->Release();  // corresponds to ref given by "new" when _pPage was created (ctor).
}

HRESULT CAtPage::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
    HRESULT hr = S_FALSE;

#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtPage::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    if ( _pPage )
    {
        DISPID      dispid;
        VARIANT     varNew;
        CBase      *pBase;

        // Create an expando
        pBase = _pPage;

        Assert(pBase);

        hr = pBase->GetExpandoDispID((LPTSTR)pszName, &dispid, fdexNameCaseSensitive|fdexNameEnsure);
        if (hr)
            goto Cleanup;

        // Use the byref member of the union because it's a PVOID and
        // there's no member corresponding to VT_LPWSTR.
        varNew.vt = VT_LPWSTR;
        varNew.byref = (LPTSTR)pszValue;

        hr = THR(CAttrArray::Set(_pPage->GetAA(), dispid, &varNew, NULL, CAttrValue::AA_Expando));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT CAtPage::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("AtPage::EndStyleRule()\r\n");
    }
#endif
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:  CAtMedia
//
//-----------------------------------------------------------------------------

CAtMedia::CAtMedia (CCSSParser *pParser, Tokenizer &tok, CStyleSheet *pStyleSheet)
                : CAtBlockHandler(pParser)
{
    Assert(pParser);
 
    _ePrevMediaType = _ePrevAtMediaType = MEDIA_NotSet;

    _pStyleSheet = pStyleSheet;

    _dwFlags = ATBLOCKFLAGS_MULTIPLERULES;
    if (pStyleSheet)
    {
        LPTSTR pszName;

        tok.StartSequence();

        // Get the propertyValue
        Tokenizer::TOKEN_TYPE tt = tok.NextToken();

        while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
        {
            tt = tok.NextToken();
        }

        tok.StopSequence(&pszName);

        EMediaType eMediaType = (EMediaType)TranslateMediaTypeString(pszName);
        if(eMediaType != MEDIA_NotSet)
        {
            _ePrevMediaType   = pStyleSheet->GetMediaTypeValue();
            _ePrevAtMediaType = pStyleSheet->GetLastAtMediaTypeValue();
            pStyleSheet->SetMediaTypeValue((EMediaType)(eMediaType & _ePrevMediaType));
            // Save the last media type for serializaton purposed
            if(_ePrevAtMediaType != MEDIA_NotSet)
            {
                eMediaType = (EMediaType)(eMediaType & _ePrevAtMediaType);
                if(eMediaType == MEDIA_NotSet)
                    eMediaType = MEDIA_Unknown;
            }
            pStyleSheet->SetLastAtMediaTypeValue(eMediaType);
        }
    }

}

CAtMedia::~CAtMedia ()
{
    if(_pStyleSheet)
    {
        // Restore the saved previous at block media types
         _pStyleSheet->SetMediaTypeValue(_ePrevMediaType);
         // Restore the previous applied media type value (& ed value)
         _pStyleSheet->SetLastAtMediaTypeValue(_ePrevAtMediaType);
    }
}

HRESULT CAtMedia::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtMedia::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    return S_OK;
}

HRESULT CAtMedia::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("AtMedia::EndStyleRule()\n");
    }
#endif
    
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Class:  CAtFontFace
//
//-----------------------------------------------------------------------------

CAtFontFace::CAtFontFace (CCSSParser *pParser, Tokenizer &tok)
                : CAtBlockHandler(pParser)
{
    LPTSTR pszName;
    Assert(pParser && pParser->GetStyleSheet());
    
    tok.StartSequence();

    // Get the propertyValue
    Tokenizer::TOKEN_TYPE tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
    {
        tt = tok.NextToken();
    }

    tok.StopSequence(&pszName);
    
    HRESULT hr = CFontFace::Create(&_pFontFace,pParser->GetStyleSheet(), pszName);
    if (!hr)
        pParser->GetStyleSheet()->AppendFontFace(_pFontFace);
}


CAtFontFace::~CAtFontFace ()
{
}

HRESULT CAtFontFace::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
    IGNORE_HR(_pFontFace->SetProperty(pszName, pszValue));

    // S_FALSE means no further processing is needed

    return S_FALSE;
}

HRESULT CAtFontFace::EndStyleRule (CStyleRule *pRule)
{
    HRESULT hr = _pFontFace->StartDownload();

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Class:  CAtUnknown
//
//-----------------------------------------------------------------------------

CAtUnknown::CAtUnknown (CCSSParser *pParser, Tokenizer &tok, CStyleSheet *pStyleSheet, LPTSTR pchAlt) 
                : CAtBlockHandler(pParser)
{
    Assert(pParser);
 
    _pStyleSheet = pStyleSheet;

    _dwFlags = ATBLOCKFLAGS_MULTIPLERULES;

    _pBlockInfo = new CAtUnknownInfo;

    if(_pBlockInfo)
    {
        if (pchAlt)
        {
            _pBlockInfo->_cstrUnknownBlockName.Set(_T("import"));
            _pBlockInfo->_cstrUnknownBlockSelector.Set(pchAlt);
        }
        else
        {
            _pBlockInfo->_cstrUnknownBlockName.Set(tok.GetStartToken(), tok.GetTokenLength());

            tok.StartSequence();

            // Get the propertyValue
            Tokenizer::TOKEN_TYPE tt = tok.NextToken();

            while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_LCurly)
            {
                tt = tok.NextToken();
            }

            tok.StopSequence();
    
            _pBlockInfo->_cstrUnknownBlockSelector.Set(tok.GetStartToken(), tok.GetTokenLength());
        }
    }
}


CAtUnknown::~CAtUnknown ()
{    
    delete _pBlockInfo;
}


HRESULT CAtUnknown::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtUnknown::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    return S_OK;
}


HRESULT CAtUnknown::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("CAtUnknown::EndStyleRule()\n");
    }
#endif

    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\print\putil.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       print.cxx
//
//  Contents:   Print/PageSetup dialog helpers
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PUTIL_HXX
#define X_PUTIL_HXX
#include "putil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // areratingsenabled()
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"    // GetAlternatePrintDoc()
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_HTMLDLG_HXX
#define X_HTMLDLG_HXX
#include "htmldlg.hxx"
#endif

DeclareTag(tagPrintBackground, "Print", "Print background")
DeclareTag(tagPrintKeepTempfiles, "Print", "Don't delete temporary files")
MtDefine(GetNextToken_ppchOut, Printing, "GetNextToken *ppchOut")
MtDefine(CIPrintCollection, Printing, "CIPrintCollection")
MtDefine(CIPrintCollection_aryIPrint_pv, CIPrintCollection, "CIPrintCollection::_aryIPrint::_pv")

static int GetNextToken(const TCHAR *pchIn, TCHAR **ppchOut);
static HRESULT ReadURLFromFile(TCHAR *pchFileName, TCHAR **ppchURL);

// helpers for the string manipulation stuff in PrintHTML

static const TCHAR g_achURLDelimiter[] = TEXT("");
static const TCHAR g_achURLPrefix[]    = TEXT("url:");
static const UINT  g_uiURLPrefixLen    = sizeof(g_achURLPrefix) - 1;

BOOL g_fFoundOutIfATMIsInstalled;
BOOL g_fATMIsInstalled;
extern BOOL g_fInHtmlHelp;

#define _cxx_
#include "print.hdl"

static const DRIVERPRINTMODE s_aPrintDriverPrintModes[] =
{ { _T("WinFax")               , PRINTMODE_NO_TRANSPARENCY },
  { _T("OLFAXDRV")             , PRINTMODE_NO_TRANSPARENCY },
  { _T("NEC  SuperScript 860") , PRINTMODE_NO_TRANSPARENCY },
  { _T("NEC  SuperScript 1260"), PRINTMODE_NO_TRANSPARENCY }
};


// the following must match the order of PrintEnum
const TCHAR *s_aachPrintType[] =
{
    _T("PageSetup"),        // PRINTTYPE_PAGESETUP
    _T("Preview"),          // PRINTTYPE_PREVIEW
    _T("Prompt"),           // PRINTTYPE_PRINT
    _T("NoPrompt"),         // PRINTTYPE_NOPROMPT
};

//
// NOTE(SujalP + OliverSe): This code is safe in a multithreaded environment because in the
// worst case multiple threads will end up calling GetPrivateProfileStringA, but they will
// all drive the same information -- either it is installed or not.
//
static void
FindIfATMIsInstalled()
{
    if (!g_fFoundOutIfATMIsInstalled)
    {
        if (!g_fUnicodePlatform)
        {
            char szReturned[2];
            GetPrivateProfileStringA("Boot",
                                     "atm.system.drv",
                                     "*",
                                     szReturned,
                                     sizeof(szReturned),
                                     "system.ini"
                                    );
            g_fATMIsInstalled = szReturned[0] != '*';
        }
        else
        {
            g_fATMIsInstalled = FALSE;
        }
        g_fFoundOutIfATMIsInstalled = TRUE;
    }
}


BOOL
IsATMInstalled()
{
    FindIfATMIsInstalled();
    return g_fATMIsInstalled;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PaintBackground
//
//  Synopsis:   Returns whether printing of backgrounds is on or off.
//
//----------------------------------------------------------------------------
BOOL CMarkup::PaintBackground()
{
    return (
#if DBG == 1
                IsTagEnabled(tagPrintBackground) ||             // Lets us force printing of backgrounds
#endif // DBG == 1
                Doc()->_pOptionSettings->fPrintBackground       // Should we always print backgrounds?
        ||      !IsPrintMedia() );                              // Are we printing?
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::DontRunScripts
//
//  Synopsis:   Returns FALSE for CDoc's and TRUE for CPrintDoc's that were
//              are marked not to run scripts because they were saved out to
//              tempfiles.
//
//----------------------------------------------------------------------------
BOOL CMarkup::DontRunScripts()
{
    // The general rule is to disallow scripts in print media.
    // 10/20/2000 (greglett)  ...And there are now no exceptions.
    return IsPrintMedia();
}


//+---------------------------------------------------------------------
//
//   Helper : CopyPrintHandles
//
//   Synopsis :
//
//   NOTE (greglett)  Most Win9x *W() API's that use the DEVMODE structure
//   use a DEVMODEA.  Under Win9x, we'll assume a DEVMODEA.  The plumbing
//   in NT is correct, so expect a DEVMODEW.
//
//   Parameters:    [in]  HGLOBAL hSrcDevNames
//                  [in]  HGLOBAL hSrcDevMode
//                  [out] HGLOBAL *phDstDevNames
//                  [out] HGLOBAL *phDstDevMode
//
//+---------------------------------------------------------------------
HRESULT CopyPrintHandles(HGLOBAL hSrcDevNames, HGLOBAL hSrcDevMode, HGLOBAL *phDstDevNames, HGLOBAL *phDstDevMode)
{
    HRESULT     hr      = S_OK;
    DEVNAMES  * pDNSrc  = NULL;
    DEVNAMES  * pDNDst  = NULL;
    void      * pDMSrc  = NULL;
    void      * pDMDst  = NULL;
    WORD        nSize;

    Assert(phDstDevNames);
    Assert(phDstDevMode);
    *phDstDevNames = NULL;
    *phDstDevMode  = NULL;

    if (!hSrcDevNames || !hSrcDevMode)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pDNSrc = (DEVNAMES *)::GlobalLock(hSrcDevNames);
    pDMSrc = ::GlobalLock(hSrcDevMode);

    if (!pDMSrc || !pDNSrc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Net structure size is: BaseSize + (DriverStrLen + DeviceStrLen + OutputStrLen) * sizeof(TCHAR)
    // String offsets are in TCHARs, not bytes.
    nSize = sizeof(DEVNAMES)
          + ( _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wDriverOffset)
            + _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wDeviceOffset)
            + _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wOutputOffset)
            + 3 ) * sizeof(TCHAR);

    *phDstDevNames = ::GlobalAlloc(GHND, nSize);
    if (!*phDstDevNames)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDNDst = (DEVNAMES *)::GlobalLock(*phDstDevNames);
    if (!pDNDst)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ::CopyMemory(pDNDst, pDNSrc, nSize);
    ::GlobalUnlock(*phDstDevNames);


    if (g_fUnicodePlatform)
        nSize = ((DEVMODEW *)pDMSrc)->dmSize + ((DEVMODEW *)pDMSrc)->dmDriverExtra;
    else
        nSize = ((DEVMODEA *)pDMSrc)->dmSize + ((DEVMODEA *)pDMSrc)->dmDriverExtra;

    // Global alloc some new space for our copy
    *phDstDevMode = ::GlobalAlloc(GHND, nSize);
    if (!*phDstDevMode)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDMDst = ::GlobalLock(*phDstDevMode);
    if (!pDMDst)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ::CopyMemory(pDMDst, pDMSrc, nSize);
    ::GlobalUnlock(*phDstDevMode);

Cleanup:
    if (pDNSrc)
        ::GlobalUnlock(hSrcDevNames);
    if (pDMSrc)
        ::GlobalUnlock(hSrcDevMode);

    if (hr != S_OK)
    {
        // Abandon ship!  Free any objects we may have allocated.
        if (*phDstDevNames)
        {
            ::GlobalFree(*phDstDevNames);
            *phDstDevNames = NULL;
        }
        if (*phDstDevMode)
        {
            ::GlobalFree(*phDstDevMode);
            *phDstDevMode = NULL;
        }
    }

    return hr;
}

HRESULT
CDocExtra::ReplacePrintHandles(HGLOBAL hDN, HGLOBAL hDM)
{
    HRESULT hr;
    HGLOBAL hDNOut = NULL;
    HGLOBAL hDMOut = NULL;

    // We have been passed a DEVNAMES/DEVMODE pair.
    // Copy it into our own
    hr = CopyPrintHandles(hDN, hDM, &hDNOut, &hDMOut);
    if (hr == S_OK)
    {
        // Print handles successfully copied.  Overwrite input arguments.
        if (_hDevNames)
            ::GlobalFree(_hDevNames);
        if (_hDevMode)
            ::GlobalFree(_hDevMode);

        _hDevNames = hDNOut;
        _hDevMode  = hDMOut;
    }

    return hr;
}

//+---------------------------------------------------------------------
//
//   Helper : ProcessHeaderFooterArray, Static
//
//   Synopsis : helper method for PrintHandler, this is essentially copied
//      from the Old CDoc::DoPrint code, and is responsible for parsing out
//      the contents of the SafeArray varArg that came into IDM_PRINT.  IN
//      template printing, we pull these out into another bundle of parameters
//      (based on expandos on the eventObject) and this is passed as the
//      varargin do the DHUI handler.  The DHUI handler then pulls them off
//      the eventObject and builds another safearray of a lot of things to be
//      used in the template. whew. lots of copies of copies.
//
//      Read print parameters
//      1. header string
//      2. footer string
//      3. Outlook Express header document IStream *
//      4. alternate URL string (used for MHTML in OE)
//      5. dwFlags to be ORed in
//      6. print template string
//      7. DEVNAMES (always W)
//      8. DEVMODE (DEVMODEA on Win9x, DEVMODEW on NT)
//
//----------------------------------------------------------------------
HRESULT ParseHeaderFooterArray(SAFEARRAY * psaHeaderFooter,
                               BSTR      * pbstrHeader,
                               BSTR      * pbstrFooter,
                               IStream  ** ppStream,
                               BSTR      * pbstrAlternate,
                               DWORD     * pdwFlags,
                               BSTR      * pbstrTemplate,
                               CDoc      * pDoc)
{
    HRESULT hr = S_OK;
    long    lArg;
    VARIANT var;

    // check parameters
    if (   !psaHeaderFooter
        || SafeArrayGetDim(psaHeaderFooter) != 1
        || psaHeaderFooter->rgsabound[0].cElements < 2
        || psaHeaderFooter->rgsabound[0].cElements == 7     // DEVNAMES and DEVMODE are a pair
        || psaHeaderFooter->rgsabound[0].cElements > 8)
    {
        return E_INVALIDARG;
    }

    Assert(pbstrHeader);
    Assert(pbstrFooter);
    Assert(ppStream);
    Assert(pbstrAlternate);
    Assert(pdwFlags);
    Assert(pbstrTemplate);
    Assert(pDoc);

    // initialize helper variables
    VariantInit(&var);

    // Obtain the header and footer
    for (lArg = 0; lArg < 2; ++lArg)
    {
        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (hr == S_OK)
        {
            hr = VariantChangeType(&var, &var, NULL, VT_BSTR);
            if (hr == S_OK && V_BSTR(&var))
            {
                if (lArg == 0)
                {
                    // transfer ownership
                    *pbstrHeader = V_BSTR(&var);
                }
                else
                {
                    // transfer ownership
                    *pbstrFooter = V_BSTR(&var);
                }

            }
        }

        VariantInit(&var);  //don't clear
    }

    // Obtain OE Header stream.
    if (psaHeaderFooter->rgsabound[0].cElements > 2)
    {
        lArg = 2;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_UNKNOWN
            && V_UNKNOWN(&var))
        {
            // transfer Ownership
            *ppStream = (IStream *)V_UNKNOWN(&var);
        }

        VariantInit(&var);  // don't clear
    }

    // Obtain OE MHTML Url.
    if (psaHeaderFooter->rgsabound[0].cElements > 3)
    {
        lArg = 3;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_BSTR
            && V_BSTR(&var)
            && SysStringLen(V_BSTR(&var)))
        {
            *pbstrAlternate = V_BSTR(&var);
        }

        VariantInit(&var); // don't clear
    }

    // Obtain dwFlags and OR them in.
    if (psaHeaderFooter->rgsabound[0].cElements > 4)
    {
        lArg = 4;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_I4
            && V_I4(&var) != 0)
        {
            *pdwFlags |= ((DWORD) V_I4(&var));
        }

        VariantInit(&var); // don't clear
    }

    // Obtain print template string
    if (psaHeaderFooter->rgsabound[0].cElements > 5)
    {
        lArg = 5;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_BSTR
            && V_BSTR(&var)
            && SysStringLen(V_BSTR(&var)))
        {
            *pbstrTemplate = V_BSTR(&var);
        }

        VariantInit(&var); // don't clear
    }

    // Hosts may pass us a DEVNAMES, DEVMODE pair with which to seed the template.
    if (psaHeaderFooter->rgsabound[0].cElements > 7)
    {
        HGLOBAL hDN = NULL;
        HGLOBAL hDM = NULL;

        lArg = 6;
        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (    hr != S_OK
            &&  V_VT(&var) == VT_PTR
            &&  V_BYREF(&var) )
        {
            hDN = V_BYREF(&var);
        }
        VariantInit(&var);

        lArg++;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (    hr != S_OK
            &&  V_VT(&var) == VT_PTR
            &&  V_BYREF(&var) )
        {
            hDM = V_BYREF(&var);
        }
        VariantInit(&var);

        pDoc->ReplacePrintHandles(hDN,hDM);
    }

    return hr;
}



//--------------------------------------------------------------------
// FirePrintEvents
//
// This function recursively walks the frames collection of the target markup,
// and fires the OnBefore/OnAfterPrint events and sets/removes expandos important
// to the print template.  These expandos are then persisted to the temp file
// and used by the print template.
//
// Expandos set:
//      __IE_DisplayURL     The "real" (as opposed to the temp file's) URL
//      __IE_ActiveFrame    Set documents with the current element in a subframe -
//                          this is the index into the frames collection of the active
//--------------------------------------------------------------------
BOOL
FirePrintEvents(CMarkup * pMarkup, CElement * pElementCurrent, BOOL fBeforePrint)
{
    BOOL        fActiveFrame    = FALSE;
    BOOL        fExpando = pMarkup->_fExpando;
    CVariant    cvarProp;
    CElement   *pHtmlElem;
    COmWindowProxy *pWindow = pMarkup->Window();

    if (!pMarkup)
        goto Cleanup;

    // Fire our OnBeforePrint, if we are in an before print.
    if (pWindow && fBeforePrint)
        pWindow->Fire_onbeforeprint();

    pMarkup->_fExpando = TRUE;

    pHtmlElem = pMarkup->GetHtmlElement();

    {
        long cFrames;

        // Walk our frames collection, recalling this on children.
        pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION);
        cFrames = pMarkup->CollectionCache()->SizeAry(CMarkup::FRAMES_COLLECTION);

        if (cFrames > 0)
        {
            CElement *pFrame;
            long i;

            for (i=0; i<cFrames; i++)
            {
                pMarkup->CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pFrame);

                if (    pFrame
                    &&  pFrame->HasSlavePtr()   )
                {
                    if (FirePrintEvents(pFrame->GetSlavePtr()->GetMarkup(), pElementCurrent, fBeforePrint))
                    {
                        fActiveFrame = TRUE;
                        if (pHtmlElem)
                        {
                            if (fBeforePrint)
                            {
                                V_VT(&cvarProp) = VT_INT;
                                V_INT(&cvarProp) = i;
                                pHtmlElem->PrimitiveSetExpando(_T("__IE_ActiveFrame"), cvarProp);
                            }
                            else
                            {
                                V_VT(&cvarProp) = VT_BOOL;
                                pHtmlElem->PrimitiveRemoveExpando(_T("__IE_ActiveFrame"));
                            }
                            cvarProp.Clear();
                        }
                    }
                }
            }
        }
    }

    pMarkup->_fExpando = fExpando;

    // AppHack (greglett) (108234)
    // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
    // They then use this ProgressChange to do something that may result in a print.
    // Thus, multiple print dialogs appear until they crash.
    // This hack delays the onafterprint event for HtmlHelp until the template is closing.
    // If we rearchitect to remove this plumbing problem (events fired always, immediately),
    // then we should remove this hack.
    if (pWindow && !(fBeforePrint || g_fInHtmlHelp))
        pWindow->Fire_onafterprint();

    if ( !fActiveFrame &&  pElementCurrent )
        fActiveFrame = (pMarkup == pElementCurrent->GetMarkup());

Cleanup:
    return fActiveFrame;
}

//--------------------------------------------------------------------
//
//  Member : SaveToTempFile
//
//  Synopsis : Helper function, this is used both by CDoc::DoPrint
//      and by execCommand::IDM_PRINTPREVIEW
//      As a save, this function always sets _fSaveTempfileForPrinting
//      to true.
//
//--------------------------------------------------------------------
HRESULT
CDoc::SaveToTempFile(CDocument *pContextDoc,    // IN
                     LPTSTR pchTempFile,        // OUT
                     LPTSTR pchSelTempFile,     // OUT
                     DWORD dwFlags)
{
    HRESULT   hr = S_OK;
    CMarkup  *pMarkup = pContextDoc->Markup();

    Assert(pMarkup);

    BOOL      fSelection = pchSelTempFile && HasTextSelection();
    CODEPAGE  codepage = pMarkup->GetCodePage();

    Assert(pchTempFile);
    Assert(!HasTextSelection() || pchSelTempFile);

#if DBG == 1 
    // (gschneid) This hack has been moved out to fromkrnl.cxx it is needed globally now.
    // Let it here to Assert that we have the same behavior as before.
    //
    // AppHack (greglett) (108234)
    // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
    // They then use this ProgressChange to do something that may result in a print.
    // Thus, multiple print dialogs appear until they crash.
    // This hack delays the onafterprint event for HtmlHelp until the template is closing.
    // If we rearchitect to remove this plumbing problem (events fired always, immediately),
    // then we should remove this hack.
    if (_pInPlace)
    {
        BOOL fInHtmlHelp = FALSE;
        TCHAR   acClass[10];
        HWND    hwnd;

        for (hwnd = _pInPlace->_hwnd;
             hwnd && !fInHtmlHelp;
             hwnd = GetParent(hwnd))
        {
            if (GetClassName(hwnd, acClass, 10) > 0)
            {
                fInHtmlHelp = (_tcsncmp(acClass, 9, _T("HH Parent"), 9) == 0);
            }
        }
    	// (gschneid) Assert here instead of setting g_fInHtmlHelp
        Assert(fInHtmlHelp == g_fInHtmlHelp);
    }
#endif // Debug

    if (!GetTempFilename(_T("\0"), _T("htm"), pchTempFile))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (fSelection)
    {
        if (!GetTempFilename(_T("\0"), _T("htm"), pchSelTempFile))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // HACK (cthrash) We must ensure that our encoding roundtrips -- the
    // only known codepage for which this isn't guaranteed is ISO-2022-JP.
    // In this codepage, half-width katakana will be converted to full-
    // width katakana, which can lead to potentially disasterous results.
    // Swap in a more desirable codepage if we have ISO-2022-JP.
    if (codepage == CP_ISO_2022_JP)
    {
        IGNORE_HR(pMarkup->SetCodePage(CP_ISO_2022_JP_ESC1));
    }

    // HACK (cthrash/sumitc) we can't identify UTF-7 pages as such, and so
    // we can't load them in correctly.  So (for bug 46925), we save UTF-7
    // as Unicode instead.
    if (codepage == CP_UTF_7)
    {
        IGNORE_HR(pMarkup->SetCodePage(CP_UCS_2));
    }

    AssertSz(!_fSaveTempfileForPrinting, "No nested printing allowed!");
    _fSaveTempfileForPrinting = TRUE;

	_fPrintEvent = TRUE;
    FirePrintEvents(pMarkup, _pElemCurrent, TRUE);
    _fPrintEvent = FALSE;

    if (fSelection)
    {
        hr = SaveSelection(pchSelTempFile);
    }

    // Save the whole doc to the temporary file
    hr = pMarkup->Save(pchTempFile, FALSE);

/*
    if (   !(dwFlags & PRINT_WAITFORCOMPLETION)
        && pDocToPrint->_fPrintedDocSavedPlugins)
        pDocToPrint->_fPrintedDocSavedPlugins = FALSE;
*/
    _fPrintEvent = TRUE;
    FirePrintEvents(pMarkup, _pElemCurrent, FALSE);
    _fPrintEvent = FALSE;

    _fSaveTempfileForPrinting = FALSE;

    IGNORE_HR(pMarkup->SetCodePage(codepage));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetPlugInSiteForPrinting
//
//  Synopsis:   Returns COleSite which is an Adobe Acrobat plugin control for printing.
//              Only used for printing Acrobat controls which only print when inplace-active.
//
//  Returns:    S_OK    - Adobe plugin exists.  IDispatch returned.
//              S_FALSE - No Adobe plugin exists
//              (anything else) - Another call failed, returning this code.
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetPlugInSiteForPrinting(CDocument *pContextDoc, IDispatch ** ppDispatch)
{
    HRESULT         hr              = S_FALSE;
    DWORD_PTR       dwEnumCookie    = 0;
    INSTANTCLASSINFO * pici;
    COleSite *      pPlugInSite     = NULL;
    CLayout  *      pLayoutClient   = NULL;
    CLayout *       pChildLayout    = NULL;
    CElement *      pElementClient  = pContextDoc->Markup()->GetElementClient();

    if (ppDispatch)
        *ppDispatch = NULL;

    // No plugin site unless the doc's rootsite's clientsite is a
    // body element.
    if (!pElementClient || ETAG_BODY != pElementClient->Tag())
        goto Cleanup;

    pLayoutClient = pElementClient->GetUpdatedLayout();

    // Get the first child site.
    pChildLayout = pLayoutClient->GetFirstLayout(&dwEnumCookie);
    if (!pChildLayout || ETAG_EMBED != pChildLayout->Tag())
        goto Cleanup;

    // We have a plugin site.
    pPlugInSite = DYNCAST(COleSite, pChildLayout->ElementOwner());

    // Insist on the plugin site being the only site.
    pChildLayout = pLayoutClient->GetNextLayout(&dwEnumCookie);
    if (pChildLayout)
        goto Cleanup;

    pici = pPlugInSite->GetInstantClassInfo();

    if (!pici || !(pici->dwCompatFlags & COMPAT_PRINTPLUGINSITE))
        goto Cleanup;

    // Do we print this as a plugin?
    // Make sure we have the IDispatch pointer
    if (!pPlugInSite->_pDisp)
        goto Cleanup;

    if (ppDispatch)
    {
        *ppDispatch = pPlugInSite->_pDisp;
        (*ppDispatch)->AddRef();                //  Should we AddRef?  Not needed, now...
    }

    hr = S_OK;

Cleanup:
    if (pLayoutClient)
        pLayoutClient->ClearLayoutIterator(dwEnumCookie, FALSE);

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------
//
//  Member:    CDoc::GetAlternatePrintDoc
//
//  Arguments: pstrUrl (out): pointer to Url of active frame
//                            needs to be at least pdlUrlLen
//                            characters long.
//             cchUrl (in):   length of url array passed in.
//
//  Synopsis : Returns S_OK and the Url of alternate print doc if it exists.
//             Otherwise returns S_FALSE.
//
//-----------------------------------------------------------------

HRESULT CDoc::GetAlternatePrintDoc(CDocument *pContextDoc, TCHAR *pchUrl, DWORD cchUrl)
{
    CTreeNode *     pNode;
    CLinkElement *  pLink;
    HRESULT         hr = S_FALSE;
    CMarkup *       pMarkup = pContextDoc->Markup();

    if (!pchUrl || cchUrl >= pdlUrlLen)
        return E_POINTER;

    if (!pMarkup->GetHeadElement())
        return S_FALSE;

    CChildIterator ci (pMarkup->GetHeadElement());

    while ( (pNode = ci.NextChild()) != NULL )
    {
        if ( pNode->Tag() == ETAG_LINK )
        {
            LPCTSTR pstrRel = NULL, pstrMedia = NULL, pstrUrl = NULL;

            // Found a link element.  Examine it.
            pLink = DYNCAST(CLinkElement, pNode->Element());

            pstrRel = pLink->GetAArel();

            if (!pstrRel || _tcsicmp(pstrRel, _T("alternate")))
                continue;

            pstrMedia = pLink->GetAAmedia();

            if (!pstrMedia || _tcsicmp(pstrMedia, _T("print")))
                continue;

            // We found a REL=alternate MEDIA=print candidate.  Lets
            // get the url.

            pstrUrl = pLink->GetAAhref();

            if (pstrUrl && (_tcslen(pstrUrl) > 0))
            {
                TCHAR achUrl[pdlUrlLen];
                DWORD cchDummy;

                // Obtain absolute Url.
                if (FAILED(CoInternetCombineUrl(pMarkup->GetUrl(pMarkup),
                                pstrUrl,
                                URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                achUrl,
                                ARRAY_SIZE(achUrl),
                                &cchDummy,
                                0))
                  || (_tcslen(achUrl) == 0))
                {
                    // Skip problematic Urls.
                    continue;
                }

                _tcsncpy(pchUrl, achUrl, cchUrl);
                hr = S_OK;
                break;
            }
        }
    }

    RRETURN1(hr, S_FALSE);
}

#ifndef WIN16
//+---------------------------------------------------------------------------
//
//  Member:     ReadURLFromFile
//
//  Synopsis:   helper to read the URL out of a shortcut file
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT ReadURLFromFile(TCHAR *pchFileName, TCHAR **ppchURL)
{
    HRESULT  hr = E_FAIL;
    IPersistFile *pPF = 0;
    IUniformResourceLocator * pUR = 0;
    TCHAR *pchNew = 0;

    if (!*ppchURL)
    {
        goto Cleanup;
    }

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                           IID_IPersistFile, (void **)&pPF);
    if (hr)
        goto Cleanup;

    hr = pPF->Load(pchFileName,0);
    if (hr)
        goto Cleanup;

    hr = pPF->QueryInterface(IID_IUniformResourceLocator, (void**)&pUR);
    if (hr)
        goto Cleanup;

    hr = pUR->GetURL(&pchNew);
    if (!hr)
    {
        // If pre-allocated buffer is too small, re-alloc it.
        size_t  ilen  =  _tcslen(pchNew);
        if  (_tcslen(*ppchURL)  <  ilen)
        {
            delete  *ppchURL;
            *ppchURL  =  new  TCHAR[ilen  +  1];
        }
        _tcscpy(*ppchURL, pchNew);
    }

Cleanup:
    ReleaseInterface(pPF);
    ReleaseInterface(pUR);
    //delete pchNew;
    CoTaskMemFree(pchNew);
    RRETURN(hr);
}
#endif // ndef WIN16



//+----------------------------------------------------------------------
//
//  Function:   GetNextToken
//
//  Purpose:    get a "..." token from a command line
//                  allocates the outstring
//
//  Returns:    index in stringnothing
//
//-----------------------------------------------------------------------
int GetNextToken(const TCHAR *pchIn, TCHAR **ppchOut)
{
    int i = 0, j = 0, len ;

    *ppchOut = 0 ;

    if (!pchIn)
    {
        return 0;
    }

    while ( pchIn[i] && pchIn[i] != '"' )
        i++ ;

    if ( !pchIn[i] )
        return 0 ;

    j=i+1 ;
    while ( pchIn[j] && pchIn[j] != '"' )
        j++ ;

    if ( j > i + 1 )
    {
        len = j - i - 1 ;
        *ppchOut = (TCHAR*) new(Mt(GetNextToken_ppchOut)) TCHAR[(len+1)];
        if ( !(*ppchOut) )
            return 0 ;

        _tcsncpy(*ppchOut,&pchIn[i+1],len);
        (*ppchOut)[len] = '\0' ;
    }
    else
        return 0 ;

    return j ;
}

//+----------------------------------------------------------------------
//
//  Function:   ParseCMDLine
//
//  Purpose:    takes a string, checks if there is printer driver info in
//              the string, returns URL, DEVNAMES, DEVMODE, and HDC as needed
//
//  Arguments:  pchIn [IN]          -The command line string to be parsed.
//                                   Format: '"<URL>" "<Printer>" "<Driver>" "<Port"'
//              ppchURL [OUT]       - The URL found.
//              ppchPrinter [OUT]   - The Device Names (printer name)
//              ppchDriver [OUT]    - The device mode (dirver)
//              ppchPort[OUT]       - The port of the device
//
// parses a string of the form:
//      "<URL>" "<PRINTER>" "<DRIVER>" "<PORT>"
//
//-----------------------------------------------------------------------
HRESULT
ParseCMDLine(const TCHAR *pchIn,
             TCHAR ** ppchURL,
             TCHAR ** ppchPrinter,
             TCHAR ** ppchDriver,
             TCHAR ** ppchPort)
{
    HRESULT hr = S_OK;
    int     index;

    Assert(pchIn);
    Assert(ppchURL);
    Assert(ppchDriver);
    Assert(ppchPort);

    *ppchURL      = NULL;
    *ppchPrinter  = NULL;
    *ppchDriver   = NULL;
    *ppchPort     = NULL;

    index = GetNextToken(pchIn, ppchURL);

    if (index == 0)
    {
        // this was not a cmd line string, get out
        hr =  E_INVALIDARG;
        goto Cleanup;
    }

    // so we should have a filename now, but it maybe
    // an URL file, so get the data out if that is the case
    if (_tcsistr(*ppchURL, TEXT(".url")))
    {
        // we need to get the string out of the file....
        hr = ReadURLFromFile(*ppchURL, ppchURL);
        if (hr)
            goto Cleanup;
    }


    // now that we have a URL sift for the other values...
    if (pchIn[++index])
    {
        // wait...there is more
        index += GetNextToken(&pchIn[index], ppchPrinter);

        if (pchIn[++index])
        {
            // wait...there is more
            index += GetNextToken(&pchIn[index], ppchDriver);

            if (pchIn[++index])
            {
                // wait...there is more
                index += GetNextToken(&pchIn[index], ppchPort);
            }
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Helper : SetPrintCommandParameters
//
//  Synopsis : this function will take a set of paramters and bundles them into
//      the event object so that it may be passed up to the DHUI handler.  This
//      information is necessary for the DHUI handler to bring up the correct
//      template, with the correct content document, and with the correct
//      Headers and footers and initial print device.
//
//          Expando Name                                 Mapped from Parameter
//     --------------------------------------------------------------------------
//     {TEXT("__IE_TemplateUrl"),         VT_BSTR},             pstrTemplate
//     {TEXT("__IE_ParentHWND"),          VT_UINT},             parentHWND
//     {TEXT("__IE_HeaderString"),        VT_BSTR},             bstrHeader
//     {TEXT("__IE_FooterString"),        VT_BSTR},             bstrFooter
//     {TEXT("__IE_OutlookHeader"),       VT_UNKNOWN},          pStream
//     {TEXT("__IE_BaseLineScale"),       VT_INT},              iFontScale
//     {TEXT("__IE_uPrintFlags"),         VT_UINT},             uFlags
//     {TEXT("__IE_ContentDocumentUrl"),  VT_BSTR},             pstrUrlToPrint
//     {TEXT("__IE_PrinterCMD_Printer"),  VT_BSTR},             pstrPrinter
//     {TEXT("__IE_PrinterCMD_Device"),   VT_BSTR},             pstrDriver
//     {TEXT("__IE_PrinterCMD_Port"),     VT_BSTR},             pstrPort
//     {TEXT("__IE_ContentSelectionUrl"), VT_BSTR},             pstrSelectionUrl
//     {TEXT("__IE_BrowseDocument"),      VT_UNKNOWN},          pBrowseDoc
//     {TEXT("__IE_TemporaryFiles"),      VT_ARRAY/VT_EMPTY},   pvarFileArray
//     {TEXT("__IE_PrinterCMD_DevNames"), VT_I8},               hDevNames
//     {TEXT("__IE_PrinterCMD_DevMode"),  VT_I8},               hDevMode
//     {TEXT("__IE_PrintType"),           VT_BSTR},             pt
//
//  Comments on __IEDevNames/Mode: This is a windows global handle (HGLOBAL), which is
//  safe to pass cross-thread.  If we pass it as a VT_*PTR RPC will refuse to marshall.
//  VT_HANDLEs are currently always 32 bits.  The only easy option this leaves us with
//  is to pass it as a VT_I8 to fake out RPC.
//
//  As other paremeters, the HTML element of each print doc has the following attributes
//  set in FirePrintEvents.
//      __IE_DisplayURL     Original (non tempfile) URL.
//      __IE_ActiveFrame    Index into the frames collection of the active FRAME/IFRAME (if one exists).
//
//      __IE_ViewLinkSrc
//
//----------------------------------------------------------------------------

IUnknown *
SetPrintCommandParameters (HWND      parentHWND,
                           LPTSTR    pstrTemplate,
                           LPTSTR    pstrUrlToPrint,
                           LPTSTR    pstrSelectionUrl,
                           UINT      uFlags,
                           INT       iFontScale,
                           BSTR      bstrHeader,
                           BSTR      bstrFooter,
                           LPSTREAM  pStream,
                           IUnknown* pBrowseDoc,
                           VARIANT * pvarFileArray,
                           HGLOBAL   hDevNames,
                           HGLOBAL   hDevMode,
                           LPTSTR    pstrPrinter,
                           LPTSTR    pstrDriver,
                           LPTSTR    pstrPort,
                           PRINTTYPE pt)
{
    HRESULT          hr = S_OK;
    CVariant         cvarTemp;
    IHTMLEventObj  * pEventObj    = NULL;
    IHTMLEventObj2 * pEvObj2      = NULL;

    // Let's assert some input constraints:
    // (1) We should never have both a printer/driver/port and a DEVMODE/DEVNAMES specified.
    //     They specify the same thing, and we have not specified an order of priority.
    // (2) Of printer/driver/port, printer is crucial.  Ensure it is there if any are.
    // (3) DEVMODE and DEVNAMES must come in a pair.
    // (4) The TempFileArray must either be a safearray of BSTRs, or an empty variant.
    Assert(     !(pstrPrinter || pstrDriver || pstrPort)
            ||  !(hDevNames || hDevMode));
    Assert(pstrPrinter || !(pstrDriver || pstrPort));
    Assert((hDevNames && hDevMode) || !(hDevNames || hDevMode));
    Assert(     pvarFileArray
            &&  (   V_VT(pvarFileArray) == (VT_ARRAY | VT_BSTR)
                ||  V_VT(pvarFileArray) == VT_EMPTY ));

    uFlags &= PRINT_FLAGSTOPASS;        // Mask out all but flags to pass on the OLECMDID_PRINT or _PRINTPREVIEW

    // Create the event object as a holder for the parameters to pass
    //---------------------------------
    hr = CEventObj::Create(&pEventObj, NULL, NULL, NULL, FALSE, NULL, NULL);
    if (hr)
        goto Cleanup;

    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEvObj2);
    if (hr)
        goto Cleanup;


    // Set the template URL
    //---------------------------------
    if (pstrTemplate)
    {
        V_VT(&cvarTemp) = VT_BSTR;
        V_BSTR(&cvarTemp) = SysAllocString(pstrTemplate);
    }
    else
    {
        cvarTemp.Clear();
    }
    pEvObj2->setAttribute(_T("__IE_TemplateUrl"), cvarTemp, 0);
    cvarTemp.Clear();


    // Set the Parent HWND
    //---------------------------------
    V_VT(&cvarTemp) = VT_UINT;
    V_UINT(&cvarTemp) = HandleToUlong(parentHWND);
    pEvObj2->setAttribute(_T("__IE_ParentHWND"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Header string
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = bstrHeader;
    pEvObj2->setAttribute(_T("__IE_HeaderString"), cvarTemp, 0);
    cvarTemp.ZeroVariant();  //don't release the string


    // set the FooterString
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = bstrFooter;
    pEvObj2->setAttribute(_T("__IE_FooterString"), cvarTemp, 0);
    cvarTemp.ZeroVariant();  //don't release the string


    // Set the Outlook header thingy
    //---------------------------------
    V_VT(&cvarTemp) = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pStream;
    if (pStream) pStream->AddRef();
    pEvObj2->setAttribute(_T("__IE_OutlookHeader"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Base line scale factor
    //---------------------------------
    V_VT(&cvarTemp) = VT_INT;
    V_INT(&cvarTemp) = iFontScale;
    pEvObj2->setAttribute(_T("__IE_BaseLineScale"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the PrintFlags
    //---------------------------------
    V_VT(&cvarTemp) = VT_UINT;
    V_UINT(&cvarTemp) = uFlags;
    pEvObj2->setAttribute(_T("__IE_uPrintFlags"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the ContentDocumentURL (this is likely the temp file that the browse
    //  document was saved into
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrUrlToPrint);
    pEvObj2->setAttribute(_T("__IE_ContentDocumentUrl"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the SelectionURL (of it was specified)
    // (this is the temp file into which the browse selection may have been saved)
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrSelectionUrl);
    pEvObj2->setAttribute(_T("__IE_ContentSelectionUrl"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the Printer Name
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrPrinter);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Printer"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Driver
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrDriver);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Device"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Printer Port
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrPort);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Port"), cvarTemp, 0);
    cvarTemp.Clear();

    // Set a reference back to ourselves, if we have the document in memory
    //---------------------------------
    V_VT(&cvarTemp) = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pBrowseDoc;
    if (pBrowseDoc) pBrowseDoc->AddRef();
    pEvObj2->setAttribute(_T("__IE_BrowseDocument"), cvarTemp, 0);
    cvarTemp.Clear();

    // Set a reference to temp file list
    //---------------------------------
    pEvObj2->setAttribute(_T("__IE_TemporaryFiles"), *pvarFileArray, 0);

    // Set references to DEVMODE/DEVNAMES, if they have been passed
    //---------------------------------
    if (hDevNames && hDevMode)
    {
        HGLOBAL hDNOut;
        HGLOBAL hDMOut;

        if (CopyPrintHandles(hDevNames, hDevMode, &hDNOut, &hDMOut) == S_OK)
        {
            V_VT(&cvarTemp) = VT_HANDLE;
            V_BYREF(&cvarTemp) = hDNOut;
            pEvObj2->setAttribute(_T("__IE_PrinterCMD_DevNames"), cvarTemp, 0);

            V_VT(&cvarTemp) = VT_HANDLE;
            V_BYREF(&cvarTemp) = hDMOut;
            pEvObj2->setAttribute(_T("__IE_PrinterCMD_DevMode"), cvarTemp, 0);

            VariantInit(&cvarTemp);
        }
    }

    // set the PrintTemplate target type
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = ::SysAllocString(s_aachPrintType[pt]);
    pEvObj2->setAttribute(_T("__IE_PrintType"), cvarTemp, 0);
    cvarTemp.Clear();

Cleanup:
    ReleaseInterface(pEventObj);
    return pEvObj2;
}



//+---------------------------------------------------------------------------
//
//  Member:     PrintMSHTML, public
//
//  Synopsis:   Prints the passed in URL
//              called as a helper from the Shell
//
//  Returns:    like WinMain
//
//----------------------------------------------------------------------------
STDAPI_(int) PrintHTML(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpURLToPrint, int nNotUsed)
{
    HRESULT             hr = E_FAIL;
    CVariant            cvarArgIn;
    IDocHostUIHandler * pDHUIHandler = NULL;
    IOleCommandTarget * pDHUICommand = NULL;
    CVariant            cvarEmpty;
    TCHAR             * pchURL       = NULL;
    TCHAR             * pchPrinter   = NULL;
    TCHAR             * pchDriver    = NULL;
    TCHAR             * pchPort      = NULL;

    // (greglett) 01/13/2000
    // We are not loading the document and saving it to a temp file.  This causes several difference from the
    // print/print preview codepath:
    //  (1) Objects won't print.  We save them to a metafile and scale them; without the browse doc, we don't have the metafile.
    //  (2) Expressions will not persist out their current value.  Shortly, they won't execute at all in the print doc.
    //  (3) WebOC documents will be directly loaded in framesets; print/print preview will load a resource URL claiming they can't be printed.
    // This could be fixed by loading the doc, saving it to tempfile, and reloading in the template, but this would more than double the time
    // required for printing.
    // (greglett) 01/13/2000
    // We are seeing a memory leak (and crash in MSHTMDBG) calling this function with debug DLLs.
    // This leak occurs due to the dialog brought up in printing, and will occur if absolutely nothing else is done.
    // This leak does not occur if PrintHTML is called from IDM_PRINT, or some other codepath than as an API.
    // Carl and I conjecture that this leak is an unreal report produced by the way we're loaded; this could be fixed by doing the
    // above fix.

    //
    // we can ignore all the stuff that is passed in beside the lpURLToPrint...
    // which can be either
    //  : a URL file spec of the form "<URL>"
    //  : or a string containing "<URL>" "<PRINTER>" "<DRIVER>" "<PORT>"
    //
    CoInitialize(NULL);

    if (!lpURLToPrint)
        goto Cleanup;

    // Open scope for thread state manager, cets.
    {
        TCHAR               achBuff[pdlUrlLen];
        CEnsureThreadState  cets;

        if (FAILED(cets._hr))
        {
            goto Cleanup;
        }

        // dll initialization of globals
        hr = InitDocClass();
        if (hr)
            goto Cleanup;

        // If ratings are enabled, refuse to print anything we don't already know about.
        if (S_OK == AreRatingsEnabled())
        {
            // If the ratings people ever convince us to bring up some UI, this is the
            // place.  That UI can potentially also provide the option to continue as normal
            // after typing in a password.
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // The way that we do this is:
        // ---------------------------
        //  1. Create a DHUIHandler (we use the default from shdocvw since we
        //          have no host in this call.
        //  2. Parse the command line to get the URL to print, printer/port/driver.
        //  3. The DHUI handler will to the document creation, url download, and
        //          issue the print commands.
        //
        hr = THR(CoCreateInstance(CLSID_DocHostUIHandler,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDocHostUIHandler,
                                  (void**)&pDHUIHandler));
        if (hr)
            goto Cleanup;

        hr = pDHUIHandler->QueryInterface(IID_IOleCommandTarget,
                                          (void **) &pDHUICommand);
        if (hr)
            goto Cleanup;


        //
        // prepare the arg parameters for the delegation call
        //

        memset(achBuff, 0, pdlUrlLen*sizeof(TCHAR));

        if (MultiByteToWideChar(CP_ACP, 0, (const char*)lpURLToPrint, -1,achBuff, pdlUrlLen-1))
        {
            hr = ParseCMDLine(achBuff, &pchURL, &pchPrinter, &pchDriver, &pchPort);
            if (FAILED(hr))
                goto Cleanup;


            V_VT(&cvarArgIn)      = VT_UNKNOWN;
            V_UNKNOWN(&cvarArgIn) = SetPrintCommandParameters(
                                        NULL,
                                        NULL,
                                        pchURL,
                                        NULL,
                                        PRINT_WAITFORCOMPLETION,
                                        0, NULL, NULL, NULL, NULL,
                                        &cvarEmpty, NULL, NULL,
                                        pchPrinter, pchDriver, pchPort,
                                        PRINTTYPE_PRINT);
            //
            // ...and finally make the delegation call
            //
            hr = pDHUICommand->Exec(&CGID_DocHostCommandHandler,
                               OLECMDID_PRINT,
                               0,
                               &cvarArgIn,
                               NULL);
        }
    }

Cleanup:
    ReleaseInterface(pDHUIHandler);
    ReleaseInterface(pDHUICommand);

    if (pchURL)
        delete []pchURL;
    if (pchPrinter)
        delete []pchPrinter;
    if (pchPort)
        delete []pchPort;
    if (pchDriver)
        delete []pchDriver;

    CoUninitialize();

    return (hr==S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PrintHandler
//
//  Synopsis:   Prints the document.  In Template Printing, the only real work
//      that Trident needs to do is to set up the eventObject Parameters and then
//      delegate the print call to the host.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CDoc::PrintHandler( CDocument   * pContextDoc,
                    const TCHAR * pchTemplate,
                    const TCHAR * pchAlternateUrl,
                    DWORD         dwFlags,               // == PRINT_DEFAULT
                    SAFEARRAY   * psaHeaderFooter,       // == NULL
                    DWORD         nCmdexecopt,           // == 0
                    VARIANTARG  * pvarargIn,             // == NULL
                    VARIANTARG  * pvarargOut,            // == NULL
                    BOOL          fPreview)              // == FALSE
{
    Assert(pContextDoc);
    HRESULT       hr = S_OK;
    BOOL          fSelection = FALSE;
    LPTSTR        pchUrlDocToPrint = NULL;          // The content Document to flow & print
    TCHAR         achTempFileName[MAX_PATH];        // Buffer for saving tempfile
    TCHAR         achSelTempFileName[MAX_PATH];
    BSTR          bstrHeader = NULL,
                  bstrFooter = NULL,
                  bstrAlt2 = NULL,
                  bstrTemplate = NULL;
    IStream     * pStream = NULL;
    CDoc        * pDocument = NULL;
    CVariant      cvarIn;
    CVariant      cvarTempFileList;
    CVariant      cvarDevNames;                     // VT_PTR - aiming at a DEVNAMES handle
    CVariant      cvarDevMode;                      // VT_PTR - aiming at a DEVMODE handle

    // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
    // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
    //
    // The pvarargIn is only provided from the CDoc::Exec code path so that back compat delegation
    // works properly. All other code paths, leave that blank, so that we can do our "default"
    // processing
    //------------------------------------------------------------------------------------------
    if (   _pHostUICommandHandler
        && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
        && !_fOutlook98)
    {
        hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                              (fPreview ? OLECMDID_PRINTPREVIEW : OLECMDID_PRINT),
                                              nCmdexecopt,
                                              pvarargIn,
                                              pvarargOut));

        if (   hr != OLECMDERR_E_NOTSUPPORTED
            && hr != OLECMDERR_E_UNKNOWNGROUP
            && hr != E_NOTIMPL)
            goto Cleanup;  // Handled
    }

    // there are some special case printing scenarios that need to be handled directly
    //--------------------------------------------------------------------------------

    // If the print document is in memory, ask for an alternate print document.
    // But We never print alternate documents if ratings are enabled to avoid
    // ratings security holes.
    if (   !pchAlternateUrl
        && S_OK == GetAlternatePrintDoc(pContextDoc, achTempFileName, MAX_PATH)
        && (_tcslen(achTempFileName) > 0))
    {
        // assign pchAlternateUrl so that we can avoid work later, and so that
        // achTempFileName doesn't get overridden.
        pchAlternateUrl  = achTempFileName;
    }

    // But, If ratings are enabled, refuse to print anything we don't already know about.
    if (   pchAlternateUrl
        && (S_OK == AreRatingsEnabled()))
    {
        // If the ratings people ever convince us to bring up some UI, this is the
        // place.  That UI can potentially also provide the option to continue as normal
        // after typing in a password.

        hr = E_FAIL;
        goto Cleanup;
    }

    // Is this an Adobe Acrobat plugin site?
    // NB: We don't do the right thing right now if we have an alternate print doc that aims at an Acrobat page. (greglett)
    //     I don't believe that we will ever care enough to fix this.
    {
        IDispatch * pDisp = NULL;
        if (GetPlugInSiteForPrinting(pContextDoc, &pDisp) == S_OK)
        {
            if (fPreview)
            {
                hr = E_FAIL;
            }
            else
            {
                static OLECHAR * oszPrint = _T("Print");
                unsigned int    nParam = 0;
                DISPID          dispidPrint = 0;
                DISPPARAMS      DispParams;
                VARIANT         varReturn;
                EXCEPINFO       excepinfo;

                // Find out what the "Print" method's dispid is.  Should be 2 for Adobe Acrobat.
                hr = THR(pDisp->GetIDsOfNames(IID_NULL, &oszPrint, 1, g_lcidUserDefault, &dispidPrint));
                if (hr)
                    goto Cleanup;

                // Invoke the print method.  For Adobe this should return immediately after
                // posting a window message to the out-of-proc server.
                VariantInit(&varReturn);
                DispParams.cNamedArgs         = 0;
                DispParams.rgdispidNamedArgs  = NULL;
                DispParams.cArgs = 0;


                hr = THR(pDisp->Invoke(dispidPrint,
                                            IID_NULL,
                                            g_lcidUserDefault,
                                            DISPATCH_METHOD,
                                            &DispParams,
                                            &varReturn,
                                            &excepinfo,
                                            &nParam));

                VariantClear(&varReturn);
            }

            // Whether we're printing (and just printed the Adobe site) or previewing (and can't
            // preview the document) we have nothing left to do.  Head for the door.
            ReleaseInterface(pDisp);
            goto Cleanup;
        }
    }

    if (psaHeaderFooter)
    {
        hr = ParseHeaderFooterArray(psaHeaderFooter,
                               &bstrHeader,
                               &bstrFooter,
                               &pStream,
                               &bstrAlt2,
                               &dwFlags,
                               &bstrTemplate,
                               this);
        if (hr)
            goto Cleanup;

        if (!pchAlternateUrl)
             pchAlternateUrl = bstrAlt2;

        // Hosts can pass either a pchTemplate BSTR or a SAFEARRAY with their Exec request.
        // If we are examining the contents of a valid SAFEARRAY, the pchTemplate must not
        // have been passed, and will therefore be NULL.
        Assert (!pchTemplate);
        pchTemplate = bstrTemplate;
    }

    //
    // We need to handle this print operation since our host didn't do it for us
    //  and this isn't a special scenario.  What we need to do is accumulate all
    //  the data that needs to be bundled into the parameter object.
    //---------------------------------------------------------------------------
    if (!pchAlternateUrl)
    {

#if DBG==1
        // Use debug tag to keep temp files from destruction
        SetTempFileTracking(!IsTagEnabled(tagPrintKeepTempfiles));
#else
        SetTempFileTracking(TRUE);
#endif // DBG == 1

        fSelection = HasTextSelection();
        SaveToTempFile(pContextDoc, achTempFileName, (fSelection) ? achSelTempFileName : NULL);

        TransferTempFileList(&cvarTempFileList);
        SetTempFileTracking(FALSE);

        pchUrlDocToPrint = achTempFileName;

        pDocument = this;
    }
    else
    {
        pchUrlDocToPrint = (LPTSTR)pchAlternateUrl;
    }

    //
    // take all the data that we have just accumulated and create a parameter
    // object to pass to the delegation call
    //-----------------------------------------------------------------------
    V_VT(&cvarIn)      = VT_UNKNOWN;
    V_UNKNOWN(&cvarIn) = SetPrintCommandParameters(
                                GetHWND(),              // parentHWND
                                (LPTSTR)pchTemplate,    // Template
                                pchUrlDocToPrint,       // URL to Print
                                (fSelection) ? achSelTempFileName : NULL,
                                dwFlags,                // PRINT flags
                                _sBaselineFont,
                                bstrHeader,             // header string
                                bstrFooter,             // footer string
                                pStream,                // OE document stream
                                pContextDoc ? (IUnknown *)pContextDoc : (IUnknown *)this,
                                &cvarTempFileList,
                                _hDevNames,
                                _hDevMode,
                                NULL, NULL, NULL,
                                (fPreview) ? PRINTTYPE_PREVIEW : (dwFlags & PRINT_DONTBOTHERUSER) ? PRINTTYPE_PRINTNOUI : PRINTTYPE_PRINT );

    // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
    // for the second time, this time using the PrintParameter IHTMLEventObject that template printing
    // normally uses.  If we don't have a _pHostUICommandHandler, then hr will remain
    // OLECMDERR_E_NOTSUPPORTED
    //------------------------------------------------------------------------------------------
    if (   _pHostUICommandHandler
        && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
        && !_fOutlook98)
    {
        hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                              (fPreview ? OLECMDID_PRINTPREVIEW2 : OLECMDID_PRINT2),
                                              0,
                                              &cvarIn,
                                              NULL));

        if (   hr != OLECMDERR_E_NOTSUPPORTED
            && hr != OLECMDERR_E_UNKNOWNGROUP
            && hr != E_NOTIMPL)
            goto Cleanup;  // Handled
    }

    //
    // delegate the print call to our backup handler
    //-----------------------------------------------
    EnsureBackupUIHandler();
    if (_pBackupHostUIHandler)
    {
        IOleCommandTarget * pBackupHostUICommandHandler;

        hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                   (void **) &pBackupHostUICommandHandler);
        if (hr)
            goto Cleanup;

        // we are setting up a print job for the spooler, increment this count.
        _cSpoolingPrintJobs++;

        hr = pBackupHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    (fPreview  ? OLECMDID_PRINTPREVIEW : OLECMDID_PRINT),
                    0,
                    &cvarIn,
                    NULL);
        if (hr)
        {
            // there was an error, remove this job from the count
            // if there was no error, then this will be decremented when
            // the olecmdid_pagestatus (-1) comes through
            _cSpoolingPrintJobs--;
        }

        ReleaseInterface(pBackupHostUICommandHandler);
    }

Cleanup:

    SysFreeString(bstrHeader);
    SysFreeString(bstrFooter);
    SysFreeString(bstrAlt2);
    SysFreeString(bstrTemplate);
    ReleaseInterface(pStream);
    RRETURN(hr);
}

struct SExpandoInfo
{
    TCHAR * name;
#if DBG==1
    VARTYPE type;
#endif
};

#define PRINTINGDLG_STRUCT   0
#define PRINTINGDLG_HANDLE   1
#define PAGESETUP_TRANSFERTO 4
#define PRINT_TRANSFERTO     14

static const SExpandoInfo s_aPagesetupExpandos[] =
{
    {OLESTR("pagesetupStruct"), WHEN_DBG(VT_PTR)   },
    {OLESTR("hPageSetup"),      WHEN_DBG(VT_HANDLE)},
    {OLESTR("pagesetupHeader"), WHEN_DBG(VT_BSTR)  },
    {OLESTR("pagesetupFooter"), WHEN_DBG(VT_BSTR)  }
};
static const SExpandoInfo s_aPrintExpandos[] =
{
    {OLESTR("printStruct"),                     WHEN_DBG(VT_PTR)   },
    {OLESTR("hPrint"),                          WHEN_DBG(VT_HANDLE)},
    {OLESTR("printfRootDocumentHasFrameset"),   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfAreRatingsEnabled"),         WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfActiveFrame"),               WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfLinked"),                    WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfSelection"),                 WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfAsShown"),                   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfShortcutTable"),             WHEN_DBG(VT_BOOL)  },
    {OLESTR("printiFontScaling"),               WHEN_DBG(VT_INT)   },
    {OLESTR("printpBodyActiveTarget"),          WHEN_DBG(VT_UNKNOWN)  },
    {OLESTR("printToFileOk"),                   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printToFileName"),                 WHEN_DBG(VT_BSTR)  },
    {OLESTR("printfActiveFrameEnabled"),        WHEN_DBG(VT_BOOL)  }
};

HRESULT CDoc::DelegateShowPrintingDialog(VARIANT *pvarargIn, BOOL fPrint)
{
    HRESULT         hr              = OLECMDERR_E_NOTSUPPORTED;
    IHTMLEventObj2  * pEvent        = NULL;
    IHTMLEventObj   * pLocalEvent1  = NULL;
    IHTMLEventObj2  * pLocalEvent2  = NULL;
    void            * pPSD          = NULL;
    VARIANT         varHandle;
    VariantInit(&varHandle);

    // pvarargIn should be an IUnknown* to an event object
    if (    _pHostUICommandHandler
        &&  !_fOutlook98            // (41577)
        &&  pvarargIn
        &&  V_VT(pvarargIn) == VT_UNKNOWN
        &&  V_UNKNOWN(pvarargIn) )
    {
        const int           cExpandos   = (fPrint) ? PRINT_TRANSFERTO : PAGESETUP_TRANSFERTO;
        const SExpandoInfo *aExpandos   = (fPrint) ? s_aPrintExpandos : s_aPagesetupExpandos;
        BSTR    bstrAttribute   = NULL;
        int     i;
        VARIANT var;
        VariantInit(&var);

        // Check if we need to do ugly magic marshalling stuff.
        // We need to if RPC won't let us pass the PAGESETUPDLG structure.
        hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj2, (void**)&pEvent);
        if (hr)
            goto Cleanup;
        Assert(pEvent);

        // We can't use a VT_PTR cross threads due to RPC.
        // CTemplatePrinter has passed us a GHND with a struct to use in this case.
        // Check for the printing handle expando.  If it doesn't exist, assume this is a call from 
        // a host/control trying to show the dialog.  (Example: ScriptX 5.5).
        // We can't use a VT_PTR cross threads due to RPC.
        // CTemplatePrinter has passed us a GHND with a struct to use in this case.
        bstrAttribute = ::SysAllocString(aExpandos[PRINTINGDLG_HANDLE].name);
        if (!bstrAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = pEvent->getAttribute(bstrAttribute,0,&varHandle);
        ::SysFreeString(bstrAttribute);

        if (    hr 
            ||  V_VT(&varHandle) != VT_HANDLE
            ||  !V_BYREF(&varHandle) )
        {

            // This is not a dialog call coming in from CTemplatePrinter.
            // We aren't responsible for the event object created by external folks.
            // Just directly delegate the call.
            hr = _pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                (fPrint) ? OLECMDID_SHOWPRINT : OLECMDID_SHOWPAGESETUP,
                0,
                pvarargIn,
                NULL);

            goto Cleanup;
        }

        // Create a local event object to hold the expandoes.
        hr = THR(CEventObj::Create(&pLocalEvent1, this, NULL, NULL));
        if (hr)
            goto Cleanup;
        Assert(pLocalEvent1);

        hr = pLocalEvent1->QueryInterface(IID_IHTMLEventObj2, (void**)&pLocalEvent2);
        if (hr)
            goto Cleanup;
        Assert(pLocalEvent2);

        // Transfer each of the (non pointer) expandoes to the local event object
        for (i=PRINTINGDLG_HANDLE+1; i < cExpandos; i++)
        {
            // Cross thread calls to this often require sys alloc'd BSTRs (TCHARs won't cut it),
            // so we do our allocation thing.
            bstrAttribute = ::SysAllocString(aExpandos[i].name);
            if (!bstrAttribute)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pEvent->getAttribute(bstrAttribute,0,&var);
            pLocalEvent2->setAttribute(bstrAttribute,var,0);

            Check(V_VT(&var) == aExpandos[i].type);
            VariantClear(&var);
            ::SysFreeString(bstrAttribute);
        }

        // Lock the handle and pass it on as the structure pointer.
        pPSD = ::GlobalLock(V_BYREF(&varHandle));
        V_VT(&var) = VT_PTR;
        V_BYREF(&var) = pPSD;
        pLocalEvent2->setAttribute(aExpandos[PRINTINGDLG_STRUCT].name,var,0);

        // Put the event parameter in the variant
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = pLocalEvent2;

        // Delegate the call
        hr = _pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                (fPrint) ? OLECMDID_SHOWPRINT : OLECMDID_SHOWPAGESETUP,
                0,
                &var,
                NULL);
        VariantInit(&var);      // Don't clear - no extra reference

        // Transfer back the info
        for (i=PRINTINGDLG_HANDLE+1; i < cExpandos; i++)
        {
            // Cross thread calls to this often require sys alloc'd BSTRs (TCHARs won't cut it),
            // so we do our allocation thing.
            bstrAttribute = ::SysAllocString(aExpandos[i].name);
            if (!bstrAttribute)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pLocalEvent2->getAttribute(bstrAttribute,0,&var);
            pEvent->setAttribute(bstrAttribute,var,0);

            ::SysFreeString(bstrAttribute);
            VariantClear(&var);
        }
    }

Cleanup:
    if (pPSD)
        ::GlobalUnlock(V_BYREF(&varHandle));
    ReleaseInterface(pEvent);
    ReleaseInterface(pLocalEvent1);
    ReleaseInterface(pLocalEvent2);
    VariantClear(&varHandle);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     SetDocumentPrinter
//
//  Synopsis:   This API is essentially a cynical hack for naughty printers.
//              CTemplatePrinter calls this whenever instantiating a new printer.
//
//              We check the printer, and if there are any known issues with it, we go into
//              the relevant compatibility mode.  For most printers, we will remain in
//              the default WYSIWYG, purely virtual device mode.
//
//              This function could be expanded in V4 to set the DC for measuring to get any
//              necessary printer font metrics.
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
extern BOOL g_fPrintToGenericTextOnly;  // HACK for Generic/Text Only printer.

HRESULT
CElement::SetDocumentPrinter(BSTR bstrPrinterName, HDC hDC)
{    
    HRESULT hr = S_OK;
    BOOL fRelayoutRequired     = FALSE;

    if (!bstrPrinterName || !hDC)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }        

    if (!_tcsicmp(bstrPrinterName, _T("Generic / Text Only")))
    {
        fRelayoutRequired = !g_fPrintToGenericTextOnly;       
        g_fPrintToGenericTextOnly = TRUE;
    }
    else
    {
        fRelayoutRequired = g_fPrintToGenericTextOnly;
        g_fPrintToGenericTextOnly = FALSE;
    }
   
    TLS(fPrintWithNoTransparency) = FALSE;
    for (int cDriverCount = ARRAY_SIZE(s_aPrintDriverPrintModes) - 1 ; cDriverCount >= 0 ; cDriverCount--)
    {
        if (!_tcscmp(s_aPrintDriverPrintModes[cDriverCount].achDriverName,bstrPrinterName))
        {
            TLS(fPrintWithNoTransparency) = !!(s_aPrintDriverPrintModes[cDriverCount].dwPrintMode & PRINTMODE_NO_TRANSPARENCY);
            break;
        }
    }


#ifdef TOO_DANGEROUS_FOR_V3
    BOOL fUsePrinterFonts      = FALSE;
    BOOL fUsePrinterResolution = FALSE;

    // TODO (greglett) (3/27/2000)
    // The generic/text only printer does not support any TrueType fonts.  It always instantiates 60 wide monospace bitmap characters.
    // This causes *major* problems in our current architecture.  The solution is to instantiate fonts on the printer's DC, and measure
    // to the printer's resolution (other printers may follow).
    // This solution turns out to be too invasive for V3, but some provision for this will have to be made in the next version.
    // I've removed most of the other code I wrote to accomplish this in the font cache/Ccs (it would clutter the source considerably)
    
    // This printer has extremely nonstandard font support.  It may not support TrueType fonts, or whatever.
    if (fUsePrinterFonts)
    {
        // Essentially, this just means "update the printer DC".
        // It could either be null, and set for special printers, or initialized to hdcDesktop and overset for special printers.
        // The latter would be slighly better for perf - one fewer potential if in the DocInfo/Font code.
        // It should prolly be on the view instead of the TLS.
        if (TLS(hdcPrint) != hDC)
        {
            TLS(hdcPrint) = hDC;        // Change this to CreateCompatibleDC - can't store a handle that can be released by the client
            fRelayoutRequired = TRUE;
        }
    }
    // Go back to screen fonts
    else if (TLS(hdcPrint))
    {
        TLS(hdcPrint) = NULL;
        fRelayoutRequired = TRUE;
    }

    // Use the printer's resolution for measurement
    if (fUsePrinterResolution)
    {
        SIZE szInch;
        szInch.cx = GetDeviceCaps(hDC, LOGPIXELSX);
        szInch.cy = GetDeviceCaps(hDC, LOGPIXELSY);
        fRelayoutRequired |= pDoc->GetView()->SetPrinterResolution(szInch);        
    }
    // Use the virtual WYSIWYG printer
    else
    {
        fRelayoutRequired |= pDoc->GetView()->SetPrinterResolution(g_uiVirtual.GetResolution());
    }
#endif

    //  (PERF) (greglett)
    //         We really only need to relayout anything in the layoutContext of a media=print DeviceRect.
    //         This is *not* the same thing as all print media markups - media=print on the DeviceRect essentially just
    //         means "measure anything inside this as if it were going to the printer."
    //         Could we use a notification?
    if (fRelayoutRequired)
    {
        fc().ClearFontCache();      // HACK!  We manually patch the fast width cache for these fonts.
        Doc()->ForceRelayout();
    }

Cleanup:
    RRETURN(hr);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CIPrintCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CIPrintCollection::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLIPrintCollection,     // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CIPrintCollection::~CIPrintCollection()
{
    long    i;

    for (i = _aryIPrint.Size()-1; i >= 0; i--)
    {
        ReleaseInterface(_aryIPrint[i]);
    }

    _aryIPrint.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLIPrintCollection)
        {
           *ppv = (IHTMLIPrintCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------
HRESULT
CIPrintCollection::AddIPrint(IPrint *pIPrint)
{
    HRESULT hr          = S_OK;

    hr = THR(_aryIPrint.AppendIndirect(&pIPrint, NULL));
    if (hr)
        goto Cleanup;

    pIPrint->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : length
//
//  Sysnopsis :
//
//----------------------------------------------------------------
HRESULT
CIPrintCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryIPrint.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : item
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::item(long lIndex, IUnknown ** ppIPrint)
{
    HRESULT   hr   = S_OK;

    if (!ppIPrint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    (*ppIPrint) = NULL;

    if (lIndex < 0 || lIndex >= _aryIPrint.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    (*ppIPrint) = _aryIPrint[lIndex];
    (*ppIPrint)->AddRef();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : _newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryIPrint.EnumVARIANT(VT_UNKNOWN,
                                      (IEnumVARIANT**)ppEnum,
                                       FALSE,
                                       FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\custcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-12000
//
//  File:       CustCursor.cxx
//
//  Contents:   Support for custom CSS cursors
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for cbitsctx
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif


#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

extern LPCTSTR GetCursorForStyle( BYTE iIndex );
extern BOOL IsSpecialUrl(LPCTSTR pszURL);

MtDefine(CCustomCursor, StyleSheets, "CCustomCursor")

CCustomCursor::CCustomCursor(  )
{

}

HRESULT
CCustomCursor::Init(const CStr &cstr, CElement* pElement )
{
    _pElement  = pElement;
    _cstrUrl.Set( cstr );
    _cstrCurUrl.Set( cstr );
    return S_OK;
}

HRESULT
CCustomCursor::StartDownload()
{
    HRESULT hr;

    Assert( ! _pBitsCtx );
    
    if ( IsCompositeUrl( ))
    {
        _fCompositeUrl = TRUE;
        _iLastComma = -1 ;
        
        Verify( GetNextUrl( & _cstrCurUrl ));
        hr = THR( BeginDownload( &_cstrCurUrl ));
        
    }
    else
        hr = THR( BeginDownload( & _cstrUrl ));


    RRETURN( hr );
}

CCustomCursor::CCustomCursor(const CCustomCursor &PCC)
{ 
    _pElement = PCC._pElement;
    _hCursor = PCC._hCursor;           // Handle to Custom Cursor
    _pBitsCtx = PCC._pBitsCtx;
    if ( _pBitsCtx )
    {
        _pBitsCtx->AddRef();
    }
    _cstrUrl.Set( PCC._cstrUrl );
    _cstrCurUrl.Set( PCC._cstrCurUrl );
    _fCompositeUrl = PCC._fCompositeUrl;
    _iLastComma = PCC._iLastComma;
    
}

//==================================================
//
//  Get the next Url to be processed.
//  Return true - if there are more, false otherwise
//
//==================================================

BOOL
CCustomCursor::GetNextUrl(CStr* pCStr)
{
    TCHAR achUrl[4096];
    UINT i,j = 0;
    TCHAR* pstr;
    TCHAR  strComma[] = _T(",");
    TCHAR* pchNew;
    int    oldComma = _iLastComma;
    
    Assert( _fCompositeUrl );

    if ( (UINT)_iLastComma == _cstrUrl.Length() )
        return FALSE;
        
    // 
    // Scan the string looking for ","
    //
    pstr = _cstrUrl;
    pstr = & ( pstr[_iLastComma+1] ) ;
    
    for( i = _iLastComma+1. ; 
         i< _cstrUrl.Length(); 
         i++, pstr++,j++ )
    {
        achUrl[j] = (*pstr);
        if( 0==_tcsnicmp(pstr, 1, strComma, 1 ))
        {
            _iLastComma = i;
            break;
        }                        
    }
    achUrl[j]= '\0';

        
    //
    // Strip the url('...')
    //
    TCHAR* pchOld = achUrl;    
    while ( _istspace( *pchOld ) )
        pchOld++;    
    int nLenIn = ValidStyleUrl( pchOld );    
    if ( nLenIn > 0 )
    {
        StripUrl( pchOld, nLenIn, & pchNew );
    }
    else
        pchNew = pchOld;
        
    pCStr->Set( pchNew );

    //
    // This is the last available url. Update _lastComma so we know...
    //
    if ( oldComma == _iLastComma )
    {
        _iLastComma = _cstrUrl.Length();
    }

    return TRUE;
}

//=============================================================
//
//  StripUrl
//      Remove url('...') from a string
//
//
//=============================================================
VOID
CCustomCursor::StripUrl( TCHAR* pch, int nLenIn , TCHAR** pchNew )
{
    TCHAR *psz = pch+4;
    TCHAR *quote = NULL;
    TCHAR *pszEnd;
    TCHAR terminator;

    Assert( ValidStyleUrl( pch) > 0 );

    while ( _istspace( *psz ) )
        psz++;
    if ( *psz == _T('\'') || *psz == _T('"') )
    {
        quote = psz++;
    }
    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
    pszEnd = pch + nLenIn - 1;
    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
        pszEnd--;
    if ( quote && ( *pszEnd == *quote ) )
        pszEnd--;
    terminator = *(pszEnd+1);
    *(pszEnd+1) = _T('\0');

    *pchNew = psz;    
 }                           

BOOL 
IsCompositeUrl(CStr *pcstr, int startAt /*=0*/)
{
    BOOL fComplex = FALSE;
    UINT i;
    TCHAR* pstr;
    TCHAR  strComma[] = _T(",");

    // 
    // Scan the string looking for ","
    //

    for( pstr = *pcstr, i = startAt ; 
         i< pcstr->Length(); 
         i++,pstr++ )
    {
        if( 0==_tcsnicmp(pstr, 1, strComma, 1 ))
        {
            fComplex = TRUE;
            break;
        }                        
    }

    return fComplex;    

}

//------------------------------------------
//
// Is this a "composite" url ? Composite urls contain many urls
//
// eg. style="cursor:url('mything.cur'), url('custom.cur'), hand";
//
//-------------------------------------------

BOOL
CCustomCursor::IsCompositeUrl()
{
    return ::IsCompositeUrl( & _cstrUrl, _iLastComma+1 );       
}


BOOL 
CCustomCursor::IsCustomUrl( CStr* pCStr )
{
    return  ValidStyleUrl((TCHAR*) pCStr) > 0 ;
}

CCustomCursor::~CCustomCursor()
{    
    if ( _pBitsCtx )
    {
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }
}

WORD
CCustomCursor::ComputeCrc() const
{
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CCustomCursor)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

//-------------------------------------------------------------
//
// CCustomCursor::BeginDownload
// 
// Begin the Cursor download. Set the _pBitsCtx
//
//-------------------------------------------------------------

HRESULT
CCustomCursor::BeginDownload(CStr* pCStr )
{
    HRESULT hr = E_FAIL;
    CBitsCtx   *pBitsCtx = NULL;
    CMarkup    *pMarkup = _pElement->GetMarkup();
    CDoc       *pDoc = pMarkup->Doc();



    //
    // Kick off the download of the cursor file 
    //

    if ( ! IsSpecialUrl( (LPCTSTR) *pCStr ))
    {        
        hr = THR(pDoc->NewDwnCtx( DWNCTX_FILE,
                    * pCStr  ,
                    _pElement,
                    (CDwnCtx **)&pBitsCtx,
                    pMarkup->IsPendingRoot()));
                    
        if ( hr == S_OK )
        {        
            SetBitsCtx( pBitsCtx);
        }

        if (pBitsCtx)
            pBitsCtx->Release();
    }
    
    RRETURN ( hr );

}

//-------------------------------------------------------------
//
// CCustomCursor::GetCursor
// 
// Return the _hCursor. Should be null if we haven't finished downloading.
//
//-------------------------------------------------------------

HCURSOR
CCustomCursor::GetCursor()
{
    return _hCursor;
}

void 
CCustomCursor::SetBitsCtx( CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
        _pBitsCtx->Release();

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        // If the bits are here then just call OnDwnChan.
        // This will start handling the font (e.g., installing it).

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper( _pElement->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}


//*********************************************************************
//  CCustomCursor::OnChan()
//  Callback used by BitsCtx once it's downloaded our cursor file.
//*********************************************************************
void 
CCustomCursor::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    CMarkup *pMarkup = _pElement->GetMarkup();
    CDoc *pDoc;
    BOOL fError = FALSE;
    
    Assert(pMarkup);
    pDoc = pMarkup->Doc();

    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    if (ulState & DWNLOAD_COMPLETE)
    {
        LPTSTR szFile = NULL;
        if ( S_OK == _pBitsCtx->GetFile(&szFile) )
        {
            HANDLE hCur = LoadImage(NULL,
                                 szFile,
                                 IMAGE_CURSOR,
                                 0,
                                 0,
                                 LR_DEFAULTSIZE | LR_LOADFROMFILE ); 
            if ( hCur )
            {
                _hCursor = (HCURSOR) hCur;
            }
            else
            {            
                fError = TRUE;
            }
            MemFreeString( szFile );
        }
        
    }
    else
    {
        fError = ( ulState & DWNLOAD_ERROR ) ;
    }

    if ( fError && _fCompositeUrl )
    {       
        HandleNextUrl();
    }

}


VOID
CCustomCursor::HandleNextUrl()
{
    long lNewValue = 0 ;
    HRESULT hr;
    

    if ( GetNextUrl( & _cstrCurUrl ))
    {
        //
        // Need to see if this is a 'custom' url or not
        // by seeing if it matches a known property
        //            
        
        hr = LookupEnumString( & ( s_propdescCStylecursor.b) , _cstrCurUrl, & lNewValue );
        if ( hr )
        {
            BeginDownload( &_cstrCurUrl );
        }
        else
        {
            LPCTSTR idc = NULL;
        
            idc = GetCursorForStyle((BYTE)lNewValue);

            _hCursor = LoadCursorA(
                                    ((DWORD_PTR)idc >= (DWORD_PTR)IDC_ARROW) ? NULL : g_hInstCore,
                                    (char *)idc);
        
        }
    }
}

VOID    
CCustomCursor::GetCurrentUrl(CStr* pcstr) 
{
    Assert( pcstr );
    pcstr->Set( _cstrCurUrl );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\curstyle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       curstyle.cxx
//
//  Contents:   Support for CElement::CurrentStyle property
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_INTSHCUT_H_
#define X_INTSHCUT_H_
#include "intshcut.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#define _cxx_
#include "curstyle.hdl"

MtDefine(CCurrentStyle, StyleSheets, "CCurrentStyle")

#define GetUnitValueWithEnumDef(p, Uv, pDesc, enumname, nDefEnumValue) \
    GetUnitValueHelper(p, Uv, pDesc, &s_enumdesc##enumname, nDefEnumValue)
#define GetUnitValueWithEnum(p, Uv, pDesc, enumname) \
    GetUnitValueHelper(p, Uv, pDesc, &s_enumdesc##enumname)

#define NULLPTRCHECK(ptr, err)  if (!ptr) \
    {   \
        hr = err; \
        goto Cleanup;   \
    }

extern CCustomCursor* 
GetCustomCursorForNode(CTreeNode* pStartNode);
extern HRESULT 
UnMungeCustomUrl( CStr* pcstrUrlOrig, CStr* pcstrResult );

//
// marka temporary fix for SupeHot 33205. We may have deleted the elemnet
// after we get the current style the first time.
// becuase of a ref-counting problem - we can't now replace the node
// talk to jbeda and rgardner about replacing this.
//
#define NODE_IN_TREE_CHECK() CTreeNode* pNodeToUse = _pNode; \
    if( ! _pNode->IsInMarkup() ) \
    { \
        pNodeToUse = _pNode->Element()->GetFirstBranch(); \
        NULLPTRCHECK(pNodeToUse, E_POINTER) \
    }

BEGIN_TEAROFF_TABLE(CCurrentStyle, IRecalcProperty)
    TEAROFF_METHOD(CCurrentStyle, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()


//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::CCurrentStyle
//
//-------------------------------------------------------------------------
CCurrentStyle::CCurrentStyle()
{
    WHEN_DBG(_dwCookie=eCookie;)
}

HRESULT
CCurrentStyle::Init(CTreeNode *pNode)
{
    HRESULT hr;

    Assert ( pNode );

    WHEN_DBG( _fInited = TRUE; );

    _pNode = pNode;
    hr = THR( _pNode->NodeAddRef() );
    if( hr )
    {
        _pNode = NULL;
    }

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::Passivate
//
//-------------------------------------------------------------------------
void
CCurrentStyle::Passivate()
{
    AssertSz( _fInited, "Must call Init first!" );
    super::Passivate();

    if( _pNode )
    {
        // Remove myself from the node's lookaside
        if( _pNode->HasCurrentStyle() && this == _pNode->GetCurrentStyle() )
        {
            Verify( this == _pNode->DelCurrentStyle() );
        }

        _pNode->NodeRelease();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     ClassDesc
//
//-------------------------------------------------------------------------
const CCurrentStyle::CLASSDESC CCurrentStyle::s_classdesc =
{
    &CLSID_HTMLCurrentStyle,       // _pclsid
    0,                             // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                          // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                          // _pcpi
    0,                             // _dwFlags
    &IID_IHTMLCurrentStyle,        // _piidDispinterface
    &s_apHdlDescs,                 // _apHdlDesc
};



//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CCurrentStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    AssertSz(eCookie==_dwCookie, "NOT A CCurrentSTYLE");
    AssertSz( _fInited, "Must call Init first!" );

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF((CBase *)this, IPerPropertyBrowsing, NULL)
    QI_TEAROFF((CBase *)this, IRecalcProperty, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle2, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle3, NULL)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+----------------------------------------------------------------
//
//  member : get_position
//
//  Synopsis : IHTMLCurrentStyle property. returns the position enum
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_position( BSTR *pbstr )
{
    HRESULT         hr;
    stylePosition   stPos;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    stPos = pNodeToUse->GetCascadedposition();
    if(stPos == stylePositionNotSet)
        stPos = stylePositionstatic;

   // get the positioning, and then its string
    hr = THR(STRINGFROMENUM(stylePosition, stPos, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_styleFloat
//
//  Synopsis : IHTMLCurrentStyle property. returns the styleDloatenum
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_styleFloat( BSTR *pbstr )
{
    HRESULT         hr;
    styleStyleFloat stFloat;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    stFloat = pNodeToUse->GetCascadedfloat();

    if(stFloat == styleStyleFloatNotSet)
        stFloat = styleStyleFloatNone;

    hr = THR(STRINGFROMENUM(styleStyleFloat, stFloat, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_color
//
//  Synopsis : IHTMLCurrentStyle property. returns the current color
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_color(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()

    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedcolor()));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_backgroundColor
//
//  Synopsis : IHTMLCurrentStyle property. returns the current backgroundColor
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundColor(VARIANT * p)
{
    HRESULT      hr;
    CColorValue  colVal;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)
    TCHAR        szBuffer[pdlColor];


    V_VT(p) = VT_EMPTY;
    colVal = pNodeToUse->GetCascadedbackgroundColor();
    if (!colVal.IsDefined())
    {
        hr = THR(colVal.SetValue(0, FALSE, CColorValue::TYPE_TRANSPARENT));
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(colVal.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
    if(hr)
        goto Cleanup;

    V_VT(p) = VT_BSTR;
    hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontFamily
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontFamily(BSTR * p)
{
    HRESULT         hr;
    LPCTSTR         pchName;
    VARIANT         varValue;
    CElement *      pElement;

    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(p, E_POINTER)
    NULLPTRCHECK(pElement, E_FAIL)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTFACE, 
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
    {
        // Return the rendered values

        // Try to get the font name
        pchName = pNodeToUse->GetCascadedfontFaceName();
        if(!pchName  || !(*pchName))
        {
            // Get the generic family name
            pchName = pNodeToUse->GetCascadedfontFamilyName();
            if(!pchName  || !(*pchName))
            {
                *p = NULL;
                hr = S_OK;
                goto Cleanup;
            }
        }
    }
    else
    {
        Assert(V_VT(&varValue) == VT_BSTR || V_VT(&varValue) == VT_LPWSTR);
        pchName = V_BSTR(&varValue);
    }

    hr = THR(FormsAllocString(pchName, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontStyle(BSTR * p)
{
    HRESULT         hr;
    styleFontStyle  sty;
    VARIANT         varValue;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTSTYLE, 
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if( !((CVariant *)&varValue)->IsEmpty() )
        sty = (styleFontStyle) V_I4(&varValue);
    else
        sty = (pNodeToUse->GetCascadedfontItalic()) ? styleFontStyleItalic : styleFontStyleNormal;

    Assert((pNodeToUse->GetCascadedfontItalic() &&  (sty == styleFontStyleOblique || sty == styleFontStyleItalic) )
            || (!pNodeToUse->GetCascadedfontItalic() && sty != styleFontStyleOblique && sty != styleFontStyleItalic) );

    hr = THR(STRINGFROMENUM(styleFontStyle, sty, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontVariant
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontVariant(BSTR * p)
{
    HRESULT           hr;
    styleFontVariant  sty;
    VARIANT           varValue;
    CElement *        pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTVARIANT,
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    sty = (((CVariant *)&varValue)->IsEmpty())
                        ? styleFontVariantNormal
                        : (styleFontVariant) V_I4(&varValue);

    hr = THR(STRINGFROMENUM(styleFontVariant, sty, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontWeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontWeight(VARIANT * p)
{
    HRESULT      hr = S_OK;
    WORD         wWeight;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    wWeight = pNodeToUse->GetCascadedfontWeight();
    V_VT(p) = VT_I4;
    V_I4(p) = wWeight;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontSize
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontSize(VARIANT * p)
{
    HRESULT      hr = S_OK;
    LONG         lSize;
    CVariant     varValue;
    CElement   * pElement;
    CUnitValue * pVal;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Full font size information is not stored in CF so we need to walk
    //  the element tree and apply the formats
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTSIZE,
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(varValue.IsEmpty())
    {
        CDoc *pDoc = pNodeToUse->Doc();

        Assert(pDoc);

        lSize = pNodeToUse->GetCharFormat()->GetHeightInTwips(pDoc);

        lSize = MulDivQuick(lSize, 1000, TWIPS_PER_POINT);
        cuv.SetValue(lSize, CUnitValue::UNIT_POINT);

        pVal = &cuv;
    }
   else
    {
        pVal = (CUnitValue*) (void*) &V_I4(&varValue);
    }

   hr = THR(GetUnitValueWithEnum(p, *pVal,
                        &(s_propdescCCurrentStylefontSize.a), styleFontSize));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridChar
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridChar(VARIANT * p)
{
    HRESULT      hr = S_OK;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    cuv = pNodeToUse->GetCascadedlayoutGridChar();
    hr = THR(GetUnitValueWithEnumDef(p, cuv, 
                                     &(s_propdescCCurrentStylelayoutGridChar.a), styleLayoutGridChar,
                                     styleLayoutGridCharNone));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridLine
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridLine(VARIANT * p)
{
    HRESULT      hr = S_OK;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    cuv = pNodeToUse->GetCascadedlayoutGridLine();
    hr = THR(GetUnitValueWithEnumDef(p, cuv, 
                                     &(s_propdescCCurrentStylelayoutGridLine.a), styleLayoutGridLine,
                                     styleLayoutGridLineNone));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridMode
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutGridMode  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutGridMode();
        
    hr = THR(STRINGFROMENUM(styleLayoutGridMode, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_layoutGridType
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridType(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutGridType  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutGridType();
        
    hr = THR(STRINGFROMENUM(styleLayoutGridType, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_layoutFlow
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutFlow(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutFlow  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutFlow();
        
    hr = THR(STRINGFROMENUM(styleLayoutFlow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_writingMode
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_writingMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutFlow  styLF;
    styleWritingMode styWM;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    styLF = pNodeToUse->GetCascadedlayoutFlow();
    switch(styLF)
    {
    case styleLayoutFlowHorizontal:             styWM = styleWritingModeLrtb; break;
    case styleLayoutFlowVerticalIdeographic:    styWM = styleWritingModeTbrl; break;
    case styleLayoutFlowNotSet:
    default:                                    styWM = styleWritingModeNotSet; break;
    }
        
    hr = THR(STRINGFROMENUM(styleWritingMode, styWM, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CCurrentStyle::get_hasLayout(VARIANT_BOOL *pfhasLayout)
{
    HRESULT hr = S_OK;
    CElement *pElement;

    NULLPTRCHECK(pfhasLayout, E_POINTER)
    Assert(_pNode && _pNode->Element());

    pElement = _pNode->Element();
    if (pElement->HasMasterPtr())
        pElement = pElement->GetMasterPtr();

    *pfhasLayout = (pElement->ShouldHaveLayout()) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCurrentStyle::get_isBlock(VARIANT_BOOL *pfBlock)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pfBlock, E_POINTER)

    *pfBlock = pNodeToUse->Element()->IsBlockElement() ? VB_TRUE : VB_FALSE; 

    hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_zoom
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_zoom(VARIANT * p)
{
    HRESULT    hr = S_OK;
    float      flZoom = 0;
    CUnitValue cuvTemp(0, CUnitValue::UNIT_ENUM);

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    flZoom = pNodeToUse->GetFancyFormat(FCPARAM)->_flZoomFactor;

    if (flZoom !=0)
    {
        flZoom *= CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult;
        cuvTemp.SetPercent(flZoom);
    }


    hr = THR(GetUnitValueWithEnumDef(p, 
                    cuvTemp,
                    &(s_propdescCCurrentStylezoom.a), styleNormal,
                    styleNormalNormal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------
//
//  member : get_textUnderlinePosition
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textUnderlinePosition(BSTR * pbstr)
{
    HRESULT         hr;
    styleTextUnderlinePosition  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextUnderlinePosition();
        
    hr = THR(STRINGFROMENUM(styleTextUnderlinePosition, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}

//+----------------------------------------------------------------
//
//  member : get_textOverflow
//
//  Synopsis : IHTMLCurrentStyle3 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textOverflow(BSTR * pbstr)
{
    HRESULT hr;
    styleTextOverflow sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextOverflow();
        
    hr = THR(STRINGFROMENUM(styleTextOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}

//+----------------------------------------------------------------
//
//  member : get_whiteSpace
//
//  Synopsis : IHTMLCurrentStyle3 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_whiteSpace(BSTR * pbstr)
{
    HRESULT hr;
    styleWhiteSpace sty = styleWhiteSpaceNormal;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    if (pNodeToUse->GetParaFormat()->_fPreInner)
        sty = styleWhiteSpacePre;
    else if (pNodeToUse->GetCharFormat()->_fNoBreak)
        sty = styleWhiteSpaceNowrap;

    hr = THR(STRINGFROMENUM(styleWhiteSpace, sty, pbstr));
        
Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_backgroundImage
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundImage(BSTR * p)
{
    HRESULT      hr;
    long         lCookie;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lCookie = pNodeToUse->GetCascadedbackgroundImageCookie();

    if(lCookie != 0)
    {
        hr = THR(GetImageNameFromCookie(lCookie, p));
    }
    else
    {
        hr = THR(FormsAllocString(_T("none"), p));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundPositionX
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundPositionX(VARIANT * p)
{
    HRESULT         hr;
    VARIANT         varValue;
    CUnitValue      uvBkgnd;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Information is modified before being stored in CF/PF/FF so we need to walk
    //  the element tree and apply the formats in a special mode to get the original value
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_BACKGROUNDPOSX,
                ComputeFormatsType_GetValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
        uvBkgnd.SetRawValue(MAKEUNITVALUE(0, UNIT_PERCENT));
    else
        uvBkgnd = *(CUnitValue *)&V_I4(&varValue);

    hr = GetUnitValueWithEnum(p, uvBkgnd,
        &(s_propdescCCurrentStylebackgroundPositionX.a), styleBackgroundPositionX);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundPositionY
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundPositionY(VARIANT * p)
{
    HRESULT         hr;
    VARIANT         varValue;
    CUnitValue      uvBkgnd;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Information is modified before being stored in CF/PF/FF so we need to walk
    //  the element tree and apply the formats in a special mode to get the original value
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_BACKGROUNDPOSY,
                ComputeFormatsType_GetValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
        uvBkgnd.SetRawValue(MAKEUNITVALUE(0, UNIT_PERCENT));
    else
        uvBkgnd = *(CUnitValue *)&V_I4(&varValue);

    hr = GetUnitValueWithEnum(p, uvBkgnd,
        &(s_propdescCCurrentStylebackgroundPositionY.a), styleBackgroundPositionY);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundRepeat
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundRepeat(BSTR * p)
{
    HRESULT                 hr;
    BOOL                    fRepeatX, fRepeatY;
    styleBackgroundRepeat   eBr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    fRepeatX = pNodeToUse->GetCascadedbackgroundRepeatX();
    fRepeatY = pNodeToUse->GetCascadedbackgroundRepeatY();

    if(fRepeatX)
        if(fRepeatY)
            eBr = styleBackgroundRepeatRepeat;
        else
            eBr = styleBackgroundRepeatRepeatX;
    else
        if(fRepeatY)
            eBr = styleBackgroundRepeatRepeatY;
        else
            eBr = styleBackgroundRepeatNoRepeat;

    // Convert to string
    hr = THR(STRINGFROMENUM( styleBackgroundRepeat, eBr, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetCascadedborderLeftColor();
        if(!cv.IsDefined())
            cv = pNodeToUse->GetCascadedcolor();

        hr = THR(GetColorHelper(p, cv));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_borderTopColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderTopColor()));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderRightColor()));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderBottomColor()));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_borderTopStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_TOP);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_RIGHT);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_BOTTOM);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_LEFT);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderTopWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderTopWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                            &(s_propdescCCurrentStyleborderTopWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderRightWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                            &(s_propdescCCurrentStyleborderRightWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderBottomWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
            &(s_propdescCCurrentStyleborderBottomWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderLeftWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                        &(s_propdescCCurrentStyleborderLeftWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_left
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_left(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedleft(),
        &(s_propdescCCurrentStyleleft.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_right
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_right(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedright(), 
                &(s_propdescCCurrentStyleright.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_top
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_top(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedtop(),
        &(s_propdescCCurrentStyletop.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_bottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_bottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedbottom(), 
         &(s_propdescCCurrentStylebottom.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_width
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_width(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedwidth(),
        &(s_propdescCCurrentStylewidth.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_height
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_height(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedheight(),
        &(s_propdescCCurrentStyleheight.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_minHeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_minHeight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedminHeight(),
        &(s_propdescCCurrentStyleminHeight.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingLeft();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingLeft.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingTop();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingTop.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingRight();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingRight.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingBottom();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingBottom.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAlign(BSTR * p)
{
    HRESULT         hr;
    htmlBlockAlign  align;
    styleDir        dir;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    align = pNodeToUse->GetCascadedblockAlign();
    dir   = pNodeToUse->GetCascadedBlockDirection();

    // The default value is left align if LTR and right align if RTL
    if(align == htmlBlockAlignNotSet)
    {
        if(dir == styleDirLeftToRight)
           align = htmlBlockAlignLeft;
        else
           align = htmlBlockAlignRight;
    }

    hr = THR(STRINGFROMENUM(htmlBlockAlign, align, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAlignLast
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAlignLast(BSTR * p)
{
    HRESULT         hr;
    styleTextAlignLast alignLast;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    alignLast = pNodeToUse->GetCascadedtextAlignLast();

    // The default value is left align if LTR and right align if RTL
    if(alignLast == styleTextAlignLastNotSet)
    {
        alignLast = styleTextAlignLastAuto;
    }

    hr = THR(STRINGFROMENUM(styleTextAlignLast, alignLast, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textDecoration
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textDecoration(BSTR * p)
{
    HRESULT         hr;
    textDecoration  td;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    if(pNodeToUse->GetCascadedunderline())
        td = textDecorationUnderline;
    else if(pNodeToUse->GetCascadedoverline())
        td = textDecorationOverline;
    else if(pNodeToUse->GetCascadedstrikeOut())
        td = textDecorationLineThrough;
    else
        td = textDecorationNone;

    hr = THR(STRINGFROMENUM(textDecoration, td, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_accelerator
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_accelerator(BSTR * p)
{
    HRESULT         hr;
    styleAccelerator sa;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sa = pNodeToUse->GetCascadedaccelerator();

    hr = THR(STRINGFROMENUM(styleAccelerator, sa, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_display
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_display(BSTR * p)
{
    HRESULT      hr;
    styleDisplay sd;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sd = pNodeToUse->GetCascadeddisplay();
    if(sd == styleDisplayNotSet)
    {
        Assert(pNodeToUse->_iFF != -1);
        sd = pNodeToUse->_fBlockNess ? styleDisplayBlock : styleDisplayInline;
    }

    hr = THR(STRINGFROMENUM(styleDisplay, sd, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_visibility
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_visibility(BSTR * p)
{
    HRESULT         hr;
    styleVisibility sv;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sv = (styleVisibility)pNodeToUse->GetFancyFormat()->_bVisibility;
    if (sv == styleVisibilityNotSet)
        sv = styleVisibilityInherit;

    hr = THR(STRINGFROMENUM(styleVisibility, sv, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_zIndex
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_zIndex(VARIANT * p)
{
    HRESULT      hr = S_OK;
    long         lVal;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lVal = pNodeToUse->GetCascadedzIndex();
    V_I4(p) = lVal;
    V_VT(p) = VT_I4;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_letterSpacing
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_letterSpacing(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedletterSpacing(),
                    &(s_propdescCCurrentStyleletterSpacing.a), styleNormal,
                    styleNormalNormal));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_wordSpacing
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordSpacing(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedwordSpacing(),
                    &(s_propdescCCurrentStylewordSpacing.a), styleNormal,
                    styleNormalNormal));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_lineHeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_lineHeight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue valHeight = pNodeToUse->GetCascadedlineHeight();
        hr = THR(GetUnitValueWithEnumDef(p, valHeight,
                    &(s_propdescCCurrentStylelineHeight.a), styleNormal,
                    styleNormalNormal));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textIndent
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textIndent(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvIndent = pNodeToUse->GetCascadedtextIndent();

        if(uvIndent.IsNull())
            uvIndent.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvIndent,
                        &(s_propdescCCurrentStyletextIndent.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_verticalAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_verticalAlign(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvVA = pNodeToUse->GetCascadedverticalAlign();
        hr = THR(GetUnitValueWithEnum(p, uvVA, &(s_propdescCCurrentStyleverticalAlign.a), styleVerticalAlign));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundAttachment
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundAttachment(BSTR * p)
{
    HRESULT                     hr;
    styleBackgroundAttachment   eBA;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    eBA = (pNodeToUse->GetCascadedbackgroundAttachmentFixed()) ?
            styleBackgroundAttachmentFixed : styleBackgroundAttachmentScroll;

    // Convert to string
    hr = THR(STRINGFROMENUM(styleBackgroundAttachment, eBA, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
 //  member : get_marginTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginTop();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginTop.a), styleAuto, styleAutoAuto));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginRight();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginRight.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginBottom();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginBottom.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginLeft();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginLeft.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clear
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clear(BSTR * p)
{
    HRESULT       hr;
    BOOL          fClearLeft, fClearRight;
    htmlClear     eClr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    fClearLeft = pNodeToUse->GetCascadedclearLeft();
    fClearRight = pNodeToUse->GetCascadedclearRight();

    if(fClearLeft)
        if(fClearRight)
            eClr = htmlClearBoth;
        else
            eClr = htmlClearLeft;
    else
        if(fClearRight)
            eClr = htmlClearRight;
        else
            eClr = htmlClearNone;

    // Convert to string
    hr = THR(STRINGFROMENUM(htmlClear, eClr, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStyleType
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStyleType(BSTR * pbstr)
{
    HRESULT             hr;
    styleListStyleType  slt;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    slt = pNodeToUse->GetCascadedlistStyleType();

    if (slt == styleListStyleTypeNotSet)
       slt = styleListStyleTypeDisc;

    hr = THR(STRINGFROMENUM(styleListStyleType, slt, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStylePosition
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStylePosition(BSTR * pbstr)
{
    HRESULT hr;
    styleListStylePosition slsp;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    slsp = pNodeToUse->GetCascadedlistStylePosition();
    if(slsp == styleListStylePositionNotSet)
        slsp = styleListStylePositionOutSide;

    hr = THR(STRINGFROMENUM(styleListStylePosition, slsp, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStyleImage
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStyleImage(BSTR * p)
{
    HRESULT      hr;
    long         lCookie;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lCookie = pNodeToUse->GetCascadedlistImageCookie();

    if(lCookie == 0)
    {
        hr = THR(FormsAllocString(_T("none"), p));
    }
    else
    {
        hr = THR(GetImageNameFromCookie(lCookie, p));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipTop(),
                    &(s_propdescCCurrentStyleclipTop.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipRight(),
                    &(s_propdescCCurrentStyleclipRight.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipBottom(),
                    &(s_propdescCCurrentStyleclipBottom.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = (GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipLeft(),
                    &(s_propdescCCurrentStyleclipLeft.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflow(BSTR * pbstr)
{
    HRESULT         hr;
    styleOverflow   stO;
    CElement *pElement;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    pElement = pNodeToUse->Element();
    Assert(pElement);
    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        Assert(pElement);
        pNodeToUse = pElement->GetFirstBranch();
        Assert(pNodeToUse);
    }

    stO = pNodeToUse->GetCascadedoverflow();

    if(stO == styleOverflowNotSet)
    {
        CDispNode *pDispNode = NULL;
        CFlowLayout *pLayout = pNodeToUse->HasFlowLayout();
        if (pLayout)
            pDispNode = pLayout->GetElementDispNode();
    
        stO = (pLayout && pDispNode && pDispNode->IsScroller()) ? styleOverflowScroll : styleOverflowVisible;
    }

    hr = THR(STRINGFROMENUM(styleOverflow, stO, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_pageBreakBefore
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_pageBreakBefore(BSTR * pbstr)
{
    HRESULT         hr;
    stylePageBreak  stpb;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    stpb = pNodeToUse->GetCascadedpageBreakBefore();

    // When not set the default value is auto
    if(stpb == stylePageBreakNotSet)
        stpb = stylePageBreakAuto;

    hr = THR(STRINGFROMENUM(stylePageBreak, stpb, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_pageBreakAfter
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_pageBreakAfter(BSTR * pbstr)
{
    HRESULT hr;
    stylePageBreak  stpb;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    stpb = pNodeToUse->GetCascadedpageBreakAfter();

    // When not set the default value is auto
    if(stpb == stylePageBreakNotSet)
        stpb = stylePageBreakAuto;

    hr = THR(STRINGFROMENUM(stylePageBreak, stpb, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_cursor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_cursor(BSTR * pbstr)
{
    HRESULT hr = S_OK  ;
    styleCursor scCursor;
    
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    scCursor = pNodeToUse->GetCascadedcursor();
    if ( scCursor == styleCursorcustom )
    {
        CCustomCursor* pCustom = GetCustomCursorForNode(pNodeToUse);
        Assert( pCustom );
        if ( pCustom )
        {
            CStr currentUrl, cstrResult;
            BOOL fContainsPeriod = FALSE;
            pCustom->GetCurrentUrl( & currentUrl );
            TCHAR* pch = (LPTSTR) currentUrl;
            size_t nLen = pch ? _tcslen(pch) : 0 ;

            while (nLen--)
            {
                if (0==_tcsnicmp(pch, 1, _T("."), 1))
                {
                    fContainsPeriod = TRUE;
                    break;
                }
                pch++;
            }

            if ( fContainsPeriod )
            {
                hr = THR( UnMungeCustomUrl( & currentUrl, & cstrResult ));
                if ( hr )
                    goto Cleanup;

                hr = THR( cstrResult.AllocBSTR( pbstr ));                
            }
            else
            {
                hr = THR( currentUrl.AllocBSTR( pbstr ));                
            }
        }
       
    }
    else
    {
        hr = THR(STRINGFROMENUM(styleCursor, scCursor , pbstr));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_tableLayout
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_tableLayout(BSTR * pbstr)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    hr = THR(STRINGFROMENUM(styleTableLayout, pNodeToUse->GetCascadedtableLayoutEnum(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderCollapse
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderCollapse (BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleBorderCollapse, pNodeToUse->GetCascadedborderCollapseEnum(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_blockDirection
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_blockDirection(BSTR * pbstr)
{
    HRESULT hr;
    
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    
    hr = THR(STRINGFROMENUM(styleDir, pNodeToUse->GetCascadedBlockDirection(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_direction
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_direction(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    hr = THR(STRINGFROMENUM(styleDir, pNodeToUse->GetCascadeddirection(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_unicodeBidi
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_unicodeBidi(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleBidi,pNodeToUse->GetCascadedunicodeBidi(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_imeMode
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_imeMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleImeMode    sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_IMEMODE, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleImeModeNotSet, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleImeMode, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_rubyAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyAlign(BSTR * pbstr)
{
    HRESULT         hr;
    styleRubyAlign  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYALIGN, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyAlignAuto, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyAlign, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_rubyPosition
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyPosition(BSTR * pbstr)
{
    HRESULT         hr;
    styleRubyPosition  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYPOSITION, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyPositionAbove, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyPosition, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_rubyOverhang
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyOverhang(BSTR * pbstr)
{
    HRESULT            hr;
    styleRubyOverhang  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYOVERHANG, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyOverhangAuto, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyOverhang, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAutospace
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAutospace(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)
    hr = WriteTextAutospaceFromLongToBSTR(pNodeToUse->GetCascadedtextAutospace(), pbstr, TRUE);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_wordBreak
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordBreak(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleWordBreak, pNodeToUse->GetCascadedwordBreak(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_wordWrap
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordWrap(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleWordWrap, pNodeToUse->GetCascadedwordWrap(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_lineBreak
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_lineBreak(BSTR * pbstr)
{
    HRESULT            hr;
    styleLineBreak     sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlineBreak();
    hr = THR(STRINGFROMENUM(styleLineBreak, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textJustify
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textJustify(BSTR * pbstr)
{
    HRESULT          hr;
    styleTextJustify just;
    htmlBlockAlign   align;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER);

    align = pNodeToUse->GetCascadedblockAlign();

    if (align == htmlBlockAlignJustify)
    {
        just = pNodeToUse->GetCascadedtextJustify();
        if(just == styleTextJustifyNotSet)
            just = styleTextJustifyAuto;
    }
    else
    {
        just = styleTextJustifyAuto;
    }
            
    hr = THR(STRINGFROMENUM(styleTextJustify, just, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textJustifyTrim
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textJustifyTrim(BSTR * pbstr)
{
    HRESULT              hr;
    styleTextJustifyTrim trim;
    htmlBlockAlign       align;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    align = pNodeToUse->GetCascadedblockAlign();

    if (align == htmlBlockAlignJustify)
    {
        trim = pNodeToUse->GetCascadedtextJustifyTrim();
    }
    else
    {
        trim = styleTextJustifyTrimNotSet;
    }
    
    hr = THR(STRINGFROMENUM(styleTextJustifyTrim, trim, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textKashida
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textKashida(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvKashida = pNodeToUse->GetCascadedtextKashida();

        if(uvKashida.IsNull())
            uvKashida.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvKashida,
                        &(s_propdescCCurrentStyletextKashida.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textKashidaSpace
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textKashidaSpace(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvKashidaSpace = pNodeToUse->GetCascadedtextKashidaSpace();

        if(uvKashidaSpace.IsNull())
            uvKashidaSpace.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvKashidaSpace,
                        &(s_propdescCCurrentStyletextKashidaSpace.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member   : get_borderColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderColor(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_borderTopColor(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderRightColor(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderBottomColor(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderLeftColor(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member   : get_borderWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderWidth(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_borderTopWidth(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderRightWidth(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderBottomWidth(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderLeftWidth(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_padding
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_padding(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_paddingTop(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingRight(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingBottom(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingLeft(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_padding
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_margin(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_marginTop(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginRight(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginBottom(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginLeft(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member   : get_borderStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;
    LPCTSTR             strTop, strRight, strBottom, strLeft;

    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;
    
    bdrStyle = GetBorderStyle(SIDE_TOP);
    strTop = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strTop)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_RIGHT);
    strRight = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strRight)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_BOTTOM);
    strBottom = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strBottom)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_LEFT);
    strLeft = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strLeft)
        goto Error;

    hr = THR(GetCompositBSTR(strTop, strRight, strBottom, strLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    hr = E_INVALIDARG;
    goto Cleanup;
}


//+----------------------------------------------------------------
//
//  member : get_overflowX
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflowX(BSTR * pbstr)
{
    HRESULT            hr;
    styleOverflow      sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedoverflowX();
    if(sty == styleOverflowNotSet)
        sty = styleOverflowVisible;
    hr = THR(STRINGFROMENUM(styleOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_overflowY
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflowY(BSTR * pbstr)
{
    HRESULT            hr;
    styleOverflow      sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedoverflowY();
    if(sty == styleOverflowNotSet)
        sty = styleOverflowVisible;
    hr = THR(STRINGFROMENUM(styleOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textTransform
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textTransform(BSTR * pbstr)
{
    HRESULT            hr;
    styleTextTransform sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextTransform();
    if(sty == styleTextTransformNotSet)
        sty = styleTextTransformNone;
    hr = THR(STRINGFROMENUM(styleTextTransform, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarTrackColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_scrollbarTrackColor(VARIANT * p)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarTrackColor();

        if(cv.IsDefined())
        {
            hr = THR(GetColorHelper(p, cv));
        }
        else
        {
            // We return empty string if it is not set (the default is generated and dithered)
            V_VT(p) = VT_BSTR;
            V_BSTR(p) = NULL;
        }

    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarBaseColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarBaseColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarBaseColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            if(colors.IsBaseColorSet())
                cv.SetValue(colors.GetBaseColor(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_scrollbarFaceColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarFaceColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarFaceColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnFace(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbar3dLightColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbar3dLightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbar3dLightColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnLight(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarShadowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarShadowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarShadowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnShadow(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_scrollbarHighlightColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarHighlightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarHighlightColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnHighLight(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarDarkShadowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarDarkShadowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarDarkShadowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnDkShadow(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarArrowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarArrowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarArrowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnArrowColor(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_filter
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_filter(BSTR * pBStr)
{
    HRESULT hr;
    LPCTSTR szFiltStr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pBStr, E_POINTER)
    szFiltStr = pNodeToUse->GetFancyFormat(FCPARAM)->_pszFilters;
    hr = THR(FormsAllocString(szFiltStr, pBStr));
    
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : GetCompositBSTR
//
//  Synopsis : Returns the string that represents the value of a 
//               border property
//              Here are the rules:
//
//            If there is only one value, it applies to all sides. 
//            If there are two values, the top and bottom are set to the 
//              first value and the right and left are set to the second. 
//            If there are three values, the top is set to the first value, 
//              the left and right are set to the second, and the bottom is 
//              set to the third. 
//            If there are four values, they apply to the top, right, bottom,
//               and left, respectively. 
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetCompositBSTR(LPCTSTR szTop, LPCTSTR szRight, 
                               LPCTSTR szBottom, LPCTSTR szLeft, BSTR *pbstrRet)
{
    CBufferedStr    strRet; 
    BOOL            fWriteRightLeft = FALSE, fWriteBottom = FALSE, fWriteLeft = FALSE;

    Assert(pbstrRet);
    Assert(szTop && szRight && szBottom && szLeft);
    AssertSz( _fInited, "Must call Init first!" );

    *pbstrRet = NULL;

    strRet.QuickAppend(szTop);    // We always have the top string
    if ( _tcsicmp( szRight, szLeft ) )
    {   // Right and left don't match - write out everything.
        fWriteRightLeft = TRUE;
        fWriteBottom = TRUE;
        fWriteLeft = TRUE;
    }
    else
    {
        if ( _tcsicmp( szTop, szBottom ) )
        {
            fWriteBottom = TRUE;     // Top and bottom don't match
            fWriteRightLeft = TRUE;
        }
        else if ( _tcsicmp( szTop, szRight ) )
            fWriteRightLeft = TRUE;
    }

    if ( fWriteRightLeft )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szRight);    // Write out the right string (may be left also)
    }
    if ( fWriteBottom )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szBottom);    // Write out the bottom string
    }
    if ( fWriteLeft )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szLeft);    // Write out the left string
    }

    RRETURN(FormsAllocString(strRet, pbstrRet));
}


//+----------------------------------------------------------------
//
//  member : GetCompositBSTR
//
//  Synopsis : Returns the string that represents the value of a 
//               border property.
//
//              Here are the rules:
//
//            If there is only one value, it applies to all sides. 
//            If there are two values, the top and bottom are set to the 
//              first value and the right and left are set to the second. 
//            If there are three values, the top is set to the first value, 
//              the left and right are set to the second, and the bottom is 
//              set to the third. 
//            If there are four values, they apply to the top, right, bottom,
//               and left, respectively. 
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetCompositBSTR(CVariant *pvarTop, CVariant *pvarRight, 
                               CVariant *pvarBottom, CVariant *pvarLeft, BSTR *bstrStr)
{
    HRESULT     hr;

    AssertSz( _fInited, "Must call Init first!" );

    hr = THR(pvarTop->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarRight->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarBottom->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarLeft->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;
    
    hr = THR(GetCompositBSTR(V_BSTR(pvarTop), V_BSTR(pvarRight), 
        V_BSTR(pvarBottom), V_BSTR(pvarLeft), bstrStr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : ComputeLongExtraFormat
//
//  Synopsis : Looks up the variant value of a format attribute
//             and returns it as a long
//              if eCmpType is ComputeFormatsType_GetValue  only this element is searched
//              if eCmpType is ComputeFormatsType_GetInheritedValue this element
//                         and its ancestors are searched, till we meet a table cell
//              if eCmpType is ComputeFormatsType_GetInheritedIntoTableValue this element
//                         and its all ancestors are searched
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::ComputeLongExtraFormat(DISPID dispID,                // IN
                                      COMPUTEFORMATSTYPE eCmpType,  // IN
                                      long defaultVal,              // IN
                                      long *plReturn)               // OUT
{
    HRESULT         hr;
    VARIANT         varValue;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    AssertSz( _fInited, "Must call Init first!" );

    NULLPTRCHECK(pElement, E_FAIL)

    hr = THR(pElement->ComputeExtraFormat(dispID, eCmpType, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    *plReturn = (((CVariant *)&varValue)->IsEmpty())
                                             ? defaultVal
                                             : V_I4(&varValue);

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : get_behavior
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_behavior(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER);


    *pbstr = NULL;
/*
    if(_pNode->Element())
    {
        // (alexz) this is wrong because there are multiple behaviors on the element
        // also, the logic itself should be in peer.cxx, not here
        CPeerHolder * pPeerPtr = _pNode->Element()->GetPeerHolderPtr();
        if(pPeerPtr)
        {
            CPeerFactoryUrl * pFactoryURL = pPeerPtr->_pPeerFactoryUrl;
            if(pFactoryURL)
            {
                FormsAllocString(pFactoryURL->_cstrUrl, pbstr);
            }

        }
    }
*/
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//*********************************************************************
// CCurrentStyle::GetDispID, IDispatch
//    Is used to do sepecial processing for the expandos. CurrentStyle
//      expandos are not stored in object's attr array
//
//*********************************************************************

STDMETHODIMP
CCurrentStyle::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;

    AssertSz( _fInited, "Must call Init first!" );

    // We do not allow adding expandos on currentStyle
    grfdex = grfdex & (~fdexNameEnsure);

    // Now let CBase to search for the dispid
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    if(hr == DISP_E_UNKNOWNNAME)
    {
        CAttrArray          * pAA;

        // Not found, search cached propagated expandos of the node
        pAA = GetCachedExpandoAA();
        if(pAA)
        {
            hr = GetExpandoDispID(bstrName, pid, grfdex, pAA);
            if (hr == S_FALSE)
            {
                Assert(*pid == DISPID_UNKNOWN);
                hr = S_OK;
            }
        }
    }

    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}


//*********************************************************************
// CCurrentStyle::GetDispID, InvokeEx
//    Is used to do sepecial processing for the expandos. CurrentStyle
//      expandos are not stored in object's attr array
//
//*********************************************************************

HRESULT
CCurrentStyle::InvokeEx(DISPID dispid, LCID lcid, WORD wFlags,  DISPPARAMS *pdispparams,
               VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;

    AssertSz( _fInited, "Must call Init first!" );

    if (!pvarResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Fail if it is a property put
    if( wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF) )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (IsExpandoDISPID(dispid))
    {
        CAttrArray          * pAA;

        if(!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // Not found, search cached propagated expandos of the node
        pAA = GetCachedExpandoAA();

        if(!pAA)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        const CAttrValue * pAV = pAA->Find(dispid, CAttrValue::AA_Expando);

        if(pAV != NULL)
            hr = pAV->GetIntoVariant(pvarResult);
        else
            V_VT(pvarResult) = VT_NULL;
    }
    else
    {
        hr = THR(super::InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
    }


Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


//+----------------------------------------------------------------
//
//  member : GetColorHelper
//
//  Synopsis : helper function used by functions gettting from
//                  CColorValue
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetColorHelper(VARIANT * p, const CColorValue &cvCol)
{
    HRESULT      hr = S_OK;
    TCHAR        szBuffer[pdlColor];

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)
    AssertSz( _fInited, "Must call Init first!" );

    V_VT(p) = VT_BSTR;
    V_BSTR(p) = NULL;

    if(cvCol.IsDefined())
    {
        hr = THR(cvCol.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    }
    else
    {
        CColorValue cvColDef = pNodeToUse->GetCascadedcolor();

        if(cvColDef.IsDefined())
        {
            hr = THR(cvColDef.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
            if(hr)
                goto Cleanup;
            hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
        }
    }


Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : GetUnitValueHelper
//
//  Synopsis : helper function used by functions gettting from
//                  CUnitValue
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetUnitValueHelper(
    VARIANT *p,
    CUnitValue uvVal,
    const PROPERTYDESC *pDesc,
    const ENUMDESC *pEnDesc /* = NULL */,
    const int nDefEnumValue /* = 0 */)
{
    HRESULT      hr = S_OK;

    NULLPTRCHECK(p, E_POINTER)
    AssertSz( _fInited, "Must call Init first!" );

    V_VT(p) = VT_EMPTY;

    if(pEnDesc && uvVal.IsNull())
        uvVal.SetRawValue(MAKEUNITVALUE(nDefEnumValue, UNIT_ENUM));

    if(uvVal.GetUnitType() == CUnitValue::UNIT_ENUM)
    {
        if(pEnDesc == NULL)
        {
            Assert(0 && "Unexpeted Unit value of enum type");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(pEnDesc->StringFromEnum(uvVal.GetUnitValue(), &(V_BSTR(p))));
    }
    else
    {
        TCHAR        szBuffer[pdlLength];

        // We aways want the unit values to be appended, so we pass in true
        hr = THR(uvVal.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), pDesc, TRUE)) ;
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    }
    if(hr)
        goto Cleanup;
    V_VT(p) = VT_BSTR;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------
//
//  member : GetImageNameFromCookie
//
//  Synopsis : helper function that allocates and return the url corresponging
//               to given cookie enclosion the url in url("...")
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetImageNameFromCookie(long lCookie, BSTR *p)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    if(lCookie)
    {
        CImgCtx *pCtx = pNodeToUse->Doc()->GetUrlImgCtx(lCookie);
        if (!pCtx)
        {
            *p = NULL;
        }
        else
        {
            CBufferedStr szBufSt;
            szBufSt.Set(_T("url(\""));
            szBufSt.QuickAppend(pCtx->GetUrl());
            szBufSt.QuickAppend(_T("\")"));
            hr = THR(FormsAllocString(szBufSt, p));
        }
    }
    else
    {
        *p = NULL;
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : GetBorderStyle
//
//  Synopsis : Helper function
//
//+----------------------------------------------------------------

styleBorderStyle
CCurrentStyle::GetBorderStyle(int nBorder)
{
    CDocInfo            di;
    CBorderInfo         bi;
    HRESULT             hr;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    {
        CElement* pElement = pNodeToUse->Element();
        di = pElement->Doc()->_dciRender;
        pElement->GetBorderInfo(&di, &bi, FALSE, FALSE);
    }
    return ConvertFmToCSSBorderStyle(bi.abStyles[nBorder]);
Cleanup:    
    // It should never come here because calles should have called NODE_IN_TREE_CHECK()
    AssertSz(0, "Caller should have called NODE_IN_TREE_CHECK()");
    return styleBorderStyleNone;
}



//+----------------------------------------------------------------
//
//  member : GetCachedExpandoAA
//
//  Synopsis : Returns the attribute array that contains the expandos
//               propagated from the style.
//+----------------------------------------------------------------

CAttrArray *
CCurrentStyle::GetCachedExpandoAA()
{
    HRESULT hr;
    CAttrArray          * pAA = NULL;
    const CFancyFormat  * pFF;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    if(pNodeToUse->_iFF == -1)
    {
         // This makes sure ComputeFormat is called and style expandos are propagated
        pNodeToUse->GetFancyFormatIndex();
        Assert(pNodeToUse->_iFF != -1);
    }

    pFF = GetFancyFormatEx(pNodeToUse->_iFF);
    if(pFF->_iExpandos != -1)
        pAA = GetExpandosAttrArrayFromCacheEx(pFF->_iExpandos);

Cleanup:
    return pAA;
}

//+----------------------------------------------------------------------------
//
//  Function:   CCurrentStyle::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CCurrentStyle::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    switch (dispid)
    {
    case DISPID_IHTMLSTYLE_LEFT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    case DISPID_IHTMLSTYLE_TOP:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_WIDTH:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_HEIGHT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\rendstyl.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "Qi_impl.h"
#endif

#ifndef X_RENDSTYL_HXX_
#define X_RENDSTYL_HXX_
#include "rendstyl.hxx"
#endif


MtDefine(CRenderStyle, StyleSheets, "CRenderStyle")

#define _cxx_
#include "rendstyl.hdl"

const CRenderStyle::CLASSDESC CRenderStyle::s_classdesc =
{
    {
        &CLSID_HTMLRenderStyle,              // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLRenderStyle,               // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLRenderStyle,          // _apfnTearOff
};


CRenderStyle::CRenderStyle(CDoc *pDoc)
{
    _pDoc = pDoc;
    _fSendNotification = TRUE;
}

void CRenderStyle::Passivate()
{
    super::Passivate();
}

HRESULT
CRenderStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;


    if( CLSID_HTMLRenderStyle == iid ) 
    {
       *ppv = this;
       return S_OK;
    }
    
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_HTML_TEAROFF(this, IHTMLRenderStyle, NULL)
    }

    if (*ppv)
        (*(IUnknown **)ppv)->AddRef();
    else
        hr = E_NOINTERFACE;

    RRETURN(hr);
}

HRESULT
CRenderStyle::OnPropertyChange ( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    CNotification       nf;
    CTreePos* ptpFirst;
    CTreePos* ptpEnd;

    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );

    if (!_fSendNotification)
        return S_OK;

    AddRef();

    CMarkup* pMarkup = _pDoc->PrimaryMarkup();
    
    if (pMarkup && pMarkup->GetElementClient())
    {
        pMarkup->GetElementClient()->GetTreeExtent( & ptpFirst, & ptpEnd );    
        nf.MarkupRenderStyle( ptpFirst->GetCp(), ptpEnd->GetCp() - ptpFirst->GetCp() , (IHTMLRenderStyle*) this );
        pMarkup->Notify(&nf);
    }

    Release();

    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\pagescol.cxx ===
//=================================================================
//
//   File:      pagescol.cxx
//
//  Contents:   CStyleSheetPageArray class
//
//  Classes:    CStyleSheetPageArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "pagescol.hdl"

MtDefine(CStyleSheetPage, StyleSheets, "CStyleSheetPage");
MtDefine(CStyleSheetPageArray, StyleSheets, "CStyleSheetPageArray");
MtDefine(CStyleSheetPageArray_aPages_pv, CStyleSheetPageArray, "CStyleSheetPageArray::_aPages::_pv");

// Refcounting structure for page rules:
// The SS holds a ref on the page array, which holds a subref on the SS.
// The page array holds a ref on each page it contains.
// Each page holds a subref on the SS.
// Destruction is led by the SS calling Free() (usually in Passivate or
// the changing of cssText).  SS releases the array, and all internal Trident
// refs/subrefs should go away.

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetPageArray
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CStyleSheetPageArray::s_classdesc =
{
    &CLSID_HTMLStyleSheetPagesCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLStyleSheetPagesCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  Member : CTOR/DTOR
//
//+----------------------------------------------------------------
CStyleSheetPageArray::CStyleSheetPageArray( CStyleSheet *pStyleSheet ) : _pStyleSheet(pStyleSheet)
{
    Assert( _pStyleSheet );
    _pStyleSheet->SubAddRef();
}

CStyleSheetPageArray::~CStyleSheetPageArray()
{
    Assert( _pStyleSheet );
    _pStyleSheet->SubRelease();

    int i;
    int len = _aPages.Size();

    for (i=0; i < len ; ++i)
    {
        _aPages[i]->Release();
    }
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::PrivateQueryInterface
//
//----------------------------------------------------------------
HRESULT
CStyleSheetPageArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetPagesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::Append
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::Append(CStyleSheetPage * pPage, BOOL fAddToContainer)
{
    HRESULT hr = S_OK;

    if ( !pPage )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = _aPages.Append( pPage );

    if ( SUCCEEDED(hr) )
    {
        pPage->AddRef();
    }

    if (fAddToContainer && _pStyleSheet)
    {
        hr = THR(_pStyleSheet->AppendPage(pPage));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::length
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aPages.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::item
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::item(long lIndex, IHTMLStyleSheetPage **ppSSPage)
{
    HRESULT         hr;
    VARIANT         varDispatch;

    if (!ppSSPage)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppSSPage = (IHTMLStyleSheetPage *) V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheetPageArray::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    IHTMLStyleSheetPage *pIPage = NULL;

    // pvar is NULL if we're validating lIndex
    if ( pvar )    
    {
        V_VT(pvar) = VT_DISPATCH;
        V_DISPATCH(pvar) = NULL;
    }

    if ( lIndex < 0 || lIndex >= _aPages.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( pvar )
    {
        hr = _aPages[ lIndex ]->QueryInterface( IID_IHTMLStyleSheetPage, (void**)&pIPage );
        if (hr)
            goto Cleanup;

        Assert( pIPage );

        V_DISPATCH(pvar) = pIPage;
    }

Cleanup:
    RRETURN(hr);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetPage
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

const CBase::CLASSDESC CStyleSheetPage::s_classdesc =
{
    0,                          // _pclsid
    0,                          // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                       // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                       // _pcpi
    0,                          // _dwFlags
    &IID_IHTMLStyleSheetPage,   // _piidDispinterface
    &s_apHdlDescs,              // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  Member : CTOR/DTOR
//
//+----------------------------------------------------------------
CStyleSheetPage::CStyleSheetPage(CStyleSheet *pStyleSheet, CAtPageBlock *pAtPage)
{
    Assert(pStyleSheet);
    _pStyleSheet = pStyleSheet;
    _pStyleSheet->SubAddRef();

    Assert(pAtPage);
    _pAtPage = pAtPage;
    _pAtPage->AddRef();
    
    _fInvalid  = FALSE;
}



CStyleSheetPage::CStyleSheetPage( CStyleSheet *pStyleSheet, const CStr & rcstrSelector, const CStr & rcstrPseudoClass )
    : _pStyleSheet( pStyleSheet )
{
    Assert( pStyleSheet );

    HRESULT hr;
    
    _fInvalid  = FALSE;

    if(_pStyleSheet)
        _pStyleSheet->SubAddRef();

    hr = CAtPageBlock::Create(&_pAtPage);
    if (hr)
    {
        _fInvalid = TRUE;
    }
    else
    {
        _pAtPage->_cstrSelectorText.Set(rcstrSelector);
        _pAtPage->_cstrPseudoClassText.Set(rcstrPseudoClass);
    }

    _pAA = NULL;
}



CStyleSheetPage::~CStyleSheetPage()
{
    if ( _pAA )
        delete( _pAA );
    _pAA = NULL;

    if(_pStyleSheet)
    {
        _pStyleSheet->SubRelease();
        _pStyleSheet = NULL;
    }

    if (_pAtPage)
    {
        _pAtPage->Release();
        _pAtPage = NULL;
    }
}


HRESULT  
CStyleSheetPage::Create(CStyleSheetPage **ppSSP, CStyleSheet *pStyleSheet, const CStr &rcstrSelector, const CStr &rcstrPseudoClass)
{
    HRESULT hr = S_OK;

    Assert(ppSSP && pStyleSheet);
    
    if (!ppSSP || !pStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppSSP = new CStyleSheetPage(pStyleSheet, rcstrSelector, rcstrPseudoClass);
    if (!(*ppSSP) || (*ppSSP)->_fInvalid)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------
//
//  Member : PrivateQueryInterface
//
//+----------------------------------------------------------------
STDMETHODIMP
CStyleSheetPage::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDispatch ||
        iid == IID_IHTMLStyleSheetPage)
    {
        *ppv = (IHTMLStyleSheetPage *)this;
    }
    else if (iid == IID_IDispatchEx)
    {
        *ppv = (IDispatchEx *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CStyleSheetPage::get_selector(BSTR *pBSTR)
{
    HRESULT hr = E_FAIL;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if (_pAtPage)
    {
        hr = _pAtPage->_cstrSelectorText.AllocBSTR( pBSTR );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheetPage::get_pseudoClass(BSTR *pBSTR)
{
    HRESULT hr = E_FAIL;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if (_pAtPage)
    {
        hr = _pAtPage->_cstrPseudoClassText.AllocBSTR(pBSTR);
    }
    
Cleanup:
    RRETURN( SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\rulestyl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       rulestyl.cxx
//
//  Contents:   Support for Cascading Style Sheets Object Model - style object
//              that hangs off a Rule.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CRuleStyle, StyleSheets, "CRuleStyle")

//+---------------------------------------------------------------------------
//
// CRuleStyle
//
//----------------------------------------------------------------------------


//+------------------------------------------------------------------------
//
//  Member:     CRuleStyle::CRuleStyle
//
//-------------------------------------------------------------------------
CRuleStyle::CRuleStyle( CStyleSheetRule *pRule ) :
    CStyle(NULL, 0, STYLE_REFCOUNTED), _pRule(pRule)
{
    CStyleRule *pSSRule;

    if ( _pRule && NULL != (pSSRule = _pRule->GetRule() ) )
    {
        _pAA = pSSRule->GetStyleAA();
    }
    else
        _pAA = NULL;
    // CStyle::~CStyle will clean the _pAA up for us (that is, set it to
    // NULL so that CBase::~CBase will not destroy it, since it doesn't
    // belong to us.  Look at CStyle::Passivate() for more info.
}

void CRuleStyle::Passivate()
{
    if ( !_pRule )
        delete _pAA;    // We don't have a rule, this must just be junk floating around.
    _pAA = NULL;
    super::Passivate();
}

ULONG CRuleStyle::PrivateAddRef ( void )
{
    return CBase::PrivateAddRef();
}

ULONG CRuleStyle::PrivateRelease( void )
{
    return CBase::PrivateRelease();
}

const CRuleStyle::CLASSDESC CRuleStyle::s_classdesc =
{
    {
        &CLSID_HTMLRuleStyle,                // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLRuleStyle,                 // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLRuleStyle,                    // _apfnTearOff
};

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//-------------------------------------------------------------------------
HRESULT CRuleStyle::OnPropertyChange( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc )
{
    HRESULT hr = S_OK;
    
    if (TestFlag(STYLE_MASKPROPERTYCHANGES))
        goto Cleanup;

    if (_pRule && _pRule->GetStyleSheet())
    {
        CMarkup *pMarkup = _pRule->GetStyleSheet()->GetMarkup();
        if (pMarkup)
        {
            CDoc *pDoc = pMarkup->Doc();
            Assert( pDoc );

            if(dispid == DISPID_A_POSITION)
            {
                if(!pDoc->_fRegionCollection)
                {
                    DWORD dwVal;
                    CAttrArray * pAA = *GetAttrArray();  Assert(pAA);
                    BOOL fFound = pAA->FindSimple(DISPID_A_POSITION, &dwVal);

                    if(fFound && ((stylePosition)dwVal == stylePositionrelative || 
                        (stylePosition)dwVal == stylePositionabsolute))
                    {
                        pDoc->_fRegionCollection = TRUE;
                    }
                }
            }

            hr = THR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ (DISPID_A_BEHAVIOR == dispid) ) );

            goto Cleanup; // done
        }
    }
    
    hr = E_FAIL;
    goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CRuleStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
HRESULT
CRuleStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    // All interfaces derived from IDispatch must be handled
    // using the ElementDesc()->_apfnTearOff tearoff interface.
    // This allows classes such as COleSite to override the
    // implementation of IDispatch methods.

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle2, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle3, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle4, NULL)

    default:
        {
            const CLASSDESC *pclassdesc = (CLASSDESC *) BaseDesc();
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface || DispNonDualDIID(iid)) 
                && _pRule)
            {
                hr = THR(CreateTearOffThunk(this, pclassdesc->_apfnTearOff, NULL, ppv, 
                                                (void *)(CRuleStyle::s_ppropdescsInVtblOrderIHTMLRuleStyle)));
            }
        }
    }
    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

CAttrArray **CRuleStyle::GetAttrArray ( void ) const
{
    CStyleRule *pRule;

    if ( _pRule && NULL != (pRule = _pRule->GetRule() ) )
        return pRule->GetRefStyleAA();
    else
        return (CAttrArray **)&_pAA;    // In case we're disconnected, we still need to
                                        // support GetAA.  This is a junk-heap AA - it will
                                        // exist only to satisfy this requirement, and get
                                        // thrown away when we destruct.
}

CAtomTable *CRuleStyle::GetAtomTable ( BOOL *pfExpando )
{
    if ( _pRule && _pRule->GetStyleSheet() )
    {
        CStyleSheet *pSS = _pRule->GetStyleSheet();
        CDoc *pDoc = pSS->GetDocument();

        if (pfExpando)
        {
            Assert(pSS->GetMarkup());
            CMarkup *pMarkupContext = pSS->GetMarkup()->GetWindowedMarkupContext();
            Assert(pMarkupContext);
            *pfExpando = pMarkupContext->_fExpando;
        }

        Assert(pDoc);
        return &(pDoc->_AtomTable);
    }
    return NULL;
};


// We use this to make sure that if an AA is creatid during CBase::GetDispID 
// it goes to the right place (CRuleStyle does not own an AttrArray)
HRESULT
CRuleStyle::GetDispID(BSTR bstrName, DWORD grfdex,  DISPID *pid)
{
    HRESULT         hr;
    BOOL            fNoAA;
    CStyleRule    * pSSRule = NULL;

    if(!_pAA && _pRule && NULL != (pSSRule = _pRule->GetRule()))
    {
        if(pSSRule->GetStyleAA())
            _pAA = pSSRule->GetStyleAA();
    }

    fNoAA = (_pAA == NULL);

    hr = THR_NOTRACE(CBase::GetDispID(bstrName, grfdex, pid));

    if(fNoAA && _pAA)
    {
        // The AA was created by CBase::InvokeEx, make sure we save it in the owner
        if(pSSRule)
        {
            Assert(pSSRule->GetStyleAA() == NULL);
            pSSRule->SetStyleAA(_pAA);
        }
        else
        {
            delete _pAA;
            _pAA = NULL;
        }
    }

    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}



//*********************************************************************
// CRuleStyle::Invoke, IDispatch
// Provides access to properties and members of the object. We use it
//      to invalidate the caches when a expando is changed on the style
//      so that it is propagated down to the elements it affects
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//*********************************************************************

STDMETHODIMP
CRuleStyle::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT         hr = DISP_E_MEMBERNOTFOUND;
    BOOL            fNoAA;
    CStyleRule    * pSSRule = NULL;

    if(!_pAA && _pRule && NULL != (pSSRule = _pRule->GetRule()))
    {
        if(pSSRule->GetStyleAA())
            _pAA = pSSRule->GetStyleAA();
    }

    fNoAA = (_pAA == NULL);

    // Jump directly to CBase. super:: will try to invalidate a branch
    hr = THR_NOTRACE(CBase::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));

    if(fNoAA && _pAA)
    {
        // The AA was created by CBase::InvokeEx, make sure we save it in the owner
        if(pSSRule)
        {
            Assert(pSSRule->GetStyleAA() == NULL);
            pSSRule->SetStyleAA(_pAA);
        }
        else
        {
            delete _pAA;
            _pAA = NULL;
        }
    }

    if(hr)
        goto Cleanup;
    

    if( (_pRule && IsExpandoDISPID(dispidMember) && (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))) || 
        (dispidMember == DISPID_IHTMLSTYLE_REMOVEATTRIBUTE && (wFlags & DISPATCH_METHOD)) )
    {
        // Invalidate the whole document, a global style has changed
        _pRule->GetStyleSheet()->GetMarkup()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    }


Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

// All putters/getters must not have a pointer into the element attrArray is it could move.
// Use the below macros to guarantee we're pointing to a local variable which is pointing to the
// style sheet attrArray and not pointing to the attrValue on the element attrArray which can
// move if the elements attrArray has attrValues added to or deleted from.
#define GETATTR_ARRAY   \
    CAttrArray *pTempStyleAA = *GetAttrArray();

#define USEATTR_ARRAY   \
    &pTempStyleAA
    

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP
CRuleStyle::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StyleComponentHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_UrlHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StringHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Long(long v)
{
    GET_THUNK_PROPDESC
    return put_LongHelper(v, pPropDesc, GetAttrArray());
}


STDMETHODIMP
CRuleStyle::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    return put_BoolHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Variant(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_VariantHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_DataEventHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::get_Url(BSTR *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        *p = NULL;
        return S_OK;
    }
    else
        return get_UrlHelper(p, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CRuleStyle::get_StyleComponent(BSTR *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        *p = NULL;
        return S_OK;
    }
    else
        return get_StyleComponentHelper(p, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CRuleStyle::get_Property(void *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        return S_OK;
    }
    else
        return get_PropertyHelper(p, pPropDesc, USEATTR_ARRAY);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

#ifndef NO_EDIT
IOleUndoManager * 
CRuleStyle::UndoManager(void) 
{ 
    return _pRule->UndoManager(); 
}

BOOL 
CRuleStyle::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( pfTreeSync )
        *pfTreeSync = FALSE;

    return _pRule->QueryCreateUndo( fRequiresParent, fDirtyChange, NULL );
}

#endif // NO_EDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\fontface.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       FontFace.cxx
//
//  Contents:   Support for Cascading Style Sheets "@font-face"
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_T2EMBAPI_H_
#define X_T2EMBAPI_H_
#include "t2embapi.h"
#endif

#ifndef X_T2EMWRAP_HXX_
#define X_T2EMWRAP_HXX_
#include "t2emwrap.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#define _cxx_
#include "fontface.hdl"

MtDefine(CFontFace, StyleSheets, "CFontFace")
MtDefine(CFontFaceName, StyleSheets, "CFontFace::_pszFaceName")
MtDefine(CFontFaceRefStr, StyleSheets, "CFontFace::InstallFont (temp)")
extern BOOL IsScriptUrl(LPCTSTR pszURL);
extern BOOL IsSpecialUrl(LPCTSTR pszURL);

const CFontFace::CLASSDESC CFontFace::s_classdesc =
{
    {
        &CLSID_HTMLStyleFontFace,            // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleFontFace,             // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyleFontFace                 // _apfnTearOff
};


HRESULT  
CFontFace::Create(CFontFace **ppFontFace, CStyleSheet *pParentStyleSheet, LPCTSTR pcszFaceName)
{
    HRESULT    hr = S_OK;

    Assert(ppFontFace);
    Assert(pParentStyleSheet);

    *ppFontFace = new CFontFace(pParentStyleSheet, NULL);
    if (!*ppFontFace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // no need to addRef here
    hr = CAtFontBlock::Create(&((*ppFontFace)->_pAtFont), pcszFaceName);
    
Cleanup:
    RRETURN(hr);
}



HRESULT 
CFontFace::Create(CFontFace **ppFontFace, CStyleSheet *pParentStyleSheet, CAtFontBlock *pAtBlock)
{
    HRESULT    hr = S_OK;

    Assert(ppFontFace);
    Assert(pParentStyleSheet);
    Assert(pAtBlock);

    *ppFontFace = new CFontFace(pParentStyleSheet, pAtBlock);
    if (!*ppFontFace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}



CFontFace::CFontFace(
    CStyleSheet *pParentStyleSheet,
    CAtFontBlock *pAtFont
    )
    : 
    _pParentStyleSheet( pParentStyleSheet ),
    _pAtFont(pAtFont)
{
    _pszInstalledName[0] = 0;
    _hEmbeddedFont = NULL;
    _fFontLoadSucceeded = FALSE;
    _fFontDownloadInterrupted = FALSE;
    _fFontDownloadStarted = FALSE;
    _pBitsCtx = NULL;
    _pAA = NULL;
    _dwStyleCookie = 0;
    if (_pAtFont)
    {
        _pAtFont->AddRef();
    }
}


CFontFace::~CFontFace()
{
#ifndef NO_FONT_DOWNLOAD
    GWKillMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0);
    if ( _hEmbeddedFont )
    {
        ULONG ulStatus;

        if ( E_NONE != T2DeleteEmbeddedFont( _hEmbeddedFont, 0, &ulStatus ) )
        {
            Assert( "Couldn't unload downloaded font!" );
        }
    }

    SetBitsCtx(NULL);
#endif
    if (_pAtFont)
    {
        _pAtFont->Release();
    }
}



HRESULT CFontFace::SetProperty( const TCHAR *pcszPropName, const TCHAR *pcszValue )
{
    HRESULT hr = S_OK;

    if ( !_tcslen( pcszPropName ) )
        return S_FALSE;

    const PROPERTYDESC * found = FindPropDescForName ( pcszPropName );

    if ( !StrCmpIC( pcszPropName, _T( "font-family" ) ) )
    {
        if ( _pAtFont->_pszFaceName )
          MemFree( _pAtFont->_pszFaceName ); //free
        _pAtFont->_pszFaceName = (TCHAR *)MemAlloc(Mt(CFontFaceName), (_tcslen( pcszValue ) + 1)*sizeof(TCHAR) );
        if ( _pAtFont->_pszFaceName )
        {
            _tcscpy( _pAtFont->_pszFaceName, pcszValue );
            TCHAR *pszFace = _pAtFont->_pszFaceName;
            while ( *pszFace && ( *pszFace != _T(',') ) )
                pszFace++;
            if ( *pszFace == _T(',') )
            {
                *pszFace-- = _T('\0');
                while ( ( pszFace >= _pAtFont->_pszFaceName ) && _istspace( *pszFace ) )
                    *pszFace-- = _T('\0');
            }
        }
        goto Cleanup;
    }

    if ( found && ( found->pfnHandleProperty ) )
    {
        // Try and parse attribute
#ifdef WIN16
        hr = THR ( (found->pfnHandleProperty)((PROPERTYDESC *)found,
            HANDLEPROP_SETHTML,
            (CVoid *)pcszValue, NULL, (CVoid *)GetAA() ) );
#else
        hr = THR ( CALL_METHOD( found, found->pfnHandleProperty, (
            HANDLEPROP_SETHTML, /*NOTE: This opcode may be incorrect when we expose these through the OM. */
            (CVoid *)pcszValue, NULL, (CVoid *)GetAA() ) ));
#endif
        if (!hr)
        {
            // got a match
            goto Cleanup;
        }
    }

    // TODO: Need to handle expandos - either here, or (more preferably) in a generic fashion in the CAtBlockHandler code.

Cleanup:
    RRETURN1(hr, S_FALSE);
}

#ifdef NO_FONT_DOWNLOAD
HRESULT CFontFace::StartDownload( void )
{
    return S_OK;
}

#else // NO_FONT_DOWNLOAD

static inline void FillClassSpec(uCLSSPEC *pclasspec)
{
    pclasspec->tyspec = TYSPEC_FILENAME;
    pclasspec->tagged_union.pFileName = _T("{630b1da0-b465-11d1-9948-00c04f98bbc9}");
}

HRESULT CFontFace::StartDownload( void )
{
    CDoc *pDoc = _pParentStyleSheet->GetElement()->Doc();
    QUERYCONTEXT qcNotUsed;
    uCLSSPEC classpec;
    LPCTSTR  pcszURL = NULL;
    HRESULT hr = E_FAIL;
    extern DYNPROC g_dynprocT2EmbedLoadFont;

    Assert(!_fFontDownloadStarted);
    _fFontDownloadStarted = TRUE;
    //
    // Do we have a source URL from which to download?
    //
    if ( !(*GetAA()) || !(*GetAA())->FindString ( DISPID_A_FONTFACESRC, &pcszURL ) )
        goto Cleanup;   // No SRC!
    
    //
    // First check if t2embed has already on the system.  Note that the user
    // may have independently loaded t2embed.dll, in which case we just use
    // that version.  Otherwise we would require a cabinet containing other
    // features the user may not need.
    //

    hr = THR_NOTRACE(LoadProcedure(&g_dynprocT2EmbedLoadFont));
    if (FAILED(hr))
    {
        FillClassSpec(&classpec);
        hr = THR(FaultInIEFeatureHelper(pDoc->GetHWND(), &classpec, &qcNotUsed, FIEF_FLAG_PEEK) );
    }
    
    //
    // If it has already been downloaded, then ask t2 to bring in the font.
    //
    if (hr == S_OK)
    {
        hr = THR(StartFontDownload());
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED))
    {
        hr = GWPostMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0, FALSE, "CFontFace::FaultInT2");
    }
    else
        hr = S_FALSE;

Cleanup:    
    RRETURN2(hr, S_FALSE, E_FAIL);
    }

void CFontFace::FaultInT2(DWORD_PTR dwContext)
{
    CDoc *pDoc = _pParentStyleSheet->GetElement()->Doc();
    uCLSSPEC classpec;
    HRESULT hr = S_OK;
    ULONG   cDie;
    
    FillClassSpec(&classpec);

    _fFontDownloadInterrupted = FALSE;
    cDie = pDoc->_cDie;
    pDoc->SubAddRef();
    PrivateAddRef();
    
    hr = THR(FaultInIEFeatureHelper(pDoc->GetHWND(), &classpec, NULL, 0));

    //
    // Irrespective of what Fault* returns we have to restart rendering! However
    // if the document cycled thru a UnloadContents then we are not interested
    // either enabling rendering or in starting font download.
    //
    if (cDie == pDoc->_cDie)
    {
        //
        // If the style element was blown away (say thru OM timer event) while
        // we were downloading (only the element was blown away -- the doc was
        // left intact and hence was not caught in the check for cDie)
        // then do not do anything since its pointless!
        //
        if (!_fFontDownloadInterrupted)
        {
            //
            // If we successfully downloaded the t2 dll, then we should proceed with
            // the download of the font.
            //
            if (S_OK == hr)
            {
                hr = StartFontDownload();
            }
        }
    }
    
    // And yes, don't leak anything :-)
    PrivateRelease();
    pDoc->SubRelease();
}

HRESULT CFontFace::StartFontDownload( void )
{
    CBitsCtx   *pBitsCtx = NULL;
    HRESULT     hr = E_FAIL;
    LPCTSTR     pcszURL = NULL;
    CElement   *pElement = _pParentStyleSheet->GetElement();
    BOOL        fAllow;
    TCHAR      *pchFontSrcURL = NULL;
    CMarkup    *pMarkup = pElement->GetMarkup();
    CDoc       *pDoc = pMarkup->Doc();

    if (!(*GetAA()) || !(*GetAA())->FindString ( DISPID_A_FONTFACESRC, &pcszURL ) )
        goto Cleanup;
    
    _fFontLoadSucceeded = FALSE;

    hr = THR(pMarkup->ProcessURLAction(
            URLACTION_HTML_FONT_DOWNLOAD,
            &fAllow));
    if (hr)
        RRETURN(hr);

    if (!fAllow)
        RRETURN(E_ACCESSDENIED);

    if (_pParentStyleSheet->GetAbsoluteHref())
    {
        hr = ExpandUrlWithBaseUrl(_pParentStyleSheet->GetAbsoluteHref(),
                                  pcszURL,
                                  &pchFontSrcURL);
        if (hr)
            goto Cleanup;
    }

    if ( ! IsScriptUrl( _pParentStyleSheet->GetAbsoluteHref() ? pchFontSrcURL : pcszURL ))
    {
        // Kick off the download of the imported sheet
        hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE,
                    _pParentStyleSheet->GetAbsoluteHref() ? pchFontSrcURL : pcszURL,
                    pElement,
                    (CDwnCtx **)&pBitsCtx,
                    pMarkup->IsPendingRoot()));
        if ( hr == S_OK )
        {
            // For rendering purposes, having an @imported sheet pending is just like having
            // a linked sheet pending.
            pDoc->EnterStylesheetDownload(&_dwStyleCookie);
            
            // Give ownership of bitsctx to the newly created (empty) stylesheet, since it's
            // the one that will need to be filled in by the @import'ed sheet.
            SetBitsCtx( pBitsCtx );
        }
    }
    
    if (pBitsCtx)
        pBitsCtx->Release();

Cleanup:
    if (pchFontSrcURL)
        MemFreeString(pchFontSrcURL);
    return hr;
}

//*********************************************************************
//  CFontFace::SetBitsCtx()
//  Sets ownership and callback information for a BitsCtx.  A FontFace
//  will have a non-NULL BitsCtx if it's being downloaded.
//*********************************************************************
void CFontFace::SetBitsCtx( CBitsCtx * pBitsCtx )
{
    CElement *pElement = _pParentStyleSheet->GetElement();

    if (_pBitsCtx)
        _pBitsCtx->Release();

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        // If the bits are here then just call OnDwnChan.
        // This will start handling the font (e.g., installing it).

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pElement->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//*********************************************************************
//  CFontFace::OnChan()
//  Callback used by BitsCtx once it's downloaded our font file.
//*********************************************************************
void CFontFace::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    CMarkup *pMarkup = _pParentStyleSheet->GetElement()->GetMarkup();
    CDoc *pDoc;
    
    Assert(pMarkup);
    pDoc = pMarkup->Doc();

    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    if (ulState & DWNLOAD_COMPLETE)
    {
        LPTSTR szFile = NULL;
        if ( S_OK == _pBitsCtx->GetFile(&szFile) )
        {
            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(pMarkup->IsPendingRoot(), _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
            
            Assert( szFile );       // GetFile should always yield a valid string if it rets S_OK

            if ( S_OK == InstallFont( szFile ) )
            {
                // (this is not always a stable moment)
                IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */FALSE) );
            }
            else
                pDoc->Invalidate(); // So we'll update the screen.
            MemFreeString( szFile );
        }
    }
    else
    {
        pDoc->Invalidate(); // So we'll update the screen.
        TraceTag((tagError, "CFontFace::OnChan bitsctx failed to complete!"));
    }
}

unsigned long __cdecl FontReadCallback( void *pvFile, void *pvData, const unsigned long ulBytes )
{
    HFILE hFile = (HFILE)(DWORD_PTR)pvFile;
    return ( _lread( hFile, pvData, ulBytes ) );
}

//*********************************************************************
//  CFontFace::InstallFont()
//      Method used to load up the font embedding DLL and attempt to
//  install the font.
//*********************************************************************
HRESULT CFontFace::InstallFont( LPCTSTR pcszPathname )
{
    HRESULT hr = S_FALSE;
    HANDLE hFile = CreateFile( pcszPathname, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    hr = S_FALSE;   // Still haven't loaded the font.
    if ( hFile != INVALID_HANDLE_VALUE)
    {
        TTLOADINFO ttli;
        CMarkup *pMarkup = _pParentStyleSheet->GetElement()->GetMarkupPtr();
        
        LPCTSTR pcszDocUrl = CMarkup::GetUrl(pMarkup);
        if (IsSpecialUrl(pcszDocUrl))
        {
            LPCTSTR pchCreatorUrl = pMarkup->GetAAcreatorUrl();
            if (pchCreatorUrl)
            {
                pcszDocUrl = pchCreatorUrl;
            }
        }

        CookupInstalledName(pMarkup);

        ttli.usStructSize = sizeof(TTLOADINFO);

        hr = THR(MemAllocString(Mt(CFontFaceRefStr), pcszDocUrl, &ttli.pusRefStr ) );
        if ( hr == S_OK )
        {
            hr = S_FALSE;   // Still haven't finished.
            ttli.usRefStrSize = _tcslen( pcszDocUrl ) + 1;
            ULONG ulPrivStatus, ulStatus;
            char acMacName[ LF_FACESIZE * 2 + 1 ];

            WideCharToMultiByte( CP_ACP, 0, _pszInstalledName, -1, acMacName, LF_FACESIZE*2, NULL, NULL );

            switch ( T2LoadEmbeddedFont( &_hEmbeddedFont, TTLOAD_PRIVATE, &ulPrivStatus, LICENSE_DEFAULT, &ulStatus,
                                                        FontReadCallback, (void *)hFile, _pszInstalledName,
                                                        acMacName, &ttli ) )
            {
            case E_FONTNAMEALREADYEXISTS:   // We must have already downloaded this font for this document.
            case E_FONTALREADYEXISTS:       // (bug # 95655)
                _hEmbeddedFont = NULL;
                // Intentional fall-through
            case E_NONE:
                // Whoo-hoo!  The font has been loaded!
                _fFontLoadSucceeded = TRUE;
                hr = S_OK;
            }
            MemFreeString( ttli.pusRefStr );
        }
        CloseHandle( hFile );
    }
    RRETURN1( hr, S_FALSE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontFace::CookupInstalledName
//
//  Synopsis:   Populate CFontFace::_pszInstalledName
//
//  Note:       Emperically we have determined that AddFontResource will fail
//              if the internal name is too long.  For these systems, we'll use
//              the old IE4-style internal name, which will fail if we have a
//              non-ASCII Unicode value.  Most fonts have an ASCII external
//              name, so this isn't usually a problem.
//
//-----------------------------------------------------------------------------

#define SIZEOF_COLOR 7 // syntax for <c>: #rrggbb

void
CFontFace::CookupInstalledName( void * p )
{
    TCHAR szTmpPtr[ 20 ];   // We use the document ptr as a hash on the installed name, so
                            // font-faces can be named the same across pages without conflict.
                            // We also use the current process ID to avoid naming conflicts
                            // across processes - although this is highly improbably, it is
                            // possible.

    if (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS && g_dwPlatformVersion == 0x00040000)
    {
        const size_t cch = LF_FACESIZE - SIZEOF_COLOR - SIZEOF_COLOR - 1;
        _tcsncpy( _pszInstalledName, _pAtFont->_pszFaceName, cch );
        _pszInstalledName[ cch ] = _T('\0');

        // Add the document pointer.

        Format( 0, szTmpPtr, 19, _T("<0c>"), p );
        _tcscat( _pszInstalledName, szTmpPtr );
    }
    else
    {
        DWORD dwFontNameHash;

        //
        // Embedded fonts are saved under a generated name which is a hash of a bunch of things.
        // First, there is a hash of the original font-name itself.  Then there is 
        // the location of the pDoc object (in Hex), and then the process Id.  The latter
        // two are added to prevent different pages from sharing fonts, as this would be a security
        // flaw.  The font name is hashed so that if two fonts differ only at the end, we still
        // register them under different names.
        //

        // NOTE (paulpark) Eventually, this code will break since we are relying on a hash.
        // If two (different) font-names hash to the same value, this will break, and we will 
        // display something in an incorrect font.

        dwFontNameHash = HashString( _pAtFont->_pszFaceName, _tcslen(_pAtFont->_pszFaceName), 0 );
        Format( 0, szTmpPtr, 19, _T("<0x>"), dwFontNameHash );
        _tcscpy( _pszInstalledName, szTmpPtr );

        // Run it twice to get a (sort-of) 64 bit hash.

        dwFontNameHash = HashString( _pAtFont->_pszFaceName, _tcslen(_pAtFont->_pszFaceName), dwFontNameHash );
        Format( 0, szTmpPtr, 19, _T("<0x>"), dwFontNameHash );
        _tcscat( _pszInstalledName, szTmpPtr );
        // Add the document pointer.

        Format( 0, szTmpPtr, 19, _T("<0x>"), p );
        _tcscat( _pszInstalledName, szTmpPtr );
    }

    // Add the process ID just to be safe.

    Format( 0, szTmpPtr, 19, _T("<0c>"), GetCurrentProcessId() );
    _tcscat(_pszInstalledName, szTmpPtr );

    // Make sure we don't overflow static buffer
    AssertSz(_tcsclen(_pszInstalledName) < LF_FACESIZE, "String length > LF_FACESIZE");
    _pszInstalledName[LF_FACESIZE - 1] = 0;
}


void
CFontFace::StopDownloads()
{
    GWKillMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0);
    _fFontDownloadInterrupted = TRUE;
}

#endif // !NO_FONT_DOWNLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\rulescol.cxx ===
//=================================================================
//
//   File:      rulescol.cxx
//
//  Contents:   CStyleSheetRuleArray class
//
//  Classes:    CStyleSheetRuleArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "rulescol.hdl"

MtDefine(CStyleSheetRule, StyleSheets, "CStyleSheetRule")
MtDefine(CStyleSheetRuleArray, StyleSheets, "CStyleSheetRuleArray")


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetRuleArray
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CStyleSheetRuleArray::s_classdesc =
{
    &CLSID_HTMLStyleSheetRulesCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLStyleSheetRulesCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------
CStyleSheetRuleArray::CStyleSheetRuleArray( CStyleSheet *pStyleSheet ) : _pStyleSheet(pStyleSheet)
{
}

//+----------------------------------------------------------------
//
//  member : StyleSheetRelease()
//      This method calls Release(), but it is called from the parent
//  stylesheet during its destruction - so we need to make sure to
//  clear our pointer to the parent stylesheet at the same time.
//
//+----------------------------------------------------------------
int CStyleSheetRuleArray::StyleSheetRelease()
{
    Assert( _pStyleSheet );
    _pStyleSheet = NULL;
    return Release();
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CStyleSheetRuleArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetRulesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::length
//
//  Sysnopsis : IHTMLFiltersCollection interface method
//
//----------------------------------------------------------------

HRESULT
CStyleSheetRuleArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pStyleSheet ) 
        *pLength = _pStyleSheet->GetNumRules();
    else
        *pLength = 0;

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::item
//
//  Sysnopsis : IHTMLStyleSheetRulesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CStyleSheetRuleArray::item(long lIndex, IHTMLStyleSheetRule **ppSSRule)
{
    HRESULT         hr;
    VARIANT         varDispatch;

    if (!ppSSRule)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppSSRule = (IHTMLStyleSheetRule *) V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheetRuleArray::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT hr = S_OK;

    // ppSSRule is NULL if we're validating lIndex 
    if ( pvar )    
        V_DISPATCH(pvar) = NULL;

    if ( !_pStyleSheet )
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    if ( lIndex < 0 || (unsigned int)lIndex >= _pStyleSheet->GetNumRules())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( pvar )
    {
        hr = _pStyleSheet->OMGetOMRule( lIndex, (IHTMLStyleSheetRule**) &V_DISPATCH(pvar) );
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_DISPATCH;
    }

Cleanup:
    RRETURN(hr);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetRule
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : ClassDesc Structure
//
//-----------------------------------------------------------------

const CBase::CLASSDESC CStyleSheetRule::s_classdesc =
{
    NULL,                                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                // _pcpi
    0,                                   // _dwFlags
    &IID_IHTMLStyleSheetRule,            // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//-----------------------------------------------------------------

CStyleSheetRule::CStyleSheetRule( CStyleSheet *pStyleSheet, DWORD dwSID, ELEMENT_TAG eTag ) :
    _pStyleSheet(pStyleSheet),
    _dwID(dwSID),
    _eTag(eTag),
    _pStyle(NULL)
{
    //
    // The sid is local to pStyleSheet -- it should not contain sheet info.
    //
    Assert( 0 == ((CStyleID)dwSID).GetSheet() );
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//-----------------------------------------------------------------

CStyleSheetRule::~CStyleSheetRule()
{
    if ( _pStyle )
    {
        _pStyle->ClearRule();
        _pStyle->PrivateRelease();
    }
}

//+----------------------------------------------------------------
//
//  member : StyleSheetRelease()
//      This method calls Release(), but it is called from the parent
//  stylesheet during its destruction - so we need to make sure to
//  clear our pointer to the parent stylesheet at the same time.
//
//+----------------------------------------------------------------
int CStyleSheetRule::StyleSheetRelease()
{
    Assert( _pStyleSheet );
    _pStyleSheet = NULL;
    return Release();
}

CStyleRule *CStyleSheetRule::GetRule()
{   // Can't be inlined because of undefined CStyleSheetArray class.
    if ( _pStyleSheet )
    {
        CStyleID sid(_dwID);
        return _pStyleSheet->OMGetRule( _eTag, sid );
    }
    return NULL;
}

//+---------------------------------------------------------------------
//
//  Class:      CStyleSheetRule::PrivateQueryInterface
//
//------------------------------------------------------------------------
HRESULT
CStyleSheetRule::PrivateQueryInterface( REFIID iid, LPVOID *ppv )
{
    HRESULT hr = S_OK;

    if ( !ppv )
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)

    default:
        if (iid == IID_IHTMLStyleSheetRule)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetRule, NULL, ppv));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    if ( *ppv )
        ((IUnknown *)*ppv)->AddRef();

    RRETURN(hr);
}

//*********************************************************************
//  CStyleSheetRule::selectorText
//      IHTMLStyleSheetRule interface method
//*********************************************************************
HRESULT
CStyleSheetRule::get_selectorText(BSTR *pBSTR)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if ( _pStyleSheet )
    {
        CStyleID sid( _dwID );

        CStyleRule *pRule = GetRule();
        Assert( pRule );
        CStyleSelector *pSelector = pRule->GetSelector();
        if ( pSelector )
        {
            CStr cstrSelector;
            pSelector->GetString( &cstrSelector );
            cstrSelector.TrimTrailingWhitespace();
            hr = cstrSelector.AllocBSTR( pBSTR );
        }
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheetRule::put_selectorText(BSTR bstr)
{
    HRESULT hr = E_NOTIMPL;

//Cleanup:
    RRETURN1( SetErrorInfo( hr ), E_NOTIMPL);
}

HRESULT CStyleSheetRule::get_style( IHTMLRuleStyle **ppStyle )
{
    HRESULT hr = S_OK;

    if ( !ppStyle )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppStyle = NULL;

    if ( !_pStyle )
    {
        _pStyle = new CRuleStyle( this );
        if ( !_pStyle )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = _pStyle->QueryInterface( IID_IHTMLRuleStyle, (void**)ppStyle);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT CStyleSheetRule::get_readOnly( VARIANT_BOOL * pvbReadOnly )
{
    Assert( pvbReadOnly );
    
    RRETURN( SetErrorInfo( _pStyleSheet->get_readOnly( pvbReadOnly ) ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\sprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sprop.cxx
//
//  Contents:   These are the Style Handlers and Helpers
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

///+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStyleProperty, public
//
//  Synopsis:   Helper for getting/setting string value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (CStr in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleStyleProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;

        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = THR(VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR));
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
            break;
        }

        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            pv = (void *)ulTagNotPresentDefault;

            if (!pv)
                goto Cleanup;       // zero string

            // fall thru
        case HANDLEPROP_VALUE:
        case HANDLEPROP_AUTOMATION:
            if ( pv && *(TCHAR *)pv )
            {
                CElement *pElem = (CElement *)pObject;
                LPTSTR lpszStyleText = (TCHAR *)pv;
                CAttrArray **ppAA = pElem->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
                // Keep the poiner that we pass to CCSSParser constructor, because ppAA may get shifted
                CAttrArray *pAA = *ppAA; 

                BOOL fXML = pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsXML();
                BOOL fIsStrictCSS1 = (OPCODE(dwOpCode) == HANDLEPROP_VALUE) ? (dwOpCode & HANDLEPROP_STRICTCSS1)
                                                                            : pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsStrictCSS1Document();

                CCSSParser ps( NULL, &pAA, fXML, fIsStrictCSS1, eSingleStyle, &CStyle::s_apHdlDescs, pObject, OPERATION(dwOpCode) );
        
                ps.Open();
                ps.Write( lpszStyleText, _tcslen( lpszStyleText ) );
                ps.Close();
            }
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        &((VARIANT *)pv)->bstrVal, 
                        TRUE));
                ((VARIANT *)pv)->vt = VT_BSTR;
            }
            else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        (BSTR *)pv, 
                        TRUE));
            }
            else
            {
                BSTR    bstr = NULL;
                
                Assert(PROPTYPE(dwOpCode) == 0);

                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        &bstr, 
                        TRUE));
                if (!hr)
                {
                    hr = ((CStr *)pv)->Set(bstr);
                    FormsFreeString(bstr);
                }
            }
            if (hr)
                goto Cleanup;
                
            break;
            
        case HANDLEPROP_STREAM:
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            {
                BSTR bstrTemp;
                hr = THR( WriteStyleToBSTR( pObject,
                                            ((CElement *)pObject)->GetInLineStyleAttrArray(),
                                            &bstrTemp,
                                            TRUE,
                                            !((CElement *)pObject)->Doc()->_fSaveTempfileForPrinting ));
                if ( !hr )
                {
                    if ( *bstrTemp )
                        hr = THR(((IStream*) (void*) pv)->Write( bstrTemp, _tcslen(bstrTemp) * sizeof(TCHAR), NULL));
                    FormsFreeString( bstrTemp );
                }
            }

            if (hr)
                goto Cleanup;
            break;

        case HANDLEPROP_COMPARE:
            {
                CElement *pElem = (CElement *)pObject;
                CAttrArray *pAA = pElem->GetInLineStyleAttrArray();
                // Check for presence of Attributs and Expandos
                hr = pAA && pAA->HasAnyAttribute(TRUE) ? S_FALSE : S_OK;
            }
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }

Cleanup:
    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    RRETURN1(hr,S_FALSE);
}

HRESULT BASICPROPPARAMS::GetStyleComponentProperty(BSTR *pbstr, CBase *pObject, CVoid *pSubObject) const
{
    VARIANT varValue;
    HRESULT hr;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( HANDLEPROP_VALUE | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
        *pbstr = V_BSTR(&varValue);

    RRETURN(pObject ? pObject->SetErrorInfo(hr) : hr);
}

HRESULT BASICPROPPARAMS::SetStyleComponentProperty( BSTR bstr, CBase *pObject, CVoid *pSubObject, WORD wFlags ) const
{
    HRESULT hr;
    CBase::CLock    Lock(pObject);
    DWORD dwOpCode = HANDLEPROP_SET|HANDLEPROP_AUTOMATION;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if (wFlags & CAttrValue::AA_Extra_Important)
        dwOpCode |= HANDLEPROP_IMPORTANT;
    if (wFlags & CAttrValue::AA_Extra_Implied)
        dwOpCode |= HANDLEPROP_IMPLIED;

    SETPROPTYPE( dwOpCode, PROPTYPE_LPWSTR );

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( dwOpCode, (void *) bstr, pObject, pSubObject ));
    
    RRETURN1(pObject ? pObject->SetErrorInfo(hr) : hr, E_INVALIDARG);
}

HRESULT BASICPROPPARAMS::GetStyleComponentBooleanProperty( VARIANT_BOOL * p, CBase *pObject, CVoid *pSubObject) const
{
    VARIANT varValue;
    HRESULT hr;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if (!pSubObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( HANDLEPROP_VALUE | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
    {
        Assert( varValue.vt == VT_BOOL );
        *p = varValue.boolVal;
    }

Cleanup:
    RRETURN(pObject->SetErrorInfo(hr));
}

HRESULT BASICPROPPARAMS::SetStyleComponentBooleanProperty( VARIANT_BOOL v, CBase *pObject, CVoid *pSubObject ) const
{
    HRESULT hr;
    CBase::CLock    Lock(pObject);
    DWORD dwOpCode = HANDLEPROP_SET|HANDLEPROP_AUTOMATION;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;
    VARIANT var;

    if (!pSubObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    var.vt = VT_BOOL;
    var.boolVal = v;

    SETPROPTYPE( dwOpCode, PROPTYPE_VARIANT );

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( dwOpCode, (void *) &var, pObject, pSubObject ));

Cleanup:
    RRETURN1(pObject->SetErrorInfo(hr), E_INVALIDARG);
}

STDMETHODIMP CStyle::put_textDecorationNone(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationNone.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationNone(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationNone.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationUnderline(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationUnderline.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationUnderline(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationUnderline.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationOverline(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationOverline.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationOverline(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationOverline.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationLineThrough(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationLineThrough.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationLineThrough(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationLineThrough.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationBlink(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationBlink.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationBlink(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationBlink.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}


HRESULT
CStyle::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};



//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStyleComponentProperty, public
//
//  Synopsis:   Helper for getting/setting url style sheet properties...
//              url(string)
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------
HRESULT
PROPERTYDESC::HandleStyleComponentProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK;
    VARIANT varDest;
    size_t  nLenIn = (size_t) -1;
	DWORD dispid = GetBasicPropParams()->dispid;
    BSTR bstrTemp;  // Used by some of the stream writers
    BOOL fTDPropertyValue=FALSE;  // If this is a SET of a text-decoration sub-property, this is the value
    WORD wFlags = 0;

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch ( dispid )
        {
        case DISPID_A_TEXTDECORATIONNONE:
        case DISPID_A_TEXTDECORATIONUNDERLINE:
        case DISPID_A_TEXTDECORATIONOVERLINE:
        case DISPID_A_TEXTDECORATIONLINETHROUGH:
        case DISPID_A_TEXTDECORATIONBLINK:
            Assert( PROPTYPE(dwOpCode) == PROPTYPE_VARIANT && "Text-decoration subproperties must take variants!" );
            Assert( V_VT((VARIANT *)pv) == VT_BOOL && "Text-decoration subproperties must take BOOLEANs!" );
            fTDPropertyValue = !!((VARIANT *)pv)->boolVal;
            break;

        default:
            switch(PROPTYPE(dwOpCode))
            {
            case PROPTYPE_VARIANT:
                if (V_VT((VARIANT *)pv) == VT_BSTR)
                {
                    pv = (void *)V_BSTR((VARIANT *)pv);
                }
                else
                {
                    hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                    if (hr)
                        goto Cleanup;
                    pv = V_BSTR(&varDest);
                }

                //intentional fallthrough
            case PROPTYPE_LPWSTR:
                switch (dispid)
                {
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_FONTFACESRC:
                    nLenIn = ValidStyleUrl((TCHAR*) pv);
                    if ( OPCODE(dwOpCode) == HANDLEPROP_VALUE )
                    {
                        if (!nLenIn && _tcsicmp( (TCHAR*)pv, _T("none") ) )
                        {
                            hr = E_INVALIDARG;
                            goto Cleanup;
                        }
                    }
                    break;

                case DISPID_A_BEHAVIOR:
                    nLenIn = pv ? _tcslen((TCHAR*) pv) : 0;
                    break;
                }
                break;

		    default:
			    Assert( FALSE );	// We shouldn't get here.
            }
            break;
        }

        switch ( dispid )
        {
        case DISPID_A_LISTSTYLEIMAGE:
        case DISPID_A_BACKGROUNDIMAGE:
        case DISPID_A_FONTFACESRC:
        case DISPID_A_BEHAVIOR:
        
            if (nLenIn && (nLenIn != (size_t) -1))
            {
                if (DISPID_A_BEHAVIOR == dispid)
                {
                    hr = THR(HandleStringProperty(dwOpCode, (TCHAR*) pv, pObject, pSubObject));
                }
                else
                {
                    TCHAR *pch = (TCHAR*) pv;
                    TCHAR *psz = pch+4;
                    TCHAR *quote = NULL;
                    TCHAR *pszEnd;
                    TCHAR terminator;

                    dwOpCode |= HANDLEPROP_URLENCLOSE;

                    while ( _istspace( *psz ) )
                        psz++;
                    if ( *psz == _T('\'') || *psz == _T('"') )
                    {
                        quote = psz++;
                    }
                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                    pszEnd = pch + nLenIn - 1;
                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                        pszEnd--;
                    if ( quote && ( *pszEnd == *quote ) )
                        pszEnd--;
                    terminator = *(pszEnd+1);
                    *(pszEnd+1) = _T('\0');
                    hr = THR(HandleStringProperty(dwOpCode, psz, pObject, pSubObject));
                    *(pszEnd+1) = terminator;
                }
            }
            else
            {
                // Why are we doing the FindSimpleAndDelete here instead of always
                // doing a HandleStringProperty?  We won't fire a prop change this way
                // and we also won't handle undo.  Ug!
                if ( !pv || !*(TCHAR*)pv )
                {   // Empty string - delete the entry.
                    CAttrArray **ppAA = (CAttrArray **)pSubObject;

                    if ( *ppAA )
                        (*ppAA)->FindSimpleAndDelete( dispid, CAttrValue::AA_StyleAttribute, NULL );
                }
                else if ( !_tcsicmp( (TCHAR*)pv, _T("none") ) )
                {
                    hr = THR(HandleStringProperty(dwOpCode, (void *)_T(""), pObject, pSubObject));
                }
                else
                    hr = E_INVALIDARG;
            }
            break;

        case DISPID_A_BACKGROUND:
            hr = ParseBackgroundProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv,
                            ( OPCODE(dwOpCode) == HANDLEPROP_VALUE ) );
            break;
        case DISPID_A_FONT:
            if ( pv && FindSystemFontByName( (TCHAR*) pv ) != sysfont_non_system )
            {
                hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            }
            else
                hr = ParseFontProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;
        case DISPID_A_LAYOUTGRID:
            hr = ParseLayoutGridProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;
        case DISPID_A_TEXTAUTOSPACE:
            if ( dwOpCode & HANDLEPROP_IMPORTANT )
                wFlags |= CAttrValue::AA_Extra_Important;
            if ( dwOpCode & HANDLEPROP_IMPLIED )
                wFlags |= CAttrValue::AA_Extra_Implied;

            hr = ParseTextAutospaceProperty( (CAttrArray **)pSubObject, (LPCTSTR)pv, OPERATION(dwOpCode), wFlags );
            break;
        case DISPID_A_TEXTDECORATION:
            if ( dwOpCode & HANDLEPROP_IMPORTANT )
                wFlags |= CAttrValue::AA_Extra_Important;
            if ( dwOpCode & HANDLEPROP_IMPLIED )
                wFlags |= CAttrValue::AA_Extra_Implied;

            // Don't create undo units if set while parsing (from initAttrBag)
            if (pObject && (OPCODE(dwOpCode) == HANDLEPROP_VALUE))
                pObject = NULL;

            hr = ParseTextDecorationProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (LPCTSTR)pv, wFlags );
            break;
        case DISPID_A_TEXTDECORATIONNONE:
        case DISPID_A_TEXTDECORATIONUNDERLINE:
        case DISPID_A_TEXTDECORATIONOVERLINE:
        case DISPID_A_TEXTDECORATIONLINETHROUGH:
        case DISPID_A_TEXTDECORATIONBLINK:
            {
                VARIANT v;
#ifndef NO_EDIT
                CVariant varOld;
                BOOL fTreeSync = FALSE;
                BOOL fCreateUndo = (pObject && (OPCODE(dwOpCode) != HANDLEPROP_VALUE)) ? pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync ) : FALSE;
                if ( fCreateUndo || fTreeSync )
                {
                    V_VT(&varOld) = VT_BSTR;
                    WriteTextDecorationToBSTR( *((CAttrArray **)pSubObject), &(V_BSTR(&varOld)) );
                }
#endif
                

                v.vt = VT_I4;
                v.lVal = 0;
                if ( *((CAttrArray **)pSubObject) )
                {   // See if we already have a text-decoration value
                    CAttrValue *pAV = (*((CAttrArray **)pSubObject))->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
                    if ( pAV )
                    {   // We do!  Copy its value into our working variant
                        v.lVal = pAV->GetLong();
                    }
                }
                switch ( dispid )
                {
                case DISPID_A_TEXTDECORATIONNONE:
                    if ( fTDPropertyValue )
                        v.lVal = TD_NONE;   // "none" clears all the other properties (unlike the other properties)
                    else
                        v.lVal &= ~TD_NONE;
                    break;
                case DISPID_A_TEXTDECORATIONUNDERLINE:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_UNDERLINE;
                    else
                        v.lVal &= ~TD_UNDERLINE;
                    break;
                case DISPID_A_TEXTDECORATIONOVERLINE:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_OVERLINE;
                    else
                        v.lVal &= ~TD_OVERLINE;
                    break;
                case DISPID_A_TEXTDECORATIONLINETHROUGH:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_LINETHROUGH;
                    else
                        v.lVal &= ~TD_LINETHROUGH;
                    break;
                case DISPID_A_TEXTDECORATIONBLINK:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_BLINK;
                    else
                        v.lVal &= ~TD_BLINK;
                    break;
                }
                if ( dwOpCode & HANDLEPROP_IMPORTANT )
                    wFlags |= CAttrValue::AA_Extra_Important;
                if ( dwOpCode & HANDLEPROP_IMPLIED )
                    wFlags |= CAttrValue::AA_Extra_Implied;
                hr = CAttrArray::Set( (CAttrArray **)pSubObject, DISPID_A_TEXTDECORATION, &v,
                                (PROPERTYDESC *)&s_propdescCStyletextDecoration, CAttrValue::AA_StyleAttribute, wFlags );

#ifndef NO_EDIT
                if (fTreeSync)
                {
                    CVariant varNew;

                    V_VT(&varNew) = VT_BSTR;
                    WriteTextDecorationToBSTR( *((CAttrArray **)pSubObject), &(V_BSTR(&varNew)) );

                    pObject->LogAttributeChange( DISPID_A_TEXTDECORATION, &varOld, &varNew );
                }

                if( fCreateUndo )
                {
                    hr = THR(pObject->CreatePropChangeUndo(DISPID_A_TEXTDECORATION, &varOld, NULL));
                    if (hr)
                        goto Cleanup;
                }
#endif
            }
            dispid = DISPID_A_TEXTDECORATION;   // This is so we call OnPropertyChange for the right property below.
            break;

        case DISPID_A_MARGIN:
        case DISPID_A_PADDING:
            hr = THR( ParseExpandProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, TRUE ) );
            break;

        case DISPID_A_BORDERWIDTH:
            // (gschneid) Border width sould be handled with the same behavior like margin and padding (last argument TRUE). 
            // But this one is buggy and needs to be reviewed for Blackcomb in compatible mode. Bug #19500.
            // It's fixed under strict css mode.
            {
                BOOL fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1;
                hr = THR(ParseExpandProperty((CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, !!fIsStrictCSS1));
            }
            break;
        case DISPID_A_BORDERCOLOR:
        case DISPID_A_BORDERSTYLE:
            hr = THR( ParseExpandProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, FALSE ) );
            break;

        case DISPID_A_STYLETEXT:
            {
                LPTSTR lpszStyleText = (TCHAR *)pv;
                CAttrArray **ppAA = (CAttrArray **)pSubObject;

                if ( *ppAA )
                    (*ppAA)->Free();

                if ( lpszStyleText && *lpszStyleText )
                {
                    CStyle *pStyle = DYNCAST(CStyle, pObject);

                    Assert( pStyle );
                    pStyle->MaskPropertyChanges( TRUE );
                    CElement *pElem = pStyle->GetElementPtr();
                    BOOL fXML = pElem && pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsXML();
                    BOOL fIsStrictCSS1 = pElem && pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsStrictCSS1Document();
                    CCSSParser ps( NULL, ppAA, fXML, fIsStrictCSS1, eSingleStyle, &CStyle::s_apHdlDescs, 
                                   pObject, OPERATION(dwOpCode) );

                    ps.Open();
	                ps.Write( lpszStyleText, lstrlen( lpszStyleText ) );
	                ps.Close();
                    pStyle->MaskPropertyChanges( FALSE );
                }
            }
            break;

        case DISPID_A_BORDERTOP:
        case DISPID_A_BORDERRIGHT:
        case DISPID_A_BORDERBOTTOM:
        case DISPID_A_BORDERLEFT:
            hr = ParseAndExpandBorderSideProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid );
            break;

        case DISPID_A_BORDER:
            hr = ParseBorderProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;

        case DISPID_A_LISTSTYLE:
            hr = ParseListStyleProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;

        case DISPID_A_BACKGROUNDPOSITION:
            hr = ParseBackgroundPositionProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR *)pv );
            break;

        case DISPID_A_CLIP:
            hr = ParseClipProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR *)pv );
            break;

        default:
            Assert( "Attempting to set an unknown type of CStyleComponent!" );
        }

        if (hr)
            goto Cleanup;
        else
        {
            // Note that dispid reflects the property that changed, not what was set -
            // e.g., textDecorationUnderline has been changed to textDecoration.
            if ( dwOpCode & HANDLEPROP_AUTOMATION )
            {
                CBase::CLock Lock( pObject );
                hr = THR(pObject->OnPropertyChange(dispid, GetdwFlags()));
            }
        }
    }
    else
    {	// GET value from data
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_STREAM:
            {
                IStream *pis = (IStream *) pv;

                switch ( dispid )
                {
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_BEHAVIOR:
                case DISPID_A_FONTFACESRC:
                    if ( (*(CAttrArray **)pSubObject)->Find( dispid, CAttrValue::AA_Attribute ) )
                    {
                        BSTR bstrSub;

                        hr = HandleStringProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16), 
                                                   &bstrSub, pObject, pSubObject );
                        if ( hr == S_OK )
                        {
                            if ( bstrSub && *bstrSub )
                            {   // This is a normal url.
                                hr = pis->Write(_T("url("), 4*sizeof(TCHAR), NULL);
                                if (!hr)
                                {
                                    hr = pis->Write( bstrSub, FormsStringLen( bstrSub ) * sizeof(TCHAR), NULL);
                                    if (!hr)
                                    {
                                        hr = pis->Write(_T(")"), 1*sizeof(TCHAR), NULL);
                                    }
                                }
                            }
                            else
                            {   // We only get here if a NULL string was stored in the array; i.e., the value is NONE.
                                hr = pis->Write(_T("none"), 4*sizeof(TCHAR), NULL);
                            }
                            FormsFreeString( bstrSub );
                        }
                    }
                    break;

                case DISPID_A_BACKGROUND:
                    hr = WriteBackgroundStyleToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_TEXTAUTOSPACE:
                    // We need to cook up this property.
                    hr = WriteTextAutospaceToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_TEXTDECORATION:
                    // We need to cook up this property.
                    hr = WriteTextDecorationToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_BORDERTOP:
                case DISPID_A_BORDERRIGHT:
                case DISPID_A_BORDERBOTTOM:
                case DISPID_A_BORDERLEFT:
                    hr = WriteBorderSidePropertyToBSTR( dispid, *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_BORDER:
                    hr = WriteBorderToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_MARGIN:
                case DISPID_A_PADDING:
                case DISPID_A_BORDERCOLOR:
                case DISPID_A_BORDERWIDTH:
                case DISPID_A_BORDERSTYLE:
                    hr = WriteExpandedPropertyToBSTR( dispid, *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_LISTSTYLE:
                    hr = WriteListStyleToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
            
                case DISPID_A_BACKGROUNDPOSITION:
                    hr = WriteBackgroundPositionToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_FONT:
                    if ( (*(CAttrArray **)pSubObject)->Find(DISPID_A_FONT, CAttrValue::AA_Attribute ) )
                        hr = HandleStringProperty(dwOpCode, pv, pObject, pSubObject);
                    else
                    {
                        // We need to cook up a "font" property.
                        hr = WriteFontToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                        if ( !hr )
                        {
                            if ( *bstrTemp )
                                hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                            FormsFreeString( bstrTemp );
                        }
                    }
                    break;
                case DISPID_A_LAYOUTGRID:
                    // We need to cook up a "layout grid" property.
                    hr = WriteLayoutGridToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
                case DISPID_A_CLIP:     // We need to cook up a "clip" property with the "rect" shape.
                    hr = WriteClipToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
                case DISPID_A_STYLETEXT:
                    hr = WriteStyleToBSTR( pObject, *(CAttrArray **)pSubObject, &bstrTemp, FALSE );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, _tcslen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
				}
            }
            break;
        default:
            {
                BSTR *pbstr;
                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    V_VT((VARIANT *)pv) = VT_BSTR;
                    pbstr = &(((VARIANT *)pv)->bstrVal);
                    break;
                case PROPTYPE_BSTR:
                    pbstr = (BSTR *)pv;
                    break;
                default:
                    Assert( "Can't get anything but a VARIANT or BSTR for style component properties!" );
                    hr = S_FALSE;
                    goto Cleanup;
                }
                switch ( dispid )
                {
                case DISPID_A_BACKGROUND:
                    hr = WriteBackgroundStyleToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_FONTFACESRC:
                case DISPID_A_BEHAVIOR:
                    {
                        CStr cstr;
                        if ( (*(CAttrArray **)pSubObject)->Find( dispid, CAttrValue::AA_Attribute ) )
                        {
                            BSTR bstrSub;
                            hr = HandleStringProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16), 
                                                       &bstrSub, pObject, pSubObject );
                            if ( hr == S_OK )
                            {
                                if ( bstrSub && *bstrSub )
                                {
                                    // CONSIDER (alexz) using Format, to remove the memallocs here

                                    if (dispid != DISPID_A_BEHAVIOR)
                                        cstr.Set( _T("url(") );

                                    cstr.Append( bstrSub );

                                    if (dispid != DISPID_A_BEHAVIOR)
                                        cstr.Append( _T(")") );
                                }
                                else
                                {   // We only get here if a NULL string was stored in the array; i.e., the value is NONE.
                                    cstr.Set( _T("none") );
                                }
                                FormsFreeString( bstrSub );
                            }
                        }
                        hr = cstr.AllocBSTR( pbstr );
                    }
                    break;

                case DISPID_A_TEXTAUTOSPACE:
                    hr = WriteTextAutospaceToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
                case DISPID_A_TEXTDECORATION:
                    hr = WriteTextDecorationToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_TEXTDECORATIONNONE:
                case DISPID_A_TEXTDECORATIONUNDERLINE:
                case DISPID_A_TEXTDECORATIONOVERLINE:
                case DISPID_A_TEXTDECORATIONLINETHROUGH:
                case DISPID_A_TEXTDECORATIONBLINK:
                    if ( PROPTYPE( dwOpCode ) != PROPTYPE_VARIANT )
                    {
                        Assert( "Can't get/set text-decoration subproperties as anything but VARIANTs!" );
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    V_VT((VARIANT *)pv) = VT_BOOL;
                    ((VARIANT *)pv)->boolVal = 0;

                    if ( *((CAttrArray **)pSubObject) )
                    {   // See if we already have a text-decoration value
                        CAttrValue *pAV = (*((CAttrArray **)pSubObject))->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
                        if ( pAV )
                        {   // We do!  Copy its value into our working variant
                            long lVal = pAV->GetLong();

                            switch ( dispid )
                            {
                            case DISPID_A_TEXTDECORATIONNONE:
                                lVal &= TD_NONE;
                                break;
                            case DISPID_A_TEXTDECORATIONUNDERLINE:
                                lVal &= TD_UNDERLINE;
                                break;
                            case DISPID_A_TEXTDECORATIONOVERLINE:
                                lVal &= TD_OVERLINE;
                                break;
                            case DISPID_A_TEXTDECORATIONLINETHROUGH:
                                lVal &= TD_LINETHROUGH;
                                break;
                            case DISPID_A_TEXTDECORATIONBLINK:
                                lVal &= TD_BLINK;
                                break;
                            }
                            if ( lVal )
                                ((VARIANT *)pv)->boolVal = -1;
                        }
                    }
                    break;

                case DISPID_A_BORDERTOP:
                case DISPID_A_BORDERRIGHT:
                case DISPID_A_BORDERBOTTOM:
                case DISPID_A_BORDERLEFT:
                    hr = WriteBorderSidePropertyToBSTR( dispid, *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_BORDER:
                    hr = WriteBorderToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_MARGIN:
                case DISPID_A_PADDING:
                case DISPID_A_BORDERCOLOR:
                case DISPID_A_BORDERWIDTH:
                case DISPID_A_BORDERSTYLE:
                    hr = WriteExpandedPropertyToBSTR( dispid, *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_LISTSTYLE:
                    hr = WriteListStyleToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
            
                case DISPID_A_BACKGROUNDPOSITION:
                    hr = WriteBackgroundPositionToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_FONT:
                    if ( (*(CAttrArray **)pSubObject)->Find(DISPID_A_FONT, CAttrValue::AA_Attribute ) )
                        hr = HandleStringProperty(dwOpCode, pv, pObject, pSubObject);
                    else
                    {
                        // We need to cook up a "font" property.
                        hr = WriteFontToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    }
                    break;

                case DISPID_A_LAYOUTGRID:
                    hr = WriteLayoutGridToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_STYLETEXT:
                    hr = WriteStyleToBSTR( pObject, *(CAttrArray **)pSubObject, pbstr, FALSE );
                    break;

                case DISPID_A_CLIP:     // We need to cook up a "clip" property with the "rect" shape.
                    hr = WriteClipToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                default:
                    Assert( "Unrecognized type being handled by CStyleUrl handler!" && FALSE );
                    break;
                }
                if ( hr == S_FALSE )
                    hr = FormsAllocString( _T(""), pbstr );
            }
            break;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\sheetcol.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sheetcol.cxx
//
//  Contents:   Support for collections of Cascading Style Sheets.. including:
//
//              CStyleSheetArray
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"  // For CAnchorElement decl, for pseudoclasses
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "sheetcol.hdl"

DeclareTag(tagStyleSheetApply,                    "Style Sheet Apply", "trace Style Sheet application")
ExternTag(tagStyleSheet)

//*********************************************************************
//      CStyleSheetArray
//*********************************************************************
const CStyleSheetArray::CLASSDESC CStyleSheetArray::s_classdesc =
{
    {
        &CLSID_HTMLStyleSheetsCollection,    // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                   // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleSheetsCollection,     // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnIHTMLStyleSheetsCollection         // _apfnTearOff
};

//*********************************************************************
//      CStyleSheetArray::CStyleSheetArray()
//  When you create a CStyleSheetArray, the owner element specified will
//  have a subref added.  In the case of the top-level stylesheets collection,
//  the owner is the CDoc.  In the case of imports collections, the owner is
//  a CStyleSheet.
//*********************************************************************
CStyleSheetArray::CStyleSheetArray(
    CBase * const pOwner,             // CBase obj that controls our lifetime/does our ref-counting.
    CStyleSheetArray * pRootSSA,      // NULL if we are the RootSSA
    CStyleSheetID const sidParentSheet)    // ID of our owner's SS (non-zero for CSSA storing imported SS only)
    :
    _pOwner(pOwner),
    _fInvalid(FALSE),
    _aStyleSheets()
{
    WHEN_DBG( _fFreed = FALSE );

    // If we are constructed w/ a NULL manager, then we manage our own storage
    _pRootSSA = pRootSSA ? pRootSSA : this;

    WHEN_DBG( _nValidLevels = 0 );

    if (!ChangeID(sidParentSheet))
    {
        _fInvalid = TRUE;
    }

    // Add-ref ourselves before returning from constructor.  This will actually subref our owner.
    AddRef();

}


BOOL
CStyleSheetArray::ChangeID(CStyleSheetID const sidParentSheet)
{
    unsigned int parentLevel;
    CStyleSheet **pSS;
    int  i;
    CStyleSheetID    sidSheet;

    _sidForOurSheets = sidParentSheet;
    _sidForOurSheets.SetRule(0);  // Clear rule information

    parentLevel = sidParentSheet.FindNestingLevel();
    // We are one level deeper than our parents.
    _Level = parentLevel + 1;
    Assert( "Invalid level computed for stylesheet array! (informational only)" && _Level > 0 && _Level < 5 );
    if ( _Level > MAX_IMPORT_NESTING )
    {
        _Level = MAX_IMPORT_NESTING;
        return FALSE;
    }

    // We want _sidForOurSheets to be the ID that should be assigned to stylesheets built by this array.
    // If we're being built to hold imported stylesheets (_Level > 1), patch the ID by lowering previous
    // level by 1.
    if ( _Level > 1 )
    {
        unsigned long parentLevelValue = sidParentSheet.GetLevel( parentLevel );
        Assert( "Nested stylesheets must have non-zero parent level value!" && parentLevelValue );
        _sidForOurSheets.SetLevel( parentLevel, parentLevelValue-1 );
    }

    sidSheet = _sidForOurSheets;
    for (i = 0, pSS = _aStyleSheets;  i < _aStyleSheets.Size(); i++, pSS++)
    {
        sidSheet.SetLevel(_Level, i+1);
        if (! (*pSS)->ChangeID(sidSheet))
            return FALSE;
    }
    
    return TRUE;
}

//*********************************************************************
//      CStyleSheetArray::~CStyleSheetArray()
//  Recall we don't maintain our own ref-count; this means our memory
//  doesn't go away until our owner's memory is going away.  In order
//  to do this, the owner has to call ->CBase::PrivateRelease() on us.
//  (see the CDoc destructor for example).
//  This works because: a) we start with an internal ref-count of 1,
//  which is keeping us alive, b) that internal ref-count is never
//  exposed to changes (all AddRef/Release calls are delegated out).
//  So in effect the internal ref-count of 1 is held by the owner.
//*********************************************************************
CStyleSheetArray::~CStyleSheetArray()
{
    Assert( "Must call Free() before destructor!" && _fFreed );
}

#if DBG==1
CStyleSheetArray::CCheckValid::CCheckValid( CStyleSheetArray *pSSA ) 
{ 
    Assert(pSSA);
    _pSSA = pSSA->RootManager(); 
    if (_pSSA->_nValidLevels == 0)
    {
        Assert( _pSSA->DbgIsValidImpl() );
    }
    _pSSA->_nValidLevels++; 
}

CStyleSheetArray::CCheckValid::~CCheckValid() 
{ 
    if (--(_pSSA->_nValidLevels) == 0) 
        Assert( _pSSA->DbgIsValidImpl() ); 
}

BOOL 
CStyleSheetArray::DbgIsValidImpl()
{
    //
    // For every style sheet, check the stylesheet is valid
    //
    {
        CStyleSheet * pSS;
        int nSS, iSS;
        for (iSS = 0, nSS = _aStyleSheets.Size(); iSS < nSS; iSS++)
        {
            pSS = _aStyleSheets[iSS];
            if (!pSS->DbgIsValid())
                return FALSE;
                
            // Recursivly call for import SSA
            if (    pSS->_pImportedStyleSheets 
                && !pSS->_pImportedStyleSheets->DbgIsValidImpl())
                return FALSE;
        }
    }

    return TRUE;
}



VOID CStyleSheetArray::Dump()
{
    if (!InitDumpFile())
        return;
    
    Dump(FALSE);

    CloseDumpFile( );
}



VOID CStyleSheetArray::Dump(BOOL fRecursive)
{
    int z;
    int nSheets;

    if (!fRecursive)
    {
        fRecursive = TRUE;
    }
    
    if (RootManager() != this)
    {
        WriteChar(g_f, ' ', 8 * _Level);
    }
    WriteHelp(g_f, _T("<0d>[StyleSheetArray]-0x<1x>\r\n"), _Level, _sidForOurSheets);
    
    for (z=0, nSheets = _aStyleSheets.Size(); z<nSheets; ++z)
    {
        CStyleSheet *pSS = _aStyleSheets[z];
        WriteChar(g_f, ' ', 8 * _Level);
        WriteHelp(g_f, _T("sheet <0d>:"), z);
        pSS->Dump(fRecursive);
        WriteHelp(g_f, _T("\r\n"));
    }
}


#endif

//*********************************************************************
//      CStyleSheetArray::PrivateQueryInterface()
//*********************************************************************
HRESULT
CStyleSheetArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//*********************************************************************
// CStyleSheetArray::Invoke, IDispatch
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support ordinal and named member access to the
// elements of the collection.
//*********************************************************************

STDMETHODIMP
CStyleSheetArray::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    LPCTSTR pszName;
    long lIdx;

    // Is the dispid an ordinal index? (array access)
    if ( IsOrdinalSSDispID( dispidMember) )
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            // Stylesheets collection is readonly.
            // Inside OLE says return DISP_E_MEMBERNOTFOUND.
            goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            if (pvarResult)
            {
                lIdx = dispidMember - DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE;
                // item() will bounds check for us.
                hr = item( lIdx, (IHTMLStyleSheet **) &(pvarResult->pdispVal));
                if (hr)
                {
                    Assert( pvarResult->pdispVal == NULL );
                    pvarResult->vt = VT_NULL;
                }
                else
                {
                    Assert( pvarResult->pdispVal );
                    pvarResult->vt = VT_DISPATCH;
                }

            }
        }
    }
    else if ( IsNamedSSDispID( dispidMember) )
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            // Stylesheets collection is readonly.
            // Inside OLE says return DISP_E_MEMBERNOTFOUND.
            goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            if (pvarResult)
            {
                hr = GetAtomTable()->
                        GetNameFromAtom( dispidMember - DISPID_STYLESHEETSCOLLECTION_NAMED_BASE,
                                         &pszName );
                if (hr)
                {
                    pvarResult->pdispVal = NULL;
                    pvarResult->vt = VT_NULL;
                    goto Cleanup;
                }

                lIdx = FindSSByHTMLID( pszName, TRUE );
                // lIdx will be -1 if SS not found, in which case item will return an error.
                hr = item( lIdx, (IHTMLStyleSheet **) &(pvarResult->pdispVal));
                if (hr)
                {
                    Assert( pvarResult->pdispVal == NULL );
                    pvarResult->vt = VT_NULL;
                }
                else
                {
                    Assert( pvarResult->pdispVal );
                    pvarResult->vt = VT_DISPATCH;
                }
            }
        }
    }
    else
    {
        // CBase knows how to handle expando
        hr = THR_NOTRACE(super::InvokeEx( dispidMember,
                                        lcid,
                                        wFlags,
                                        pdispparams,
                                        pvarResult,
                                        pexcepinfo,
                                        pSrvProvider));
    }

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//*********************************************************************
//  CStyleSheetArray::GetDispID, IDispatchEx
//  Overridden to output a particular dispid range for ordinal access,
//  and another range for named member access.  Ordinal access dispids
//  range from DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE to
//  DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX.  Named access dispids
//  range from DISPID_STYLESHEETSCOLLECTION_NAMED_BASE to
//  DISPID_STYLESHEETSCOLLECTION_NAMED_MAX.
//********************************************************************

STDMETHODIMP
CStyleSheetArray::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT           hr = E_FAIL;
    long              lIdx = 0;
    long              lAtom = 0;
    DISPID            dispid = 0;

    Assert( bstrName && pid );

    // Could be an ordinal access
    hr = ttol_with_error(bstrName, &lIdx);
    if ( !hr )
    {
        dispid = DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE + lIdx;
        *pid = (dispid > DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX) ?
                        DISPID_UNKNOWN : dispid;
        hr = S_OK;
        goto Cleanup;
    }

    // Not ordinal access; could be named (via id) access if we're the top-level collection
    if ( _Level == 1 )
    {
        lIdx = FindSSByHTMLID( bstrName, (grfdex & fdexNameCaseSensitive) ? TRUE : FALSE );
        if ( lIdx != -1 )   // -1 means not found
        {
            // Found a matching ID!

            // Since we found the element in the elements collection,
            // update atom table.  This will just retrieve the atom if
            // the string is already in the table.
            Assert( bstrName );
            hr = GetAtomTable()->AddNameToAtomTable(bstrName, &lAtom);
            if ( hr )
                goto Cleanup;
            // lAtom is the index into the atom table.  Offset this by
            // base.
            lAtom += DISPID_STYLESHEETSCOLLECTION_NAMED_BASE;
            *pid = lAtom;
            if (lAtom > DISPID_STYLESHEETSCOLLECTION_NAMED_MAX)
            {
                hr = DISP_E_UNKNOWNNAME;
            }
            goto Cleanup;
        }
    }

    // Otherwise delegate to CBase impl for expando support etc.
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

Cleanup:
    RRETURN(THR_NOTRACE( hr ));
}

//*********************************************************************
//  CStyleSheetArray::GetNextDispID, IDispatchEx
//  Supports enumerating our collection indices in addition to the
//  collection's own properties.  Semantically this implementation is
//  known to be incorrect; prgbstr and prgid should match (both should
//  be the next dispid).  This is due to the current implementation in
//  the element collections code (collect.cxx); when that gets fixed,
//  this should be looked at again.  In particular, the way we begin
//  to enumerate indices is wonky; we should be using the start enum
//  DISPID value.
//*********************************************************************
STDMETHODIMP
CStyleSheetArray::GetNextDispID(DWORD grfdex,
                                DISPID id,
                                DISPID *prgid)
{
    HRESULT hr = S_OK;
    Assert( prgid );

    // Are we in the middle of enumerating our indices?
    if ( !IsOrdinalSSDispID(id) )
    {
        // No, so delegate to CBase for normal properties
        hr = super::GetNextDispID( grfdex, id, prgid );
        if (hr)
        {
            // normal properties are done, so let's start enumerating indices
            // if we aren't empty.  Return string for index 0,
            // and DISPID for index 1.
            if (_aStyleSheets.Size())
            {
                *prgid = DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE;
                hr = S_OK;
            }
        }
    }
    else
    {
        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if ( !IsOrdinalSSDispID(id+1) || (((long)(id+1-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE)) >= _aStyleSheets.Size()) )
        {
            *prgid = DISPID_UNKNOWN;
            hr = S_FALSE;
            goto Cleanup;
        }

        ++id;
        *prgid = id;
    }

Cleanup:
    RRETURN1(THR_NOTRACE( hr ), S_FALSE);
}

STDMETHODIMP
CStyleSheetArray::GetMemberName(DISPID id, BSTR *pbstrName)
{
    TCHAR   ach[20];

    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;

    // Are we in the middle of enumerating our indices?
    if ( !IsOrdinalSSDispID(id) )
    {
        // No, so delegate to CBase for normal properties
        super::GetMemberName(id, pbstrName);
    }
    else
    {
        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if ( !IsOrdinalSSDispID(id) || (((long)(id-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE)) >= _aStyleSheets.Size()) )
            goto Cleanup;

        if (Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), (long)id-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE))
            goto Cleanup;

        FormsAllocString(ach, pbstrName);
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

// Helpers for determining whether dispids fall into particular ranges.
BOOL CStyleSheetArray::IsOrdinalSSDispID( DISPID dispidMember )
{
    return ((dispidMember >= DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE) &&
           (dispidMember <= DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX));
}

BOOL CStyleSheetArray::IsNamedSSDispID( DISPID dispidMember )
{
    return ((dispidMember >= DISPID_STYLESHEETSCOLLECTION_NAMED_BASE) &&
           (dispidMember <= DISPID_STYLESHEETSCOLLECTION_NAMED_MAX));
}


//*********************************************************************
//      CStyleSheetArray::Free()
//              Release all stylesheets we're holding, and clear our storage.
//  After this has been called, we are an empty array.  If we were
//      responsible for holding onto rules, they too have been emptied.
//*********************************************************************
void CStyleSheetArray::Free( void )
{
    // Forget all the CStyleSheets we're storing
    CStyleSheet **ppSheet;
    int z;
    int nSheets = _aStyleSheets.Size();
    for (ppSheet = (CStyleSheet **) _aStyleSheets, z=0; z<nSheets; ++z, ++ppSheet)
    {
         // We need to make sure that when imports stay alive after the collection
         // holding them dies, they don't point to their original parent (all sorts
         // of badness would occur because we wouldn't be able to tell that the
         // import is effectively out of the collection, since the parent chain would
         // be intact).
         (*ppSheet)->DisconnectFromParentSS();
         if ( (*ppSheet)->GetRootContainer() == this )
             (*ppSheet)->_pSSAContainer = NULL;

         (*ppSheet)->Release();
    }
    _aStyleSheets.DeleteAll();

    _cstrUserStylesheet.Free();
    WHEN_DBG( _fFreed = TRUE );
}

//*********************************************************************
//  CStyleSheetArray::CreateNewStyleSheet()
//      This method creates a new CStyleSheet object and adds it to the
//  array (at the end).  The newly created stylesheet has an ref count of 1
//  and has +1 subrefs on the parent element, which are considered to be
//  held by the stylesheet array.  If the caller decides to keep a pointer
//  to the newly created stylesheet (e.g. when a STYLE or LINK element
//  creates a new stylesheet and tracks it), it must call CreateNewStyleSheet
//  to get the pointer and then make sure to AddRef it.
//
//  S_OK    :  no need to download
//  S_FALSE :  need to download
//
//*********************************************************************
HRESULT CStyleSheetArray::CreateNewStyleSheet( CStyleSheetCtx *pCtx, CStyleSheet **ppStyleSheet,
                                               long lPos /*=-1*/, long *plNewPos /*=NULL*/)
{
    // lPos == -1 indicates append.
    HRESULT hr = S_OK;
    HRESULT hrReturn = hr;

    if (!ppStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppStyleSheet = NULL;

    if ( lPos == _aStyleSheets.Size() )
        lPos = -1;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to create

    // If our level is full, then just don't create the requested stylesheet.
    if ( _aStyleSheets.Size() >= MAX_SHEETS_PER_LEVEL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Create the stylesheet
    hr =CStyleSheet::Create(pCtx, ppStyleSheet, this);
    if (!SUCCEEDED(hr))
        goto Cleanup;
    hrReturn = hr;

    hr = AddStyleSheet(*ppStyleSheet, lPos, plNewPos);

    if (!hr)
        (*ppStyleSheet)->Release();       // Remove the extra one the Add put on to keep the count correct
Cleanup:
    if ( !SUCCEEDED(hr) )   // need to propagate the error code back
    {
        if (ppStyleSheet && *ppStyleSheet)
        {
            delete *ppStyleSheet;
            *ppStyleSheet = NULL;
        }
        hrReturn = hr;
    }
    RRETURN1(hrReturn, S_FALSE);
}


//*********************************************************************
//  CStyleSheetArray::AddStyleSheet()
//  This method tells the array to add the stylesheet to the array, like
//  CreateStyleSheet, but with an existing StyleSheet
//*********************************************************************
HRESULT CStyleSheetArray::AddStyleSheet( CStyleSheet * pStyleSheet, long lPos /* = -1 */, long *plNewPos /* = NULL */ )
{
    WHEN_DBG( CStyleSheetArray::CCheckValid checkValid(this) );
#if DBG == 1
    if (IsTagEnabled(tagStyleSheet))
    {
        WHEN_DBG( Dump(FALSE) );
    }
#endif
    
    // lPos == -1 indicates append.
    HRESULT hr = S_OK;
    CStyleSheetID id = _sidForOurSheets;      // id for new sheet
    long lValue;

    Assert ( pStyleSheet );
    Assert ( lPos >= -1 && lPos <= _aStyleSheets.Size() );

    if ( lPos == _aStyleSheets.Size() )
        lPos = -1;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to create

    // If our level is full, then just don't create the requested stylesheet.
    if ( _aStyleSheets.Size() >= MAX_SHEETS_PER_LEVEL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set value for current level of new sheet
    lValue = ((lPos == -1) ? _aStyleSheets.Size() : lPos) + 1;
    id.SetLevel( _Level, lValue );

    // Change the StyleSheet container (is a no-op when just created), including import sheets
    pStyleSheet->ChangeContainer(_pRootSSA);

    // Update all the rules for this StyleSheet with the new ID
    pStyleSheet->ChangeID(id);

    if (lPos == -1) // Append..
    {
        hr = _aStyleSheets.AppendIndirect( &pStyleSheet );
        // Return the index of the newly appended sheet
        if ( plNewPos )
            *plNewPos = _aStyleSheets.Size()-1;
    }
    else            // ..or insert
    {
        hr = _aStyleSheets.InsertIndirect( lPos, &pStyleSheet );
        if ( hr )
            goto Cleanup;

        // Return the index of the newly inserted sheet
        if ( plNewPos )
            *plNewPos = lPos;

        // Patch ids of sheets that got shifted up by the insertion.
        // Start patching at +1 from the insertion position.
        for ( ++lPos; lPos < _aStyleSheets.Size() ; ++lPos )
        {
            _aStyleSheets[lPos]->PatchID( _Level, lPos+1, FALSE  );
        }
    }

    pStyleSheet->AddRef();          // Reference for the Add or the Create

Cleanup:
    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheetArray::ReleaseStyleSheet()
//  This method tells the array to release its reference to a stylesheet,
//  After this, as far as the array is concerned, the stylesheet does not
//  exist -- it no longer has a pointer to it, all other stylesheets have
//  their ids patched, and the rules of the released stylesheet are marked
//  as gone from the tree and have ids of 0.
//*********************************************************************
HRESULT CStyleSheetArray::ReleaseStyleSheet( CStyleSheet * pStyleSheet, BOOL fForceRender )
{
    HRESULT hr = E_FAIL;

    WHEN_DBG( CStyleSheetArray::CCheckValid checkValid(this) );

    Assert( pStyleSheet );
    Assert( pStyleSheet->_sidSheet.FindNestingLevel() == _Level );

    long idx = _aStyleSheets.FindIndirect( &pStyleSheet );
    if (idx == -1) // idx == -1 if not found; e.g. an elem releasing its SS which has already been removed from SSC via OM.
        return hr;

    _aStyleSheets.Delete(idx);  // no return value

    Assert( pStyleSheet->_sidSheet.GetLevel( _Level ) == (unsigned long)(idx+1) );

    // Make sure the appropriate rules get marked to reflect the fact this stylesheet is out of the
    // collection (a.k.a out of the tree).
    hr = pStyleSheet->ChangeStatus( CS_DETACHRULES, fForceRender, NULL );

    // Patch ids of remaining stylesheets (each SS that came after us has its level value reduced by 1)
    // Start patching at the idx where we just deleted (everyone was shifted down).
    while (idx < _aStyleSheets.Size())
    {
        _aStyleSheets[idx]->PatchID( _Level, idx+1, FALSE );
        ++idx;
    }

    // Release that ref that used to be held by this collection/array
    pStyleSheet->Release();

    return hr;
}


CStyleSheet *
CStyleSheetArray::FindStyleSheetForSID(CStyleSheetRuleID sidTarget)
{
    unsigned long uLevel;
    unsigned long uWhichLevel;
    unsigned long uSheetTarget = sidTarget.GetSheet();

    CDataAry<CStyleSheet*> *pArray = &_aStyleSheets;
    CStyleSheet *pSheet;

    // For each level in the incoming SID
    for ( uLevel = 1 ;
        uLevel <= MAX_IMPORT_NESTING && pArray ;
        uLevel++ )
    {
        uWhichLevel = sidTarget.GetLevel(uLevel);

        Assert(uWhichLevel <= (unsigned long)pArray->Size());

        // Either we exactly match one in the current array at our index for this level
        if ( uWhichLevel && ((*pArray)[uWhichLevel-1])->_sidSheet.GetSheet() == uSheetTarget )
            return (*pArray)[uWhichLevel-1];
        // Or we need to dig into the imports array
        pSheet = (*pArray)[uWhichLevel];
        if ( !pSheet->_pImportedStyleSheets )
            break;
        pArray = &(pSheet->_pImportedStyleSheets->_aStyleSheets);
    }
    return NULL;
}



void
CachedStyleSheet::PrepareForCache (CStyleSheetRuleID sidSR, CStyleRule *pRule)
{
    _pRule = pRule;
    _sidSR = sidSR;
}

LPTSTR
CachedStyleSheet::GetBaseURL(void)
{
    unsigned int    uSIdx;

    if (_pRule && _sidSR)
    {
        uSIdx = _sidSR.GetSheet();
        if (!(_pCachedSS && _uCachedSheet == uSIdx))
        {
            _pCachedSS = _pssa->GetSheet(_sidSR);
            _uCachedSheet = uSIdx;
        }
        return _pCachedSS->GetAbsoluteHref();
    }
    else
    {
       return NULL;
    }

}

MtDefine(CRules_ary, CStyleSheetArray, "CRules_ary")


BOOL CStyleSheetArray::OnlySimpleRulesApplied(CFormatInfo *pCFI)
{
    BOOL fSimple = TRUE;
    CStyleRule *pRule;
    CProbableRules *ppr;

    Assert(!pCFI->_ProbRules.IsItValid(this));
    if (S_OK != THR(BuildListOfProbableRules(pCFI->_pNodeContext, &pCFI->_ProbRules)))
    {
        fSimple = FALSE;
        goto Cleanup;
    }

    ppr = &pCFI->_ProbRules;
    Assert(ppr->IsItValid(this));
    if (ppr->_cRules.Size())
    {
        for (LONG i = 0; i < ppr->_cRules.Size(); i++)
        {
            pRule = ppr->_cRules[i]._pRule;
            Assert(pRule);
            if (pRule->GetSelector()->_pParent)
                fSimple = FALSE;
        }
    }

    if (ppr->_cWRules.Size())
    {
        for (LONG i = 0; i < ppr->_cWRules.Size(); i++)
        {
            pRule = ppr->_cWRules[i]._pRule;
            Assert(pRule);
            if (pRule->GetSelector()->_pParent)
                fSimple = FALSE;
        }
    }
    
Cleanup:
    return fSimple;
}

HRESULT
CStyleSheetArray::BuildListOfProbableRules(
                    CTreeNode *pNode, CProbableRules *ppr, 
                    CClassIDStr *pclsStrLink,       // computed class string/hash value
                    CClassIDStr *pidStr,        // computed id string/has value
                    BOOL  fRecursiveCall        // FALSE for ext. callers
                    )
{
    HRESULT hr = S_OK;
    CStyleSheet * pSS;
    int nSS, iSS;

    LPCTSTR pszClass;
    LPCTSTR pszID;
    INT nClassIdLen = 0;
    BOOL fRootCall = FALSE;

    CClassIDStr  clsStrOnStack;
    CClassIDStr  idStrOnStack;
    
    if (!fRecursiveCall)
    {
        Assert(pclsStrLink == NULL);
        Assert(pidStr == NULL);
        
        CElement *pElement = pNode->Element();
        if (!pclsStrLink)
        {
            HRESULT hrClass = pElement->GetStringAt(
                                pElement->FindAAIndex(DISPID_CElement_className, CAttrValue::AA_Attribute), 
                                &pszClass);
            if (!hrClass && pszClass && *pszClass)
            {
                CDataListEnumerator pClassIdNames(pszClass); 
                if (pClassIdNames.GetNext(&pszClass, &nClassIdLen))
                {
                    CClassIDStr  **pNext= &pclsStrLink;
                    //
                    // if we only have one class name, which probably will
                    // be most common, then we don't allocate memory on heap
                    //
                    pclsStrLink         = &clsStrOnStack;

                    (*pNext)->_dwHashKey   = HashStringCiDetectW(pszClass, nClassIdLen, 0);
                    (*pNext)->_dwHashKey   = FormalizeHashKey( (*pNext)->_dwHashKey << 2 );
                    (*pNext)->_eType       = eClass;
                    (*pNext)->_strClassID  = pszClass;
                    (*pNext)->_nClassIDLen = nClassIdLen;
                    (*pNext)->_pNext       = NULL;

                    // If we have to allocate memory, do it
                    while (pClassIdNames.GetNext(&pszClass, &nClassIdLen))
                    {
                        Assert(pNext);
                        pNext = &((*pNext)->_pNext);
                        *pNext = new CClassIDStr();
                        if (!(*pNext))
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        
                        (*pNext)->_dwHashKey   = HashStringCiDetectW(pszClass, nClassIdLen, 0);
                        (*pNext)->_dwHashKey   = FormalizeHashKey( (*pNext)->_dwHashKey << 2 );
                        (*pNext)->_eType       = eClass;
                        (*pNext)->_strClassID  = pszClass;
                        (*pNext)->_nClassIDLen = nClassIdLen;
                        (*pNext)->_pNext       = NULL;
                    }
                 }
            }
        }

        if (!pidStr)
        {
            HRESULT hrID = pElement->GetStringAt(
                                pElement->FindAAIndex(DISPID_CElement_id, CAttrValue::AA_Attribute),
                                &pszID);
            if (!hrID && pszID && &pszID)
            {
                idStrOnStack._dwHashKey = FormalizeHashKey( HashStringCiDetectW(pszID, _tcslen(pszID), 0) << 2 );
                idStrOnStack._eType       = eID;
                idStrOnStack._strClassID  = pszID;
                idStrOnStack._nClassIDLen = _tcslen(pszID);
                idStrOnStack._pNext       = NULL;
                pidStr = &idStrOnStack;
            }
        }

        fRootCall = TRUE;
        fRecursiveCall = TRUE;
    }


    if (fRootCall) 
        ppr->Init();

    //
    // Now do a depth first traverse
    //
    for (iSS = 0, nSS = _aStyleSheets.Size(); iSS < nSS; iSS++)
    {
        pSS = _aStyleSheets[iSS];
        Assert(pSS);
        hr = THR(pSS->AppendListOfProbableRules(pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
        if (hr)
            goto Cleanup;
    }
    
    if (fRootCall) 
    {
        ppr->Validate(this);

        if (pclsStrLink && (pclsStrLink == &clsStrOnStack))
        {
            // we are the one who allocated memory
            // skip the first one since it is one stack
            pclsStrLink = pclsStrLink->_pNext;
            while (pclsStrLink)
            {
                CClassIDStr  *pN = pclsStrLink->_pNext;
                delete pclsStrLink;
                pclsStrLink = pN;
            }
        }
    }

    
Cleanup:    
    RRETURN(hr);
}

//*********************************************************************
//  CStyleSheetArray::Apply()
//      This method applies (in cascade order) all style rules in the
//  collection of all sheets in this Array that apply to this element
//  context to the formats passed in pStyleInfo.
//*********************************************************************

#ifdef CSSSHARE_NOPRESORT
//  ascending order according to specificity
int RTCCONV CompareRules(const void * pvElem1, const void * pvElem2)
{
    CProbableRuleEntry *pvRE1 = (CProbableRuleEntry *)pvElem1;
    CProbableRuleEntry *pvRE2 = (CProbableRuleEntry *)pvElem2;

    Assert(pvRE1->_pRule && pvRE1->_pRule->IsMemValid() && "CompareRules called on non-CProbableRuleEntry item" );
    Assert(pvRE2->_pRule && pvRE2->_pRule->IsMemValid() && "CompareRules called on non-CProbableRuleEntry item" );

    DWORD   dwSP1 = pvRE1->_pRule->GetSpecificity();
    DWORD   dwSP2 = pvRE2->_pRule->GetSpecificity();

    if (dwSP1 == dwSP2)
    {
        if (pvRE1->_sidSheetRule > pvRE2->_sidSheetRule)
        {
            return 1;
        }
        else
        {  
            return -1;
        }
        // never return 0
    }
    else if (dwSP1 > dwSP2)
        return 1;
    else 
        return -1;
}
#endif



HRESULT CStyleSheetArray::Apply( CStyleInfo *pStyleInfo,
        ApplyPassType passType,
        EMediaType eMediaType,
        BOOL *pfContainsImportant /*=NULL*/ )
{
    HRESULT hr = S_OK;

    // Cache for class & ID on this element and potentially its parents (if they get walked)
    CStyleClassIDCache CIDCache;

#if DBG == 1
    if (IsTagEnabled(tagStyleSheetApply))
    {
        WHEN_DBG( Dump() );
    }
#endif

    WHEN_DBG( CTreeNode *pNode = pStyleInfo->_pNodeContext );

    // used to walk through ppTRules
    CStyleRule  *pTagRule = NULL;
    CStyleSheetRuleID sidTagRule = 0;
    int nTagRules;
    int iLastTagRule = -1;


    // used to walk through ppWcRules
    CStyleRule *pWildcardRule = NULL;
    CStyleSheetRuleID  sidWildRule = 0;
    int nWildcardRules;
    int iLastWCRule = -1;

    CStyleRule *pRule = NULL;

    // If we _know_ there's no class/id on this elem, don't bother w/ wildcard rules
    CachedStyleSheet cachedSS(this);
    CFormatInfo *pCFI;
    EPseudoElement epeTag = pelemNone;
    EPseudoElement epeWildcard = pelemNone;

    int iWCNum = 0;
    int iTagNum = 0;
    BOOL fTagApplied = TRUE;
    BOOL fWildcardApplied = TRUE;

    CRules *pcRules;
    CRules *pcWRules;
    CProbableRules ProbRules;
    
    if (!pStyleInfo->_ProbRules.IsItValid(this))
    {
        // Its not valid or its valid for a different style sheet. In any case
        // lets build the new list in a different place since if its actuall
        // built, then we want it to remain built since it will be used by
        // that style sheet at a later time.
        BuildListOfProbableRules(pStyleInfo->_pNodeContext, &ProbRules);
        pcRules  = &ProbRules._cRules;
        pcWRules = &ProbRules._cWRules;
    }
    else
    {
        // Valid for this style sheet, so just use the one in the style info
        pcRules  = &pStyleInfo->_ProbRules._cRules;
        pcWRules = &pStyleInfo->_ProbRules._cWRules;
    }

    nTagRules = pcRules->Size();
    nWildcardRules = pcWRules->Size();

#ifdef CSSSHARE_NOPRESORT
    // Sort by specificity, then by source order (i.e. rule ID).  
    if (nTagRules > 1)
        qsort(*pcRules, nTagRules, sizeof(CProbableRuleEntry), CompareRules);

    if (nWildcardRules > 1)
        qsort(*pcWRules, nWildcardRules, sizeof(CProbableRuleEntry), CompareRules);
#endif


#if DBG == 1
    if (IsTagEnabled(tagStyleSheetApply))
    {
        // Dump the rules list
        int n;
        for (n = 0; n < nTagRules; n++)
        {
            CProbableRuleEntry *pRE = (CProbableRuleEntry *)pcRules->Deref(sizeof(CProbableRuleEntry),n);
            Assert (pRE && pRE->_pRule);
            TraceTag((tagStyleSheetApply, "- [%2d]: ", n));
            pRE->_pRule->DumpRuleString(this);
        }

        for (n = 0; n < nWildcardRules; n++)
        {
            CProbableRuleEntry *pRE = (CProbableRuleEntry *)pcWRules->Deref(sizeof(CProbableRuleEntry),n);
            Assert (pRE->_pRule);
            TraceTag((tagStyleSheetApply, "- [%2d]: ", n));
            pRE->_pRule->DumpRuleString(this);
        }
        
    }
#endif

    pCFI = (passType == APPLY_Behavior) ? NULL : (CFormatInfo*)pStyleInfo;

    if (pCFI)
        pCFI->SetMatchedBy(pelemNone);

    while (nTagRules || nWildcardRules)
    {

        if (fTagApplied)
        {
            fTagApplied = FALSE;

            while ((iLastTagRule == iTagNum) && nTagRules)
            {
                ++iTagNum;
                --nTagRules;
            }

            if (nTagRules)
            {
                iLastTagRule = iTagNum;
                pTagRule = pcRules->Item(iTagNum)._pRule;
                sidTagRule = pcRules->Item(iTagNum)._sidSheetRule;
                pRule = pTagRule;
            }

            // Walk back from end of the rules lists, looking for a rule that needs to be applied.
            while (nTagRules &&
                    (!pRule->GetSelector() ||
                     !pRule->MediaTypeMatches(eMediaType) ||
                     !pRule->GetSelector()->Match(pStyleInfo, passType, &CIDCache)
                    )
                  )
            {
                TraceTag((tagStyleSheetApply, "Check Tag Rule %08lX", pRule->GetRuleID()));
                --nTagRules;
                ++iTagNum;
                while ((iLastTagRule == iTagNum) && nTagRules)
                {
                    ++iTagNum;
                    --nTagRules;
                }
                if (nTagRules)
                {
                    iLastTagRule = iTagNum;
                    pTagRule = pcRules->Item(iTagNum)._pRule;
                    sidTagRule = pcRules->Item(iTagNum)._sidSheetRule;
                    pRule = pTagRule;
                }
            }
            epeTag = pCFI ? pCFI->GetMatchedBy() : pelemNone;
        }

        if (fWildcardApplied)
        {
            fWildcardApplied = FALSE;
            while ((iLastWCRule == iWCNum) && nWildcardRules)
            {
                ++iWCNum;
                --nWildcardRules;
            }

            if (nWildcardRules)
            {
                iLastWCRule = iWCNum;
                pWildcardRule = pcWRules->Item(iWCNum)._pRule;
                sidWildRule   = pcWRules->Item(iWCNum)._sidSheetRule;
                pRule = pWildcardRule;
            }

            // Make sure this rule should be applied.
            // If the rule has a parent/pseudoclass/pseudoelement, we need to call Match
            // to make sure the rule applies.
            // Otherwise, the rule will apply since it is a wildcard (bare class/id) rule.
            while (nWildcardRules && 
                    (!pRule->GetSelector() || 
                     !pRule->MediaTypeMatches(eMediaType) ||
                     ((pRule->GetSelector()->_pParent ||
                       (pRule->GetSelector()->_ePseudoclass != pclassNone) ||
                       (pRule->GetSelector()->_ePseudoElement != pelemNone))
                      && !pRule->GetSelector()->Match(pStyleInfo, passType, &CIDCache))
                    )
                  )
            {
                TraceTag((tagStyleSheetApply, "Check Wildcard Rule %08lX", pRule->GetRuleID()));
                --nWildcardRules;
                ++iWCNum;
                while ((iLastWCRule == iWCNum) && nWildcardRules)
                {
                    ++iWCNum;
                    --nWildcardRules;
                }
                if (nWildcardRules)
                {
                    iLastWCRule = iWCNum;
                    pWildcardRule = pcWRules->Item(iWCNum)._pRule;
                    sidWildRule   = pcWRules->Item(iWCNum)._sidSheetRule;
                    pRule = pWildcardRule;
                }
            }
            epeWildcard = pCFI ? pCFI->GetMatchedBy() : pelemNone;
        }
        
        // When we get here, nTagRules and nWildcardRules index to rules that need to be applied.
        if (nTagRules)
        {
            if (nWildcardRules)
            {
                // If we get here, then we have a wildcard rule AND a tag rule that need to be applied.
                // NOTE: This '>=' should eventually take source order into account.
                if ( pTagRule->GetSpecificity() >= pWildcardRule->GetSpecificity() )
                {
                    // If the specificity of the tag rule is greater or equal, apply the wildcard rule here,
                    // then we'll overwrite it by applying the tag rule later.
                    if ( pWildcardRule->GetStyleAA() )
                    {
                        cachedSS.PrepareForCache( sidWildRule, pWildcardRule);

                        TraceTag((tagStyleSheetApply, "Applying Wildcard Rule: %08lX to etag: %ls  id: %ls", 
                            (DWORD)pWildcardRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                        if (pCFI)
                            pCFI->SetMatchedBy(epeWildcard);
                        
                        hr = THR( ApplyAttrArrayValues (
                            pStyleInfo,
                            pWildcardRule->GetRefStyleAA(),
                            &cachedSS,
                            passType,
                            pfContainsImportant ) );

                        if ( hr != S_OK )
                            break;
                    }
                    fWildcardApplied = TRUE;
                    --nWildcardRules;
                    ++iWCNum;
                }
                else
                {
                    if ( pTagRule->GetStyleAA() )
                    {
                        cachedSS.PrepareForCache( sidTagRule ,pTagRule);
                                        
                        TraceTag((tagStyleSheetApply, "Applying Tag Rule: %08lX to etag: %ls  id: %ls", 
                            (DWORD)pTagRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                        if (pCFI)
                            pCFI->SetMatchedBy(epeTag);
                        
                        hr = THR( ApplyAttrArrayValues (
                            pStyleInfo,
                            pTagRule->GetRefStyleAA(),
                            &cachedSS,
                            passType,
                            pfContainsImportant ) );

                        if ( hr != S_OK )
                            break;
                    }
                    fTagApplied = TRUE;
                    --nTagRules;
                    ++iTagNum;
                }
            }
            else
            {
                if ( pTagRule->GetStyleAA() )
                {
                    cachedSS.PrepareForCache( sidTagRule, pTagRule);
                                        
                    TraceTag((tagStyleSheetApply, "Applying Tag Rule: %08lX to etag: %ls  id: %ls", 
                        (DWORD)pTagRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                    if (pCFI)
                        pCFI->SetMatchedBy(epeTag);
                    
                    hr = THR( ApplyAttrArrayValues (
                        pStyleInfo,
                        pTagRule->GetRefStyleAA(),
                        &cachedSS,
                        passType,
                        pfContainsImportant ) );

                    if ( hr != S_OK )
                        break;
                }
                fTagApplied = TRUE;
                --nTagRules;
                ++iTagNum;
            }
        }
        else if ( nWildcardRules )
        {
            if ( pWildcardRule->GetStyleAA() )
            {
                cachedSS.PrepareForCache( sidWildRule, pWildcardRule);
                                
                TraceTag((tagStyleSheetApply, "Applying Wildcard Rule: %08lX to etag: %ls  id: %ls", 
                    (DWORD) pWildcardRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                if (pCFI)
                    pCFI->SetMatchedBy(epeWildcard);
                
                hr = THR( ApplyAttrArrayValues (
                    pStyleInfo,
                    pWildcardRule->GetRefStyleAA(),
                    &cachedSS,
                    passType,
                    pfContainsImportant ) );

                if ( hr != S_OK )
                    break;
            }
            fWildcardApplied = TRUE;
            --nWildcardRules;
            ++iWCNum;
        }
    }   // End of while(nTagRules || nWildcardRules) loop

    if (pCFI)
       pCFI->SetMatchedBy(pelemNone);
    
    pStyleInfo->_ProbRules.Invalidate(this);

    RRETURN( hr );
}

//*********************************************************************
//      CStyleSheetArray::TestForPseudoclassEffect()
//              This method checks all the style rules in this collection of
//  style sheets to see if a change in pseudoclass will change any
//  properties.
//*********************************************************************
BOOL CStyleSheetArray::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )
{
    AssertSz( pStyleInfo, "NULL styleinfo!" );
    AssertSz( pStyleInfo->_pNodeContext, "NULL node context!" );
    CElement *pElem = pStyleInfo->_pNodeContext->Element();
    AssertSz( pElem, "NULL element!" );

    int z;
    int nSheets;
    
    CDoc *pDoc = pElem->Doc();
    AssertSz( pDoc, "No Document attached to this Site!" );

    if ( pDoc->_pOptionSettings && !pDoc->_pOptionSettings->fUseStylesheets )
        return FALSE;   // Stylesheets are turned off.


    for (z=0, nSheets = _aStyleSheets.Size(); z<nSheets; ++z)
    {
        CStyleSheet *pSS = _aStyleSheets[z];

        if (pSS->TestForPseudoclassEffect(pStyleInfo, fVisited,  fActive, fOldVisited, fOldActive ))
            return TRUE;
    }

    return FALSE;
}



//*********************************************************************
//      CStyleSheetArray::Get()
//  Acts like the array operator.
//*********************************************************************
CStyleSheet * CStyleSheetArray::Get( long lIndex )
{
    if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
    {
        return NULL;
    }

    return _aStyleSheets[ lIndex ];
}


//*********************************************************************
//  CStyleSheetArray::length
//      IHTMLStyleSheetsCollection interface method
//*********************************************************************

HRESULT
CStyleSheetArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aStyleSheets.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//*********************************************************************
//  CStyleSheetArray::item
//      IHTMLStyleSheetsCollection interface method.  This overload is
//  not exposed via the PDL; it's purely internal.  Automation clients
//  like VBScript will access the overload that takes variants.
//*********************************************************************

HRESULT
CStyleSheetArray::item(long lIndex, IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT   hr;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // Just exit if access is out of bounds.
    if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void**)ppHTMLStyleSheet);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CStyleSheetArray::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT             hr = S_OK;
    long                lIndex;
    IHTMLStyleSheet     *pHTMLStyleSheet;
    CVariant            cvarArg;

    if (!pvarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Clear return value
    VariantInit (pvarRes);

    if (VT_EMPTY == V_VT(pvarArg1))
    {
        Assert("Don't know how to deal with this right now!" && FALSE);
        goto Cleanup;
    }

    // first attempt ordinal access...
    hr = THR(cvarArg.CoerceVariantArg(pvarArg1, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&cvarArg);

        // Just exit if access is out of bounds.
        if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void **)&pHTMLStyleSheet);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // not a number so try a name
        hr = THR_NOTRACE(cvarArg.CoerceVariantArg(pvarArg1, VT_BSTR));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            // its a string, so handle named access
            if ( _Level != 1 )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            lIndex = FindSSByHTMLID( (LPTSTR)V_BSTR(pvarArg1), FALSE ); // not case sensitive for VBScript
            if ( lIndex == -1 )
            {
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }

            hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void **)&pHTMLStyleSheet);
            if (hr)
                goto Cleanup;

        }
    }

    V_VT(pvarRes) = VT_DISPATCH;
    V_DISPATCH(pvarRes) = pHTMLStyleSheet;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheetArray::_newEnum
//      IHTMLStyleSheetsCollection interface method
//*********************************************************************

HRESULT
CStyleSheetArray::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aStyleSheets.EnumVARIANT(VT_DISPATCH,
                                      (IEnumVARIANT**)ppEnum,
                                      FALSE,
                                      FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheetArray::FindSSByHTMLID
//  Searches the array for a stylesheet whose parent element has
//  the specified HTML ID.  Returns index if found, -1 if not found.
//*********************************************************************

long
CStyleSheetArray::FindSSByHTMLID( LPCTSTR pszID, BOOL fCaseSensitive )
{
    HRESULT   hr;
    CElement *pElem;
    BSTR      bstrID;
    long      lIdx;

    for ( lIdx = 0 ; lIdx < _aStyleSheets.Size() ; ++lIdx )
    {
        pElem = (_aStyleSheets[lIdx])->GetParentElement();
        Assert( "Must always have parent element!" && pElem );
        // TODO perf: more efficient way to get id?
        hr = pElem->get_PropertyHelper( &bstrID, (PROPERTYDESC *)&s_propdescCElementid );
        if ( hr )
            return -1; 

        if (bstrID)
        {
            if ( !(fCaseSensitive ? _tcscmp( pszID, bstrID ) : _tcsicmp( pszID, bstrID )) )
            {
                FormsFreeString(bstrID);
                return lIdx;
            }
            FormsFreeString(bstrID);
        }
    }
    return -1;
}



//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchDownloadedFont, static
//
//  Synopsis:   If the supplied face name maps to a successfully 
//              downloaded (embedded) font, fill in the appropriate 
//              pCF members and return TRUE. Otherwise, leave pCF untouched 
//              and return FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CStyleSheetArray::__ApplyFontFace_MatchDownloadedFont(TCHAR * szFaceName, 
                                    CCharFormat * pCF, 
                                    CMarkup * pMarkup)
{
   Assert(_tcsclen(szFaceName) < LF_FACESIZE);

   CStyleSheet **ppSheet;
   int z;
   int nSheets = _aStyleSheets.Size();
   for (ppSheet = (CStyleSheet **) _aStyleSheets, z=0; z<nSheets; ++z, ++ppSheet)
   {
        int n = (*ppSheet)->GetNumDownloadedFontFaces();
        CFontFace **ppFace = (*ppSheet)->GetDownloadedFontFaces();

        for( ; n > 0; --n, ppFace++)
        {
            if (((*ppFace)->IsInstalled()) && (_tcsicmp(szFaceName, (*ppFace)->GetFriendlyName()) == 0))
            {
                pCF->SetFaceName((*ppFace)->GetInstalledName());
                pCF->_bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                pCF->_bCharSet = DEFAULT_CHARSET;
                pCF->_fDownloadedFont = TRUE;
                return TRUE;
            }
        }

        if ((*ppSheet)->_pImportedStyleSheets)
        {
            if ((*ppSheet)->_pImportedStyleSheets->__ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup))
                return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\sheets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sheets.cxx
//
//  Contents:   Support for Cascading Style Sheets.. including:
//
//              CStyleSelector
//              CStyleRule
//              CStyleSheet
//              CStyleID
//              CSharedStyleSheet
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif


#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"  // For CAnchorElement decl, for pseudoclasses
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"    // for CLinkElement
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"   // for CStyleElement
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif



// NOTE: Right now we do a certain amount of dyncasting of _pParentElement to
// either CLinkElement or CStyleElement.  Consider developing an ABC (CStyleSheetElement?)
// that exposes the stylesheet support for elements (e.g. _pStyleSheet, SetReadyState() etc)?
// Might be more trouble than it's worth..

#define _cxx_
#include "sheet.hdl"

MtDefine(StyleSheets, Mem, "StyleSheets")
MtDefine(CStyleSheet, StyleSheets, "CStyleSheet")
MtDefine(CStyleSheet_apFontFaces_pv, CStyleSheet, "CStyleSheet::_apFontFace_pv");
MtDefine(CStyleSheet_apOMRules_pv, CStyleSheet, "CStyleSheet::_apOMRules_pv")
MtDefine(CStyleSheet_CreateNewStyleSheet, StyleSheets, "CStyleSheet::CreateNewStyleSheet");
MtDefine(CNamespace, CStyleSheet, "CStyleSheet::_pDefaultNamespace")
MtDefine(CStyleSelector, StyleSheets, "CStyleSelector")
MtDefine(CStyleClassIDCache, StyleSheets, "CStyleClassIDCache")
MtDefine(CachedStyleSheet, StyleSheets, "CachedStyleSheet")
MtDefine(CStyleSheetAddImportedStyleSheet_pszParsedURL, Locals, "CStyleSheet::AddImportedStyleSheet pszParsedURL")
MtDefine(CClassCache_ary, StyleSheets, "CClassCache_ary")
MtDefine(CCache_ary, StyleSheets, "CCache_ary")
MtDefine(CClassIDStr, StyleSheets, "CClassIDStr")




DeclareTag(tagStyleSheet,                    "Style Sheet", "trace Style Sheet operations")
ExternTag(tagSharedStyleSheet)
extern BOOL GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem);


#if  DBG == 1
void DumpHref(TCHAR *pszHref)
{
    if (IsTagEnabled(tagStyleSheet))
    {
        CStr        strRule;
        CHAR       szBuffer[2000];

        WideCharToMultiByte(CP_ACP, 0, pszHref, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        TraceTag( (tagStyleSheet, "Href == [%s]", szBuffer) );
    }
}
#endif                



//*********************************************************************
//  CStyleClassIDCache::~CStyleClassIDCache()
//*********************************************************************
CStyleClassIDCache::~CStyleClassIDCache()
{
    CCacheEntry * pEntry = _aCacheEntry;
    int i = _aCacheEntry.Size();

    for ( ; i > 0 ; i--, pEntry++ )
    {
        pEntry->~CCacheEntry();
    }
}

//*********************************************************************
//  CStyleClassIDCache::EnsureSlot(int slot)
//      Makes sure that this slot is initialized and ready to use
//*********************************************************************
HRESULT CStyleClassIDCache::EnsureSlot(int slot)
{
    HRESULT hr = S_OK;
    int     nOrigSize = _aCacheEntry.Size();
    int     i;
    CCacheEntry * pAryStart;

    Assert(slot >= 0);

    if (slot < nOrigSize)
        goto Cleanup;

    pAryStart = _aCacheEntry;
    
    hr = _aCacheEntry.Grow(slot+1);
    if (hr)
        goto Cleanup;

    if (pAryStart != _aCacheEntry)
    {
        pAryStart = _aCacheEntry;

        for( i = 0; i < nOrigSize; i++, pAryStart++ )
        {
            pAryStart->_aryClass.ReinitAfterPossibleRealloc();
        }
    }
    else
    {
        pAryStart = &(_aCacheEntry[nOrigSize]);
    }

    Assert( pAryStart == &(_aCacheEntry[nOrigSize]));

    for( i = nOrigSize; i <= slot; i++, pAryStart++ )
    {
        // use placement new
        new(pAryStart) CCacheEntry;
    }

Cleanup:
    RRETURN(hr);
}

//*********************************************************************
//  CStyleClassIDCache::PutClass(LPCTSTR pszClass, int slot)
//      Parses and stores the class in the cache.
//*********************************************************************

HRESULT CStyleClassIDCache::PutClass(LPCTSTR pszClass, int slot)
{
    HRESULT hr = S_OK;
    LPCTSTR pszThisClass = NULL; // keep compiler happy
    INT nThisLength = 0; // keep compiler happy
    CClassCache * pClass;
    CDataListEnumerator classNames(pszClass);

    Assert(slot >= 0);
    
    hr = EnsureSlot(slot);
    if (hr)
        goto Cleanup;

    _aCacheEntry[slot]._pszClass = pszClass;

    // Allow for comma, seperated ClassName
    while (classNames.GetNext(&pszThisClass, &nThisLength))
    {
        // NOTE: This should always be non zero but check was in old code...
        Assert(nThisLength); 

        hr = _aCacheEntry[slot]._aryClass.AppendIndirect(NULL, &pClass);
        if (hr)
            goto Cleanup;

        pClass->_pszClass = pszThisClass;
        pClass->_cchClass = nThisLength;
        pClass->_dwHash = HashStringCiDetectW(pszThisClass, nThisLength, 0);
    }

Cleanup:
    RRETURN(hr);
}

//*********************************************************************
//  CStyleClassIDCache::PutNoClass(int slot)
//      Puts an empty entry to denote cache spot is taken.
//*********************************************************************

HRESULT CStyleClassIDCache::PutNoClass(int slot)
{
    HRESULT hr;
    Assert(slot >= 0); 
    
    hr = THR(EnsureSlot(slot));
    if (hr)
        goto Cleanup;

    _aCacheEntry[slot]._pszClass = NULL;

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleClassIDCache::PutID(int slot)
//      Stores the ID in the Cache
//*********************************************************************

void CStyleClassIDCache::PutID(LPCTSTR pszID, int slot)
{
    Assert(slot >= 0); 
    
    if (S_OK != EnsureSlot(slot))
        return;
    
    _aCacheEntry[slot]._pszID = pszID; 
}

//---------------------------------------------------------------------
//  Class Declaration:  CStyleSelector
//      This class implements a representation of a stylesheet selector -
//  that is, a particular tag/attribute situation to match a style rule.
//---------------------------------------------------------------------

//*********************************************************************
//  CStyleSelector::CStyleSelector()
//      The constructor for the CStyleSelector class initializes all
//  member variables.
//*********************************************************************

CStyleSelector::CStyleSelector (Tokenizer &tok, CStyleSelector *pParent, BOOL fIsStrictCSS1, BOOL fXMLGeneric)
{
    _fSelectorErr = FALSE;
    _ulRefs = 0;    // this is to fool the code that does not know that selector does refcounting
    _pParent = pParent;
    _pSibling = NULL;
    _eElementType = ETAG_UNKNOWN;
    _ePseudoclass = pclassNone;
    _ePseudoElement = pelemNone;

    _dwStrClassHash = 0;
    _fIsStrictCSS1 = !!fIsStrictCSS1;

    Init(tok, fXMLGeneric);
}

CStyleSelector::CStyleSelector ()
{
    _ulRefs = 0;
    _pParent = NULL;
    _pSibling = NULL;
    _ePseudoclass = pclassNone;
    _ePseudoElement = pelemNone;
    _eElementType = ETAG_NULL;

    _dwStrClassHash = 0;
}

//*********************************************************************
//  CStyleSelector::~CStyleSelector()
//*********************************************************************
CStyleSelector::~CStyleSelector( void )
{
    delete _pParent;
    delete _pSibling;
}

//*********************************************************************
//  CStyleSelector::Init()
//      This method parses a string selector and initializes all internal
//  member data variables.
//*********************************************************************

HRESULT CStyleSelector::Init (Tokenizer &tok, BOOL fXMLGeneric)
{
    HRESULT                 hr = S_OK;
    TCHAR                  *szIdent;
    ULONG                   cSzIdent;   
    Tokenizer::TOKEN_TYPE   tt;

/*
    selector
      : simple_selector
    simple_selector
      : [[scope:\]? element_name]? [ HASH | class | pseudo ]* S*
    class
      : '.' IDENT
    element_name
      : IDENT | '*'
    pseudo
      : ':' [ IDENT | FUNCTION S* IDENT S* ')' ]
    HASH
      : '#' IDENT
*/

    // First we parse the first part of a selector. E.g. in TABLE DIV #id we are parsing TABLE.

    tt = tok.TokenType();

    Assert(!_fSelectorErr);
    if (tok.IsIdentifier(tt))
    {
        if (fXMLGeneric)
        {
            _eElementType = ETAG_NULL;

            if (tok.CurrentChar() == CHAR_ESCAPE)
            {
                if (tok.IsKeyword(_T("HTML")))
                {
                    if (tok.NextToken() == Tokenizer::TT_EscColon)
                    {
                        // from the html namespace
                        // just skip past the HTML\: and continue the normal HTML parse
                        fXMLGeneric = FALSE;
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_Asterisk)
                        {
                            if(_Nmsp.IsEmpty())
                                _eElementType = ETAG_UNKNOWN;      // Wildcard
                            else
                                _eElementType = ETAG_GENERIC;
              
                            _cstrTagName.Set (_T("*"), 1);
                            goto ParseRemaining;  // Done, fetch next token in selector
                        }
                        else if (!tok.IsIdentifier(tt))
                        {
                            // Error, discard this token and continue with rest in this selector
                            hr = S_FALSE;
                            goto ParseRemaining;
                        }
                    }
                    else
                    {
                        // Error, discard this token and continue with rest in this selector
                        hr = S_FALSE;
                        goto ParseRemaining;
                    }
                }
            }
        }

        szIdent = tok.GetStartToken();
        cSzIdent = tok.GetTokenLength();

        if (!fXMLGeneric)
            _eElementType = EtagFromName(szIdent, cSzIdent);      

        if (_eElementType == ETAG_NULL || !_Nmsp.IsEmpty() || tok.CurrentChar() == CHAR_ESCAPE)
        {
            _eElementType = ETAG_GENERIC;
            if(tok.CurrentChar() == CHAR_ESCAPE)
            {
                if (tok.NextToken() == Tokenizer::TT_EscColon)
                {
                    // The selector has scope\:name syntax
                    _Nmsp.SetShortName(szIdent, cSzIdent);
                    
                    tt = tok.NextToken();

                    if (tok.IsIdentifier(tt))
                    {
                        szIdent = tok.GetStartToken();
                        cSzIdent = tok.GetTokenLength();

                        _cstrTagName.Set(szIdent, cSzIdent);
                    }
                    else if (tt == Tokenizer::TT_Asterisk)
                    {
                        if(_Nmsp.IsEmpty())
                            _eElementType = ETAG_UNKNOWN;      // Wildcard
                        else
                            _eElementType = ETAG_GENERIC;
              
                        _cstrTagName.Set (_T("*"), 1);
                    }
                    else
                        hr = S_FALSE;
                }
                else
                    hr = S_FALSE;
            }
            else
            {
                _cstrTagName.Set(szIdent, cSzIdent);
            }
        }
    }
    else if (tt == Tokenizer::TT_Asterisk)
    {
        if(_Nmsp.IsEmpty())
            _eElementType = ETAG_UNKNOWN;      // Wildcard
        else
            _eElementType = ETAG_GENERIC;

        _cstrTagName.Set (_T("*"), 1);
    }
    else
        hr = S_FALSE;

// Now we parse the rest of the selector. E.g in TABLE DIV #id the DIV #id part.

ParseRemaining:

    tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        if (hr == S_OK)
        {
            // if no whitespace then next token is part of same selector, else bale out.
            if (isspace(tok.PrevChar()))
            {
                tt = tok.NextToken();
                break;
            }
            else
                tt = tok.NextToken();

            // Pseudo elements are only allowed at the beginning of a selector. If we are in standard compliant mode this
            // sets the flag that the rule is invalid in standard compliant mode.
            if ((_ePseudoElement!=pelemNone) && _fIsStrictCSS1) 
                _fSelectorErr = TRUE;    
        }
        else
            hr = S_OK;

        if (tt == Tokenizer::TT_Hash)
        {
            tt = tok.NextToken();

            if (tok.IsIdentifier(tt))
            {
                szIdent = tok.GetStartToken();
                cSzIdent = tok.GetTokenLength();
                _cstrID.Set(szIdent, cSzIdent);


                // In standard compliant mode we have a different set of allowed selectors than in compatible mode.
                // We mark invalid (with resp to CSS) selectors.
                if (_fIsStrictCSS1 && !tok.IsCSSIdentifier(tt))
                    _fSelectorErr = TRUE;
            }
        }
        else if (tt == Tokenizer::TT_Dot)
        {
            tt = tok.NextToken();

            if (tok.IsIdentifier(tt))
            {
                szIdent = tok.GetStartToken();
                cSzIdent = tok.GetTokenLength();
                _cstrClass.Set(szIdent, cSzIdent);
                _dwStrClassHash = HashStringCiDetectW(szIdent, cSzIdent, 0 /*Hash seed*/);

                // In standard compliant mode we have a different set of allowed selectors than in compatible mode.
                // We mark invalid (with resp to CSS) selectors.
                if (_fIsStrictCSS1 && !tok.IsCSSIdentifier(tt))
                    _fSelectorErr = TRUE;
            }
        }
        else if (tt == Tokenizer::TT_Colon)
        {
            tt = tok.NextToken();

            if (tok.IsKeyword(_T("active")))
                _ePseudoclass = pclassActive;
            else if (tok.IsKeyword(_T("visited")))
                _ePseudoclass = pclassVisited;
            else if (tok.IsKeyword(_T("hover")))
                _ePseudoclass = pclassHover;
            else if (tok.IsKeyword(_T("link")))
                _ePseudoclass = pclassLink;
            else if (tok.IsKeyword(_T("first-letter")))
                _ePseudoElement = pelemFirstLetter;
            else if (tok.IsKeyword(_T("first-line")))
                _ePseudoElement = pelemFirstLine;
            else
            {
                // Unrecognized Pseudoclass/Pseudoelement name!
                _ePseudoElement = pelemUnknown;
            }
        }
        else // unknown token for current selector or end of current selector, bail out.
            break;

        // if we get here then current token is '.',':' or '#'
        if (!tok.IsIdentifier(tt))
        {
            // malformed '.',':' or '#', get outa here.
            if (tt != Tokenizer::TT_Dot &&
                tt != Tokenizer::TT_Colon &&
                tt != Tokenizer::TT_Hash)
                break;
            else
                hr = S_FALSE; // continue with current token.
        }
    }

    return S_OK;
}


//*********************************************************************
//  CStyleSelector::GetSpecificity()
//      This method computes the cascade order specificity from the
//  number of tagnames, IDs, classes, etc. in the selector.
//*********************************************************************
DWORD CStyleSelector::GetSpecificity( void )
{
    DWORD dwRet = 0;

    if ( _eElementType != ETAG_UNKNOWN )
        dwRet += SPECIFICITY_TAG;
    if ( _cstrClass.Length() )
        dwRet += SPECIFICITY_CLASS;
    if ( _cstrID.Length() )
        dwRet += SPECIFICITY_ID;
    switch ( _ePseudoclass )
    {
    case pclassActive:
    case pclassVisited:
    case pclassHover:
        dwRet += SPECIFICITY_PSEUDOCLASS;
        //Intentional fall-through
    case pclassLink:
        dwRet += SPECIFICITY_PSEUDOCLASS;
        break;
    }
    switch ( _ePseudoElement )
    {
    case pelemFirstLetter:
        dwRet += SPECIFICITY_PSEUDOELEMENT;
        //Intentional fall-through
    case pelemFirstLine:
        dwRet += SPECIFICITY_PSEUDOELEMENT;
        break;
    }

    if ( _pParent )
        dwRet += _pParent->GetSpecificity();

    return dwRet;
}


//*********************************************************************
//  CStyleSelector::MatchSimple()
//      This method compares a simple selector with an element.
//*********************************************************************

MtDefine(MStyleSelector, Metrics, "Style Selector Matching");
MtDefine(MStyleSelectorClassCacheMisses, MStyleSelector, "Class Cache Misses");
MtDefine(MStyleSelectorClassMatchAttempts, MStyleSelector, "Class Match Attempts");
MtDefine(MStyleSelectorHashMisses, MStyleSelector, "Hash Misses");

BOOL CStyleSelector::MatchSimple( CElement *pElement, CFormatInfo *pCFI, CStyleClassIDCache *pCIDCache, int iCacheSlot, EPseudoclass *pePseudoclass)
{
    // If that element tag doesn't match what's specified in the selector, then NO match.
    if ( ( _eElementType != ETAG_UNKNOWN ) && ( _eElementType != pElement->TagType() ) || _fSelectorErr)
        return FALSE;

    LPCTSTR pszClass;
    LPCTSTR pszID;

    // if an extended tag, match scope name and tag name
    if ((_eElementType == ETAG_GENERIC))
    {
        // CONSIDER: the _tcsicmp-s below is a potential perf problem. Use atom table for the
        // scope name and tag name to speed this up.
        if(0 != _tcsicmp(pElement->NamespaceHtml(), _Nmsp.GetNamespaceString()))
            // Namespaces don't match
            return FALSE;
        if(0 != _tcsicmp(_T("*"), _cstrTagName) &&                       // not a wild card and
             0 != _tcsicmp(pElement->TagName(), _cstrTagName))           //   tag name does not match
            return FALSE;                                                // then report no match
    }

    // We only need to check when the cache slot is greater than 0
    // This code is required in case of a contextual selector (ie if there is a parent)
    if (iCacheSlot > 0)
    {
        INT nLen = _cstrClass.Length();
        // Only worry about classes on the element if the selector has a class
        if ( nLen )
        {
        
            MtAdd(Mt(MStyleSelectorClassMatchAttempts), 1, 0);
        
            // If we don't know the class of the element, get it now.
            if (!pCIDCache->IsClassSet(iCacheSlot))
            {
                HRESULT hr;

                pszClass = NULL;

                MtAdd(Mt(MStyleSelectorClassCacheMisses), 1, 0);

                hr = pElement->GetStringAt(
                        pElement->FindAAIndex(DISPID_CElement_className, CAttrValue::AA_Attribute),
                        &pszClass);

                if (S_OK != hr && DISP_E_MEMBERNOTFOUND != hr)
                    return FALSE;

                if (pszClass)
                    hr = pCIDCache->PutClass(pszClass, iCacheSlot);
                else
                    hr = pCIDCache->PutNoClass(iCacheSlot);

                if (hr)
                    return FALSE;
            }

            CClassCacheAry* pClassCache = pCIDCache->GetClass(iCacheSlot);

            // pClassCache should never be NULL, if it reaches this point in the code
            Assert(pClassCache != NULL);

            CClassCache *pElem;
            int    i;

            for (i = pClassCache->Size(), pElem = *pClassCache;
                 i > 0;
                 i--, pElem++)
            {
                 if (pElem->_dwHash == _dwStrClassHash)
                 {
                    if (nLen == pElem->_cchClass)
                    {
                        // Case sensitive comparision iff in strict css mode.
                        if (_fIsStrictCSS1 ? 
                              !_tcsncmp ( (LPTSTR)_cstrClass, nLen, pElem->_pszClass, pElem->_cchClass)
                            : !_tcsnicmp ( (LPTSTR)_cstrClass, nLen, pElem->_pszClass, pElem->_cchClass)
                           )
                        {
                                goto CompareIDs;
                        }
#ifdef PERFMETER
                        else
                            MtAdd(Mt(MStyleSelectorHashMisses), 1, 0);
#endif
                    }
                 }
            }

            return FALSE;
        }

    CompareIDs:
        // Only worry about ids on the element if the selector has an id
        if ( _cstrID.Length() )
        {
            pszID = pCIDCache->GetID(iCacheSlot);
            // No match if the selector has an ID but the element doesn't.
            if ( !pszID )
                return FALSE;
            // If we don't know the ID of the element, get it now.
            if (pszID == UNKNOWN_CLASS_OR_ID)
            {
                HRESULT hr;

                hr =  pElement->GetStringAt( 
                        pElement->FindAAIndex( DISPID_CElement_id, CAttrValue::AA_Attribute ),
                        &pszID);

                if (S_OK != hr && DISP_E_MEMBERNOTFOUND != hr)
                    return FALSE;

                pCIDCache->PutID(pszID, iCacheSlot);

                if (!pszID)
                    return FALSE;
            }
            // Case sensitive comparision iff in strict css mode.
            if (_fIsStrictCSS1 ? _tcscmp( _cstrID, pszID ) : _tcsicmp( _cstrID, pszID ))
                return FALSE;
        }
    }

    if ( _ePseudoclass != pclassNone )
    {
        AAINDEX idx;

        if ( pElement->TagType() != ETAG_A )    // NOTE: Eventually, we should allow other hyperlink types here, like form submit buttons or LINKs.
            return FALSE;                       // When we do, change the block below as well.

        if ( pePseudoclass )
        {
            if ( *pePseudoclass == _ePseudoclass )
                return TRUE;
            else
                return FALSE;
        }

        if ( !*(pElement->GetAttrArray()) )
            return FALSE;

                                                // The following is the block that has to change:
        idx = pElement->FindAAIndex( DISPID_CAnchorElement_href, CAttrValue::AA_Attribute );
        if ( idx == AA_IDX_UNKNOWN )
            return FALSE;   // No HREF - must be a target anchor, not a source anchor.

        CAnchorElement *pAElem = DYNCAST( CAnchorElement, pElement );
        EPseudoclass psc = pAElem->IsVisited() ? pclassVisited : pclassLink;

        // Hover and Active are applied in addition to either visited or link
        // Hover is ignored if anchor is active.
        if (    _ePseudoclass == psc
            ||  (pAElem->IsActive()  && _ePseudoclass == pclassActive)
            ||  (pAElem->IsHovered() && _ePseudoclass == pclassHover) )
            return TRUE;
        return FALSE;
    }

    if (pCFI)
    {
        if (_ePseudoElement == pelemUnknown)
        {
            return FALSE;
        }

        // See comment in formats.cxx function CElement::ApplyDefaultFormat for this.
        if (    pCFI->_fFirstLetterOnly
            && _ePseudoElement != pelemFirstLetter
           )
        {
            pCFI->SetMatchedBy(pelemNone);
            return FALSE;
        }

        if (   pCFI->_fFirstLineOnly
            && _ePseudoElement != pelemFirstLine
           )
        {
            pCFI->SetMatchedBy(pelemNone);
            return FALSE;
        }
        
        pCFI->SetMatchedBy(_ePseudoElement);
    }
    else
    {
        return (_ePseudoElement == pelemNone);
    }

    return TRUE;
}

//*********************************************************************
//  CStyleSelector::Match()
//      This method compares a contextual selector with an element context.
//*********************************************************************
BOOL CStyleSelector::Match( CStyleInfo * pStyleInfo, ApplyPassType passType, CStyleClassIDCache *pCIDCache, EPseudoclass *pePseudoclass /*=NULL*/ )
{
    CStyleSelector *pCurrSelector = this;
    int iCacheSlot = 0;
    CTreeNode *pNode = pStyleInfo->_pNodeContext;
    CFormatInfo *pCFI = (passType == APPLY_Behavior) ? NULL : (CFormatInfo*)pStyleInfo;
    EPseudoElement epeSave = pelemNone;
    BOOL fIsComplexRule = FALSE;
    
    // Cache slot 0 stores the original elem's class/id
    if ( !pCurrSelector->MatchSimple( pNode->Element(), pCFI, pCIDCache, iCacheSlot, pePseudoclass) )
        return FALSE;

    if (pCFI)
    {
        epeSave = pCFI->GetMatchedBy();
        pCFI->SetMatchedBy(pelemNone);
    }
    
    pCurrSelector = pCurrSelector->_pParent;
    pNode = pNode->Parent();
    ++iCacheSlot;

    fIsComplexRule = !!pCurrSelector;
    
    // We matched the innermost part of the contextual selector.  Now walk up
    // the remainder of the contextual selector (if it exists), testing whether our
    // element's containers satisfy the remainder of the contextual selector.  MatchSimple()
    // stores our containers' class/id in cache according to their containment level.
    while ( pCurrSelector && pNode )
    {
        if ( pCurrSelector->MatchSimple( pNode->Element(), pCFI, pCIDCache, iCacheSlot, pePseudoclass) )
            pCurrSelector = pCurrSelector->_pParent;
        // Rules like:
        //
        // FORM DIV:first-letter B { color : red }
        //
        // are explicitly disallowed by CSS. Hence the first MatchSimple will set
        // the epe to none and then the one in the loop will set it to eFirstLetter.
        // If we see this happen then we should just return a rule mis-match, since we
        // are supposed to ignore them.
        if (pCFI && pCFI->GetMatchedBy() != pelemNone)
                return FALSE;
        
        pNode = pNode->Parent();
        
        ++iCacheSlot;
    }

    if (pCFI)
    {
        // Restore the psuedo element which we found during match of the first
        // selector. The parent selectors are uninteresting and are explicitly
        // disallowed by CSS
        pCFI->SetMatchedBy(epeSave);
    }
    
    if ( !pCurrSelector )
    {
        if (fIsComplexRule && pCFI)
            pCFI->NoStealing();
        return TRUE;
    }
    return FALSE;
}

HRESULT CStyleSelector::GetString( CStr *pResult )
{
    Assert( pResult );

    if ( _pParent )     // This buys us the context selectors.
        _pParent->GetString( pResult );

    switch ( _eElementType )
    {
    case ETAG_UNKNOWN:  // Wildcard - don't write tag name.
        break;
    case ETAG_NULL:     // Unknown tag name - write it out as "UNKNOWN".
        pResult->Append( _T("UNKNOWN") );
        break;
    case ETAG_GENERIC:     // Peer
        if(!_Nmsp.IsEmpty())
        {
            pResult->Append(_Nmsp.GetNamespaceString());
            pResult->Append(_T("\\:"));
        }
        pResult->Append(_cstrTagName);
        break;
    default:
        pResult->Append( NameFromEtag( _eElementType ) );
        break;
    }

    if ( _cstrClass.Length() )
    {
        pResult->Append( _T(".") );
        pResult->Append( _cstrClass );
    }
    if ( _cstrID.Length() )
    {
        pResult->Append( _T("#") );
        pResult->Append( _cstrID );
    }
    switch ( _ePseudoclass )
    {
    case pclassActive:
        pResult->Append( _T(":active") );
        break;
    case pclassVisited:
        pResult->Append( _T(":visited") );
        break;
    case pclassLink:
        pResult->Append( _T(":link") );
        break;
    case pclassHover:
        pResult->Append( _T(":hover") );
        break;
#ifdef DEBUG
    default:
        Assertsz(0, "Unknown pseudoclass");
#endif
    }
    switch ( _ePseudoElement )
    {
    case pelemFirstLetter:
        pResult->Append( _T(":first-letter") );
        break;
    case pelemFirstLine:
        pResult->Append( _T(":first-line") );
        break;
    case pelemUnknown:
        pResult->Append( _T(":unknown") );
        break;
#ifdef DEBUG
    default:
        Assertsz(0, "Unknown pseudoelement");
#endif
    }
    pResult->Append( _T(" ") );
    return S_OK;
}


//---------------------------------------------------------------------
//  Class Declaration:  CStyleRule
//      This class represents a single rule in the stylesheet - a pairing
//  of a selector (the situation) and a style (the collection of properties
//  affected in that situation).
//---------------------------------------------------------------------

//*********************************************************************
//  CStyleRule::CStyleRule()
//*********************************************************************
CStyleRule::CStyleRule( CStyleSelector *pSelector )
{
    _dwSpecificity = 0;
    _pSelector = NULL;
    if ( pSelector )
        SetSelector( pSelector );
    _paaStyleProperties = NULL;
    _sidRule = 0;
    _dwMedia = 0;
    _dwAtMediaTypeFlags = 0;
#if DBG == 1    
    _dwPreSignature  = PRESIGNATURE;
    _dwPostSignature = POSTSIGNATURE;
#endif    
}


//*********************************************************************
//  CStyleRule::Clone
//*********************************************************************
HRESULT
CStyleRule::Clone(CStyleRule **ppClone)
{
    HRESULT hr = S_OK;

    Assert( ppClone );

    //
    // note _pSelector is shared since it is read only!
    // OM put_selectorText returns E_NOIMPL at this point!
    // 
    *ppClone = new CStyleRule(_pSelector); // this will setup _dwSpecificity 
    if (!*ppClone)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_paaStyleProperties)
    {
        hr = _paaStyleProperties->Clone( &((*ppClone)->_paaStyleProperties) );
        if (hr)
            goto Cleanup;
    }

    (*ppClone)->_sidRule = _sidRule;
    (*ppClone)->_dwMedia = _dwMedia;
    (*ppClone)->_dwAtMediaTypeFlags = _dwAtMediaTypeFlags;

Cleanup:
    if (hr && *ppClone)
    {
        delete (*ppClone);
        (*ppClone) = NULL;
    }
    RRETURN(hr);
}


//*********************************************************************
//  CStyleRule::~CStyleRule()
//*********************************************************************
CStyleRule::~CStyleRule()
{
    // Make sure we don't die while still attached to a selector
    Assert( (_pSelector == NULL) || (_pSelector == (CStyleSelector*)(LONG_PTR)(-1)) );
}

//*********************************************************************
//  CStyleRule::Free()
//      This method deletes all members of CStyleRule.
//*********************************************************************
void CStyleRule::Free( void )
{
    if ( _pSelector )
    {
        _pSelector->Release();
        _pSelector = NULL;
    }

    if ( _paaStyleProperties )
    {
        delete( _paaStyleProperties );
        _paaStyleProperties  = NULL;
    }
#ifdef DBG
    _pSelector = (CStyleSelector *)(LONG_PTR)(-1);
    _paaStyleProperties = (CAttrArray *)(LONG_PTR)(-1);
#endif
}

//*********************************************************************
//  CStyleRule::SetSelector()
//      This method sets the selector used for this rule.  Note that
//  this method should only be called once on any given CStyleRule object.
//*********************************************************************
void CStyleRule::SetSelector( CStyleSelector *pSelector )
{
    Assert( "Selector is already set for this rule!" && !_pSelector );
    Assert( "Can't set a NULL selector!" && pSelector );

    _pSelector = pSelector;
    _dwSpecificity = pSelector->GetSpecificity();
    _pSelector->AddRef();
}


ELEMENT_TAG  CStyleRule::GetElementTag() const
{
    Assert(_pSelector); 
    return _pSelector->_eElementType; 
}



HRESULT CStyleRule::GetString( CBase *pBase, CStr *pResult )
{
    HRESULT hr;
    BSTR bstr;

    Assert( pResult );

    if ( !_pSelector )
        return E_FAIL;
    _pSelector->GetString( pResult );

    pResult->Append( _T("{\r\n\t") );

    hr = WriteStyleToBSTR( pBase, _paaStyleProperties, &bstr, FALSE );
    if ( hr != S_OK )
        goto Cleanup;

    if ( bstr )
    {
        if ( *bstr )
            pResult->Append( bstr );
        FormsFreeString( bstr );
    }

    pResult->Append( _T("\r\n}\r\n") );
Cleanup:
    RRETURN(hr);
}


HRESULT CStyleRule::GetMediaString(DWORD dwCurMedia, CBufferedStr *pstrMediaString)
{
    HRESULT     hr = S_OK;
    int         i;
    BOOL        fFirst = TRUE;

    Assert(dwCurMedia != (DWORD)MEDIA_NotSet);

    dwCurMedia = dwCurMedia & (DWORD)MEDIA_Bits;

    if(dwCurMedia == (DWORD)MEDIA_All)
    {
        AssertSz(cssMediaTypeTable[0]._mediaType == MEDIA_All, "MEDIA_ALL must me element 0 in the array");
        hr = THR(pstrMediaString->Set(cssMediaTypeTable[0]._szName));
        goto Cleanup;
    }

    for(i = 1; i < ARRAY_SIZE(cssMediaTypeTable); i++)
    {
        if(cssMediaTypeTable[i]._mediaType & dwCurMedia)
        {
            if(fFirst)
            {
                pstrMediaString->Set(NULL);
                fFirst = FALSE;
            }
            else
            { 
                hr = THR(pstrMediaString->QuickAppend(_T(", ")));
            }
            if(hr)
                break;
            hr = THR(pstrMediaString->QuickAppend(cssMediaTypeTable[i]._szName));
            if(hr)
                break;
        }
    }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleRule::GetNamespace
//      Returns the namespace name that this rule belongs, NULL if none
//*********************************************************************
const CNamespace *
CStyleRule::GetNamespace() const
{
    Assert(_pSelector); 
    return _pSelector->GetNamespace();
}



#if DBG == 1
BOOL 
CStyleRule::DbgIsValid()
{
    //
    // _sidRule should only have rule information
    // 
    unsigned int nSheet = _sidRule.GetSheet();
    if (nSheet)
    {
        Assert("CStyleRule -- _sidRule should only contain rule info" && FALSE);
        return FALSE;
    }
    return TRUE;
}


VOID  CStyleRule::DumpRuleString(CBase *pBase)
{
    CStr        strRule;
    CHAR        szBuffer[2000];

    GetString(pBase, &strRule);
    WideCharToMultiByte(CP_ACP, 0, strRule, -1, szBuffer, sizeof(szBuffer), NULL, NULL);

    TraceTag((tagStyleSheet, "  StyleRule RuleID: %08lX  TagName: %s  Rule: %s", 
            (DWORD) GetRuleID(), GetSelector()->_cstrTagName, szBuffer));
}

#endif

//+---------------------------------------------------------------------------
//
// CStyleRuleArray.
//
//----------------------------------------------------------------------------
//*********************************************************************
//  CStyleRuleArray::Free()
//      This method deletes all members of CStyleRuleArray.
//*********************************************************************
void CStyleRuleArray::Free( )
{

    // We do not own the rules -- need to release them
    
    DeleteAll();
}

//*********************************************************************
//  CStyleRuleArray::InsertStyleRule()
//      This method adds a new rule to the rule array, putting it in
//  order in the stylesheet.  Note that the rules are kept in order of
//  DESCENDING preference (most important rules first) - this is due to
//  the mechanics of our Apply functions.
//*********************************************************************
HRESULT CStyleRuleArray::InsertStyleRule( CStyleRule *pNewRule, BOOL fDefeatPrevious, int *piIndex )
{
    Assert( "Style Rule is NULL!" && pNewRule );
    Assert( "Style Selector is NULL!" && pNewRule->GetSelector() );
    Assert( "Style ID isn't set!" && (pNewRule->GetRuleID() != 0) );

    if (piIndex)
        *piIndex = Size();

    return Append( pNewRule );
}


//*********************************************************************
//  CStyleRuleArray::InsertStyleRule()
//      This method delete a rule from the rule array -- it does not
//      manage the life time of the removed rule
//*********************************************************************
HRESULT 
CStyleRuleArray::RemoveStyleRule( CStyleRule *pOldRule, int *piIndex)
{
    int z;
    CStyleRule *pRule;

    Assert( "Style Rule is NULL!" && pOldRule );
    Assert( "Style Selector is NULL!" && pOldRule->GetSelector() );

    if (piIndex)
        *piIndex = -1;
        
    for ( z = 0; z < Size(); ++z)
    {
        pRule = Item(z);
        if (pRule == pOldRule)
        {
            if (piIndex)
                *piIndex = z;
                
            Delete(z);
            return S_OK;
        }
    }
    
    return E_FAIL;
}




//---------------------------------------------------------------------
//  Class Declaration:  CStyleSheetCtx
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//  Class Declaration:  CStyleSheet
//      This class represents a complete stylesheet.  It (will) hold a
//  list of ptrs to style rules, sorted by source order within the sheet.
//  Storage for the rules is managed by the stylesheet's containing array
//  (a CStyleSheetArray), which sorts them by tag and specificity
//  for fast application to the data.
//---------------------------------------------------------------------

const CStyleSheet::CLASSDESC CStyleSheet::s_classdesc =
{
    {
        &CLSID_HTMLStyleSheet,               // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleSheet,                // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnIHTMLStyleSheet                    // _apfnTearOff
};

//*********************************************************************
//  CStyleSheet::CStyleSheet()
//  You probably don't want to be calling this yourself to create style
//  sheet objects -- use CStyleSheetArray::CreateNewStyleSheet().
//*********************************************************************
CStyleSheet::CStyleSheet(
    CElement *pParentElem,
    CStyleSheetArray * const pSSAContainer
    )
    :
    _pSSSheet(NULL),
    _pParentElement(pParentElem),
    _pParentStyleSheet(NULL),
    _pImportedStyleSheets(NULL),
    _pSSAContainer(pSSAContainer),
    _pPageRules(NULL),
    _sidSheet(0),
    _fDisabled(FALSE),
    _fComplete(FALSE),
    _fParser(FALSE),
    _fReconstruct(FALSE),
    _pCssCtx(NULL),
    _nExpectedImports(0),
    _nCompletedImports(0),
    _eParsingStatus(CSSPARSESTATUS_NOTSTARTED),
    _dwStyleCookie(0),
    _dwScriptCookie(0),
    _pOMRulesArray(NULL)
{
    Assert( "Stylesheet must have container!" && _pSSAContainer );
    // Stylesheet starts internally w/ ref count of 1, and subrefs its parent.
    // This maintains consistency with the addref/release implementations.
    if (_pParentElement)
        _pParentElement->SubAddRef();
   
    WHEN_DBG( _pts = GetThreadState() );
}


CStyleSheet::~CStyleSheet()
{
    // This will free the Imports because ins ref counts are always one
    //  (it ref counts its parent for other purposes
    if(_pImportedStyleSheets)
        _pImportedStyleSheets->CBase::PrivateRelease(); 

    // This is just in case Passviate is not called
    // before final destruction 
    if (_pSSSheet)
    {
        Assert( FALSE && "CStyleSheet::Passivate should have been called" );
        CSharedStyleSheet *pSSTmp = _pSSSheet;
        _pSSSheet = NULL;
        pSSTmp->Release();
    }
}




//*********************************************************************
//  CStyleSheet::AttachLate()
//
//      S_OK     : successfully attached. 
//
//  Switch to a different Shared Style Sheet.  However we might choose to
//  also reconstruct all the OM related stuff and imported style sheets. 
//
//  fReconstruct means we need to reconstruct.
//  fIsReplacement  means if we do choose to reconstruct, do we need to
//  recreate all the OM related stuffs (in the we don't have any OM stuffs)
//  or simply repopulate exisiting OM related stuffs with the new SSS
//
//*********************************************************************
HRESULT
CStyleSheet::AttachLate(CSharedStyleSheet *pSSS, BOOL fReconstruct, BOOL fIsReplacement)
{
    HRESULT  hr = S_OK;
    Assert( pSSS );

    TraceTag( (tagSharedStyleSheet, "AttachLate - have [%p], attach to [%p]", _pSSSheet, pSSS) );
    if (_pSSSheet == pSSS)
        goto Cleanup;
    
    DisconnectSharedStyleSheet();
    ConnectSharedStyleSheet(pSSS);

    if (fReconstruct)
    {
        hr = THR( ReconstructStyleSheet( GetSSS(), /*fReplace*/fIsReplacement) );
        if (hr)
            goto Cleanup;
    }
    
    
Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleSheet::AttachByLastMod()
//
//      S_OK     : successfully attached. no need to download.
//      S_FALSE  :  cannot attach to existing ones
//
// NOTENOTE::::::::::::::::::This function is designed for the following usage:
//
// AttachByLastMod(pSheet, pSSSM, NULL, &pSSSOut, FALSE);
// do someting...
// AttachByLastMod(pSheet, pSSSM, pSSSOut, NULL, TRUE);
//
//*********************************************************************
HRESULT  
CStyleSheet::AttachByLastMod(CSharedStyleSheetsManager *pSSSM, 
                        CSharedStyleSheet *pSSSIn /* = NULL */, CSharedStyleSheet **pSSSOut /*=NULL*/,
                        BOOL fDoAttach /* = TRUE */)
{
    HRESULT  hr = E_FAIL;
    Assert( GetSSS() );
    Assert( pSSSM );

    TraceTag( (tagSharedStyleSheet, "AttachByLastMod - have [%p] with [%p] doattach [%d]", GetSSS(), pSSSIn, fDoAttach) );
    CSharedStyleSheet *pSSS = GetSSS();

    if (pSSSOut)
    {
        *pSSSOut = NULL;
    }

    if (!pSSSIn 
        && _pParentElement 
        && _pParentElement->GetMarkup() 
        && _pParentElement->GetMarkup()->GetWindowedMarkupContext()->GetDwnDoc()
        )     // if the element is in ether, don't attach late
    {
        CSharedStyleSheetCtx  ctxSSS;
        Assert( _pParentElement );

        ctxSSS._dwMedia  = MEDIATYPE(pSSS->_eMediaType);
        ctxSSS._fExpando = !!pSSS->_fExpando;
        ctxSSS._fXMLGeneric = !!pSSS->_fXMLGeneric;
        ctxSSS._cp       = pSSS->_cp;
        ctxSSS._szAbsUrl = pSSS->_achAbsoluteHref;
        ctxSSS._pft      = &(pSSS->_ft);                    // this should have been populated
        WHEN_DBG( ctxSSS._pSSInDbg   = pSSS );
        ctxSSS._dwBindf  = pSSS->_dwBindf;
        ctxSSS._dwFlags  = SSS_IGNOREREFRESH | SSS_IGNORESECUREURLVALIDATION;
        ctxSSS._pParentElement = _pParentElement;
        ctxSSS._fIsStrictCSS1 = !!(_pParentElement->GetMarkupPtr()->IsStrictCSS1Document());

        hr = THR( pSSSM->FindSharedStyleSheet( &pSSSIn, &ctxSSS) );  // addRefed
        if (!SUCCEEDED(hr)) 
            goto Cleanup;
        
        Assert( pSSSIn != pSSS );
        Assert( hr == S_FALSE || (pSSSIn && pSSSIn->_fComplete) );
        Assert( hr == S_FALSE || (pSSSIn && !pSSSIn->_fParsing) );
    }
    else
    {
        // we already have pSSSIn
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        Assert( pSSSIn );

        if (pSSSOut)
        {
            *pSSSOut = pSSSIn;
        }

        if (fDoAttach)
        {
            hr = S_FALSE;
            Assert (pSSSIn != GetSSS());
            Assert( !GetSSS()->_fComplete );
            Assert( !GetSSS()->_fParsing );
            Assert( pSSSIn->_fComplete );
            Assert( !pSSSIn->_fParsing );
            Assert( !pSSSIn->_fModified );
            Assert( pSSSIn->_pManager );
            WHEN_DBG( Assert( GetSSS()->_lReserveCount <= 1 ) );

            //
            // Do not reset the _pManager of GetSSS() to NULL
            // it could have been shared!
            //
            Assert( _pImportedStyleSheets == 0);
            Assert( !_pPageRules );
            Assert( !_pOMRulesArray );
            Assert( _apFontFaces.Size() == 0 );
            Assert( _apOMRules.Size() == 0 );
            hr = THR(AttachLate(pSSSIn, /*fReconstruct*/ TRUE, /*fIsReplacement*/ FALSE));
            WHEN_DBG( InterlockedDecrement( &(pSSSIn->_lReserveCount) ) );
            WHEN_DBG( Assert( GetSSS()->_lReserveCount == 0 ) );
            pSSSIn->Release(); // pSSSIn has been AddRefed, offset the one by FindSharedStyleSheet
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//*********************************************************************
//  CStyleSheet::AttachEarly()
//
//      S_OK     : successfully attached. no need to download.
//      S_FALSE  :  cannot attach to existing ones or existing one not complete
//*********************************************************************
HRESULT  
CStyleSheet::AttachEarly(CSharedStyleSheetsManager *pSSSM, 
                         CSharedStyleSheetCtx *pCtx, CSharedStyleSheet **ppSSSOut)
{
    HRESULT  hr = S_FALSE;
    Assert( _pSSSheet == NULL );
    Assert( pSSSM );
    Assert( pCtx );
    Assert( ppSSSOut );

    *ppSSSOut = NULL;

    if (!pCtx->_pParentElement || !pCtx->_pParentElement->GetMarkup())      // if the element is in the ether, don't attach
        goto Cleanup;
        
    TraceTag( (tagSharedStyleSheet, "AttachEarly") );
    hr = THR( pSSSM->FindSharedStyleSheet( ppSSSOut, pCtx) );
    if (!SUCCEEDED(hr)) 
        goto Cleanup;

    if (hr == S_OK)
    {
        TraceTag( (tagSharedStyleSheet, "AttachEarly - got [%p]", *ppSSSOut) );
        Assert( *ppSSSOut );
        ConnectSharedStyleSheet( *ppSSSOut );
        (*ppSSSOut)->Release(); // to offset the AddRef by FindSharedStyleSheet
        WHEN_DBG( InterlockedDecrement( &((*ppSSSOut)->_lReserveCount) ) );
        WHEN_DBG( Assert( (*ppSSSOut)->_lReserveCount == 0 ) );

        Assert( _pImportedStyleSheets == 0);
        Assert( !_pPageRules );
        Assert( !_pOMRulesArray );
        Assert( _apFontFaces.Size() == 0 );
        Assert( _apOMRules.Size() == 0 );
        hr = THR( ReconstructStyleSheet( GetSSS(), /*fReplace*/FALSE ) );  
        Assert( SUCCEEDED(hr) );
        if (hr == S_OK)
        {
            _eParsingStatus = CSSPARSESTATUS_DONE;
            _fComplete     = TRUE;
        }
        //
        // S_FALSE means the share one is not complete
        //
    }
    //
    // S_FALSE means we cannot find one
    //

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//  CStyleSheet::Create()
//
// This is the factory method for creating a new style sheet. It can
// be called to do the following:
//      1. simply create an empty CStyleSheet with an empty 
//         CSharedStyleSheet
//      2. create an empty CStyleSheet and a CSharedStyleSheet, 
//         prepare CSharedStyleSheet to be shared.
//      3. create an empty CStyleSheet, try to find an existing 
//         CSharedStyleSheet. connect the empty CStyleSheet with 
//         existing CSharedStyleSheet
//
// If the exisiting CSharedStyleSheet has been downloaded and complete, we
// can simply reconstruct CStyleSheet from exisiting CSharedStyleSheet.
// Otherwise a download is needed.
//
// It any case, we might end up in two different situation:
//      S_OK     : no need to download...
//      S_FALSE  : need to download...
//*********************************************************************
HRESULT 
CStyleSheet::Create(
        CStyleSheetCtx *pCtx, 
        CStyleSheet **ppStyleSheet, 
        CStyleSheetArray * const pSSAContainer 
        )
{
    Assert( !pCtx || pCtx->_pParentElement );
    Assert( !pCtx || (pCtx->_pParentStyleSheet == NULL || pCtx->_dwCtxFlag & STYLESHEETCTX_IMPORT) );
    Assert( !pCtx || (pCtx->_pSSS == NULL) );
    
    HRESULT  hr = S_OK;
    BOOL     fNeedDownload  = TRUE;

    DWORD   dwMedia  = MEDIA_All;   
    TCHAR   *pAbsUrl = NULL;
    BOOL    fExpando = TRUE;
    CODEPAGE    cp   = CP_UNDEFINED;
    BOOL fXMLGeneric = FALSE;
    BOOL fIsStrictCSS1 = FALSE;
    CDoc    *pDoc    = NULL;
    CDwnDoc *pDwnDoc = NULL;
    CMarkup *pMarkup  = NULL;

    if (!ppStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pSSAContainer && "CStyleSheet cannot live without a container!");

    *ppStyleSheet = new CStyleSheet((pCtx ? pCtx->_pParentElement : NULL), pSSAContainer);
    if (!*ppStyleSheet)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    {
        //
        // give it a temporary sheet ID so that we know nesting level when we 
        // reconstruct. This will be fixed up when it is added to the collection anyway.
        //
        unsigned long uLevel = pSSAContainer->_Level;
        if (uLevel == 0)    uLevel = 1;
        if ( uLevel > MAX_IMPORT_NESTING )
        {
            Assert(FALSE && "Newly created CStyleSheet Exceeds Max Nesting Levels");
            hr = E_FAIL;
            goto Cleanup;
        }
        (*ppStyleSheet)->_sidSheet.SetLevel(uLevel, 1);
    }

    if (pCtx && pCtx->_pParentElement)
    {
        pMarkup = pCtx->_pParentElement->GetMarkup();
        if (!pMarkup)
        {
            pMarkup = pCtx->_pParentElement->GetWindowedMarkupContext();
        }
        if (pMarkup)
        {
            pDwnDoc = pMarkup->GetWindowedMarkupContext()->GetDwnDoc();
        }
    }

    if (pCtx)
    {
        // obtian the media setting
        if (pCtx->_dwCtxFlag & STYLESHEETCTX_IMPORT)
        {
            Assert(pCtx->_pParentStyleSheet);
            // Fix up new SS to reflect the fact that it's imported (give it parent, set its import href)
            (*ppStyleSheet)->_pParentStyleSheet = pCtx->_pParentStyleSheet;
            (*ppStyleSheet)->_cstrImportHref.Set(pCtx->_szUrl);
            dwMedia  = pCtx->_pParentStyleSheet->GetMediaTypeValue();
            if (pCtx->_szUrl && pCtx->_szUrl[0])
            {
                if (pCtx->_pParentStyleSheet->GetAbsoluteHref())
                {
                    hr = ExpandUrlWithBaseUrl(pCtx->_pParentStyleSheet->GetAbsoluteHref(),
                                              pCtx->_szUrl,
                                              &pAbsUrl);
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), pCtx->_szUrl, &pAbsUrl);
                    if (!pAbsUrl)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                }
            }
            else
            {
                pAbsUrl = NULL;
            }
            
            fExpando = pCtx->_pParentStyleSheet->GetSSS()->_fExpando;
            cp = pCtx->_pParentStyleSheet->GetSSS()->_cp;
            fXMLGeneric = pCtx->_pParentStyleSheet->GetSSS()->_fXMLGeneric;
            fIsStrictCSS1 = pCtx->_pParentStyleSheet->GetSSS()->_fIsStrictCSS1;
            pDoc  = pCtx->_pParentStyleSheet->GetDocument();
        } // end if -- import 
        else
        {            
            Assert( !pCtx->_pParentStyleSheet );
            Assert( pCtx->_pParentElement );

            LPCTSTR pcszMedia = NULL;
            TCHAR   cBuf[pdlUrlLen];

            pDoc  = pCtx->_pParentElement->Doc();
            Assert(pDoc);
            switch (pCtx->_pParentElement->Tag())
            {
            case  ETAG_LINK:
                    {
                        CLinkElement  *pLink = DYNCAST(CLinkElement, pCtx->_pParentElement);
                        pCtx->_szUrl = pLink->GetAAhref();
                        Assert(pMarkup);
                        hr = CMarkup::ExpandUrl(pMarkup, pCtx->_szUrl, ARRAY_SIZE(cBuf), cBuf, pCtx->_pParentElement);
                        if (hr)
                            goto Cleanup;

                        MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), cBuf, &pAbsUrl);
                        if (pAbsUrl == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        
                        pcszMedia    = pLink->GetAAmedia();
                    }
                    break;
                    
            case  ETAG_STYLE:
                    {
                        CStyleElement *pStyle = DYNCAST(CStyleElement, pCtx->_pParentElement);
                        Assert(pMarkup);
                        hr = CMarkup::ExpandUrl(pMarkup, _T(""), ARRAY_SIZE(cBuf), cBuf, NULL);
                        if (hr)
                            goto Cleanup;

                        MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), cBuf, &pAbsUrl);
                        if (pAbsUrl == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }

                        pcszMedia    = pStyle->GetAAmedia();
                    }
                    break;
                    
            }

            if (NULL != pcszMedia) 
            {
                dwMedia  = TranslateMediaTypeString(pcszMedia);
            }

            Assert(pMarkup);
            fExpando = pMarkup->_fExpando;
            cp = pMarkup->GetCodePage();
            fXMLGeneric = pMarkup->IsXML();
            fIsStrictCSS1 = pMarkup->IsStrictCSS1Document();
        }// end else - Link/Style element
        
        if (pCtx->_dwCtxFlag & STYLESHEETCTX_REUSE)
        {
            if (pDoc && pMarkup)        // we don't want to try the reuse route if the element is in the ether
            {
                CSharedStyleSheetsManager *pSSSM = pDoc->GetSharedStyleSheets();
                CSharedStyleSheetCtx   ctxSSS;

                Assert(pCtx->_pParentElement);
                if (pDwnDoc)        // we cannot AttachEarly if there is no pDwnDoc available.
                {
                    ctxSSS._pParentElement = pCtx->_pParentElement;
                    ctxSSS._dwBindf = pDwnDoc->GetBindf();
                    ctxSSS._dwRefresh = pDwnDoc->GetRefresh();
                    ctxSSS._dwMedia  = dwMedia;
                    ctxSSS._fExpando = fExpando;
                    ctxSSS._fXMLGeneric = fXMLGeneric;
                    ctxSSS._cp       = cp;
                    ctxSSS._szAbsUrl = pAbsUrl;
                    ctxSSS._dwFlags = SSS_IGNORECOMPLETION | SSS_IGNORELASTMOD;
                    ctxSSS._fIsStrictCSS1 = fIsStrictCSS1;

                    Assert(pSSSM);
                    hr = THR( (*ppStyleSheet)->AttachEarly(pSSSM, &ctxSSS, &(pCtx->_pSSS)) );
                    if (!SUCCEEDED(hr)) 
                        goto Cleanup;

                    if (hr == S_OK)
                    {
                        fNeedDownload = FALSE;
                    }
                    
                    // S_FALSE: either we don't have one or we have one but cannot construct
                    if (pCtx->_pSSS) 
                    {
                        // We are done -- we might still need to download though...
                        goto Cleanup;
                    }
                    //
                    // FALL THROUGH
                    // 
                }
                //
                // FALL THROUGH
                //
            }
        } // end if reuse
    }// end if if(pCtx)

    //
    // Create CSharedStyleSheet from scratch
    //
    Assert(fNeedDownload);
    Assert(!pCtx || !pCtx->_pSSS);
    
    CSharedStyleSheet *pNewSSS;
    hr = THR( CSharedStyleSheet::Create( &pNewSSS ) );
    if (hr)
        goto Cleanup;

    Assert( *ppStyleSheet );
    (*ppStyleSheet)->ConnectSharedStyleSheet( pNewSSS );
    pNewSSS->Release();     // offset the addRef inside ConnectSharedStyleSheet;

    if (pCtx)
    {
        //
        // IF this stylesheet is created without a context, which means
        // we are in user style sheet or host style sheet cases, we
        // have problems here since all the settings here are
        // markup dependent while in the above cases, they have
        // to be markup independent.  
        // (zhenbinx)
        //
        (*ppStyleSheet)->GetSSS()->_fExpando = fExpando;
        (*ppStyleSheet)->GetSSS()->_fXMLGeneric = fXMLGeneric;
        (*ppStyleSheet)->GetSSS()->_fIsStrictCSS1 = fIsStrictCSS1;
        (*ppStyleSheet)->GetSSS()->_cp  = cp;
        
        hr = THR( (*ppStyleSheet)->SetMediaType( dwMedia, FALSE ) );
        if (hr)
            goto Cleanup;
        (*ppStyleSheet)->SetAbsoluteHref(pAbsUrl);
        pAbsUrl = NULL;

        if (pCtx->_dwCtxFlag & STYLESHEETCTX_SHAREABLE)
        {
            if (pDoc && pMarkup)    // we don't want to share if the element is in ether
            {
                //
                // Note:  This is assuming that the a download will be initiated after 
                // the CStyleSheet is created.  This can expedite in page style sheets
                // sharing. However, this seems not necessary since we probably will
                // not have style sheets shareable in the same page.
                // However we need to always assign some value to _dwRefresh and _dwBindf.
                // They should be modified after HEADERS callbackup anyways...
                //
                Assert( pCtx->_pParentElement );
                Assert( pCtx->_pParentElement->HasMarkupPtr() );
                if (pDwnDoc)
                {
                    (*ppStyleSheet)->GetSSS()->_dwRefresh = pDwnDoc->GetRefresh();
                    (*ppStyleSheet)->GetSSS()->_dwBindf   = pDwnDoc->GetBindf();
                    // make this SS part of the shared collection -- this will also make sure
                    // to set up CSharedStyleSheet::_pManager
                    pDoc->GetSharedStyleSheets()->AddSharedStyleSheet((*ppStyleSheet)->GetSSS());
                }
            }
        }
        Assert((*ppStyleSheet)->_pSSSheet);
    }

Cleanup:
    if (!SUCCEEDED(hr))
    {
        if (*ppStyleSheet)
        {
            (*ppStyleSheet)->Passivate();
            (*ppStyleSheet)->Release();
            (*ppStyleSheet) = NULL;
        }
        // delete resoruces 
    } 
    else if (fNeedDownload)
    {
        hr = S_FALSE;
    }
    delete pAbsUrl;
    RRETURN1(hr, S_FALSE);
}



//*********************************************************************
//  CStyleSheet::ReconstructStyleSheet()
// Reconstruct a CStyleSheet from an CSharedStyleSheet
// This should only be called in two scenario:
// a.  we have an empty SSS, and need to recreate pSSSheet from existing SSS
//     this is mostly used on creation case when we can reuse existing SSS.
// b.  we have an SSS, and need to replace current SSS with existing SSS, 
//    and reconstruct pSSSheet.  Note in this case, SSS should have the same
//    structure as existing SSS. This is mostly used in copy-on-write case
// 
//*********************************************************************
HRESULT
CStyleSheet::ReconstructStyleSheet(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT     hr = S_OK;

    Assert( pSSSheet );

    if (!pSSSheet->_fComplete)
    {
        TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] however sss [%p] is not completed\n", this, pSSSheet));
        hr = S_FALSE;   // still need download...
        goto Cleanup;
    }

    {
        TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] from existing completed sss [%p]\n", this, pSSSheet));
        hr = THR( ReconstructOMRules(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;

        hr = THR( ReconstructFontFaces(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;
            
        hr = THR( ReconstructPages(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;
        
        if (!fReplace)
        {
            _nExpectedImports = _nCompletedImports = 0;
            _fReconstruct = TRUE;

            TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstructing imports [%4d]\n", this, GetSSS()->_apImportedStyleSheets.Size()));
            // reconstruct imported style sheets
            CSharedStyleSheet::CImportedStyleSheetEntry    *pRE;
            int n;
            for (pRE = GetSSS()->_apImportedStyleSheets, n = 0;
                 n < GetSSS()->_apImportedStyleSheets.Size();
                 n++, pRE++
                 )
            {
                TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstruct -- add imports [%4d] \n", this, n) );
                WHEN_DBG( DumpHref(pRE->_cstrImportHref) );
                hr = THR( AddImportedStyleSheet(pRE->_cstrImportHref, /* not parsing */FALSE, /*lPos*/-1, /*plPosNew*/NULL, /*fFireOnCssChange*/FALSE) );
#if DBG == 1
                if (!SUCCEEDED(hr))
                {
                    TraceTag( (tagSharedStyleSheet, "reconstruct style sheet - AddImportedStyleSheet failed - could be because of max-import leve exceeded") );
                }
#endif
            }
                 
            _fReconstruct = FALSE;
            if (FAILED(hr))      // maybe failing due to maximum importing level
            {
                hr = S_OK;
                goto Cleanup;
            }
        }
  }
    
Cleanup:    
    RRETURN1(hr, S_FALSE);
}



//*********************************************************************
//  CStyleSheet::ReconstructOMRules()
// Reconstruct a OMRule array CSharedStyleSheet 
// 
//*********************************************************************
HRESULT
CStyleSheet::ReconstructOMRules(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( _apOMRules.Size() == 0 );

#if 0
    //
    // Since we are all the style sheets are shared within the same CDoc
    // this is not needed.
    //
        // note we are reproducing the logic in AddStyleRule.
        if (!fReplace)
        {
            TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstructing rules [%4d]\n", this, GetNumRules()));
            CStyleRule **pRules;
            int z;
            for (z = 0, pRules=GetSSS()->_apRulesList;
                 (DWORD)z < GetNumRules();
                 z++, pRules++
                 )
            {
                if ((*pRules)->GetStyleAA())
                {
                    //
                    // If the rule has the behavior attribute set, turn on the flag on the doc
                    // which forever enables behaviors.
                    //

                    // Only do the Find if PeersPossible is currently not set
                    if (_pParentElement && !_pParentElement->Doc()->AreCssPeersPossible())
                        if ((*pRules)->GetStyleAA()->Find(DISPID_A_BEHAVIOR))
                            _pParentElement->Doc()->SetCssPeersPossible();
                }
            }
        }

        //
        // else if we are replacing an existing one. The OM rule list and imported style sheets
        // are already in place. no need to do anything...
        //
#endif  

    //
    // Since we don't cache CStyleRule on OM objects, there is no need to do recontructions at all.
    //
    return hr;
}



//*********************************************************************
//  CStyleSheet::ReconstructFontFaces()
// Reconstruct a CFontFaces from an CSharedStyleSheet
//*********************************************************************
HRESULT
CStyleSheet::ReconstructFontFaces(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( fReplace ? pSSSheet->_apFontBlocks.Size() == _apFontFaces.Size() : 0 == _apFontFaces.Size());
    CAtFontBlock **ppAtFonts;
    int n;
    for (n = 0, ppAtFonts = pSSSheet->_apFontBlocks;
         n < pSSSheet->_apFontBlocks.Size();
         n++, ppAtFonts++
         )
    {
        CFontFace *pFontFace;
        if (fReplace)
        {
            CAtFontBlock *pAtFont = _apFontFaces[n]->_pAtFont;

            Assert( _apFontFaces[n]->_pAtFont );
            _apFontFaces[n]->_pAtFont = (*ppAtFonts);
            (*ppAtFonts)->AddRef();
            
            pAtFont->Release();
            pFontFace = _apFontFaces[n];
            //
            // It is possible we have already started a download,
            // before we finish the download, a copy-on-write is
            // initiated. In this case, a font download is warranted.
            //
        }
        else
        {
            hr = THR( CFontFace::Create(&pFontFace, this, *ppAtFonts) );
            if (hr)
                goto Cleanup;
                
            hr = THR( _apFontFaces.Append(pFontFace) );
            if (hr)
                goto Cleanup;

            Assert( pFontFace );
            Assert(!pFontFace->IsInstalled());
            Assert(!pFontFace->DownloadStarted());
            //
            // We need to do font download and installation since
            // it is per-markup installation.
            //
        }

        if (!pFontFace->DownloadStarted())
        {
            //
            // Do per-markup installation. Since embedded font is copy-righted
            // so that it can only be used within specified domain, we have to
            // check the font installation against markup domain. 
            // 
            // e.g. 
            //      A.domain markup
            //          <link ref=B.domain.css>
            //                   B.domain.css -> @font c.eot
            //      c.eot has to be checked against A.domain instead of
            //      B.domain, which means even if B.domain.css is shared,
            //      c.eot is NOT shared between different markups.
            //
            IGNORE_HR(pFontFace->StartDownload());
        }
    }
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::ReconstructPages()
// Reconstruct a CStyleSheetPages from an CSharedStyleSheet
//*********************************************************************
HRESULT
CStyleSheet::ReconstructPages(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( fReplace ? (_pPageRules ? pSSSheet->_apPageBlocks.Size() == _pPageRules->_aPages.Size() : pSSSheet->_apPageBlocks.Size() == 0)
                     : _pPageRules == NULL);

    if (!fReplace && pSSSheet->_apPageBlocks.Size() > 0)
    {
        Assert( _pPageRules == NULL );
        _pPageRules = new CStyleSheetPageArray(this);
        if (!_pPageRules)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
                     
    CAtPageBlock **ppAtPages;
    int n;
    for (n = 0, ppAtPages = pSSSheet->_apPageBlocks;
         n < pSSSheet->_apPageBlocks.Size();
         n++, ppAtPages++
         )
    {
        Assert( _pPageRules );
        if (fReplace)
        {
            Assert( _pPageRules->_aPages[n]->_pAtPage );
            _pPageRules->_aPages[n]->_pAtPage->Release();
            _pPageRules->_aPages[n]->_pAtPage = (*ppAtPages);
            (*ppAtPages)->AddRef();
        }
        else
        {
            CStyleSheetPage *pPage = new CStyleSheetPage(this, (*ppAtPages));
            if (!pPage)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = THR(_pPageRules->_aPages.Append(pPage));
            if (hr)
                goto Cleanup;
            pPage->AddRef();
        }
    }
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::Passivate()
//*********************************************************************
void CStyleSheet::Passivate()
{
    // The mucking about with _pImportedStyleSheets in Free()
    // will subrel us, which _may_ cause self-destruction.
    // To get around this, we subaddref ourselves and then subrelease.
    SubAddRef();
    Free();
    DisconnectSharedStyleSheet();
    // disconnect from parent element
    _pParentElement = NULL;
    _pParentStyleSheet = NULL;
    SubRelease();

    // Perform CBase passivation last - we need access to the SSA container.
    super::Passivate();
 }



//*********************************************************************
//  CStyleSheet::DisconnectSharedStyleSheet()
//
//*********************************************************************
 void 
 CStyleSheet::DisconnectSharedStyleSheet(void)
 {
    // This is the final construction so we release shared style sheet
    if (_pSSSheet)
    {
        CSharedStyleSheet *pSSTmp = _pSSSheet;
        _pSSSheet = NULL;

        //  disconnect this style sheet from the shared style sheet
        pSSTmp->_apSheetsList.DeleteByValue(this);
        pSSTmp->Release();
    }
 }



//*********************************************************************
//  CStyleSheet::ConnectSharedStyleSheet()
//
//*********************************************************************
 void 
 CStyleSheet::ConnectSharedStyleSheet(CSharedStyleSheet *pSSS)
 {
    Assert( !_pSSSheet );
    Assert( pSSS );

    _pSSSheet = pSSS;
    _pSSSheet->AddRef();
    _pSSSheet->_apSheetsList.Append(this);
 }


//*********************************************************************
//  CStyleSheet::Free()
//  Storage for the stylesheet's rules is managed by the shared SS,
//  so all the stylesheet itself is responsible for is any imported style
//  sheets.  It may be advisable to take over management of our own rules?
//*********************************************************************
void CStyleSheet::Free( void )
{

    SetCssCtx(NULL);

    if ( _pImportedStyleSheets )
    {
        _pImportedStyleSheets->Free( );  // Force our stylesheets collection to release its
                                            // refs on imported stylesheets.
        _pImportedStyleSheets->Release();   // this will subrel us

    }

    if ( _pOMRulesArray )
        _pOMRulesArray->StyleSheetRelease();
    _pOMRulesArray = NULL;

    int idx = _apOMRules.Size();
    while ( idx )
    {
         CStyleSheetRule *pOMRule = _apOMRules[idx-1];
         if (pOMRule)
         {
            pOMRule->StyleSheetRelease();
            _apOMRules[idx - 1] = NULL;
         }
         idx--;
    }
    _apOMRules.DeleteAll();


    idx = _apFontFaces.Size();
    while (idx)
    {
        _apFontFaces[idx - 1]->PrivateRelease();
        idx--;
    }
    _apFontFaces.DeleteAll();
    

    // Free any @page rules
    if ( _pPageRules )
    {
        // Let go of the rules array (which is subref'ing us)
        // This is the only ref that should be held by Trident code.
        // Once the array goes away, it will release its subref on us.
        _pPageRules->Release();
        _pPageRules = NULL;
    }

    _nExpectedImports = _nCompletedImports = 0;
}

//*********************************************************************
//      CStyleSheet::PrivateQueryInterface()
//*********************************************************************
HRESULT
CStyleSheet::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IHTMLStyleSheet, NULL)
        QI_TEAROFF(this, IHTMLStyleSheet2, NULL)
        // TODO (KTam): remove the default case as it is unnecessary w/ the above tearoffs
        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                iid == *pclassdesc->_classdescBase._piidDispinterface)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        Assert( _pParentElement );
        if ( !_pParentStyleSheet && ( _pParentElement->Tag() == ETAG_STYLE ) )
        {
            CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
            pStyle->SetDirty(); // Force us to build from our internal representation for persisting.
        }
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CStyleSheet::PrivateAddRef( void )
{
    // StyleSheet belongs to its parent
    if (_pParentElement)
        _pParentElement->SubAddRef();

    return CBase::PrivateAddRef();
}

ULONG CStyleSheet::PrivateRelease( void )
{
    if (_pParentElement)
        _pParentElement->SubRelease();
    return CBase::PrivateRelease();
}

CStyleSheetArray *CStyleSheet::GetRootContainer( void )
{
    return _pSSAContainer ? _pSSAContainer->_pRootSSA : NULL;
}

CDoc *CStyleSheet::GetDocument( void )
{
    return _pParentElement ? _pParentElement->Doc() : NULL;
}

CMarkup *CStyleSheet::GetMarkup( void )
{
    return _pParentElement ? _pParentElement->GetMarkup() : NULL;
}



//
//
CAtomTable *CStyleSheet::GetAtomTable ( BOOL *pfExpando )
{
    Assert(_pParentElement); 
    if (pfExpando)
    {
        if (_fComplete)
        {
            Assert(GetMarkup());
            CMarkup *pMarkupContext = GetMarkup()->GetWindowedMarkupContext();
            Assert(pMarkupContext);
            *pfExpando = pMarkupContext->_fExpando;
        }
        else
        {
            *pfExpando = GetSSS()->_fExpando;
        }
    }
    
    return _pParentElement->GetAtomTable();         
}



//*********************************************************************
//  CStyleSheet::AddStyleRule()
//      This method adds a new rule to the correct CStyleRuleArray in
//  the hash table (hashed by element (tag) number) (The CStyleRuleArrays
//  are stored in the containing CStyleSheetArray).  This method is
//  responsible for splitting apart selector groups and storing them
//  as separate rules.  May also handle important! by creating new rules.
//
//  We also maintain a list in source order of the rules inserted by
//  this stylesheet -- the list has the rule ID (rule info only, no
//  import nesting info) and etag (no pointers)
//
//  NOTE:  If there are any problems, the CStyleRule will auto-destruct.
//*********************************************************************
HRESULT CStyleSheet::AddStyleRule( CStyleRule *pRule, BOOL fDefeatPrevious /*=TRUE*/, long lIdx /*=-1*/ )
{
    WHEN_DBG( Assert(DbgIsValid()) );
    HRESULT hr = S_OK;
    
    Assert( "Style Rule is NULL!" && pRule );
    Assert( "Style Selector is NULL!" && pRule->GetSelector() );
    Assert( "Stylesheet must have a rule container!" && GetSSS() );
    Assert( "Style ID for StyleSheet has not been set" && _sidSheet );

    hr = THR(GetSSS()->AddStyleRule(pRule, fDefeatPrevious, lIdx));
    if (hr)
        goto Cleanup;

    //
    // Even though pRule could be a group rules, they share the same
    // AA. So we only need to inspect it once here. 
    //
    if (pRule->GetStyleAA())
    {
        //
        // If the rule has the behavior attribute set, turn on the flag on the doc
        // which forever enables behaviors.
        //

        // Only do the Find if PeersPossible is currently not set
        if (_pParentElement && !_pParentElement->Doc()->AreCssPeersPossible())
            if (pRule->GetStyleAA()->Find(DISPID_A_BEHAVIOR))
                _pParentElement->Doc()->SetCssPeersPossible();
    }
    //
    // DONOT update automation array, it will be updated by OnNewStyleRuleAdded
    //

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheet::OnNewStyleRuleAdded(CStyleRule *pRule)     // callback for new style added
{
#if DBG==1
    if (IsTagEnabled(tagStyleSheet))
    {
        pRule->DumpRuleString(this);
    }
#endif

    // Updating automation array starting from this rule 
    unsigned long lRule = pRule->GetRuleID().GetRule();
    if (lRule <= (unsigned long)_apOMRules.Size())  // if the new rule is inserted in an index <= maximum index
    {
        Assert(lRule > 0);
        // insert one position
        _apOMRules.Insert(lRule - 1, NULL);
    }
    
    for (int n = lRule; n < _apOMRules.Size(); n++)
    {
        if (_apOMRules[n])
        {
            // update _dwID
            Assert(_apOMRules[n]->_dwID >= lRule);
            _apOMRules[n]->_dwID++;
        }
    }
    return S_OK;
}


//*********************************************************************
//  CStyleSheet::RemoveStyleRule()
//  Simply removes style rule  -- not responsible for updating layout,etc.
//*********************************************************************
HRESULT 
CStyleSheet::RemoveStyleRule(long lIdx)
{
    Assert(DbgIsValid());
    
    HRESULT  hr = S_OK;
    CStyleRuleID  sidRule;
    
    // Make sure the index is valid.
    if (  lIdx < 0  || (unsigned long)lIdx >= GetNumRules()  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    sidRule.SetRule(lIdx + 1);
    hr = THR(GetSSS()->RemoveStyleRule(sidRule));
    
Cleanup:
    RRETURN(hr);
}



HRESULT 
CStyleSheet::OnStyleRuleRemoved(CStyleRuleID sidRule)     // callback for new style added
{
    // Updating automation array starting from this rule 
    unsigned long lRule = sidRule.GetRule();
    for (int n = lRule; n < _apOMRules.Size(); n++)
    {
        if (_apOMRules[n])
        {
            // update _dwID
            Assert(_apOMRules[n]->_dwID > lRule);
            _apOMRules[n]->_dwID--;
        }
    }

    if (lRule <= (unsigned long)_apOMRules.Size())
    {
        if (_apOMRules[lRule-1])
        {
            _apOMRules[lRule - 1]->StyleSheetRelease();
            _apOMRules.Delete(lRule - 1);
        }
    }
    
    return S_OK;
}



//*********************************************************************
//  CStyleSheet::AddImportedStyleSheet()
//      This method adds an imported stylesheet to our imported list
//  (which is created if necessary), and kicks off a download of the
//  imported stylesheet.
//
//  fParsing determines if we are parsing a style block. It is for example
//  not set if we are called through IHTMLStyleSheet interface. See also comment
//  in function.
//*********************************************************************
HRESULT CStyleSheet::AddImportedStyleSheet( TCHAR *pszURL, BOOL fParsing, long lPos /*=-1*/, long *plNewPos /*=NULL*/, BOOL fFireOnCssChange /*=TRUE*/)
{
    Assert(DbgIsValid());
    
    CStyleSheet *pStyleSheet = NULL;
    CCssCtx *pCssCtx = NULL;
    HRESULT hr = E_FAIL;
    CStyleSheetCtx  ctxSS;
    CSharedStyleSheet::CImportedStyleSheetEntry  *pEntry = NULL;
    BOOL    fFinished = FALSE;
    BOOL    fReconstructed = FALSE;

    // Do not support imported SS in User SS as there is no doc!
    if (!_pParentElement)
        goto Cleanup;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to add sheet

    // Check if our URL is a CSS url(xxx) string.  If so, strip "url(" off front,
    // and ")" off back.  Otherwise assume it'a a straight URL.
    // This function modifies the parameter string pointer
    hr = RemoveStyleUrlFromStr(&pszURL);
    if(FAILED(hr))
        goto Cleanup;

   if (!_fReconstruct)
   {
        //
        // If this is a strict CSS document, we shouldn't allow @imports after the first selector rule.
        // This only happens if we are in parsing time -- this assumes that anything that is parsed
        // in is correct so during reconstruction time, we would not need to check this again.
        // Another case where we don't want to apply strict css is, if we are called through the CHTMLStyleSheet 
        // interface to add an import. Therefore fParsing was introduced. More generally fParsing determines
        // if we are _parsing_ a style sheet.
#if DBG == 1
        if (_pParentElement && _pParentElement->IsInMarkup() )
        {
            Assert( _pParentElement->GetMarkup()->IsStrictCSS1Document() == !!GetSSS()->_fIsStrictCSS1 );
        }
#endif
        if (GetSSS()->_fIsStrictCSS1 && GetNumRules() && fParsing)
        {
            hr = S_OK;
            goto Cleanup;
        }

        //
        // add our imported style sheet list - before we even try to create new style sheet
        // because style sheet creation might fail due to MAX level. However we still
        // want to record the information
        //
        GetSSS()->_apImportedStyleSheets.AppendIndirect(NULL, &pEntry);  
        if (!pEntry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        if (pszURL)
        {
            pEntry->_cstrImportHref.Set(pszURL);
        }
    }

    // Bail if we're max'ed out on nesting.
    if ((long)_sidSheet.FindNestingLevel() >= MAX_IMPORT_NESTING)
    {
        TraceTag( (tagStyleSheet, "Maximum import nesting exceeded! (informational)") );
        hr = E_INVALIDARG;  // no need to download
        goto Cleanup;
    }

    hr = E_FAIL;
    // The imports array could already exist because of previous @imports,
    // or because the imports collection was previously requested from script.
    if ( !_pImportedStyleSheets )
    {
        // Imported stylesheets don't manage their own rules.
        _pImportedStyleSheets = new CStyleSheetArray( this, GetRootContainer(), _sidSheet );
        Assert( "Failure to allocate imported stylesheets array! (informational)" && _pImportedStyleSheets );
        if (!_pImportedStyleSheets)
            goto Cleanup;
        if (_pImportedStyleSheets->_fInvalid)
        {
            _pImportedStyleSheets->CBase::PrivateRelease();
            goto Cleanup;
        }
    }
    ++_nExpectedImports; // we will track this one

    // Create the stylesheet in the "imported array".  
    ctxSS._pParentElement    = _pParentElement;
    ctxSS._pParentStyleSheet = this;
    ctxSS._szUrl             = pszURL;
    ctxSS._dwCtxFlag = (STYLESHEETCTX_IMPORT | STYLESHEETCTX_REUSE | STYLESHEETCTX_SHAREABLE);
    hr = _pImportedStyleSheets->CreateNewStyleSheet( &ctxSS, &pStyleSheet, lPos, plNewPos);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (hr == S_FALSE)     // hr = S_FALSE means need to download 
    {
        hr = S_OK;
        
        // Kick off the download of the imported sheet
        if (pszURL && pszURL[0])
        {
            CDoc *  pDoc = _pParentElement->Doc();
            BOOL fPendingRoot = FALSE;

            if (_pParentElement->IsInMarkup())
            {
                fPendingRoot = _pParentElement->GetMarkup()->IsPendingRoot();
            }

            Assert(pStyleSheet->_eParsingStatus != CSSPARSESTATUS_DONE);
            hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, pStyleSheet->GetAbsoluteHref(), _pParentElement,
                                    (CDwnCtx **)&pCssCtx, fPendingRoot));
            
            if (hr == S_OK)
            {
                // For rendering purposes, having an @imported sheet pending is just like having
                // a linked sheet pending.
                pDoc->EnterStylesheetDownload(&(pStyleSheet->_dwStyleCookie));
                _pParentElement->GetMarkup()->BlockScriptExecution(&(pStyleSheet->_dwScriptCookie));

                // Give ownership of bitsctx to the newly created (empty) stylesheet, since it's
                // the one that will need to be filled in by the @import'ed sheet.
                pStyleSheet->SetCssCtx(pCssCtx);
                pCssCtx->Release();
            }
        }
        else
        {
            pStyleSheet->GetSSS()->_fComplete = TRUE;
            fFinished = TRUE;
        }
    }
    else // hr == S_OK
    {
        fFinished = TRUE;
        fReconstructed = TRUE;
    }

    if (fFinished)
    {
        Assert( pStyleSheet );
        // we have reconstructed from exsiting...
        //////////////////////////////////////////////
        pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
        pStyleSheet->_fComplete      = TRUE;
         // This sheet has finished, one way or another.
        _nCompletedImports++;
        // notify parent that this is done
        pStyleSheet->CheckImportStatus();        
    }

    if (fReconstructed && fFireOnCssChange)
    {
        if (_pParentElement->IsInMarkup())
        {
            IGNORE_HR( _pParentElement->GetMarkup()->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );
        }
    }
    
    WHEN_DBG( !pStyleSheet || pStyleSheet->DbgIsValid() );

Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendFontFace()
//*********************************************************************
HRESULT
CStyleSheet::AppendFontFace(CFontFace *pFontFace)
{
    HRESULT hr = THR(_apFontFaces.Append(pFontFace));
    if (!hr)
    {
        hr = THR(GetSSS()->AppendFontFace(pFontFace->_pAtFont));
    }
    
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendPage()
//*********************************************************************
HRESULT 
CStyleSheet::AppendPage(CStyleSheetPage *pPage)
{ 
    RRETURN( GetSSS()->AppendPage(pPage->_pAtPage) ); 
}



//*********************************************************************
//  CStyleSheet::ChangeStatus()
//  Enable or disable this stylesheet and its imported children
//*********************************************************************
HRESULT CStyleSheet::ChangeStatus(
    DWORD dwAction,               // CS_ flags as defined in sheets.hxx
    BOOL fForceRender /*=TRUE*/,  // should we force everyone to update their formats and re-render?
                                  // We want to avoid forcing a re-render when the doc/tree is unloading/dying etc.
    BOOL *pfChanged)              // Should only be non-NULL on recursive calls (ext. callers use NULL)
{
    Assert( DbgIsValid() );
    Assert(!( (dwAction & CS_ENABLERULES) && (dwAction & CS_CLEARRULES) ) );
    Assert(!( (dwAction & CS_CLEARRULES) && MEDIATYPE(dwAction)  ));
    Assert( GetRootContainer() );

    HRESULT hr = S_OK;
    int z;
    CStyleSheet *pSS;
    BOOL  fRootStyleSheet = FALSE;
    BOOL  fChanged        = FALSE;
    BOOL  fDisabled       = _fDisabled;
    CMarkup *pMarkup = NULL;


    // The first call pfChange should be NULL
    if (!pfChanged)
    {  
        pfChanged = &fChanged;
        fRootStyleSheet = TRUE;
    }

    if (fRootStyleSheet)
    {
       pMarkup = DYNCAST(CMarkup, GetRootContainer()->_pOwner);  // top CStyleSheetArray's owner is always the markup
    }

    // Mark this stylesheet's status
    _fDisabled = !(dwAction & CS_ENABLERULES);
    if (dwAction & CS_CLEARRULES)
    {
        if (GetSSS())
        {
            hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
            if (hr)
                goto Cleanup;  
            IGNORE_HR( GetSSS()->ReleaseRules() );
        }

        // clear out our OM list 
        Free();
    }

    if (dwAction & CS_DETACHRULES)
    {
        if (_pSSAContainer)
        {
            //
            // Simpy cut down the connection 
            // so that the style sheet is aware
            // of its status as being detached
            //
            // StyleSheet does not hold any ref
            // to its container. 
            // 
            _pSSAContainer = NULL;
        }
    }


    if ( MEDIATYPE(dwAction) )
    {   
        Assert( !(dwAction & CS_CLEARRULES ) );
        hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
        if (hr)
            goto Cleanup;
        
        hr = THR( GetSSS()->ChangeRulesStatus(dwAction, pfChanged) );
        if (hr)
            goto Cleanup;
    }


    // Recursively scan sheets of our imports
    if (_pImportedStyleSheets)
    {
        for ( z=0 ; (pSS=(_pImportedStyleSheets->Get(z))) != NULL ; ++z)
        {
            hr = THR( pSS->ChangeStatus( dwAction, fForceRender, pfChanged ) );
            if (hr)
                goto Cleanup;
        }
    }

    // If our imported style sheets did not change anything
    // See if this current style sheet caused any change
    if (!*pfChanged)
    {
        if (fDisabled != _fDisabled || (dwAction & CS_CLEARRULES) || (dwAction & CS_DETACHRULES))
        {
            if (GetNumRules())
            {
                *pfChanged = TRUE;
            }
        }
    }

    if (fRootStyleSheet)   // root stylesheet
    {
        Assert(pfChanged);
        // Force update of element formats to account for new set of rules
        if ( fForceRender && *pfChanged  && pMarkup)
        {
            IGNORE_HR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE) );
        }
    }

Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendListOfProbableRules()
//
//  Add Probable Rules from this sheet to CProbableRules
//  This will only be called by CStyleSheetArray::BuildListOfProbableRules
//*********************************************************************
HRESULT 
CStyleSheet::AppendListOfProbableRules(CTreeNode *pNode, CProbableRules *ppr, CClassIDStr *pclsStrLink, CClassIDStr *pidStr, BOOL fRecursiveCall)
{
    HRESULT  hr;

    if (_fDisabled)
    {
        hr = S_OK;
        goto Cleanup;
    }

#if DBG == 1
    if (IsTagEnabled(tagStyleSheet))
    {
        WHEN_DBG( Dump() );
    }
#endif
    
    // Recursivly call for import SSA -- depth first search 
    if (_pImportedStyleSheets)
    {
        hr = THR(_pImportedStyleSheets->BuildListOfProbableRules(pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
        if (hr)
            goto Cleanup;
    }

    hr = THR(GetSSS()->AppendListOfProbableRules(_sidSheet, pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}




//*********************************************************************
//  CStyleSheet::TestForPseudoclassEffect()
//*********************************************************************

BOOL 
CStyleSheet::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )

{
    if (GetSSS()->TestForPseudoclassEffect(pStyleInfo, fVisited, fActive, fOldVisited, fOldActive))
        return TRUE;
    if (_pImportedStyleSheets)
    {
        return _pImportedStyleSheets->TestForPseudoclassEffect(pStyleInfo, fVisited, fActive, fOldVisited, fOldActive);
    }

    return FALSE;
}       




//*********************************************************************
//  CStyleSheet::ChangeContainer()
//
//  When a StyleSheet moves to another StyleSheetArray, this method changes
//  the container StyleSheetArray -- no need to change container for imported
//  style sheets as their container will be _pImportedStyleSheets
//*********************************************************************
void    
CStyleSheet::ChangeContainer(CStyleSheetArray * pSSANewContainer)
{
    Assert( DbgIsValid() );
    
    Assert(pSSANewContainer);
    _pSSAContainer = pSSANewContainer;

    if (_pImportedStyleSheets)
    {
        _pImportedStyleSheets->_pRootSSA = _pSSAContainer->_pRootSSA;
    }
}

MtDefine(LoadFromURL, Utilities, "CStyleSheet::LoadFromURL");

//*********************************************************************
//  CStyleSheet::LoadFromURL()
//  Marks as "dead" any rules that this stylesheet currently has, and
//  loads a new set of rules from the specified URL.  Because of our
//  ref-counting scheme, if this sheet has an imports collection allocated,
//  that collection object is reused (i.e. any existing imported SS are
//  released).
//*********************************************************************
HRESULT CStyleSheet::LoadFromURL( CStyleSheetCtx *pCtx, BOOL fAutoEnable /*=FALSE*/ )
{
    HRESULT     hr;
    CCssCtx    *pCssCtx = NULL;

    WHEN_DBG( Assert(DbgIsValid()) );

    BOOL fDisabled = _fDisabled;    // remember our current disable value.

    hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
    if (hr)
        goto Cleanup;
    
    // Force all our rules (and rules of our imports) to be marked as out of the tree ("dead"),
    // but don't patch other rules to fill in the ID hole.
    // Don't force a re-render since we will immediately be loading new rules.
    hr = ChangeStatus( CS_CLEARRULES, FALSE, NULL );   // disabling, detached from tree, no re-render
    if ( hr )
        goto Cleanup;

    GetSSS()->_fParsing   = FALSE;
    GetSSS()->_fComplete = FALSE;
    GetSSS()->_fModified  = TRUE;

    // Note: the ChangeStatus call above will have set us as disabled.  Restore our original disable value.
    _fDisabled = fAutoEnable? FALSE : fDisabled;

    // Clear our readystate information:
    _eParsingStatus = CSSPARSESTATUS_PARSING;
    _nExpectedImports = 0;
    _nCompletedImports = 0;

    if(GetAbsoluteHref())
    {
        MemFreeString(GetAbsoluteHref());
        SetAbsoluteHref(NULL);
    }

    // That's all the cleanup we need; our parent element, parent stylesheet, sheet ID etc.
    // stay the same!


    // Kick off the download of the URL
    if ( pCtx && pCtx->_szUrl && pCtx->_szUrl[0] )
    {
        CDoc *  pDoc = _pParentElement->Doc();
        TCHAR   cBuf[pdlUrlLen];
        BOOL    fPendingRoot = NULL;

        hr = CMarkup::ExpandUrl(
                NULL, pCtx->_szUrl, ARRAY_SIZE(cBuf), cBuf, _pParentElement);
        if (hr)
            goto Cleanup;
        MemAllocString(Mt(LoadFromURL), cBuf, GetRefAbsoluteHref());
        if (GetAbsoluteHref() == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_pParentElement->IsInMarkup())
        {
            fPendingRoot = _pParentElement->GetMarkup()->IsPendingRoot();
        }

        hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, pCtx->_szUrl,
                    _pParentElement, (CDwnCtx **)&pCssCtx, fPendingRoot));
        if (hr == S_OK)
        {
            // Block rendering while we load..
            pDoc->EnterStylesheetDownload(&_dwStyleCookie);

            GetMarkup()->BlockScriptExecution(&_dwScriptCookie);
            if ( IsAnImport() )
                (_pParentStyleSheet->_nCompletedImports)--;

            // We own the bits context..
            SetCssCtx(pCssCtx);
        }
    }
    else
    {
        SetCssCtx( NULL );
        Fire_onerror();
        CheckImportStatus();
    }

Cleanup:
    if (pCssCtx)
        pCssCtx->Release();

    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheet::PatchID()
//  Patches the ID of this stylesheet and all nested imports
//*********************************************************************

void CStyleSheet::PatchID(
    unsigned long ulLevel,       // Level that will change
    unsigned long ulValue,       // Value level will be given
    BOOL fRecursiveCall)        // Is this a recursive call? (FALSE for ext. callers).
{
    Assert (ulLevel > 0 && ulLevel <= MAX_IMPORT_NESTING );
    Assert ( ulValue <= MAX_SHEETS_PER_LEVEL );

    long i = 0;
    CStyleSheet * pISS;

    // Fix our own ID
    _sidSheet.SetLevel( ulLevel, ulValue );
    Assert( _sidSheet );    // should never become 0

    // Everyone nested below the sheet for which PatchID was first called needs
    // to be patched at the same level with a value that's 1 less.
    if (!fRecursiveCall)
    {
        fRecursiveCall = TRUE;
        --ulValue;
    }

    // If we have imports, ask them to fix all of their IDs.
    if ( _pImportedStyleSheets )
    {
        // Fix ID that imports collection will use to build new imports
        _pImportedStyleSheets->_sidForOurSheets.SetLevel( ulLevel, ulValue );
        // Recursively fix imported stylesheets
        while ( (pISS = _pImportedStyleSheets->Get(i++)) != NULL )
        {
            pISS->PatchID( ulLevel, ulValue, fRecursiveCall );
        }
    }
}

//*********************************************************************
//  CStyleSheet::ChangeID()
//  Changes the ID for this StyleSheet and all the rules
//*********************************************************************
BOOL  CStyleSheet::ChangeID(CStyleSheetID const idNew)
{
    unsigned int ulLevel = idNew.FindNestingLevel();
    unsigned int ulValue = idNew.GetLevel(ulLevel);

    Assert (ulLevel > 0 && ulLevel <= MAX_IMPORT_NESTING );
    Assert ( ulValue <= MAX_SHEETS_PER_LEVEL );

    // Update our ID
    _sidSheet = idNew & ~RULE_MASK;

    // Fix our own ID
    _sidSheet.SetLevel( ulLevel, ulValue );
    Assert( _sidSheet );    // should never become 0

    // Change the Imported sheets
    if (_pImportedStyleSheets)
    {
        if (!_pImportedStyleSheets->ChangeID(_sidSheet))
            return FALSE;
    }
    
    return TRUE;
}

//*********************************************************************
//  CStyleSheet::SetCssCtx()
//  Sets ownership and callback information for a CssCtx.  A stylesheet
//  will have a non-NULL CssCtx if it's @import'ed.
//*********************************************************************
void CStyleSheet::SetCssCtx(CCssCtx * pCssCtx)
{    
    if (_pCssCtx)
    {   // If we're tromping on an in-progress download, fix the completed count up.

        TraceTag( (tagStyleSheet, "SetCssCtx [%p]-- get new bitsctx [%p] while still holding bitsctx [%p] and sss [%p]\n", this, pCssCtx, _pCssCtx, GetSSS()));
        if (!_fComplete)
        {
            if (IsAnImport())
                (_pParentStyleSheet->_nCompletedImports)++;
            _pParentElement->Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        }
        _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->Disconnect();
        _pCssCtx->Release();
    }

    _fComplete = FALSE;
    _pCssCtx = pCssCtx;

    if (pCssCtx)
    {
        pCssCtx->AddRef();

        pCssCtx->AddRef();     // Keep ourselves alive
        SetReadyState( READYSTATE_LOADING );

        if ( pCssCtx == _pCssCtx )    // Make sure we're still the bitsctx for this stylesheet -
        {                               // it's possible SetReadyState fired and changed the bitsctx.
            TraceTag( (tagStyleSheet, "SetCssCtx [%p]-- ulState is  [%x]", _pCssCtx, _pCssCtx->GetState()) );
            if (pCssCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            {
               OnDwnChan(pCssCtx);
            }
            else
            {
                pCssCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
                pCssCtx->SetCallback(OnDwnChanCallback, this);
                pCssCtx->SelectChanges(DWNCHG_COMPLETE|DWNCHG_HEADERS, 0, TRUE);
            }
        }

        pCssCtx->Release();     // Stop keeping ourselves alive
    }
}


//*********************************************************************
//  CStyleSheet::DoParsing()
// Goto parsing state - or in the shared case, fake a parsing session 
//
// S_OK:    Parsing succeeded: either a real one or a reconstructed one
// S_FALSE: Waitting for callback...
//
//*********************************************************************
HRESULT
CStyleSheet::DoParsing(CCssCtx *pCssCtx)
{
    HRESULT  hr = S_OK;
    Assert( _pSSSheet );
    Assert( pCssCtx );
    IStream *pStream = NULL;

    Assert( _fParser == FALSE );

    {
        if (!GetSSS()->_fComplete)
        {
            _eParsingStatus = CSSPARSESTATUS_PARSING;
            if (GetSSS()->_fParsing)
            {
                // someone is doing the parsing. the shared style sheet 
                // should call back to notify us when the parsing is done 
                // so we can do reconstruct from the shared style sheet. 
                // pretend that we are doing the parsing...
                // This could easily happen if there is a circular references A.css - B.css - A.css
                // The second time A.css is trying to do parsing, it will see that the first A.css is 
                // already doing parsing...
                TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] wait others parsing [%p]", this, GetSSS()));
                hr = S_FALSE;
                goto Cleanup;
            }
            else
            {
                Assert( pCssCtx );
                TraceTag( (tagSharedStyleSheet, "DoParsing -- this [%p] will do parsing for [%p]", this, GetSSS()));
                if ( S_OK == pCssCtx->GetStream(&pStream) )
                {
                    // this is the one that is going to do the parsing
                    GetSSS()->_fParsing = TRUE;
                    _fParser = TRUE;
                }
            }
        }
        else
        {
            Assert( _eParsingStatus != CSSPARSESTATUS_DONE );
            _eParsingStatus = CSSPARSESTATUS_DONE;
        }
    }

    if (_eParsingStatus == CSSPARSESTATUS_DONE )
    {
        TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] find one that is already completed [%p]", this, GetSSS()));
        hr = THR(ReconstructStyleSheet(GetSSS(), /*fReplace*/FALSE));
        if (hr)
            goto Cleanup;
    }       

    if (pStream && _fParser )
    {
        CMarkup *pMarkup = _pParentElement->GetMarkup();
        
        CCSSParser parser( this, NULL, IsXML(), IsStrictCSS1() );
        parser.LoadFromStream(pStream, pMarkup->GetCodePage());
        pStream->Release();
        
        _eParsingStatus = CSSPARSESTATUS_DONE;    
        TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] finished parsing for [%p]\n", this, GetSSS()));

        GetSSS()->_fParsing  = FALSE;   // done parsing...
        GetSSS()->_fComplete = TRUE;    // finished construction
        GetSSS()->Notify(NF_SHAREDSTYLESHEET_PARSEDONE);
        _fParser = FALSE;
        TraceTag( (tagSharedStyleSheet, "DoParsing [%p]-- finished notification for PARSEDONE-[%p]\n", this, GetSSS()));
    }
    else if (_fParser)
    {
        _eParsingStatus = CSSPARSESTATUS_DONE;   // Need to make sure we'll walk up to our parent in CheckImportStatus()
        TraceTag((tagError, "CStyleSheet::DoParsing bitsctx failed to get file!"));

        //
        // TODO: impl. CSharedStyleSheet::SwitchParserAway
        //
        GetSSS()->_fParsing  = FALSE;   // done parsing...
        GetSSS()->_fComplete = TRUE;    // finished construction
        GetSSS()->Notify(NF_SHAREDSTYLESHEET_BITSCTXERROR);
        _fParser = FALSE;
        TraceTag( (tagSharedStyleSheet, "DoParsing [%p]-- finished notification for PARSEERROR-[%p]\n", this, GetSSS()));
        
        Fire_onerror();
        EnsureCopyOnWrite(/*fDeatchOnly*/ TRUE);    // disconnect from the shared SS();
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//  CStyleSheet::OnDwnChan()
//  Callback used by CssCtx once it's downloaded the @import'ed
//  stylesheet data that will be used to fill us out.  Also used when
//  the HREF on a linked stylesheet changes (we reuse the CStyleSheet
//  object and setup a new bitsctx on it)
//*********************************************************************
void CStyleSheet::OnDwnChan(CDwnChan * pDwnChan)
{
    Assert( GetThreadState() == _pts );
    
    ULONG ulState;
    CMarkup *pMarkup;
    CDoc *pDoc;
    HRESULT  hr;
    BOOL    fDoHeaders;

    Assert(_pCssCtx && "OnDwnChan called while _pCssCtx == NULL, possibely legacy callbacks");
    Assert(_pParentElement);
    _pParentElement->EnsureInMarkup();

    pMarkup = _pParentElement->GetMarkup();
    Assert(pMarkup);

    pDoc = pMarkup->Doc();

    if ( IsAnImport() && !_fDisabled )      // if it's already disabled, leave it.
        _fDisabled = _pParentStyleSheet->_fDisabled;

    ulState = _pCssCtx->GetState();
    fDoHeaders = (BOOL)(ulState & DWNLOAD_HEADERS);
    if (!fDoHeaders)
    {
        fDoHeaders = (ulState & DWNLOAD_COMPLETE) && !(ulState & DWNLOAD_HEADERS);
    }
    
    if (fDoHeaders)
    {
        //
        // TODO: this could have been called twice (although it does no harm) --we can modify this
        // to be called only once in the future.
        //
        BOOL fGotLastMod = FALSE;
        FILETIME ft = {0};
        
        ft = _pCssCtx->GetLastMod();
        if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
        {
            fGotLastMod = GetUrlTime(&ft, GetAbsoluteHref(), _pParentElement);
        }
        else
            fGotLastMod = TRUE;
        
        if (fGotLastMod)
        {
            GetSSS()->_ft = ft;
            TraceTag( (tagSharedStyleSheet, "OnDwnChan - DoHeaders -- set FT [%x] [%x] for [%p]", GetSSS()->_ft.dwHighDateTime, GetSSS()->_ft.dwLowDateTime, GetSSS()) );
        }
#if DBG==1            
        else
        {   
            TraceTag( (tagSharedStyleSheet, "Link - OnDwnChan cannot get FILETIME from CssCtx") );
        }
#endif             
        GetSSS()->_dwBindf = _pCssCtx->GetBindf();
        GetSSS()->_dwRefresh = _pCssCtx->GetRefresh();
    }

    // try to attach late
    if (ulState & (DWNLOAD_COMPLETE |DWNLOAD_HEADERS))
    {
        CSharedStyleSheetsManager *pSSSM = GetSSS()->_pManager;
        CSharedStyleSheet *pSSS = NULL;
        if (pSSSM && !GetSSS()->_fComplete)
        {
            if (!(GetSSS()->_ft.dwHighDateTime == 0 && GetSSS()->_ft.dwLowDateTime == 0)
               && (S_OK == THR(AttachByLastMod(pSSSM, NULL, &pSSS, FALSE)))
               )
            {
                // Stop downloading
                TraceTag( (tagSharedStyleSheet, "Attached -- stop downloading") );
                if (!(ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                {
                    _pCssCtx->SetLoad( FALSE, NULL, FALSE );
                    ulState |= DWNLOAD_COMPLETE;
                }
                Assert( pSSS );
                hr = THR(AttachByLastMod(pSSSM, pSSS, NULL, TRUE));
                Assert(hr == S_OK);
                _eParsingStatus = CSSPARSESTATUS_DONE;
            }
        }
        //
        // else simply fall through...
        // 
    }

    // do parsing if necessary 
    if ( ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED) )
    {
       Assert(!_fComplete);
       _fComplete = TRUE;
            
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);

        // This sheet has finished, one way or another.
        if ( IsAnImport() )
            _pParentStyleSheet->_nCompletedImports++;

        if (ulState & DWNLOAD_COMPLETE)
        {
            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(pMarkup->IsPendingRoot(), _pCssCtx->GetUrl(), _pCssCtx->GetSecFlags());
            if (_eParsingStatus != CSSPARSESTATUS_DONE)
            {
                IGNORE_HR( DoParsing(_pCssCtx) );
            }
        }
        else
        {
            EnsureCopyOnWrite(/*fDetachOnly*/TRUE, /*fWaitForCompletion*/FALSE);
            _eParsingStatus = CSSPARSESTATUS_DONE;      // Need to make sure we'll walk up to our parent in CheckImportStatus()
            TraceTag((tagError, "CStyleSheet::OnChan bitsctx failed to complete!"));
            if ( ulState & DWNLOAD_ERROR )
                Fire_onerror();
        }

        //
        // If our parsing simply returns -- that is, someone else is doing parsing
        // then we will defer the call to OnCssChange after we got the notifications.
        //
        if (CSSPARSESTATUS_DONE == _eParsingStatus)
        {
            TraceTag( (tagSharedStyleSheet, "parsing status == DONE Notify markup and parent, unblock script execution") );
            // Relayout the doc; new rules may have been loaded (e.g. DWNLOAD_COMPLETE),
            // or we may have killed off rules w/o re-rendering before starting the load
            // for this sheet (e.g. changing src of an existing sheet).
            IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );

            // notify parent that this is done
            CheckImportStatus();    // Needed e.g. if all imports were cached, their OnChan's would all be called
                                    // before parsing finished.
            pMarkup->UnblockScriptExecution(&_dwScriptCookie);
            
            _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
            SetCssCtx(NULL);
        }
    }
    else
    {
       WHEN_DBG( if (!(ulState & DWNLOAD_HEADERS)) Assert( "Unknown result returned from CStyleSheet's bitsCtx!" && FALSE ) );
    }
}

//*********************************************************************
//  CStyleSheet::Fire_onerror()
//      Handles firing onerror on our parent element.
//*********************************************************************
void CStyleSheet::Fire_onerror()
{
    if ( !_pParentElement )
        return;    // In case we're a user stylesheet

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        pStyle->Fire_onerror();
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        pLink->Fire_onerror();
    }
}

//*********************************************************************
//  CStyleSheet::IsXML()
//      Says whether this stylesheet should follow xml generic parsing rules
//*********************************************************************
BOOL CStyleSheet::IsXML(void)
{
    // the parent element may have been detached, is there a problem here?
    return _pParentElement && _pParentElement->IsInMarkup() && _pParentElement->GetMarkupPtr()->IsXML();
}

//*********************************************************************
//  CStyleSheet::IsStrictCSS1()
//*********************************************************************

BOOL CStyleSheet::IsStrictCSS1(void)
{
    return _pParentElement && _pParentElement->IsInMarkup() && _pParentElement->GetMarkupPtr()->IsStrictCSS1Document();
}

//*********************************************************************
//  CStyleSheet::Notify()
// Notifications from CSharedStyleSheet
//*********************************************************************
HRESULT 
CStyleSheet::Notify(DWORD dwNotification)
{
    HRESULT  hr = S_OK;

    Assert( !_fParser );
    switch (dwNotification)
    {
    case NF_SHAREDSTYLESHEET_BITSCTXERROR:
            if (_eParsingStatus == CSSPARSESTATUS_PARSING)    // !_fParser
            {
                Assert( !_fParser );
                TraceTag( (tagSharedStyleSheet, "Notify [%p]-- received notification for BITSCTXERROR-[%p]\n", this, GetSSS()));
                _eParsingStatus = CSSPARSESTATUS_DONE;

                Fire_onerror();
                EnsureCopyOnWrite(/*fDetachOnly*/ TRUE);    // disconnect from the shared SS();
            }
            //
            // FALL THROUGH
            //
        
    case NF_SHAREDSTYLESHEET_PARSEDONE:
            if (_eParsingStatus == CSSPARSESTATUS_PARSING)    // !_fParser
            {
                TraceTag( (tagSharedStyleSheet, "Notify [%p]-- received notification for PARSEDONE-[%p]\n", this, GetSSS()));
                Assert( !_fParser );
                Assert( _fComplete );
                Assert( GetSSS()->_fComplete );
                Assert( !GetSSS()->_fParsing );
                
                _eParsingStatus = CSSPARSESTATUS_DONE;
                // now the shared style sheet is ready to be used -- creating from a new one
                hr = THR( ReconstructStyleSheet(GetSSS(), /*fReplace*/FALSE) ); 
                if (SUCCEEDED(hr))
                {
                    // might still have imports pending
                    hr = S_OK;
                }
            }

            if (_eParsingStatus == CSSPARSESTATUS_DONE)
            {
                Assert( _fComplete );
                CMarkup  *pMarkup = GetMarkup();
                // Link element is responsible for downloading and parsing...
                Assert(!_fParser);
                if (!IsAnImport() && _pParentElement && _pParentElement->Tag() == ETAG_LINK)
                {
                    CLinkElement  *pLink = DYNCAST(CLinkElement, _pParentElement);
                    Assert( pLink );
                    TraceTag( (tagSharedStyleSheet, "Notify [%p]-- PARSEDONE-[%p] -- notify link element [%p]\n", this, GetSSS(), pLink));
                    
                    IGNORE_HR( pLink->OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
                    CheckImportStatus();
                    if (pLink->_dwScriptDownloadCookie)
                    {
                        Assert (pMarkup);
                        pMarkup->UnblockScriptExecution(&(pLink->_dwScriptDownloadCookie));
                        pLink->_dwScriptDownloadCookie = NULL;
                    }
                    pLink->_pCssCtx->SetProgSink(NULL); // detach download from document's load progress
                    pLink->SetCssCtx( NULL );           // No reason to hold on to the data anymore
                }
                else
                {
                    TraceTag( (tagSharedStyleSheet, "Notify [%p]-- PARSEDONE-[%p] -- detach download [%p]\n", this, GetSSS(), _pCssCtx));
                    // Relayout the doc; new rules may have been loaded (e.g. DWNLOAD_COMPLETE),
                    // or we may have killed off rules w/o re-rendering before starting the load
                    // for this sheet (e.g. changing src of an existing sheet).
                    IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );

                    // notify parent that this is done
                    CheckImportStatus();    // Needed e.g. if all imports were cached, their OnChan's would all be called
                                            // before parsing finished.
                    pMarkup->UnblockScriptExecution(&_dwScriptCookie);
                    
                    _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
                    SetCssCtx(NULL);
                }
            }
            else
            {
                TraceTag( (tagSharedStyleSheet, "Notify [%p] is not one that is waitting -- has gone through DoParsing for [%p]  yet", this, GetSSS()) );
            }
            break;
    
    default:
        break;
    }

    RRETURN(hr);
}


//*********************************************************************
//  CStyleSheet::SetReadyState()
//      Handles passing readystate changes to our parent element, which
//  may cause our parent element to fire the onreadystatechange event.
//*********************************************************************
HRESULT CStyleSheet::SetReadyState( long readyState )
{
    TraceTag( (tagStyleSheet, "[%p] set readystate [%x] ready state is %x", this, readyState, READYSTATE_COMPLETE) );
    if ( !_pParentElement )
        return S_OK;    // In case we're a user stylesheet

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        return pStyle->SetReadyStateStyle( readyState );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        return pLink->SetReadyStateLink( readyState );
    }
}

//*********************************************************************
//  CStyleSheet::CheckImportStatus()
//  Checks whether all our imports have come in, and notify our parent
//  if necessary.  This ultimately includes causing our parent element
//  to fire events.
//*********************************************************************
void CStyleSheet::CheckImportStatus( void )
{
    // If all stylesheets nested below us are finished d/ling..
    if ( _eParsingStatus != CSSPARSESTATUS_PARSING && (_nExpectedImports == _nCompletedImports) )
    {
        if ( IsAnImport() )
        {
            // If we've hit a break in our parentSS chain, just stop..
            if ( !IsDisconnectedFromParentSS() )
            {
                // Notify our parent that we are finished.
                _pParentStyleSheet->CheckImportStatus();
            }
        }
        else
        {
            // We are a top-level SS!  Since everything below us is
            // finished, we can fire.
            SetReadyState( READYSTATE_COMPLETE );
        }
    }
}

//*********************************************************************
//  CStyleSheet::StopDownloads
//      Halt all downloading of stylesheets, including all nested imports.
//*********************************************************************
void CStyleSheet::StopDownloads( BOOL fReleaseCssCtx )
{
    long z;
    CStyleSheet *pSS;

    if ( _pCssCtx )
    {
        CMarkup *pMarkup;

        TraceTag( (tagStyleSheet, "StopDownloads [%p]-- while we are still holding _pCssCtx [%p] for [%p]\n", this, _pCssCtx, GetSSS()));
        Assert( _fParser == FALSE );
        EnsureCopyOnWrite( /*fDeatchOnly*/ TRUE, /*fWaitForCompleteion*/FALSE);
        
       _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->SetLoad( FALSE, NULL, FALSE );

        pMarkup = _pParentElement->GetMarkup();
        if(pMarkup)
            pMarkup->Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        
         // This sheet has finished, one way or another.
         if ( IsAnImport() )
             _pParentStyleSheet->_nCompletedImports++;
         _eParsingStatus = CSSPARSESTATUS_DONE;   // Need to make sure we'll walk up to our parent in CheckImportStatus()

        if ( fReleaseCssCtx )
            SetCssCtx(NULL);
     }


    if ( _pImportedStyleSheets )
    {
        for ( z=0 ; (pSS=(_pImportedStyleSheets->Get(z))) != NULL ; ++z)
            pSS->StopDownloads( fReleaseCssCtx );
    }

#ifndef NO_FONT_DOWNLOAD
    // If we initiated any downloads of embedded fonts, stop those too
    {
        int n = _apFontFaces.Size();
        int i;
        CFontFace *pFace;

        for( i=0; i < n; i++)
        {
            pFace = ((CFontFace **)(_apFontFaces))[ i ];
            Assert( pFace->ParentStyleSheet() == this );
            pFace->StopDownloads();
        }
    }
#endif // NO_FONT_DOWNLOAD
}

//*********************************************************************
//  CStyleSheet::OMGetOMRule
//      Returns the automation object for a given rule number, creating
//  the automation object if necessary and caching it in _apOMRules.
//  If the index is out of range, may return NULL.
//*********************************************************************
HRESULT CStyleSheet::OMGetOMRule( long lIdx, IHTMLStyleSheetRule **ppSSRule )
{
    HRESULT  hr = S_OK;
    unsigned long     lRule;
    Assert( ppSSRule );

    *ppSSRule = NULL;
    if ( lIdx < 0 || (unsigned int)lIdx >= GetNumRules())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(OMGetOMRuleInternal(lIdx, &lRule));
    if (hr)
        goto Cleanup;

    hr = THR(_apOMRules[lRule]->QueryInterface( IID_IHTMLStyleSheetRule, (void **)ppSSRule ));
    
Cleanup:
    RRETURN(hr);
}


//
//   lIdx is 0 based
//
HRESULT 
CStyleSheet::OMGetOMRuleInternal(unsigned long lIdx, unsigned long *plRule)
{
    HRESULT    hr = S_OK;
    int  iMaxIdx;

    //
    // _apOMRules is a virtual array its size equals to the highest 
    // accessed rule idx. It will grow (leap) if a higher index 
    // rule is accessed.
    //
    Assert(plRule);
    *plRule = 0;

    Assert(lIdx < GetNumRules());
    iMaxIdx = _apOMRules.Size() - 1;
    if (iMaxIdx < 0 || lIdx > (unsigned int)iMaxIdx)    // out-of-bound
    {
        _apOMRules.Grow(lIdx+1);
        for (int n=iMaxIdx+1; n < _apOMRules.Size(); n++)
        {
            _apOMRules[n] = NULL;
        }
        _apOMRules.Insert(lIdx, NULL);
        Assert(!_apOMRules[lIdx]);
    }

    if (_apOMRules[lIdx] == NULL)
    {
        CStyleRule  *pSR = GetSSS()->GetRule((CStyleRuleID)(lIdx + 1));
        if (pSR)
        {
            CStyleSheetRule *pRE = new CStyleSheetRule( this, pSR->GetRuleID(), pSR->GetElementTag() );
            if (!pRE)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _apOMRules[lIdx] = pRE;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
    }
    *plRule = lIdx;
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::EnSureCopyOnWrite
// 
//  fDeatchOnly means we will not try to reconstruct OM rules, imports, Fonts, Pages
//  it generally means we are going to discard everything, and start from
//  scratch again. This could happen such as put_href is called. 
//
//*********************************************************************
HRESULT
CStyleSheet::EnsureCopyOnWrite(BOOL fDetachOnly, BOOL fWaitForCompletion)
{
    HRESULT  hr = S_OK;

    TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - fDetachOnly [%d]", fDetachOnly) );
    if (GetSSS()->_pManager)    // if this is shared
    {
        //
        // Give the fact that there is no script events come in during parsing time
        // _fComplete == FALSE means this function is called during parsing. There
        // is nothing to worry about...
        //
        if (fWaitForCompletion && !GetSSS()->_fComplete)  
            goto Cleanup;

#if DBG == 1        
        if (fWaitForCompletion)
        {
            Assert( GetSSS()->_fComplete );
            Assert( !GetSSS()->_fParsing );
            Assert( GetSSS()->_lReserveCount >= 0 );
        }
#endif     
        if (GetSSS()->_apSheetsList.Size() > 1)     // shared
        {
            CSharedStyleSheet  *pSSS;

            TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - shared, need to clone lReserveCount [%d] _spSheetsList.Size [%d]", GetSSS()->_lReserveCount, GetSSS()->_apSheetsList.Size()) );
            WHEN_DBG( DumpHref(GetAbsoluteHref() ) );
            hr = THR( GetSSS()->Clone(&pSSS, /*fNoContent=*/fDetachOnly) ); // this will set ref to 1
            if (hr)
                goto Cleanup;

            pSSS->_pManager = NULL;     // this is our own private copy
            hr = THR( AttachLate( pSSS, /*fReconstruct*/!fDetachOnly, /*fIsReplacement*/TRUE) );
            pSSS->Release();      // to offset the addref by Clone 
            if (hr)
                goto Cleanup;
            
        }
        else if (GetSSS()->_pManager)
        {
            WHEN_DBG( Assert( GetSSS()->_lReserveCount == 0 ) );
            //
            // remove this from collection as this can no longer be shared
            //
            TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - non-shared, simply remove from collection") );
            WHEN_DBG( DumpHref(GetAbsoluteHref() ) );
            hr = THR( GetSSS()->_pManager->RemoveSharedStyleSheet(GetSSS()) );
            GetSSS()->_pManager = NULL;
        }
        GetSSS()->_fModified = TRUE;
    }
#if DBG == 1
    else
    {
        AssertSz( GetSSS()->_apSheetsList.Size() <= 1, 
            "Shared Style Sheet that is not in the shared array - "
            "probably CDoc is released when there is outstanding stylesheet");
    }
#endif
Cleanup:
    RRETURN(hr);
}



#if 0
//*********************************************************************
// CStyleSheet::Invoke
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support copy-on-write for write access 
//*********************************************************************

STDMETHODIMP
CStyleSheet::InvokeEx(DISPID       dispidMember,
                      LCID         lcid,
                      WORD         wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT *    pvarResult,
                      EXCEPINFO *  pexcepinfo,
                      IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // do copy-on-write if necessary
    Assert( DISPID_CStyleSheet_addImport    ==   DISPID_CStyleSheet_id + 1 );
    Assert( DISPID_CStyleSheet_addRule      ==   DISPID_CStyleSheet_addImport + 1);
    Assert( DISPID_CStyleSheet_removeImport ==   DISPID_CStyleSheet_addRule + 1);
    Assert( DISPID_CStyleSheet_removeRule   ==   DISPID_CStyleSheet_removeImport + 1);
    Assert( DISPID_CStyleSheet_media        ==   DISPID_CStyleSheet_removeRule + 1);
    Assert( DISPID_CStyleSheet_cssText      ==   DISPID_CStyleSheet_media + 1);
    Assert( DISPID_CStyleSheet_rules        ==   DISPID_CStyleSheet_cssText + 1);
    
    if ( dispidMember > DISPID_CStyleSheet_id 
        && dispidMember < DISPID_CStyleSheet_cssText
        )
    {
        if ( !( dispidMember >= DISPID_CStyleSheet_media 
                && (wFlags & DISPATCH_PROPERTYGET) 
              )
           )  // get for media/cssText does need copy on write
        {
            if (!SUCCEEDED(EnsureCopyOnWrite()))
                goto Cleanup;
        }
    }  

    // CBase knows how to handle expando
    hr = THR_NOTRACE(super::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));
                                    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}
#endif    


//*********************************************************************
//  CStyleSheet::title
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_title(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // Imports don't support the title property; just return NULL string.
    if ( IsAnImport() )
        goto Cleanup;

    hr = _pParentElement->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCElementtitle );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_title(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // We don't support the title prop on imports.
    if ( IsAnImport() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    hr = _pParentElement->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCElementtitle );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::media
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_media(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCStyleElementmedia );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementmedia );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_media(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCStyleElementmedia );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCLinkElementmedia );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_cssText
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_cssText(BSTR *pBSTR)
{
    HRESULT hr = S_OK;
    CStr cstr;
    CMarkup *pMarkup;
    TCHAR *pAbsoluteHref;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pMarkup = GetMarkup();
    pAbsoluteHref = GetAbsoluteHref();
    if (pMarkup && pAbsoluteHref && !pMarkup->AccessAllowed(pAbsoluteHref))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    *pBSTR = NULL;

    hr = GetString( &cstr );

    if ( hr != S_OK )
        goto Cleanup;

    hr = cstr.AllocBSTR( pBSTR );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::put_cssText
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::put_cssText(BSTR bstr)
{
    WHEN_DBG( Assert(DbgIsValid()) );

    HRESULT hr = S_OK;
    CElement *pParentElement = _pParentElement;
    CStyleSheet *pParentSS = _pParentStyleSheet;
    CMarkup *pMarkup;
    BOOL fDisabled = _fDisabled;
    CCSSParser *parser;
    Assert(pParentElement);

    hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
    if (hr)
        goto Cleanup;
    
    // Remove all the rules
    hr = ChangeStatus( CS_CLEARRULES, FALSE, NULL );   // disabling, detached from tree, no re-render
    if ( hr )
        goto Cleanup;

    GetSSS()->_fParsing   = FALSE;
    GetSSS()->_fComplete = FALSE;
    GetSSS()->_fModified  = TRUE;
    
    // Now restore a few bits of information that don't actually change for us.
    _pParentElement = pParentElement;
    _pParentStyleSheet = pParentSS;
    _fDisabled = fDisabled;

    // Parse the new style string!
    parser = new CCSSParser( this, NULL, IsXML(), IsStrictCSS1());
    if ( !parser )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    parser->Open();
    parser->Write( bstr, _tcslen( bstr ) );
    parser->Close();
    delete parser;

    // Reformat and rerender.

    pMarkup = pParentElement->GetMarkup();
    if (pMarkup)
        hr = THR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE) );

Cleanup:
    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheet::parentStyleSheet
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_parentStyleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // NOTE: Just return self if we're disconnected?
    if ( IsAnImport() && !IsDisconnectedFromParentSS() )
    {
        hr = _pParentStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::owningElement
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_owningElement(IHTMLElement** ppHTMLElement)
{
    HRESULT hr = S_OK;

    if (!ppHTMLElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLElement = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    hr = _pParentElement->QueryInterface(IID_IHTMLElement,
                                          (void**)ppHTMLElement);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::disabled
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_disabled(VARIANT_BOOL* pvbDisabled)
{
    HRESULT hr = S_OK;

    if (!pvbDisabled)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pvbDisabled = (_fDisabled ? VB_TRUE : VB_FALSE);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_disabled(VARIANT_BOOL vbDisabled)
{
    HRESULT hr = S_OK;
    DWORD   dwAction;

    Assert( DbgIsValid() );

    // If the enable/disable status isn't changing, do nothing.
    if ( (_fDisabled ? VB_TRUE : VB_FALSE) != vbDisabled )
    {
        dwAction = (vbDisabled ? 0 : CS_ENABLERULES);   // 0 means disable rules
        hr = ChangeStatus( dwAction, TRUE, NULL);   // Force a rerender

        // We have to stuff these into the AA by hand in order to avoid
        // firing an OnPropertyChange (which would put us into a recursive loop).
        if ( _pParentElement->Tag() == ETAG_STYLE )
            hr = THR(s_propdescCElementdisabled.b.SetNumber( _pParentElement,
                     CVOID_CAST(_pParentElement->GetAttrArray()), vbDisabled, 0 ));
        else
        {
            Assert( _pParentElement->Tag() == ETAG_LINK );
            hr = THR(s_propdescCElementdisabled.b.SetNumber( _pParentElement,
                     CVOID_CAST(_pParentElement->GetAttrArray()), vbDisabled, 0 ));
        }
    }

    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::readonly
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_readOnly(VARIANT_BOOL* pvbReadOnly)
{
    HRESULT hr = S_OK;

    if (!pvbReadOnly)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // Imports are readonly.  Also, if we have a parent element of type LINK, we must
    // be a linked stylesheet, and thus readonly.

    *pvbReadOnly = ( IsAnImport() || (_pParentElement->Tag() == ETAG_LINK) ) ?
                        VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::imports
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_imports(IHTMLStyleSheetsCollection** ppHTMLStyleSheetsCollection)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheetsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheetsCollection = NULL;

    // If we don't already have an imports collection instantiated, do so now.
    if ( !_pImportedStyleSheets )
    {
        // Imported stylesheets don't manage their own rules.
        _pImportedStyleSheets = new CStyleSheetArray( this, _pSSAContainer, _sidSheet );
        Assert( "Failure to allocate imported stylesheets array! (informational)" && _pImportedStyleSheets );
        if (!_pImportedStyleSheets)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        if (_pImportedStyleSheets->_fInvalid)
        {
            hr = E_OUTOFMEMORY;
            _pImportedStyleSheets->CBase::PrivateRelease();
            goto Cleanup;
        }
    }

    hr = _pImportedStyleSheets->QueryInterface(IID_IHTMLStyleSheetsCollection,
                                            (void**)ppHTMLStyleSheetsCollection);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::rules
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_rules(IHTMLStyleSheetRulesCollection** ppHTMLStyleSheetRulesCollection)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    TCHAR *pAbsoluteHref;

    if (!ppHTMLStyleSheetRulesCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pMarkup = GetMarkup();
    pAbsoluteHref = GetAbsoluteHref();

    static int fRunningInBrowser = -1;

    if (fRunningInBrowser == -1)
        fRunningInBrowser = GetModuleHandle(TEXT("iexplore.exe")) != NULL 
            || GetModuleHandle(TEXT("explorer.exe")) != NULL
            || GetModuleHandle(TEXT("msn6.exe")) != NULL;
    
    if ( fRunningInBrowser == 1 && pMarkup && pAbsoluteHref && !pMarkup->AccessAllowed(pAbsoluteHref))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    *ppHTMLStyleSheetRulesCollection = NULL;

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );     // someone might be writing to it...
    if (hr)
        goto Cleanup;
    
    // If we don't already have a rules collection instantiated, do so now.
    if ( !_pOMRulesArray )
    {
        _pOMRulesArray = new CStyleSheetRuleArray( this );
        if ( !_pOMRulesArray )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = _pOMRulesArray->QueryInterface( IID_IHTMLStyleSheetRulesCollection,
                                            (void**)ppHTMLStyleSheetRulesCollection);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::href
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_href(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // If we're an import..
    if ( IsAnImport() )
    {
        hr = _cstrImportHref.AllocBSTR( pBSTR );
    }
    else if ( _pParentElement->Tag() == ETAG_LINK ) // .. if we're a <link>
    {
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_UrlHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementhref );
    }
    else    // .. we must be a <style>, and have no href.
    {
        Assert( "Bad element type associated with stylesheet!" && _pParentElement->Tag() == ETAG_STYLE );
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_href(BSTR bstr)
{
    HRESULT hr = S_OK;

    // Are we an import?
    if ( IsAnImport() )
    {
        if ( _pParentStyleSheet->IsAnImport() || (_pParentElement->Tag() == ETAG_LINK) )
        {
            // If we're an import, but our parent isn't a top-level stylesheet,
            // (i.e. our parent is also an import), or if we're an import of a linked
            // stylesheet then our href is readonly.
            goto Cleanup;
        }

        CStyleSheetCtx  ctxSS;
        ctxSS._szUrl = (LPCTSTR)bstr;

        hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
        if (hr)
            goto Cleanup;
        hr = LoadFromURL( &ctxSS );
        if ( hr )
            goto Cleanup;

        _cstrImportHref.Set( bstr );
    }
    // Are we a linked stylesheet?
    else if ( _pParentElement->Tag() == ETAG_LINK )
    {        
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->put_UrlHelper( bstr, (PROPERTYDESC *)&s_propdescCLinkElementhref );
    }
    // Otherwise we must be a <style>, and have no href.
    else
    {
        Assert( "Bad element type associated with stylesheet!" && _pParentElement->Tag() == ETAG_STYLE );
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_type
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_type(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( _pParentElement );

    // NOTE: we currently return the top-level SS's HTML type attribute for imports;
    // this is OK for now since we only support text/css, but in theory stylesheets of
    // one type could import stylesheets of a different type.

    if ( _pParentElement->Tag() == ETAG_STYLE )
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCStyleElementtype );
    }
    else if ( _pParentElement->Tag() == ETAG_LINK )
    {
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementtype );
    }
    else
    {
        Assert( "Bad element type associated with stylesheet!" && FALSE );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_id
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_id(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( _pParentElement );

    // Imports have no id; we don't return the parent element's id
    // because that would suggest you could use the id to get to the
    // import (when it would actually get you to the top-level SS).
    if ( IsAnImport() )
    {
        goto Cleanup;
    }

    hr = THR( _pParentElement->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCElementid ) );

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addImport
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::addImport(BSTR bstrURL, long lIndex, long *plNewIndex)
{
    HRESULT hr = S_OK;

    if ( !plNewIndex )
    {
        hr = E_POINTER;

        goto Cleanup;
    }

    // Return value of -1 indicates failure to insert.
    *plNewIndex = -1;

    // Check for zero-length URL, which we ignore.
    if ( FormsStringLen(bstrURL) == 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If requested index out of bounds, just append the import
    if ( (lIndex < -1) ||
         (_pImportedStyleSheets && (lIndex > _pImportedStyleSheets->Size())) ||
         (!_pImportedStyleSheets && (lIndex > 0)) )
    {
        lIndex = -1;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
 
    hr = AddImportedStyleSheet( (LPTSTR)bstrURL, /* we are not parsing */FALSE, lIndex, plNewIndex);
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT CStyleSheet::removeImport( long lIndex )
{
    HRESULT hr = S_OK;

    CStyleSheet *pImportedStyleSheet;

    // If requested index out of bounds, error out
    if ( !_pImportedStyleSheets || (lIndex < 0) || (lIndex >= _pImportedStyleSheets->Size()))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    pImportedStyleSheet = _pImportedStyleSheets->_aStyleSheets[lIndex];
    pImportedStyleSheet->StopDownloads(TRUE);
    hr = _pImportedStyleSheets->ReleaseStyleSheet( pImportedStyleSheet, TRUE );

    if (!hr)
    {
        CSharedStyleSheet::CImportedStyleSheetEntry  *pEntry;
        pEntry = (CSharedStyleSheet::CImportedStyleSheetEntry *)(GetSSS()->_apImportedStyleSheets) + lIndex;
        if (pEntry)
        {
            pEntry->_cstrImportHref.Free();
            GetSSS()->_apImportedStyleSheets.Delete(lIndex);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addRule
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::addRule(BSTR bstrSelector, BSTR bstrStyle, long lIndex, long *plNewIndex)
{
    HRESULT         hr = E_OUTOFMEMORY;
    CStyleSelector *pNewSelector = NULL;
    CStyleSelector *pChildSelector = NULL;
    CStyleRule     *pNewRule = NULL;
    CCSSParser     *ps = NULL;
    Tokenizer       tok;
    Tokenizer::TOKEN_TYPE tt;

    if (!plNewIndex || !bstrSelector || !bstrStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plNewIndex = -1;

    if (!(*bstrSelector) || !(*bstrStyle))
    {
        // Strings shouldn't be empty
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    tok.Init(bstrSelector, FormsStringLen(bstrSelector));

    tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF)
    {
        // the parent element may have been detached, is there a problem here?
        pChildSelector = new CStyleSelector(tok, pNewSelector, IsStrictCSS1(), IsXML());
        if (!pChildSelector)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pNewSelector = pChildSelector;

        tt = tok.TokenType();

        // We do not support grouping of selectors through addRule, only contexttual
        if (tt == Tokenizer::TT_Comma)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (!pNewSelector)
    {   // Selector was invalid or empty
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNewRule = new CStyleRule(pNewSelector);
    if ( !pNewRule )
        goto Cleanup;

    // Actually parse the style text
    ps = new CCSSParser(this, pNewRule->GetRefStyleAA(), IsXML(), IsStrictCSS1(), eSingleStyle, &CStyle::s_apHdlDescs,
                        this, HANDLEPROP_SET|HANDLEPROP_VALUE );
    if ( !ps )
        goto Cleanup;

    ps->Open();
    ps->Write((LPTSTR)bstrStyle, FormsStringLen(bstrStyle));
    ps->Close();

    delete ps;

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;

    // Add the rule to our stylesheet, and get the index
    hr = AddStyleRule(pNewRule, TRUE, lIndex);
    // The AddStyleRule call will have deleted the new rule for us, so we're OK.
    if (hr)
    {
        pNewRule = NULL;    // already deleted by AddStyleRule _even when it fails_
        goto Cleanup;
    }

    hr = THR(_pParentElement->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE));

Cleanup:
    if (hr)
    {
        if (pNewSelector)
            delete pNewSelector;
        if (pNewRule)
            delete pNewRule;
    }

    RRETURN(SetErrorInfo(hr));
}


//*********************************************************************
//  CStyleSheet::removeRule
//      IHTMLStyleSheet interface method
//      This method remove a rule from CStyleRuleArray in the hash table
//  as well as the CRuleEntryArray.
//*********************************************************************
HRESULT CStyleSheet::removeRule( long lIndex )
{
    Assert( DbgIsValid() );

    HRESULT     hr = S_OK;

    Assert( "Stylesheet must have a container!" && _pSSAContainer );

    // Make sure the index is valid.
    if (  lIndex < 0  || (unsigned long)lIndex >= GetNumRules()  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    //
    // Remove the rules in rule-store.
    //
    hr = THR(RemoveStyleRule(lIndex));
    if (hr)
        goto Cleanup;

    // Force update of element formats to account for new set of rules
    if (GetRootContainer()->_pOwner)
    {
        CMarkup *pMarkup = DYNCAST(CMarkup, GetRootContainer()->_pOwner);  // rule manager's owner is always the markup

        if (pMarkup)
            IGNORE_HR( pMarkup->ForceRelayout() );
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT CStyleSheet::GetString( CStr *pResult )
{
    RRETURN(GetSSS()->GetString( this, pResult));
}


//*********************************************************************
//  CStyleSheet::pages
//      IHTMLStyleSheet2 interface property
//*********************************************************************

HRESULT
CStyleSheet::get_pages(IHTMLStyleSheetPagesCollection** ppHTMLStyleSheetPagesCollection)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheetPagesCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheetPagesCollection = NULL;

    // Create the "pages" array if we don't already have one.
    if ( !_pPageRules )
    {
        _pPageRules = new CStyleSheetPageArray( this );
        // The stylesheet owns the ref on the page array that it will release when it passivates.
        // The page array holds a subref back on the stylesheet.
    }

    if ( _pPageRules )
    {
        hr = _pPageRules->QueryInterface(IID_IHTMLStyleSheetPagesCollection,
                                            (void**)ppHTMLStyleSheetPagesCollection);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addPageRule
//      IHTMLStyleSheet2 interface method
//*********************************************************************

HRESULT
CStyleSheet::addPageRule(BSTR bstrSelector, BSTR bstrStyle, long lIndex, long *plNewIndex)
{
    HRESULT         hr = E_NOTIMPL;

    RRETURN(SetErrorInfo(hr));
}



//*********************************************************************
//  CStyleSheet::GetRule
//      This should only be called from OM
//*********************************************************************
CStyleRule *CStyleSheet::OMGetRule( ELEMENT_TAG eTag, CStyleRuleID ruleID )
{

    // Only look up OM array
    DWORD  dwRule = ruleID.GetRule();

    if (dwRule <= GetNumRules())
    {
        CStyleRule *pRule = GetRule(ruleID);
        if (pRule && pRule->GetElementTag() == eTag)
        {
            return pRule;
        }
    }
    return NULL;
};



CStyleRule  *CStyleSheet::GetRule(CStyleRuleID   ruleID)
{
    Assert( ruleID.GetSheet() == 0  || ruleID.GetSheet() == _sidSheet);
    
    unsigned int nRule = ruleID.GetRule();
    if (nRule <= GetNumRules())
    {
        return GetSSS()->GetRule((CStyleRuleID)nRule);
    }
    Assert("Try to GetRule that is not in current style sheet" && FALSE);
    return NULL;
}



//*********************************************************************
//  CStyleSheet::DbgIsValid
//      Debug functions
//*********************************************************************
#if DBG==1
BOOL 
CStyleSheet::DbgIsValid()
{
    // 
    // Make sure the automation array is okay
    //
    CStyleSheetRule **pRules;
    int i;
    BOOL fRet = TRUE;

    for (i = 0, pRules = _apOMRules;
         i < _apOMRules.Size();
         i++, pRules++
         )
    {
        if (*pRules)
        {
            CStyleRule  *pRule;
            CStyleRuleID sidRule = (CStyleRuleID)((*pRules)->_dwID);
            unsigned int nRule = sidRule.GetRule();

            if ( (*pRules)->_pStyleSheet != this)
            {   
                Assert( "automation rules contain one rule that belongs to different StyleSheet" && FALSE );
                fRet = FALSE;
                goto Cleanup;
            }
            
            if ( sidRule.GetSheet() != 0 ||
                 nRule > GetNumRules() ||
                 nRule != (unsigned int)(i+1)
                )
            {
                Assert( "automation rules contain one rule that has invalid _dwID" && FALSE );
                fRet = FALSE;
                goto Cleanup;
            }


            pRule = (CStyleRule *)(GetSSS()->_apRulesList[nRule - 1]);
            Assert(pRule);
            
            if (pRule->GetElementTag() != (*pRules)->_eTag)
            {
                Assert( "automation rule with different _eTag -- out-of-sync"&&FALSE );
                fRet = FALSE;
                goto Cleanup;
            }
        }
    }

    //
    // Now make sure SSS is valid
    //
    fRet = GetSSS()->DbgIsValid();
Cleanup:
    Assert( fRet && "CStyleSheet::DbgIsValid -- not valid");
    return fRet;
}



VOID CStyleSheet::Dump()
{
    if (!InitDumpFile())
        return;
    
    Dump(FALSE);
    
    CloseDumpFile();
}

VOID CStyleSheet::Dump(BOOL fRecursive)
{
    WriteHelp(g_f, _T("-0x<0x>:<1s>\r\n"), _sidSheet, GetSSS()->_achAbsoluteHref);
    if (_pImportedStyleSheets)
    {
        _pImportedStyleSheets->Dump(fRecursive);
    }
    WriteString(g_f, _T("\r\n"));
    GetSSS()->Dump(this);
}

#endif



//---------------------------------------------------------------------
//  Class Declaration:  CStyleID
//
//  A 32-bit cookie that uniquely identifies a style rule's position
//  in the cascade order (i.e. it encodes the source order within its
//  containing stylesheet, as well as the nesting depth position of
//  its containing stylesheet within the entire stylesheet tree.
//
//  The source order of the rule within the sheet is encoded in the
//  Rules field (12 bits).
//
//  We allow up to MAX_IMPORT_NESTING (4) levels of @import nesting
//  (including the topmost HTML document level).  The position within
//  each nesting level is encoded in 5 bits.
//
//---------------------------------------------------------------------
CStyleID::CStyleID(const unsigned long l1, const unsigned long l2,
                    const unsigned long l3, const unsigned long l4, const unsigned long r)
{
    Assert( "Maximum of 31 stylesheets per level!" && l1 <= MAX_SHEETS_PER_LEVEL && l2 <= MAX_SHEETS_PER_LEVEL && l3 <= MAX_SHEETS_PER_LEVEL && l4 <= MAX_SHEETS_PER_LEVEL );
    Assert( "Maximum of 4095 rules per stylesheet!" && r <= MAX_RULES_PER_SHEET );

    _dwID = ((l1<<27) & LEVEL1_MASK) | ((l2<<22) & LEVEL2_MASK) | ((l3<<17) & LEVEL3_MASK) |
            ((l4<<12) & LEVEL4_MASK) | (r & RULE_MASK);
}

//*********************************************************************
// CStyleID::SetLevel()
// Sets the value of a particular nesting level
//*********************************************************************
void CStyleID::SetLevel(const unsigned long level, const unsigned long value)
{
    Assert( "Maximum of 31 stylesheets per level!" && value <= MAX_SHEETS_PER_LEVEL );
    switch( level )
    {
        case 1:
            _dwID &= ~LEVEL1_MASK;
            _dwID |= ((value<<27) & LEVEL1_MASK);
            break;
        case 2:
            _dwID &= ~LEVEL2_MASK;
            _dwID |= ((value<<22) & LEVEL2_MASK);
            break;
        case 3:
            _dwID &= ~LEVEL3_MASK;
            _dwID |= ((value<<17) & LEVEL3_MASK);
            break;
        case 4:
            _dwID &= ~LEVEL4_MASK;
            _dwID |= ((value<<12) & LEVEL4_MASK);
            break;
        default:
            Assert( "Invalid Level for style ID" && FALSE );
    }
}

//*********************************************************************
// CStyleID::GetLevel()
// Gets the value of a particular nesting level
//*********************************************************************
unsigned long CStyleID::GetLevel(const unsigned long level) const
{
    switch( level )
    {
        case 1:
            return ((_dwID>>27)&0x1F);
        case 2:
            return ((_dwID>>22)&0x1F);
        case 3:
            return ((_dwID>>17)&0x1F);
        case 4:
            return ((_dwID>>12)&0x1F);
        default:
            Assert( "Invalid Level for style ID" && FALSE );
            return 0;
    }
}

//*********************************************************************
// TranslateMediaTypeString()
//      Parses a MEDIA attribute and builds the correct EMediaType from it.
//*********************************************************************
MtDefine(TranslateMediaTypeString_pszMedia, Locals, "TranslateMediaTypeString pszMedia");

DWORD TranslateMediaTypeString( LPCTSTR pcszMedia )
{
    DWORD dwRet = 0;
    LPTSTR pszMedia;
    LPTSTR pszString;
    LPTSTR pszNextToken;
    LPTSTR pszLastChar;

    // TODO: Handle OOM here
    MemAllocString(Mt(TranslateMediaTypeString_pszMedia), pcszMedia, &pszMedia);
    pszString = pszMedia;

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;
        pszNextToken = pszString;
        while ( *pszNextToken && *pszNextToken != _T(',') )
            pszNextToken++;
        if ( pszNextToken > pszString )
        {
            pszLastChar = pszNextToken - 1;
            while ( isspace( *pszLastChar ) && ( pszLastChar >= pszString ) )
                *pszLastChar-- = _T('\0');
        }
        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');
        if ( !*pszString )
            continue;   // This is so empty MEDIA strings will default to All instead of Unknown.
        dwRet |= CSSMediaTypeFromName(pszString);
    }

    if ( !dwRet )
        dwRet = MEDIA_All;
    MemFree( pszMedia );
    return ( dwRet );
}

// 
//*********************************************************************
// CNamespace::SetNamespace
// Parses given string and stores into member variables depending on the type
//*********************************************************************
HRESULT 
CNamespace::SetNamespace(LPCTSTR pchStr)
{
    HRESULT         hr;
    CBufferedStr    strWork;
    LPTSTR          pStr;

    strWork.Set(pchStr);

    pStr = (LPTSTR)strWork;

    if (pStr == NULL)
    {   
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(RemoveStyleUrlFromStr(&pStr));
    if(SUCCEEDED(hr))
    {
        Assert( pStr[0] != 0 );
        _strNamespace.Set(pStr);
        hr = S_OK;
    }
    //_strNameSpace will be empty if we fail

Cleanup:

    RRETURN(hr);
}



//*********************************************************************
// CNamespace::IsEqual
// Returns TRUE if the namspaces  are equal
//*********************************************************************
BOOL 
CNamespace::IsEqual(const CNamespace * pNmsp) const
{
    if(!pNmsp || pNmsp->IsEmpty())
    {
        if(IsEmpty())
            return TRUE;
        else
            return FALSE;
    }

    return (_tcsicmp(_strNamespace, pNmsp->_strNamespace) == 0);
}


const CNamespace& 
CNamespace::operator=(const CNamespace & nmsp)
{
    if(&nmsp != this)
    {
        _strNamespace.Set(nmsp._strNamespace);
    }

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltable.cxx
//
//  Contents:   CTableLayout basic methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList in CTableLayout::Notify
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"  // DB stuff in Notify
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableLayoutBlock, Layout, "CTableLayoutBlock")
MtDefine(CTableLayout, Layout, "CTableLayout")
MtDefine(CTableLayout_aryRows_pv, CTableLayout, "CTableLayout::_aryRows::_pv")
MtDefine(CTableLayout_aryBodys_pv, CTableLayout, "CTableLayout::_aryBodys::_pv")
MtDefine(CTableLayout_aryCols_pv, CTableLayout, "CTableLayout::_aryCols::_pv")
MtDefine(CTableLayout_aryColGroups_pv, CTableLayout, "CTableLayout::_aryColGroups::_pv")
MtDefine(CTableLayout_aryColCalcs_pv, CTableLayout, "CTableLayout::_aryColCalcs::_pv")
MtDefine(CTableLayout_aryCaptions_pv, CTableLayout, "CTableLayout::_aryCaptions::_pv")
MtDefine(CreateTableLayoutCache, PerfPigs, "CTableLayout::CreateTableLayoutCache")
MtDefine(CTableLayout_paryCurrentRowSpans, CTableLayout, "CTableLayout::_paryCurrentRowSpans")
MtDefine(CTableLayout_paryCurrentRowSpans_pv, CTableLayout, "CTableLayout::_paryCurrentRowSpans::_pv")
MtDefine(CTableLayout_pAbsolutePositionCells_pv, CTableLayout, "CTableLayout::_pAbsolutePositionCells::_pv")
MtDefine(CTableLayout_Notify_aryRects_pv, Locals, "CTableLayout::Notify aryRects::_pv")
MtDefine(CTableLayoutBreak_pv, ViewChain, "CTableLayoutBreak_pv");
ExternTag(tagLayoutTasks);

DeclareTag(tagTLCDirty, "Tables", "trace TLC dirty bit");

ExternTag(tagCalcSize);


extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);

const CLayout::LAYOUTDESC CTableLayoutBlock::s_layoutdesc =
{
    LAYOUTDESC_TABLELAYOUT,         // _dwFlags
};

const CLayout::LAYOUTDESC CTableLayout::s_layoutdesc =
{
    LAYOUTDESC_TABLELAYOUT,         // _dwFlags
};

//+---------------------------------------------------------------------
//
// CTableLayoutBlock implementation
//
//+---------------------------------------------------------------------
//+------------------------------------------------------------------------
//
//  Member:     CTableLayoutBlock::constructor
//
//-------------------------------------------------------------------------
CTableLayoutBlock::CTableLayoutBlock(CElement * pElement, CLayoutContext *pLayoutContext) 
    : CLayout(pElement, pLayoutContext)
{
    _sizeParent.cx  = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayoutBlock::destructor
//
//-------------------------------------------------------------------------
CTableLayoutBlock::~CTableLayoutBlock()
{
    if (_pTableBorderRenderer)
        _pTableBorderRenderer->Release();
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetCaptionDispNode 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetCaptionDispNode()
{
    Assert(_fHasCaptionDispNode);
    return DYNCAST(CDispContainer, GetElementDispNode());
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetTableInnerDispNode 
//
//  Synopsis:   Find and return the CDispNode which contains TBODY cells
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetTableInnerDispNode()
{
    // TODO (112594, olego): Table inner / outer disp node work needs to be finished. 
    // There are many comments and code that is supposed to distinguish between inner 
    // and outer table dispnode. Though this work has not been finished and double 
    // set of table dispnode function effectively have the same implementation. 
    // We need to investigate and either role everything back to use single function 
    // set or truly implement inner / outer dispnodes functionality. 

    // Not done yet...assume all THEAD/TFOOT/TBODY cells live under the same display node (brendand)
    return GetTableOuterDispNode();
}

//+---------------------------------------------------------------------
//
// Function:    CTableLayoutBlock::GetTableOuterDispNode  
//
//  Synopsis:   Find and return the CDispNode which contains THEAD/TFOOT cells
//
//+---------------------------------------------------------------------
CDispContainer * 
CTableLayoutBlock::GetTableOuterDispNode()
{
    CDispContainer *    pDispNodeTableOuter;

    if (_fHasCaptionDispNode)
    {
        Assert(GetElementDispNode());

        for (CDispNode* pDispNode = GetElementDispNode()->GetFirstFlowChildNode();
                        pDispNode;
                        pDispNode = pDispNode->GetNextFlowNode())
        {
            if (!pDispNode->IsOwned())
                break;
        }

        Assert(pDispNode && pDispNode->IsFlowNode());

        pDispNodeTableOuter = CDispContainer::Cast(pDispNode);
    }
    else
    {
        pDispNodeTableOuter = CDispContainer::Cast(GetElementDispNode());
    }

    return pDispNodeTableOuter;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::EnsureTableDispNode 
//
//  Synopsis:   Manage the lifetime of the table layout display node
//
//  Arugments:  pci   - Current CTableCalcInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed
//              E_FAIL  otherwise
//
//+---------------------------------------------------------------------
HRESULT
CTableLayoutBlock::EnsureTableDispNode(
    CCalcInfo *         pci,
    BOOL                fForce)
{
    CDispContainer *    pDispNode;
    CDispNode *         pDispNodeElement;
    CDispContainer *    pDispNodeTableOuter;
    CTableLayout *      pTableLayoutCache;
    CDispNodeInfo       dni;
    HRESULT             hr = S_OK;

    Assert(pci);

    pTableLayoutCache = Table()->TableLayoutCache();
    Assert(pTableLayoutCache);

    //
    //  Get display node attributes
    //

    GetDispNodeInfo(&dni, pci, TRUE);
    Assert(!dni.IsScroller());
    Assert(!dni.IsRTLScroller());

    //
    //  Locate the display node that anchors cells
    //  (If a separate CAPTIONs display node exists, the display node for cells
    //   will be the only unowned node in the flow layer)
    //

    pDispNodeElement    = GetElementDispNode();
    pDispNodeTableOuter = GetTableOuterDispNode();
    
    //  Assert for print view positioned elements pagination support 
    Assert(!pci->_fCloneDispNode || (pDispNodeElement && pDispNodeTableOuter)); 
    Assert(!pci->_fCloneDispNode || (!pTableLayoutCache->HasCaptions() == !_fHasCaptionDispNode));

    //
    //  If a display node is needed to hold CAPTIONs and TCs, ensure one exists
    //

    if (    pTableLayoutCache->HasCaptions()
        &&  (   !_fHasCaptionDispNode
            ||  fForce
            ||  pci->_fCloneDispNode 
            ||  dni.HasUserClip() != pDispNodeElement->HasUserClip()))
    {
        DWORD extras = 0;

        if(dni.HasUserClip())
            extras |= DISPEX_USERCLIP;
        if(dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        
        pDispNode = CDispContainer::New(this, extras);
        if (!pDispNode)
            goto Error;

        pDispNode->SetOwned();
        pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());

        if (dni.HasUserClip())
            pDispNode->SetUserClip(CRect(CRect::CRECT_EMPTY));

        EnsureDispNodeLayer(dni, pDispNode);

        //
        // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
        // TODO - At some point the edit team may want to provide
        // a better UI-level way of selecting nested "thin" tables
        //
        //
        // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
        //        pTableLayoutCache->EnsureTableFatHitTest( pDispNode );
        
        if (pDispNodeElement)
        {
            if (_fHasCaptionDispNode)
            {
                if (pci->_fCloneDispNode)
                {
                    Assert(pci->GetLayoutContext());
                    AddDispNodeToArray(pDispNode); 
                }
                else 
                {
                    pDispNode->ReplaceNode(pDispNodeElement);
                }
            }
            else
            {
                pDispNodeElement->InsertParent(pDispNode);
                pDispNodeElement->SetOwned(FALSE);
                pDispNodeElement->SetAffectsScrollBounds(TRUE);
                pDispNodeElement->SetLayerFlow();
            }
        }

        if (_pDispNode == pDispNodeElement)
        {
            _pDispNode = pDispNode;
        }

        pDispNodeElement     = pDispNode;
        _fHasCaptionDispNode = TRUE;

        hr = S_FALSE;
    }

    //
    //  Otherwise, if a CAPTION/TC node exists and is not needed, remove it
    //  (The display node which anchors the table cells is the only unowned
    //   node within the flow layer)
    //

    else if (   !pTableLayoutCache->HasCaptions()
            &&  _fHasCaptionDispNode)
    {
        Assert(!pci->_fCloneDispNode);

        pDispNodeTableOuter->ReplaceParent();

        pDispNodeElement =
        _pDispNode = pDispNodeTableOuter;

        _pDispNode->SetOwned();
        _pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());

        _fHasCaptionDispNode = FALSE;

        //
        // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
        // TODO - At some point the edit team may want to provide
        // a better UI-level way of selecting nested "thin" tables
        //
        //
        // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
        //
        
        pTableLayoutCache->EnsureTableFatHitTest( _pDispNode );

        hr = S_FALSE;
    }

    //
    //  If no display node for the cells exist or if an interesting property has changed, create a display node
    //
    Assert(!dni.IsScroller());
    Assert(!dni.IsRTLScroller());

    if (    !pDispNodeTableOuter
        ||  fForce
        ||  pci->_fCloneDispNode 
        ||  dni.GetBorderType() != pDispNodeTableOuter->GetBorderType()
        ||  (   !_fHasCaptionDispNode
            &&  dni.HasUserClip() != pDispNodeTableOuter->HasUserClip())

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
        ||  pTableLayoutCache->GetFatHitTest()     != pDispNodeTableOuter->IsFatHitTest() )
    {
        DWORD extras = 0;
        if (dni.HasUserClip() && !_fHasCaptionDispNode)
            extras = DISPEX_USERCLIP;
        if (dni.GetBorderType() == DISPNODEBORDER_SIMPLE)
            extras |= DISPEX_SIMPLEBORDER;
        else if (dni.GetBorderType() == DISPNODEBORDER_COMPLEX)
            extras |= DISPEX_COMPLEXBORDER;
        if (!_fHasCaptionDispNode && dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        
        pDispNode = CDispContainer::New(this, extras);

        if (!pDispNode)
            goto Error;

        pDispNode->SetOwned(!_fHasCaptionDispNode);

        if (dni.HasUserClip())
            pDispNode->SetUserClip(CRect(CRect::CRECT_EMPTY));

        if (_fHasCaptionDispNode)
        {
            pDispNode->SetLayerFlow();
        }
        else
        {
            EnsureDispNodeLayer(dni, pDispNode);
            pDispNode->SetAffectsScrollBounds(!ElementOwner()->IsRelative());
        }

        EnsureDispNodeBackground(dni, pDispNode);
        EnsureDispNodeVisibility(dni.GetVisibility(), ElementOwner(), pDispNode);


        pTableLayoutCache->EnsureTableFatHitTest( pDispNode );

        if (pci->_fCloneDispNode)
        {
            Assert(pDispNodeTableOuter);

            if (_fHasCaptionDispNode)
            {
                Assert(pDispNodeElement);
                DYNCAST(CDispContainer, pDispNodeElement)->InsertChildInFlow(pDispNode);
            }
            else 
            {
                Assert(pci->GetLayoutContext());
                AddDispNodeToArray(pDispNode); 
            }
        }
        else 
        {
            if (pDispNodeTableOuter)
            {
                pDispNode->ReplaceNode(pDispNodeTableOuter);
            }
            else if (_fHasCaptionDispNode)
            {
                Assert(pDispNodeElement);
                DYNCAST(CDispContainer, pDispNodeElement)->InsertChildInFlow(pDispNode);
            }
        }

        if ( !_fHasCaptionDispNode 
            && _pDispNode == pDispNodeElement)
        {
            _pDispNode = pDispNode;
        }

        hr = S_FALSE;
    }

    return hr;

Error:
    if (pDispNode)
    {
        pDispNode->Destroy();
    }

    if (pDispNodeElement)
    {
        pDispNodeElement->Destroy();
    }

    _pDispNode = NULL;
    _fHasCaptionDispNode = FALSE;
    return E_FAIL;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Init
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT
CTableLayoutBlock::Init()
{
    HRESULT hr = super::Init();

    // Tables are breakable if their markup's master is a layoutrect
    SetElementAsBreakable();

    return hr;
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::CalcSize 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
DWORD 
CTableLayoutBlock::CalcSizeVirtual(CCalcInfo * pci, SIZE * psize, SIZE * psizeDefault)
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->CalcSizeVirtual(pci, psize, psizeDefault);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Draw 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
void 
CTableLayoutBlock::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    Assert(Table()->HasLayoutAry());
    Table()->TableLayoutCache()->Draw(pDI, pDispNode);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Notify 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
void 
CTableLayoutBlock::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    CTableLayout * pTableLayoutCache = Table()->TableLayoutCache();

    Assert(Table()->HasLayoutAry() == (this != (CTableLayoutBlock *)pTableLayoutCache));

    BOOL fCanRecalc = pTableLayoutCache->CanRecalc();
    BOOL fHandle = TRUE;

    //
    //  Respond to the notification if:
    //      a) The table is not sizing (if sizing ignore the notification),
    //      b) The notification is not handled yet (ignore if it is already handled),
    //      c) The table is capable of recalcing.
    //

    if (pnf->IsTextChange() && !pnf->IsFlagSet(NFLAGS_PARSER_TEXTCHANGE))
    {
        pTableLayoutCache->_fDontSaveHistory = TRUE;
        Table()->ClearHistory();                // don't use history

        // commented the code below since it will happened during hadnling the Text Changes bellow
        //if (_fUsingHistory)                   // if we are already using History
        //{
        //    Assert (CanRecalc());
        //    pTableLayout->Resize();           // then, ensure full resize
        //}
    }

    if (   !fCanRecalc
        && !pnf->IsHandled()
        && IsPositionNotification(pnf)
        && !ElementOwner()->IsZParent())
    {
        fHandle = FALSE;
    }

    if (    fCanRecalc
        &&  !pnf->IsHandled()
        &&  (   !TestLock(CElement::ELEMENTLOCK_SIZING)
            ||  IsPositionNotification(pnf)))
    {
        //
        //  First, handle z-change and position change notifications
        //

        if (IsPositionNotification(pnf))
        {
            fHandle = HandlePositionNotification(pnf);
        }

        //
        //  Next, handle resize requests
        //

        else if (pnf->IsType(NTYPE_ELEMENT_RESIZE))
        {
            Assert(pnf->Element() != ElementOwner() || LayoutContext());

            //  In print view there are several layout blocks existing for the element. 
            //  Notification is distributed to every block. Due to specific of NTYPE_ELEMENT_RESIZE
            //  (changing of pnf->_pElement) we may want to proceed it only once
            if (pnf->Element() != ElementOwner())
            {

                //
                //  Always "dirty" the layout associated with the element
                //

                pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                //
                //  Handle absolute elements by noting that one is dirty
                //

                if (pnf->Element()->IsAbsolute())
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Request: Queuing RF_MEASURE on ly=0x%x [e=0x%x,%S sn=%d] by CTableLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    QueueRequest(CRequest::RF_MEASURE, pnf->Element());

                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CTableLayout::Notify() [n=%S srcelem=0x%x,%S] [abs desc need sizing]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                }

                //
                //  Handle non-absolute elements by
                //      a) Marking the table dirty
                //      b) Resizing the table
                //

                else
                {
                    Assert(pnf->IsType(NTYPE_ELEMENT_RESIZE));
                    Assert(pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));

                    if (    pTableLayoutCache->IsFullyCalced() 
                        || (pTableLayoutCache->IsRepeating() && !pTableLayoutCache->IsFixed() && !pTableLayoutCache->IsGenerationInProgress()) )
                    {
                        pTableLayoutCache->ResetMinMax();
                    }

                    // any (non-databound) changes to a databound table while
                    // generation is in progress should turn off incremental recalc
                    if (pTableLayoutCache->IsRepeating() && 
                        // TODO (112595) :  There is a dozen places all other in Trident where check 
                        // for element / layout type is done through call to Tag() and comparing to 
                        // ETAG_TD / ETAG_TH. This is a potential source of bugs since sometimes only 
                        // one condition is compared. Switching to IsTableCell should be placed in such cases. 
                        (pnf->Element()->Tag() == ETAG_TD || pnf->Element()->Tag() == ETAG_TH) &&
                        DYNCAST(CTableCell, pnf->Element())->Row()->_iRow < 
                            pTableLayoutCache->_iLastRowIncremental )
                    {
                        pTableLayoutCache->_fDirtyBeforeLastRowIncremental = TRUE;
                    }

                    fHandle = FALSE;        // stealing notification
                    pnf->SetElement(ElementOwner()); // parent of the table will handle the request
                }
            }
            else 
            {
                fHandle = FALSE;        // stealing notification
            }
        }

        //
        //  If remeasuring or a descendent is changing their min/max,
        //  resize the table and clear its min/max
        //

        else if (   pnf->IsType(NTYPE_ELEMENT_REMEASURE) 
                ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)   //  <- bug # 107654 
                ||  pnf->IsType(NTYPE_ELEMENT_MINMAX)   )
        {
            Assert(     pnf->Element() == ElementOwner()
                    ||  pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));    // Necessary to allow ChangeTo below

            pTableLayoutCache->ResetMinMax();

            //
            //  Mark forced layout if requested
            //

            // Remember REMEASUREALLCONTENTS implies FORCE.  Bug #89131,
            // table sections don't morph remeasure notifies.
            if (pnf->LayoutFlags() & LAYOUT_FORCE)
            {
                // In PPV this is the only chance to make layout blocks dirty
                //_fForceLayout = TRUE;
                ElementOwner()->DirtyLayout(pnf->LayoutFlags());
            }

            fHandle = FALSE;
            pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
        }

        //
        //  Interpret "text" changes immediately beneath the table as invalidating
        //  the row/cells collection(s)
        //

        else if (pnf->IsTextChange() && pTableLayoutCache->IsCompleted())
        {
            if (pTableLayoutCache->IsRepeating())
            {
                if (pTableLayoutCache->_nDirtyRows && pTableLayoutCache->_cDirtyRows >= pTableLayoutCache->_nDirtyRows)  // we are in chanking mode
                {
                    if (pTableLayoutCache->_nDirtyRows < 100)
                        pTableLayoutCache->_nDirtyRows += 10;  // increment chunk size for resize
                    pTableLayoutCache->_cDirtyRows = 0;        // reset the dirty row counter for future chunk of rows resize
                    pTableLayoutCache->_fDirty     = TRUE;
                    pTableLayoutCache->Resize();
                }
            }
            else
            {
                Assert(pnf->Element() != ElementOwner());
                if (!pTableLayoutCache->_fTableOM)
                {
                    pTableLayoutCache->MarkTableLayoutCacheDirty();
                    pTableLayoutCache->Resize();
                }
            }
        }

        //
        //  Handle translated ranges
        //

        else if (pnf->IsType(NTYPE_TRANSLATED_RANGE))
        {
            Assert(pnf->IsDataValid());
            HandleTranslatedRange(pnf->DataAsSize());
        }

        //
        //  Handle changes to CSS display and visibility
        //

        else if (   pnf->IsType(NTYPE_DISPLAY_CHANGE)
                ||  pnf->IsType(NTYPE_VISIBILITY_CHANGE))
        {
            HandleVisibleChange(pnf->IsType(NTYPE_VISIBILITY_CHANGE));
        }
        else if ( pnf->IsType(NTYPE_ZERO_GRAY_CHANGE ))
        {
            HandleZeroGrayChange( pnf );
        }

        //
        //  Handle z-parent changes
        //

        else if (pnf->IsType(NTYPE_ZPARENT_CHANGE))
        {
            if (!ElementOwner()->IsPositionStatic())
            {
                ElementOwner()->ZChangeElement();
            }

            else if (_fContainsRelative)
            {
                ZChangeRelDispNodes();
            }
        }

        //
        //  Insert adornments as needed
        //

        else if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
        {
            fHandle = HandleAddAdornerNotification(pnf);
        }

        //
        //  Handle invalidations
        //

        else if (IsInvalidationNotification(pnf))
        {
            //
            // Invalidations of table parent elements
            //

            if (    ElementOwner() == pnf->Element() 
                ||  pnf->IsFlagSet(NFLAGS_DESCENDENTS)  )
            {
                Invalidate();
            }

            //
            // Invalidations of table child elements
            //

            else if (pnf->Element())
            {
                RECT rcBound = g_Zero.rc;
                CDataAry<RECT> aryRects(Mt(CTableLayout_Notify_aryRects_pv));

                RegionFromElement(pnf->Element(), &aryRects, &rcBound, 0);

                if (!IsRectEmpty(&rcBound))
                {
                    Invalidate(&rcBound);
                }
            }
        }
    }

#ifndef NO_DATABINDING
    if (pTableLayoutCache->_pDetailGenerator)
    {
        if (pnf->IsType(NTYPE_STOP_1) ||
            pnf->IsType(NTYPE_MARKUP_UNLOAD_1))
        {
            pnf->SetSecondChanceRequested();
        }
        else if (pnf->IsType(NTYPE_STOP_2) ||
                 pnf->IsType(NTYPE_MARKUP_UNLOAD_2))
        {
            pTableLayoutCache->_pDetailGenerator->StopGeneration();
        }
    }
#endif

    if (pnf->IsType(NTYPE_ELEMENT_ENSURERECALC))
    {

        //if the notification is for this element, just pass it to parent so it will 
        // calc us if we got in its background recalc/dirty range.
        if (pnf->Element() == ElementOwner())
        {
            fHandle = FALSE;
        }

        //
        //  Otherwise, request the parent layout to measure up through this element
        //  In other words, fire NTYPE_ELEMENT_ENSURERECALC from this element - it will 
        // first come to us (see line above), then to parent and parent will hopefully continue 
        // until all is recalced up the tree. Then we return from 
        // SendNotification(NTYPE_ELEMENT_ENSURERECALC) and process requests (if any) for 
        // the element we've got this notification in the first place.
        //
        else
        {
            CView * pView = Doc()->GetView();

            if(pView->IsActive() && fCanRecalc)
            {
                CView::CEnsureDisplayTree   edt(pView);

                ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);

                if (!pTableLayoutCache->IsFullyCalced())
                {
                    ProcessRequest(pnf->Element());
                }
            }
        }
    }

    //
    //  Handle the notification (unless its been changed)
    //

    if (fHandle && pnf->IsFlagSet(NFLAGS_ANCESTORS))
    {
        pnf->SetHandler(ElementOwner());
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::IsDirty 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
BOOL
CTableLayoutBlock::IsDirty()
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->IsDirty();
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::OnFormatsChange 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT 
CTableLayoutBlock::OnFormatsChange(DWORD dwFlags)
{
    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->OnFormatsChange(dwFlags);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::GetClientPainterInfo
//
// Synopsis:     
//
//+---------------------------------------------------------------------
DWORD 
CTableLayoutBlock::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if (GetTableOuterDispNode() != pDispNodeFor) 
    {                                            // if draw request is for dispNode other then 
        return 0;                                // primary then no drawing at all the dispNode
    }

    Assert(Table()->HasLayoutAry());
    return Table()->TableLayoutCache()->GetPeerPainterInfo(pAryClientInfo);
}

//+---------------------------------------------------------------------
//
// CTableLayout implementation
//
//+---------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::constructor
//
//-------------------------------------------------------------------------

CTableLayout::CTableLayout(CElement * pElement, CLayoutContext *pLayoutContext)
    : CTableLayoutBlock(pElement, pLayoutContext),
        _aryRows(Mt(CTableLayout_aryRows_pv)),
        _aryBodys(Mt(CTableLayout_aryBodys_pv)),
        _aryCols(Mt(CTableLayout_aryCols_pv)),
        _aryColGroups(Mt(CTableLayout_aryColGroups_pv)),
        _aryColCalcs(Mt(CTableLayout_aryColCalcs_pv)),
        _aryCaptions(Mt(CTableLayout_aryCaptions_pv))
{
    // no Init(); function

    _fDirty         = TRUE;
    _fAllRowsSameShape = TRUE;
    _sizeMin.cx     = -1;
    _sizeMax.cx     = -1;
    _cNestedLevel   = -1;
    _iInsertRowAt   = -1;
    _cyHeaderHeight = -1;
    _cyFooterHeight = -1;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::destructor
//
//  Note:       The borderinfo cache must be deleted in the destructor
//
//-------------------------------------------------------------------------

CTableLayout::~CTableLayout()
{
    if (_pBorderInfoCellDefault)
        delete _pBorderInfoCellDefault;

    ClearRowSpanVector();

    if (_pAbsolutePositionCells)
    {
        int i;

        for (i = _pAbsolutePositionCells->Size()-1; i>=0; i--)
        {
            _pAbsolutePositionCells->Item(i)->SubRelease();
        }

        _pAbsolutePositionCells->SetSize(0);
        delete _pAbsolutePositionCells;
        _pAbsolutePositionCells = NULL;
    }
}


//+---------------------------------------------------------------
//
//  Member:     CTableLayout::Detach
//
//  Synopsis:   Disconnects everything
//
//  Notes:      Call this method before releasing the site.  As a container
//              site we are expected to release all contained sites.
//
//---------------------------------------------------------------

void
CTableLayout::Detach()
{
#ifndef NO_DATABINDING
    // note the order of the detachment is important,
    // we need to detach the detail generator before we touch the aryBodys.
    if (_pDetailGenerator)
    {
        _pDetailGenerator->Detach();
        delete _pDetailGenerator;
        _pDetailGenerator = NULL;
    }
#endif

    ClearTopTableLayoutCache();

    // We just wiped out our table layout cache.  Mark it dirty in case
    // UNDO resurrects the table.
    MarkTableLayoutCacheDirty();

    DestroyFlowDispNodes();

    super::Detach();
}


//+----------------------------------------------------------------------------
//
// Member:   CTableLayout::VoidCachedFormats
//
// Synopsis: Clear all the format cache information in colgroups, tbodys, cols
//           and any header and footer.
//
//-----------------------------------------------------------------------------

void
CTableLayout::VoidCachedFormats()
{
    CTableCol     **ppCol;
    CTableCol     **ppColGroup;
    int             iCol;
    int             iColGroup;

    // NOTE: clear cached format on rows/cells/sections is done by ClearRunChaches.
    //       but we need to do it for Cols and ColGroups since you can not get to
    //       them from the runs.

    // clear cached format info for table cols collection
    for (ppCol = _aryCols, iCol = _aryCols.Size();
         iCol > 0;
         iCol--, ppCol++)
    {
        if (   *ppCol 
            && (*ppCol)->GetFirstBranch())
        {
            (*ppCol)->GetFirstBranch()->VoidCachedInfo();
        }
    }

    // clear cached format info for table colGroups collection
    for (ppColGroup = _aryColGroups, iColGroup = _aryColGroups.Size();
         iColGroup > 0;
         iColGroup--, ppColGroup++)
    {
        if (   *ppColGroup
            && (*ppColGroup)->GetFirstBranch())
        {
            (*ppColGroup)->GetFirstBranch()->VoidCachedInfo();
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CreateTableLayoutCache
//
//  Synopsis:   Walks a table, restoring the table layout cache.
//
//+----------------------------------------------------------------------------

static ELEMENT_TAG   atagSkip[] = { ETAG_TD, ETAG_TH, ETAG_CAPTION, ETAG_TC, ETAG_TABLE };
static ELEMENT_TAG   atagChildren[] = { ETAG_TD, ETAG_TH, ETAG_CAPTION, ETAG_TC, ETAG_TR, ETAG_TBODY, ETAG_THEAD, ETAG_TFOOT, ETAG_COL, ETAG_COLGROUP };

HRESULT
CTableLayout::CreateTableLayoutCache()
{
    HRESULT         hr = S_OK;
    CTreeNode *     pNode = NULL;
    CTable *        pTable = Table();
    CChildIterator  iter(pTable, NULL, CHILDITERATOR_USETAGS, atagSkip, ARRAY_SIZE(atagSkip), atagChildren, ARRAY_SIZE(atagChildren));
    CTableRow     * pRow = NULL;
    CTableSection * pSection = NULL;
    CTableCol     * pColGroup = NULL;
    CTableCell    * pCell = NULL;
    CElement      * pElementScope;
    ELEMENT_TAG     etag;
    BOOL            fFirstRow = TRUE;

    FlushGrid();

    MtAdd(Mt(CreateTableLayoutCache), +1, 0);

    _fEnsuringTableLayoutCache = TRUE;
    _fAllRowsSameShape = TRUE;
    _cRowsParsed = 0;

#if NEED_A_SOURCE_ORDER_ITERATOR
    _iHeadRowSourceIndex = 0;
    _iFootRowSourceIndex = 0;
#endif

    for (pNode = iter.NextChild();
         pNode;
         pNode = iter.NextChild())
    {
        pElementScope = pNode->Element();

        // do not include elements that are exiting tree 
        if (pElementScope->_fExittreePending) 
            continue;

        etag = pElementScope->Tag();

        switch ( etag )
        {
        case ETAG_TBODY :
        case ETAG_TFOOT :
        case ETAG_THEAD :

            pSection = DYNCAST( CTableSection, pElementScope );
            hr = THR( AddSection( pSection ) );
            if (hr)
                goto Cleanup;

            break;

        case ETAG_TR:

            if (pSection)
            {
                pRow = DYNCAST( CTableRow, pElementScope );
                if (pSection == pRow->Section())
                {

                    if (!fFirstRow && _fAllRowsSameShape && _cCols != _cTotalColSpan)
                    {
                        _fAllRowsSameShape = FALSE;
                    }
                    fFirstRow = FALSE;

                    _cRowsParsed++;
                    hr = THR( AddRow( pRow ) );
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    pRow = NULL;    // blocking cells from coming into a table's cache
                }
            }
            else
            {
                pRow = DYNCAST( CTableRow, pElementScope );
                pRow->_iRow = -1;
                pRow = NULL;        // blocking cells from coming into a table's cache
            }

            break;

        case ETAG_COL :

            if (pColGroup)
            {
                hr = THR( AddCol( DYNCAST( CTableCol, pElementScope ) ) );
                if (hr)
                    goto Cleanup;
            }
            
            break;

        case ETAG_COLGROUP :

            pColGroup = DYNCAST(CTableCol, pElementScope);
            hr = THR( AddColGroup( pColGroup ) );
            if (hr)
                goto Cleanup;

            break;

        case ETAG_TD :
        case ETAG_TH :

            if (pRow)
            {
                pCell = DYNCAST( CTableCell, pElementScope );
                if (pRow == pCell->Row())
                {
                    hr = THR( pRow->RowLayoutCache()->AddCell(pCell) );
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    pRow = NULL;
                }
            }

            break;

        case ETAG_CAPTION :
        case ETAG_TC :
            {
                CTableCaption * pCaption = DYNCAST( CTableCaption, pElementScope );

                pCaption->_uLocation = pCaption->IsCaptionOnBottom()
                                       ? CTableCaption::CAPTION_BOTTOM
                                       : CTableCaption::CAPTION_TOP;

                hr = THR( AddCaption( pCaption ) );
                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    EnsureColsFormatCacheChange();

    hr = EnsureCells();

Cleanup:
    _fEnsuringTableLayoutCache = FALSE;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddRow
//
//  Synopsis:   Add a row to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddRow(CTableRow * pRow, BOOL fNewRow)
{
    Assert(pRow);

    CTableRowLayout *   pRowLayout = pRow->RowLayoutCache();
    int                 iSection;
    int                 iRow;
    CTableSection *     pSection;
    CTableSection **    ppSection;
    HRESULT             hr = S_OK;

    pSection = pRow->Section();
    Assert(pSection);

    // insert the row at the end of the section
    if (!_fTableOM)
    {
        iRow = pRow->_iRow = pSection->_iRow + pSection->_cRows;
    }
    else
    {
        iRow = pRow->_iRow = _iInsertRowAt;
        Assert (iRow >= pSection->_iRow && iRow <= pSection->_iRow + pSection->_cRows);
    }

    hr = AddRowElement(iRow, pRow);
    if (hr)
        goto Cleanup;

    if (IsRepeating() && iRow < _iLastRowIncremental) 
    {
        _fDirtyBeforeLastRowIncremental = TRUE;
    }

    // Need to clear the array of cells because in the new lazy table
    // layout cache (TLC), we always have to create the caches down to
    // the table cell level since we don't know anymore what caused the
    // TLC to be invalid (e.g. TOM, DB, ...).
    if (_fTLCDirty)
    {
        pRowLayout->ClearRowLayoutCache();
    }

    if (!fNewRow)
    {
        EnsureCols(pRowLayout->_aryCells.Size());
    }

    // Ensure the cells in the row according to the number of columns
    hr = pRowLayout->EnsureCells(GetCols());
    if (hr)
        goto Cleanup;

    pSection->_cRows++;

    if (fNewRow)
    {
        // copy the row-spanned cells down from previous rows...
        if (iRow > pSection->_iRow && _cCurrentRowSpans)
        {
            int         iCol;
            CTableCell *pRowSpannedCell = NULL;
            int         cColSpan = 0;

            Assert (_paryCurrentRowSpans && _paryCurrentRowSpans->Size());

            pRow->_fCrossingRowSpan = TRUE;

            for (iCol = 0; _cCurrentRowSpans && iCol < _paryCurrentRowSpans->Size(); iCol++)
            {
                int iRemainingRowsSpan = (*_paryCurrentRowSpans)[iCol];
                if (iRemainingRowsSpan > 0)
                {
                    if ( (--(*_paryCurrentRowSpans)[iCol]) == 0 )
                    {
                        // row spaned cells ends in this row
                        Assert (_cCurrentRowSpans > 0);
                        _cCurrentRowSpans--;
                    }   // else: row spanned cells crossing this row
                    pRowSpannedCell = Cell(_aryRows[iRow - 1]->RowLayoutCache()->_aryCells[iCol]);
                    cColSpan = pRowSpannedCell->ColSpan();
                    for (int i = 0; i < cColSpan; i++)
                    {
                        pRowLayout->SetCell(i+iCol, MarkSpanned(pRowSpannedCell));
                    }
                }
            }
        }

        pRowLayout->_cRealCells = 0;
        pRow->_fHaveRowSpanCells = FALSE;
    }

    // Adjust the row index held by each row in the array following the insertion point
    for (iRow = GetRows()-1; iRow > pRow->_iRow; iRow--)
    {
        GetRow(iRow)->_iRow++;
        Assert(GetRow(iRow)->_iRow == iRow);
    }

    Assert (iRow == pRowLayout->RowPosition()); // sanity check

    // If the row is for a THEAD and the TFOOT is already present, advance the TFOOT row
    // (THEADs never need advancing since their rows are always first in the row array)
    if (_pFoot                   &&
        !pSection->_fBodySection &&
        pSection->Tag() == ETAG_THEAD)
    {
        _pFoot->_iRow++;
        Assert(_pFoot->_iRow < GetRows());
    }

    // Lastly, advance the row indexes of any sections which follow the inserted row
    // (Since TBODYs are inserted in source order, only the insertion of a THEAD or TFOOT
    //  can cause the advancement of the rows owned by a body)
    if (!pSection->_fBodySection || _pSectionInsertBefore)
    {
        Assert (!pSection->_fBodySection || _fPastingRows);
        Assert(iRow == pRowLayout->RowPosition());
        for (ppSection = _aryBodys, iSection = _aryBodys.Size();
             iSection > 0;
             iSection--, ppSection++)
        {
            if((*ppSection)->_iRow >= iRow && (*ppSection) != pSection)
            {
                (*ppSection)->_iRow++;
                Assert((*ppSection)->_iRow + (*ppSection)->_cRows <= GetRows());
            }
        }
    }

    _cTotalColSpan = 0;       // set it up for the this row

    ConsiderResizingFixedTable(pRow);

Cleanup:
    RRETURN(hr);
}


// Helper function called on exit tree for row
void
CTableLayout::RowExitTree(int iRow, CTableSection *pCurSection)
{
    CTableRow       *pRow;
    CTableSection   *pSection;
    int              i, cRows;

    if (!pCurSection || !(pCurSection->_cRows > 0 && iRow >= pCurSection->_iRow && iRow < pCurSection->_iRow + pCurSection->_cRows))
        return;

    if (_aryRows.Size() <= iRow)
    {
        Assert (iRow==0 || !IsTableLayoutCacheCurrent());
        return;
    }

    // 1. delete row from the cache
    DeleteRowElement(iRow);

    // 2. update counter of rows in the current section
    pCurSection->_cRows--;

    // 3. adjust row index for the following rows
    cRows = _aryRows.Size();
    for (i = iRow; i < cRows; i++)
    {
        pRow = _aryRows[i];
        pRow->_iRow = i;          // adjust row index
        pSection = pRow->Section();
        if (pSection != pCurSection && pSection->_cRows)
        {
            // 4. adjust row index for the following sections
            Assert (pSection->_iRow >= iRow);
            pSection->_iRow--;
            pCurSection = pSection;
        }
    }
}

MtDefine( FixedResize, LayoutMetrics, "ResizeElement in ConsiderResizingFixedTable" );

void
CTableLayout::ConsiderResizingFixedTable(CTableRow * pRow)
{
    CheckSz(    !ElementOwner()->GetFirstBranch()->GetFancyFormat()->_bTableLayout 
            ||  IsFixed(), 
            "CTableLayout::ConsiderResizingFixedTable : CFancyFormat::TableLayoutFixed != CTableLayout::TableLayoutFixed");

    // Let fixed-sized tables know if a new row arrived.
    if (!_fCompleted            &&  // if we have not completed the parsing of the table ,
        IsFixedBehaviour()      &&  // and the table-layout is fixed (or has a history)
        !Table()->IsDatabound())    // and we are not a databound table,
    {
        // Issue an incremental recalc/rendering request.
        const int iGoodNumberOfRows4IncRecalc = 10;
        DWORD dwCurrentTime = GetTickCount();

        Assert (pRow);
        CTableSection * pSection = pRow->Section();

        // and we are not parsing header/footer, then
        if (!pSection || pSection == _pFoot)
            return;

        Assert(_cRowsParsed > _cCalcedRows);

        // Fire an incremental resize in an interval of numberofResizes*1 sec (1000 ticks) and not less then for 10 new rows.
        if (_cRowsParsed - _cCalcedRows > iGoodNumberOfRows4IncRecalc &&
           (dwCurrentTime - _dwTimeEndLastRecalc >_dwTimeBetweenRecalc))
        {
#if DBG==1
            _pDocDbg->_fUsingTableIncRecalc = TRUE;
#endif 
            _fIncrementalRecalc = TRUE;
            ElementOwner()->ResizeElement();
            MtAdd(Mt(FixedResize), 1, 0);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearTopTableLayoutCache
//
//  Synopsis:   Clears the table layout cache (TLC).
//              Does NOT Drill down to table row layout cache (TRLC).
//
//----------------------------------------------------------------------------
void
CTableLayout::ClearTopTableLayoutCache()
{
    ClearAllRowElements();         // row elements array
    ClearAllColGroups();           // col groups array
    _aryBodys.DeleteAll();
    ClearAllCaptions();            // captions array

    _pHead = NULL;
    _pFoot = NULL;


    Assert (!_aryRows.Size());
    Assert (!_aryCaptions.Size());
    Assert (!_aryBodys.Size());
    Assert (!_pFoot);
    Assert (!_pHead);

    _cCols = 0;                    // max # of cells in a row
    _aryCols.DeleteAll();          // col array
}

//+---------------------------------------------------------------------------
//
//  Member:     ClearTableLayoutCache - formerly ReleaseRowsAndSections
//
//  Synopsis:   Clears the table layout cache (TLC).  Drills down to table
//              row layout cache (TRLC).
//
//----------------------------------------------------------------------------

void
CTableLayout::ClearTableLayoutCache()
{
    BOOL fEnsuringTLC = _fEnsuringTableLayoutCache;
    _fEnsuringTableLayoutCache = TRUE;

    ReleaseRowsAndSections(TRUE, FALSE);    // fReleaseHeaderFooter = TRUE, fReleaseTCs = FALSE

    ClearAllCaptions();

    Assert (!_aryRows.Size());
    Assert (!_aryCaptions.Size());
    Assert (!_aryBodys.Size());
    Assert (!_pFoot);
    Assert (!_pHead);

    _cCols = 0;                     // max # of cells in a row
    _aryCols.DeleteAll();          // col array
    ClearAllColGroups();           // col groups array

    _fEnsuringTableLayoutCache = fEnsuringTLC;

    ClearRowSpanVector();
    if (_pAbsolutePositionCells)
    {
        int i;

        for (i = _pAbsolutePositionCells->Size()-1; i>=0; i--)
        {
            _pAbsolutePositionCells->Item(i)->SubRelease();
        }

        _pAbsolutePositionCells->SetSize(0);
        delete _pAbsolutePositionCells;
        _pAbsolutePositionCells = NULL;
    }
}


void
CTableLayout::ReleaseRowsAndSections(BOOL fReleaseHeaderFooter, BOOL fReleaseTCs)
{
    CTableSection **    ppSection;
    int                 iSection;
    int                 cR;
    CTableRow     **    ppRow;
    int                 iHeadFootRows = fReleaseHeaderFooter? 0 : GetHeadFootRows();
    int                 idx = 0;
    CTableRow      *    pRow;
    BOOL                fParentOfTCs = FALSE;

    // for every row, clear the row's layout caches
    for (cR = GetRows() - iHeadFootRows, ppRow = fReleaseHeaderFooter? _aryRows : &_aryRows[_aryBodys[0]->_iRow];
        cR > 0;
        cR--, ppRow++)
    {
        pRow = *ppRow;
        fParentOfTCs |= fReleaseTCs && pRow->_fParentOfTC;
        CTableRowLayout *pRowLayout = pRow->RowLayoutCache();
        if (pRowLayout)
        {
            pRowLayout->ClearRowLayoutCache();
            pRow->_iRow = -1;
        }
    }

    for (ppSection = _aryBodys, iSection = _aryBodys.Size();
         iSection > 0;
         iSection--, ppSection++)
    {
        (*ppSection)->_iRow = 0;
        (*ppSection)->_cRows = 0;
    }

    if (!iHeadFootRows)
    {
        ClearAllRowElements();
    }
    else
    {
        for (cR = GetRows() - iHeadFootRows, idx = _aryRows.Size() - 1;
            cR > 0;
            cR--, idx--)
        {
            DeleteRowElement(idx);
        }
    }
    if (fReleaseHeaderFooter)
    {
        _pHead = NULL;
        _pFoot = NULL;
    }

    fParentOfTCs |= fReleaseTCs && _fBodyParentOfTC;

    if (fParentOfTCs)
        ReleaseTCs();
    _aryBodys.DeleteAll();

    return;
}

void
CTableLayout::ReleaseBodysAndTheirRows(int iBodyStart, int iBodyFinish)
{
    CTableRow       *pRow;
    CTableRowLayout *pRowLayout;
    CTableSection   *pSection;
    int             iRow, cRows, iBody, cBodys;
    int             nReleasedRows = 0;
    BOOL            fParentOfTCs = FALSE;

    Assert (iBodyFinish >= iBodyStart && iBodyFinish < _aryBodys.Size() && iBodyStart >= 0);

    iRow = _aryBodys[iBodyStart]->_iRow;

    if (IsRepeating() && iRow < _iLastRowIncremental) 
    {
        _fDirtyBeforeLastRowIncremental = TRUE;
    }

    for (cBodys = iBodyFinish - iBodyStart + 1; cBodys; cBodys--)
    {
        pSection = _aryBodys[iBodyStart];
        for (cRows = pSection->_cRows; cRows; cRows--)
        {
            pRow = _aryRows[iRow];
            pRowLayout = pRow->RowLayoutCache();
            pRowLayout->ClearRowLayoutCache();
            pRow->_iRow = 0;
            fParentOfTCs |= pRow->_fParentOfTC;
            DeleteRowElement(iRow);
            nReleasedRows++;
        }
        pSection->_cRows = 0;
        fParentOfTCs |= pSection->_fParentOfTC;
        _aryBodys.Delete(iBodyStart);
    }

    for (iBody = iBodyStart; iBody < _aryBodys.Size(); iBody++)
    {
        pSection = _aryBodys[iBody];
        pSection->_iRow -= nReleasedRows;
        for (iRow = pSection->_iRow, cRows = pSection->_cRows;
             cRows;
             cRows--, iRow++)
        {
            _aryRows[iRow]->_iRow -= nReleasedRows;
        }
    }

    if (fParentOfTCs)
        ReleaseTCs();
}

void
CTableLayout::ReleaseTCs()
{
    int             ic, cC;
    CTableCaption  *pCaption;
    CTableCaption **ppCaption;
    CTreeNode      *pNode;

    for (cC = _aryCaptions.Size(), ic = 0, ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++, ic++)
    {
        pCaption = *ppCaption;
        if (pCaption->Tag() == ETAG_TC)
        {
            pNode = pCaption->GetFirstBranch(); // pNode == 0 means it was already removed from the tree
            if (!pNode)
            {
                DeleteCaption(ic);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     AddCaption
//
//  Synopsis:   Add caption to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddCaption(CTableCaption * pCaption)
{
    HRESULT hr;
    CElement *pParent = NULL;

    Assert(pCaption);

    hr = AppendCaption(pCaption);
    if (!hr)
    {
        if (pCaption->Tag() == ETAG_TC)
        {
            pParent = pCaption->GetFirstBranch()->Parent()->Element();

            while ( pParent )
            {
                switch (pParent->Tag())
                {
                case ETAG_TBODY:
                case ETAG_THEAD:
                case ETAG_TFOOT:
                    DYNCAST(CTableSection, pParent)->_fParentOfTC = TRUE;
                    _fBodyParentOfTC = TRUE;
                    goto Cleanup;
                case ETAG_TR:
                    DYNCAST(CTableRow, pParent)->_fParentOfTC = TRUE;
                    goto Cleanup;
                case ETAG_TABLE:
                    goto Cleanup;
                default:
                    pParent = pParent->GetFirstBranch()->Parent()->Element();
                }
            }

            AssertSz( FALSE, "TCs should always at least be in a TABLE -- should never walk up to a root" );
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddSection
//
//  Synopsis:   Add a section to the table
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::AddSection(CTableSection * pSection)
{
    int     iRow = 0;
    int     iSections = 0;
    HRESULT hr = S_OK;

    Assert(pSection);

    pSection->_fBodySection = TRUE;

    switch(pSection->Tag())
    {
    case ETAG_THEAD:
        if (!_pHead)
        {
            pSection->_fBodySection = FALSE;
            _pHead = pSection;
            iRow = 0;
#if NEED_A_SOURCE_ORDER_ITERATOR
            _iHeadRowSourceIndex = _aryRows.Size();
#endif
        }
        break;

    case ETAG_TFOOT:
        if (!_pFoot)
        {
            pSection->_fBodySection = FALSE;
            _pFoot = pSection;
            iRow = _pHead
                        ? _pHead->_cRows
                        : 0;
#if NEED_A_SOURCE_ORDER_ITERATOR
            _iFootRowSourceIndex = _aryRows.Size();
#endif
        }
        break;

    case ETAG_TBODY:
        break;

    default:
        Assert(FALSE);
    }

    if (pSection->_fBodySection)
    {
        iSections = _aryBodys.Size();
        if (_pSectionInsertBefore)
        {
            Assert (iSections);
            for (int i = 0; i < _aryBodys.Size(); i++)
            {
                if (_aryBodys[i] == _pSectionInsertBefore)
                {
                    hr = _aryBodys.Insert(i, pSection);
                    iRow = _pSectionInsertBefore->_iRow;
                    break;
                }
            }
        }
        else
        {
            hr = _aryBodys.Append(pSection);
            iRow = GetRows();
        }
        if (hr)
            goto Cleanup;

        iSections++;

        Assert (iSections == _aryBodys.Size());
    }

    pSection->_iRow = iRow;
    pSection->_cRows = 0;   // have to do it, since it is called on old rows as well

    // nuke the row span vector for the new section
    ClearRowSpanVector();

Cleanup:

    RRETURN(hr);
}


void
CTableLayout::BodyExitTree(CTableSection *pSection)
{
    if (pSection == _pHead)
    {
        _pHead = NULL;
    }
    else if (pSection == _pFoot)
    {
        _pFoot = NULL;
    }
    else
    {
        for (int i = 0; i < _aryBodys.Size(); i++)
        {
            if (_aryBodys[i] == pSection)
            {
                _aryBodys.Delete(i);
                break;
            }
        }
    }
    return;
}

#if NEED_A_SOURCE_ORDER_ITERATOR
CTableRow *
CTableLayout::GetRowInSourceOrder(int iS)
{
    int  iRow = iS;
    BOOL fHaveTHead = _pHead && _pHead->_cRows;
    BOOL fHaveTFoot = _pFoot && _pFoot->_cRows;

    // Optimization.
    if (!fHaveTHead && !fHaveTFoot)
        goto Cleanup;

    // Case 1: row is in header
    if (fHaveTHead && iS >= _iHeadRowSourceIndex && iS < _iHeadRowSourceIndex + _pHead->_cRows)
    {
        iRow = iS - _iHeadRowSourceIndex;
        goto Cleanup;
    }

    // Case 2: row is in footer
    if (fHaveTFoot && iS >= _iFootRowSourceIndex && iS < _iFootRowSourceIndex + _pFoot->_cRows)
    {
        iRow = iS - _iFootRowSourceIndex + (fHaveTHead?_pHead->_cRows:0);
        goto Cleanup;
    }

    // Case 3: row is in front of header
    if (fHaveTHead && iS < _iHeadRowSourceIndex)
    {
        iRow += _pHead->_cRows;
    }

    // Case 4: row is in front of footer
    if (fHaveTFoot && iS < _iFootRowSourceIndex)
    {
        iRow += _pFoot->_cRows;
    }

Cleanup:
    return _aryRows[iRow];
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     AddColGroup
//
//  Synopsis:   Add a column group to the table
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::AddColGroup(CTableCol * pColGroup)
{
    HRESULT hr;
    int cColSpan;
    int iAt;

    Assert(pColGroup->GetFirstBranch()->Ancestor(ETAG_TABLE)->Element() == Table());

    cColSpan = pColGroup->Cols();

    Assert(cColSpan >= 0);

    iAt = _aryColGroups.Size();

    hr = _aryCols.EnsureSize(iAt);
    if (hr)
        goto Cleanup;

    hr = _aryColGroups.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    pColGroup->_iCol = iAt;
    pColGroup->_cCols = cColSpan;

    while (_aryCols.Size() < iAt)
    {
        _aryCols.Append(NULL);
    }
    EnsureCols(_aryCols.Size());

    while(_aryColGroups.Size() < iAt + cColSpan)
    {
        if (S_OK == _aryColGroups.Append(pColGroup))
            pColGroup->SubAddRef();
    }

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddCol
//
//  Synopsis:   Add a column group to the table
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::AddCol(CTableCol * pCol)
{
    HRESULT hr = S_OK;
    CTableCol * pColGroup;
    int cColSpan;
    int iAt;

    Assert(pCol->GetFirstBranch()->Ancestor(ETAG_TABLE)->Element() == Table());

    Verify(pColGroup = pCol->ColGroup());
    
    if (!pColGroup)
    {
        pCol->_iCol = -1;
        pCol->_cCols = 0;
        goto Cleanup;
    }

    cColSpan = pCol->Cols();

    Assert(cColSpan >= 0);

    iAt = _aryCols.Size();
    Assert(_aryColGroups.Size() >= iAt);
    Assert(_aryColGroups.Size() <= iAt || _aryColGroups[iAt] == pColGroup);

    // HTML 3 Table Model: if COLGROUP contains one or more COLS the span attribute of the COLGROUP is ignored
    if (iAt == pColGroup->_iCol && pColGroup->_cCols == pColGroup->Cols())
    {
        pColGroup->_cCols = 0;  // ignore SPAN for colGroup
    }

    hr = _aryCols.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    hr = _aryColGroups.EnsureSize(iAt + cColSpan);
    if (hr)
        goto Cleanup;

    pCol->_iCol = iAt;
    pCol->_cCols = cColSpan;
    pColGroup->_cCols += cColSpan;

    while (_aryCols.Size() < iAt + cColSpan)
    {
        _aryCols.Append(pCol);
    }
    EnsureCols(_aryCols.Size());

    // Per ftp://ds.internic.net/rfc/rfc1942.txt:
    // If COLGROUPS contains COLs, ignore SPAN of COLGROUP.
    while (_aryColGroups.Size() > iAt + cColSpan)
    {
        _aryColGroups[_aryColGroups.Size()-1]->SubRelease();
        _aryColGroups.Delete(_aryColGroups.Size()-1);
    }

    while(_aryColGroups.Size() < iAt + cColSpan)
    {
        if (S_OK ==_aryColGroups.Append(pColGroup))
            pColGroup->SubAddRef();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCols
//
//  Synopsis:   Take note of no. of cols in a row
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureCols(int cCols)
{
    if (_cCols < cCols)
        _cCols = cCols;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     EnsureCells
//
//  Synopsis:   Make sure that there are at least cCols cells in the
//              table in every row
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureCells()
{
    HRESULT hr = S_OK;
    CTableRow ** ppRow;
    CTableRow * pRow;
    int cCols;
    int cR;

    Assert(IsTableLayoutCacheCurrent());

    cCols = GetCols();

    // make sure rows have enough cells...
    for (cR = GetRows(), ppRow = _aryRows;
        cR > 0;
        cR--, ppRow++)
    {
        pRow = *ppRow;

        if (pRow->RowLayoutCache()->GetCells() < cCols)
        {
            hr = pRow->RowLayoutCache()->EnsureCells(cCols);
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     CheckTable
//
//  Synopsis:   Checks table state
//
//-----------------------------------------------------------------------------
#if DBG == 1
void CTableLayout::CheckTable()
{
    CTableRow * pRow;
    CTableRowLayout * pRowLayout;
    CTableSection * pSection;
    CTableCell * pCell;
    int i, j;
    int c;

    Assert(IsTableLayoutCacheCurrent());

    for (i = 0; i < _aryRows.Size(); i++)
    {
        pRow = _aryRows[i];
        pRowLayout = pRow->RowLayoutCache();

        Assert(pRowLayout->RowPosition() == i);
        pSection = pRow->Section();
        Assert(pSection->_cGeneratedRows ||
               (i >= pSection->_iRow && i < pSection->_iRow + pSection->_cRows));
        for (j = 0; j < pRowLayout->_aryCells.Size(); j++)
        {
            pCell = pRowLayout->_aryCells[j];
            if (!IsEmpty(pCell))
            {
                if (IsReal(pCell))
                {
                    pCell = Cell(pCell);
                    Assert(pCell->RowIndex() == i);
                    Assert(pCell->ColIndex() == j);
                    Assert(pCell->Row() == pRow);
                }
                else
                {
                    pCell = Cell(pCell);
                    Assert(i < pCell->RowIndex() + pCell->RowSpan());
                    Assert(j < pCell->ColIndex() + pCell->ColSpan());
                    Assert(pCell->Row()->_iRow < pCell->RowIndex() + pCell->RowSpan());
                    Assert(pCell->Layout()->Col()->_iCol < pCell->ColIndex() + pCell->ColSpan());
                }
            }
        }
    }
    c = 0;
    if (_pHead)
    {
        Assert(_pHead->_iRow == c);
        c += _pHead->_cRows;
    }
    if (_pFoot && (!_aryBodys.Size() || _pFoot->_iRow <= _aryBodys[0]->_iRow))
    {
        Assert(_pFoot->_iRow == c);
        c += _pFoot->_cRows;
    }
    for (i = 0; i < _aryBodys.Size(); i++)
    {
        pSection = _aryBodys[i];
#ifndef NO_DATABINDING
        if (!IsRepeating())
#endif
        {
            // the following assert checks if the section starts with the
            // correct _iRow or it could of being an empty TBODY section that
            // appeared before the THEAD section.
            Assert(pSection->_iRow == c || !pSection->_cRows);
            c += pSection->_cRows;
        }
#ifndef NO_DATABINDING
        else
        {
            c+= pSection->_cGeneratedRows;
        }
#endif
    }
    if (_pFoot && (_aryBodys.Size() && _pFoot->_iRow > _aryBodys[0]->_iRow))
    {
        Assert(_pFoot->_iRow == c);
        c += _pFoot->_cRows;
    }
    Assert(c == _aryRows.Size());  // for now until Caption added
}


static TCHAR g_achTabs[] = _T("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
#define PRINTLN(f) WriteHelp(pF, _T("<0s>")_T(##f)_T("\n"), &g_achTabs[ARRAY_SIZE(g_achTabs) - iTabs]


void
CTableCellLayout::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;
    CUnitValue      uvWidth = GetFirstBranch()->GetCascadedwidth();
    CUnitValue      uvHeight = GetFirstBranch()->GetCascadedheight();

    PRINTLN("\n*** CELL ***\n") );
    psz = TableCell()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = TableCell()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iRow: <1d>"), TableCell()->RowIndex());
    PRINTLN("_iCol: <1d>"), ColIndex());
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());
    PRINTLN("_xMin: <1d>"), _sizeMin.cu);
    PRINTLN("_xMax: <1d>"), _sizeMax.cu);
    PRINTLN("_sizeCell: <1d> <2d>"), _sizeCell.cx, _sizeCell.cy);
    uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableCellwidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
    uvHeight.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableCellheight.a);
    PRINTLN("HEIGHT = <1s>"), achBuf);
}


void
CTableRowLayout::Print(HANDLE pF, int iTabs)
{
    CTableCell **   ppCell;
    const TCHAR *   psz;
    int             cC;

    PRINTLN("\n*** ROW ***\n") );
    psz = TableRow()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = TableRow()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iRow: <1d>"), RowPosition());
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());

    for (cC = _aryCells.Size(), ppCell = _aryCells; cC > 0; cC--, ppCell++)
    {
        if (IsReal(*ppCell))
            Cell(*ppCell)->Layout()->Print(pF, iTabs+1);
    }
}


void
CTableLayout::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;
    CUnitValue      uvWidth = GetFirstBranch()->GetCascadedwidth();
    CUnitValue      uvHeight = GetFirstBranch()->GetCascadedheight();

    Assert(IsTableLayoutCacheCurrent());

    PRINTLN("\n*** TABLE ***\n"));
    psz = Table()->GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = Table()->GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_ptProposed: <1d> <2d>"), GetXProposed(), GetYProposed());
    PRINTLN("_sizeMin: <1d> <2d>"), _sizeMin.cx, _sizeMin.cy);
    PRINTLN("_sizeMax: <1d> <2d>"), _sizeMax.cx, _sizeMax.cy);
    PRINTLN("_sizeParent: <1d> <2d>"), _sizeParent.cx, _sizeParent.cy);

    uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTablewidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
    uvHeight.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableheight.a);
    PRINTLN("HEIGHT = <1s>"), achBuf);

    CTableCol ** ppCol;
    int cC;

    for (cC = _aryCols.Size(), ppCol = _aryCols; cC > 0; cC--, ppCol++)
    {
        (*ppCol)->Print(pF, iTabs+1);
    }

    CTableRow ** ppRow;
    int cR;

    for (cR = _aryRows.Size(), ppRow = _aryRows; cR > 0; cR--, ppRow++)
    {
        (*ppRow)->RowLayoutCache()->Print(pF, iTabs+1);
    }
}

void
CTableLayout::DumpTable(const TCHAR * pch)
{
    HANDLE pF = CreateFile(
            _T("c:\\tt."),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (pF == INVALID_HANDLE_VALUE)
        return;

    SetFilePointer( pF, GetFileSize( pF, 0 ), 0, 0 );

    WriteHelp(pF, _T("\nDumpTable: <0s> -------------------------------------------------------------------")_T("\n"), pch);

    Print(pF, 0);

    CloseHandle(pF);
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CTableLayout::HandleMessage(CMessage * pMessage)
{
    switch(pMessage->message)
    {
    case WM_SYSKEYDOWN:
        if (pMessage->wParam == VK_F12 && !(pMessage->lParam & SYS_PREVKEYSTATE))
        {
            DumpTable(_T("F12"));
            return S_OK;
        }
    }
    return super::HandleMessage(pMessage);
}
#endif // DBG == 1


//+----------------------------------------------------------
//
// Member : GetChildElementTopLeft
//
//  Synopsis : csite virtual override, this returns the top and the left of non-site
//      elements that have the Table as their site parent.
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    HRESULT hr = S_OK;

    Assert(pChild && !pChild->GetUpdatedLayout());

    hr = EnsureTableLayoutCache();
    if (hr)
        RRETURN(hr);

    pt = g_Zero.pt;

    // if we get here, it means that someone wants the
    // top leff of an element of whose parent site is
    // the table, this means THead, TBody,TSection
    switch (pChild->Tag())
    {
    case ETAG_THEAD :
        if (_pHead && _pHead->_cRows && (_pHead->_iRow < _aryRows.Size() ) && _pHead==pChild)
        {
            // the row is a site, so get its unparked position
            hr = THR(_aryRows[ _pHead->_iRow ] ->GetElementTopLeft(pt));
        }
        break;
    case ETAG_TFOOT :
        if (_pFoot && _pFoot->_cRows && (_pFoot->_iRow < _aryRows.Size() ) && _pFoot == pChild)
        {
            // the row is a site, so get its unparked position
            hr = THR(_aryRows[ _pFoot->_iRow ] ->GetElementTopLeft(pt));
        }
        break;

    case ETAG_TBODY :
        {
            CTableSection * pSection;
            long i;

            for (i = 0; i < _aryBodys.Size(); i++)
            {
                pSection = _aryBodys[i];
#ifndef NO_DATABINDING
                if (!IsRepeating())
#endif
                {
                    if (pSection  == pChild && pSection->_cRows)
                    {
                        hr = THR(_aryRows[ pSection->_iRow ] ->GetElementTopLeft(pt));
                        break;
                    }
                }
            }
            break;
        }
    }

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member :    FlushGrid
//
//  Synopsis :  This function should be called when the new
//              row/cell is inserted/deleted or when changing
//              rowSpan/colSpan attributes of the cells.
//
//-------------------------------------------------------------------------

void
CTableLayout::FlushGrid()
{
    BOOL fEnsuringTableLayoutCache = _fEnsuringTableLayoutCache;
    _fEnsuringTableLayoutCache = TRUE;
    _fZeroWidth = FALSE;            // set to 1 if table is empty (0 width).
    _fHavePercentageRow = FALSE;    // one or more rows have heights which are a percent
    _fHavePercentageCol = FALSE;    // one or more cols have widths which are a percent
    _fHavePercentageInset = FALSE;
    _fForceMinMaxOnResize = FALSE;
    _fCols = FALSE;                 // column widths are fixed
    _fAlwaysMinMaxCells = FALSE;    // calculate min/max for all cells
    _fAllRowsSameShape = TRUE;      // assume all the rows have the same shape

    _cSizedCols = 0;                // Number of sized columns

    ResetMinMax();

    // We should clear the TLC, so that we don't burn our fingers on dead cells or rows later.
    ClearTableLayoutCache();

    _aryColCalcs.DeleteAll();       // calculated columns array
    _cDirtyRows = 0;                // how many resize req's I've ignored
    _nDirtyRows = 0;                // how many resize req's to ignore

    _iLastNonVirtualCol = 0;        // last non virtual column in the table
    _cNonVirtualCols = 0;           // number of non virtual columns

    _fUsingHistory = FALSE;
    _fDontSaveHistory = TRUE;

    _fEnsuringTableLayoutCache = fEnsuringTableLayoutCache;
    
    _iLastRowIncremental = 0;       // reset incremental recalc state
    _fDatabindingRecentlyFinished = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member :    Fixup
//
//  Synopsis :  After insert/delete operation we need to fixup table
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::Fixup(BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr      = S_OK;
    CTable *    pTable  = Table();

    // Assert( GetMarkup()->Doc()->IsLoading() );

    if (fIncrementalUpdatePossible)
    {
        ResetMinMax();
        _iCollectionVersion++;                  // this will invalidate table's collections
        MarkTableLayoutCacheCurrent();
    }
    else
    {
        // Make sure we dirty the TLC.
        MarkTableLayoutCacheDirty();

        // Several of the TOM functions (e.g. createTHead) try to use the table
        // layout cache (TLC) immediately after TOM operations, so ensure the TLC.
        hr = EnsureTableLayoutCache();

    }
    pTable->ResizeElement();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetFirstCaption
//
//  Synopsis:   helper function to get the first caption
//
//----------------------------------------------------------------------------

CTableCaption *
CTableLayout::GetFirstCaption()
{
    CTableCaption * pCaption = NULL;
    CTableCaption **ppCaption;
    int             cC;

    Assert(AssertTableLayoutCacheCurrent());

    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++)
    {
        if ((*ppCaption)->Tag() == ETAG_CAPTION)
        {
            pCaption = *ppCaption;
            break;
        }
    }

    return pCaption;
}


// Have to include whether the table has percent sized rows in it, in order
// to determine if it is percent sized.
BOOL CTableLayout::PercentSize()
{
    return (_fHavePercentageRow || super::PercentSize());
}
BOOL CTableLayout::PercentHeight()
{
    return (_fHavePercentageRow || super::PercentHeight());
}


#ifdef NEVER_USED_CODE

//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetCellFromRowCol
//
//  Synopsis:   Returns the cell located at table grid position (iRow,iCol)
//
//  Arguments:  iRow [in]         -- visual row index
//              iCol [in]         -- visual col index
//              ppTableCell [out] -- table cell at (iRow,iCol)
//
//  Returns:    Returns S_OK with pointer to table cell.  The pointer will
//              be NULL when the cell at the specified position doesn't exist
//              or is a non-real cell part of another cell's row- or columnspan.
//
//  Note:       When the CTableSection version is called, the rows and column
//              indices are relative to the section origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::GetCellFromRowCol(int iRow, int iCol, CTableCell **ppTableCell)
{
    CTableRow * pTableRow;
    CTableCell *pTableCell;
    HRESULT     hr = S_OK;

    if (!ppTableCell)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTableCell = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < 0 || iRow >= GetRows() || iCol < 0 || iCol >= GetCols())
        goto Cleanup;

    // Obtain row from iRow.
    iRow = VisualRow2Index(iRow);
    pTableRow = _aryRows[iRow];
    Assert(pTableRow && !"NULL row in legal range");

    // Obtain col from iCol.
    pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];

    if (IsReal(pTableCell))
        *ppTableCell = pTableCell;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetCellsFromRowColRange
//
//  Synopsis:   Returns an array of the cells located in the inclusive range
//              spanned by (iRowTop,iColLeft)-(iRowBottom,iColRight)
//
//  Arguments:  iRowTop    [in]     -- visual top row index
//              iColLeft   [in]     -- visual left col index
//              iRowBottom [in]     -- visual row index
//              iColRight  [in]     -- visual col index
//              paryCells  [in,out] -- array of table cells in range (allocated
//                                     by caller)
//
//  Returns:    Returns S_OK with array of table cells.
//
//  Note:       When the CTableSection version is called, the rows and column
//              indices are relative to the section origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::GetCellsFromRowColRange(int iRowTop, int iColLeft, int iRowBottom, int iColRight, CPtrAry<CTableCell *> *paryCells)
{
    CTableRow *    pTableRow;
    CTableCell *   pTableCell;
    int            cRows, iRow, iCol;
    HRESULT        hr;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iRowTop = max(0, iRowTop);
    iRowBottom = min(GetRows()-1, iRowBottom);
    iColLeft = max(0, iColLeft);
    iColRight = min(GetCols()-1, iColRight);
    cRows = iRowBottom - iRowTop + 1;

    if (!paryCells || cRows <= 0 || iColLeft > iColRight)
    {
        hr = paryCells ? S_OK : E_POINTER;
        goto Cleanup;
    }

    // Loop from top row to bottom row.
    for (iRow = VisualRow2Index(iRowTop) ; cRows ; cRows--, iRow = GetNextRow(iRow))
    {
        pTableRow = _aryRows[iRow];
        Assert(pTableRow && "NULL row in legal range");

        // Loop from left col to right col.
        for (iCol = iColLeft ; iCol <= iColRight ; iCol++)
        {
            pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];
            if (IsReal(pTableCell))
            {
                // Add cell to array.
                paryCells->Append(pTableCell);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}
#endif 

//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Initiate a re-layout of the table
//
//  Arguments:  grfFlags - LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CTableLayoutBlock::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx( (   tagCalcSize, 
                    TAG_NONAME|TAG_INDENT, 
                    "(CTableLayoutBlock::DoLayout L(0x%x, %S) grfLayout(0x%x)", 
                    this, 
                    ElementOwner()->TagName(), 
                    grfLayout ) );

    CTable *pTable = Table();
    CTableLayout *pTableLayoutCache = pTable->TableLayoutCache();

    Assert(pTableLayoutCache);

    // hidden layouts are measured when they are unhidden
    if (pTableLayoutCache->CanRecalc() && !IsDisplayNone())
    {
        CTableCalcInfo  tci(pTable, this);
        CSize           size;

        tci._grfLayout |= grfLayout;

        //  Init available height for PPV 
        if (    tci.GetLayoutContext()
            &&  tci.GetLayoutContext()->ViewChain() 
            &&  ElementCanBeBroken()  )
        {
            CLayoutBreak *pLayoutBreak;
            tci.GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
            Assert(pLayoutBreak);

            if (pLayoutBreak)
            {
                tci._cyAvail = pLayoutBreak->AvailHeight();
            }
        }

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            if (_fForceLayout)
            {
                tci._grfLayout |= LAYOUT_FORCE;
            }

            tci.SizeToParent(&_sizeParent);
            if (!tci._pTableLayout)
                tci._pTableLayout = this;

            CalculateLayout(&tci, &size, FALSE, FALSE);

            pTableLayoutCache->Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&tci, size);
        }

        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }
    else
    {
        pTableLayoutCache->Reset(TRUE);
    }

    TraceTagEx( (   tagCalcSize, 
                    TAG_NONAME|TAG_OUTDENT, 
                    ")CTableLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", 
                    this, 
                    ElementOwner()->TagName(), 
                    grfLayout ));
}

void
CTableLayout::Resize()
{
    CElement *    pElement = ElementOwner();
    CMarkup *     pMarkup = pElement->GetMarkup();

    Assert (pElement);
    if (!pMarkup->_fTemplate)   // don't resize tables that are in the template markup (generated tables for data-binding).
    {
        if (! (IsRepeating() && !_fDatabindingRecentlyFinished && IsGenerationInProgress()) )
        {
            ResetMinMax();
        }       
        // else optimize databinding recalcing of the table during CTableLayout::CalculateLayout
        // ... but first reset incremental recalc members (bug # 105017)
        ResetIncrementalRecalc();
        pElement->ResizeElement();
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::OnFormatsChange
//
//  Synopsis:   Handle formats change notification
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::OnFormatsChange(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    // clear's formats on cols and colspans
    VoidCachedFormats();

    // (bug # 104204) If formats are changed table must do min max pass again
    ResetMinMax();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     EnsureRowSpanVector
//
//  Synopsis:   Make sure there are at least cCells number of slots in the row span vector
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureRowSpanVector(int cCells)
{
    HRESULT hr = S_OK;
    int     c = 0;

    if (!_paryCurrentRowSpans)
    {
        _paryCurrentRowSpans = new(Mt(CTableLayout_paryCurrentRowSpans)) CDataAry<int>(Mt(CTableLayout_paryCurrentRowSpans_pv));
        if (!_paryCurrentRowSpans)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    c = _paryCurrentRowSpans->Size();
    if (c >= cCells)
        goto Cleanup;

    hr = _paryCurrentRowSpans->EnsureSize(cCells);
    if (hr)
        goto Cleanup;

    Assert(c <= cCells);

    _paryCurrentRowSpans->SetSize(cCells);

    while (cCells-- > c)
    {
        (*_paryCurrentRowSpans)[cCells] = 0;    // set the previous cells as not rows spanned (row span == 1)
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     ClearRowSpanVector
//
//  Synopsis:   Delete the row span vector (if any)
//
//----------------------------------------------------------------------------

void
CTableLayout::ClearRowSpanVector()
{
    _cCurrentRowSpans = 0;
    delete _paryCurrentRowSpans;
    _paryCurrentRowSpans = NULL;
}


VOID
CTableLayout::ShowSelected( CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected, BOOL fLayoutCompletelyEnclosed )
{
    CDispNode * pDispNode = GetElementDispNode(ElementOwner());

    // if the table is filtered, we need to invalidate so that the filter
    // will redraw its input with the correct selection feedback (bug 107750)
    if (pDispNode && pDispNode->IsDrawnExternally())
    {
        pDispNode->Invalidate();
    }
}

// just to indicate that user width is specified
// to indicate that it is a 0-width
#define HISTORY_WIDTH_SPECIFIED (101)   
#define HISTORY_ZERO_PERCENT    (102)   
#define HISTORY_SPECIAL_LAST_VALUE (102)
//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::SaveHistoryValue()
//
//  Synopsis:   save history:
//                              - value
//                              - _fTextChanged
//                              - scroll position
//
//-------------------------------------------------------------------------

HRESULT
CTableLayout::SaveHistoryValue(CHistorySaveCtx *phsc)
{
    CDataStream ds;
    HRESULT     hr      = S_OK;
    IStream *   pStream = NULL;
    CStr        cstrVal;
    CTable *    pTable = Table();
    int         iP;
    int         cC, cCols, cColsSave;
    CTableColCalc *pColCalc;

    Assert(phsc);
    if (!phsc)
        goto Cleanup;

    hr = THR(phsc->BeginSaveStream(pTable->GetSourceIndex(), 
                                   pTable->HistoryCode(), 
                                   &pStream));
    if (hr)
        goto Cleanup;

    ds.Init(pStream);

    // save number of columns
    cColsSave = cCols = _aryColCalcs.Size();
    if (_fCols)
    {
        Assert (cCols >= 0);
        cColsSave = 0 - cCols;
    }
    hr = THR(ds.SaveDword(cColsSave));
    if (hr)
        goto Cleanup;

    hr = THR(ds.SaveDword(_cNonVirtualCols));
    if (hr)
        goto Cleanup;

    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        hr = THR(ds.SaveDword(pColCalc->_xMin));
        if (hr)
            goto Cleanup;
        hr = THR(ds.SaveDword(pColCalc->_xMax));
        if (hr)
            goto Cleanup;
        if (pColCalc->_fVirtualSpan)
        {
            pColCalc->_xWidth = - pColCalc->_xWidth;
        }
        hr = THR(ds.SaveDword(pColCalc->_xWidth));
        if (hr)
            goto Cleanup;
        iP = 0;
        if (pColCalc->IsWidthSpecified())
        {
            if (pColCalc->IsWidthSpecifiedInPercent())
            {
                iP = pColCalc->GetPercentWidth();
                Assert (iP <= 100);
                if (iP == 0)
                    iP = HISTORY_ZERO_PERCENT;   // we need to trnaslate this value back as 0%
            }
            else
            {
                iP = HISTORY_WIDTH_SPECIFIED;   // just to indicate that user width is specified
            }
        }
        hr = THR(ds.SaveDword(iP));
        if (hr)
            goto Cleanup;
    }


    hr = THR(phsc->EndSaveStream());
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}


HRESULT
CTableLayout::LoadHistory(IStream *   pStreamHistory, CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    CStr    cstrVal;
    int     cC, cCols;
    int     iP;
    CTableColCalc *pColCalc;

    Assert (pStreamHistory);

    CDataStream ds(pStreamHistory);

    THREADSTATE * pts = GetThreadState();
    CMarkup *pMarkup = ElementOwner()->GetMarkup();

    if (   !pMarkup
        || !pMarkup->_fSafeToUseCalcSizeHistory
        || (pMarkup->GetFontHistoryIndex() != pts->_iFontHistoryVersion))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(ds.LoadDword((DWORD *)&cCols));
    if (hr)
        goto Cleanup;

    _fCols = FALSE;
    if (cCols < 0)
    {   // _fCols flag was saved
        cCols = 0 - cCols;
        _fCols = TRUE;
    }

    if (cCols != GetCols())
    {
        // NOTE (carled): we can't have this assert anymore.  The reason is 
        // simply that we do not yet have a unique-numeric ID for each element
        // (hopefully we'll get this for IE5.X).  This affects history since
        // DHTML pages can cause the historyindex (currently the srcIndex) of a 
        // table to be different at save time than it is at load time, and thus
        // we can potentially get the wrong history stream loaded for this element.
        // this is a generic history bug, but this is the only history assert and 
        // it has been hit on some DHTML pages.  Once we have a unique ID, then we
        // can use that for the historyIdx, and this assert can be re-enabled.
//        Assert (FALSE && "this is a serious history bug");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(ds.LoadDword((DWORD *)&_cNonVirtualCols));
    if (hr)
        goto Cleanup;

    // reset column values
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        // pColCalc->Clear();   // Don't clear it (since we have already Cleared it in CalculateMinMax,
                                // and also have set _fDisplayNone flag on it).
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xMin));
        if (hr)
            goto Cleanup;
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xMax));
        if (hr)
            goto Cleanup;
        hr = THR(ds.LoadDword((DWORD *)&pColCalc->_xWidth));
        if (hr)
            goto Cleanup;
        if (pColCalc->_xWidth < 0)
        {
            pColCalc->_fVirtualSpan = TRUE;
            pColCalc->_xWidth = - pColCalc->_xWidth;
        }
        hr = THR(ds.LoadDword((DWORD *)&iP));
        if (hr)
            goto Cleanup;
        Assert (iP >=0 && iP <= HISTORY_SPECIAL_LAST_VALUE);
        if (iP)
        {
            switch (iP)
            {
                case HISTORY_WIDTH_SPECIFIED:
                    pColCalc->SetPixelWidth(pci, pColCalc->_xWidth);    // user width is specified
                    break;
                case HISTORY_ZERO_PERCENT:
                    iP = 0;                         // fall through
                default:
                    pColCalc->SetPercentWidth(iP);  // percent width specified
                    break;
            }
        }
    }

Cleanup:
    _fUsingHistory = (hr == S_OK);
    RRETURN(hr);
}


int
CTableLayout::GetNextRowSafe(int iRow)
{
    // iRow can be in range [-1, GetRows()-1]
    Assert(AssertTableLayoutCacheCurrent() && iRow >= -1 && iRow < GetRows());

    // If iRow is -1, return first row.
    if (iRow < 0)
        return GetFirstRow();

    // If iRow is last row, return row index outside range.
    if (iRow == GetLastRow())
        return GetRows();

    return GetNextRow(iRow);
}

int
CTableLayout::GetPreviousRowSafe(int iRow)
{
    // iRow can be in range [0, GetRows() (!! not GetRows()-1) ]
    Assert(AssertTableLayoutCacheCurrent() && iRow >= 0 && iRow <= GetRows());

    // If iRow is outside row range, return index last row.
    if (iRow >= GetRows())
        return GetLastRow();

    return GetPreviousRow(iRow);
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayout::EnsureTableLayoutCache
//
// Synopsis:     Support for lazy table layout cache (TLC) maintenance.
//               The document tree version serves as the baseline.
//
//+---------------------------------------------------------------------

HRESULT
CTableLayout::EnsureTableLayoutCache()
{
    HRESULT hr;

    if (IsTableLayoutCacheCurrent())
        return S_OK;

    if (!GetFirstBranch())
    {
        Assert(!"Must have a first branch, i.e. table must be in the tree in order to retrieve the table layout cache");
        RRETURN(E_FAIL);
    }

    hr = THR(CreateTableLayoutCache());

    // FUTURE: In the future, we need to be able to deal with inconsistent tree scenarios and
    // we have to deal with situations in which the table layout cache cannot be retrieved.
    // This will have to be tunnelled up to CalcSize and Draw.
    Assert(hr == S_OK && "EnsureTableLayoutCache failed");
    if (!hr)
    {
        MarkTableLayoutCacheCurrent();
    }

    RRETURN(hr);
}


HRESULT
CTableLayout::AddAbsolutePositionCell(CTableCell *pCell)
{
    HRESULT hr;
    if (!_pAbsolutePositionCells)
    {
        _pAbsolutePositionCells = new  (Mt(CTableLayout_pAbsolutePositionCells_pv)) CPtrAry<CTableCell *> (Mt(CTableLayout_pAbsolutePositionCells_pv));
        if (!_pAbsolutePositionCells)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = _pAbsolutePositionCells->Append(pCell);
    if (hr==S_OK)
        pCell->SubAddRef();

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//
//  Returns:    Pointer to the element CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CTableLayout::GetElementDispNode(CElement *  pElement) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
//                    : pElement->Tag() == ETAG_THEAD || pElement->Tag() == ETAG_TFOOT
//                        ? GetTableOuterDispNode()
                        : NULL);
}


void CTableLayout::EnsureColsFormatCacheChange()
{
    if (_aryCols.Size() == 0)
        return; 

    CTableRow ** ppRow;
    int          cR;

    for (ppRow = _aryRows, cR = GetRows(); 
        cR > 0; 
        cR--, ppRow++)
    {
        CTableRowLayout *   pRowLayoutCache;
        CTableCell **       ppCell;
        int                 cC;

        pRowLayoutCache = (*ppRow)->RowLayoutCache();
        Assert(pRowLayoutCache);
    
        if (pRowLayoutCache->_aryCells.Size())
        {
            Assert(_aryCols.Size() <= pRowLayoutCache->_aryCells.Size());
            cC = min(_aryCols.Size(), pRowLayoutCache->_aryCells.Size());

            for (ppCell = pRowLayoutCache->_aryCells; 
                cC > 0; 
                cC--, ppCell++)
            {
                CTableCell *pCell = Cell(*ppCell);
                if (pCell)
                {
                    pCell->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
                }
            }
        }
    }
}

#if DBG==1

void CTableLayout::TraceTLCDirty(BOOL fDirty)
{
    if (!fDirty != !_fTLCDirty)
    {
        TraceTag((tagTLCDirty, "TLC for table %ld marked %s",
            Table()->_nSerialNumber, fDirty ? "dirty" : "clean"));
        TraceCallers(tagTLCDirty, 1, 10);
    }
}

#endif

//+---------------------------------------------------------------------
//
// CTableLayoutBreak implementation
//
//+---------------------------------------------------------------------
//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBreak::~CTableLayoutBreak 
//
// Synopsis:     
//
//+---------------------------------------------------------------------
CTableLayoutBreak::~CTableLayoutBreak()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\t2embapi.h ===
/***************************************************************************
 * Module: T2EMBAPI.H
 *
 * Copyright (c) Microsoft Corp., 1996, 1997
 *
 * Author: Paul Linnerud (paulli)
 * Date:   May 1996
 *
 * Mods:
 *
 * Header file for the TrueType embedding services dll (T2EMBED.DLL)
 *
 **************************************************************************/

#ifndef I_T2EMBAPI_H_
#define I_T2EMBAPI_H_
#pragma INCMSG("--- Beg 't2embapi.h'")

#if !defined(_T2API_LIB_)
#define T2API __declspec(dllimport)
#else
#define T2API __declspec(dllexport)
#endif

// Charset flags for ulCharSet field of TTEmbedFont
#if !defined(CHARSET_UNICODE)
#define CHARSET_UNICODE                    1
#define CHARSET_DEFAULT                    1
#define CHARSET_SYMBOL                     2
#endif

// Status returned by TTLoadEmbeddedFont
#if !defined(EMBED_PREVIEWPRINT)
#define EMBED_PREVIEWPRINT                 1
#define EMBED_EDITABLE                     2
#define EMBED_INSTALLABLE                  3
#define EMBED_NOEMBEDDING                  4
#endif

// Use restriction flags
#if !defined(LICENSE_INSTALLABLE)
#define LICENSE_INSTALLABLE             0x0000
#define LICENSE_DEFAULT                 0x0000
#define LICENSE_NOEMBEDDING             0x0002
#define LICENSE_PREVIEWPRINT            0x0004
#define LICENSE_EDITABLE                0x0008
#endif

// Options given to TTEmbedFont in uFlags parameter
#if !defined(TTEMBED_RAW)
#define TTEMBED_RAW							0x00000000
#define TTEMBED_SUBSET						0x00000001
#define TTEMBED_TTCOMPRESSED				0x00000004
#define TTEMBED_FAILIFVARIATIONSIMULATED	0x00000010
#define TTEMBED_XORENCRYPTDATA				0x10000000 // internal
#endif

// Bits returned through pulStatus for TTEmbedFont
#if !defined(TTEMBED_VARIATIONSIMULATED)
#define TTEMBED_VARIATIONSIMULATED		0x00000001					
#endif

// Flag options for TTLoadEmbeddedFont 
#if !defined(TTLOAD_PRIVATE)
#define TTLOAD_PRIVATE                  0x00000001 
#endif

// Bits returned through pulStatus for TTLoadEmbeddedFont 
#if !defined(TTLOAD_FONT_SUBSETTED)
#define TTLOAD_FONT_SUBSETTED		0x00000001
#define TTLOAD_FONT_IN_SYSSTARTUP	0x00000002
#endif

// Flag options for TTDeleteEmbeddedFont
#if !defined(TTDELETE_DONTREMOVEFONT)
#define TTDELETE_DONTREMOVEFONT		0x00000001	
#endif

// Error codes
#if !defined(E_NONE)
#define E_NONE                      0x0000L
#endif

// Top level error codes
#if !defined(E_CHARCODECOUNTINVALID)
#define E_CHARCODECOUNTINVALID      0x0002L
#define E_CHARCODESETINVALID        0x0003L
#define E_DEVICETRUETYPEFONT        0x0004L
#define E_HDCINVALID                0x0006L
#define E_NOFREEMEMORY              0x0007L
#define E_FONTREFERENCEINVALID      0x0008L
#define E_NOTATRUETYPEFONT          0x000AL
#define E_ERRORACCESSINGFONTDATA    0x000CL
#define E_ERRORACCESSINGFACENAME    0x000DL
#define E_ERRORUNICODECONVERSION    0x0011L
#define E_ERRORCONVERTINGCHARS      0x0012L
#define E_EXCEPTION					0x0013L
#define E_RESERVEDPARAMNOTNULL		0x0014L	
#define E_CHARSETINVALID			0x0015L
#define E_WIN32S_NOTSUPPORTED		0x0016L
#endif

// Indep level error codes 
#if !defined(E_ERRORCOMPRESSINGFONTDATA)
#define E_ERRORCOMPRESSINGFONTDATA    0x0100L
#define E_FONTDATAINVALID             0x0102L
#define E_NAMECHANGEFAILED            0x0103L
#define E_FONTNOTEMBEDDABLE           0x0104L
#define E_PRIVSINVALID                0x0105L
#define E_SUBSETTINGFAILED            0x0106L
#define E_READFROMSTREAMFAILED        0x0107L
#define E_SAVETOSTREAMFAILED          0x0108L
#define E_NOOS2                       0x0109L
#define E_T2NOFREEMEMORY              0x010AL
#define E_ERRORREADINGFONTDATA        0x010BL
#define E_FLAGSINVALID                0x010CL
#define E_ERRORCREATINGFONTFILE       0x010DL
#define E_FONTALREADYEXISTS           0x010EL
#define E_FONTNAMEALREADYEXISTS       0x010FL
#define E_FONTINSTALLFAILED           0x0110L
#define E_ERRORDECOMPRESSINGFONTDATA  0x0111L
#define E_ERRORACCESSINGEXCLUDELIST   0x0112L
#define E_FACENAMEINVALID			  0x0113L
#define E_STREAMINVALID               0x0114L
#define E_STATUSINVALID				  0x0115L
#define E_PRIVSTATUSINVALID			  0x0116L
#define E_PERMISSIONSINVALID		  0x0117L
#define E_PBENABLEDINVALID			  0x0118L
#define E_SUBSETTINGEXCEPTION		  0x0119L
#define E_SUBSTRING_TEST_FAIL		  0x011AL
#define E_FONTVARIATIONSIMULATED	  0x011BL
#endif

// Bottom level error codes
#if !defined(E_ADDFONTFAILED)
#define E_ADDFONTFAILED             0x0200L
#define E_COULDNTCREATETEMPFILE     0x0201L
#define E_FONTFILECREATEFAILED      0x0203L
#define E_WINDOWSAPI                0x0204L
#define E_FONTFILENOTFOUND          0x0205L
#define E_RESOURCEFILECREATEFAILED  0x0206L
#define E_ERROREXPANDINGFONTDATA    0x0207L
#define E_ERRORGETTINGDC            0x0208L
#define E_EXCEPTIONINDECOMPRESSION	0x0209L
#define E_EXCEPTIONINCOMPRESSION	0x020AL
#endif

#ifdef __cplusplus
extern "C" {
#endif

// 1st argument - Stream identifier (file handle or other) (dwStream) */
// 2nd argument - Address of buffer with data to read or write */
// 3rd argument - Number of bytes to read or write */
typedef unsigned long( __cdecl *READEMBEDPROC ) ( void*, void*, const unsigned long );
typedef unsigned long( __cdecl *WRITEEMBEDPROC ) ( void*, const void*, const unsigned long );

#if !defined(_TTLOADINFO_DEFINED)
typedef struct
{
	unsigned short usStructSize;	// size in bytes of structure client should set to sizeof(TTLOADINFO)
	unsigned short usRefStrSize;	// size in wide characters of pusRefStr including NULL terminator
	LPTSTR  pusRefStr;		// reference or actual string. 
}TTLOADINFO;
#define _TTLOADINFO_DEFINED
#endif

#if !defined(_TTEMBEDINFO_DEFINED)
typedef struct
{
	unsigned short usStructSize;	// size in bytes of structure client should set to sizeof(TTEMBEDINFO)
	unsigned short usRootStrSize;   // size in wide chars of pusSubStr including NULL terminator(s)
	LPTSTR  pusRootStr;		// substring(s) of strings given at load time. can have multiple strings separated
									//  by a NULL terminator. 
}TTEMBEDINFO;
#define _TTEMBEDINFO_DEFINED
#endif

/* Font Embedding APIs ----------------------------------------------------*/

T2API LONG WINAPI TTEmbedFont
(
	HDC       hDC,                    // device-context handle
	ULONG     ulFlags,                // flags specifying the request
	ULONG     ulCharSet,              // flags specifying char set
	ULONG*    pulPrivStatus,          // upon completion contains embedding priv of font
	ULONG*    pulStatus,              // on completion may contain status flags for request
	WRITEEMBEDPROC lpfnWriteToStream, // callback function for doc/disk writes
	LPVOID    lpvWriteStream,         // the output stream tokin
	USHORT*   pusCharCodeSet,         // address of buffer containing optional
									  // character codes for subsetting
	USHORT    usCharCodeCount,        // number of characters in the
									  // lpvCharCodeSet buffer
	USHORT    usLanguage,             // specifies the language in the name table to keep
									  //  set to 0 to keep all
	TTEMBEDINFO* pTTEmbedInfo         // optional security
);


T2API LONG WINAPI TTLoadEmbeddedFont
(
	HANDLE*   phFontReference,			// on completion, contains handle to identify embedded font installed
										// on system
	ULONG	  ulFlags,					// flags specifying the request 
	ULONG*    pulPrivStatus,			// on completion, contains the embedding status
	ULONG     ulPrivs,					// allows for the reduction of licensing privileges
	ULONG*    pulStatus,				// on completion, may contain status flags for request 
	READEMBEDPROC lpfnReadFromStream,	// callback function for doc/disk reads
	LPVOID    lpvReadStream,			// the input stream tokin
	LPWSTR    szWinFamilyName,			// the new 16 bit windows family name can be NULL
	LPSTR	  szMacFamilyName,			// the new 8 bit mac family name can be NULL
	TTLOADINFO* pTTLoadInfo				// optional security
);

T2API LONG WINAPI TTDeleteEmbeddedFont
(
	HANDLE    hFontReference,	// Reference to font value provided by load functions										
	ULONG	  ulFlags,
	ULONG*    pulStatus
);

T2API LONG WINAPI TTGetEmbeddingType
(                                                                       
	HDC         hDC,                   // device context handle
	ULONG*      pulEmbedType           // upon completion, contains the
									   // embedding status
);

T2API LONG WINAPI TTCharToUnicode
(	
	HDC			hDC,				// device context handle
	UCHAR*		pucCharCodes,		// array of 8 bit character codes to convert
	ULONG		ulCharCodeSize,		// size of 8 bit character code array
	USHORT*     pusShortCodes,		// buffer to recieve Unicode code points
	ULONG		ulShortCodeSize,	// size in wide characters of 16 bit character code array
	ULONG		ulFlags				// Control flags
);


/* Font Enabling APIs -----------------------------------------------------*/

T2API LONG WINAPI TTIsEmbeddingEnabled
(                                                                       
	HDC                     hDC,            // device context handle                                                                
	BOOL*           pbEnabled       // upon completion will indicate if enabled
);                                                              

T2API LONG WINAPI TTIsEmbeddingEnabledForFacename
(                                                                       
	LPSTR           lpszFacename,   // facename
	BOOL*           pbEnabled       // upon completion will indicate if enabled
);

T2API LONG WINAPI TTEnableEmbeddingForFacename
(                                   // If fEnable != 0, it removes the indicated
	LPSTR           lpszFacename,   // typeface name from the "embedding
	BOOL            bEnable         // exclusion list".  Else, it enters the
);                                  // indicated typeface name in the "embedding
									// exclusion list". 

#ifdef __cplusplus
}
#endif

#pragma INCMSG("--- End 't2embapi.h'")
#else
#pragma INCMSG("*** Dup 't2embapi.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\t2emwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       T2EmWrap.cxx
//
//  Contents:   Wrapper functions for the OpenType Embedding DLL (t2embed.dll).
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_T2EMBAPI_H_
#define X_T2EMBAPI_H_
#include "t2embapi.h"
#endif

#ifndef X_T2EMWRAP_HXX_
#define X_T2EMWRAP_HXX_
#include "t2emwrap.hxx"
#endif


DYNLIB g_dynlibT2Embed = { NULL, NULL, "T2EMBED.DLL" };
DYNPROC g_dynprocT2EmbedLoadFont =
    { NULL, &g_dynlibT2Embed, "TTLoadEmbeddedFont" };
DYNPROC g_dynprocT2EmbedDeleteFont =
    { NULL, &g_dynlibT2Embed, "TTDeleteEmbeddedFont" };

// refcount

ULONG g_cT2EmbedFonts = 0;

void LockT2Embed()
{
    LOCK_GLOBALS;
    g_cT2EmbedFonts++;
}

void FreeT2Embed()
{
    LOCK_GLOBALS;
    g_cT2EmbedFonts--;
    if (g_cT2EmbedFonts == 0)
    {
        FreeDynlib(&g_dynlibT2Embed);
    }
}

LONG WINAPI T2LoadEmbeddedFont( HANDLE *phFontReference, ULONG ulFlags, ULONG *pulPrivStatus,
        ULONG ulPrivs, ULONG *pulStatus, READEMBEDPROC lpfnReadFromStream, LPVOID lpvReadStream,
        LPWSTR szWinFamilyName, LPSTR szMacFamilyName, TTLOADINFO *pTTLoadInfo )
{
    LONG lRet = E_EXCEPTION;
    
    LockT2Embed();
    if ( THR( LoadProcedure( &g_dynprocT2EmbedLoadFont ) ) == S_OK )
    {
        LOADEMBFONTFN lpfnTTLoadEmbeddedFont = (LOADEMBFONTFN)g_dynprocT2EmbedLoadFont.pfn;

        lRet = (lpfnTTLoadEmbeddedFont)( phFontReference, ulFlags, pulPrivStatus, ulPrivs, pulStatus,
                                                    lpfnReadFromStream, lpvReadStream, szWinFamilyName,
                                                    szMacFamilyName, pTTLoadInfo );
    }
    FreeT2Embed();
    return lRet;
}

LONG WINAPI T2DeleteEmbeddedFont ( HANDLE hFontReference, ULONG ulFlags, ULONG *pulStatus )
{
    LONG lRet = E_EXCEPTION;
    
    LockT2Embed();
    if ( THR( LoadProcedure( &g_dynprocT2EmbedDeleteFont ) ) == S_OK )
    {
        DELEMBFONTFN lpfnTTDeleteEmbeddedFont = (DELEMBFONTFN)g_dynprocT2EmbedDeleteFont.pfn;
        lRet = (lpfnTTDeleteEmbeddedFont)( hFontReference, ulFlags, pulStatus );
    }
    FreeT2Embed();
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\ssheets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ssheets.cxx
//
//  Contents:   Support for shared style sheets
//
//
//  History:    zhenbinx    created 08/18/2000
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif


MtDefine(CSharedStyleSheet, Mem, "CSharedStyleSheet");
MtDefine(CSharedStyleSheet_apRulesList_pv, CSharedStyleSheet, "CSharedStyleSheet_apRulesList_pv");
MtDefine(CSharedStyleSheet_apImportedStyleSheets_pv, CSharedStyleSheet, "CSharedStyleSheet_apImportedStyleSheets_pv");
MtDefine(CSharedStyleSheet_apPageBlocks_pv, CSharedStyleSheet, "CSharedStyleSheet_apPageBlocks_pv");
MtDefine(CSharedStyleSheet_apFontBlocks_pv, CSharedStyleSheet, "CSharedStyleSheet_apFontBlocks_pv");
MtDefine(CStyleSheetArray, CSharedStyleSheet, "CStyleSheetArray")
MtDefine(CStyleSheetArray_aStyleSheets_pv, CSharedStyleSheet, "CStyleSheetArray::_aStyleSheets::_pv")
MtDefine(CStyleRule, CSharedStyleSheet, "CStyleRule")
MtDefine(CStyleRuleArray, CSharedStyleSheet, "CStyleRuleArray")
MtDefine(CStyleRuleArray_pv, CSharedStyleSheet, "CStyleRuleArray::_pv")
MtDefine(CAtPageBlock, CSharedStyleSheet, "CAtPageBlock");
MtDefine(CAtFontBlock, CSharedStyleSheet, "CAtFontBlock");
MtDefine(CSharedStyleSheet_apSheetsList_pv, CSharedStyleSheet, "CSharedStyleSheet::_apSheetsList");

MtDefine(CSharedStyleSheetsManager, Mem, "CSharedStyleSheetManager");
MtDefine(CSharedStyleSheetsManager_apSheets_pv, CSharedStyleSheetsManager, "CSharedStyleSheetsManager_apSheets_pv");



DeclareTag(tagSharedStyleSheet, "Style Sheet Shared", "trace Shared Style Sheet operations")

//---------------------------------------------------------------------
//  Class Declaration:  CSharedStyleSelect
//      This class implements a parsed style sheet - it managers the rules
//      and is shared among different markup so that re-parse is not
//      necessary if the same CSS is ref-ed in different markups.
//---------------------------------------------------------------------

//*********************************************************************
//      CSharedStyleSheet::Create
//  Factory Method
//*********************************************************************
HRESULT
CSharedStyleSheet::Create(CSharedStyleSheet **ppSSS)
{
    HRESULT hr = S_OK;

    if (!ppSSS)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppSSS = new CSharedStyleSheet();
    if (!*ppSSS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if (hr && (*ppSSS) && (*ppSSS)->_fInvalid)
    {
        delete (*ppSSS);
        (*ppSSS) = NULL;
    }
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::CSharedStyleSheet()
//  The shared style sheet contains only the rules
//*********************************************************************
CSharedStyleSheet::CSharedStyleSheet()
    :
    _pManager(NULL),
    _pRulesArrays(NULL),
    _fInvalid(FALSE),
    _fComplete(FALSE),
    _fParsing(FALSE),
    _fModified(FALSE),
    _fExpando(FALSE),
    _achAbsoluteHref(NULL),
    _cp(CP_UNDEFINED),
    _fXMLGeneric(FALSE),
    _dwBindf(0),
    _dwRefresh(0),
    _ulRefs(1)
{
    WHEN_DBG( _fPassivated = FALSE );
    WHEN_DBG( _lReserveCount = 0 );

    _eMediaType = MEDIA_All;
    _eLastAtMediaType = MEDIA_NotSet;

    memset(&_ft, 0, sizeof(FILETIME));

    _pRulesArrays = new CStyleRuleArray[ETAG_LAST];
    if (!_pRulesArrays)
    {
        _fInvalid = TRUE;
        goto Cleanup;
    }

    _htClassSelectors.SetCallBack(this, CompareIt);
    _htIdSelectors.SetCallBack(this, CompareIt);


Cleanup:
    if (_fInvalid)
    {
        if (_pRulesArrays)
        {
            delete [] _pRulesArrays;
            _pRulesArrays = NULL;
        }
    }
}


CSharedStyleSheet::~CSharedStyleSheet()
{
    Assert( "Must call Free() before destructor!" && _fPassivated );
}


STDMETHODIMP_(ULONG)
CSharedStyleSheet::PrivateAddRef()
{
    return (ULONG)InterlockedIncrement((LONG *)&_ulRefs);
}



STDMETHODIMP_(ULONG)
CSharedStyleSheet::PrivateRelease()
{
    if ((ULONG)InterlockedDecrement((LONG *)&_ulRefs) == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        delete this;
        return 0;
    }
    return _ulRefs;
}



//*********************************************************************
//      CSharedStyleSheet::Passivate
//  Disconnect this from anything elese. Free all the resources we are holding onto.
//  This object is about to die...
//*********************************************************************
void
CSharedStyleSheet::Passivate()
{
    Assert( _ulRefs == ULREF_IN_DESTRUCTOR );

    // free all resources
    ReInit();

    // notify the manager that this is gone
    if (_pManager)
    {
        _pManager->RemoveSharedStyleSheet(this);
        _pManager = NULL;
    }

    // no sheets should be holding on to this now..
     _apSheetsList.DeleteAll();

    if (_pRulesArrays)
    {
        delete [] _pRulesArrays;    // Arrays should be empty; we're just releasing mem here
        _pRulesArrays = NULL;
    }

    WHEN_DBG( _fPassivated = TRUE );
}



//*********************************************************************
//      CSharedStyleSheet::ReInit()
//  Free all the resources we are holding onto -- re-init this to its pristine state.
//*********************************************************************
void
CSharedStyleSheet::ReInit()
{
    // release all rules and internal indexes
    ReleaseRules();

    if (_achAbsoluteHref)
    {
        MemFreeString(_achAbsoluteHref);
        _achAbsoluteHref = NULL;
    }

    _fComplete = FALSE;
    _fParsing   = FALSE;
    _fModified   = FALSE;
    _cp        = CP_UNDEFINED;
    _fXMLGeneric = FALSE;
    _fExpando   = FALSE;
}





//*********************************************************************
//      CSharedStyleSheet::ReleaseRules
//  Release all rules we are holding onto.
//*********************************************************************
HRESULT
CSharedStyleSheet::ReleaseRules(void)
{
    //
    // DONOT call ReleaseRules on imported shared style sheets!
    // Pretend that we don't know imported shared style sheets since
    // our containing style sheets knows about its imported style
    // sheet, so they will release the imported shared style sheets
    // correctly.
    //
    //
    int z;

    _fComplete = FALSE;
    _fParsing  = FALSE;

    int idx = _apRulesList.Size();
    while ( idx )
    {
        _apRulesList[ idx-1]->Free();
        delete _apRulesList[ idx - 1];
        idx--;
    }
    _apRulesList.DeleteAll();

    // Free all @pages
    idx = _apPageBlocks.Size();
    while (idx)
    {
        _apPageBlocks[idx-1]->Release();
        idx--;
    }
    _apPageBlocks.DeleteAll();


    // Forget all the @font we're storing
    idx =  _apFontBlocks.Size();
    while (idx)
    {
        _apFontBlocks[idx - 1]->Release();
        idx--;
    }
    _apFontBlocks.DeleteAll();


    if (_pRulesArrays)
    {
        for ( z=0 ; z < ETAG_LAST ; ++z )
            _pRulesArrays[z].Free( );
    }

    {
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            pary->Free();
            delete pary;
        }
        _htClassSelectors.ReInit();
        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            pary->Free();
            delete pary;
        }
        _htIdSelectors.ReInit();
    }

    {
        // remove imported style sheets
        CImportedStyleSheetEntry    *pRE;
        int n;
        for (pRE = _apImportedStyleSheets, n = _apImportedStyleSheets.Size();
             n > 0;
             n--, pRE++
             )
        {
            pRE->_cstrImportHref.Free();
        }
        _apImportedStyleSheets.DeleteAll();
    }

    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::Clone()
//  Make a new one just like this one...
//*********************************************************************
HRESULT
CSharedStyleSheet::Clone(CSharedStyleSheet **ppSSS, BOOL fNoContent)
{
    HRESULT hr = S_OK;
    int n;
    CSharedStyleSheet *pClone = NULL;

    Assert( DbgIsValid() );
    Assert( ppSSS );

    hr = CSharedStyleSheet::Create(ppSSS);
    if (hr)
        goto Cleanup;
    pClone = (*ppSSS);
    Assert( pClone );

    // clone settings
    if (_achAbsoluteHref)
    {
        MemAllocString( Mt(CSharedStyleSheet), _achAbsoluteHref, &(pClone->_achAbsoluteHref) );
        if ( !pClone->_achAbsoluteHref )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    pClone->_eMediaType       = _eMediaType;
    pClone->_eLastAtMediaType = _eLastAtMediaType;
    pClone->_fInvalid         = _fInvalid;
    pClone->_fComplete        = _fComplete;
    pClone->_fModified        = _fModified;
    pClone->_fExpando         = _fExpando;
    pClone->_cp               = _cp;
    pClone->_fXMLGeneric      = _fXMLGeneric;
    pClone->_pManager         = _pManager;
    pClone->_fIsStrictCSS1    = _fIsStrictCSS1;

    if (fNoContent)     // we are done...
    {
        TraceTag( (tagSharedStyleSheet, "Clone - fNoContent - simply return") );
        goto Cleanup;
    }

    // clone rules
    CStyleRule  **pRules;
    CStyleRule  *pCloneRule;
    for (n = 0, pRules = _apRulesList;
         n < _apRulesList.Size();
         n++, pRules++)
    {
        hr = (*pRules)->Clone(&pCloneRule);
        if (hr)
            goto Cleanup;
        pClone->_apRulesList.Append(pCloneRule);
    }

    // clone imports
    CImportedStyleSheetEntry    *pRE;
    for (pRE = _apImportedStyleSheets, n = 0;
         n < _apImportedStyleSheets.Size();
         n++, pRE++
         )
    {
        CImportedStyleSheetEntry *pNE;
        pClone->_apImportedStyleSheets.AppendIndirect(NULL, &pNE);

        pNE->_cstrImportHref.Set( pRE->_cstrImportHref );
    }

    // clone @font
    CAtFontBlock **ppAtFont;
    for (n=0, ppAtFont = _apFontBlocks;
         n < _apFontBlocks.Size();
         n++, ppAtFont++
         )
    {
        CAtFontBlock *pAtFont;
        hr = (*ppAtFont)->Clone(&pAtFont);
        if (hr)
            goto Cleanup;

        pClone->_apFontBlocks.Append(pAtFont);
    }

    // clone @page
    CAtPageBlock **ppAtPage;
    for (n = 0, ppAtPage = _apPageBlocks;
         n < _apPageBlocks.Size();
         n++, ppAtPage++
         )
    {
        CAtPageBlock *pAtPage;
        hr = (*ppAtPage)->Clone(&pAtPage);
        if (hr)
            goto Cleanup;

        pClone->_apPageBlocks.Append(pAtPage);
    }

    // clone indexes
    if (_pRulesArrays)
    {
        TraceTag( (tagSharedStyleSheet, "Clone  indexes rule-array") );
        int z;
        for ( z=0 ; z < ETAG_LAST ; ++z )
        {
            CStyleRuleArray *pTagRules = &(_pRulesArrays[z]);
            Assert(pTagRules);
            CStyleRuleArray * pCloneRA = &(pClone->_pRulesArrays[z]);
            Assert( pCloneRA);
            for (n = 0; n < pTagRules->Size(); n++)
            {
                CStyleRule  *pRule = *((CStyleRule **)pTagRules->Deref(sizeof(CStyleRule *), n));
                Assert( pRule );
                CStyleRuleID sidRule = pRule->GetRuleID();
                Assert( sidRule >= 1);
                Verify( S_OK == THR(pCloneRA->InsertStyleRule( pClone->_apRulesList[sidRule - 1], TRUE, NULL)) );
                TraceTag( (tagSharedStyleSheet, "Clone  indexes rule-array [%2d] with rule [%d]", z, n) );
            }
        }
    }

    //
    // clone hash table this way is slow
    //
    UINT iIndex;
    CStyleRuleArray * pary;
    CHtPvPv     *pVV;

    TraceTag( (tagSharedStyleSheet, "Clone  indexes class hash table") );
    pVV = &(pClone->_htClassSelectors);
    hr = _htClassSelectors.CloneMemSetting( &pVV, FALSE /* fCreateNew */);
    if (hr)
        goto Cleanup;

    for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
         pary;
         pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
    {
        // set the entry
        CStyleRuleArray   *pCloneRuleAry = new CStyleRuleArray();
        if (!pCloneRuleAry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        void *pdwKey = _htClassSelectors.GetKey(iIndex);    // no need to clone key since it is just a hash value
        pClone->_htClassSelectors.Set(iIndex, pdwKey, pCloneRuleAry);

        // set the entry array
        int nRules = pary->Size();
        int iRule;
        CStyleRuleID sidRule;

        TraceTag( (tagSharedStyleSheet, "Clone  indexes class hash table - [%p] has [%d] rules", pCloneRuleAry, nRules) );
        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            sidRule = pary->Item(iRule)->GetRuleID();
            pCloneRuleAry->Append( pClone->_apRulesList[sidRule - 1] );
        }
    }

    //
    TraceTag( (tagSharedStyleSheet, "Clone  indexes id hash table") );
    pVV =  &(pClone->_htIdSelectors);
    hr = _htIdSelectors.CloneMemSetting( &pVV, FALSE /*fCreateNew */);
    if (hr)
        goto Cleanup;

    for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
         pary;
         pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
    {
        // set the entry
        CStyleRuleArray   *pCloneRuleAry = new CStyleRuleArray();
        if (!pCloneRuleAry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        void *pdwKey = _htIdSelectors.GetKey(iIndex);    // no need to clone key since it is just a hash value
        pClone->_htIdSelectors.Set(iIndex, pdwKey, pCloneRuleAry);

        int nRules = pary->Size();
        int iRule;
        CStyleRuleID sidRule;

        TraceTag( (tagSharedStyleSheet, "Clone  indexes id hash table - [%p] has [%d] rules", pCloneRuleAry, nRules) );
        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            sidRule = pary->Item(iRule)->GetRuleID();
            pCloneRuleAry->Append( pClone->_apRulesList[sidRule - 1] );
        }
    }

    Assert( DbgIsValid() );
    Assert( pClone->DbgIsValid() );
Cleanup:
    if (hr && pClone)
    {
        pClone->Release();    // this will cause destruction in case of any failures
        (*ppSSS) = NULL;
        Assert(FALSE && "CSharedStyleSheet::Clone Failed");
    }
    RRETURN(hr);
}



//*********************************************************************
//      CSharedStyleSheet::Notify()
//  Notify the style sheets that share this one that certain events
//  happens such as done parsing
//*********************************************************************
HRESULT
CSharedStyleSheet::Notify(DWORD dwNotification)
{
    HRESULT  hr = S_OK;
    CStyleSheet **ppSS;
    int n;
    for (n = _apSheetsList.Size(), ppSS = _apSheetsList;
         n > 0;
         n--, ppSS++
         )
     {
        //
        // TODO: Make this async -- otherwise we would be deadlocked in multithread case
        //
        // GWPostMethodCallEx(_pts, this, ONCALL_METHOD(CDwnChan, OnMethodCall, onmethodcall), 0, FALSE, GetOnMethodCallName());
        //
        if ( (*ppSS)->_eParsingStatus == CSSPARSESTATUS_PARSING)
        {
            hr = THR((*ppSS)->Notify(dwNotification));
            if (hr)
                goto Cleanup;
        }
     }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::SwitchParserAway()
// error during parsing. try to switch to a different parser
//*********************************************************************
HRESULT
CSharedStyleSheet::SwitchParserAway(CStyleSheet *pSheet)
{
    RRETURN(E_NOTIMPL);
}



//*********************************************************************
//      CSharedStyleSheet::CompareIt()
//  Used in CHtPvPv by _htIdSelectors and _htClassSelectors
//*********************************************************************
BOOL
CSharedStyleSheet::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CStyleRuleArray *   pary;
    CClassIDStr *       strProbe;
    CStyleRule *        pRule;
    CStyleSelector *    pSelector;

    strProbe = (CClassIDStr *)pvKeyPassedIn;
    pary = (CStyleRuleArray *)pvVal2;

    Assert( pary && pary->Size() );

    pRule = *((CStyleRule **)pary->Deref(sizeof(CStyleRule *), 0));
    pSelector = pRule->GetSelector();

    // The following code uses case sensitive comparison iff we are in strict css mode.
    if (strProbe->_eType == eClass)
    {
        if (pSelector->_fIsStrictCSS1)
            return !_tcsncmp(pSelector->_cstrClass, pSelector->_cstrClass.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
        else
            return !_tcsnicmp(pSelector->_cstrClass, pSelector->_cstrClass.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
    }
    else
    {
        if (pSelector->_fIsStrictCSS1)
            return !_tcsncmp(pSelector->_cstrID, pSelector->_cstrID.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
        else
            return !_tcsnicmp(pSelector->_cstrID, pSelector->_cstrID.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
    }
}







 CStyleRule *CSharedStyleSheet::GetRule(CStyleRuleID sidRule)
{
    Assert ( "rule id contains sheet id" && (sidRule.GetSheet() == 0) );
    if (sidRule.GetRule() <= 0 || sidRule.GetRule() > (unsigned int)(_apRulesList.Size()))
        return NULL;
    return _apRulesList[sidRule.GetRule() - 1];
}


//*********************************************************************
//  CSharedStyleSheet::ChangeRulesStatus()
// Change Media type
//*********************************************************************
HRESULT
CSharedStyleSheet::ChangeRulesStatus(DWORD dwAction, BOOL *pfChanged)
{
    Assert( MEDIATYPE(dwAction) && "ChangeRulesStatus should only be called for media types");

    if (MEDIATYPE(dwAction))
    {
        if (*pfChanged)
        {
            if (_eMediaType != (EMediaType)MEDIATYPE(dwAction))
            {
                *pfChanged = TRUE;
            }
        }
        _eMediaType = (EMediaType)MEDIATYPE(dwAction);

        // change rules
        CStyleRule **pRules;
        int n;
        for (n = _apRulesList.Size(), pRules = _apRulesList;
             n > 0;
             n--, pRules++)
        {
            // Need to patch media type.
            (*pRules)->SetMediaType(dwAction);
        }
    }

    return S_OK;
}


//*********************************************************************
//  CSharedStyleSheet::AddStyleRule()
//      This method adds a new rule to the correct CStyleRuleArray in
//  the hash table (hashed by element (tag) number) (The CStyleRuleArrays
//  are stored in the containing CStyleSheetArray).  This method is
//  responsible for splitting apart selector groups and storing them
//  as separate rules.  May also handle important! by creating new rules.
//
//  We also maintain a list in source order of the rules inserted by
//  this stylesheet -- the list has the rule ID (rule info only, no
//  import nesting info) and etag (no pointers)
//
//  NOTE:  If there are any problems, the CStyleRule will auto-destruct.
//*********************************************************************
HRESULT
CSharedStyleSheet::AddStyleRule(CStyleRule *pRule, BOOL fDefeatPrevious /*=TRUE*/, long lIdx /*=-1*/)
{
    WHEN_DBG(Assert(DbgIsValid()));

    HRESULT     hr  = S_OK;
    CStyleSelector  *pNextSelector;

    do
    {
        CStyleRule *pSiblingRule = NULL;

        pNextSelector = pRule->GetSelector()->_pSibling;
        pRule->GetSelector()->_pSibling = NULL;

        if ( _apRulesList.Size() >= MAX_RULES_PER_SHEET )
        {
            hr = E_INVALIDARG;
            break;
        }

        pRule->SetMediaType(pRule->GetMediaType() | _eMediaType );
        pRule->SetLastAtMediaTypeBits( _eLastAtMediaType  );

        if ( ( lIdx < 0 ) || ( lIdx >= _apRulesList.Size() ) )   // Add at the end
        {
            lIdx = _apRulesList.Size();
            pRule->GetRuleID().SetRule( lIdx + 1 );
        }
        else
        {
            CStyleRule      **pRE;
            int  i, nRules;

            pRule->GetRuleID().SetRule( lIdx + 1 );

            for ( pRE = (CStyleRule **)_apRulesList + lIdx, i = lIdx, nRules = _apRulesList.Size();
                  i < nRules; i++, pRE++ )
            {
                (*pRE)->GetRuleID().SetRule( (*pRE)->GetRuleID().GetRule() + 1 );
            }

        }

        // _Track_ the rule in our internal list.  This list lets us enumerate in
        // source order the rules that we've added.  It makes a copy of the rule
        // entry, so it's OK for re to be on the stack.
        if ( ( lIdx < 0 ) || ( lIdx >= _apRulesList.Size() ) )   // Add at the end
            _apRulesList.Append( pRule );
        else
            _apRulesList.Insert( lIdx, pRule );


        // Call back to CStyleSheet so that it has a chance to update OM
        if (!_pManager)
        {
            // only update OM if it is not shared and completed
            // there is no point to update OM since there would be
            // no OM event comes in during parsing.
            Assert( _apSheetsList.Size() == 1 );    // must be a private copy
            int i;
            for (i = 0; i < _apSheetsList.Size(); i++)
            {
                hr = THR(_apSheetsList[i]->OnNewStyleRuleAdded(pRule));
                if (hr)
                    goto Cleanup;
            }
        }

        // index this rule
        hr = THR(IndexStyleRule(pRule, ruleInsert, fDefeatPrevious));
        if (hr)
            goto Cleanup;



        if ( pNextSelector )
        {
            pSiblingRule = new CStyleRule( pNextSelector );
            if ( !pSiblingRule )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Copy the recognized style properties from the original rule's attr array
            pSiblingRule->SetStyleAA(NULL);
            if ( pRule->GetStyleAA())
            {
                CAttrArray  *paa;
                hr = pRule->GetStyleAA()->Clone( &paa );
                if ( hr != S_OK )
                    break;
                pSiblingRule->SetStyleAA(paa);
            }

            // Copy any unknown properties
            //hr = pRule->_uplUnknowns.Duplicate( pSiblingRule->_uplUnknowns );
            //if ( hr != S_OK )
            //  break;
        }

        if ( pNextSelector )
            pRule = pSiblingRule;

    } while ( pNextSelector );

Cleanup:
    WHEN_DBG(Assert(DbgIsValid()));
    RRETURN( hr );

}




//*********************************************************************
//      CSharedStyleSheet::RemoveStyleRule(long lIdx)
//
//*********************************************************************
HRESULT
CSharedStyleSheet::RemoveStyleRule(CStyleRuleID sidRule)
{
    WHEN_DBG( Assert(DbgIsValid()) );

    HRESULT  hr = S_OK;
    CStyleRule **pRE;
    int i;
    CStyleRule *pRule;
    unsigned long lRule = sidRule.GetRule();

    if (lRule <= 0 || lRule > (unsigned long)_apRulesList.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Call back to CStyleSheet so that it has a chance to update OM
    if (!_pManager)
    {
        Assert( _apSheetsList.Size() == 1 );    // must be a private copy
        for (i = 0; i < _apSheetsList.Size(); i++)
        {
            hr = THR(_apSheetsList[i]->OnStyleRuleRemoved(sidRule));
            if (hr)
                goto Cleanup;
        }
    }

    // re-index
    hr = THR(IndexStyleRule(_apRulesList[lRule - 1], ruleRemove, FALSE));
    if (hr)
        goto Cleanup;

    // Shift Down all the IDs
    for (pRE = (CStyleRule **)_apRulesList+lRule, i=lRule;
         i < _apRulesList.Size();
         i++, pRE++
         )
    {
        Assert( (*pRE)->GetRuleID().GetRule() > 0);
        (*pRE)->GetRuleID().SetRule( (*pRE)->GetRuleID().GetRule() - 1);
    }

    // release all the resources we are holding on to...
    pRule = _apRulesList[lRule-1];
    Assert(pRule);
    pRule->Free();
    delete pRule;
    // remove it from the collection
    _apRulesList.Delete(lRule - 1);

Cleanup:
    WHEN_DBG(Assert(DbgIsValid()));
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::IndexStyleRule()
//  Index Style Rules. Should only be called by CSharedStyleSheet::AddStyleRule().  Since rules
//  are actually stored by CSSS's, this exposes that ability.
//*********************************************************************
HRESULT
CSharedStyleSheet::IndexStyleRule(CStyleRule *pRule, ERulesShiftAction eAction, BOOL fDefeatPrevious)
{
    HRESULT hr = S_OK;

    int iIndex;
    BOOL  fInserted     = FALSE;
    BOOL  fRemoved      = FALSE;
    BOOL  *pfProcessed  = (eAction == ruleInsert? &fInserted : &fRemoved);

    if (pRule->GetSelector()->_cstrID.Length())
    {
        CClassIDStr cmpKey;
        DWORD dwHash, dwKey;
        CStyleRuleArray *pHashRules;
        BOOL    fFound;

        dwHash = HashStringCiDetectW(pRule->GetSelector()->_cstrID, pRule->GetSelector()->_cstrID.Length(), 0);
        dwKey = dwHash << 2;
        dwKey = FormalizeHashKey(dwKey);

        cmpKey._eType = eID;
        cmpKey._strClassID = pRule->GetSelector()->_cstrID;
        cmpKey._nClassIDLen = pRule->GetSelector()->_cstrID.Length();

        fFound = !_htIdSelectors.LookupSlow(ULongToPtr(dwKey), (void *)&cmpKey, (void **)&pHashRules);

        switch (eAction)
        {
        case ruleInsert:
            if (!fFound)
            {
                // Create New
                pHashRules = new CStyleRuleArray;

                if (!pHashRules)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

#if DBG==1
                hr = _htIdSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules, (void *)&cmpKey);
#else
                hr = _htIdSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules);
#endif
                if (hr)
                {
                    // could not insert in hash table, but created new above, so get rid of it
                    Assert(pHashRules);
                    delete pHashRules;
                    goto Cleanup;
                }
            }

            hr = pHashRules->Append(pRule);
            if (hr)
                goto Cleanup;

            //
            // We don't want both class Hash and ID Hash
            // if the rule have both Class and ID
            //
            fInserted = TRUE;
            break;


       case ruleRemove:
            if (fFound)
            {
                if (pHashRules->Size() == 1)
                {
                    if (pHashRules != _htIdSelectors.Remove(ULongToPtr(dwKey), (void *)&cmpKey))
                    {
                        Assert(FALSE);
                    }
                    pHashRules->Free();
                    delete pHashRules;
                }
                else
                {
                    pHashRules->RemoveStyleRule(pRule, NULL);
                }
                fRemoved = TRUE;
            }

            break;
       }// end-switch
    } // end id hash table


    if (!(*pfProcessed) && pRule->GetSelector()->_cstrClass.Length())
    {
        CClassIDStr cmpKey;
        DWORD dwHash, dwKey;
        CStyleRuleArray *pHashRules;
        BOOL        fFound;

        dwHash = pRule->GetSelector()->_dwStrClassHash;
        dwKey = dwHash << 2;
        dwKey = FormalizeHashKey(dwKey);

        cmpKey._eType = eClass;
        cmpKey._strClassID = pRule->GetSelector()->_cstrClass;
        cmpKey._nClassIDLen = pRule->GetSelector()->_cstrClass.Length();

        fFound = !_htClassSelectors.LookupSlow(ULongToPtr(dwKey), (void *)&cmpKey, (void **)&pHashRules);

        switch (eAction)
        {
        case ruleInsert:
            if (!fFound)
            {
                // Create New
                pHashRules = new CStyleRuleArray;

                if (!pHashRules)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
#if DBG==1
                hr = _htClassSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules, (void *)&cmpKey);
#else
                hr = _htClassSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules);
#endif
                if (hr)
                {
                    // could not insert in hash table, but created new above, so get rid of it
                    Assert(pHashRules);
                    delete pHashRules;
                    goto Cleanup;
                }
            }

            hr = pHashRules->Append(pRule);
            if (hr)
                goto Cleanup;
            fInserted = TRUE;
            break;


        case ruleRemove:
            if (fFound)
            {
                if (pHashRules->Size() == 1)
                {
                    if (pHashRules != _htClassSelectors.Remove(ULongToPtr(dwKey), (void *)&cmpKey))
                    {
                        Assert(FALSE);
                    }
                    pHashRules->Free();
                    delete pHashRules;
                }
                else
                {
                    pHashRules->RemoveStyleRule(pRule, NULL);
                }
                fRemoved = TRUE;
            }
            break;
        } // end switch
    }// end class hash table


    if (!(*pfProcessed))
    {
        Assert( "Must have index array allocated to add index!" && _pRulesArrays );

        CStyleRuleArray * pRA = &(_pRulesArrays[ pRule->GetElementTag() ]);
        if (eAction == ruleInsert)
            hr = pRA->InsertStyleRule( pRule, fDefeatPrevious, &iIndex );
        else
            hr = pRA->RemoveStyleRule(pRule, &iIndex);
        if (hr)
            goto Cleanup;
        WHEN_DBG( (*pfProcessed) = TRUE );
    }

Cleanup:
    Assert( (*pfProcessed) );
    RRETURN(hr);
}




// ascending order
WHEN_NOT_DBG(inline)
HRESULT InsertProbableRule(CRules &cwRules, CStyleRule *pRule, CStyleSheetID sidSheet)
{
    HRESULT     hr = S_OK;

#ifndef CSSSHARE_NOPRESORT
    CStyleSheetRuleID   sidSheetRuleID;
    DWORD               sp;

    Assert(pRule);
    sidSheetRuleID  = sidSheet;
    sidSheetRuleID.SetRule(pRule->GetRuleID());
    sp = pRule->GetSpecificity();

    int lBound  = 0;
    int uBound  = cwRules.Size();
    int nMedian = 0;

    while (lBound < uBound)
    {
        nMedian = (lBound + uBound) >> 1;
        CProbableRuleEntry *pElem  = ((CProbableRuleEntry *)cwRules) + nMedian;
        DWORD spElem = pElem->_pRule->GetSpecificity();

        if (spElem == sp)
        {
            if (pElem->_sidSheetRule < sidSheetRuleID)
            {
                lBound  = nMedian + 1;
                nMedian++;
            }
            else if (pElem->_sidSheetRule > sidSheetRuleID)
            {
                uBound   = nMedian;
            }
            else
            {
                // we found the same rule simply return
                goto Cleanup;
            }
        }
        else  if (spElem > sp)
        {
            uBound  = nMedian;
        }
        else    // spElem < sp
        {
            lBound  = nMedian + 1;
            nMedian++;
        }
    }

    Assert( nMedian >= 0);
    hr = cwRules.InsertIndirect(nMedian, NULL);
    if (!hr)
    {
        cwRules[nMedian]._pRule = pRule;
        cwRules[nMedian]._sidSheetRule = sidSheetRuleID;
    }

#else

    CProbableRuleEntry  *pElem;
    cwRules.AppendIndirect(NULL, &pElem);
    pElem->_pRule = pRule;
    pElem->_sidSheetRule = sidSheet;
    pElem->_sidSheetRule.SetRule( pRule->GetRuleID() );
#endif

Cleanup:
    return hr;
}


//*********************************************************************
//      CSharedStyleSheet::AppendListOfProbableRules()
//              This method checks all the style rules in this style sheet
//  to build a list of applicable rules to a given element
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendListOfProbableRules(
        CStyleSheetID sidSheet,
        CTreeNode *pNode,
        CProbableRules *ppr,
        CClassIDStr *pclsStrLink,
        CClassIDStr *pidStr,
        BOOL fRecursiveCall
        )
{
    Assert(pNode);
    Assert(ppr);

    HRESULT  hr = S_OK;
    CStyleRule   *pRule;
    CElement *pElement = pNode->Element();
    // Save the pointer for later use
    CClassIDStr *pclsStrLink2 = pclsStrLink;

    while (pclsStrLink)
    {
        CStyleRuleArray *pHashRules;
        CStyleRule      *pRule;

        if (!_htClassSelectors.LookupSlow(ULongToPtr(pclsStrLink->_dwHashKey), (void *)(pclsStrLink),(void **)&pHashRules))
        {
            for (int i = 0; i < pHashRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pHashRules->Deref(sizeof(CStyleRule *), i));
                if (!pRule->GetSelector()->_fSelectorErr)
                {
                    if (pRule->GetElementTag() == pElement->TagType())
                    {
                        // If the Rule found has both a class and an ID,
                        // then make sure the element has that class and ID
                        // as well, or this rule should not apply.
                        if (!pRule->GetSelector()->_cstrID.Length() ||
                                (pidStr &&
                                    (pRule->GetSelector()->_fIsStrictCSS1 ?
                                         _tcsequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                         : _tcsiequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                    )
                                )
                           )
                        {
                            InsertProbableRule(ppr->_cRules, pRule, sidSheet);
                        }
                    }
                    else if (pRule->GetElementTag() == ETAG_UNKNOWN)
                    {
                        // Look at the comment above.
                        if (!pRule->GetSelector()->_cstrID.Length() ||
                                (pidStr &&
                                    (pRule->GetSelector()->_fIsStrictCSS1 ?
                                         _tcsequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                         : _tcsiequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                    )
                                )
                           )
                        {
                            InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
                        }
                    }
                }
            }
        }
        pclsStrLink = pclsStrLink->_pNext;
    }

    if (pidStr)
    {
        CStyleRuleArray *pHashRules;
        CStyleRule      *pRule;
        CStyleSelector  *pSelector;

        if (!_htIdSelectors.LookupSlow(ULongToPtr(pidStr->_dwHashKey), (void *)pidStr, (void **)&pHashRules))
        {
            for (int i = 0; i < pHashRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pHashRules->Deref(sizeof(CStyleRule *), i));
                pSelector = pRule->GetSelector();
                if (!pSelector->_fSelectorErr)
                {
                    // fNeedToBeApplied determines if the current rule needs to be applied to the element. There are two cases:
                    // (1) The rule does _not_ have a class selector. In this case it must be applied because it matches
                    // the id attribute of the element (otherwise we wouldn't be here).
                    // (2) The rule has a class selector. Then it is applied if and only if the class selector is a member
                    // of the class attribute set of the element.
                    BOOL fNeedToBeApplied = FALSE;
                    if (pSelector->_cstrClass.Length())
                    { // This rule has a class selector, check that it is in the class attribute of the element
                        for ( ; pclsStrLink2;  pclsStrLink2 = pclsStrLink2->_pNext)
                        {
                            if (pSelector->_fIsStrictCSS1 ?
                                    !_tcsncmp(pSelector->_cstrClass,
                                              pSelector->_cstrClass.Length(),
                                              pclsStrLink2->_strClassID,
                                              pclsStrLink2->_nClassIDLen)
                                    : !_tcsnicmp(pSelector->_cstrClass,
                                                 pSelector->_cstrClass.Length(),
                                                 pclsStrLink2->_strClassID,
                                                 pclsStrLink2->_nClassIDLen)
                               )
                            {
                                fNeedToBeApplied = TRUE;
                                // Finding one class selector is enough ("OR")
                                break;
                            }
                        }
                    }
                    else
                    { // This rule does not have a class selector, so apply it
                        fNeedToBeApplied = TRUE;
                    }

                    if (fNeedToBeApplied)
                    {
                        if (pRule->GetElementTag() == pElement->TagType())
                        {
                            InsertProbableRule(ppr->_cRules, pRule, sidSheet);
                        }
                        else if (pRule->GetElementTag() == ETAG_UNKNOWN)
                        {
                            InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
                        }
                    }
                }
            }
        }
    }

    {
        ELEMENT_TAG etag = pElement->TagType();
        CStyleRuleArray *pTagRules = &_pRulesArrays[etag];

        if (pTagRules)
        {
            for (int i = 0; i < pTagRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pTagRules->Deref(sizeof(CStyleRule *), i));
                Assert(!pRule->GetSelector()->_cstrClass.Length() && !pRule->GetSelector()->_cstrID.Length());
                InsertProbableRule(ppr->_cRules, pRule, sidSheet);
            }
        }
    }

    // Look at wildcard rules
    {
        CStyleRuleArray *pWCRules = &_pRulesArrays[ETAG_UNKNOWN];

        if (pWCRules)
        {
            for (int i = 0; i < pWCRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pWCRules->Deref(sizeof(CStyleRule *), i));
                Assert(!pRule->GetSelector()->_cstrClass.Length() && !pRule->GetSelector()->_cstrID.Length());
                InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
           }
        }
    }

    RRETURN(hr);
}


BOOL
CSharedStyleSheet::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )
{
    AssertSz( pStyleInfo, "NULL styleinfo!" );
    AssertSz( pStyleInfo->_pNodeContext, "NULL node context!" );
    CElement *pElem = pStyleInfo->_pNodeContext->Element();
    AssertSz( pElem, "NULL element!" );

   // Begin walking rules..

    // Cache for class and ID of this element and potentially its parents
    CStyleClassIDCache CIDCache;
    EPseudoclass eOldClass = pclassLink;
    EPseudoclass eNewClass = pclassLink;

    // Set up the pseudoclass types
    if ( fActive )
        eNewClass = pclassActive;
    else if ( fVisited )
        eNewClass = pclassVisited;

    if ( fOldActive )
        eOldClass = pclassActive;
    else if ( fOldVisited )
        eOldClass = pclassVisited;

    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            if ( (*pSR)->GetElementTag() == pElem->Tag() || (*pSR)->GetElementTag() == ETAG_UNKNOWN)
            {
                if ( (*pSR)->GetSelector()->Match( pStyleInfo, APPLY_All, &CIDCache, &eNewClass )^
                     (*pSR)->GetSelector()->Match( pStyleInfo, APPLY_All, &CIDCache, &eOldClass ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
}


//*********************************************************************
//      CSharedStyleSheet::GetString()
//              Serialization
//*********************************************************************
HRESULT CSharedStyleSheet::GetString( CBase *pBase, CStr *pResult )
{

    {
        // Handle @import
        CImportedStyleSheetEntry    *pRE;
        int n;
        for (pRE = _apImportedStyleSheets, n = _apImportedStyleSheets.Size();
             n > 0;
             n--, pRE++
             )
        {
            pResult->Append( _T("@import url( ") );
            pResult->Append( pRE->_cstrImportHref );
            pResult->Append( _T(" );\r\n") );
        }
    }

    {
        // Handle @font
        int nFonts = _apFontBlocks.Size();
        CAtFontBlock    *pAtFont;
        for(int i=0; i < nFonts; i++ )
        {
            LPCTSTR pcszURL = NULL;

            pAtFont = _apFontBlocks[i];
            Assert(pAtFont && pAtFont->_pAA);
            pAtFont->_pAA->FindString ( DISPID_A_FONTFACESRC, &pcszURL );
            pResult->Append( _T("@font-face {\r\n\tfont-family: ") );
            pResult->Append( pAtFont->_pszFaceName );
            if ( pcszURL )
            {
                pResult->Append( _T(";\r\n\tsrc:url(") );
                pResult->Append( pcszURL );
                pResult->Append( _T(")") );
            }
            pResult->Append( _T(";\r\n}\r\n") );
        }
    }


    // Handle @page rules
    {
        HRESULT hr = S_OK;
        CAttrArray *pAA = NULL;
        const CAttrValue *pAV = NULL;
        int iLen;
        int idx;
        LPCTSTR lpPropName = NULL;
        LPCTSTR lpPropValue = NULL;
        BSTR bstrTemp = NULL;
        long nPageRules = _apPageBlocks.Size();
        CAtPageBlock *pPage = NULL;

        for (int i=0 ; i < nPageRules ; ++i )
        {
            pPage = _apPageBlocks[i];
            pAA = pPage->_pAA;

            pResult->Append( _T("@page ") );
            pResult->Append( pPage->_cstrSelectorText );
            if ( pPage->_cstrPseudoClassText.Length() )
            {
                pResult->Append( _T(":") );
                pResult->Append( pPage->_cstrPseudoClassText );
            }
            pResult->Append( _T(" {") );

            // Dump expandos
            // NB (JHarding): For an empty rule, ie
            // @page {}
            // pPage->_pAA is NULL.
            if( pAA )
            {
                pAV = (CAttrValue *)(*pAA);
                iLen = pAA->Size();
                for ( idx=0; idx < iLen; idx++ )
                {
                    if ((pAV->AAType() == CAttrValue::AA_Expando))
                    {
                        hr = pBase->GetExpandoName( pAV->GetDISPID(), &lpPropName );
                        if (hr)
                            continue;

                        if ( pAV->GetIntoString( &bstrTemp, &lpPropValue ) )
                            continue;   // Can't convert to string

                        pResult->Append( lpPropName );
                        pResult->Append( _T(": ") );
                        pResult->Append( lpPropValue );
                        if ( bstrTemp )
                        {
                            SysFreeString ( bstrTemp );
                            bstrTemp = NULL;
                        }
                        pResult->Append( _T("; ") );
                    }
                    pAV++;
                }
            }
            pResult->Append( _T("}\r\n") );
        }
    }


    {
        // Handle rules
        CStyleRule *pRule;
        CStyleRule **pRE;
        int i, nRules;


        DWORD           dwPrevMedia = (DWORD)MEDIA_NotSet;
        DWORD           dwCurMedia;
        CBufferedStr    strMediaString;

        // Handle rules.
        for ( pRE = _apRulesList, i = 0, nRules = _apRulesList.Size();
              i < nRules; i++, pRE++ )
        {
            pRule = (*pRE);
            if ( pRule )
            {
                // Write the media type string if it has changed from previous rule
                dwCurMedia = pRule->GetLastAtMediaTypeBits();
                if(dwCurMedia != MEDIA_NotSet)
                {
                    if(dwCurMedia != dwPrevMedia)
                    {
                        // Media type has changed, close the previous if needed and open a new one
                        if(dwPrevMedia != MEDIA_NotSet)
                            pResult->Append( _T("\r\n}\r\n") );

                        pResult->Append( _T("\r\n@media ") );
                        pRule->GetMediaString(dwCurMedia, &strMediaString);
                        pResult->Append(strMediaString);
                        pResult->Append( _T("    \r\n{\r\n") );
                    }
                }
                else
                {
                    // Close the old one if it is there
                    if(dwPrevMedia != MEDIA_NotSet)
                        pResult->Append( _T("    }\r\n") );
                }

                // Save the new namespace as the current one
                dwPrevMedia = dwCurMedia;

                // Now append the rest of the rule
                pRule->GetString( pBase, pResult );
            }
        }

        // If we have not closed the last namespace, close it
        if(dwPrevMedia != MEDIA_NotSet)
            pResult->Append( _T("\r\n}\r\n") );
    }

    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::AppendFontFace()
// Note: Add a CAtPageBlock into our collection
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendFontFace(CAtFontBlock *pAtFont)
{
    Assert(pAtFont);
    _apFontBlocks.Append(pAtFont);
    pAtFont->AddRef();
    return S_OK;
}





//*********************************************************************
//      CSharedStyleSheet::AppendPage()
// Note: Add a CAtPageBlock into our collection
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendPage(CAtPageBlock *pAtPage)
{
    Assert(pAtPage);
    _apPageBlocks.Append(pAtPage);
    pAtPage->AddRef();
    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::DbgIsValid()
//  Debug functions
//*********************************************************************
#if DBG==1
BOOL
CSharedStyleSheet::DbgIsValid()
{
    // check to make sure all the rules are valid
    if(IsTagEnabled(tagSharedStyleSheet))
    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            // valid _sidRule is relative id -- no sheetid contained
            if ( (*pSR)->GetRuleID().GetSheet() != 0)
            {
                TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to sheetid in rule [%d]", z) );
                goto Error;
            }

            // valid rules are positioned correctly
            if ( (*pSR)->GetRuleID().GetRule() != (unsigned int)(z+1) )
            {
                TraceTag( (tagSharedStyleSheet,  "CSharedStyleSheet: invalid due to vaild rule [%d] in wrong position [%d]", (*pSR)->GetRuleID().GetRule(), z) );
                goto Error;
            }

            // any rule should only be referenced once and only once
            // in the indexed rule array and the hash tables
            if ( !ExistsOnceInRulesArrays( (*pSR) ) )
            {
                TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to !exist once and only once in indexes") );
                goto Error;
            }
        }
    }

    // Now, for every rule in the indexed array , make sure it shows up in
    // the style sheet once and only once
    if(IsTagEnabled(tagSharedStyleSheet))
    {
        for (int iRA=0 ; iRA < ETAG_LAST ; ++iRA)
        {
            CStyleRuleArray *pRA = &(_pRulesArrays[iRA]);
            int nRules = pRA->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pRA->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }

            }
        }

        //
        // Check validity of the hash tables
        //
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }
            }
        }

        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }

            }
        }
    }

    return TRUE;
Error:
    Assert( FALSE && "CSharedStyleSheet - DbgIsValid FALSE!");
    return FALSE;
}


BOOL
CSharedStyleSheet::ExistsOnceInRulesArrays( CStyleRule * pRule )
{
    BOOL fFound = FALSE;

    int iRA;
    for (iRA=0 ; iRA < ETAG_LAST ; ++iRA)
    {
        CStyleRuleArray *pRA = &(_pRulesArrays[iRA]);
        int nRules = pRA->Size();
        int iRule;
        CStyleRule * pRuleCompare;

        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            pRuleCompare = pRA->Item(iRule);

            if (pRuleCompare == pRule)
            {
                if (fFound)
                    return FALSE; // multiple times
                fFound = TRUE;
            }
        }
    }

    // see if this also exist in hash tables
    {
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (pR == pRule)
                {
                    if (fFound)
                        return FALSE;   // multiple times
                    fFound = TRUE;
                }
            }
        }

        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (pR == pRule)
                {
                    if (fFound)
                        return FALSE;   // multiple times
                    fFound = TRUE;
                }

            }
        }
    }

    return fFound;
}


int
CSharedStyleSheet::OccurancesInStyleSheet( CStyleRule * pRule )
{
    int nFound = 0;
    int iSSR, nSSR;
    CStyleRule * pRuleCompare;
    for (iSSR = 0, nSSR = _apRulesList.Size(); iSSR < nSSR; iSSR++)
    {
        pRuleCompare = _apRulesList[iSSR];

        if (pRuleCompare == pRule)
        {
            nFound++;
        }

    }

    return nFound;
}


VOID
CSharedStyleSheet::Dump(CStyleSheet *pStyleSheet)
{
    Assert(pStyleSheet);
    unsigned long lLevel = pStyleSheet->_sidSheet.FindNestingLevel();
    // check to make sure all the rules are valid
    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            CStr cstr;

            (*pSR)->GetString(pStyleSheet, &cstr);
            WriteChar(g_f, ' ', lLevel * 8 + 2);
            WriteHelp(g_f, _T("(<0d>)<1s>\r\n "), (*pSR)->GetRuleID().GetRule(),cstr);
        }
    }



}
#endif


//---------------------------------------------------------------------
//  Class Declaration:  CAtPageBlock
//      This class implements a parsed page block - it managers all
//  the properties in an @page block
//---------------------------------------------------------------------

//*********************************************************************
//      CAtPageBlock::CAtPageBlock()
// Note: _pAA is created by CStyleSheetPage
//
//*********************************************************************
CAtPageBlock::CAtPageBlock()
    :
    _cstrSelectorText(),
    _cstrPseudoClassText(),
    _pAA(NULL),
    _ulRefs(1)
{

}


CAtPageBlock::~CAtPageBlock()
{
    // free should have been called
    Assert(_pAA == NULL);
}


void CAtPageBlock::Free(void)
{
    if (_pAA)
    {
        delete _pAA;
        _pAA = NULL;
    }
}


HRESULT
CAtPageBlock::Clone(CAtPageBlock **ppAtPage)
{
    HRESULT  hr = S_OK;

    hr = Create(ppAtPage);
    if (hr)
        goto Cleanup;

    if (_pAA)
    {
        hr = _pAA->Clone( &(*ppAtPage)->_pAA );
        if (hr)
            goto Cleanup;
    }

    (*ppAtPage)->_cstrSelectorText.Set(_cstrSelectorText);
    (*ppAtPage)->_cstrPseudoClassText.Set(_cstrPseudoClassText);

Cleanup:
    RRETURN(hr);
}


HRESULT
CAtPageBlock::Create(CAtPageBlock **ppAtPgBlk)
{
    HRESULT  hr = S_OK;

    Assert( ppAtPgBlk );
    *ppAtPgBlk = new CAtPageBlock();
    if (!*ppAtPgBlk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppAtPgBlk)->_pAA = new CAttrArray;
    if (!(*ppAtPgBlk)->_pAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        if (*ppAtPgBlk)
        {
            (*ppAtPgBlk)->Free();
            delete *ppAtPgBlk;
            *ppAtPgBlk = NULL;
        }
    }
    return hr;
}




//---------------------------------------------------------------------
//  Class Declaration:  CAtFontBlock
//      This class implements a parsed/downloaded font block -
//---------------------------------------------------------------------

//*********************************************************************
//      CAtFontBlock::CAtFontBlock()
// Note: _pAA is created by CStyleSheetPage
//
//*********************************************************************
CAtFontBlock::CAtFontBlock()
    :
    _pszFaceName(NULL),
    _pAA(NULL),
    _ulRefs(1)
{
}


CAtFontBlock::~CAtFontBlock()
{
    // free should have been called
    Assert(_pAA == NULL);
    Assert(_pszFaceName == NULL);
}


void CAtFontBlock::Free(void)
{
    if (_pAA)
    {
        delete _pAA;
        _pAA = NULL;
    }

    if ( _pszFaceName )
      MemFree( _pszFaceName ); //free
    _pszFaceName = NULL;
}



HRESULT
CAtFontBlock::Clone(CAtFontBlock **ppAtFont)
{
    //
    // TODO: this only works if CAtFontBlock is
    // read only. Needs further consideration!
    //
    this->AddRef();
    *ppAtFont = this;

    return S_OK;
}


HRESULT
CAtFontBlock::Create(CAtFontBlock **ppAtFontBlock, LPCTSTR pcszFaceName)
{
    HRESULT  hr = S_OK;

    Assert( ppAtFontBlock );
    *ppAtFontBlock = new CAtFontBlock();

    if (!*ppAtFontBlock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppAtFontBlock)->_pAA = new CAttrArray;
    if (!(*ppAtFontBlock)->_pAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( pcszFaceName )
    {

        hr = THR( MemAllocString(Mt(CAtFontBlock), pcszFaceName, &((*ppAtFontBlock)->_pszFaceName)) );
    }

Cleanup:
    if (hr)
    {
        if (*ppAtFontBlock)
        {
            (*ppAtFontBlock)->Free();
            delete *ppAtFontBlock;
            *ppAtFontBlock = NULL;
        }
    }
    RRETURN(hr);
}



//---------------------------------------------------------------------
//  Class Declaration:  CSharedStyleSheetsManager
//      This class managers all the shared style sheets
//---------------------------------------------------------------------
//*********************************************************************
//      CSharedStyleSheetsManager::CSharedStyleSheetsManager
//
//*********************************************************************
CSharedStyleSheetsManager::CSharedStyleSheetsManager(CDoc *pDoc)
{
#ifdef CSSS_MT
    memset(&_cs, 0, sizeof(CRITICAL_SECTION));
#endif
    _pDoc = pDoc;
}


HRESULT
CSharedStyleSheetsManager::Create(CSharedStyleSheetsManager **ppSSSM, CDoc *pDoc)
{
    HRESULT hr = S_OK;
    Assert(ppSSSM);
    (*ppSSSM) = new CSharedStyleSheetsManager(pDoc);
    if (!(*ppSSSM))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifdef CSSS_MT
    hr = THR(HrInitializeCriticalSection( &((*ppSSSM)->_cs) ));
#endif

Cleanup:
    RRETURN(hr);
}


CSharedStyleSheetsManager::~CSharedStyleSheetsManager()
{
#ifdef CSSS_MT
    DeleteCriticalSection(&_cs);
#endif

    //
    // If someone holds a reference to the style sheet after
    // the DOC is gone, we have to disconnect it with 
    // this manager. 
    //
    CSharedStyleSheet **pAry;
    int n;
    for (n = _apSheets.Size(), pAry = _apSheets;
         n > 0;
         n--, pAry++
        )
    {
        Assert( (*pAry) 
                && !(*pAry)->_fInvalid 
                && !(*pAry)->_fModified 
                );
        (*pAry)->_pManager = NULL;
        TraceTag( (tagWarning, "SharedStyleSheetsManager goes away while its shared style sheets are still alive [%p]",(*pAry)) );
    }
}




#ifdef CSSS_MT
HRESULT
CSharedStyleSheetsManager::Enter()
{
    HRESULT  hr = S_OK;

    __try
    {
        TraceTag( (tagSharedStyleSheet, "[%p] -- try enter CS by tid [0x%x]", this, GetCurrentThreadId()) );
        ::EnterCriticalSection(&_cs);
        TraceTag( (tagSharedStyleSheet, "[%p] -- entered CS by tid [0x%x]", this, GetCurrentThreadId()) );

    } __except(GetExceptionCode() == STATUS_INVALID_HANDLE)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
CSharedStyleSheetsManager::Leave()
{
    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheetsManager [%p] -- leavingr CS by tid [0x%x]", this, GetCurrentThreadId()) );
    LeaveCriticalSection(&_cs);
    return S_OK;
}
#endif



#if  DBG == 1
BOOL
CSharedStyleSheetsManager::DbgIsValid()
{
    CSharedStyleSheet **pAry;
    int n;
    for (n = _apSheets.Size(), pAry = _apSheets;
         n > 0;
         n--, pAry++
        )
    {

        Assert( (*pAry)
                && !(*pAry)->_fInvalid
                && !(*pAry)->_fModified
                );
        {
            int z;
            int nFound = 0;
            for (z = 0; z < _apSheets.Size(); z++)
            {
                if (_apSheets[z] == (*pAry))
                    nFound++;
            }
            if (nFound != 1)
            {
                Assert( FALSE &&  "CSharedStyleSheetsManager : more than one copy of [%p] exist in shared array!");
                return FALSE;
            }
        }
    }

    return TRUE;
}


VOID
CSharedStyleSheetsManager::Dump()
{
    if (!InitDumpFile( TRUE ))
        return;

    CSharedStyleSheet **pAry;
    int n;
    for (n = 0, pAry = _apSheets;
         n < _apSheets.Size();
         n++, pAry++
        )
    {
        CStr        strRule;
        CHAR        szBuffer[1024];
        WideCharToMultiByte(CP_ACP, 0, (*pAry)->_achAbsoluteHref, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        TraceTag( (tagSharedStyleSheet, "[%2d]-%s", n, szBuffer) );

        WriteHelp(g_f, _T("<0d>-<1s>\r\n"), n, (*pAry)->_achAbsoluteHref);
    }

    CloseDumpFile();
}

#endif


//*********************************************************************
//      CSharedStyleSheetsManager::AddSharedStyleSheet
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::AddSharedStyleSheet(CSharedStyleSheet *pSSS)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    HRESULT  hr = S_OK;

    Assert( DbgIsValid() );

    if (_apSheets.Find(pSSS) > 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_apSheets.Append(pSSS));
    if (!hr)
    {
        pSSS->_pManager = this;
    }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheetsManager::RemoveSharedStyleSheet
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::RemoveSharedStyleSheet(CSharedStyleSheet *pSSS)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    Assert( DbgIsValid() );
    Assert( pSSS );
    pSSS->_pManager = NULL;

    if (_apSheets.DeleteByValue(pSSS))
        return S_OK;

    return E_FAIL;
}

//*********************************************************************
//  CSharedStyleSheetsManager::FindSharedStyleSheet
//
// Find one shared style sheet other than the passed in one that can be reused
//
// S_OK:    Find a match -- everything is okay
// S_FALSE: Cannot find a match
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::FindSharedStyleSheet(CSharedStyleSheet **ppSSS, CSharedStyleSheetCtx *pCtx)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    Assert( DbgIsValid() );
    Assert( pCtx && pCtx->_szAbsUrl && pCtx->_pParentElement);
    Assert( ppSSS );

    HRESULT hr = S_FALSE;

    *ppSSS = NULL;

#if DBG == 1
    if (IsTagEnabled(tagSharedStyleSheet))
    {
        Dump();
    }
    {
        CStr        strRule;
        CHAR        szBuffer[1024];
        if (pCtx->_szAbsUrl)
        {
            WideCharToMultiByte(CP_ACP, 0, pCtx->_szAbsUrl, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        }
        else
        {
            szBuffer[0] = '\0';
        }
        TraceTag( (tagSharedStyleSheet, " Try [%s]", szBuffer) );
    }

#endif


    //
    // simply find the first one that matches
    //
    CSharedStyleSheet **pAry;
    int n;

    if ( !(pCtx->_dwFlags & SSS_IGNORESECUREURLVALIDATION) )
    {
        BOOL        fPendingRoot = FALSE;
        CMarkup *   pMarkup = NULL;

        if (pCtx->_pParentElement->IsInMarkup())
        {
            pMarkup = pCtx->_pParentElement->GetMarkup();
            fPendingRoot = pMarkup->IsPendingRoot();
        }
        else
        {
            pMarkup = _pDoc->PrimaryMarkup();
        }

        Assert(pMarkup);

        if (!pMarkup->ValidateSecureUrl(fPendingRoot, pCtx->_szAbsUrl, FALSE, TRUE))
        {
            TraceTag( (tagSharedStyleSheet, "ValidateSecureUrl returned FALSE") );
            goto Cleanup;
        }
    }

    for (n = 0, pAry = _apSheets;
         n <  _apSheets.Size();
         n++, pAry++
        )
    {
        if ( (*pAry)
            && ( !(*pAry)->_fModified )
            && ( (*pAry)->_achAbsoluteHref && pCtx->_szAbsUrl && _tcsequal((*pAry)->_achAbsoluteHref, pCtx->_szAbsUrl)  )
            && ( (*pAry)->_eMediaType == (EMediaType)MEDIATYPE(pCtx->_dwMedia) )
            && ( (!!(*pAry)->_fExpando) == !!pCtx->_fExpando  )
            && ( (!!(*pAry)->_fXMLGeneric) == !!pCtx->_fXMLGeneric  )
            && ( !!(*pAry)->_fIsStrictCSS1 == !!pCtx->_fIsStrictCSS1 )
            && ( ((*pAry)->_cp) == pCtx->_cp )
           )
        {
            BOOL  fFound = TRUE;

            if (!(pCtx->_dwFlags & SSS_IGNORECOMPLETION) )
            {
                if ( !(*pAry)->_fComplete )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching - not completed!") );
                    continue;
                }
            }

            if (!(pCtx->_dwFlags & SSS_IGNOREREFRESH))
            {
                if ( (*pAry)->_dwRefresh != pCtx->_dwRefresh )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching _dwRefresh [%x] - pCtx->_dwRefresh [%x]", (*pAry)->_dwRefresh, pCtx->_dwRefresh) );
                    continue;
                }
            }


            if (!(pCtx->_dwFlags & SSS_IGNOREBINDF))
            {
                if ( ((*pAry)->_dwBindf & BINDF_OFFLINEOPERATION) != (pCtx->_dwBindf & BINDF_OFFLINEOPERATION) )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching _dwBindf [%x] - pCtx->_dwBindf [%x]", (*pAry)->_dwBindf, pCtx->_dwBindf) );
                    continue;
                }
            }

            if ( !(pCtx->_dwFlags & SSS_IGNORELASTMOD) )
            {
                fFound = FALSE;
                if (pCtx->_pft)
                {
                    // this is the match - check to see if it expires...
                    TraceTag( (tagSharedStyleSheet, "timestamp [%d] - FT [%x] [%x]", n, (*pAry)->_ft.dwHighDateTime, (*pAry)->_ft.dwLowDateTime) );
                    TraceTag( (tagSharedStyleSheet, "timestamp target - FT [%x] [%x]", pCtx->_pft->dwHighDateTime, pCtx->_pft->dwLowDateTime) );
                    if (memcmp(&((*pAry)->_ft), &g_Zero, sizeof(FILETIME)) != 0)   // not empty
                    {
                        Assert(pCtx->_pft);
                        if (memcmp(&((*pAry)->_ft), pCtx->_pft, sizeof(FILETIME)) == 0)
                        {
                            Assert( (*pAry) != pCtx->_pSSInDbg );
                            TraceTag( (tagSharedStyleSheet, "Found by matching timestamp!") );

                            fFound = TRUE;
                        }
                    }
                    else
                        TraceTag( (tagSharedStyleSheet, "Warning: Found SS with empty timestamp!") );
                }
            }

            if (fFound)
            {
                *ppSSS = (*pAry);
                WHEN_DBG( InterlockedIncrement( &((*ppSSS)->_lReserveCount) ) );
                (*ppSSS)->AddRef();
                hr  =  S_OK;
                TraceTag( (tagSharedStyleSheet, "Found a good SharedStyleSheet at [%d]", n) );
                goto Cleanup;
            }
        }
    }

    TraceTag( (tagSharedStyleSheet, "Cannot find a matching shared style sheet") );
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//      CSharedStyleSheetsManager::GetUrlTime()
//*********************************************************************
extern HRESULT  CoInternetParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
extern BOOL GetFileLastModTime(TCHAR * pchFile, FILETIME * pftLastMod);

BOOL
GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem)
{
    BOOL  fRet = FALSE;
    Assert( pszAbsUrl );
    {
        // only works for file://
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        HRESULT hr = THR(CoInternetParseUrl(pszAbsUrl, PARSE_PATH_FROM_URL, 0,
                    achPath, ARRAY_SIZE(achPath), &cchPath, 0));

        if (hr == S_OK)
        {
            fRet = GetFileLastModTime(achPath, pt);
        }
    }

#if 0
    if (!fRet)
    {
        extern BOOL GetUrlLastModTime(TCHAR * pchUrl, UINT uScheme, DWORD dwBindf, FILETIME * pftLastMod);
       // this does not work well for APPs
        {
            DWORD    dwBindf = 0;
            UINT     uScheme;
            if (pElem && pElem->IsInMarkup())
            {
                CDwnDoc *pDwnDoc = pElem->GetMarkup()->GetWindowedMarkupContext()->GetDwnDoc();
                if (pDwnDoc)
                {
                    dwBindf = pDwnDoc->GetBindf();
                }
            }

            uScheme = GetUrlScheme(pszAbsUrl);
            fRet = GetUrlLastModTime(const_cast<TCHAR *>(pszAbsUrl), uScheme, dwBindf, pt);
        }
    }
#endif

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltablekb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltablekb.cxx
//
//  Contents:   CTableLayout keyboard methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableRowLayoutPageBreak_aCellChoices_pv, Locals, "CTableRowLayout::PageBreak aCellChoices::_pv")

ExternTag(tagPaginate);

//+-------------------------------------------------------------------------
//
//  Method:     GetCellFromPos
//
//  Synopsis:   Retrun the Cell in the table that is closest to the position.
//
//  Arguments:  [ptPosition] - coordinates of the position
//
//  Returns:    table cell, or NULL if the table is empty or the point is
//              outside of the table
//
//--------------------------------------------------------------------------

CTableCell *
CTableLayout::GetCellFromPos(POINT * pptPosition)
{
    CTableCell  *       pCell = NULL;
    CTableCaption   *   pCaption;
    CTableCaption   **  ppCaption;
    int                 yTop, yBottom;
    int                 xLeft, xRight;
    BOOL                fCaptions;
    BOOL                fBelowRows = FALSE;
    CDispNode         * pDispNode;
    int                 cC;
    int                 x, y;
    CTableRowLayout   * pRowLayout = NULL;
    CPoint              pt;
    
    pDispNode = GetTableInnerDispNode();
    if (!pDispNode)
        return NULL;

    pDispNode->TransformPoint((CPoint&) *pptPosition, COORDSYS_GLOBAL, &pt, COORDSYS_BOX);
    if (pt.y >= 0)
    {
        yTop    =
        yBottom = 0;
        pRowLayout = GetRowLayoutFromPos(pt.y, &yTop, &yBottom, &fBelowRows);
    }
    else
    {
        // may be in the top captions
        pDispNode = GetTableOuterDispNode();
        pDispNode->TransformPoint((CPoint&) *pptPosition, COORDSYS_GLOBAL, &pt, COORDSYS_BOX);
    }
    
    y = pt.y;
    x = pt.x;

    if (pRowLayout)
    {
        int iCol = GetColExtentFromPos(x, &xLeft, &xRight);
        if (iCol >= 0)
        {
            pCell = Cell(pRowLayout->_aryCells[iCol]);
        }
    }
    else
    {
        fCaptions = _aryCaptions.Size();
        if (fCaptions)
        {
            // note: the BOTTOM/TOP captions are mixed in the array of captions
            // but the captions are sorted Y position wise
            for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                 cC > 0;
                 cC--, ppCaption++)
            {
                pCaption = (*ppCaption);
                if ((fBelowRows && pCaption->_uLocation == CTableCaption::CAPTION_BOTTOM) ||
                    (!fBelowRows && pCaption->_uLocation == CTableCaption::CAPTION_TOP))
                {
                    pCell = pCaption;
                    pDispNode = pCaption->Layout()->GetElementDispNode();
                    if (pDispNode)
                    { 
                        RECT rcBound;
                        pDispNode->GetBounds(&rcBound);
                        if (y < rcBound.bottom)
                        {
                            break;  // we found the caption
                        }
                    }
                }
            }
        }

    }
    return pCell;
}


//+----------------------------------------------------------------------------
//
//  Member:     CTableLayout::RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for a table element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CTableLayoutBlock::RegionFromElement(CElement      * pElement,
                                    CDataAry<RECT> * paryRects,
                                    RECT           * prcBound,
                                    DWORD            dwFlags)
{
    CLayoutContext *pLayoutContext    = LayoutContext();
    CTableLayout   *pTableLayoutCache = Table()->TableLayoutCache();
    CRect           rcBound;

    Assert( pElement && paryRects);

    if (!pElement || !paryRects)
        return;

    // Clear the array before filling it.
    paryRects->SetSize(0);

    if(!prcBound)
    {
        prcBound = &rcBound;
    }

    *prcBound = g_Zero.rc;

    // If the element passed is the element that owns this instance, let CLayout handle it.
    if (_pElementOwner == pElement)
    {
        super::RegionFromElement(pElement, paryRects, prcBound, dwFlags);
        return;
    }

    CLayout   * pLayout   = pElement->CurrentlyHasLayoutInContext(pLayoutContext) ? pElement->GetUpdatedLayout(pLayoutContext) : NULL;
    CDispNode * pDispNode = pLayout ? pLayout->GetElementDispNode() : NULL;
    CDispNode * pGridNode = GetTableInnerDispNode();

    if (!pGridNode)
        return;

    if (!pTableLayoutCache->IsTableLayoutCacheCurrent())   // if we are in the middle of modifying the table (and not recacled yet), return
        return;

    // If the element has a displaynode of its own, let it answer itself.
    if (pDispNode)
    {
        pDispNode->GetClientRect(prcBound, CLIENTRECT_CONTENT);
        goto Done;
    }

    // As a start, set the bounding rect to the table grid content area.
    pGridNode->GetClientRect(prcBound, CLIENTRECT_CONTENT);

    switch (pElement->Tag())
    {
    case ETAG_TR:
    {
        AssertSz(pLayout, "Layout MUST exist in the layout context.");

        //  No layout in the context.
        if (!pLayout)
            return;

        CTableRowLayoutBlock * pRowLayout = DYNCAST(CTableRowLayoutBlock, pLayout);
        int yTop = 0, yBottom = 0;
        Assert(pRowLayout);

        Verify(pTableLayoutCache->GetRowTopBottom(pRowLayout->RowPosition(), &yTop, &yBottom));
        prcBound->top = yTop;
        prcBound->bottom = yBottom;
        break;
    }
    case ETAG_THEAD:
    case ETAG_TFOOT:
    case ETAG_TBODY:
    {
        CTableSection * pSection = DYNCAST(CTableSection, pElement);
        int yTop = 0, yBottom = 0;
        Assert(pSection);

        if (!pSection->_cRows)
        {
            *prcBound = g_Zero.rc;
            break;
        }

        Verify(pTableLayoutCache->GetRowTopBottom(pSection->_iRow, &yTop, &yBottom));
        prcBound->top = yTop;

        Verify(pTableLayoutCache->GetRowTopBottom(pSection->_iRow + pSection->_cRows - 1, &yTop, &yBottom));
        prcBound->bottom = yBottom;
        break;
    }
    case ETAG_COLGROUP:
    case ETAG_COL:
    {
        CTableCol * pCol = DYNCAST(CTableCol, pElement);
        int xLeft = 0, xRight = 0;
        Assert(pCol);

        if (!pCol->_cCols || pTableLayoutCache->GetCols() == 0 || pTableLayoutCache->_aryColCalcs.Size() == 0)
        {
            *prcBound = g_Zero.rc;
            break;
        }

        pTableLayoutCache->GetColLeftRight(pCol->_iCol, &xLeft, &xRight);
        prcBound->left = xLeft;
        prcBound->right = xRight;

        // if it is not a spanned column, we are done
        if (pCol->_cCols > 1)
        {
            // if it is a spanned column, get the right coordinate for the last column
            pTableLayoutCache->GetColLeftRight(pCol->_iCol + pCol->_cCols - 1, &xLeft, &xRight);
            prcBound->right = xRight;
        }
        break;
    }
    default:
        // Any other elements return empty rect.
        *prcBound = g_Zero.rc;
        break;
    }

    if (_fHasCaptionDispNode)
        pGridNode->TransformRect((CRect&)*prcBound, COORDSYS_FLOWCONTENT, (CRect *)prcBound, COORDSYS_PARENT);

Done:

    if (dwFlags & RFE_SCREENCOORD)
    {
        TransformRect(prcBound, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    }

    if (!IsRectEmpty(prcBound))
        paryRects->AppendIndirect(prcBound);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetRowTopBottom
//
//  Synopsis:   Obtain the row's y-extent.
//
//  Arguments:  [iRowLocate]  - IN:  index of row to be located
//              [pyRowTop]    - OUT: yTop of row
//              [pyRowBottom] - OUT: yBottom of row
//
//  Note:       Cellspacing is considered OUTSIDE the row.
//
//  Returns:    TRUE if row found.
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::GetRowTopBottom(int iRowLocate, int * pyRowTop, int * pyRowBottom)
{
    CTableRowLayout * pRowLayout;
    int               iRow, cRows = GetRows(), iRowLast;

    Assert(pyRowTop && pyRowBottom);

    if (iRowLocate < 0 || iRowLocate >= cRows)
    {
        *pyRowTop = *pyRowBottom = 0;
        return FALSE;
    }

    Assert(_aryRows[iRowLocate]->RowLayoutCache());

    iRow = GetFirstRow();
    iRowLast = GetLastRow();
    pRowLayout = _aryRows[iRow]->RowLayoutCache();
    *pyRowTop = _yCellSpacing;
    *pyRowBottom = pRowLayout->_yHeight + _yCellSpacing;

    while (iRowLocate != iRow && iRow != iRowLast)
    {
        iRow = GetNextRowSafe(iRow);
        pRowLayout = _aryRows[iRow]->RowLayoutCache();
        *pyRowTop = *pyRowBottom + _yCellSpacing;
        *pyRowBottom += pRowLayout->_yHeight + _yCellSpacing;
    }

    Assert(iRowLocate == iRow);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetColLeftRight
//
//  Synopsis:   Obtain the column's x-extent.
//
//  Arguments:  [iColLocate] - IN:  index of col to be located
//              [pxColLeft]  - OUT: xLeft of col
//              [pxColRight] - OUT: xRight of col
//
//  Note:       Cellspacing is considered OUTSIDE the column.
//
//  Returns:    TRUE if column found.
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::GetColLeftRight(int iColLocate, int * pxColLeft, int * pxColRight)
{
    int iCol = 0, cCols = GetCols(), xWidth;

    Assert (pxColLeft  && pxColRight);

    *pxColLeft = *pxColRight = 0;

    if (_aryColCalcs.Size() != cCols) 
    {
        Assert (FALSE && "we should not reach this code, since we have to be calced at this point");
        return FALSE;
    }

    if (iColLocate < 0 || iColLocate >= cCols)
    {
        return FALSE;
    }

    // NOTE: This code works for RTL as well.
    *pxColLeft  = _xCellSpacing;
    *pxColRight = _aryColCalcs[0]._xWidth + _xCellSpacing;

    while (iColLocate != iCol && iCol < cCols-1)
    {
        xWidth = _aryColCalcs[++iCol]._xWidth;
        *pxColLeft = *pxColRight + _xCellSpacing;
        *pxColRight += xWidth + _xCellSpacing;
    }

    Assert(iColLocate == iCol);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetRowLayoutFromPos
//
//  Synopsis:   Returns the row layout in the table at the y-position and its
//              y-extent.
//
//  Arguments:  [y]           - IN:  y-coordinate of the position
//              [pyRowTop]    - OUT: yTop of row
//              [pyRowBottom] - OUT: yBottom of row
//              [pLayoutContext] - IN: layout context we're searching in
//
//  Returns:    Table row layout, or NULL if the table is empty or y-position
//              is outside the table.  Bottom cellspacing is considered part of
//              the row (i.e. the top cellspacing corresponds to no row).
//
//--------------------------------------------------------------------------

CTableRowLayout *
CTableLayout::GetRowLayoutFromPos(int y, int * pyRowTop, int * pyRowBottom, BOOL *pfBelowRows, CLayoutContext *pLayoutContext /*=NULL*/)
{
    // We have two "row layout"-type ptrs.  We use the "block" internally
    // in this fn because in cases w/ context, the blocks have the height info.
    // However, we always need to return a full CTableRowLayout because callers
    // often expect a real row layout (i.e. one with an _aryCells).
    CTableRowLayoutBlock * pRowLayoutBlock = NULL;
    CTableRowLayout      * pRowLayoutReturned = NULL;
    int                 iRow, cRows = GetRows(), iRowLast;

    Assert(pyRowTop && pyRowBottom);

    *pyRowTop = 0;
    *pyRowBottom = 0;

    if (pfBelowRows)
    {
        *pfBelowRows = FALSE;
    }

    if (!cRows || y<0)
        goto Cleanup;

    iRow          = GetFirstRow();
    iRowLast      = GetLastRow();

    if ( pLayoutContext )
    {
        // If we have context, then we're a layout block that almost certainly
        // doesn't contain all the rows in the table.  Find the first row that
        // exists in this context.
        CTableRow *pTR = _aryRows[iRow];
        while ( iRow <= iRowLast && !pTR->CurrentlyHasLayoutInContext( pLayoutContext ))
        {
            iRow = GetNextRowSafe(iRow);
            pTR = _aryRows[iRow];
        }

        // Either we found a row w/ context, or we ran out of rows.
        // If we found a row w/ context, we're 'successful' and want to continue processing.
        // If we ran out of rows while looking, then bail.

        if ( iRow > iRowLast )
        {
            // Failed to find any rows in this context
            goto Cleanup;
        }
    }

    AssertSz( _aryRows[iRow]->CurrentlyHasLayoutInContext( pLayoutContext ), "Row must have some kind of layout at this point" );

    pRowLayoutReturned = _aryRows[iRow]->RowLayoutCache();
    pRowLayoutBlock = DYNCAST(CTableRowLayoutBlock, _aryRows[iRow]->GetUpdatedLayout(pLayoutContext));

    Assert( !pLayoutContext ? pRowLayoutReturned == pRowLayoutBlock : TRUE );

    *pyRowTop    += _yCellSpacing;
    *pyRowBottom += pRowLayoutBlock->_yHeight + 2*_yCellSpacing; // two cellspacings for first row: above AND below

    while (y >= *pyRowBottom && iRow != iRowLast && ( pLayoutContext ? _aryRows[iRow]->CurrentlyHasLayoutInContext( pLayoutContext ) : TRUE ))
    {
        iRow = GetNextRowSafe(iRow);

        pRowLayoutReturned = _aryRows[iRow]->RowLayoutCache();
        pRowLayoutBlock = DYNCAST(CTableRowLayoutBlock, _aryRows[iRow]->GetUpdatedLayout(pLayoutContext));
        Assert( !pLayoutContext ? pRowLayoutReturned == pRowLayoutBlock : TRUE );

        *pyRowTop = *pyRowBottom;
        *pyRowBottom += pRowLayoutBlock->_yHeight + _yCellSpacing;
    }

    if (pfBelowRows)
    {
        *pfBelowRows = TRUE;
    }

Cleanup:

    return pRowLayoutReturned;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetColExtentFromPos
//
//  Synopsis:   Returns the x-extent of the column in the table at the
//              specified x-position.
//
//  Arguments:  [x]          - IN:  x-coordinate of the position
//              [pxColLead]  - OUT: xLead of column (side on which column begins - 
//                                  left for Left To Right and right for Right To Left)
//              [pyColTrail] - OUT: xTrail of column (side on which column ends -
//                                  right for Left To Right and left for Right To Left)
//              [fRightToLeft] - IN: the table is layed out RTL (origin it top/right)
//
//  Returns:    Column index found located between [*pxColLeft,*pxColRight).
//              Else returns -1.  Uses colcalcs.
//
//--------------------------------------------------------------------------

int
CTableLayout::GetColExtentFromPos(int x, int * pxColLead, int * pxColTrail, BOOL fRightToLeft)
{
    int iCol = 0, cCols = GetCols(), xWidth;

    if (!cCols || (!fRightToLeft ? x<0 : x>0))
        return -1;

    *pxColLead  = _xCellSpacing;

    if(!fRightToLeft)
    {
        *pxColTrail = _aryColCalcs[0]._xWidth + 2*_xCellSpacing;

        while (x >= *pxColTrail && iCol < cCols-1)
        {
            xWidth = _aryColCalcs[++iCol]._xWidth;
            *pxColLead = *pxColTrail;
            *pxColTrail += xWidth + _xCellSpacing;
        }
    }
    else
    {
        *pxColTrail = - _aryColCalcs[0]._xWidth - 2*_xCellSpacing;
        
        while (x <= *pxColTrail && iCol < cCols-1)
        {
            xWidth = _aryColCalcs[++iCol]._xWidth;
            *pxColLead = *pxColTrail;
            *pxColTrail -= xWidth + _xCellSpacing;
        }
    }

    return iCol;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTableLayout::GetHeaderFooterRects
//
//  Synopsis:   Retrieves the global rect of THEAD and TFOOT.
//
//  Arguments:  [prcTableHeader] - OUT: global rect of header
//              [prcTableFooter] - OUT: global rect of footer
//
//  Returns:    Rects if header and footer exist AND are supposed to be
//              repeated.  Empty rects otherwise.
//
//--------------------------------------------------------------------------

void
CTableLayout::GetHeaderFooterRects(RECT * prcTableHeader, RECT * prcTableFooter)
{
    CDispNode * pElemDispNode = GetElementDispNode();
    CDispNode * pDispNode = GetTableInnerDispNode();
    CTableRowLayout * pRowLayout;
    CRect rc, rcInner;
    int iRow;

    if (!pDispNode)
        return;

    Assert(prcTableHeader && prcTableFooter);
    memset(prcTableHeader, 0, sizeof(RECT));
    memset(prcTableFooter, 0, sizeof(RECT));

    // GetBounds returns coordinates in PARENT system.
    pElemDispNode->GetBounds(&rc);
    pElemDispNode->TransformRect(rc, COORDSYS_PARENT, &rc, COORDSYS_GLOBAL);
    rc.left = 0;

    pDispNode->GetClientRect(&rcInner, CLIENTRECT_CONTENT);
    pDispNode->TransformRect(rcInner, COORDSYS_FLOWCONTENT, &rcInner, COORDSYS_GLOBAL);

    if (_pHead && _pHead->_cRows)
    {
        CTreeNode * pNode = _pHead->GetFirstBranch();
        const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;

        // If repeating of table headers is set on THEAD, calculate the rect.
        if (pFF && pFF->_bDisplay == styleDisplayTableHeaderGroup)
        {
            *prcTableHeader = rc;
            prcTableHeader->top = rcInner.top + _yCellSpacing;
            prcTableHeader->bottom = prcTableHeader->top;

            for ( iRow = _pHead->_iRow ; iRow < _pHead->_iRow + _pHead->_cRows ; iRow++ )
            {
                pRowLayout = GetRow(iRow)->RowLayoutCache();
                Assert(pRowLayout);

                prcTableHeader->bottom += _yCellSpacing;
                prcTableHeader->bottom += pRowLayout->_yHeight;
            }
        }
    }

    if (_pFoot && _pFoot->_cRows)
    {
        CTreeNode * pNode = _pFoot->GetFirstBranch();
        const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;

        // If repeating of table footers is set on TFOOT, calculate the rect.
        if (pFF && pFF->_bDisplay == styleDisplayTableFooterGroup)
        {
            *prcTableFooter = rc;
            prcTableFooter->bottom = rcInner.bottom - _yCellSpacing;
            prcTableFooter->top = prcTableFooter->bottom;

            for ( iRow = _pFoot->_iRow ; iRow < _pFoot->_iRow + _pFoot->_cRows ; iRow++ )
            {
                pRowLayout = GetRow(iRow)->RowLayoutCache();
                Assert(pRowLayout);

                prcTableFooter->top -= pRowLayout->_yHeight;
                prcTableFooter->top -= _yCellSpacing;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     GetNextFlowLayout
//
//  Synopsis:   Retrun a cell (if it exists) in the direction specified by
//              iDir.
//
//  Arguments:  [iDir]:       The direction to search in
//              [ptPosition]: The point from where to start looking for a cell
//              [pElementLayout]: The child site from where this call came and to which
//                            the point belongs.
//              [pcp]:        The cp in the new txt site
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite in the direction specified if one exists,
//              NULL otherwise.
//
//--------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                                BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout;

    if (IsCaption(pElementLayout->Tag()))
    {
        pFlowLayout = GetNextFlowLayoutFromCaption(iDir, ptPosition, DYNCAST(CTableCaption, pElementLayout));
    }
    else
    {
        CTableCell *pCell = DYNCAST(CTableCell, pElementLayout);
        int iCol = pCell->ColIndex();
        int iRow = pCell->RowIndex();

        if (iDir == NAVIGATE_UP || iDir == NAVIGATE_DOWN)
        {
            iCol += pCell->ColSpan() - 1;    // if cell is spanned
            if (iDir == NAVIGATE_DOWN)
                iRow += pCell->RowSpan() - 1;
        }

        pFlowLayout = GetNextFlowLayoutFromCell(iDir, ptPosition, iRow, iCol);
    }

    // If we find a table cell then lets find the position we want to be at
    // in that table cell. If we did not find a cell, then pass this call
    // to our parent.
    return pFlowLayout
            ? pFlowLayout->GetPositionInFlowLayout(iDir, ptPosition, pcp, pfCaretNotAtBOL, pfAtLogicalBOL)
            : GetUpdatedParentLayout()->GetNextFlowLayout(iDir, ptPosition, Table(), pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetNextFlowLayout
//
//  Synopsis:   Retrun a cell (if it exists) in the direction specified by
//              iDir.
//
//  Arguments:  [iDir]:       The direction to search in
//              [ptPosition]: The point from where to start looking for a cell
//              [pElementLayout]: The child element (with layout) from where this
//                            call came and to which the point belongs.
//              [pcp]:        The cp in the new txt site
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite in the direction specified if one exists,
//              NULL otherwise.
//
//  Note:       This method just routes the call straight up to the table and
//              passes the incoming child as the child rather than itself.
//
//--------------------------------------------------------------------------

CFlowLayout *
CTableRowLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                                   BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    return TableLayoutCache()->GetNextFlowLayout(iDir, ptPosition, pElementLayout, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayoutFromCell
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [iRow]       -  (current) cell's row number
//              [iCol]       -  (current) cell's column number
//
//-----------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayoutFromCell(NAVIGATE_DIRECTION iDir, POINT ptPosition, int iRow, int iCol)
{
    CPoint ptContent(ptPosition);
    TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
    
    if (ptContent.x < 0 && (iDir == NAVIGATE_UP || iDir == NAVIGATE_DOWN))
    {
        ptContent.x = 0;
    }

    int                 x = ptContent.x;
    CTableCaption   *   pCaption;
    CTableCaption   **  ppCaption;
    int                 cC;
    int                 cRows;
    int                 cCols;
    BOOL                fGoingUp = FALSE;
    CFlowLayout     *   pFlowLayout = NULL;
    CTableCell      *   pCell = NULL;

    if (EnsureTableLayoutCache())
        return NULL;

    
    cRows = GetRows();
    cCols = GetCols();

    //  Note:       iRow could be outside of the _AryRows range by +/-1
    //              iCol could be outside of the _aryColumns range by +/-1
    Assert (iRow >= -1 && iRow <= cRows);
    Assert (iCol >= -1 && iCol <= cCols);

    switch (iDir)
    {
    case NAVIGATE_LEFT:
        while (iRow >= 0 && !pCell)
        {
            while (--iCol >= 0 && !pCell)
            {
                // go to the cell on the left
                pCell = GetCellBy(iRow, iCol);
            }
            // go to the right most cell of the previous row
            iRow = GetPreviousRowSafe(iRow);
            iCol = cCols;
        }
        fGoingUp = TRUE;
        break;

    case NAVIGATE_RIGHT:
        while (iRow < cRows && !pCell)
        {
            while (++iCol < cCols && !pCell)
            {
                // go to the cell on the right
                pCell = GetCellBy(iRow, iCol);

                // If we ended up in the middle of a colspan, walk out of that cell in next iteration.
                // This case is taken care of inside GetCellBy.
            }
            // go to the left most cell of the next row
            iRow = GetNextRowSafe(iRow);
            iCol = -1;
        }
        break;

    case NAVIGATE_UP:
        while ((iRow = GetPreviousRowSafe(iRow)) >= 0 && !pCell)
        {
            AssertSz (IsReal(pCell), "We found a row/colspan");
            pCell = GetCellBy(iRow, iCol, x);
        }
        fGoingUp = TRUE;
        break;

    case NAVIGATE_DOWN:
        while ((iRow = GetNextRowSafe(iRow)) < cRows && !pCell)
        {
            AssertSz (IsReal(pCell), "We found a row/colspan");
            pCell = GetCellBy(iRow, iCol, x);

            // If we ended up in the middle of a rowspan, walk out of that cell in next iteration.
            if (pCell && pCell->RowSpan() > 1 && iRow > pCell->RowIndex())
            {
                Assert(pCell->RowIndex() + pCell->RowSpan() - 1 >= iRow);
                iRow = pCell->RowIndex() + pCell->RowSpan() - 1;
                pCell = NULL;
            }
        }
        break;

    }

    // Get the layout of the real cell.
    if (pCell)
    {
        AssertSz(IsReal(pCell), "We need to have a real cell");
        pFlowLayout = pCell->Layout();
    }

    if (!pFlowLayout && _aryCaptions.Size())
    {
        // note: the BOTTOM/TOP captions are mixed in the array of captions
        // but the captions are sorted Y position wise
        for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
             cC > 0;
             cC--, ppCaption++)
        {
            pCaption = (*ppCaption);
            if (!pCaption->Layout()->NoContent())
            {
                if (fGoingUp)
                {
                    // So we need to take last TOP caption
                    if (pCaption->_uLocation == CTableCaption::CAPTION_TOP)
                    {
                        pFlowLayout = DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                    }
                }
                else
                {
                    // So we need to take first BOTTOM caption
                    if (pCaption->_uLocation == CTableCaption::CAPTION_BOTTOM)
                    {
                        pFlowLayout = DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                        break;
                    }
                }
            }
        }
    }

    return pFlowLayout;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayoutFromCaption
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pCaption]   -  current caption
//
//-----------------------------------------------------------------------------

CFlowLayout *
CTableLayout::GetNextFlowLayoutFromCaption(NAVIGATE_DIRECTION iDir, POINT ptPosition, CTableCaption *pCaption)
{
    unsigned    uLocation = pCaption->_uLocation;   // Caption placing (TOP/BOTTOM)
    int         i, cC, iC;

    if( EnsureTableLayoutCache() )
        return NULL;

    cC = _aryCaptions.Size();
    iC = _aryCaptions.Find(pCaption);
    Assert (iC >=0 && iC < cC);

    switch (iDir)
    {
    case NAVIGATE_LEFT:
    case NAVIGATE_UP:
        for (i = iC - 1; i >= 0; i--)
        {
            pCaption = _aryCaptions[i];
            if (!pCaption->Layout()->NoContent())
            {
                if (pCaption->_uLocation == uLocation)
                {
                    return DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                }
            }
        }
        if (uLocation == CTableCaption::CAPTION_BOTTOM)
        {
            return GetNextFlowLayoutFromCell(iDir, ptPosition, GetRows(), 0);
        }
        break;
    case NAVIGATE_RIGHT:
    case NAVIGATE_DOWN:
        for (i = iC + 1; i < cC; i++)
        {
            pCaption = _aryCaptions[i];
            if (!pCaption->Layout()->NoContent())
            {
                if (pCaption->_uLocation == uLocation)
                {
                    return DYNCAST(CFlowLayout, pCaption->GetUpdatedLayout());
                }
            }
        }
        if (uLocation == CTableCaption::CAPTION_TOP)
        {
            return GetNextFlowLayoutFromCell(iDir, ptPosition, -1, GetCols());
        }
        break;

    }

    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetCellBy
//
//  Synopsis:   get the cell from the specified row and from the specified column
//              that is positioned under the specified X-position.
//
//  Arguments:  iRow     - row
//              iCol     - column
//              X        - x position
//
//-----------------------------------------------------------------------------

CTableCell *
CTableLayout::GetCellBy(int iRow, int iCol, int x)
{
    CTableCell  *pCell = NULL;
    CTableRow   *pRow;

    Assert(IsTableLayoutCacheCurrent());

    int xLeft, xRight;
    iCol = GetColExtentFromPos(x, &xLeft, &xRight);

    while (iCol >= 0)
    {
        pRow = _aryRows[iRow];
        pCell = pRow->RowLayoutCache()->_aryCells[iCol];
        if (pCell)
        {
            break;
        }
        // go to the cell on the left
        iCol--; // colSpan case
    }
    return Cell(pCell);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetCellBy
//
//  Synopsis:   get the cell from the specified row and from the specified column
//
//  Arguments:  iRow     - row
//              iCol     - column
//
//-----------------------------------------------------------------------------

inline CTableCell *
CTableLayout::GetCellBy(int iRow, int iCol)
{
    Assert(IsTableLayoutCacheCurrent());
    CTableRow *pRow = _aryRows[iRow];
    return Cell(pRow->RowLayoutCache()->_aryCells[iCol]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\style.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       style.cxx
//
//  Contents:   Support for Cascading Style Sheets.. including:
//
//              CCSSParser
//              CStyle
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include <strbuf.hxx>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

static const TCHAR strURLBeg[] = _T("url(");

MtDefine(CStyle, StyleSheets, "CStyle")
MtDefine(CCSSParser, StyleSheets, "CCSSParser")
MtDefine(ParseBackgroundProperty_pszCopy, Locals, "ParseBackgroundProperty pszCopy")
MtDefine(ParseFontProperty_pszCopy, Locals, "ParseFontProperty pszCopy")
MtDefine(ParseExpandProperty_pszCopy, Locals, "ParseExpandProperty pszCopy")
MtDefine(ParseAndExpandBorderSideProperty_pszCopy, Locals, "ParseAndExpandBorderSideProperty pszCopy")
MtDefine(ParseTextDecorationProperty_pszCopy, Locals, "ParseTextDecorationProperty pszCopy")
MtDefine(ParseTextAutospaceProperty_pszCopy, Locals, "ParseTextAutospaceProperty pszCopy")
MtDefine(ParseListStyleProperty_pszCopy, Locals, "ParseListStyleProperty pszCopy")
MtDefine(ParseBackgroundPositionProperty_pszCopy, Locals, "ParseBackgroundPositionProperty pszCopy")


#define SINGLEQUOTE _T('\'')
#define DOUBLEQUOTE _T('\"')

DeclareTag(tagStyleInlinePutVariant, "Style", "trace CStyle::put_Variant")

//---------------------------------------------------------------------
//  Class Declaration:  CCSSParser
//      The CCSSParser class implements a parser for data in the
//  Cascading Style Sheets format.
//---------------------------------------------------------------------

//*********************************************************************
//  CCSSParser::CCSSParser()
//      The constructor for the CCSSParser class initializes all member
//  variables for a full stylesheet declaration.
//*********************************************************************
CCSSParser::CCSSParser(
    CStyleSheet *pStyleSheet,
    CAttrArray **ppPropertyArray, /*=NULL*/
    BOOL fXMLGeneric,    /* FALSE */
    BOOL fStrictCSS1,    /* FALSE */
    ePARSERTYPE eType,   /* =eStylesheetDefinition */
    const HDLDESC *pHDLDesc, /*=&CStyle::s_apHdlDescs*/
    CBase * pBaseObj,   /*=NULL*/
    DWORD dwOpcode /*=HANDLEPROP_SETHTML*/) : _pHDLDesc(pHDLDesc)
{
    _ppCurrProperties = ppPropertyArray;
    
    _pStyleSheet = pStyleSheet;
    _eDefType = eType;   

    _pCurrSelector = NULL;
    _pCurrRule = NULL;
    _pSiblings = NULL;
    _pBaseObj = pBaseObj;
    _pDefaultNamespace = NULL;

    _iAtBlockNestLevel = 0;

    _fXMLGeneric = fXMLGeneric;
    _fIsStrictCSS1 = fStrictCSS1;

    _dwOpcode = dwOpcode;
    if (fStrictCSS1)
        _dwOpcode |= HANDLEPROP_STRICTCSS1;
           
}

//*********************************************************************
//  CCSSParser::~CCSSParser()
//      The destructor for the CCSSParser class doesn't explicitly do
//  anything - the CBuffer is automatically deleted, though.
//*********************************************************************
CCSSParser::~CCSSParser()
{
    delete _pCurrSelector;
    delete _pSiblings;
    delete _pDefaultNamespace;

    // Buffers are auto-deleted.
}

// Shortcut for loading from files.
HRESULT CCSSParser::LoadFromFile( LPCTSTR szFilename, CODEPAGE codepage )
{
    IStream * pStream;
    HRESULT hr;

    hr = THR(CreateStreamOnFile(szFilename, STGM_READ | STGM_SHARE_DENY_NONE,
                &pStream));

    if (hr == S_OK)
    {
        hr = THR(LoadFromStream(pStream, codepage));
        pStream->Release();
    }

    RRETURN(hr);
}

#define BUF_SIZE    8192

// Shortcut for loading from files.
HRESULT CCSSParser::LoadFromStream(IStream * pStream, CODEPAGE codepage)
{
    CStreamReadBuff streamReader( pStream, NavigatableCodePage( codepage == CP_UNDEFINED ? g_cpDefault : codepage ) );
    HRESULT hr;
    ULONG uLen;
    ULONG cbToRead = 0;
    TCHAR achBuffer[ BUF_SIZE ];
    TCHAR *pchBuffer = NULL;
    LONG lPosition = 0;
    STATSTG statstg;

    Open();

    IGNORE_HR( streamReader.GetPosition( &lPosition ) );
    
    hr = THR(pStream->Stat(&statstg, STATFLAG_DEFAULT));
    if (hr)
        goto Cleanup;

    cbToRead = statstg.cbSize.LowPart;
    if (cbToRead > BUF_SIZE)
    {
        pchBuffer = new TCHAR[cbToRead];
        if (!pchBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
        pchBuffer = achBuffer;
    
    hr = THR(streamReader.Read(pchBuffer, cbToRead, &uLen));
    if (hr == S_FALSE)
        hr = S_OK;

    if (hr || uLen == 0)
        goto Cleanup;

    codepage = CheckForCharset(pchBuffer, uLen);
    
    if (codepage != CP_UNDEFINED && streamReader.SwitchCodePage( codepage ))
    {
        streamReader.SetPosition(lPosition);

        _codepage = streamReader.GetCodePage();
        
        hr = THR(streamReader.Read(pchBuffer, cbToRead, &uLen));
        if (hr == S_FALSE)
            hr = S_OK;

        if (hr || uLen == 0)
           goto Cleanup;
    }
    
    Write(pchBuffer, uLen);

Cleanup:
    if (cbToRead > BUF_SIZE && pchBuffer)
        delete pchBuffer;
    
    Close();

    RRETURN(hr);
}

//*********************************************************************
//  CCSSParser::CheckForCharset()
//      Looks for the @charset directive.  Returns the codepage if
//      found, CP_UNDEFINED if not.
//*********************************************************************

CODEPAGE
CCSSParser::CheckForCharset( TCHAR * pch, ULONG cch )
{
    CODEPAGE codepage = CP_UNDEFINED;

    // Check the directive

    if (*pch == TEXT('@'))
    {
        // NUL terminate for expedience
        TCHAR *pLastCharPos = &pch[cch-1];
        const TCHAR chTemp = *pLastCharPos;
        *pLastCharPos = 0;
        
        if (StrCmpNIC( ++pch, TEXT("charset"), 7) == 0)
        {
            TCHAR chQuote;
            TCHAR *pchStart;
 
            pch += 7;
            
            // Skip whitespace

            while (isspace(*pch)) pch++;

            // Skip quote char, if any.

            if (*pch == DOUBLEQUOTE || *pch == SINGLEQUOTE)
            {
                chQuote = *pch++;
            }
            else
            {
                chQuote = 0;
            }

            pchStart = pch;

            // Find end of string

            while (!isspace(*pch) && *pch != chQuote && *pch != CHAR_SEMI) pch++;

            // Stash a NULL char temporarily

            const TCHAR chTemp = *pch;
            *pch = 0;

            // Ask MLANG for the numeric codepage value

            codepage = CodePageFromAlias( pchStart );

            // Restore buffer

            *pch = chTemp;
        }

        // Reverse the NUL termination

        *pLastCharPos = chTemp;
    }

    return codepage;
}

//*********************************************************************
//  CCSSParser::Open()
//      This method readies the CCSSParser to parse stylesheet data.
//*********************************************************************
void CCSSParser::Open()
{
    _pCurrSelector = NULL;
    _pSiblings = NULL;
    if ( _eDefType == eStylesheetDefinition )   // full stylesheet definition.
    {
        _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_PARSING;
        _ppCurrProperties = NULL;
    }
}


//*********************************************************************
//  CCSSParser::EndStyleDefinition()
//      The parser calls this internal method when it wants to terminate
//  a style definition (usually on '}' or EOD).
//*********************************************************************
HRESULT CCSSParser::EndStyleDefinition( void )
{
    HRESULT hr = S_OK;

    if ( _iAtBlockNestLevel > 0)
    {
        hr = EndAtBlock();
        // Continue if parsing, S_FALSE means done
        if(hr == S_FALSE)
        {
            if(_pCurrRule)
            {
                // Free the _pCurrSelector
                _pCurrRule->Free( );
                // and then free _pCurrRule
                delete _pCurrRule;
            }
            hr = S_OK;
            goto Cleanup;
        }
    }

    if ( ( _eDefType == eStylesheetDefinition ) && _pCurrSelector )
    {   // This is a full stylesheet definition.
        Assert ( "CSSParser must already have an allocated CStyleSheet!" && _pStyleSheet );
        hr = _pStyleSheet->AddStyleRule( _pCurrRule );  // Siblings are handled internally
    }

Cleanup:
    _ppCurrProperties = NULL;
    _pCurrSelector = NULL;
    _pCurrRule = NULL;
    RRETURN(hr);
}

//*********************************************************************
//  CCSSParser::ProcessAtBlock()
//      This method is used to set up parsing of an at-block, e.g. an
//  @page {} or @font-face {} block.
//*********************************************************************
HRESULT
CCSSParser::ProcessAtBlock (EAtBlockType atBlock, Tokenizer &tok, LPTSTR pchAlt)
{
    // At this point, _cbufPropertyName contains the @token name, and
    // _cbufBuffer contains any text between the @token and the '{'

    Tokenizer::TOKEN_TYPE tt;

    Assert(!_pCurrSelector);
    Assert(!_pSiblings);

    if (_iAtBlockNestLevel >= ATNESTDEPTH)
    {
        // This is purely error-recovery - we've nested deeper than we support
        Assert(!"CSS: @block parsing nested too deep!");
        goto Error;
    }

    switch (atBlock)
    {
    case AT_PAGE:
        _sAtBlock[_iAtBlockNestLevel] = new CAtPage(this, tok);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;
        break;

    case AT_FONTFACE:
        _sAtBlock[_iAtBlockNestLevel] = new CAtFontFace(this, tok);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        break;
 
    case AT_MEDIA:
        _sAtBlock[_iAtBlockNestLevel] = new CAtMedia(this, tok, _pStyleSheet);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        break;

    default:
        Assert(atBlock == AT_UNKNOWN);
        _sAtBlock[_iAtBlockNestLevel] = new CAtUnknown(this, tok, _pStyleSheet, pchAlt);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        tt = tok.TokenType();
        // Parse past the @unknown selector. it could have multiple rules.
        if (tt == Tokenizer::TT_LCurly)
        {
            UINT nCurlyCount = 1;
            while (nCurlyCount && tt != Tokenizer::TT_EOF)
            {
                tt = tok.NextToken();
                if (tt == Tokenizer::TT_LCurly)
                    nCurlyCount++;
                else if (tt == Tokenizer::TT_RCurly)
                    nCurlyCount--;
            }
        }

        _iAtBlockNestLevel++;
        EndAtBlock(TRUE);

        return S_OK;
    }

    _iAtBlockNestLevel++;
    return S_OK;

Error:
    return S_FALSE;
}


//*********************************************************************
//  CCSSParser::EndAtBlock()
//      This method is used to clean up after parsing of an at-block,
//  e.g. an @page {} or @font-face {} block.
//*********************************************************************
HRESULT CCSSParser::EndAtBlock(BOOL fForceDecrement)
{
    HRESULT hr = S_FALSE;
        
    // We need to clean up the stack for MULTIPLERULE @blocks only when we are before a selector
    if ( _iAtBlockNestLevel > 0)
    {
        if(!_sAtBlock[ _iAtBlockNestLevel - 1]->IsFlagSet(ATBLOCKFLAGS_MULTIPLERULES) || fForceDecrement) 
        {
            _iAtBlockNestLevel--;
            hr = _sAtBlock[ _iAtBlockNestLevel ]->EndStyleRule( _pCurrRule);
            delete (_sAtBlock[ _iAtBlockNestLevel ]);
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        // We've received too many '}' tokens.  Oh well, just ignore them.
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Helper Function:    BackupAttrValue
//
//  Synopsis:
//    This function does a backup of the attr corresponding to the PROPERTYDESC ppd
//    in CAttrArray *pAA. If no value is found in the attr array pAttrValue is set to VT_Empty.
//    BE CAREFUL, because the function doesn't free the former value of pAttrValue!
//
//    Input: CAttrArray*, PROPERTYDESC* 
//    Output: CAttrValue
//-------------------------------------------------------------------------

void
BackupAttrValue(CAttrArray *pAA, PROPERTYDESC *ppd, CAttrValue *pAttrValue)
{
    Assert(pAA && ppd && pAttrValue);
    
    // Initialize the AttrValue. Be careful, this doesn't take care of the former value, which may have to
    // be freed.
    pAttrValue->SetAVType(VT_EMPTY);

    AAINDEX ppdAAIndex = AA_IDX_UNKNOWN;

    // Find the index corresponding to the property desc ppd
    ppdAAIndex = pAA->FindAAIndex(ppd->GetDispid(), CAttrValue::AA_Attribute);

    if (ppdAAIndex != AA_IDX_UNKNOWN)
    { // If this property is stored in our array copy it to pAttrValue and return that we've been successful
        pAttrValue->Copy(pAA->FindAt(ppdAAIndex));
    }
}

//+------------------------------------------------------------------------
//
//  Helper Function:    RestoreAttrArray
//
//  Synopsis:
//      This function either restores the pAttrValue back to our CAttrArray
//      or if pAttrValue is of type VT_EMPTY simply deletes the corresponding entry
//
//  Input: CAttrArray*, PROPERTYDESC*, pAttryValue 
//  Modifies: CAttrArray*
//-------------------------------------------------------------------------

void
RestoreAttrArray(CAttrArray *pAA, PROPERTYDESC *ppd, CAttrValue *pAttrValue)
{
    Assert(pAA && ppd && pAttrValue);

    AAINDEX ppdAAIndex = AA_IDX_UNKNOWN;

    // Find the index corresponding to the property desc ppd
    ppdAAIndex = pAA->FindAAIndex(ppd->GetDispid(), CAttrValue::AA_Attribute);

    if (ppdAAIndex != AA_IDX_UNKNOWN)
    { // There is an entry in the current attribute array
        if (pAttrValue->GetAVType() == VT_EMPTY)
        { // pAttrValue is NULL iff there hasn't been any entry, originally
            (pAA->Delete(ppdAAIndex));
        }
        else 
        {    // Restore the attr value
            (pAA->FindAt(ppdAAIndex))->Copy(pAttrValue);
        }
    }
}
            
//+------------------------------------------------------------------------
//
//  Helper Function:    RemoveQuotes
//
//  Synopsis:
//      This function determines if a string is quoted and removes the matching
//  quotes from the string. If the quots do not match or there are no quotes
//  it returns S_FALSE
//-------------------------------------------------------------------------

HRESULT
RemoveQuotes(LPTSTR *ppszStr)
{
    TCHAR       chQuote;
    LPTSTR      pstrProp;
    LPTSTR      pstrPropEnd;
    HRESULT     hr = S_FALSE;

    // Remove the spaces before the quote (if there are spaces and a quote)
    while (_istspace(**ppszStr)) (*ppszStr)++;

    pstrProp = *ppszStr;

    // Skip the quote if it is present and remember the quote type
    if ((*pstrProp != DOUBLEQUOTE) && (*pstrProp != SINGLEQUOTE))
        // The string does not start with a quote, ignore it
        goto Cleanup;

    chQuote = *pstrProp;
    pstrProp++;

    // Scan for a matching quote
    while(*pstrProp != _T('\0') && *pstrProp != chQuote)
        pstrProp++;

    if(*pstrProp == _T('\0'))
        // No matching quote
        goto Cleanup;

    // Save the ending quote position
    pstrPropEnd = pstrProp;

    pstrProp++;

    // Check to see if the quote is the last thing in the string 
    while (_istspace(*pstrProp)) pstrProp++;
    if(*pstrProp != _T('\0'))
        goto Cleanup;

    /// Remove the starting quote
    (*ppszStr)++;
    // Remove the ending quote
    *pstrPropEnd = _T('\0');
    hr = S_OK;

Cleanup:
    if(hr == S_FALSE)
    {
        // Remove the spaces at the end of the string
        int nUrlLen = _tcslen(*ppszStr);
        while (nUrlLen > 0 && _istspace( (*ppszStr)[--nUrlLen] ) )
            (*ppszStr)[nUrlLen] = _T('\0');
    }

    RRETURN1(hr, S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Helper Function:    RemoveStyleUrlFromStr
//
//  Synopsis:
//      This function determines if a string is a valid CSS-style URL
//  functional notation string (e.g. "url(http://www.foo.com/bar)") and
//  returns the url string without url( and ) and surrounding quotes
//  !!!! This function modifies the parameter string pointer
//
//  Return Values:
//      S_OK if there was a url and S_FALSE it there was no URL string in front
//      
//-------------------------------------------------------------------------

HRESULT 
RemoveStyleUrlFromStr(TCHAR **ppszURL)
{
    HRESULT       hr = S_OK;
    int           nUrlLen;

    // Remove the leading spaces
    while ( _istspace(**ppszURL)) (*ppszURL)++;
    // and the trailing spaces
    nUrlLen = _tcslen(*ppszURL);
    while (nUrlLen > 0  && _istspace( (*ppszURL)[--nUrlLen] ) )  (*ppszURL)[nUrlLen] = _T('\0');

    // Check if our URL is a CSS url(xxx) string.  If so, strip "url(" off front,
    // and ")" off back.  Otherwise assume it'a a straight URL.
    if (!ValidStyleUrl(*ppszURL))
    {
        RemoveQuotes(ppszURL);
        hr = S_FALSE;
        goto Cleanup;
    }

    // Skip the "url(" (-1 for the terminating 0)
    *ppszURL += ARRAY_SIZE(strURLBeg) - 1;

    // Now cut from the end the closing )
    nUrlLen = _tcslen(*ppszURL);
    (*ppszURL)[--nUrlLen] = _T('\0');

    // Remove the leading spaces
    while ( _istspace(**ppszURL))  {(*ppszURL)++; nUrlLen--; }
    // Now remove the trailing spaces
    while (nUrlLen > 0 && _istspace( (*ppszURL)[--nUrlLen] ) )
        (*ppszURL)[nUrlLen] = _T('\0');

    RemoveQuotes(ppszURL); 

Cleanup:
    // Remove the leading spaces
    while ( _istspace(**ppszURL))  {(*ppszURL)++; nUrlLen--; }
    // Now remove the trailing spaces
    while (nUrlLen > 0 && _istspace( (*ppszURL)[--nUrlLen] ) )
        (*ppszURL)[nUrlLen] = _T('\0');

    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Helper Function:    NextSize
//
//  Synopsis:
//      This function tokenizes a font-size; we can't just tokenize on space,
//  in case we have a string like "12 pt".  This function returns a pointer
//  to the first character that is not part of the first size specifier in the
//  string.  It may or may not skip whitespace following the size specifier.
//
//  Return Values:
//      NULL on error (no size at the head of this string)
//      "" if the end of the string was reached.
//      pointer to following characters if success.
//-------------------------------------------------------------------------
TCHAR *NextSize( TCHAR *pszSize, const NUMPROPPARAMS *ppp )
{
    TCHAR *pszChar = pszSize;
    TCHAR *pszLastSpace = NULL;

    Assert( pszSize != NULL );

    // Skip any leading whitespace
    while ( _istspace( *pszChar ) )
        pszChar++;

    // it's okay for the first character to be '-' or '+'
    if ( ( *pszChar == _T('-') ) || ( *pszChar == _T('+') ) )
        pszChar++;

    // if the first character (after any '-') is not a digit, check if it's an enumerated size, then error.
    if ( !_istdigit( *pszChar ) && ( *pszChar != _T('.') ) )
    {
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            TCHAR chTerm;
            TCHAR *pszToken = pszChar;
            long lEnum;

            while ( _istalpha( *pszChar ) || ( *pszChar == _T('-') ) )
                pszChar++;

            chTerm = *pszChar;
            *pszChar = 0;

            HRESULT hr = LookupEnumString ( ppp, pszToken, &lEnum );
            *pszChar = chTerm;
            if ( hr == S_OK )
            {
                return pszChar;
            }
        }

        return NULL;
    }

    // Now we know we have at least one digit, so we can pull a size out of it.

    // Skip over all the digits
    while ( _istdigit( *pszChar ) || ( *pszChar == _T('.') ) )
        pszChar++;

    //  Skip any whitespace between the last digit and the (potential) unit string
    pszLastSpace = pszChar;
    while ( _istspace( *pszChar ) )
        pszChar++;

    //  If the string is "in", parse it as inches
    if (    ( pszChar[0] && pszChar[1] ) // Make sure at least two chars remain
        &&  (   !_tcsnicmp( _T("in"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("cm"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("mm"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("em"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("ex"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("pt"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("pc"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("px"), 2, pszChar, 2 ) ) )
        return (pszChar + 2);

    if ( *pszChar == _T('%') )  // If the string ends with '%', it's a percentage
        return pszChar+1;

    // Default is to treat the string as "px" and parse it as pixels
    return pszLastSpace;
}

//+------------------------------------------------------------------------
//
//  Function:     ::SetStyleProperty
//
//  Synopsis:   Add a style property name/value pair to the CAttrArray,
//  store as an unknown pair if the property is not recognized.
//
//-------------------------------------------------------------------------
HRESULT CCSSParser::SetStyleProperty(Tokenizer &tok)
{
    HRESULT                 hr = S_OK;
    TCHAR                   chOld = _T('\0');
    WORD                    wMaxstrlen = 0;
    DISPID                  dispid = DISPID_UNKNOWN;
    const PROPERTYDESC     *found;
    BOOL                    fFoundExpression = FALSE;
    BOOL                    fImportant = FALSE;
    TCHAR                  *pchPropName;
    Tokenizer::TOKEN_TYPE   tt = Tokenizer::TT_Unknown;
    
    Assert(tok.IsIdentifier(tok.TokenType()));
    if (LPTSTR(_cbufPropertyName))
        _cbufPropertyName.Set(tok.GetStartToken(), tok.GetTokenLength());
    pchPropName = LPTSTR(_cbufPropertyName);

    // Get the propertyName.
    Assert(_pHDLDesc && "Should have a propdesc list!");

    found = pchPropName ? _pHDLDesc->FindPropDescForName(pchPropName) : NULL;

    wMaxstrlen = found ? ((found->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 : (found->GetBasicPropParams()->wMaxstrlen ? found->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE)) : 0;

    if (_fIsStrictCSS1) 
    {
    	// Next token must be a colon
    	if (tt != Tokenizer::TT_EOF)
            tt = tok.NextToken();

        // Under strict css the next token _must_ be a colon. If the next token
        // is not a colon we try to bring the parser back in a valid state. I.e.
        // we search for a semicolon or a right curly (both close a property/value pair).
        if (tt != Tokenizer::TT_Colon) 
        {
            // (Error recovery) Next token was _not_ a colon. Eat until we find a 
            // promissing position to begin parsing again.
            while (tt != Tokenizer::TT_EOF && 
                tt != Tokenizer::TT_Semi && 
                tt != Tokenizer::TT_RCurly)
            {
                if (tt == Tokenizer::TT_LCurly)
                {
                    // Eat nested curlies, e.g. color: { { { { }} }};
                    UINT nCurlyCount = 1;
                    while (nCurlyCount && tt != Tokenizer::TT_EOF)
                    {
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_LCurly)
                            nCurlyCount++;
                        else if (tt == Tokenizer::TT_RCurly)
                            nCurlyCount--;
                    }
                    Assert(tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_EOF);
                    // We still need to find a valid end for the property/value pair
                    if (tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken();
                }
                else
                {
                    tt = tok.NextToken();	
                }
            }
            goto Cleanup;
        }
        // If we have found a colon we are fine.
    }
    else
    {
        while (tt != Tokenizer::TT_Colon &&
            tt != Tokenizer::TT_Equal &&
            tt != Tokenizer::TT_Semi &&
            tt != Tokenizer::TT_RCurly &&
            tt != Tokenizer::TT_EOF)
        {
            tt = tok.NextToken();
        }
    }

    Assert (tt == Tokenizer::TT_Colon ||
            tt == Tokenizer::TT_Equal ||
            tt == Tokenizer::TT_Semi ||
            tt == Tokenizer::TT_RCurly ||
            tt == Tokenizer::TT_EOF);

    if (tt != Tokenizer::TT_EOF)
    {
        TCHAR *pchValue;

        if (tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_Semi)
        {
            _cbufBuffer.Clear();
        }
        else
        {
            Assert (tt == Tokenizer::TT_Colon || tt == Tokenizer::TT_Equal);

            if (tt == Tokenizer::TT_Colon)
            {
                tok.NextNonSpaceChar();
                Assert (tt == Tokenizer::TT_Colon);
            }

            // TODO: for now return the string and pass it to the value type handler (parser).
            //         should really pass the tokenizer (tok) and let the value type handler do the
            //         parsing w/ the tokenizer.
        
            tok.StartSequence(&_cbufBuffer);

            // Get the propertyValue
            while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_RCurly && tt != Tokenizer::TT_Bang)
            {
                tt = tok.NextToken(TRUE);
                if (tt == Tokenizer::TT_LCurly)
                {
                    UINT nCurlyCount = 1;
                    while (nCurlyCount && tt != Tokenizer::TT_EOF)
                    {
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_LCurly)
                            nCurlyCount++;
                        else if (tt == Tokenizer::TT_RCurly)
                            nCurlyCount--;
                    }
                    Assert(tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_EOF);
                    tt = Tokenizer::TT_LCurly;
                }
                else if (tt == Tokenizer::TT_LParen)
                    tt = tok.NextToken(TRUE, FALSE, !_fIsStrictCSS1);
            }
        
            tok.StopSequence();
        }
        pchValue = LPTSTR(_cbufBuffer);

        if (wMaxstrlen && _cbufBuffer.Length() > wMaxstrlen)
        {
            chOld = pchValue[wMaxstrlen];
            pchValue[wMaxstrlen] = _T('\0');
        }

        // Look for !important
        if (tt == Tokenizer::TT_Bang)
        {
            tt = tok.NextToken();
            if (tok.IsIdentifier(tt) && tok.IsKeyword(_T("important")))
            {
                fImportant = TRUE;
            }
        }

        if (!pchPropName || !pchValue)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_iAtBlockNestLevel > 0)
        {
            // Remove the extra outside quotes form the property value
            RemoveQuotes(&pchValue);
            if (_sAtBlock[_iAtBlockNestLevel - 1])
                hr = _sAtBlock[_iAtBlockNestLevel - 1]->SetProperty(pchPropName, pchValue, FALSE);    // TODO: substitute important
            // S_FALSE means done the at block does not want to continue parsing
            if(hr == S_FALSE)
            {
                hr = S_OK;
                goto Cleanup;
            }
            // We set the properties as usual
        }

        if (found)
        {
            dispid = found->GetDispid();        // remember this for later

            hr = THR(SetExpression(dispid, wMaxstrlen, chOld));
            if (hr == S_OK)
            {
                fFoundExpression = TRUE;
                goto Cleanup;
            }
            else if (hr != S_FALSE)
                goto Cleanup;

            // S_FALSE means we didn't find an expression.  Fall through and process normally
            hr = S_OK;
        }

        if (_ppCurrProperties)
        {
            if (found && (found->pfnHandleProperty))
            {
                DWORD dwOpcode = _dwOpcode;

                // The flag HANDLEPROP_STRICTCSS1 is set in dwOpcode in the CSSParser constructure and should not be altered later.
                Assert(!_fIsStrictCSS1 || (dwOpcode & HANDLEPROP_STRICTCSS1));

                if (fImportant)
                    dwOpcode |= HANDLEPROP_IMPORTANT;

                // Remove the extra outside quotes form the property value, except for the font-family
                // font-family low level handler will take care of the quotes
                // In the case of font-family the problem is that many real world sites use the wrong syntax 
                // for listing fonts like font-face:"a,b,c". If we do not remove the quotes in this case we 
                // would break lots of things. We still want to preserve the quotes in other cases
                if(!_fIsStrictCSS1 && (found != &(s_propdescCStylefontFamily.a) || _tcschr(pchValue, _T(','))))
                {
                    RemoveQuotes(&pchValue);
                }

                // Try and parse attribute
#ifdef WIN16
                hr = THR((found->pfnHandleProperty)((PROPERTYDESC *)found,
                                                    (dwOpcode|(PROPTYPE_LPWSTR<<16)),
                                                    (CVoid *)pchValue,
                                                    _pBaseObj,
                                                    (CVoid *)((found->GetPPFlags() & PROPPARAM_ATTRARRAY) ?
                                                                    (void*)_ppCurrProperties :
                                                                    (void*) _pBaseObj)));
#else
                hr = THR (CALL_METHOD(found,
                                      found->pfnHandleProperty,
                                      ((dwOpcode|(PROPTYPE_LPWSTR<<16)),
                                      (CVoid *)pchValue,
                                      _pBaseObj,
                                      (CVoid *)((found->GetPPFlags() & PROPPARAM_ATTRARRAY) ?
                                                (void*)_ppCurrProperties :
                                                (void*)_pBaseObj))));
#endif
                if (hr)
                {
                    // We got an illegal value for a property, stuff it into the attr array as an unknown
                    if (chOld)
                    {
                        pchValue[wMaxstrlen] = chOld;
                        chOld = 0;
                    }
                    hr = CAttrArray::SetString(_ppCurrProperties, found, pchValue, TRUE, CAttrValue::AA_Extra_DefaultValue);
                    goto Cleanup;
                }
                else
                {
                    // We need to check for position:absolute and position:relative so that 
                    // region collection is not built when not needed. This is a temporary
                    // optimization and will go away soon.
                    if (found == &(s_propdescCStyleposition.a) && (*_ppCurrProperties))
                    {
                        CElement *pElem;
                        CDoc     *pDoc;

                        GetParentElement(&pElem);

                        if (pElem)
                        {
                            pDoc = pElem->Doc();

                            if (!pDoc->NeedRegionCollection())
                            {
                                DWORD dwVal;
                                BOOL fFound = (*_ppCurrProperties)->FindSimple(DISPID_A_POSITION, &dwVal);

                                if (fFound && ((stylePosition)dwVal == stylePositionrelative || 
                                    (stylePosition)dwVal == stylePositionabsolute))
                                {
                                    pDoc->_fRegionCollection = TRUE;
                                }
                            }
                        }
                    }

                    // got a match
                    goto Cleanup;
                }
            }
            else if (!found)
            {   // Not found... should be added as an expando.
                VARIANT     varNew;
                CBase      *pBase;

                // Create an expando
                if (_eDefType == eSingleStyle)
                    pBase = _pBaseObj;
                else
                {
                    if (!_pStyleSheet->GetParentElement())
                        goto Cleanup;
                    pBase = _pStyleSheet;
                }

                Assert(pBase);

                hr = pBase->GetExpandoDispID(pchPropName, &dispid, fdexNameCaseSensitive|fdexNameEnsure);
                if (hr)
                    goto Cleanup;

                hr = THR(SetExpression(dispid));
                if (hr == S_OK)
                {
                    fFoundExpression = TRUE;
                    goto Cleanup;
                }
                else if (hr == S_FALSE)
                {
                    varNew.vt = VT_LPWSTR;
                    varNew.byref = (LPTSTR)pchValue;

                    hr = THR(CAttrArray::Set(_ppCurrProperties, dispid, &varNew, NULL, CAttrValue::AA_Expando));
                    if (hr)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CCSSParser::Declaration (Tokenizer &tok, BOOL fCreateSelector)
{
    Tokenizer::TOKEN_TYPE   tt = Tokenizer::TT_Unknown;

    // Begin a style declaration
    if (_eDefType == eStylesheetDefinition && fCreateSelector)   // full stylesheet definition.
    {
        if (_pCurrSelector)
            _pCurrSelector->SetSibling(_pSiblings);
        else
        {
            _pCurrSelector = _pSiblings;
            // If there's a style decl with no selector, we give
            if (!_pCurrSelector)                    
                _pCurrSelector = new CStyleSelector();

            if (!_pCurrSelector)
                goto Cleanup;
        }

        _pSiblings = NULL;
        _pCurrRule = new CStyleRule(_pCurrSelector);
        if (!_pCurrRule)
            goto Cleanup;

        _ppCurrProperties = _pCurrRule->GetRefStyleAA();
    }

    tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        if (tok.IsIdentifier(tt))
            SetStyleProperty(tok); 

        // continue fetching for more prop/value pairs...
        tt = tok.TokenType();
        if (tt == Tokenizer::TT_RCurly)
            break;

        tt = tok.NextToken();
    }

Cleanup:
    return TRUE;
}

BOOL
CCSSParser::RuleSet(Tokenizer &tok)
{
    Tokenizer::TOKEN_TYPE tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        // selector+ [pseudo_element | solitary_pseudo_element]? | solitary_pseudo_element
        // 
        CStyleSelector *pNew = new CStyleSelector(tok, _pCurrSelector, _fIsStrictCSS1, _fXMLGeneric);
        if (!pNew)
        {
            goto Cleanup;
        }

        tt = tok.TokenType();
        // skip comments in selector names.
        while(tt == Tokenizer::TT_Comment && tt != Tokenizer::TT_EOF)
            tt = tok.NextToken();

        // More than one selector?
        if (tt == Tokenizer::TT_Comma)
        {   // This is a sibling in a group listing.
            // Push the new selector on the front of the sibling list
            pNew->SetSibling(_pSiblings);
            _pSiblings = pNew;
            _pCurrSelector = NULL;

            while(tt == Tokenizer::TT_Comma || tt == Tokenizer::TT_Comment)
                tt = tok.NextToken();
        }
        else
        {   // This is (or might be) the beginning of a context list.
            _pCurrSelector = pNew;
        }

        // if it is continue with the next selector (which will be the child\sibling of this one) 
        // else get outa here.
        if (!tok.IsIdentifier(tt) &&
            tt != Tokenizer::TT_Asterisk &&
            tt != Tokenizer::TT_Hash &&
            tt != Tokenizer::TT_Dot &&
            tt != Tokenizer::TT_Colon)
            break;
    }

Cleanup:
    return TRUE;
}

//*********************************************************************
//  CCSSParser::Write()
//      This method is used to pass a block of data to the stylesheet
//  parser. It returns the data actually written if it succeeds and 0
//  if it fails.
//*********************************************************************
ULONG
CCSSParser::Write(TCHAR *pData, ULONG ulLen )
{
    HRESULT hr=S_OK;
    BOOL fCreateSelector = TRUE;
    Tokenizer tok;
    tok.Init(pData, ulLen);

    Tokenizer::TOKEN_TYPE tt;
    tt = tok.NextToken();

    if (_eDefType == eSingleStyle)
    {
        while (tt != Tokenizer::TT_EOF)
        {
            Declaration(tok);
            tt = tok.NextToken();
        }
    }
    else
    {
        // [CDO | CDC]* | [import [CDO | CDC]*]* | [ruleset [CDO | CDC]*]*
        while (tt != Tokenizer::TT_EOF)
        {
            if (tt == Tokenizer::TT_At)
            {
                tt = tok.NextToken();

                // @import [STRING | URL] ';'
                if (tok.IsKeyword(_T("import")))
                {
                    BOOL    fNeedRParen = FALSE;
                    BOOL    fSyntaxError = TRUE;

                    // remember start of selector name in case of malformed @import
                    TCHAR *pStart = tok.GetStartSeq();

                    // [STRING | URL]
                    tt = tok.NextToken();
                    while (!tok.IsIdentifier(tt) && tt != Tokenizer::TT_String && tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken();

                    if (tok.IsKeyword(_T("url")))
                    {
                        if (tok.NextToken() == Tokenizer::TT_LParen)
                        {
                            fNeedRParen = TRUE;
                            tt = tok.NextToken(TRUE, FALSE, !_fIsStrictCSS1);
                            // Should be URL string at this point.
                        }
                    }

                    // Get the URL of the @import
                    if (tt == Tokenizer::TT_String || (fNeedRParen && tt == Tokenizer::TT_RParen))
                    {
                        // Semi-colon required for @import
                        tt = tok.NextToken();
                        while (tt == Tokenizer::TT_Comment)
                            tt = tok.NextToken();

                        if (tt == Tokenizer::TT_Semi)
                        {
                            fSyntaxError = FALSE;
                            if (_pStyleSheet)
                                _pStyleSheet->AddImportedStyleSheet(tok.GetTokenValue(), /* parsing */TRUE);
                        }
                    }

                    if (fSyntaxError)
                    {
                        while (tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_LCurly && tt != Tokenizer::TT_EOF)
                            tt = tok.NextToken();

                        CStr cstrAlt;
                        hr = cstrAlt.Set(pStart, tok.GetSeqLength(pStart));
                        if (hr != S_OK)
                            goto Cleanup;

                        if (tt == Tokenizer::TT_LCurly)
                        {
                            // Error parsing @import, treat as unknown @block
                            ProcessAtBlock(AT_UNKNOWN, tok, cstrAlt);
                        }
                        else if (tt == Tokenizer::TT_Semi)
                        {
                            if (_pStyleSheet)
                                _pStyleSheet->AddImportedStyleSheet(cstrAlt, /* parsing */ TRUE);
                        }
                    }
                }
                // @page S* '{' S* declaration [ ';' S* declaration ]* '}'
                else if (tok.IsKeyword(_T("page")))
                {
                    ProcessAtBlock(AT_PAGE, tok);
                    fCreateSelector = FALSE;
                    tt = tok.TokenType();
                    // if already at left curly, skip this loop to process left curly in next.
                    if (tt == Tokenizer::TT_LCurly)
                        continue;
                }
                // @media S* '{' S* ruleset* '}'
                else if (tok.IsKeyword(_T("media")))
                {
                    ProcessAtBlock(AT_MEDIA, tok);
                }
                // @font-face S* '{' S* declaration [ ';' S* declaration ]* '}'
                else if (tok.IsKeyword(_T("font-face")))
                {
                    ProcessAtBlock(AT_FONTFACE, tok);
                    fCreateSelector = FALSE;
                    tt = tok.TokenType();
                    // if already at left curly, skip this loop to process left curly in next.
                    if (tt == Tokenizer::TT_LCurly)
                        continue;
                }
                else
                {
                    // Error, unknown @block
                    ProcessAtBlock(AT_UNKNOWN, tok);
                }
            }
            else if (tt == Tokenizer::TT_Comment ||
                     tt == Tokenizer::TT_EndHTMLComment ||
                     tt == Tokenizer::TT_BeginHTMLComment ||
                     tt == Tokenizer::TT_Comma)
            {

            }
            else if (tt == Tokenizer::TT_RCurly)
            {
                EndAtBlock(TRUE);
            }
            else if (tt == Tokenizer::TT_LCurly)
            {
                // Process values until TT_RCurly.
                tt = tok.NextToken();

                if (Declaration(tok, fCreateSelector))
                {
                    fCreateSelector = TRUE;
                    tt = tok.TokenType();
                    if (tt == Tokenizer::TT_RCurly)
                    {
                        EndStyleDefinition();
                        // End of Declaration we're done with this parse loop.
                        
                        tt = tok.NextToken();
                        // Even though a ';' is invalid between rules, we need this hack to allow
                        // it to be ignored for compat reasons as it is a fairly common occurance.
                        if (tt != Tokenizer::TT_Semi)
                            continue;
                    }
                    else
                        continue;   // Error, start over with this token.
                }
            }
            else if (RuleSet(tok))
            {
                // if selector not followed by a left curly, error! delete current selector and process next token
                tt = tok.TokenType();
                if (tt != Tokenizer::TT_LCurly)
                {
                    if (_pCurrSelector)
                    {
                        delete _pCurrSelector;
                        _pCurrSelector = NULL;
                    }
                    if (_pSiblings)
                    {
                        delete _pSiblings;
                        _pSiblings = NULL;
                    }

                    while (tt != Tokenizer::TT_LCurly &&
                           tt != Tokenizer::TT_RCurly &&
                           tt != Tokenizer::TT_BeginHTMLComment &&
                           tt != Tokenizer::TT_EndHTMLComment &&
                           tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken(FALSE, TRUE);
                }

                // continue to LCurly in the next loop
                Assert(tt == Tokenizer::TT_LCurly ||
                       tt == Tokenizer::TT_RCurly ||
                       tt == Tokenizer::TT_BeginHTMLComment ||
                       tt == Tokenizer::TT_EndHTMLComment ||
                       tt == Tokenizer::TT_EOF);
                continue;
            }
            else
            {
                    // BAD Parsing...
            }

            // Fetch next token...
            tt = tok.NextToken();
        }
    }

Cleanup:
    if (hr != S_OK)
        return 0;
    return ulLen;

}


//*********************************************************************
//  CCSSParser::Close()
//      This method finishes off any current style or stylesheet declaration.
//*********************************************************************
void CCSSParser::Close()
{
    if ( _ppCurrProperties)
        EndStyleDefinition();

    if ( _eDefType == eStylesheetDefinition )
    {
        _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
    }

    // If for some reason at blocks are left in the @block stack, delete them
   while(_iAtBlockNestLevel-- > 0)
       delete _sAtBlock[_iAtBlockNestLevel];
}


//+---------------------------------------------------------------------------
//
// CStyle
//
//----------------------------------------------------------------------------
#define _cxx_
#include "style.hdl"


//+------------------------------------------------------------------------
//
//  Member:     CStyle::CStyle
//
//-------------------------------------------------------------------------
CStyle::CStyle(CElement *pElem, DISPID dispID, DWORD dwFlags, CAttrArray * pAA /*=NULL*/)
{
    WHEN_DBG(_dwCookie=eCookie;)

    _pElem = pElem;
    _dispIDAA = dispID;

    if (pElem)
    {
        if (dispID != DISPID_UNKNOWN)
        {
            _pAA = *pElem->CreateStyleAttrArray(_dispIDAA);
        }
    }

    ClearFlag(STYLE_MASKPROPERTYCHANGES);
    SetFlag(dwFlags);
    if (TestFlag(STYLE_SEPARATEFROMELEM))
    {
        Assert(_pElem);
        _pElem->SubAddRef();
    }

    if (pAA && TestFlag(STYLE_DEFSTYLE))
    {
        Assert(dispID == DISPID_UNKNOWN);
        _pAA = pAA;
    }

    Assert( TestFlag(STYLE_REFCOUNTED) || !TestFlag(STYLE_SEPARATEFROMELEM) || TestFlag(STYLE_DEFSTYLE) );
}

//+------------------------------------------------------------------------
//
//  Member:     CStyle::~CStyle
//
//-------------------------------------------------------------------------
CStyle::~CStyle()
{
    if (!TestFlag(STYLE_REFCOUNTED))
    {
        Passivate();
    }
}

void CStyle::Passivate()
{
    if (_pStyleSource)
    {
        _pStyleSource->Release();
        _pStyleSource = NULL;
    }

    if (TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->SubRelease();
        _pElem = NULL;
    }
    else
    {
        // Don't leave this alone, or CBase::Passivate will try to manage its destruction.
        // Since it doesn't actually belong to us (it belongs to its entry in _pElem->_pAA),
        // this would cause problems.
        _pAA = NULL;
    }
    super::Passivate();
}


ULONG CStyle::PrivateAddRef ( void )
{
    Assert(_pElem);
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->AddRef();
    }
    else if (TestFlag(STYLE_DEFSTYLE))
    {
        CDefaults *pDefaults = _pElem->GetDefaults();
        Assert(pDefaults);
        _pElem->AddRef();
        pDefaults->PrivateAddRef();
    }
    else
    {
        super::PrivateAddRef();
    }

    return 0;
}

ULONG CStyle::PrivateRelease( void )
{
    Assert(_pElem);
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->Release();
    }
    else if (TestFlag(STYLE_DEFSTYLE))
    {
        CDefaults *pDefaults = _pElem->GetDefaults();
        Assert(pDefaults);
        _pElem->Release();
        pDefaults->PrivateRelease();
    }
    else
    {
        super::PrivateRelease();
    }

    return 0;
}


const CStyle::CLASSDESC CStyle::s_classdesc =
{
    {
        &CLSID_HTMLStyle,                    // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyle,                     // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyle,              // _apfnTearOff
};

BEGIN_TEAROFF_TABLE(CStyle, IServiceProvider)
        TEAROFF_METHOD(CStyle, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CStyle, IRecalcProperty)
    TEAROFF_METHOD(CStyle, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()


//+---------------------------------------------------------------------------
//
//  Helper Function:    InvokeSourceGet
//
//----------------------------------------------------------------------------

HRESULT
InvokeSourceGet(IDispatch * pdisp, DISPID dispid, VARTYPE varTypeResultRequested, void * pv)
{
    HRESULT     hr;
    CInvoke     invoke(pdisp);

    hr = THR(invoke.Invoke(dispid, DISPATCH_PROPERTYGET));
    if (hr)
        goto Cleanup;


    switch (varTypeResultRequested)
    {
    case VT_VARIANT:
        hr = VariantCopy ((VARIANT*)pv, invoke.Res());
        break;

    case VT_BSTR:
        if (VT_BSTR != V_VT(invoke.Res()))
        {
            Assert (FALSE);
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        *((BSTR*)pv) = V_BSTR(invoke.Res());
        V_VT(invoke.Res()) = VT_EMPTY; // to avoid freeing the result
        V_BSTR(invoke.Res()) = NULL;

        break;

    case VT_I4:

        if (VT_I4 != V_VT(invoke.Res()))
        {
            Assert (FALSE);
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        *((UINT*)pv) = V_I4(invoke.Res());

        break;

    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::NeedToDelegateGet
//
//----------------------------------------------------------------------------

BOOL
CStyle::NeedToDelegateGet(DISPID dispid)
{
    CAttrArray **ppAA = GetAttrArray();
    return (_pStyleSource && ppAA && *ppAA &&
            AA_IDX_UNKNOWN == (*ppAA)->FindAAIndex(dispid, CAttrValue::AA_Attribute));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::DelegateGet
//
//----------------------------------------------------------------------------

HRESULT
CStyle::DelegateGet(DISPID dispid, VARTYPE varType, void * pv)
{
    return InvokeSourceGet(_pStyleSource, dispid, varType, pv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::getValueHelper, public
//
//  Synopsis:   Helper function to implement get_ top/left/width/height
//
//  Arguments:  [plValue] -- Place to put value
//              [dwFlags] -- Flags indicating whether its an X or Y attribute
//              [puv]     -- CUnitValue containing the value we want to return
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

enum putValueFlags
{
    PUTVF_X     = 0x1,
    PUTVF_SIZE  = 0x2,
    PUTVF_Y     = 0x4,
    PUTVF_POS   = 0x8
};


HRESULT
CStyle::getValueHelper(long *plValue, DWORD dwFlags, const PROPERTYDESC *pPropertyDesc)
{
    HRESULT       hr = S_OK;
    RECT          rcParent;
    CUnitValue    uvTemp;
    DWORD         dwVal;
    CLayout     * pLayoutParent;
    long          lParentSize;

    if (!plValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pElem)
    {    
        hr = THR(_pElem->EnsureInMarkup());
        if (hr)
            goto Cleanup;
            
        if (_pElem->Doc()->_fDefView)
        {
            switch (pPropertyDesc->GetDispid())
            {
            case DISPID_CStyle_width:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedwidth();
                break;
                
            case DISPID_CStyle_left:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedleft();
                break;
                
            case DISPID_CStyle_top:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedtop();
                break;
                
            case DISPID_CStyle_right:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedright();
                break;
                
            case DISPID_CStyle_bottom:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedbottom();
                break;
                
            case DISPID_CStyle_height:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedheight();
                break;

            default:
                Assert(0 && "Unexpected dispid");
                break;
            }
        }
        else
        {
            CAttrArray **ppAA = GetAttrArray();
            if (ppAA)
                CAttrArray::FindSimple(*ppAA, pPropertyDesc, &dwVal);
            else
                dwVal = (DWORD)pPropertyDesc->ulTagNotPresentDefault;

            uvTemp.SetRawValue(dwVal);
        }
    }
    
    if (!uvTemp.IsNull() && _pElem)
    {
        CDocInfo    DCI;


        pLayoutParent = _pElem->GetFirstBranch()->Parent()->GetUpdatedNearestLayout();
        if (!pLayoutParent && _pElem->GetMarkup())
        {
            CElement *pElement = _pElem->GetMarkup()->GetElementClient();

            if (pElement)
            {
                pLayoutParent = pElement->GetUpdatedLayout();
            }
        }

        if (pLayoutParent || _pElem->GetMarkup())
        {
            DCI.Init(pLayoutParent ? pLayoutParent->ElementOwner() : _pElem->GetMarkup()->Root());
        }
        // else, the element is not in a tree. e.g. el = new Image();

        if (pLayoutParent)
        {
            pLayoutParent->GetClientRect(&rcParent);

            if (   rcParent.right == 0
                && rcParent.left == 0
                && rcParent.bottom ==0
                && rcParent.top == 0)
            {
                // MORE OM protection.  This is being called from the style OM, and is accessing 
                // layout properties.  The only way that this can be reliable is for us to try
                // to push the ensureView queues at this point. see get_offset* for other examples.
                hr = _pElem->EnsureRecalcNotify();
                if (hr)
                {
                    *plValue = 0;
                    goto Cleanup;
                }

                // Layout state may have changed.  Reget layout.
                pLayoutParent = _pElem->GetFirstBranch()->Parent()->GetUpdatedNearestLayout();
                if (pLayoutParent)
                    pLayoutParent->GetClientRect(&rcParent);
            }
    
            if (dwFlags & PUTVF_X)
                lParentSize = rcParent.right - rcParent.left;
            else
                lParentSize = rcParent.bottom - rcParent.top;
        }
        else
        {
            // if there is no parent layout and no Element client layout
            // rcParent is empty, therefore lParentSize is NULL
            lParentSize = 0;
        }

        if (dwFlags & PUTVF_X)
        {
            *plValue = uvTemp.XGetPixelValue(&DCI, lParentSize, 
                           _pElem->GetFirstBranch()->GetFontHeightInTwips(&uvTemp));
            *plValue = DCI.DocPixelsFromDeviceX(*plValue);
        }
        else
        {
            *plValue = uvTemp.YGetPixelValue(&DCI, lParentSize, 
                           _pElem->GetFirstBranch()->GetFontHeightInTwips(&uvTemp));
            *plValue = DCI.DocPixelsFromDeviceY(*plValue);
        }
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::putValueHelper, public
//
//  Synopsis:   Helper function for implementing put_ top/left/width/height
//
//  Arguments:  [lValue]  -- New value to store
//              [dwFlags] -- Flags indicating direction and what it affects
//              [dispid]  -- DISPID of property
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

// NOTE (carled) there is a compiler bug that manifest with this function
//  do NOT reorder the local variables below or else dwFlags will incorrectly
//  get reset to 0 and the site postion
HRESULT
CStyle::putValueHelper(long lValue, DWORD dwFlags, DISPID dispid, const PROPERTYDESC *ppropdesc)
{
    BOOL    fChanged    = FALSE;
    RECT    rcParent;
    long    delta;
    DWORD   dwPropFlags = ELEMCHNG_CLEARCACHES;
    HRESULT hr          = S_OK;
    CLayout *pParentLayout;
    const PROPERTYDESC *pPropDesc = NULL;

    if(!_pElem)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    pParentLayout = _pElem->GetUpdatedParentLayout(GUL_USEFIRSTLAYOUT);

    if (dwFlags & PUTVF_SIZE)
        dwPropFlags |= ELEMCHNG_SIZECHANGED;
    else
        dwPropFlags |= ELEMCHNG_SITEPOSITION;

    if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
    {
        pPropDesc = ppropdesc;
        dwPropFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
    }

#ifndef NO_EDIT
    {
        CUndoPropChangeNotificationPlaceHolder
                notfholder( TRUE, _pElem, dispid, dwPropFlags );
#endif // NO_EDIT

        if (!pParentLayout && _pElem->GetMarkup())
        {
            CElement *pElement = _pElem->GetMarkup()->GetElementClient();
            // if there is no parent layout.
            // we are either a body ot framesetsite.
            // we should get client element rect
            if (pElement)
            {
                pParentLayout = pElement->GetUpdatedLayout();
            }
        }

        if (pParentLayout)
        {
            pParentLayout->GetClientRect(&rcParent);

            if (dwFlags & PUTVF_X)
                delta = rcParent.right - rcParent.left;
            else
                delta = rcParent.bottom - rcParent.top;
        }
        else
        {
            // if there is no parent layout and no Element client layout
            // rcParent is empty, therefore delta is NULL
            delta = 0;
        }

        hr = THR(_pElem->SetDim(dispid,
                                (float)lValue,
                                CUnitValue::UNIT_PIXELS,
                                delta,
                                GetAttrArray(),
                                _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA,
                                &fChanged));
        if (hr)
            goto Cleanup;

        if (fChanged)
        {
            _pElem->OnPropertyChange(dispid, dwPropFlags, pPropDesc);
        }

#ifndef NO_EDIT
        notfholder.SetHR( fChanged ? hr : S_FALSE );
    }
#endif // NO_EDIT

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::get_pixelWidth(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelWidth)

    if (NeedToDelegateGet(DISPID_CStyle_pixelWidth))
    {
        return DelegateGet(DISPID_CStyle_pixelWidth, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStylewidth.a));
}

HRESULT
CStyle::put_pixelWidth(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelWidth)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_SIZE, 
                           STDPROPID_XOBJ_WIDTH, 
                           (PROPERTYDESC *)&s_propdescCStylewidth));
}

HRESULT
CStyle::get_pixelHeight(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelHeight)

    if (NeedToDelegateGet(DISPID_CStyle_pixelHeight))
    {
        return DelegateGet(DISPID_CStyle_pixelHeight, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStyleheight.a));
}

HRESULT
CStyle::put_pixelHeight(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelHeight)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_SIZE, 
                           STDPROPID_XOBJ_HEIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleheight));
}

HRESULT
CStyle::get_pixelLeft(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelLeft)

    if (NeedToDelegateGet(DISPID_CStyle_pixelLeft))
    {
        return DelegateGet(DISPID_CStyle_pixelLeft, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStyleleft.a));
}

HRESULT
CStyle::put_pixelLeft(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelLeft)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_LEFT, 
                           (PROPERTYDESC *)&s_propdescCStyleleft));
}

HRESULT
CStyle::get_pixelRight(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelRight)

    if (NeedToDelegateGet(DISPID_CStyle_pixelRight))
    {
        return DelegateGet(DISPID_CStyle_pixelRight, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStyleright.a));
}

HRESULT
CStyle::put_pixelRight(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelRight)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_RIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleright));
}

HRESULT
CStyle::get_pixelTop(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelTop)

    if (NeedToDelegateGet(DISPID_CStyle_pixelTop))
    {
        return DelegateGet(DISPID_CStyle_pixelTop, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStyletop.a));
}

HRESULT
CStyle::put_pixelTop(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelTop)
    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_TOP, 
                           (PROPERTYDESC *)&s_propdescCStyletop));
}

HRESULT
CStyle::get_pixelBottom(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelBottom)

    if (NeedToDelegateGet(DISPID_CStyle_pixelBottom))
    {
        return DelegateGet(DISPID_CStyle_pixelBottom, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStylebottom.a));
}

HRESULT
CStyle::put_pixelBottom(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelBottom)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_BOTTOM, 
                           (PROPERTYDESC *)&s_propdescCStylebottom));
}


HRESULT
CStyle::getfloatHelper(float *pfValue, DWORD dwFlags, const PROPERTYDESC *pPropertyDesc)
{
    HRESULT                   hr = S_OK;
    CUnitValue                uvTemp;
    DWORD                     dwVal;
    
    if (!pfValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (_pElem)
    {
        hr = THR(_pElem->EnsureInMarkup());
        if (hr)
            goto Cleanup;

        if (_pElem->Doc()->_fDefView)
        {
            switch (pPropertyDesc->GetDispid())
            {
            case DISPID_CStyle_width:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedwidth();
                break;
                
            case DISPID_CStyle_left:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedleft();
                break;
                
            case DISPID_CStyle_top:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedtop();
                break;
                
            case DISPID_CStyle_right:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedright();
                break;
                
            case DISPID_CStyle_bottom:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedbottom();
                break;
                
            case DISPID_CStyle_height:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedheight();
                break;

            default:
                Assert(0 && "Unexpected dispid");
                break;
            }
        }
        else
        {
            CAttrArray **ppAA = GetAttrArray();
            if (ppAA)
                CAttrArray::FindSimple(*ppAA, pPropertyDesc, &dwVal);
            else
                dwVal = (DWORD)pPropertyDesc->ulTagNotPresentDefault;

            uvTemp.SetRawValue(dwVal);
        }
    }
    
    if (!uvTemp.IsNull())
    {
        *pfValue = uvTemp.GetFloatValue();
    }
    else
    {
        *pfValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::putfloatHelper(float fValue, DWORD dwFlags, DISPID dispid, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr          = S_OK;
    DWORD   dwPropFlags = ELEMCHNG_CLEARCACHES;
    BOOL    fChanged    = FALSE;
    RECT    rcParent;
    long    delta;
    const PROPERTYDESC *pPropDesc = NULL;

    if(!_pElem)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (!_pElem->GetUpdatedParentLayout())
    {
        delta = 0;
    }
    else
    {
        _pElem->GetUpdatedParentLayout()->GetClientRect(&rcParent);

        if (dwFlags & PUTVF_X)
            delta = rcParent.right - rcParent.left;
        else
            delta = rcParent.bottom - rcParent.top;
    }

    hr = THR(_pElem->SetDim(dispid,
                            fValue,
                            CUnitValue::UNIT_NULLVALUE,
                            delta,
                            GetAttrArray(),
                            _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA,
                            &fChanged));
    if (hr)
        goto Cleanup;

    if (fChanged)
    {
        if (dwFlags & PUTVF_SIZE)
            dwPropFlags |= ELEMCHNG_SIZECHANGED;
        else
            dwPropFlags |= ELEMCHNG_SITEPOSITION;

        if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
        {
            pPropDesc = ppropdesc;
            dwPropFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
        }

        _pElem->OnPropertyChange(dispid, dwPropFlags, pPropDesc);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::get_posWidth(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posWidth)

    if (NeedToDelegateGet(DISPID_CStyle_posWidth))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStylewidth.a));
}

HRESULT
CStyle::put_posWidth(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posWidth)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_SIZE, 
                           STDPROPID_XOBJ_WIDTH, 
                           (PROPERTYDESC *)&s_propdescCStylewidth));
}

HRESULT
CStyle::get_posHeight(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posHeight)

    if (NeedToDelegateGet(DISPID_CStyle_posHeight))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStyleheight.a));
}

HRESULT
CStyle::put_posHeight(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posHeight)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_SIZE, 
                           STDPROPID_XOBJ_HEIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleheight));
}

HRESULT
CStyle::get_posLeft(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posLeft)

    if (NeedToDelegateGet(DISPID_CStyle_posLeft))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStyleleft.a));
}

HRESULT
CStyle::put_posLeft(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posLeft)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_LEFT, 
                           (PROPERTYDESC *)&s_propdescCStyleleft));
}


HRESULT
CStyle::get_posRight(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posRight)

    if (NeedToDelegateGet(DISPID_CStyle_posRight))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStyleright.a));
}

HRESULT
CStyle::put_posRight(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posRight)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_RIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleright));
}

HRESULT
CStyle::get_posTop(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posTop)

    if (NeedToDelegateGet(DISPID_CStyle_posTop))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStyletop.a));
}

HRESULT
CStyle::put_posTop(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posTop)
    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_TOP, 
                           (PROPERTYDESC *)&s_propdescCStyletop));
}

HRESULT
CStyle::get_posBottom(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posBottom)

    if (NeedToDelegateGet(DISPID_CStyle_posBottom))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStylebottom.a));
}

HRESULT
CStyle::put_posBottom(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posBottom)
    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_BOTTOM, 
                           (PROPERTYDESC *)&s_propdescCStylebottom));
}



//+------------------------------------------------------------------------
//
//  Function:   EscapeQuotes
//
//  Synopsis:   Changes all the double quotes in the string to single quotes
//              Future implementations of this function must escape the quotes,
//                  so the information is saved. They might also need to allocate
//                  and return another string.
//-------------------------------------------------------------------------

void
EscapeQuotes(LPTSTR lpPropValue)
{
    if(!lpPropValue)
        return;

    while(*lpPropValue != 0)
    {
        if(*lpPropValue == DOUBLEQUOTE)
            *lpPropValue = SINGLEQUOTE;
        lpPropValue++;
    }
}


//+------------------------------------------------------------------------
//
//  Function:   ::WriteStyleToBSTR
//
//  Synopsis:   Converts a collection of style properties to a BSTR for display on grid
//
//  Note:       Look at size member of GlobalAlloc on large style sheets
//
//-------------------------------------------------------------------------
HRESULT WriteStyleToBSTR( CBase *pObject, CAttrArray *pAA, BSTR *pbstr, BOOL fQuote, BOOL fSaveExpressions)
{
    CPtrBagVTableAggregate::CIterator vTableIterator(CStyle::s_apHdlDescs.pStringTableAggregate);
    HRESULT hr=S_OK;
    BASICPROPPARAMS *pbpp;
    LPCTSTR pchLastOut = NULL;
    const CAttrValue *pAV;
    CStr cstrStyle;
    BSTR bstr = NULL;
    BOOL fUseCompositeBackground    = FALSE;
    BOOL fUseCompositeBGPosition    = FALSE;
    BOOL fUseCompositeFont          = FALSE;
    BOOL fUseCompositeBorderTop     = FALSE;
    BOOL fUseCompositeBorderRight   = FALSE;
    BOOL fUseCompositeBorderBottom  = FALSE;
    BOOL fUseCompositeBorderLeft    = FALSE;
    BOOL fUseCompositeMargin        = FALSE;
    BOOL fUseCompositeLayoutGrid    = FALSE;
    BOOL fUseCompositeListStyle     = FALSE;

    int iLen;
    int idx;
    LPCTSTR lpPropName = NULL;
    LPCTSTR lpPropValue;
    BSTR bstrTemp;

    if ( !pbstr )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    if ( !(pAA && pAA->HasAnyAttribute(TRUE)) )
        goto Cleanup;

    //Quote style string?
    if (fQuote)
    {
        hr = cstrStyle.Append( _T("\"") );
        if (hr != S_OK)
            goto Cleanup;
    }

    if ( pAA->Find( DISPID_A_BACKGROUNDPOSX, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDPOSY, CAttrValue::AA_Attribute ) )
        fUseCompositeBGPosition = TRUE;
    if ( fUseCompositeBGPosition &&
         pAA->Find( DISPID_A_BACKGROUNDIMAGE , CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_BACKCOLOR, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDREPEAT, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDATTACHMENT, CAttrValue::AA_Attribute ) )
        fUseCompositeBackground = TRUE;

    if ( pAA->Find( DISPID_A_FONTWEIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTSTYLE,   CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTVARIANT, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTSIZE,    CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LINEHEIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTFACE,    CAttrValue::AA_Attribute ) )
        fUseCompositeFont = TRUE;

    if ( pAA->Find( DISPID_A_LAYOUTGRIDMODE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDTYPE,   CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDLINE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDCHAR,    CAttrValue::AA_Attribute ) )
        fUseCompositeLayoutGrid = TRUE;

    if ( pAA->Find( DISPID_A_BORDERTOPSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERTOPWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderTop = TRUE;

    if ( pAA->Find( DISPID_A_BORDERRIGHTSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERRIGHTWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderRight = TRUE;

    if ( pAA->Find( DISPID_A_BORDERBOTTOMSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERBOTTOMWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderBottom = TRUE;

    if ( pAA->Find( DISPID_A_BORDERLEFTSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERLEFTWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderLeft = TRUE;

    if ( pAA->Find( DISPID_A_MARGINTOP,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINRIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINBOTTOM,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINLEFT,  CAttrValue::AA_Attribute ) )
        fUseCompositeMargin = TRUE;
        
    if ( (pAA->Find(DISPID_A_LISTSTYLETYPE,  CAttrValue::AA_Attribute) &&
          pAA->Find(DISPID_A_LISTSTYLEPOSITION,  CAttrValue::AA_Attribute) &&
          pAA->Find(DISPID_A_LISTSTYLEIMAGE,  CAttrValue::AA_Attribute)) ||
         pAA->Find(DISPID_A_LISTSTYLE,  CAttrValue::AA_Attribute) )
        fUseCompositeListStyle = TRUE;

    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        DWORD dispid = ppropdesc->GetBasicPropParams()->dispid;

        pAV = NULL;

        // NOTE: for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
            continue;

        pbpp = (BASICPROPPARAMS *)(ppropdesc+1);

        if ( (pbpp->dwPPFlags & PROPPARAM_NOPERSIST) ||
                (!(pbpp->dwPPFlags&PROPPARAM_ATTRARRAY)))
            continue;

        switch ( dispid )
        {
        case DISPID_A_BACKGROUNDPOSX:
        case DISPID_A_BACKGROUNDPOSY:
            if ( fUseCompositeBGPosition )
                continue;
            break;
        case DISPID_A_BACKGROUNDIMAGE:
        case DISPID_BACKCOLOR:
        case DISPID_A_BACKGROUNDREPEAT:
        case DISPID_A_BACKGROUNDATTACHMENT:
            if ( fUseCompositeBackground )
                continue;
            break;
        case DISPID_A_FONTWEIGHT:
        case DISPID_A_FONTSTYLE:
        case DISPID_A_FONTVARIANT:
        case DISPID_A_FONTSIZE:
        case DISPID_A_LINEHEIGHT:
        case DISPID_A_FONTFACE:
            if ( fUseCompositeFont )
                continue;
            break;
        case DISPID_A_LAYOUTGRIDMODE:
        case DISPID_A_LAYOUTGRIDTYPE:
        case DISPID_A_LAYOUTGRIDLINE:
        case DISPID_A_LAYOUTGRIDCHAR:
            if ( fUseCompositeLayoutGrid )
                continue;
            break;
        case DISPID_A_BORDERTOPSTYLE:
        case DISPID_A_BORDERTOPWIDTH:
        case DISPID_A_BORDERTOPCOLOR:
            if ( fUseCompositeBorderTop )
                continue;
            break;
        case DISPID_A_BORDERRIGHTSTYLE:
        case DISPID_A_BORDERRIGHTWIDTH:
        case DISPID_A_BORDERRIGHTCOLOR:
            if ( fUseCompositeBorderRight )
                continue;
            break;
        case DISPID_A_BORDERBOTTOMSTYLE:
        case DISPID_A_BORDERBOTTOMWIDTH:
        case DISPID_A_BORDERBOTTOMCOLOR:
            if ( fUseCompositeBorderBottom )
                continue;
            break;
        case DISPID_A_BORDERLEFTSTYLE:
        case DISPID_A_BORDERLEFTWIDTH:
        case DISPID_A_BORDERLEFTCOLOR:
            if ( fUseCompositeBorderLeft )
                continue;
            break;
        case DISPID_A_MARGINTOP:
        case DISPID_A_MARGINRIGHT:
        case DISPID_A_MARGINBOTTOM:
        case DISPID_A_MARGINLEFT:
            if ( fUseCompositeMargin )
                continue;
            break;

        case DISPID_A_LISTSTYLETYPE:
        case DISPID_A_LISTSTYLEPOSITION:
        case DISPID_A_LISTSTYLEIMAGE:
            if ( fUseCompositeListStyle )
                continue;
            break;

        case DISPID_A_CLIPRECTTOP:
        case DISPID_A_CLIPRECTRIGHT:
        case DISPID_A_CLIPRECTBOTTOM:
        case DISPID_A_CLIPRECTLEFT:
            // We do not write out the components
            continue;

        case DISPID_A_CLIP:
        if ( pAA->Find( DISPID_A_CLIPRECTTOP,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTRIGHT,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTBOTTOM,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTLEFT,  CAttrValue::AA_Attribute ) )
             goto WriteOutName;
        continue;

        case DISPID_A_BACKGROUNDPOSITION:
            if ( fUseCompositeBGPosition && !fUseCompositeBackground )
                goto WriteOutName;
            continue;
        case DISPID_A_BACKGROUND:
            if ( fUseCompositeBackground )
                goto WriteOutName;
            continue;
        case DISPID_A_FONT:
            if ( fUseCompositeFont )
                goto WriteOutName;
            break;  // Font may be in the attr array, if it's a system font.
        case DISPID_A_LAYOUTGRID:
            if ( fUseCompositeLayoutGrid )
                goto WriteOutName;
            break;
        case DISPID_A_BORDERTOP:
            if ( fUseCompositeBorderTop )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERRIGHT:
            if ( fUseCompositeBorderRight )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERBOTTOM:
            if ( fUseCompositeBorderBottom )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERLEFT:
            if ( fUseCompositeBorderLeft )
                goto WriteOutName;
            continue;
        case DISPID_A_LISTSTYLE:
            if ( fUseCompositeListStyle )
                goto WriteOutName;
            continue;
        case DISPID_A_MARGIN:
            if ( fUseCompositeMargin )
                goto WriteOutName;
            continue;
        }
        // does this property exist in the aa?  We may skip this test if
        // this is a composite property (hence the gotos above), since they
        // may not actually be in the AA.
        if ( ( pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Attribute ) ) != NULL )
        {

WriteOutName:

            //Write out property name
            if (!pchLastOut || 0!=StrCmpC(pchLastOut, ppropdesc->pstrName))
            {
                if (pchLastOut)
                {
                    hr = cstrStyle.Append( _T("; ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrStyle.Append( ppropdesc->pstrName );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrStyle.Append( _T(": ") );
                if (hr != S_OK)
                    goto Cleanup;
                pchLastOut = ppropdesc->pstrName;
            }
            else
            {
                hr = cstrStyle.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }

            //Write out value
    #ifdef WIN16
            hr = (ppropdesc->pfnHandleProperty)( (PROPERTYDESC *)ppropdesc, HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16),
                                 (void *)&bstr, NULL, (CVoid*) (void*) &pAA);
    #else
            hr = CALL_METHOD( ppropdesc, ppropdesc->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16),
                                 (void *)&bstr, NULL, (CVoid*) (void*) &pAA));
    #endif
            if (hr == S_OK)
            {
                if(fQuote)
                {
                    // We are outputing to an inline style. For now we have to replace the 
                    //  double quotes to single, because of external pair of double quotes. Later
                    //   we might want to escape the quotes. We might also want to change how we pass
                    // in and out the string, because changing inplace will not work when escaping
                    // changes the string length, of course.
                    EscapeQuotes((LPTSTR)bstr);
                }
                hr = cstrStyle.Append( bstr );
                if (hr != S_OK)
                    goto Cleanup;
                FormsFreeString( bstr );
            }

            // TODO: Don't handle "! important" on composite properties.
            if ( pAV && pAV->IsImportant() )
            {
                hr = cstrStyle.Append( _T("! important") );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }

        // See if there's an expression
        if (    fSaveExpressions
            && ((pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Expression)) != NULL) )
        {
            //
            // TODO (michaelw) this will probably mess up if expressions are applied to composite properties
            //
            // The problem is actually caused by the poor way we loop through every possible attribute
            // apparently to make composite props come out right.  Sheesh!
            //
            if (pchLastOut)
            {
                hr = cstrStyle.Append(_T("; "));
                if (hr != S_OK)
                    goto Cleanup;
            }

            hr = cstrStyle.Append( _T("; ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append( ppropdesc->pstrName );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append( _T(": expression(") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append(pAV->GetLPWSTR());
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append(_T(")"));
            if (hr != S_OK)
                goto Cleanup;
            pchLastOut = ppropdesc->pstrName;
        }
    }

    // Look for all expandos & dump them out
    if ( pObject )
    {
        pAV = (CAttrValue *)(*pAA);
        iLen = pAA->Size();
        for ( idx=0; idx < iLen; idx++ )
        {
            if ((pAV->AAType() == CAttrValue::AA_Expando))
            {
                hr = pObject->GetExpandoName( pAV->GetDISPID(), &lpPropName );
                if (hr)
                    continue;

                if ( pAV->GetIntoString( &bstrTemp, &lpPropValue ) )
                    continue;   // Can't convert to string
                if(fQuote)
                {
                    // We are outputing to an inline style. For now we have to replace the 
                    //  double quotes to single, because of external pair of double quotes. Later
                    //   we might want to escape the quotes.
                    EscapeQuotes((LPTSTR)lpPropValue);
                }

                if (pchLastOut)
                {
                    hr = cstrStyle.Append( _T("; ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrStyle.Append( lpPropName );
                if (hr != S_OK)
                    goto Cleanup;
                pchLastOut = lpPropName;
                hr = cstrStyle.Append( _T(": ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrStyle.Append( lpPropValue );
                if (hr != S_OK)
                    goto Cleanup;
                if ( bstrTemp )
                    SysFreeString ( bstrTemp );
            }
            pAV++;
        }
    }

    // Quote style string?
    if (fQuote)
    {
        hr = cstrStyle.Append( _T("\"") );
        if (hr != S_OK)
            goto Cleanup;
    }

    if (cstrStyle.Length() )
    {
        hr = cstrStyle.AllocBSTR( pbstr );
        if (hr != S_OK)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBackgroundStyleToBSTR
//
//  Synopsis:   Converts 'background' property to a BSTR
//
//-------------------------------------------------------------------------

HRESULT WriteBackgroundStyleToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBackground;
    BSTR bstr = NULL;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    if ( S_OK == s_propdescCStylebackgroundImage.b.GetStyleComponentProperty(&bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("none") ) )
        {
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        goto Cleanup;
    }

    pAV = pAA->Find( DISPID_BACKCOLOR, CAttrValue::AA_Attribute );
    if ( pAV )
    {
        TCHAR szBuffer[64];
        CColorValue cvColor = (CColorValue)pAV->GetLong();

        if ( S_OK == cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL ) )
        {
            if ( _tcsicmp( szBuffer, _T("transparent") ) )
            {
                if ( cstrBackground.Length() )
                {
                    hr = cstrBackground.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBackground.Append( szBuffer );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString(bstr);
    bstr = NULL;

    if ( S_OK == s_propdescCStylebackgroundAttachment.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("scroll") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylebackgroundRepeat.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("repeat") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == WriteBackgroundPositionToBSTR( pAA, &bstr ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("0% 0%") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    // If we got this far, we have all the right properties in the AA... but if all of them were default,
    if ( !cstrBackground.Length() )
    {   // We want to put all the defaults in the string.
        hr = cstrBackground.Set( _T("none transparent scroll repeat 0% 0%") );
        goto Cleanup;
    }

Cleanup:
    FormsFreeString(bstr);
    if (hr == S_OK)
    {
        bstr = NULL;
        return cstrBackground.AllocBSTR( pbstr );
    }
    return (hr);
}

void    
CStyle::MaskPropertyChanges(BOOL fMask)
{ 
    if (fMask)
    {
        SetFlag(STYLE_MASKPROPERTYCHANGES);
    }
    else
    {
        ClearFlag(STYLE_MASKPROPERTYCHANGES);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CStyle::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    const PROPERTYDESC *pPropDesc = NULL;

    Assert(!ppropdesc || ppropdesc->GetDispid() == dispid);
    //Assert(!ppropdesc || ppropdesc->GetdwFlags() == dwFlags);

    if (TestFlag(STYLE_MASKPROPERTYCHANGES))
        goto Cleanup;

    DeleteCSSExpression(dispid);

    if (_pElem)
    {
        if(dispid == DISPID_A_POSITION)
        {
            CDoc * pDoc = _pElem->Doc();

            if(!pDoc->_fRegionCollection)
            {
                DWORD dwVal = 0;
                CAttrArray **ppAA = GetAttrArray();
                BOOL fFound = ppAA && *ppAA && (*ppAA)->FindSimple(DISPID_A_POSITION, &dwVal);

                if(fFound && ((stylePosition)dwVal == stylePositionrelative || 
                    (stylePosition)dwVal == stylePositionabsolute))
                {
                    pDoc->_fRegionCollection = TRUE;
                }
            }
        }

        // allow Element to make a decision based on distinguishing the same DISPID from
        // element vs in-line style, by OR'ing in the ELEMCHNG_INLINESTYLE_PROPERTY
        if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
        {
            pPropDesc = ppropdesc;
            dwFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
        }

        if (TestFlag(STYLE_NOCLEARCACHES))
        {
            //
            // NOTE: (anandra) HACK ALERT.  This is completely a workaround
            // for the fact that CElement::OnPropertyChange turns around and calls 
            // ComputeFormat.  This causes recursion for the behavior onstyleapply stuff.
            // By not clearing the formats here, we prevent this from happening.  
            // CPeerHolder::ApplyStyleMulti will clear the caches correctly.
            //
            
            dwFlags &= ~(ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF);
        }
        
        if (TestFlag(STYLE_DEFSTYLE))
        {
            dwFlags |= ELEMCHNG_DONTFIREEVENTS;
        }

        hr = THR(_pElem->OnPropertyChange(dispid, dwFlags, pPropDesc));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
HRESULT
CStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;
    AssertSz(eCookie==_dwCookie, "NOT A CSTYLE");

    // All interfaces derived from IDispatch must be handled
    // using the ElementDesc()->_apfnTearOff tearoff interface.
    // This allows classes such as COleSite to override the
    // implementation of IDispatch methods.

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle2, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle3, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle4, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_TEAROFF(this, IPerPropertyBrowsing, NULL)
        QI_TEAROFF(this, IRecalcProperty, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(_pElem, (IUnknown*)(IPrivateUnknown*)this);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
    default:
        {
            const CLASSDESC *pclassdesc = (CLASSDESC *) BaseDesc();

            if (iid == CLSID_CStyle)
            {
                *ppv = this;    // Weak ref
                return S_OK;
            }

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == IID_IHTMLStyle || DispNonDualDIID(iid) ))
            {
                hr = THR(CreateTearOffThunk(this,
                                            (void *)(pclassdesc->_apfnTearOff),
                                            NULL,
                                            ppv,
                                            (void *)(CStyle::s_ppropdescsInVtblOrderIHTMLStyle)));
            }
        }
    }
    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

STDMETHODIMP
CStyle::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;

    if (!_pAA && _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
    {
        Assert(_pElem);
        _pAA = *_pElem->CreateStyleAttrArray(_dispIDAA);
    }

    hr = THR_NOTRACE(CBase::GetDispID(bstrName, grfdex, pid));

    RRETURN(hr);
}

//*********************************************************************
// CStyle::Invoke, IDispatch
// Provides access to properties and members of the object. We use it
//      to invalidate the caches when a expando is changed on the style
//      so that it is propagated down to the elements it affects
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//*********************************************************************

STDMETHODIMP
CStyle::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // CBase knows how to handle this
    hr = THR_NOTRACE(CBase::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));

    if(hr)
        goto Cleanup;

    if (IsExpandoDISPID(dispidMember) && (wFlags & DISPATCH_PROPERTYPUT))
    {
        // pElem can be 0 only if we are a CRuleStyle. But in that case we
        // will not come here because CRuleStyle::InvokeEx will handle it and
        // call CBase::InvokeEx directly.
        Assert(_pElem != 0);
        // Invalidate the branch only, this is an inline style
        DWORD   dwFlag = ELEMCHNG_CLEARCACHES;
        _pElem->EnsureFormatCacheChange(dwFlag);
    }


Cleanup:
    SetErrorInfo( hr );
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

STDMETHODIMP
CStyle::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    Assert(_pElem);
    RRETURN(SetErrorInfo(_pElem->QueryService(guidService, riid, ppvObject)));
}


//+------------------------------------------------------------------------
//
//  Helper Function:    ValidStyleUrl
//
//  Synopsis:
//      This function determines if a string is a valid CSS-style URL
//  functional notation string (e.g. "url(http://www.foo.com/bar)").
//
//  Return Values:
//      zero if invalid, otherwise the length of the string inside
//-------------------------------------------------------------------------
size_t ValidStyleUrl(TCHAR *pch)
{
    size_t nLen = pch ? _tcslen(pch) : 0;
    if (   (nLen>=5)
          && (0==_tcsnicmp(pch, ARRAY_SIZE(strURLBeg) - 1, strURLBeg, ARRAY_SIZE(strURLBeg) - 1))
          && (_T(')') == pch[nLen-1])
    )
    {
        return nLen;
    }
    return 0;
}

//+------------------------------------------------------------------------
//
// Member:      DeleteCSSExpression
//
// Description: Delete a CSS expression by dispid
//
// Notes:       This function gets called by OnPropertyChange so
//              it needs to be pretty quick for the non recalc case
//
//+------------------------------------------------------------------------

BOOL
CStyle::DeleteCSSExpression(DISPID dispid)
{
    if (_pElem && (_pElem->Doc()->_recalcHost.GetSetValueDispid(_pElem) != dispid))
    {
        CAttrArray **ppAA = GetAttrArray();
        return ppAA && *ppAA && (*ppAA)->FindSimpleAndDelete(dispid, CAttrValue::AA_Expression);
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   CStyle::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CStyle::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr;

    switch (dispid)
    {
    case DISPID_IHTMLSTYLE_LEFT:
    case DISPID_IHTMLSTYLE_PIXELLEFT:
    case DISPID_IHTMLSTYLE_POSLEFT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    case DISPID_IHTMLSTYLE_TOP:
    case DISPID_IHTMLSTYLE_PIXELTOP:
    case DISPID_IHTMLSTYLE_POSTOP:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_WIDTH:
    case DISPID_IHTMLSTYLE_PIXELWIDTH:
    case DISPID_IHTMLSTYLE_POSWIDTH:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_HEIGHT:
    case DISPID_IHTMLSTYLE_PIXELHEIGHT:
    case DISPID_IHTMLSTYLE_POSHEIGHT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CStyle::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.removeExpression(this, strPropertyName, pfSuccess)));
}

ExternTag(tagRecalcDisableCSS);

STDMETHODIMP
CStyle::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_FALSE;)

    Assert( _pElem );

    if ( _pElem->IsPrintMedia() )
        return S_OK;

    _pElem->_fHasExpressions = TRUE;

    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.setExpression(this, strPropertyName, strExpression, strLanguage)));
}

STDMETHODIMP
CStyle::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.getExpression(this, strPropertyName, pvExpression)));
}

HRESULT 
CCSSParser::SetExpression(DISPID dispid, WORD wMaxstrlen /* = 0 */, TCHAR chOld /* = 0 */)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_FALSE;)

    HRESULT hr;
    TCHAR *p = (LPTSTR)_cbufBuffer;
    VARIANT v;

    if (chOld)
        p[wMaxstrlen] = chOld;

    // trim trailing whitespace
    _cbufBuffer.TrimTrailingWhitespace();

    // skip leading whitespace
    while (isspace(*p))
        p++;

    unsigned len = _cbufBuffer.Length() - (p - (LPTSTR)_cbufBuffer);

    // Are we looking at an expression()
    if (len > 11 &&
        !_tcsnicmp(p, 11, _T("expression("), 11) &&
        p[len - 1] == _T(')'))
    {
        p[len - 1] = 0;

        v.vt = VT_LPWSTR;
        v.byref = p + 11;

        hr = THR(CAttrArray::Set(_ppCurrProperties, dispid, &v, NULL, CAttrValue::AA_Expression));
    }
    else
        hr = S_FALSE;

    if (chOld)
        p[wMaxstrlen] = 0;

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     GetParentElement
//
//-------------------------------------------------------------------------

void
CCSSParser::GetParentElement(CElement ** ppElement)
{
    *ppElement = NULL;

    if (!_pStyleSheet)
    {
        HRESULT     hr;

        Assert(_pBaseObj);
        hr = _pBaseObj->PrivateQueryInterface(CLSID_CElement, (LPVOID *)ppElement);
        if (hr)
        {
            CStyle * pStyle;
            hr = _pBaseObj->PrivateQueryInterface(CLSID_CStyle, (LPVOID *)&pStyle);
            if(!hr)
                (*ppElement) = pStyle->GetElementPtr();
        }
    }
    else
    {
        (*ppElement) = _pStyleSheet->GetParentElement();
    }
}


//+------------------------------------------------------------------------
//
//  Function:     CCSSParser::SetDefaultNamespace
//
//  Synopsis:   Sets default namespace; in particular used by CXmlDeclElement
//
//-------------------------------------------------------------------------
void
CCSSParser::SetDefaultNamespace(LPCTSTR pchNamespace)
{
    _pDefaultNamespace = new CNamespace();
    if (!_pDefaultNamespace)
        goto Cleanup;

    _pDefaultNamespace->SetShortName(pchNamespace);

Cleanup:
    return;
}



//+------------------------------------------------------------------------
//
//  Function:     ::ParseBackgroundProperty
//
//  Synopsis:
//      This function reads a background property string from the given
//  data string, setting the internal style data of the CAttrArray to reflect any
//  given background styling.
//-------------------------------------------------------------------------
HRESULT ParseBackgroundProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBGString, BOOL bValidate )
{
    LPTSTR pszString, pszCopy;
    LPTSTR  pszNextToken;
    HRESULT hr = S_OK;
    BOOL fSeenXPos = FALSE;
    BOOL fSeenYPos = FALSE;
    PROPERTYDESC *pPropertyDesc;
    PROPERTYDESC *ppdPosX                 = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX.a;
    PROPERTYDESC *ppdPosY                 = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY.a;
    PROPERTYDESC *ppdBackgroundRepeat     = (PROPERTYDESC *)&s_propdescCStylebackgroundRepeat.a;
    PROPERTYDESC *ppdBackgroundAttachment = (PROPERTYDESC *)&s_propdescCStylebackgroundAttachment.a;
    PROPERTYDESC *ppdBackgroundImage      = (PROPERTYDESC *)&s_propdescCStylebackgroundImage.a;
    PROPERTYDESC *ppdBackgroundColor      = (PROPERTYDESC *)&s_propdescCStylebackgroundColor.a;
    BOOL fSeenBGColor      = FALSE;
    BOOL fSeenBGImage      = FALSE;
    BOOL fSeenBGRepeat     = FALSE;
    BOOL fSeenBGAttachment = FALSE;
    TCHAR *pszLastXToken = NULL;

    CAttrValue      avPosX, avPosY, avRepeat, avAttachment, avImage, avColor;
    
    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdPosX, &avPosX);
        BackupAttrValue (*ppAA, ppdPosY, &avPosY);
        BackupAttrValue (*ppAA, ppdBackgroundRepeat, &avRepeat);
        BackupAttrValue (*ppAA, ppdBackgroundImage, &avImage);
        BackupAttrValue (*ppAA, ppdBackgroundAttachment, &avAttachment);
        BackupAttrValue (*ppAA, ppdBackgroundColor, &avColor);
    }


    if ( !pcszBGString )
        pcszBGString = _T("");

    pszCopy = pszNextToken = pszString = new(Mt(ParseBackgroundProperty_pszCopy)) TCHAR [_tcslen( pcszBGString ) + 1 ];

    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszBGString );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = NextParenthesizedToken( pszString );

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        hr = ppdBackgroundRepeat->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );

        if ( hr != S_OK )
        {
            hr = ppdBackgroundAttachment->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );

            if ( hr != S_OK )
            {
                if ( ValidStyleUrl( pszString ) > 0 || !_tcsicmp( pszString, _T("none") ) )
                {
                    hr = ppdBackgroundImage->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                    fSeenBGImage = TRUE;
                }
                else
                {   // Try it as a color
                    hr = ppdBackgroundColor->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                    if ( hr == S_OK )
                    {   // We decided this was a color.
                        fSeenBGColor = TRUE;
                        continue;
                    }
                    else    // Not a color.
                    {   // First see if it's a measurement string
                        BOOL fTriedOneWay = FALSE;

                        // If two numeric values given, horizontal comes first (CSS spec).  If keywords
                        // are used ("top", "left" etc), order is irrelevant.
                        if ( !fSeenXPos )
                        {
TryAsX:
                            hr = ppdPosX->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                            if ( hr == S_OK )
                            {
                                fSeenXPos = TRUE;
                                if ( pszLastXToken && !fSeenYPos )
                                {
                                    if ( ppdPosY->TryLoadFromString (
                                            dwOpCode, pszLastXToken, pObject, ppAA ) == S_OK )
                                        fSeenYPos = TRUE;
                                }

                                pszLastXToken = pszString;
                                continue;
                            }
                            else if ( !fTriedOneWay )
                            {
                                fTriedOneWay = TRUE;
                                goto TryAsY;
                            }
                        }

                        if ( !fSeenYPos )
                        {
TryAsY:
                            hr = ppdPosY->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
                            if ( hr == S_OK )
                            {
                                fSeenYPos = TRUE;
                                continue;
                            }
                            else if ( !fTriedOneWay )
                            {
                                fTriedOneWay = TRUE;
                                goto TryAsX;
                            }
                        }
                    }

                    // The string could not be recognized as a valid background spec. We bail out in
                    // strict css1 mode
                    if (fIsStrictCSS1) 
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    
                    // Not a background string... return if we're in validate mode.
                    if ( bValidate )
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                } // end if else test for color
            } // end if test for background-attachment failure
            else
                fSeenBGAttachment = TRUE;
        } // end if test for background-repeat failure
        else
            fSeenBGRepeat = TRUE;
    } // end for next token
    if ( fSeenXPos ^ fSeenYPos )
    {   // If only one set, must set the other to "50%" as per the CSS spec.
        pPropertyDesc = fSeenXPos ? ppdPosY : ppdPosX;

#ifdef WIN16
        hr = (pPropertyDesc->pfnHandleProperty)( pPropertyDesc, (dwOpCode|(PROPTYPE_LPWSTR<<16)),
                            (CVoid *)_T("50%"), pObject, (CVoid *) ppAA );
#else
        hr = CALL_METHOD( pPropertyDesc, pPropertyDesc->pfnHandleProperty, ( (dwOpCode|(PROPTYPE_LPWSTR<<16)),
                            (CVoid *)_T("50%"), pObject, (CVoid *) ppAA ));
#endif
    }

    if ( !fSeenXPos && !fSeenYPos )
    {
        ppdPosX->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        ppdPosY->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
    }

    if ( !fSeenBGImage )
        ppdBackgroundImage->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
    if ( !fSeenBGColor )
        ppdBackgroundColor->TryLoadFromString ( dwOpCode, _T("transparent"), pObject, ppAA );
    if ( !fSeenBGRepeat )
        ppdBackgroundRepeat->TryLoadFromString ( dwOpCode, _T("repeat"), pObject, ppAA );
    if ( !fSeenBGAttachment )
        ppdBackgroundAttachment->TryLoadFromString ( dwOpCode, _T("scroll"), pObject, ppAA );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPosX, &avPosX);
                RestoreAttrArray(*ppAA, ppdPosY, &avPosY);
                RestoreAttrArray(*ppAA, ppdBackgroundAttachment, &avAttachment);
                RestoreAttrArray(*ppAA, ppdBackgroundColor, &avColor);
                RestoreAttrArray(*ppAA, ppdBackgroundImage, &avImage);
                RestoreAttrArray(*ppAA, ppdBackgroundRepeat, &avRepeat);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // Clean up the temporary attribute backups
        avPosX.Free();
        avPosY.Free();
        avAttachment.Free();
        avColor.Free();
        avImage.Free();
        avRepeat.Free();
    }

    delete[] pszCopy ;
    RRETURN1( hr, E_INVALIDARG);
}

typedef struct {
    const TCHAR *szName;
    Esysfont eType;
} SystemFontName;

const SystemFontName asSystemFontNames[] =
{
    { _T("caption"), sysfont_caption },
    { _T("icon"), sysfont_icon },
    { _T("menu"), sysfont_menu },
    { _T("message-box"), sysfont_messagebox },
    { _T("messagebox"), sysfont_messagebox },
    { _T("small-caption"), sysfont_smallcaption },
    { _T("smallcaption"), sysfont_smallcaption },
    { _T("status-bar"), sysfont_statusbar },
    { _T("statusbar"), sysfont_statusbar }
};

int RTCCONV
CompareSysFontPairsByName( const void * pv1, const void * pv2 )
{
    return StrCmpIC( ((SystemFontName *)pv1)->szName,
                     ((SystemFontName *)pv2)->szName );
}

Esysfont FindSystemFontByName( const TCHAR * szString )
{
    SystemFontName sPotentialSysFont;

    sPotentialSysFont.szName = szString;

    SystemFontName *pFont = (SystemFontName *)bsearch( &sPotentialSysFont,
                                              asSystemFontNames,
                                              ARRAY_SIZE(asSystemFontNames),
                                              sizeof(SystemFontName),
                                              CompareSysFontPairsByName );
    if ( pFont )
        return pFont->eType;
    return sysfont_non_system;
}


//+------------------------------------------------------------------------
//
//  Function:     ::ParseFontProperty
//
//  Synopsis:
//      This function reads an aggregate font property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  font weight, style, variant, size, line-height, or families set by the string.
//-------------------------------------------------------------------------
HRESULT ParseFontProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszFontString )
{
    LPTSTR pszString, pszCopy;
    LPTSTR  pszNextToken;
    HRESULT hResult = S_OK;
    TCHAR chTerminator;
    BOOL fFontWeight  = FALSE;
    BOOL fFontStyle   = FALSE;
    BOOL fFontVariant = FALSE;

    PROPERTYDESC* ppdWeight     = (PROPERTYDESC*)&s_propdescCStylefontWeight.a;
    PROPERTYDESC* ppdStyle      = (PROPERTYDESC*)&s_propdescCStylefontStyle.a;
    PROPERTYDESC* ppdVariant    = (PROPERTYDESC*)&s_propdescCStylefontVariant.a;
    PROPERTYDESC* ppdSize       = (PROPERTYDESC*)&s_propdescCStylefontSize.a;
    PROPERTYDESC* ppdLineHeight = (PROPERTYDESC*)&s_propdescCStylelineHeight.a;
    PROPERTYDESC* ppdFamily     = (PROPERTYDESC*)&s_propdescCStylefontFamily.a;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avWeight, avStyle, avSize, avVariant, avLineHeight, avFamily;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdWeight, &avWeight);
        BackupAttrValue (*ppAA, ppdStyle, &avStyle);
        BackupAttrValue (*ppAA, ppdVariant, &avVariant);
        BackupAttrValue (*ppAA, ppdSize, &avSize);
        BackupAttrValue (*ppAA, ppdLineHeight, &avLineHeight);
        BackupAttrValue (*ppAA, ppdFamily, &avFamily);
    }

    if ( !pcszFontString || !*pcszFontString )
        return E_INVALIDARG;

    pszCopy = pszNextToken = pszString = new(Mt(ParseFontProperty_pszCopy)) TCHAR [_tcslen( pcszFontString ) + 1 ];
    if ( !pszString )
    {
        hResult = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszFontString );

    // Peel off (and handle) any font weight, style, or variant strings at the beginning
    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;

        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        // Try font weight handler first
        hResult = ppdWeight->TryLoadFromString( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontWeight = TRUE;
            continue;   // token was a font weight - go on to next token
        }

        // Try font style handler next
        hResult = ppdStyle->TryLoadFromString( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontStyle = TRUE;
            continue;   // token was a font style - go on to next token
        }

        // Try font variant handler last
        hResult = ppdVariant->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            if (fIsStrictCSS1 && fFontWeight && fFontStyle && fFontVariant)
            {
                hResult = E_INVALIDARG;
                goto Cleanup;
            }
            fFontVariant = TRUE;
            continue;   // token was a font variant - go on to next token
        }

        break;  // String was unrecognized; must be a font-size.
    }

    if ( !*pszString )
    {
        hResult = E_INVALIDARG;
        goto Cleanup;
    }

    if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
        *(pszNextToken - 1) = _T(' ');

    pszNextToken = NextSize( pszString, &s_propdescCStylefontSize.b);

    if ( !pszNextToken )
    {
        hResult = E_INVALIDARG;
        goto Cleanup;
    }

    chTerminator = *pszNextToken;
    *pszNextToken = _T('\0');

    hResult = ppdSize->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
    if ( hResult != S_OK )
        goto Cleanup;

    *pszNextToken = chTerminator;
    while ( _istspace( *pszNextToken ) )
        pszNextToken++;

    if ( *pszNextToken == _T('/') )
    {   // There is a line-height value present
        pszString = ++pszNextToken;
        pszNextToken = fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelineHeight.b );

        if ( !pszNextToken )
        {
            hResult = E_INVALIDARG;
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
        }

        chTerminator = *pszNextToken;
        *pszNextToken = _T('\0');

        hResult = ppdLineHeight->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult != S_OK )
        {
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
        }

        *pszNextToken = chTerminator;
        while ( _istspace( *pszNextToken ) )
            pszNextToken++;
    }
    else
    {
        hResult = ppdLineHeight->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );
        if ( hResult != S_OK )
            if (fIsStrictCSS1)
                goto Cleanup;
            else
                goto SetDefaults;
    }

    if ( !*pszNextToken )
    {
        hResult = E_INVALIDARG;
        if (fIsStrictCSS1)
            goto Cleanup;
        else
            goto SetDefaults;
    }

    if ( OPCODE(dwOpCode) == HANDLEPROP_AUTOMATION )
    {
        BSTR bstr;

        hResult = FormsAllocString( pszNextToken, &bstr );
        if ( hResult )
            goto SetDefaults;

        hResult = s_propdescCStylefontFamily.b.SetStringProperty( bstr, pObject, (CVoid *)ppAA );

        FormsFreeString( bstr );

        if ( hResult )
            goto SetDefaults;
    }
    else
    {
        hResult = ppdFamily->TryLoadFromString ( dwOpCode, pszNextToken, pObject, ppAA );
        if (hResult && fIsStrictCSS1)
            goto Cleanup; // in strict
    }

SetDefaults:
    // Set the default font weight
    if ( !fFontWeight )
        ppdWeight->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

    // Set the default font style
    if ( !fFontStyle )
        ppdStyle->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

    // Set the default font variant
    if ( !fFontVariant )
        ppdVariant->TryLoadFromString ( dwOpCode, _T("normal"), pObject, ppAA );

Cleanup:
    if (hResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdWeight, &avWeight);
                RestoreAttrArray(*ppAA, ppdStyle, &avStyle);
                RestoreAttrArray(*ppAA, ppdVariant, &avVariant);
                RestoreAttrArray(*ppAA, ppdSize, &avSize);
                RestoreAttrArray(*ppAA, ppdLineHeight, &avLineHeight);
                RestoreAttrArray(*ppAA, ppdFamily, &avFamily);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avWeight.Free();
        avStyle.Free();
        avVariant.Free();
        avSize.Free();
        avLineHeight.Free();
        avFamily.Free();
    }
  
    delete[] pszCopy;

    RRETURN1( hResult, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseLayoutGridProperty
//
//  Synopsis:
//      This function reads an aggregate layout-grid property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  layout grid values set by the string.
//-------------------------------------------------------------------------
HRESULT ParseLayoutGridProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszGridString )
{
    LPTSTR  pszString;
    LPTSTR  pszNextToken;
    HRESULT hResult = S_OK;
    TCHAR chTerminator = _T('\0');
    BOOL fGridMode = FALSE;
    BOOL fGridType = FALSE;
    BOOL fGridChar = FALSE;
    BOOL fGridLine = FALSE;
    PROPERTYDESC* ppdGridMode = (PROPERTYDESC*)&s_propdescCStylelayoutGridMode.a;
    PROPERTYDESC* ppdGridType = (PROPERTYDESC*)&s_propdescCStylelayoutGridType.a;
    PROPERTYDESC* ppdGridLine = (PROPERTYDESC*)&s_propdescCStylelayoutGridLine.a;
    PROPERTYDESC* ppdGridChar = (PROPERTYDESC*)&s_propdescCStylelayoutGridChar.a;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avGridMode, avGridType, avGridLine, avGridChar;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdGridMode, &avGridMode);
        BackupAttrValue (*ppAA, ppdGridType, &avGridType);
        BackupAttrValue (*ppAA, ppdGridLine, &avGridLine);
        BackupAttrValue (*ppAA, ppdGridChar, &avGridChar);
    }

    

    if ( !pcszGridString || !*pcszGridString )
        goto SetDefaults;

    pszString = (LPTSTR)pcszGridString;

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid mode
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;
        if ( *pszNextToken )
        {
            chTerminator = *pszNextToken;
            *pszNextToken++ = _T('\0');
        }

        hResult = ppdGridMode->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            fGridMode = TRUE;
            pszString = pszNextToken;
        }
        if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
            *(pszNextToken - 1) = chTerminator;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid type
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && !_istspace( *pszNextToken ) )
            pszNextToken++;
        if ( *pszNextToken )
        {
            chTerminator = *pszNextToken;
            *pszNextToken++ = _T('\0');
        }

        hResult = ppdGridType->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
        if ( hResult == S_OK )
        {
            fGridType = TRUE;
            pszString = pszNextToken;
        }
        if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
            *(pszNextToken - 1) = chTerminator;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid line size
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelayoutGridLine.b);

        if ( pszNextToken )
        {
            if ( *pszNextToken )
            {
                chTerminator = *pszNextToken;
                *pszNextToken++ = _T('\0');
            }

            hResult = ppdGridLine->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hResult == S_OK )
            {
                fGridLine = TRUE;
                pszString = pszNextToken;
            }
            if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
                *(pszNextToken - 1) = chTerminator;
        }
        else
            hResult = E_INVALIDARG;
    }

    if ( !*pszString )
        goto SetDefaults;

    // Read in the grid char size
    if ( hResult == S_OK )
    {

        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = 
            fIsStrictCSS1 ? NextParenthesizedToken ( pszString ) : NextSize( pszString, &s_propdescCStylelayoutGridChar.b);

        if ( pszNextToken )
        {
            if ( *pszNextToken )
            {
                chTerminator = *pszNextToken;
                *pszNextToken++ = _T('\0');
            }

            hResult = ppdGridChar->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hResult == S_OK )
            {
                fGridChar = TRUE;
                pszString = pszNextToken;
            }
            if ( *pszNextToken )    // If we replaced a space with a NULL, unreplace it.
                *(pszNextToken - 1) = chTerminator;
        }
        else
            hResult = E_INVALIDARG;
    }

    if (fIsStrictCSS1)
    { // check if there is coming something after the last token. In strict css1 mode we need to fail then.
        while (_istspace(*pszNextToken))
            pszNextToken++;
        if (*pszNextToken)
            hResult = E_INVALIDARG;
    }

SetDefaults:
    // Set the default layout grid mode
    if ( !fGridMode )
        ppdGridMode->TryLoadFromString ( dwOpCode, _T("both"), pObject, ppAA );
    // Set the default layout grid type
    if ( !fGridType )
        ppdGridType->TryLoadFromString ( dwOpCode, _T("loose"), pObject, ppAA );
    // Set the default layout grid line
    if ( !fGridLine )
        ppdGridLine->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
    // Set the default layout grid char
    if ( !fGridChar )
        ppdGridChar->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );

    if (hResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdGridMode, &avGridMode);
                RestoreAttrArray(*ppAA, ppdGridType, &avGridType);
                RestoreAttrArray(*ppAA, ppdGridLine, &avGridLine);
                RestoreAttrArray(*ppAA, ppdGridChar, &avGridChar);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avGridMode.Free();
        avGridType.Free();
        avGridLine.Free();
        avGridChar.Free();
    }


    RRETURN1( hResult, E_INVALIDARG );
}


HRESULT GetExpandingPropdescs( DWORD dwDispId, PROPERTYDESC **pppdTop, PROPERTYDESC **pppdRight,
                               PROPERTYDESC **pppdBottom, PROPERTYDESC **pppdLeft )
{
    switch ( dwDispId )
    {
    case DISPID_A_PADDING:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStylepaddingTop.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStylepaddingRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStylepaddingBottom.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStylepaddingLeft.a;
        break;
    case DISPID_A_MARGIN:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStylemarginTop.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStylemarginRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStylemarginBottom.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStylemarginLeft.a;
        break;
    case DISPID_A_BORDERCOLOR:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopColor.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightColor.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomColor.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftColor.a;
        break;
    case DISPID_A_BORDERWIDTH:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopWidth.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightWidth.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomWidth.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftWidth.a;
        break;
    case DISPID_A_BORDERSTYLE:
        *pppdTop = (PROPERTYDESC *)&s_propdescCStyleborderTopStyle.a;
        *pppdRight = (PROPERTYDESC *)&s_propdescCStyleborderRightStyle.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleborderBottomStyle.a;
        *pppdLeft = (PROPERTYDESC *)&s_propdescCStyleborderLeftStyle.a;
        break;
    case DISPID_A_CLIP:
        *pppdTop    = (PROPERTYDESC *)&s_propdescCStyleclipTop.a;
        *pppdRight  = (PROPERTYDESC *)&s_propdescCStyleclipRight.a;
        *pppdBottom = (PROPERTYDESC *)&s_propdescCStyleclipBottom.a;
        *pppdLeft   = (PROPERTYDESC *)&s_propdescCStyleclipLeft.a;
        break;

    default:
        Assert( "Unrecognized expansion property!" && FALSE );
        return S_FALSE;
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseExpandProperty
//
//  Synopsis:
//      This function reads a "margin" or "padding" property value from the
//  given data string, setting the internal data of the CAttrArray to reflect
//  any given margins or padding.  This function handles expansion of the
//  margin or padding values if less than four values are present.
//-------------------------------------------------------------------------
HRESULT ParseExpandProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBGString, DWORD dwDispId, BOOL fIsMeasurements )
{
    LPTSTR  pszCopy;
    LPTSTR  pszTop, pszRight, pszBottom, pszLeft, pszEnd;
    HRESULT hr = S_OK;
    CUnitValue cuv;
    PROPERTYDESC *ppdTop;
    PROPERTYDESC *ppdRight;
    PROPERTYDESC *ppdBottom;
    PROPERTYDESC *ppdLeft;

    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue avTop, avRight, avLeft, avBottom;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if ( THR( GetExpandingPropdescs( dwDispId, &ppdTop, &ppdRight, &ppdBottom, &ppdLeft ) ) )
        return S_FALSE;

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdTop, &avTop);
        BackupAttrValue (*ppAA, ppdRight, &avRight);
        BackupAttrValue (*ppAA, ppdLeft, &avLeft);
        BackupAttrValue (*ppAA, ppdBottom, &avBottom);
    }

    if ( !pcszBGString )
        pcszBGString = _T("");

    pszTop = pszRight = pszBottom = pszLeft = pszCopy = new(Mt(ParseExpandProperty_pszCopy)) TCHAR [_tcslen( pcszBGString ) + 1 ];
    if ( !pszTop )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy, pcszBGString );


    // (gschneid) 
    // NextParenthizedToken parses two kinds of tokens: simple ones like "100px" from whitespace to whitespace and the functional
    // notation "rgb(...)", but not "100 px" because there's a space between "100" and "px". NextSize parses only measurements and
    // also takes care of spaces between number and unit specifier like in "100 px". I.e. given the input "100 px" NextParenthizedToken 
    // will return the tokens "100" and "px" and NextSize will return "100 px" as the next token. Depending on the value of fIsMeasurements
    // either the function NextSize or NextParenthizedToken is called. 
    // In strict CSS1 "100 px" is not a valid specifiaction of a measure because of the space between number and unit specifier. This means
    // it is sufficient to use NextParenthizedToken for tokenizing the input. But this is equivalent to set fIsMeasurement to FALSE.

    if (fIsStrictCSS1)
        fIsMeasurements = FALSE;

    if ( *pszCopy )
    {
        while ( _istspace( *pszTop ) )
            pszTop++;       // Skip any leading whitespace
        if ( !fIsMeasurements )
            pszRight = NextParenthesizedToken( pszTop );
        else
            pszRight = NextSize( pszTop, (NUMPROPPARAMS *)(ppdTop + 1) );

        if ( pszRight && !*pszRight )
            pszRight = NULL;

        if ( pszRight )
        {
            *pszRight++ = _T('\0');
        }

        if ( fIsMeasurements )
        {
            // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
            Assert(!fIsStrictCSS1);
            hr = THR( cuv.FromString( pszTop, ppdTop, FALSE ) );
        }
        if ( hr )
            goto Cleanup;

        if ( pszRight )
        {
            // Got the top value - let's check for the right value.
            while ( _istspace( *pszRight ) )
                pszRight++;       // Skip any leading whitespace
            if ( !fIsMeasurements )
                pszBottom = NextParenthesizedToken( pszRight );
            else
                pszBottom = NextSize( pszRight, (NUMPROPPARAMS *)(ppdRight + 1) );

            if ( pszBottom && !*pszBottom )
                pszBottom = NULL;

            if ( pszBottom )
            {
                *pszBottom++ = _T('\0');
            }

            if ( fIsMeasurements )
            {
                // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                Assert(!fIsStrictCSS1);
                hr = THR( cuv.FromString( pszRight, ppdRight, FALSE) );
            }
            if ( hr == S_OK )
            {
                pszLeft = pszRight;

                if ( pszBottom )
                {
                    // Got the right value - let's check for the bottom value.
                    while ( _istspace( *pszBottom ) )
                        pszBottom++;       // Skip any leading whitespace
                    if ( !fIsMeasurements )
                        pszLeft = NextParenthesizedToken( pszBottom );
                    else
                        pszLeft = NextSize( pszBottom, (NUMPROPPARAMS *)(ppdBottom + 1) );

                    if ( pszLeft && !*pszLeft )
                        pszLeft = NULL;

                    if ( pszLeft )
                    {
                        *pszLeft++ = _T('\0');

                        while ( _istspace( *pszLeft ) )
                            pszLeft++;       // Skip any leading whitespace
                        if ( pszLeft && !*pszLeft )
                            pszLeft = NULL;
                    }

                    if ( fIsMeasurements )
                    {
                        // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                        Assert(!fIsStrictCSS1);
                        hr = THR( cuv.FromString( pszBottom, ppdBottom, FALSE) );
                    }
                    if ( hr == S_OK )
                    {
                        if ( pszLeft )
                        {
                            if ( !fIsMeasurements )
                                pszEnd = NextParenthesizedToken( pszLeft );
                            else
                                pszEnd = NextSize( pszLeft, (NUMPROPPARAMS *)(ppdLeft + 1) );

                            if ( pszEnd && !*pszEnd )
                                pszEnd = NULL;

                            if ( pszEnd )
                                *pszEnd = _T('\0');

                            // Got the bottom value - let's check for the left value.
                            if ( fIsMeasurements )
                            {
                                // In strict css1 mode fIsMeasurements is always set to FALSE, i.e. a this branch of the if statement can never be executed.
                                Assert(!fIsStrictCSS1);
                                hr = THR( cuv.FromString( pszLeft, ppdLeft, FALSE) );
                            }
                            if ( hr != S_OK )
                                pszLeft = pszRight; // Failed to get left value
                        }
                        else    // No left value present
                            pszLeft = pszRight;
                    }
                    else    // Failed to get bottom value
                        pszBottom = pszTop;
                }
                else    // No bottom or left value present
                    pszBottom = pszTop;
            }
            else    // Failed to get right value
                pszRight = pszTop;
        }
        else    // Only one margin present
            pszRight = pszTop;
    }
    else
    {   // Empty string should still clear the properties.
        pszTop = pszRight = pszBottom = pszLeft = pszCopy;
    }

    hr =  ppdTop->TryLoadFromString ( dwOpCode, pszTop, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdRight->TryLoadFromString ( dwOpCode, pszRight, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdBottom->TryLoadFromString ( dwOpCode, pszBottom, pObject, ppAA );
    if ( hr )
        goto Cleanup;
    hr =  ppdLeft->TryLoadFromString ( dwOpCode, pszLeft, pObject, ppAA );

    if (fIsStrictCSS1) 
    {   // In strict CSS1 only a max of 4 margin/padding spezifiers are allowed
        // Either bottom or left must be the most right
        if (pszLeft > pszBottom) {
            pszEnd = pszLeft;
        }
        else
        {
            pszEnd = pszBottom;
        }
        // Advance to the end of the last specification in the incoming string
        while (*pszEnd) pszEnd++;
        // If we are not at the end of the incoming string go one more
        if (pcszBGString[pszEnd-pszCopy])
            pszEnd++;
        // Now lets skip white spaces
        while ( _istspace( *pszEnd ) )
            pszEnd++;
        if (*pszEnd) 
            hr = E_INVALIDARG;      
    }
    

Cleanup:

    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdTop, &avTop);
                RestoreAttrArray(*ppAA, ppdRight, &avRight);
                RestoreAttrArray(*ppAA, ppdLeft, &avLeft);
                RestoreAttrArray(*ppAA, ppdBottom, &avBottom);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avTop.Free();
        avRight.Free();
        avLeft.Free();
        avBottom.Free();
    }

    delete[] pszCopy ;
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseBorderProperty
//
//  Synopsis:
//      This function reads an aggregate border property string from the given
//  data string, setting the internal data of the CAttrArray to reflect any
//  border styles, widths, or colors set by the string.
//-------------------------------------------------------------------------
HRESULT ParseBorderProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBorderString )
{
    HRESULT hr = S_OK;


    hr = s_propdescCStyleborderTop.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderRight.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderBottom.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );
    if ( hr != S_OK && hr != E_INVALIDARG )
        return hr;

    hr = s_propdescCStyleborderLeft.a.TryLoadFromString ( dwOpCode, pcszBorderString,pObject, ppAA );

    return hr;
}

HRESULT GetBorderSidePropdescs( DWORD dwDispId, PROPERTYDESC **pppdStyle,
                               PROPERTYDESC **pppdColor, PROPERTYDESC **pppdWidth )
{
    Assert( "Must have PD pointers!" && pppdStyle && pppdColor && pppdWidth );

    PROPERTYDESC *borderpropdescs[3][4] =
    { { (PROPERTYDESC *)&s_propdescCStyleborderTopStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomStyle.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftStyle.a },
      { (PROPERTYDESC *)&s_propdescCStyleborderTopColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomColor.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftColor.a },
      { (PROPERTYDESC *)&s_propdescCStyleborderTopWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderRightWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderBottomWidth.a,
        (PROPERTYDESC *)&s_propdescCStyleborderLeftWidth.a } };

    switch ( dwDispId )
    {
    case DISPID_A_BORDERTOP:
        *pppdStyle = borderpropdescs[0][0];
        *pppdColor = borderpropdescs[1][0];
        *pppdWidth = borderpropdescs[2][0];
        break;
    case DISPID_A_BORDERRIGHT:
         *pppdStyle = borderpropdescs[0][1];
        *pppdColor = borderpropdescs[1][1];
        *pppdWidth = borderpropdescs[2][1];
        break;
    case DISPID_A_BORDERBOTTOM:
        *pppdStyle = borderpropdescs[0][2];
        *pppdColor = borderpropdescs[1][2];
        *pppdWidth = borderpropdescs[2][2];
        break;
    case DISPID_A_BORDERLEFT:
        *pppdStyle = borderpropdescs[0][3];
        *pppdColor = borderpropdescs[1][3];
        *pppdWidth = borderpropdescs[2][3];
        break;
    default:
        Assert( "Not a DISPID for a valid border property!" );
        return S_FALSE;
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:     ::ParseAndExpandBorderSideProperty
//
//  Synopsis:
//      This function takes an aggregate border side property string (e.g. the
//  string for "border-top") and sets the internal data of the CAttrArray to
//  reflect any border style, width or color set by the string.
//-------------------------------------------------------------------------
HRESULT ParseAndExpandBorderSideProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBorderString, DWORD dwDispId )
{
    LPTSTR          pszString, pszCopy, pszNextToken;
    HRESULT         hr = S_OK;
    PROPERTYDESC  * ppdStyle;
    PROPERTYDESC  * ppdColor;
    PROPERTYDESC  * ppdWidth;
    int             nSeenStyle = 0;
    int             nSeenWidth = 0;
    int             nSeenColor = 0;
    
    // The following variables are needed for backing up the attributes. They are used for restoring in error cases in strict CSS1 mode
    CAttrValue      avColor, avWidth, avStyle;
    
    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if ( S_FALSE == GetBorderSidePropdescs( dwDispId, &ppdStyle, &ppdColor, &ppdWidth ) )
        return S_FALSE;

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdColor, &avColor);
        BackupAttrValue (*ppAA, ppdWidth, &avWidth);
        BackupAttrValue (*ppAA, ppdStyle, &avStyle);
    }

    if ( !pcszBorderString )
        pcszBorderString = _T("");

    pszCopy = pszNextToken = pszString = new(Mt(ParseAndExpandBorderSideProperty_pszCopy)) TCHAR [_tcslen( pcszBorderString ) + 1 ];
    if ( !pszCopy )
    {
        return E_OUTOFMEMORY;
    }
    _tcscpy( pszCopy, pcszBorderString );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = NextParenthesizedToken( pszString );

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        hr = ppdStyle->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA);

        if ( hr != S_OK )
        {   // Let's see if it's a measurement string
            hr = ppdWidth->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA );
            if ( hr != S_OK )
            {   // Try it as a color
                hr = ppdColor->TryLoadFromString( dwOpCode, pszString, pObject, ppAA);
                if ( hr != S_OK )
                {   // Not a valid border string token
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                else
                    nSeenColor++;
            }
            else
                nSeenWidth++;
        }
        else
            nSeenStyle++;
    }

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdColor, &avColor);
                RestoreAttrArray(*ppAA, ppdWidth, &avWidth);
                RestoreAttrArray(*ppAA, ppdStyle, &avStyle);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avColor.Free();
        avWidth.Free();
        avStyle.Free();
    }   

    if (!fIsStrictCSS1 && !hr) 
    {
        if (nSeenStyle == 0)
            ppdStyle->TryLoadFromString ( dwOpCode, _T("none"), pObject, ppAA );
        if (nSeenWidth == 0)
            ppdWidth->TryLoadFromString ( dwOpCode, _T("medium"), pObject, ppAA );
        if (nSeenColor == 0)
        {
            DWORD dwVal;
            if ( *ppAA )
                (*ppAA)->FindSimpleInt4AndDelete( ppdColor->GetBasicPropParams()->dispid, &dwVal, CAttrValue::AA_StyleAttribute );
        }
    }

    if(!hr && (nSeenStyle > 1 || nSeenWidth > 1 || nSeenColor > 1))
        hr = E_INVALIDARG;

    delete[] pszCopy ;

    RRETURN1( hr, E_INVALIDARG );

}

CAttrArray **CStyle::GetAttrArray ( void ) const
{
    CAttrArray **ppAA;
    
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        CAttrArray **ppAASrc = const_cast<CAttrArray **>(&_pAA);
        ppAA = _pElem->CreateStyleAttrArray(_dispIDAA);
        if (ppAA)
            *ppAASrc = *ppAA;
        return ppAA;
    }

    ppAA = const_cast<CAttrArray **>(&_pAA);
    if (*ppAA)
        return ppAA;
        
    *ppAA = new CAttrArray;
    return ppAA;
}


//+------------------------------------------------------------------------
//
//  Function:   ::ParseTextDecorationProperty
//
//  Synopsis:   Parses a text-decoration string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseTextDecorationProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszTextDecoration, WORD wFlags )
{
    TCHAR *pszString;
    TCHAR *pszCopy = NULL;
    TCHAR *pszNextToken;
    HRESULT hr = S_OK;
    BOOL fInvalidValues = FALSE;
    BOOL fInsideParens;
    VARIANT v;
    CVariant varOld;
    BOOL fTreeSync=FALSE;

    Assert( ppAA && "No (CAttrArray*) pointer!" );

    PROPERTYDESC *ppdTextDecoration  = (PROPERTYDESC*)&s_propdescCStyletextDecoration.a;

    CAttrValue avTextDecoration;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.
        BackupAttrValue (*ppAA, ppdTextDecoration, &avTextDecoration);
    }

#ifndef NO_EDIT
    if (pObject)
    {
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {

            V_VT(&varOld) = VT_BSTR;
            WriteTextDecorationToBSTR( *ppAA, &(V_BSTR(&varOld)) );

            if( fTreeSync )
            {
                VARIANT    varNew;

                V_VT( &varNew ) = VT_LPWSTR;
                varNew.byref = (void*)pcszTextDecoration;
    
                pObject->LogAttributeChange( DISPID_A_TEXTDECORATION, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(DISPID_A_TEXTDECORATION, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    if ( !pcszTextDecoration )
        pcszTextDecoration = _T("");

    v.vt = VT_I4;
    v.lVal = 0;

    pszCopy = pszNextToken = pszString = new(Mt(ParseTextDecorationProperty_pszCopy)) TCHAR [_tcslen(  pcszTextDecoration ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy,  pcszTextDecoration );

    // Loop through the tokens in the string (parenthesis parsing is for future
    // text-decoration values that might have parameters).
    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fInsideParens = FALSE;
        while ( _istspace( *pszString ) )
            pszString++;

        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;
            pszNextToken++;
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        if ( !StrCmpIC( pszString, _T("none") ) )
            v.lVal = TD_NONE;   // "none" clears all the other properties (unlike the other properties)
        else if ( !StrCmpIC( pszString, _T("underline") ) )
            v.lVal |= TD_UNDERLINE;
        else if ( !StrCmpIC( pszString, _T("overline") ) )
            v.lVal |= TD_OVERLINE;
        else if ( !StrCmpIC( pszString, _T("line-through") ) )
            v.lVal |= TD_LINETHROUGH;
        else if ( !StrCmpIC( pszString, _T("blink") ) )
            v.lVal |= TD_BLINK;
        else
        {
            fInvalidValues = TRUE;
            if (fIsStrictCSS1)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }

    hr = CAttrArray::Set( ppAA, DISPID_A_TEXTDECORATION, &v,
                    (PROPERTYDESC *)&s_propdescCStyletextDecoration, CAttrValue::AA_StyleAttribute, wFlags );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdTextDecoration, &avTextDecoration);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avTextDecoration.Free();    
    }

    delete[] pszCopy;
    RRETURN1( fInvalidValues ? (hr?hr:E_INVALIDARG) : hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseTextAutospaceProperty
//
//  Synopsis:   Parses a text-autospace string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseTextAutospaceProperty( CAttrArray **ppAA, LPCTSTR pcszTextAutospace, DWORD dwOpCode, WORD wFlags )
{
    TCHAR *pszTokenBegin;
    TCHAR *pszCopy;
    TCHAR *pszTokenEnd;
    HRESULT hr = S_OK;
    BOOL fInvalidValues = FALSE;
    VARIANT v;
    

    Assert( ppAA && "No (CAttrArray*) pointer!" );

    if ( !pcszTextAutospace )
        pcszTextAutospace = _T("");

    v.vt = VT_I4;
    v.lVal = 0;

    pszCopy = pszTokenBegin = pszTokenEnd = new(Mt(ParseTextAutospaceProperty_pszCopy)) TCHAR [_tcslen(  pcszTextAutospace ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy( pszCopy,  pcszTextAutospace );

    for ( pszTokenBegin = pszTokenEnd = pszCopy;
          pszTokenBegin && *pszTokenBegin; 
          pszTokenBegin = pszTokenEnd )
    {
        while ( _istspace( *pszTokenBegin ) )
            pszTokenBegin++;

        pszTokenEnd = pszTokenBegin;
        
        while ( *pszTokenEnd && !_istspace( *pszTokenEnd ) )
            pszTokenEnd++;

        if(*pszTokenEnd)
            *pszTokenEnd++ = _T('\0');

        if( StrCmpIC(pszTokenBegin, _T("ideograph-numeric")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_NUMERIC;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-space")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_SPACE;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-alpha")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_ALPHA;
        }
        else if( StrCmpIC(pszTokenBegin, _T("ideograph-parenthesis")) == 0 )
        {
            v.lVal |= TEXTAUTOSPACE_PARENTHESIS;
        }
        else if( StrCmpIC(pszTokenBegin, _T("none")) == 0 )
        {
            v.lVal = TEXTAUTOSPACE_NONE;
        }
        else
        {
            fInvalidValues = TRUE;
            if (dwOpCode & HANDLEPROP_STRICTCSS1)
                // In strict CSS1 mode we skip the whole property value.
                goto Cleanup;
        }
    }

    hr = CAttrArray::Set( ppAA, DISPID_A_TEXTAUTOSPACE, &v,
                    (PROPERTYDESC *)&s_propdescCStyletextAutospace, CAttrValue::AA_StyleAttribute, wFlags );

Cleanup:
    delete[] pszCopy;
    RRETURN1( fInvalidValues ? (hr?hr:E_INVALIDARG) : hr, E_INVALIDARG );
}


//+------------------------------------------------------------------------
//
//  Function:   ::ParseListStyleProperty
//
//  Synopsis:   Parses a list-style string in CSS format and sets the
//              appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseListStyleProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszListStyle )
{
    TCHAR *pszString;
    TCHAR *pszCopy;
    TCHAR *pszNextToken;
    HRESULT hrResult = S_OK;
    BOOL fInsideParens;
    BOOL fNone;
    BOOL fTypeDone = FALSE;
    TCHAR achNone[] = _T("none");
    TCHAR *pchNone;
    TCHAR chCurr;
    TCHAR chNone;

    PROPERTYDESC *ppdType  = (PROPERTYDESC*)&s_propdescCStylelistStyleType.a;
    PROPERTYDESC *ppdPos   = (PROPERTYDESC*)&s_propdescCStylelistStylePosition.a; 
    PROPERTYDESC *ppdImage = (PROPERTYDESC*)&s_propdescCStylelistStyleImage.a; 

    CAttrValue avType, avPos, avImage;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.

        BackupAttrValue (*ppAA, ppdPos, &avPos);
        BackupAttrValue (*ppAA, ppdType, &avType);
        BackupAttrValue (*ppAA, ppdImage, &avImage);
    }

    if ( !pcszListStyle || !*pcszListStyle )
    {
        if ( *ppAA )
        {
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLETYPE, CAttrValue::AA_StyleAttribute );
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLEPOSITION, CAttrValue::AA_StyleAttribute );
            (*ppAA)->FindSimpleAndDelete( DISPID_A_LISTSTYLEIMAGE, CAttrValue::AA_StyleAttribute );
        }
        return S_OK;
    }

    pszCopy = pszNextToken = pszString = new(Mt(ParseListStyleProperty_pszCopy)) TCHAR [_tcslen(  pcszListStyle ) + 1 ];
    if ( !pszCopy )
    {
        hrResult = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy( pszCopy,  pcszListStyle );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fNone = TRUE;
        fInsideParens = FALSE;
        pchNone = achNone;
        while ( _istspace( *pszString ) )
            pszString++;

        pszNextToken = pszString;
        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;

            if (fNone && !fInsideParens)
            {
                chCurr = *pszNextToken++ ;
                chNone = *pchNone++;
                if ((chCurr != chNone) && (chCurr != (chNone - _T('a') + _T('A'))))
                    fNone = FALSE;
            }
            else
            {
                fNone = FALSE;
                pszNextToken++;
            }
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        // Try type
        if ((fNone && fTypeDone) || ppdType->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
        {   // Failed: try position
            if ( ppdPos->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
            {   // Failed: try image
                if ( ppdImage->TryLoadFromString ( dwOpCode, pszString, pObject, ppAA ) )
                {
                    hrResult = E_INVALIDARG;
                    if (fIsStrictCSS1)
                        goto Cleanup;
                }
            }
        }
        else
            fTypeDone = TRUE;
    }

Cleanup:
    
    if (hrResult == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPos, &avPos);
                RestoreAttrArray(*ppAA, ppdType, &avType);
                RestoreAttrArray(*ppAA, ppdImage, &avImage);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avPos.Free();
        avType.Free();
        avImage.Free();
    }


    delete[] pszCopy;
    RRETURN1( hrResult, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteFontToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the font properties in CSS format.
//              We will only build a non-empty string and return it if
//              there are the minimum set of font properties (if the font
//              string is valid according to the CSS spec, which requires
//              at least a size and a font-family).
//
//-------------------------------------------------------------------------
HRESULT WriteFontToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrFont;
    BSTR bstr = NULL;
    BOOL fIsValid = TRUE;
    VARIANT v;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( S_OK == s_propdescCStylefontWeight.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontStyle.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontVariant.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("normal") ) )
        {
            hr = cstrFont.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylefontSize.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  ) && ( v.vt == VT_BSTR && (LPTSTR)v.byref && *(LPTSTR)v.byref ) )
    {
        hr = cstrFont.Append( (LPTSTR)v.byref );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    VariantClear(&v);

    if ( S_OK == s_propdescCStylelineHeight.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA ) && ( v.vt == VT_BSTR && (LPTSTR)v.byref && *(LPTSTR)v.byref ) )
    {
        if ( _tcsicmp( (LPTSTR)v.byref, _T("normal") ) )
        {
            hr = cstrFont.Append( _T("/") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrFont.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }
    hr = cstrFont.Append( _T(" ") );
    if (hr != S_OK)
        goto Cleanup;

    bstr = NULL;
    if ( S_OK == s_propdescCStylefontFamily.b.GetStringProperty(&bstr, NULL, (CVoid *)&pAA ) &&
         bstr && *bstr )
    {
        hr = cstrFont.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
        fIsValid = FALSE;

Cleanup:
    FormsFreeString(bstr);
    VariantClear(&v);
    if (hr == S_OK)
    {
        if ( !fIsValid )
        {
            hr = cstrFont.Set( _T("") );
            if (hr != S_OK)
                return hr;
        }
        return cstrFont.AllocBSTR( pbstr );
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteLayoutGridToBSTR
//
//  Synopsis:
//
//-------------------------------------------------------------------------
HRESULT WriteLayoutGridToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrLayoutGrid;
    BSTR bstrMode = NULL;
    BSTR bstrType = NULL;
    BOOL fIsValid = TRUE;
    CVariant v1, v2;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );

    if ( S_OK == s_propdescCStylelayoutGridMode.b.GetEnumStringProperty( &bstrMode, NULL, (CVoid *)&pAA ) && bstrMode && *bstrMode )
    {
        if ( _tcsicmp( bstrMode, _T("both") ) )
        {
            hr = cstrLayoutGrid.Append( (TCHAR *)bstrMode );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridType.b.GetEnumStringProperty( &bstrType, NULL, (CVoid *)&pAA ) && bstrType && *bstrType )
    {
        if ( _tcsicmp( bstrType, _T("loose") ) )
        {
            hr = cstrLayoutGrid.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrLayoutGrid.Append( (TCHAR *)bstrType );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridLine.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v1, NULL, (CVoid *)&pAA  ) && ( v1.vt == VT_BSTR && v1.bstrVal && *v1.bstrVal ) )
    {
        hr = cstrLayoutGrid.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrLayoutGrid.Append( (TCHAR *)v1.bstrVal );
        if (hr != S_OK)
            goto Cleanup;
        fIsValid = TRUE;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

    if ( S_OK == s_propdescCStylelayoutGridChar.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v2, NULL, (CVoid *)&pAA ) && ( v2.vt == VT_BSTR && v2.bstrVal && *v2.bstrVal ) )
    {
        hr = cstrLayoutGrid.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrLayoutGrid.Append( (TCHAR *)v2.bstrVal );
        if (hr != S_OK)
            goto Cleanup;
    }
    else
    {
        fIsValid = FALSE;
        goto Cleanup;
    }

Cleanup:
    FormsFreeString(bstrMode);
    FormsFreeString(bstrType);

    if (hr == S_OK)
    {
        if (!fIsValid)
        {
            hr = cstrLayoutGrid.Set(_T(""));
            if (hr != S_OK)
                return hr;
        }
        else if (!cstrLayoutGrid.Length())  // Set all defaults
        {
            hr = cstrLayoutGrid.Set(_T("both loose none none"));
            if (hr != S_OK)
                return hr;
        }
        
        return cstrLayoutGrid.AllocBSTR(pbstr);
    }
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   ::WriteTextDecorationToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the text-decoration properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteTextDecorationToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrTextDecoration;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    if ( !pAA )
        return S_FALSE;

    pAV = pAA->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
    if ( pAV )
    {   // We've got one!
        if ( hr == S_OK && pAV->GetLong() & TD_NONE )
            hr = cstrTextDecoration.Append( _T("none ") );
        if ( hr == S_OK && pAV->GetLong() & TD_UNDERLINE )
            hr = cstrTextDecoration.Append( _T("underline ") );
        if ( hr == S_OK && pAV->GetLong() & TD_OVERLINE )
            hr = cstrTextDecoration.Append( _T("overline ") );
        if ( hr == S_OK && pAV->GetLong() & TD_LINETHROUGH )
            hr = cstrTextDecoration.Append( _T("line-through ") );
        if ( hr == S_OK && pAV->GetLong() & TD_BLINK )
            hr = cstrTextDecoration.Append( _T("blink ") );
        cstrTextDecoration.TrimTrailingWhitespace();
    }

    if (hr != S_OK)
        RRETURN(hr);
    RRETURN( cstrTextDecoration.AllocBSTR( pbstr ) );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteTextAutospaceToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the text-autospace properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteTextAutospaceToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrTextAutospace;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    if ( !pAA )
        return S_FALSE;

    pAV = pAA->Find( DISPID_A_TEXTAUTOSPACE, CAttrValue::AA_Attribute );
    if ( pAV )
    {
        hr = WriteTextAutospaceFromLongToBSTR( pAV->GetLong(), pbstr, FALSE );
    }
    else
    {
        hr = cstrTextAutospace.Set( _T("") );
        if (hr == S_OK)
            hr = cstrTextAutospace.AllocBSTR( pbstr );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------
//
//  static function : WriteTextAutospaceFromLongToBSTR
//
//  Synopsis : given the current textAutospace property, this
//             will write it out to a string
//
//+----------------------------------------------------------------

HRESULT
WriteTextAutospaceFromLongToBSTR(LONG lTextAutospace, BSTR * pbstr, BOOL fWriteNone)
{
    CStr cstrTA;
    HRESULT hr=S_OK;

    if(!lTextAutospace)
    {
        if(fWriteNone)
            hr = cstrTA.Set(_T("none"));
        else
            hr = cstrTA.Set(_T(""));
    }
    else
    {
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_ALPHA)
        {
            hr = cstrTA.Append(_T("ideograph-alpha "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_NUMERIC)
        {
            hr = cstrTA.Append(_T("ideograph-numeric "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_SPACE)
        {
            hr = cstrTA.Append(_T("ideograph-space "));
        }
        if(hr == S_OK && lTextAutospace & TEXTAUTOSPACE_PARENTHESIS)
        {
            hr = cstrTA.Append(_T("ideograph-parenthesis"));
        }
        if (hr == S_OK)
            cstrTA.TrimTrailingWhitespace();
    }

    if (hr == S_OK)
        hr = cstrTA.AllocBSTR(pbstr);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBorderToBSTR
//
//  Synopsis:   Cooks up a BSTR of the border properties in CSS format.
//
//-------------------------------------------------------------------------

// NOTE: This function could be more efficient by doing all the Find()s itself
// and collapsing the values directly. - CWilso
HRESULT WriteBorderToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBorder;
    BSTR bstrTemp = NULL;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );
    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERCOLOR, pAA, &bstrTemp );
    if ( ( hr == S_OK ) && bstrTemp )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            hr = cstrBorder.Append( (TCHAR *)bstrTemp );
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }
    if ( hr != S_OK )
        goto Cleanup;

    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERWIDTH, pAA, &bstrTemp );
    if ( hr == S_OK )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            if ( StrCmpC( (TCHAR *)bstrTemp, _T("medium") ) )
            {
                if ( cstrBorder.Length() )
                {
                    hr = cstrBorder.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBorder.Append( (TCHAR *)bstrTemp );
            }
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }
    if ( hr != S_OK )
        goto Cleanup;

    hr = WriteExpandedPropertyToBSTR( DISPID_A_BORDERSTYLE, pAA, &bstrTemp );
    if ( hr == S_OK )
    {
        if ( !_tcschr( bstrTemp, _T(' ') ) )
        {
            if ( StrCmpC( (TCHAR *)bstrTemp, _T("none") ) )
            {
                if ( cstrBorder.Length() )
                {
                    hr = cstrBorder.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBorder.Append( (TCHAR *)bstrTemp );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }
        else
            hr = S_FALSE;
        FormsFreeString( bstrTemp );
        bstrTemp = NULL;
    }

Cleanup:
    FormsFreeString( bstrTemp );
    if ( hr == S_FALSE )
        hr = cstrBorder.Set( _T("") );
    if (hr == S_OK)
        return cstrBorder.AllocBSTR( pbstr );
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteExpandedPropertyToBSTR
//
//  Synopsis:   Cooks up a BSTR of an aggregate expanded property (e.g.
//              margin, padding, etc.) if the aggregate can be built.  Will
//              accomplish minization (e.g. "10px 10px 10px 10px" will be
//              written as "10px").
//
//-------------------------------------------------------------------------
HRESULT WriteExpandedPropertyToBSTR( DWORD dwDispId, CAttrArray *pAA, BSTR *pbstr )
{
    PROPERTYDESC *ppdTop;
    PROPERTYDESC *ppdRight;
    PROPERTYDESC *ppdBottom;
    PROPERTYDESC *ppdLeft;
    LPTSTR pszTop = NULL;
    LPTSTR pszRight = NULL;
    LPTSTR pszBottom = NULL;
    LPTSTR pszLeft = NULL;
    VARIANT v;
    CStr cstrRetVal;
    BOOL fWriteRightLeft = FALSE;
    BOOL fWriteBottom    = FALSE;
    BOOL fWriteLeft      = FALSE;
    BOOL fTopInAA, fRightInAA, fBottomInAA, fLeftInAA;
    HRESULT hr = S_OK;

    Assert( pbstr != NULL );
    Assert( pAA && "Must have AttrArray!");
    if ( !pAA )
        goto Error;

    if ( THR( GetExpandingPropdescs( dwDispId, &ppdTop, &ppdRight, &ppdBottom, &ppdLeft ) ) )
        goto Error;

    fTopInAA =    NULL != pAA->Find( ppdTop->GetDispid() );
    fRightInAA =  NULL != pAA->Find( ppdRight->GetDispid() );
    fBottomInAA = NULL != pAA->Find( ppdBottom->GetDispid() );
    fLeftInAA =   NULL != pAA->Find( ppdLeft->GetDispid() );

    if ( !fTopInAA || !fRightInAA || !fBottomInAA || !fLeftInAA )
    {
        if ( ( dwDispId == DISPID_A_BORDERCOLOR ) &&
             !fTopInAA && !fRightInAA && !fBottomInAA && !fLeftInAA )
            goto Cleanup;
        else
            goto Error; // Need all four sides to cook up expanded property.
    }

#ifdef WIN16
    if ( (ppdTop->pfnHandleProperty)( ppdTop, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdTop, ppdTop->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszTop = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdRight->pfnHandleProperty)( ppdRight, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdRight, ppdRight->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszRight = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdBottom->pfnHandleProperty)( ppdBottom, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdBottom, ppdBottom->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszBottom = (LPTSTR)v.byref;

#ifdef WIN16
    if ( (ppdLeft->pfnHandleProperty)( ppdLeft, HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) )
#else
    if ( CALL_METHOD( ppdLeft, ppdLeft->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *) &pAA ) ))
#endif
        goto Error;
    pszLeft = (LPTSTR)v.byref;

    if ( !pszTop || !pszRight || !pszBottom || !pszLeft )
        goto Error;

    hr = cstrRetVal.Append( pszTop );    // We always have the top string
    if (hr != S_OK)
        goto Cleanup;
    if ( _tcsicmp( pszRight, pszLeft ) )
    {   // Right and left don't match - write out everything.
        fWriteRightLeft = TRUE;
        fWriteBottom = TRUE;
        fWriteLeft = TRUE;
    }
    else
    {
        if ( _tcsicmp( pszTop, pszBottom ) )
        {
            fWriteBottom = TRUE;     // Top and bottom don't match
            fWriteRightLeft = TRUE;
        }
        else if ( _tcsicmp( pszTop, pszRight ) )
            fWriteRightLeft = TRUE;
    }

    if ( fWriteRightLeft )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszRight );    // Write out the right string (may be left also)
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( fWriteBottom )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszBottom );    // Write out the bottom string
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( fWriteLeft )
    {
        hr = cstrRetVal.Append( _T(" ") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrRetVal.Append( pszLeft );    // Write out the left string
        if (hr != S_OK)
            goto Cleanup;
    }

Cleanup:
    if (pszLeft)
        FormsFreeString(pszLeft);
    if (pszRight)
        FormsFreeString(pszRight);
    if (pszTop)
        FormsFreeString(pszTop);
    if (pszBottom)
        FormsFreeString(pszBottom);

    if (hr == S_OK)
        hr = THR(cstrRetVal.AllocBSTR( pbstr ));

    RRETURN1(hr, S_FALSE);

Error:
    hr = S_FALSE;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteListStyleToBSTR
//
//  Synopsis:   Cooks up a BSTR of the list item properties in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteListStyleToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    HRESULT hr = S_FALSE;
    CStr cstrListStyle;
    BSTR bstr = NULL;

    Assert( pbstr != NULL );
    s_propdescCStylelistStyleType.b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( bstr && *bstr )
    {
        hr = cstrListStyle.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }

    FormsFreeString(bstr);
    bstr = NULL;

    if ( S_OK == s_propdescCStylelistStyleImage.b.GetStyleComponentProperty(&bstr, NULL, (CVoid *)&pAA ) )
    {
        if ( bstr && *bstr )
        {
            if ( hr == S_OK )
            {
                hr = cstrListStyle.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrListStyle.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }

    FormsFreeString(bstr);
    bstr = NULL;

    s_propdescCStylelistStylePosition.b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( bstr && *bstr )
    {
        if ( hr == S_OK )
        {
            hr = cstrListStyle.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
        }
        hr = cstrListStyle.Append( (TCHAR *)bstr );
        if (hr != S_OK)
            goto Cleanup;
    }
    if ( hr == S_OK )
        hr = cstrListStyle.AllocBSTR( pbstr );

    FormsFreeString(bstr);

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBorderSidePropertyToBSTR
//
//  Synopsis:   Cooks up a BSTR of all the border properties applied to a
//              particular side in CSS format.
//
//-------------------------------------------------------------------------
HRESULT WriteBorderSidePropertyToBSTR( DWORD dispid, CAttrArray *pAA, BSTR *pbstr )
{
    PROPERTYDESC *ppdStyle;
    PROPERTYDESC *ppdColor;
    PROPERTYDESC *ppdWidth;
    CStr cstrBorder;
    BSTR bstr = NULL;
    HRESULT hr = S_OK;
    VARIANT v;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( S_FALSE == GetBorderSidePropdescs( dispid, &ppdStyle, &ppdColor, &ppdWidth ) )
        return S_FALSE;

    hr = ((PROPERTYDESC_BASIC *)ppdColor)->b.GetColor( (CVoid *)&pAA, &cstrBorder );
    if ( hr != S_OK )
        goto Cleanup;

    hr = ppdWidth->HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  );
    if ( ( hr == S_OK ) && ( v.vt == VT_BSTR ) && v.byref )
    {
        if ( _tcsicmp( (LPTSTR)v.byref, _T("medium") ) )
        {
            if ( cstrBorder.Length() )
            {
                hr = cstrBorder.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBorder.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBorder.Set( _T("") );
        goto Cleanup;
    }

    hr = ((PROPERTYDESC_NUMPROP *)ppdStyle)->b.GetEnumStringProperty(&bstr, NULL, (CVoid *)&pAA );
    if ( hr != S_OK )
        goto Cleanup;
    if ( bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("none") ) )
        {
            if ( cstrBorder.Length() )
            {
                hr = cstrBorder.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBorder.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBorder.Set( _T("") );
        goto Cleanup;
    }


    if ( !cstrBorder.Length() )    // All defaults
        hr = cstrBorder.Set( _T("medium none") );
    if(hr != S_OK)
        goto Cleanup;

Cleanup:
    VariantClear(&v);
    FormsFreeString(bstr);
    if ( hr == S_OK )
        hr = cstrBorder.AllocBSTR( pbstr );
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseBackgroundPositionProperty
//
//  Synopsis:   Parses a background-position string in CSS format and sets
//              the appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseBackgroundPositionProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBackgroundPosition )
{
    TCHAR *pszString;
    TCHAR *pszCopy;
    TCHAR *pszNextToken;
    BOOL fInsideParens;
    BOOL fXIsSet = FALSE;
    BOOL fYIsSet = FALSE;
    PROPERTYDESC *pPropertyDesc;
    TCHAR *pszLastXToken = NULL;
    HRESULT hr = S_OK;
    

    PROPERTYDESC *ppdPosX = (PROPERTYDESC*)&s_propdescCStylebackgroundPositionX.a;
    PROPERTYDESC *ppdPosY = (PROPERTYDESC*)&s_propdescCStylebackgroundPositionY.a;

    CAttrValue avPosX, avPosY;

    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that is
    // valid. Because the parser was written for the latter case there is no easy way to find out in advance that there is a wrong token inside
    // the property definition. Therefore we make a backup of our properties and restore it if we find an invalid token.
    BOOL          fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1; // extract mode (strict css1 or compatible)
    BOOL          fEmptyAttrArray = (*ppAA == NULL);

    if (!fEmptyAttrArray && fIsStrictCSS1) 
    {
        // In strict css1 mode in an error situation we have to revert to our initial attribute values. So
        // let's do a backup of the attributes which may be changed.
        BackupAttrValue (*ppAA, ppdPosX, &avPosX);
        BackupAttrValue (*ppAA, ppdPosY, &avPosY);
    }


    if( !pcszBackgroundPosition || !(*pcszBackgroundPosition))
    {
        // Empty value must set the properties to 0%
        ppdPosX->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        ppdPosY->TryLoadFromString ( dwOpCode, _T("0%"), pObject, ppAA );
        return S_OK;
    }


    pszCopy = pszNextToken = pszString = new(Mt(ParseBackgroundPositionProperty_pszCopy)) TCHAR [_tcslen( pcszBackgroundPosition ) + 1 ];
    if ( !pszCopy )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy( pszCopy, pcszBackgroundPosition );

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        fInsideParens = FALSE;
        while ( _istspace( *pszString ) )
            pszString++;

        // (gschneid) We need to eat white spaces first because otherwise we do not proceed, i.e. pszNextToken is
        // not advanced.
        while ( *pszNextToken && _istspace( *pszNextToken ))
            pszNextToken++;

        while ( *pszNextToken && ( fInsideParens || !_istspace( *pszNextToken ) ) )
        {
            if ( *pszNextToken == _T('(') )
                fInsideParens = TRUE;
            if ( *pszNextToken == _T(')') )
                fInsideParens = FALSE;
            pszNextToken++;
        }

        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');

        if ( fXIsSet && !fYIsSet )
            pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY;
        else    // If X and Y have both either been set or both not set or just Y set, then try X first.
            pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX;

        if ( pPropertyDesc->TryLoadFromString ( dwOpCode,pszString, pObject, ppAA ) )
        {   // Failed: try the other propdesc, it might be a enum in that direction
            if ( fXIsSet && !fYIsSet )
                pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX;
            else
                pPropertyDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY;

            if ( S_OK == pPropertyDesc->TryLoadFromString( dwOpCode,
                        pszString, pObject, ppAA ) )
            {
                if ( fXIsSet && !fYIsSet )
                {
                    fXIsSet = TRUE;
                    if ( S_OK == ppdPosY->TryLoadFromString( dwOpCode, pszLastXToken, pObject, ppAA ) )
                        fYIsSet = TRUE;
                }
                else
                    fYIsSet = TRUE;
            }
            else
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
        else
        {
            if ( fXIsSet && !fYIsSet )
                fYIsSet = TRUE;
            else
            {
                fXIsSet = TRUE;
                pszLastXToken = pszString;
            }
        }
        if ( fXIsSet && fYIsSet )
        {
            if (fIsStrictCSS1 && (*pszNextToken))
                hr = E_INVALIDARG;
            goto Cleanup;   // We're done - we've set both values.
        }
    }

    if ( !fXIsSet )
        ppdPosX->TryLoadFromString ( dwOpCode, _T("50%"), pObject, ppAA );

    if ( !fYIsSet )
        ppdPosY->TryLoadFromString ( dwOpCode, _T("50%"), pObject, ppAA );

Cleanup:
    if (hr == E_INVALIDARG && fIsStrictCSS1)
    { // Restore attr values in attr array because an error happened with resp. to strict css1 mode.
        if (*ppAA)
        { // Only do the restoring if there is an attr array.
            if (fEmptyAttrArray)
            { // The attribute array was NULL when we entered the function. So we just delete everything by calling Free.
                (*ppAA)->Free();
            } 
            else 
            { // Restore individual attribute values.
                // We need these indexes to figure out if there has been added any attributes?
                RestoreAttrArray(*ppAA, ppdPosX, &avPosX);
                RestoreAttrArray(*ppAA, ppdPosY, &avPosY);
            }
        }   
    }

    if (fIsStrictCSS1 && !fEmptyAttrArray)
    { // clean up the temporary attribute values
        avPosX.Free();
        avPosY.Free();
    }


    delete[] pszCopy;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBackgroundPositionToBSTR
//
//  Synopsis:   Cooks up a BSTR of the background position.
//
//-------------------------------------------------------------------------
HRESULT WriteBackgroundPositionToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBGPos;
    VARIANT v;
    HRESULT hr=S_OK;

    Assert( pbstr != NULL );
    VariantInit( &v );

    if ( pAA->Find( DISPID_A_BACKGROUNDPOSX, CAttrValue::AA_Attribute ) ||
        pAA->Find( DISPID_A_BACKGROUNDPOSY, CAttrValue::AA_Attribute ) )
    {
        if ( S_OK == s_propdescCStylebackgroundPositionX.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                            &v, NULL, (CVoid *)&pAA  ) )
        {
            hr = cstrBGPos.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
            VariantClear(&v);

            if ( S_OK == s_propdescCStylebackgroundPositionY.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *)&pAA ) )
            {
                hr = cstrBGPos.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrBGPos.Append( (LPTSTR)v.byref );
                if (hr != S_OK)
                    goto Cleanup;
                VariantClear(&v);
            }
        }
    }

Cleanup:
    VariantClear(&v);
    if (hr != S_OK)
        RRETURN(hr);
    RRETURN( cstrBGPos.AllocBSTR( pbstr ) );
}

//+------------------------------------------------------------------------
//
//  Function:   ::ParseClipProperty
//
//  Synopsis:   Parses a "clip" string in CSS format (from the positioning
//              specification) and sets the appropriate sub-properties.
//
//-------------------------------------------------------------------------
HRESULT ParseClipProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszClip )
{
    HRESULT hr = E_INVALIDARG;
    size_t nLen = pcszClip ? _tcslen(pcszClip) : 0;

    if ( !pcszClip )
        return S_OK;

    if ( ( nLen > 6 ) &&
         !_tcsnicmp(pcszClip, 4, _T("rect"), 4 )  &&
         ( pcszClip[nLen-1] == _T(')') ) )
    {
        // skip the "rect"
        LPCTSTR pcszProps = pcszClip + 4;

        // Terminate the string
        ((TCHAR *)pcszClip)[nLen-1] = 0;

        // skip any whitespace
        while(*pcszProps && *pcszProps == _T(' '))
            pcszProps++;

        // there better be a string, a '('
        if (*pcszProps != _T('('))
            goto Cleanup;

        // skip the '('
        pcszProps++;

        // (gschneid) Synopsis says that this is parsing the clip in css format. That's not exactly true.
        // Passing as last argument TRUE allows measure specs like "100 px". These are not allowed according
        // to CSS1 (should be "100px"; without space). I don't change anything here because this would break
        // the compatibility mode. In strict css1 mode it's taken care of this in ParseAndExpand property.
        hr = THR_NOTRACE(ParseExpandProperty( ppAA,
                                pObject,
                                dwOpCode,
                                pcszProps,
                                DISPID_A_CLIP,
                                TRUE ));

        // Restore the string
        ((TCHAR *)pcszClip)[nLen-1] = _T(')');
    }

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteClipToBSTR
//
//  Synopsis:   Cooks up a BSTR of the "clip" region property.
//
//-------------------------------------------------------------------------
HRESULT WriteClipToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrClip;
    VARIANT v;
    HRESULT hr;

    Assert( pbstr != NULL );
    VariantInit( &v );
    hr = s_propdescCStyleclipTop.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                        &v, NULL, (CVoid *)&pAA  );
    if ( hr == S_OK && v.byref )
    {
        hr = cstrClip.Append( _T("rect(") );
        if (hr != S_OK)
            goto Cleanup;
        hr = cstrClip.Append( (LPTSTR)v.byref );
        if (hr != S_OK)
            goto Cleanup;
        VariantClear(&v);
        hr = s_propdescCStyleclipRight.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                            &v, NULL, (CVoid *)&pAA  );
        if ( hr == S_OK && v.byref )
        {
            hr = cstrClip.Append( _T(" ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrClip.Append( (LPTSTR)v.byref );
            if (hr != S_OK)
                goto Cleanup;
            VariantClear(&v);
            hr = s_propdescCStyleclipBottom.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                &v, NULL, (CVoid *)&pAA  );
            if ( hr == S_OK && v.byref )
            {
                hr = cstrClip.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrClip.Append( (LPTSTR)v.byref );
                if (hr != S_OK)
                    goto Cleanup;
                VariantClear(&v);
                hr = s_propdescCStyleclipLeft.a.HandleUnitValueProperty(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                                    &v, NULL, (CVoid *)&pAA  );
                if ( hr == S_OK && v.byref )
                {
                    hr = cstrClip.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                    hr = cstrClip.Append( (LPTSTR)v.byref );
                    if (hr != S_OK)
                        goto Cleanup;
                    hr = cstrClip.Append( _T(")") );
                    if (hr != S_OK)
                        goto Cleanup;
                    VariantClear(&v);
                    RRETURN( cstrClip.AllocBSTR( pbstr ) );
                }
            }
        }
    }

    // Fancy way to pass a NULL pointer back?? -
    // We'll ONLY get here in the error case
Cleanup:
    VariantClear(&v);
    cstrClip.Free();
    if (hr != S_OK)
        RRETURN(hr);
    RRETURN(cstrClip.AllocBSTR( pbstr ) );
}


// All putters/getters must not have a pointer into the element attrArray is it could move.
// Use the below macros to guarantee we're pointing to a local variable which is pointing to the
// style sheet attrArray and not pointing to the attrValue on the element attrArray which can
// move if the elements attrArray has attrValues added to or deleted from.
#define GETATTR_ARRAY   \
    CAttrArray *pTempStyleAA;                       \
    CAttrArray **ppTempStyleAA = GetAttrArray();    \
    if (!ppTempStyleAA)                             \
        RRETURN(SetErrorInfo(E_OUTOFMEMORY));       \
    pTempStyleAA = *ppTempStyleAA;

#define USEATTR_ARRAY   \
    &pTempStyleAA
    

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 

STDMETHODIMP
CStyle::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_StyleComponentHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_UrlHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_StringHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_Long(long v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_LongHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}


STDMETHODIMP
CStyle::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_BoolHelper(v, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_Variant(VARIANT var)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

#if DBG == 1
    {
        HRESULT     hr2;
        CVariant    varStr;

        hr2 = THR_NOTRACE(VariantChangeTypeSpecial(&varStr, &var, VT_BSTR));

        TraceTag((
            tagStyleInlinePutVariant,
            "put_Variant, tag: %ls, id: %ls, sn: %ld    name: %ls  type: %ld, str: %ls",
            _pElem->TagName(), STRVAL(_pElem->GetAAid()),
            _pElem->SN(),
            STRVAL(pPropDesc->pstrExposedName),
            V_VT(&var),
            S_OK == hr2 ? STRVAL(V_BSTR(&varStr)) : _T("<unknown>")));
    }
#endif

    // Allow runtimestyle default property values to be set
    return put_VariantHelper(var, pPropDesc, USEATTR_ARRAY, (DISPID_INTERNAL_RUNTIMESTYLEAA == _dispIDAA));
}

STDMETHODIMP
CStyle::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    return put_DataEventHelper(v, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_Url(BSTR * pbstr)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_BSTR, pbstr);
    }

    return get_UrlHelper(pbstr, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_StyleComponent(BSTR * pbstr)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_BSTR, pbstr);
    }

    return get_StyleComponentHelper(pbstr, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CStyle::get_Property(void * pv)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY

    if (NeedToDelegateGet(pPropDesc->GetDispid()))
    {
        return DelegateGet(pPropDesc->GetDispid(), VT_VARIANT, pv);
    }

    return get_PropertyHelper(pv, pPropDesc, USEATTR_ARRAY);
}


#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltableom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltableom.cxx
//
//  Contents:   CTableLayout object model methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif


#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createTHead
//
//  Synopsis:   Table Layout OM method helper
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createTHead(IDispatch** ppHead)
{
    HRESULT               hr;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pHead)
    {
        hr = Doc()->CreateElement(ETAG_THEAD, &pElement);
        if (hr)
            goto Cleanup;

        Assert (pElement);

        hr = ensureTBody();
        if (hr)
            goto Cleanup;

        pAdjacentElement = _pFoot? _pFoot : _aryBodys[0];    // insert right before 1st body, or before the footer
        where = CElement::BeforeBegin;

        hr = insertElement(pAdjacentElement, pElement, where, TRUE);

        if (hr)
            goto Cleanup;
        
        Assert (pElement == _pHead);
    }
    
    if (ppHead)
    {
        hr = _pHead->QueryInterface(IID_IHTMLTableSection, (void **)ppHead);
    }

Cleanup:

    CElement::ReleasePtr(pElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteTHead
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteTHead()
{
    HRESULT hr = EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (_pHead)
    {
        hr = deleteElement(_pHead);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createTFoot
//
//  Synopsis:   Table Layout OM method helper
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createTFoot(IDispatch** ppFoot)
{
    HRESULT               hr;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pFoot)
    {
        hr = Doc()->CreateElement(ETAG_TFOOT, &pElement);
        if (hr)
            goto Cleanup;

        Assert (pElement);
        hr = ensureTBody();
        if (hr)
            goto Cleanup;

        pAdjacentElement = _aryBodys[0];    // insert right before the first body
        where = CElement::BeforeBegin;

        hr = insertElement(pAdjacentElement, pElement, where, TRUE);

        if (hr)
            goto Cleanup;
        
        Assert (pElement == _pFoot);
    }
    
    if (ppFoot)
    {
        hr = _pFoot->QueryInterface(IID_IHTMLTableSection, (void **)ppFoot);
    }

Cleanup:

    CElement::ReleasePtr(pElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::ensureTBody
//
//  Synopsis:   Table Layout OM method helper
//
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::ensureTBody()
{
    HRESULT               hr = S_OK;
    CElement  *           pAdjacentElement = NULL;
    CElement::Where       where;
    CElement  *           pElement = NULL;

    if (!_aryBodys.Size())
    {
        hr = Doc()->CreateElement(ETAG_TBODY, &pElement);
        if (!hr)
        {
            Assert (pElement);
            pAdjacentElement = Table();    // insert right before the end of table
            where = CElement::BeforeEnd;
            _fEnsureTBody = TRUE;
            hr = insertElement(pAdjacentElement, pElement, where, TRUE);
            _fEnsureTBody = FALSE;
        }
    }
    
    CElement::ReleasePtr(pElement);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteTFoot
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteTFoot()
{
    HRESULT hr = EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (_pFoot)
    {
        hr = deleteElement(_pFoot);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::createCaption
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::createCaption(IHTMLTableCaption** ppCaption)
{
    HRESULT         hr;
    CElement      * pNewElement = NULL;
    CTableCaption * pCaption;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = GetFirstCaption();
    if (!pCaption)
    {
        hr = Doc()->CreateElement(ETAG_CAPTION, &pNewElement);
        if (hr)
            goto Cleanup;

        Assert (pNewElement);

        // If there are no captions then insert right after the beginning of the table.
        hr = insertElement(ElementOwner(), pNewElement, CElement::AfterBegin, TRUE);

        if (hr)
            goto Cleanup;

        Assert (pNewElement == _aryCaptions[0]);

        pCaption = DYNCAST(CTableCaption, pNewElement);
    }
    
    if (ppCaption)
    {
        hr = pCaption->QueryInterface(IID_IHTMLTableCaption, (void **)ppCaption);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CTableLayout::deleteCaption
//
//  Synopsis:   Table Layout OM method helper
//
//----------------------------------------------------------------------------

HRESULT 
CTableLayout::deleteCaption()
{
    CTableCaption * pCaption;
    HRESULT         hr;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = GetFirstCaption();

    if (pCaption)
    {
        hr = deleteElement(pCaption);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     VisualRow2Index (helper function)
//
//  Synopsis:   converts visual row index to an index into an _aryRows.
//
//----------------------------------------------------------------------------

int
CTableLayout::VisualRow2Index(int iRow)
{
    int cRowsFoot = _pFoot? _pFoot->_cRows : 0;

    Assert(IsTableLayoutCacheCurrent());

    if (cRowsFoot)
    {
        int cRowsHead = _pHead? _pHead->_cRows : 0;
        if (iRow >= cRowsHead)
        {
            int cRowsTotal= GetRows();
            if (iRow >= cRowsTotal - cRowsFoot)
            {
                // it is a footer row
                iRow += _pFoot->_iRow - (cRowsTotal - cRowsFoot);
            }
            else
            {
                // it is a body row
                iRow += cRowsFoot;
            }
        }
        // else it is a header row
    }// else there is nothing to do

    return iRow;
}


HRESULT
CTableLayout::insertElement(CElement *pAdjacentElement, 
                            CElement *pInsertElement, 
                            CElement::Where where, 
                            BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr;
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc  );

    Assert (pAdjacentElement);
    Assert (pInsertElement);

    if( IsEditable() )
    {
        pu.Start( IDS_UNDONEWCTRL );
        hr = THR( pDoc->BeginSelectionUndo());
    }
    
    _fTableOM = fIncrementalUpdatePossible;
    hr = pAdjacentElement->InsertAdjacent(where, pInsertElement);
    _fTableOM = FALSE;
    if (!hr)
    {
        Fixup(fIncrementalUpdatePossible);

        // VID wants us to save out end tags to elements inserted via the TOM (IE5, 23789).
        pInsertElement->_fExplicitEndTag = TRUE;
    }

    if ( IsEditable() )
    {
        hr = THR( pDoc->EndSelectionUndo() );
        pu.Finish( hr );        
    }

     
    RRETURN (hr);
}


HRESULT
CTableLayout::deleteElement(CElement *pDeleteElement, 
                            BOOL fIncrementalUpdatePossible)
{
    HRESULT     hr;
    BOOL        fInBrowseMode = !IsEditable();
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc );
    
    Assert (pDeleteElement);

  
    if( !fInBrowseMode )
    {
        pu.Start( IDS_UNDODELETE );   
        hr = THR( pDoc->BeginSelectionUndo() );
    }

    _fTableOM = fIncrementalUpdatePossible;
    hr = pDeleteElement->RemoveOuter();
    _fTableOM = FALSE;
    if (!hr)
    {
        Fixup(fIncrementalUpdatePossible);
    }

    if( !fInBrowseMode )
    {
        hr = THR( pDoc->EndSelectionUndo() );
        pu.Finish( hr );        
    }        


    RRETURN (hr);
}


HRESULT
CTableLayout::moveElement( IMarkupServices * pMarkupServices,
                           IMarkupPointer  * pmpBegin,
                           IMarkupPointer  * pmpEnd,
                           IMarkupPointer  * pmpTarget )
{
    HRESULT     hr;
    CDoc* pDoc = Doc();
    CParentUndo pu( pDoc );

    Assert(pMarkupServices && pmpBegin && pmpEnd && pmpTarget);

    if( IsEditable() )
    {
        pu.Start( IDS_UNDONEWCTRL );
        hr = THR( pDoc->BeginSelectionUndo());
    }

    hr = THR(pMarkupServices->Move(pmpBegin, pmpEnd, pmpTarget));
    if (!hr)
    {
        Fixup();
    }

    if ( IsEditable() )
    {
        hr = THR( pDoc->EndSelectionUndo());
        pu.Finish( hr );        
    }
    
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\style\tokenz.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#define ISDIGIT(ch) (((unsigned)((ch) - _T('0'))) <= _T('9') - _T('0'))
#define ISHEXAL(ch) (((unsigned)((ch) & ~(_T('a') ^ _T('A'))) - _T('A')) <= _T('F')-_T('A'))
#define ISHEX(ch)   (ISDIGIT(ch) || ISHEXAL(ch))

#ifndef NO_UTF16
typedef DWORD XCHAR;
#else
typedef TCHAR XCHAR;
#endif

extern XCHAR EntityChFromHex(TCHAR *pch, ULONG cch);

Tokenizer::Tokenizer ()
{
	_pCharacterStream = 0;
	_cCharacterStream = 0;
    _currChar = '\0';

    _currToken = TT_Unknown;

    _currTokOffset = 0;
    _nextTokOffset = 0;
    _pStartOffset = 0;
    _pEndOffset = 0;

    _pStartTokenValueOffset = 0;
    _pEndTokenValueOffset = 0;

    _pEscStart = NULL;
    _pEscBuffer = &_tokenValue;
    _fEscSeq = FALSE;
    _fEatenComment = FALSE;
}

    
Tokenizer::TOKEN_TYPE
Tokenizer::NextToken(BOOL fNeedRightParen, BOOL fIgnoreStringToken, BOOL fIgnoreEsc)
{
    Tokenizer::TOKEN_TYPE tt = TT_Unknown;

    if (_currToken == TT_LParen && fNeedRightParen)
    {
        while (CDOToken() && NextChar())
            NextNonSpaceChar();

        TCHAR chPeek = PeekNextNonSpaceChar();
        if (chPeek == CHAR_SINGLE ||
            chPeek == CHAR_DOUBLE)
        {
            TCHAR chStrDelim = chPeek;

            NextChar();

            // Don't include the beginning quote in string value.
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

            FetchString(chStrDelim, fIgnoreEsc);

            // Point at RParen.
            NextChar();             // Skip pass the end quote
        }
        else
        {
            // Don't include the beginning LParen in the value.
            _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

            // Pull out the url that inside of ( ) that isn't a quoted string.
            // e.g., url(file.css)
            FetchString(CHAR_RIGHT_PAREN, fIgnoreEsc);
            if (CurrentChar() == CHAR_RIGHT_PAREN)
                tt = TT_RParen;
        }

        if (tt != TT_RParen)
        {
            do
            {
                NextNonSpaceChar();
            }
            while (CDOToken() && NextChar());

            if (CurrentChar() == CHAR_RIGHT_PAREN)
                tt = TT_RParen;
        }
    }
    else if (CurrentChar())
    {
        _pStartOffset = _pCharacterStream + _nextTokOffset - 1;
        
        if (CurrentChar() == CHAR_ESCAPE && PeekNextChar(0) == CHAR_COLON)
        {
            NextChar();
            tt = TT_EscColon;
        }
        // Identifier?
        else if (_istalnum(CurrentChar()) ||
                 (CurrentChar() >= CSS_UNICODE_MIN && CurrentChar() <= CSS_UNICODE_MAX) ||
                 CurrentChar() == CHAR_ESCAPE)
        {
            // Fetch the rest of the identifier.
            tt = FetchIdentifier();
            while (CDOToken())
            {
                NextChar();
                Assert(IsIdentifier(tt));
            }

            goto Done;
        }
/*
        else if ((CurrentChar() >= '0' && CurrentChar() <= '9'))
        {
            tt = FetchNumber();
            goto Done;
        }
*/
        else
        {
            switch (CurrentChar())
            {
            case CHAR_HASH : 
                tt = TT_Hash;
                break;

            case CHAR_AT : 
                tt = TT_At;
                break;

            case CHAR_SINGLE : 
            case CHAR_DOUBLE : 
                {
                    if (fIgnoreStringToken)
                    {
                        tt = TT_Unknown;
                        break;
                    }

                    TCHAR chStrDelim = CurrentChar();

                    NextChar();

                    // Don't include the beginning quote in string value.
                    _pStartOffset = _pCharacterStream + _nextTokOffset - 1;

                    FetchString(chStrDelim);
                    tt = TT_String;
                    break;
                }

            case CHAR_EQUAL : 
                tt = TT_Equal;
                break;
            
            case CHAR_COLON : 
                tt = TT_Colon;
                break;

            case CHAR_LEFT_CURLY : 
                tt = TT_LCurly;
                break;

            case CHAR_RIGHT_CURLY : 
                tt = TT_RCurly;
                break;

            case CHAR_SEMI : 
                tt = TT_Semi;
                break;

            case CHAR_DOT : 
                tt = TT_Dot;
                break;

            case CHAR_COMMA : 
                tt = TT_Comma;
                break;

            case CHAR_ASTERISK : 
                tt = TT_Asterisk;
                while (PeekNextChar(0) == CHAR_FORWARDSLASH && PeekNextChar(1) == CHAR_ASTERISK)
                {
                    NextChar();
                    Verify(CDOToken());
                    Assert(tt == TT_Asterisk);
                }
                break;

            case CHAR_LEFT_PAREN : 
                tt = TT_LParen;
                break;

            case CHAR_RIGHT_PAREN : 
                tt = TT_RParen;
                break;

            case CHAR_BANG : 
                tt = TT_Bang;
                break;

            case CHAR_LBRACKET : 
            case CHAR_HYPHEN : 
                // <!--  or -->
                tt = GetIE5CompatToken();
                break;

            default: 
                // /* ?
                if (CDOToken())
                {
                    // find and return comment token.
                    tt = TT_Comment;
                }
                else
                    tt = TT_Unknown;

                break;
            }
        }
    }
    else    // Done parsing EOF hit.
    {
        tt = TT_EOF;
    }

    _currTokOffset = _nextTokOffset;

    NextChar();

Done:
    if (tt != TT_Hash && tt != TT_At)
    {
        if (tt != TT_Colon && tt != TT_Dot)
            NextNonSpaceChar();
        else
        {
            Assert(tt == TT_Dot || tt == TT_Colon);
            while (CDOToken())
            {
                NextChar();
                Assert(tt == TT_Dot || tt == TT_Colon);
            }
        }
    }

    _currToken = tt;

    return tt;
}

Tokenizer::TOKEN_TYPE

Tokenizer::FetchIdentifier()
{
    BOOL   fEscSeq = FALSE;
    BOOL  *pfEscSeq = _pEscStart ? &_fEscSeq : &fEscSeq;
    // Flag is true iff the identifier we are going to fetch is a standard compliant identifier.
    // See definition of CSSIdentifier[First]?Char to see what is a standard compliant character.
    BOOL   fCSSCompliant = TRUE;
    BOOL   fFirstCharacter = TRUE;
    BOOL   fIsCSSIdentifierChar = CSSIdentifierChar(CurrentChar()); // Performance tuning. By doing this we avoid call
                                                                    // CSSIdentifierChar twice in the following while loop.
 
    while (fIsCSSIdentifierChar ||  // Performance tuning. See end of while loop.
           NonCSSIdentifierChar(CurrentChar()) ||
           CurrentChar() == CHAR_ESCAPE)
    {
        if (CurrentChar() == CHAR_ESCAPE)
        {
            if (!_pEscStart && (PeekNextChar(0) == CHAR_COLON))
                break;

            if (!*pfEscSeq)
            {
                *pfEscSeq = TRUE;
                Assert(_pEscBuffer && (_pEscStart || _pEscBuffer == &_tokenValue));
                if (_pEscStart && !_fEatenComment)
                    _pEscBuffer->Clear();
                else
                    _pEscBuffer->Set(_pStartOffset, (_pCharacterStream + _nextTokOffset - 1) - _pStartOffset);
            }

            ProcessEscSequence();
            fFirstCharacter = FALSE;
        }
        else
        {
            if (*pfEscSeq && !_pEscStart)
                _pEscBuffer->Append(CurrentChar());

            if (fFirstCharacter)
            {
                fCSSCompliant = fCSSCompliant && CSSIdentifierFirstChar(CurrentChar());
                fFirstCharacter = FALSE;
            }
            else
            {
                fCSSCompliant = fCSSCompliant && fIsCSSIdentifierChar;   
            }
        }

        NextChar();
        fIsCSSIdentifierChar = CSSIdentifierChar(CurrentChar());
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    if (!_pEscStart)
    {
        Assert(_pEscBuffer == &_tokenValue);
        _pStartTokenValueOffset = (*pfEscSeq) ? (LPTSTR)_tokenValue : _pStartOffset;
        _pEndTokenValueOffset = (*pfEscSeq) ? _pStartTokenValueOffset + _pEscBuffer->Length() : _pEndOffset;
    }

    return fCSSCompliant ? TT_CSSIdentifier : TT_Identifier;
}


Tokenizer::TOKEN_TYPE
Tokenizer::FetchNumber()
{
    // digit = 0..9
    // number = digit* | [digit + '.' [+ digit*]]

    while (CurrentChar() >= '0' && CurrentChar() <= '9') 
    {
        NextChar();
    }

    if (CurrentChar() == CHAR_DOT)
    {
        NextChar();
        if (CurrentChar() >= '0' && CurrentChar() <= '9')
        {
            while (CurrentChar() >= '0' && CurrentChar() <= '9')
                NextChar();
        }
        else
        {
            return TT_Unknown;
        }
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;
/*
NOTE: Need to support 36pt above 2 lines does that.
    if (isspace(CurrentChar()))
    {
        _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

        return TT_Number;
    }
    else
    {
        return TT_Unknown;
    }
*/
    _pStartTokenValueOffset = _pStartOffset;
    _pEndTokenValueOffset = _pEndOffset;

    return TT_Number;
}


// Looking for /* and 
BOOL
Tokenizer::CDOToken()
{
    if (CurrentChar() == CHAR_FORWARDSLASH &&
        PeekNextChar(0) == CHAR_ASTERISK)
    {
        if (_pEscStart)
        {
            if (!_fEscSeq && !_fEatenComment)
                _pEscBuffer->Set(_pEscStart, (_pCharacterStream + _nextTokOffset) - _pEscStart - 1);
            else
                _pEscBuffer->Append(_pEscStart, (_pCharacterStream + _nextTokOffset) - _pEscStart - 1);

            _fEatenComment = TRUE;
        }
        // skip the /*
        NextChar();
        NextChar();

        while (CurrentChar() &&
               (CurrentChar() != CHAR_ASTERISK ||
                PeekNextChar(0) != CHAR_FORWARDSLASH))
        {
            NextChar();
        }

        // skip the */
        if (CurrentChar())
        {
            // Only advance one char here as there will be one more in NextToken(), after this.
            NextChar();
        }

        _pEndOffset = _pCharacterStream + _nextTokOffset;

        if (_pEscStart)
            _pEscStart = _pEndOffset;

        return TRUE;
    }

    return FALSE;
}

void Tokenizer::StopSequence(LPTSTR *ppchSequence)
{
    Assert(_pEscStart);

    _pEndTokenValueOffset = _pCharacterStream + _currTokOffset - 1;

    if (_pEscBuffer != &_tokenValue)
    {
        if (!_fEscSeq && !_fEatenComment)
        {
            // fill in the buffer, if passed in to startSequence(), & if not esc sequence
            _pEscBuffer->Set(GetStartToken(), GetTokenLength());
        }
        else if (_pEndTokenValueOffset > _pEscStart)
        {
            // fill in the rest of the escape sequence
            _pEscBuffer->Append(_pEscStart, _pEndTokenValueOffset - _pEscStart);
        }

        _pEscBuffer = &_tokenValue;
        Assert(!ppchSequence);
    }
    else if (_fEscSeq || _fEatenComment)
    {
        // fill in the rest of the escape sequence
        _tokenValue.Append(_pEscStart, _pEndTokenValueOffset - _pEscStart);
        _pStartTokenValueOffset = (LPTSTR)_tokenValue;
        _pEndTokenValueOffset = _pStartTokenValueOffset + _pEscBuffer->Length();
        if (ppchSequence)
        {
            _tokenValue.TrimTrailingWhitespace();
            *ppchSequence = _pStartTokenValueOffset;
        }
    }
    else if (ppchSequence)
    {
        _tokenValue.Set(GetStartToken(), GetTokenLength());
        _tokenValue.TrimTrailingWhitespace();
        *ppchSequence = (LPTSTR)_tokenValue;
    }

    _pEscStart = NULL;
    if (_fEscSeq)
        _fEscSeq = FALSE;
    if (_fEatenComment)
        _fEatenComment = FALSE;
}

void Tokenizer::ProcessEscSequence()
{
    TCHAR *pchWord = _pCharacterStream + _nextTokOffset;
    TCHAR *pchCurr = pchWord;
    XCHAR chEnt;
    _currChar = *pchCurr;

    while (_currChar && (pchCurr - pchWord < 6) && ISHEX(_currChar))
        _currChar = *(++pchCurr);

    chEnt = (pchCurr == pchWord) ? (isspace(_currChar) ? 0 : _currChar)
                                 : EntityChFromHex(pchWord, pchCurr - pchWord);
    
    if (chEnt)
    {
        if (_pEscStart)
        {
            _pEscBuffer->Append(_pEscStart, pchWord - _pEscStart - 1);
            _pEscStart = pchCurr + ((pchCurr == pchWord) ? 1 : 0);
        }

        if (chEnt < 0x10000)
        {
            _pEscBuffer->Append(chEnt);
        }
        else
        {
            _pEscBuffer->Append(HighSurrogateCharFromUcs4(chEnt));
            _pEscBuffer->Append(LowSurrogateCharFromUcs4(chEnt));
        }
    }

    if (pchCurr == pchWord)
        _nextTokOffset++;
    else if (!isspace(_currChar))
    {
        _nextTokOffset += (ULONG)(pchCurr - pchWord);
        _currChar = *(_pCharacterStream + _nextTokOffset - 1);
    }
    else
    {
        _nextTokOffset += (ULONG)(pchCurr - pchWord + 1);
        if (_pEscStart)
            _pEscStart++;
    }
    
    Assert(_currChar == *(_pCharacterStream + _nextTokOffset - 1));
}

BOOL
Tokenizer::FetchString(TCHAR chDelim, BOOL fIgnoreEsc)
{
    BOOL   fResult;
    BOOL   fEscSeq = FALSE;
    BOOL  *pfEscSeq = _pEscStart ? &_fEscSeq : &fEscSeq;

    while (CurrentChar() && CurrentChar() != chDelim)
    {
        if (CHAR_RIGHT_PAREN == chDelim && !fIgnoreEsc && isspace(CurrentChar()))
            break;

        if (CurrentChar() == CHAR_ESCAPE && !fIgnoreEsc)
        {
            if (!*pfEscSeq)
            {
                *pfEscSeq = TRUE;
                Assert(_pEscBuffer && (_pEscStart || _pEscBuffer == &_tokenValue));
                if (_pEscStart && !_fEatenComment)
                    _pEscBuffer->Clear();
                else
                    _pEscBuffer->Set(_pStartOffset, (_pCharacterStream + _nextTokOffset - 1) - _pStartOffset);
            }

            ProcessEscSequence();
        }
        else if (*pfEscSeq && !_pEscStart)
            _pEscBuffer->Append(CurrentChar());

        NextChar();
    }

    _pEndOffset = _pCharacterStream + _nextTokOffset - 1;

    // Was end string delimiter found ' or " depending on how the string started?
    fResult = !!CurrentChar();

    if (!_pEscStart)
    {
        Assert(_pEscBuffer == &_tokenValue);
        _pStartTokenValueOffset = (*pfEscSeq) ? (LPTSTR)_tokenValue : _pStartOffset;
        _pEndTokenValueOffset = (*pfEscSeq) ? _pStartTokenValueOffset + _pEscBuffer->Length() : _pEndOffset;
    }

    return fResult;
}

Tokenizer::TOKEN_TYPE
Tokenizer::GetIE5CompatToken()
{
    TCHAR chCurrent = CurrentChar();
    Tokenizer::TOKEN_TYPE tt = TT_Unknown;

    Assert(chCurrent == CHAR_LBRACKET || chCurrent == CHAR_HYPHEN);

    if (_currTokOffset && !isspace(PrevChar()))
        return tt;

    switch (PeekNextChar(0))
    {
    // <!-- ?
    case CHAR_BANG :

        if (chCurrent == CHAR_LBRACKET && 
            PeekNextChar(1) == CHAR_HYPHEN &&
            PeekNextChar(2) == CHAR_HYPHEN)
        {
            AdvanceChars(3);
            tt = TT_BeginHTMLComment;
        }
        
        break;

    // --> ?
    case CHAR_HYPHEN :
        
        if (chCurrent == CHAR_HYPHEN &&
            PeekNextChar(1) == CHAR_RBRACKET) 
        {
            AdvanceChars(2);
            tt = TT_EndHTMLComment;
        }

        break;

    default:
        tt = TT_Unknown;
        break;
    }

    return tt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\caret.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       caret.cpp
//
//  Contents:   Implementation of the caret manipulation for the
//              CTextSelectionRecord class.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CARET_HXX_
#define X_CARET_HXX_
#include "caret.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__IME_H_
#define X__IME_H_
#include "_ime.h"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

MtDefine(CCaret, Edit, "CCaret");
MtDefine(CCaretUpdateScreenCaret_aryCaretBitMap_pv, Locals, "CCaret::UpdateScreenCaret aryCaretBitMap::_pv")
MtDefine(CCaretCreateCSCaret_aryCaretBitMap_pv, Locals, "CCaret::CreateCSCaret aryCaretBitMap::_pv")
MtDefine(CCaretCreateCSCaret_aryCaretVertBitMap_pv, Locals, "CCaret::CreateCSCaret::aryCaretVertBitMap::_pv")

const LONG CCaret::_xInvisiblePos = -32000;
const LONG CCaret::_yInvisiblePos = -32000;
const UINT CCaret::_HeightInvisible = 1;
const UINT CCaret::_xCSCaretShift = 2; // COMPLEXSCRIPT Number of pixels to shift bitmap caret to properly align

#if DBG ==1
static const LPCTSTR strCaretName = _T(" Physical Caret");
#endif

// Begin a-thkesa


#ifndef SPI_GETCARETWIDTH
#define SPI_GETCARETWIDTH                   0x2006
#endif

//End

//////////////////////////////////////////////////////////////////////////
//
//  CCaret's Constructor, Destructor
//
//////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//    Method:       CCaret::CCaret
//
//    Parameters:   CDoc*           pDoc        Document that owns caret
//
//    Synopsis:     Constructs the CCaret object, sets the caret's associated
//                  document.
//+-----------------------------------------------------------------------

CCaret::CCaret( CDoc * pDoc )
    : _pDoc( pDoc )
{
    _cRef = 0;
    _fVisible = FALSE;
    _fMoveForward = TRUE;
    _fPainting = 0;
    _Location.x = 0;
    _Location.y = 0;

    // Before doing anything .. first make sure we have
    // correct width.. by doing the following.
    // Begin a-thkesa
    // Get the current system setting for cursor.
    // See windows Bug:491261
    DWORD dwWidth = 1 ;
    BOOL bRet = ::SystemParametersInfo(
                SPI_GETCARETWIDTH,// system parameter to retrieve or set
                0,                // depends on action to be taken
                &dwWidth,         // depends on action to be taken
                0                 // user profile update option
                );

    if( bRet && dwWidth>0 )
    {
       _width = dwWidth; 
    }
    else
    {
       _width = 1 ;
    }
    //End.
    _height = 0;
    _dx = 0;
    _dy = 0;
    _dh = 0;
    _fCanPostDeferred = TRUE;
}


//+-----------------------------------------------------------------------
//    Method:        CCaret::~CCaret
//
//    Parameters:    None
//
//    Synopsis:     Destroys the CCaret object, sets the caret's associated
//                  document to null, releases the markup pointer.
//+-----------------------------------------------------------------------

CCaret::~CCaret()
{
    //
    // Remove any pending updates
    //
    _fCanPostDeferred = FALSE; // I'm dying here...
    GWKillMethodCall( this, ONCALL_METHOD( CCaret, DeferredUpdateCaret, deferredupdatecaret ), 0 );
    GWKillMethodCall( this, ONCALL_METHOD( CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll ), 0 );

    if ( _fVisible )
    {
        ::DestroyCaret();
    }        
    delete _pDPCaret;
}


//+-----------------------------------------------------------------------
//    Method:        CCaret::Init
//
//    Parameters:    None
//
//    Synopsis:     This method initalizes the caret object. It will create 
//                  the caret's mu pointer in the main tree of the document.
//                  Note that after initializing the caret, you must position
//                  and make the caret visible explicitly.
//+-----------------------------------------------------------------------

HRESULT
CCaret::Init()
{
    HRESULT hr = S_OK;

    _pDPCaret = new CDisplayPointer( _pDoc );
    if( _pDPCaret == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
        
    hr = THR( _pDPCaret->SetPointerGravity(POINTER_GRAVITY_Right) );
    if (FAILED(hr))
        goto Cleanup;

    hr = THR( _pDPCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
#if DBG == 1
    _pDPCaret->SetDebugName(strCaretName);
#endif

Cleanup:

    RRETURN( hr );
}



//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCaret::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CCaret::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CCaret::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( this , IUnknown )
        QI_INHERITS( this , IHTMLCaret )
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}



//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IHTMLCaret's Implementation
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveCaretToPointer
//
//    Parameters:   
//          pPointer        -   Pointer to move caret to the left of
//          fAtEOL          -   Is the caret after the EOL character?
//
//    Synopsis:     Moves the caret to the specified location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveCaretToPointer( 
    IDisplayPointer*    pDispPointer,
    BOOL                fScrollIntoView,
    CARET_DIRECTION     eDir )
{
    HRESULT hr = S_OK ;

    Assert( _pDPCaret );

    switch (eDir)
    {
    case CARET_DIRECTION_INDETERMINATE:
    {
        HRESULT hr;
        BOOL fEqual;
        BOOL fLeft;
        DISPLAY_GRAVITY dispGravityPointer;
        DISPLAY_GRAVITY dispGravityCaret;

        //
        // NOTE: IsBetweenLines doesn't work properly in some cases, so if
        // display gravity is different, skip the perf optimization.
        //

        hr = THR(_pDPCaret->GetDisplayGravity(&dispGravityCaret) );
        if (FAILED(hr))
            goto Cleanup;

        hr = THR(pDispPointer->GetDisplayGravity(&dispGravityPointer) );
        if (FAILED(hr))
            goto Cleanup;

        if (dispGravityCaret == dispGravityPointer)
        {
            hr = THR(_pDPCaret->IsEqualTo(pDispPointer, &fEqual));
            if (FAILED(hr))
                goto Cleanup;

            if (fEqual)
            {
                if (fScrollIntoView && _fVisible)
                {
                    hr = THR( pDispPointer->ScrollIntoView() );
                    if (FAILED(hr))
                        goto Cleanup;

                    hr = S_OK;
                }

                goto Cleanup;
            }
        }

        hr = THR(_pDPCaret->IsLeftOf(pDispPointer, &fLeft));
        if (SUCCEEDED(hr))
        {
            _fMoveForward = fLeft;
        }
        break;
    }
    case CARET_DIRECTION_SAME:
        break;
    case CARET_DIRECTION_BACKWARD:
    case CARET_DIRECTION_FORWARD:
        _fMoveForward = (eDir == CARET_DIRECTION_FORWARD);
        break;
#if DBG==1
    default:
        Assert(FALSE);
#endif
    }

    hr = THR( _pDPCaret->MoveToPointer( pDispPointer ));
    if( hr )
        goto Cleanup;

    DeferUpdateCaret( _fVisible && fScrollIntoView ); // Only scroll on move if visible
    
Cleanup:
    Assert(hr == S_OK);
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveCaretToPointerEx
//
//    Parameters:   
//          pPointer        -   Pointer to move caret to the left of
//          fAtEOL          -   Is the caret after the EOL character?
//
//    Synopsis:     Moves the caret to the specified location and set
//                  some common attributes. This should cut down on the
//                  number of times we calc the caret's location
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveCaretToPointerEx( 
    IDisplayPointer*    pDispPointer,
    BOOL                fVisible,
    BOOL                fScrollIntoView,
    CARET_DIRECTION     eDir )
{
    HRESULT     hr;
    BOOL        fOldVisible;
    
    hr = THR( MoveCaretToPointer( pDispPointer, fScrollIntoView, eDir ));
    fOldVisible = _fVisible;
    _fVisible = fVisible;

    //  If we moved the caret and the caret is becoming visible, make it visible.
    if (!fOldVisible && _fVisible)
    {
        DeferUpdateCaret( fScrollIntoView ); // Only scroll on move if visible
    }

    RRETURN ( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveMarkupPointerToCaret
//
//    Parameters:   IMarkupPointer *    Pointer to move to the right of the 
//                                      caret
//
//    Synopsis:     Moves the pointer to the right of the caret's location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveMarkupPointerToCaret( 
    IMarkupPointer *    pPointer )
{
    HRESULT hr = S_OK ;
    Assert( _pDPCaret );
    hr = THR( _pDPCaret->PositionMarkupPointer(pPointer) );
    RRETURN( hr );
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::MoveDisplayPointerToCaret
//
//    Parameters:   IDisplayPointer *  Pointer to move to the right of the 
//                                      caret
//
//    Synopsis:     Moves the pointer to the right of the caret's location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::MoveDisplayPointerToCaret( 
    IDisplayPointer *pDispPointer )
{
    HRESULT hr = S_OK ;
    Assert( _pDPCaret );
    hr = THR( pDispPointer->MoveToPointer(_pDPCaret) );
    RRETURN( hr );
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::IsVisible
//
//    Parameters:   BOOL *  True if the caret is visible.
//
//    Synopsis:     The caret is visible if Show() has been called. NOTE that
//                  this does not tell you if the caret is on the screen.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::IsVisible(
    BOOL *              pIsVisible)
{
    
    *pIsVisible = !!_fVisible;
  
    return S_OK;
}

BOOL
CCaret::IsPositioned()
{
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pDPCaret->IsPositioned( & fPositioned ));

    return fPositioned;
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::Show
//
//    Parameters:   None
//
//    Synopsis:     Un-hides the caret. It will display wherever it is 
//                  currently located.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::Show(
    BOOL        fScrollIntoView )
{
    HRESULT hr = S_OK;
    _fVisible = TRUE;
    DeferUpdateCaret( fScrollIntoView );
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::Hide
//
//    Parameters:   None
//
//    Synopsis:     Makes the caret invisible.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::Hide()
{
    HRESULT hr = S_OK;
    _fVisible = FALSE;
    
    if( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd )
    {
        ::HideCaret( _pDoc->_pInPlace->_hwnd );
    }
    
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::InsertText
//
//    Parameters:   OLECHAR *           The text to insert
//
//    Synopsis:     Inserts text to the left of cursor's current location.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::InsertText( 
    OLECHAR *           pText,
    LONG                lLen )
{
    Assert( _pDPCaret );
    
    HRESULT hr = S_OK ;
    LONG lActualLen = lLen;
    CTreeNode* pNode = NULL;
    BOOL fPositioned;
    CMarkupPointer mp(_pDoc);

    if (!_pDPCaret)
    {
	hr = E_FAIL;
	goto Cleanup;
    }

    hr = THR(_pDPCaret->IsPositioned(&fPositioned) );
    if (hr)
        goto Cleanup;
    
    if (!fPositioned)
    {
        hr= E_FAIL;
        goto Cleanup;
    }                

    //
    // marka - being EXTRA CAREFUL to fix a Stress failure.
    //
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if ( !pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    if (ETAG_INPUT == pNode->Element()->GetMasterIfSlave()->Tag())
    {
        CFlowLayout * pLayout = GetFlowLayout();
        Assert( pLayout );
        if ( ! pLayout )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
   
        if( lActualLen < 0 )
            lActualLen = pText ? _tcslen( pText ) : 0;
            
        LONG lMaxLen = pLayout->GetMaxLength();
        LONG lContentLen = pLayout->GetContentTextLength();
        LONG lCharsAllowed = lMaxLen - lContentLen;

        if( lActualLen > lCharsAllowed )
        {
            lActualLen = lCharsAllowed;
        }

        if( lActualLen <= 0 )
            goto Cleanup;
          
    }

    _fTyping = TRUE;

    hr = THR( _pDPCaret->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    if (hr)
        goto Cleanup;

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr)
        goto Cleanup;
        
    hr = _pDoc->InsertText( &mp, pText, lActualLen );
    if( hr )
        goto Cleanup;
    
Cleanup:
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::InsertMarkkup
//
//    Parameters:   OLECHAR *           The markup to insert
//
//    Synopsis:     Inserts html to the left of cursor's current location.
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::InsertMarkup( 
    OLECHAR *           pMarkup )
{
    return E_NOTIMPL;
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::ScrollIntoView
//
//    Parameters:   None
//
//    Synopsis:     Scrolls the current cursor location into view.
//                  NOTE: _Location may not be updated (_Location
//                  is only computed in CalcScreenCaretPos, called
//                  only from UpdateScreenCaret)
//+-----------------------------------------------------------------------

STDMETHODIMP 
CCaret::ScrollIntoView()
{
    DeferUpdateCaret( TRUE );
    return S_OK; // we can allways post a deferred update
}

//+-----------------------------------------------------------------------
//    Method:       CCaret::GetElementContainer
//
//    Parameters:   IHTMLElement **     The containing element.
//
//    Synopsis:     Returns the parent element at the cursor's current 
//                  location.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::GetElementContainer( 
    IHTMLElement **     ppElement )
{
    HRESULT         hr = S_OK ;
    CMarkupPointer  mp(_pDoc);

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr) 
        goto Cleanup;
        
    hr = THR( mp.CurrentScope( ppElement ));

Cleanup:
    RRETURN( hr );
}


CTreeNode *
CCaret::GetNodeContainer(DWORD dwFlags)
{  
    HRESULT         hr;
    CMarkupPointer  mp(_pDoc);
    CTreeNode *     pNode       = NULL;

    if (!_pDPCaret)
        goto Error;

    hr = THR( _pDPCaret->PositionMarkupPointer(&mp) );
    if (hr)
        goto Error;
            
    pNode = mp.CurrentScope(dwFlags);
    if (!pNode)
    {
        pNode = mp.Markup()->Root()->GetFirstBranch();
        Assert(pNode);
    }

Error:    
    return pNode;
}


STDMETHODIMP
CCaret::GetLocation(
    POINT *             pPoint,
    BOOL                fTranslate )
{
    HRESULT       hr = S_OK;
    
    if( fTranslate )
    {
        CFlowLayout * pLayout = GetFlowLayout();
        if( pLayout == NULL )
            RRETURN( E_FAIL );
            
        CPoint t( _Location );
        pLayout->TransformPoint(  &t, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL );
        pPoint->x = t.x;
        pPoint->y = t.y;
    }
    else
    {
        pPoint->x = _Location.x;
        pPoint->y = _Location.y;
    }

    g_uiDisplay.DocPixelsFromDevice(pPoint);

    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::UpdateCaret
//
//    Parameters:   none
//
//    Synopsis:     Allow the client of an IHTMLCaret to ask us to update
//                  our current location when we get around to it.
//+-----------------------------------------------------------------------

STDMETHODIMP
CCaret::UpdateCaret()
{
    DeferUpdateCaret( FALSE );
    return( S_OK );
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::UpdateCaret
//
//    Parameters:   
//                  fScrollIntoView -   If TRUE, scroll caret into view if 
//                                      we have focus or if not and 
//                                      selection isn't hidden
//                  fForceScroll    -   Force the caret to scroll no
//                                      matter what
//                  pdci            -   CDocInfo. Not used and may be null
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to ask us 
//                  to update our current location when we get around to it. 
//                  Also allows internal (mshtml) clients to control if we 
//                  scroll.
//
//+-----------------------------------------------------------------------

HRESULT
CCaret::UpdateCaret(
    BOOL        fScrollIntoView, 
    BOOL        fForceScroll,
    CDocInfo *  pdci )
{
    DeferUpdateCaret( ( fScrollIntoView || fForceScroll ));
    return( S_OK );
}



//+-----------------------------------------------------------------------
//    Method:       CCaret::GetCaretDirection
//
//    Parameters:   
//                  peDir    -  return current Caret Direction. It is either
//                              backward or forward
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to query for
//                  the caret direction.
//
//+-----------------------------------------------------------------------
STDMETHODIMP
CCaret::GetCaretDirection(
            CARET_DIRECTION *peDir
            )
{
    Assert (peDir);
    if (peDir)
    {
        *peDir = (_fMoveForward) ? CARET_DIRECTION_FORWARD:CARET_DIRECTION_BACKWARD;
        return (S_OK);
    }
    else
    {
        return (E_INVALIDARG);
    }
}


//+-----------------------------------------------------------------------
//    Method:       CCaret::SetCaretDirection
//
//    Parameters:   
//                  eDir    -   Caret Direction
//
//    Synopsis:     Allow the internal client of an IHTMLCaret to set caret
//                  direction without having to resort to other approaches.
//
//+-----------------------------------------------------------------------
STDMETHODIMP
CCaret::SetCaretDirection(
            CARET_DIRECTION eDir
            )
{

    HRESULT hr = S_OK;
    switch (eDir)
    {
        case CARET_DIRECTION_FORWARD:
            _fMoveForward = TRUE;
            break;
            
        case CARET_DIRECTION_BACKWARD:
            _fMoveForward = FALSE;
            break;

        default:
            hr = S_FALSE;
            break;
    }

    RRETURN(hr);
}



HRESULT
CCaret::BeginPaint()
{
    _fPainting ++ ;

    if( _fPainting == 1 )
    {
        _fUpdateEndPaint = FALSE;
        _fUpdateScrollEndPaint = FALSE;
    
        if( _fVisible )
        {
            Assert( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd );
            ::HideCaret( _pDoc->_pInPlace->_hwnd );
        }
    }
    
    return S_OK;
}


HRESULT
CCaret::EndPaint()
{
    HRESULT hr = S_OK;
    
    _fPainting -- ;

    //
    // if we recieved a deferred update of any flavor,
    // we want to post another update to compensate for
    // the loss.
    //

    if( _fPainting == 0 )
    {
        if( _fUpdateScrollEndPaint )
        {
            DeferUpdateCaret( TRUE );
        }
        else if( _fUpdateEndPaint )
        {
            DeferUpdateCaret( FALSE );
        }
        else if( _fVisible )
        {
            Assert( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd );
            ::ShowCaret( _pDoc->_pInPlace->_hwnd );
        }
        
        //
        // handled, even if there were nested paints...
        //

        _fUpdateEndPaint = FALSE;
        _fUpdateScrollEndPaint = FALSE;
    }

    return hr;
}


HRESULT
CCaret::LoseFocus()
{
//    ::DestroyCaret();
    if( _pDoc && _pDoc->_pInPlace && _pDoc->_pInPlace->_hwnd )
        ::HideCaret( _pDoc->_pInPlace->_hwnd );

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//  Private Utility functions
//
//////////////////////////////////////////////////////////////////////////

CFlowLayout *
CCaret::GetFlowLayout()
{
    CFlowLayout *   pFlowLayout;
    CTreeNode *     pNode;
    
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if( pNode == NULL )
        return NULL;
        
    pFlowLayout = pNode->GetFlowLayout();

    
    return pFlowLayout;
}

//+-----------------------------------------------------------------------
//    CCaret::UpdateScreenCaret
//    PRIVATE
//
//    Parameters:   None
//
//    Synopsis:     Something moved us, so we have to update the position of 
//                  the screen caret.
//
//    NOTE:   There are various things that affect caret. 
//            g_fComplextScript && fRTLFlow  -- affect caret shape
//            fVerticalFlow                  -- affects caret shape
//            _fMoveForward                  -- affects caret affinity
//
//+-----------------------------------------------------------------------

HRESULT
CCaret::UpdateScreenCaret( BOOL fScrollIntoView, BOOL fIsIME )
{
    HRESULT             hr = S_OK;
    POINT               ptGlobal;
    POINT               ptClient;
    CFlowLayout *       pFlowLayout;
    LCID                curKbd = LOWORD(GetKeyboardLayout(0));
    long                yDescent = 0;
    CTreeNode *         pNode = NULL;
    CCharFormat const * pCharFormat = NULL;
    LONG                cp;
    CCalcInfo           CI;
    BOOL                fIsPositioned;
    DISPLAY_GRAVITY     eDispGravity;
    BOOL                fComplexLine = FALSE;
    BOOL                fRTLFlow     = FALSE;
    BOOL                fVerticalFlow= FALSE;
    LONG                xAdjust = 0;
    LONG                xDelta  = 0;
    BOOL                fDeferredCreateCaret = FALSE;

    // Before doing anything .. first make sure we have
    // correct width.. by doing the following.
    // Begin a-thkesa
    // Get the current system setting for cursor.
    // See windows Bug:491261
    DWORD dwWidth = 1;
    BOOL bRet = ::SystemParametersInfo(
                  SPI_GETCARETWIDTH,// system parameter to retrieve or set
                  0,                // depends on action to be taken
                  &dwWidth,         // depends on action to be taken
                  0                 // user profile update option
                  );

    if( bRet && dwWidth>0 )
    {
      _width = dwWidth; 
    }
    else
    {   
      _width = 1 ;
    }
    //End.
	
	   // Prepare to update the caret
    //

    Assert( _pDoc != NULL );
    if( _pDoc == NULL )
    {
        return FALSE;
    }

    // If any of the following are true, we have no work to do
    if(     _pDPCaret == NULL || 
            _pDoc->_state < OS_INPLACE || 
            _pDoc->_pInPlace == NULL ||
            _pDoc->_pInPlace->_hwnd == NULL ||
            _pDoc->TestLock( SERVERLOCK_BLOCKPAINT ) ||
            _pDoc->_fPageTransitionLockPaint)
    {
        return FALSE;
    }

    IGNORE_HR( _pDoc->NotifySelection( EDITOR_NOTIFY_UPDATE_CARET, NULL) );

    hr = THR( _pDPCaret->IsPositioned(&fIsPositioned) );
    if( !fIsPositioned )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
        
    pNode = GetNodeContainer(MPTR_SHOWSLAVE);
    if( pNode == NULL )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    pFlowLayout = pNode->GetFlowLayout();
    if( pFlowLayout == NULL )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //If caret was set in the GENERIC element that later has got a view slave as a result of
    // some script action (from HTC script for example) , we should bail from here until caret
    // will be moved to some legit place as a result of user action. IE6 bug 4915.
    {
        CElement *pElement = pNode->Element();
        if(    pElement->Tag() == ETAG_GENERIC
            && pFlowLayout->ElementOwner() == pElement
            && pElement->HasSlavePtr())
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }
    
    cp = _pDPCaret->GetCp();
    pFlowLayout->WaitForRecalc( cp, -1 );


    pCharFormat = pNode->GetCharFormat();

    CI.Init(pFlowLayout);

    hr = THR(_pDPCaret->GetDisplayGravity(&eDispGravity) );
    if (FAILED(hr))
        goto Cleanup;

    if (-1 == pFlowLayout->PointFromTp( cp, NULL, eDispGravity == DISPLAY_GRAVITY_PreviousLine, _fMoveForward, ptClient, NULL, TA_BASELINE, 
                                        &CI, &fComplexLine, &fRTLFlow))
    {
        hr = OLE_E_BLANK;
        goto Cleanup;
    }

    Assert( pNode->Element() != _pDoc->PrimaryRoot() );

    //
    // Get the text height
    //

    if( ! _fVisible || _fPainting > 0 )
    {
        _height = 1;
    }
    else
    {
        long lNewHeight;
        
        // Start with springloader
        extern long GetSpringLoadedHeight(IMarkupPointer *, CFlowLayout *, long *);    

        lNewHeight = GetSpringLoadedHeight(NULL, pFlowLayout, &yDescent);
        
        if( lNewHeight != -1 )
        {
            BOOL fDefer;
            
            // Reflow, and we will want to defer our caret
            // update until the line remeasures
            SetHeightAndReflow( lNewHeight, &fDefer );

            if( fDefer )
            {
                DeferUpdateCaret( fScrollIntoView );
                goto Cleanup;
            }
        }
        else
        {
            // if springloader fails, get the text height from the format cache
            CCcs     ccs;
            const CBaseCcs *pBaseCcs;
            
            if (!fc().GetCcs(&ccs, CI._hdc, &CI, pCharFormat))
                goto Cleanup;

            pBaseCcs = ccs.GetBaseCcs();
            
            _height = pBaseCcs->_yHeight;
            
            yDescent = pBaseCcs->_yDescent;
            ccs.Release();
        }
    }

    if(_hbmpCaret)
    {
        if (fRTLFlow)
        {
            // the -1 at the end is an off by one adjustment needed for RTL
            xAdjust += (_xCSCaretShift + 1);
        }
        else
        {
            xAdjust += _xCSCaretShift;
        }
    }

    _Location.x = ptClient.x -  xAdjust;
    _Location.y = ptClient.y - ( _height - yDescent ) ;

#if 0
    //
    // Clip x to flow layout.  In general, the location returned from PointFromTp can be outside
    // the dimensions of the flow layout.
    //
    // For example: <DIV style="height:100">foo {caret}</DIV>
    //
    // The space will not contribute to the width of the DIV but will influence PointFromTp.  So
    // the caret will not be visible.
    //

    RECT rc;

    pFlowLayout->GetRect(&rc, COORDSYS_FLOWCONTENT);

    if (_Location.x >= rc.right)
    {
        _Location.x = rc.right-1;
    }
#endif
    
    //
    // Render the caret in the proper location
    //

    Assert( _fPainting == 0 );

    if( DocHasFocus() ||
      ( _pDoc->_pDragDropTargetInfo != NULL ) ) // We can update caret if we don't have focus during drag & drop
    {
        //
        // We need to caret vertical caret differently
        //
        fVerticalFlow = pFlowLayout->ElementOwner()->HasVerticalLayoutFlow();

    
        if( !fIsIME && g_fComplexScriptInput)
        {
            fDeferredCreateCaret = TRUE;
        }
        else
        {
            if( _hbmpCaret != NULL )
            {
                DestroyCaret();
                DeleteObject((void*)_hbmpCaret);
                _hbmpCaret = NULL;
            }
        }

        
        if( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if (fRTLFlow)
        {
            // consider the case for RTL with RTL flow 
            // the caret is located on the left side
            // of the typed in character, so the above
            // adjustment no longer satisfies the "adjust
            // into character" nature. So we want to
            // adjust the rectangle a little bit bigger
            //
            xDelta += _xCSCaretShift;
        }
        
        if( _pDoc->_state > OS_INPLACE )
        {

            ::HideCaret( _pDoc->_pInPlace->_hwnd );

            // if we have been requested to scroll, scroll the caret location into view
            if( fScrollIntoView && _fVisible && _fPainting == 0 )
            {
                // 
                // Here we want to consider both left-scrolling and right-scrolling cases
                // since caret position has been adjusted, we have to adjust the width of 
                // the caret rectangle too. 
                //
                //
                CRect rcLocal(  _Location.x + _dx , 
                                _Location.y + _dy , 
                                _Location.x + _dx + xAdjust + _width + xDelta,
                                _Location.y + _dy + _height + _dh );
                                
                pFlowLayout->ScrollRectIntoView( rcLocal, fVerticalFlow?SP_TYPINGSCROLL:SP_MINIMAL , fVerticalFlow?SP_MINIMAL:SP_TYPINGSCROLL );
            }

            // Translate our coordinates into window coordinates
            hr = THR( GetLocation( &ptGlobal , TRUE ) );
            g_uiDisplay.DeviceFromDocPixels(&ptGlobal);
            
            CRect rcGlobal;
            INT   yOffTop, yOffBottom;

            if (!fVerticalFlow)
            {
                rcGlobal.SetRect(   ptGlobal.x + _dx, 
                                    ptGlobal.y + _dy, 
                                    ptGlobal.x + _dx + xAdjust + _width, 
                                    ptGlobal.y + _dy + _height + _dh );
            }
            else
            {
                rcGlobal.SetRect(   ptGlobal.x - _dy - _dh - _height,
                                    ptGlobal.y + _dx, 
                                    ptGlobal.x - _dy, 
                                    ptGlobal.y + _dx + xAdjust + _width );
            }                                    

            // Calculate the visible caret after clipping to the layout in global
            // window coordinates
            CRect rcLayout;
            pFlowLayout->GetClippedClientRect( &rcLayout, CLIENTRECT_CONTENT );
            pFlowLayout->TransformRect( &rcLayout, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL );

            //
            // Do the clipping manually instead of letting Windows
            // handle it in bitmap caret case
            //
            if (fDeferredCreateCaret)  
            {
                if (!fVerticalFlow)
                {
                    if (rcGlobal.top >= rcLayout.bottom || rcGlobal.top + _height <= rcLayout.top)
                    {
                        // completely invisible
                        yOffTop     = _height;
                        yOffBottom  = 0;
                    }
                    else if (rcGlobal.top >= rcLayout.top && rcGlobal.top + _height <= rcLayout.bottom)
                    {
                        // completely visible
                        yOffTop     = 0;
                        yOffBottom  = 0;
                    }
                    else 
                    {
                        // partially visible
                        if (rcLayout.top >= rcGlobal.top)
                        {
                            yOffTop    = rcLayout.top - rcGlobal.top;
                            yOffBottom = _height - yOffTop - rcLayout.Height();
                            if (yOffBottom < 0)  yOffBottom = 0;
                        }
                        else
                        {
                            Assert (rcLayout.top <= rcLayout.bottom);
                            yOffTop     = 0;
                            yOffBottom  = _height - (rcLayout.bottom - rcGlobal.top);
                            if (yOffBottom > _height) yOffBottom = _height;
                        }
                        Assert (yOffTop >=0 && yOffTop <= _height);
                        Assert (yOffBottom >= 0 && yOffBottom <= _height);
                    }
                }
                else
                {
                    if ( rcGlobal.right <= rcLayout.left || rcGlobal.right - _height >= rcLayout.right)
                    {
                        // completely invisible
                        yOffTop    =  _height;
                        yOffBottom =  0;
                    }
                    else if (rcGlobal.right <= rcLayout.right && rcGlobal.right - _height >= rcLayout.left)
                    {
                        // completely visible
                        yOffTop     = 0;
                        yOffBottom  = 0;
                    }
                    else
                    {
                        // partially visible
                        if (rcLayout.right <= rcGlobal.right)
                        {
                            yOffTop    = rcGlobal.right - rcLayout.right;
                            yOffBottom = _height - yOffTop - rcLayout.Width();
                            if (yOffBottom < 0) yOffBottom = 0;
                        }
                        else
                        {
                            Assert (rcGlobal.right >= rcLayout.left);
                            yOffTop    = 0;
                            yOffBottom = _height - (rcGlobal.right - rcLayout.left);
                            if (yOffBottom > _height)  yOffBottom = _height;
                        }
                        Assert (yOffTop >=0 && yOffTop <= _height);
                        Assert (yOffBottom >= 0 && yOffBottom <= _height);
                    }
                }
                CreateCSCaret(curKbd, fVerticalFlow, yOffTop, yOffBottom);
            }
            
            rcGlobal.IntersectRect( rcLayout );            
            INT iW = rcGlobal.Width();
            INT iH = rcGlobal.Height();
            
            ::CreateCaret(  _pDoc->_pInPlace->_hwnd,
                            _hbmpCaret,
                            iW,
                            iH );

            if (!fVerticalFlow)
            {
                ::SetCaretPos( rcGlobal.left, rcGlobal.top );
            }
            else
            {
                ::SetCaretPos( rcGlobal.left + _dh, rcGlobal.top );
            }

            if( _fVisible && _fPainting == 0 && iW > 0  && iH > 0 )
            {
                if (::GetFocus() == _pDoc->_pInPlace->_hwnd)
                {
                    ::ShowCaret( _pDoc->_pInPlace->_hwnd );
                }
            }
        }
    }

Cleanup:
    RRETURN( hr );
}


//+-----------------------------------------------------------------------
//  PRIVATE
//  CCaret::CreateCSCaret
//  COMPLEXSCRIPT
//
//  Parameters: 
//              LCID        curKbd              Current Keyboard script
//              BOOL        fVerticalFlow       vertical/horizontal caret?
//              INT         yOffTop             number of top part pixels clipped
//              INT         yOffBottom          number of bottom part pixels clipped
//
//  Synopsis:   creates bitmap caret for complex scripts...like Arabic, 
//              Hebrew, Thai, etc.
//
//  NOTE:       we only clip on the y direction. 
//
//+-----------------------------------------------------------------------

void 
CCaret::CreateCSCaret(LCID curKbd, BOOL fVerticalFlow, INT yOffTop, INT yOffBottom)
{
    // array for creating the caret bitmap if needed
    CStackDataAry<WORD, 128> aryCaretBitMap( Mt( CCaretCreateCSCaret_aryCaretBitMap_pv ));

    // A new caret will be created. Destroy the caret bitmap if it existed
    if(_hbmpCaret != NULL)
    {
        DestroyCaret();
        DeleteObject((void*)_hbmpCaret);
        _hbmpCaret = NULL;
    }

    int i;
    int iClippedHeight;
    Assert( _height >= 0 );
    Assert( yOffTop >= 0 && yOffTop <= _height);
    Assert( yOffBottom >= 0 && yOffBottom <= _height);

    iClippedHeight = _height - yOffTop - yOffBottom;
    Assert( iClippedHeight >= 0);
    if (iClippedHeight <= 0) return;    // no need to create caret

     // dynamically allocate more memory for the cursor so that
     // the bmp can be created to the correct size
     aryCaretBitMap.Grow( iClippedHeight );

     // draw the vertical stem from top to bottom
     for(i = 0; i < iClippedHeight; i++)
     {
         aryCaretBitMap[i] = 0x0020;
     }

    if(PRIMARYLANGID(LANGIDFROMLCID(curKbd)) == LANG_THAI)
    {
        // when Thai keyboard is active we need to create the cursor which
        // users are accustomed to

        // change the bottom row to the tail
        if (yOffBottom <= 0)        
        {
            aryCaretBitMap[iClippedHeight - 1] = 0x0038;
        }

    }
    else if(g_fBidiSupport)
    {

        // on a Bidi system we need to create the directional cursor which
        // users are accustomed to

        // get the current keyboard direction and draw the flag
        if(IsRtlLCID(curKbd))
        {
            if (yOffTop <= 1)
            {
                if (yOffTop <= 0)
                {
                    aryCaretBitMap[0] = 0x00E0;
                    aryCaretBitMap[1] = 0x0060;
                }
                else
                {
                    aryCaretBitMap[0] = 0x0060;
                }
            }
        }
        else
        {
            if (yOffTop <= 1)
            {
                if (yOffTop <= 0)
                {
                    aryCaretBitMap[0] = 0x0038;
                    aryCaretBitMap[1] = 0x0030;
                }
                else 
                {
                    aryCaretBitMap[0] = 0x0030;
                }
            }
        }

    }

    if (!fVerticalFlow)
    {
        // create the bitmap
        _hbmpCaret = (HBITMAP)CreateBitmap(5, iClippedHeight, 1, 1, (void*) aryCaretBitMap);
    }
    else
    {
        // create the bitmap
        CStackDataAry<WORD, 128> aryCaretVertBitMap( Mt( CCaretCreateCSCaret_aryCaretVertBitMap_pv ));
        aryCaretVertBitMap.Grow( (iClippedHeight % 16 == 0 ? iClippedHeight : iClippedHeight  + 16) / 16 * 5 );
        RotateCaretBitmap((BYTE *)((void *)aryCaretBitMap), 
                          5, 
                          iClippedHeight,
                          (BYTE *)((void *)aryCaretVertBitMap)
                          );
        _hbmpCaret = (HBITMAP)CreateBitmap(iClippedHeight, 5, 1, 1, (void*) aryCaretVertBitMap);
    }
}


////////////////////////////////////////////////////////////////////////////////////////
//  PRIVATE:
//  CCaret::RotateCaretBitmap
//  COMPLEXSCRIPT  VERTICAL
//
// 
//  Create a vertical caret bitmap out of horizontal one. Note this is an ad hoc 
//  function used for the caret only. In the future we can consider calling 
//  general purpose rotation functions in xgdi.cxx  
//
//  Rotate 90 degree to the right
//  Given  pbmSrcBits with width iW, and height iH, x [0..iW-1] y [0..iH-1]
//  Transform:  
//         (x, y)  --->  (iH - 1 - y, x)
//
//  Return number of bytes in the destination bitmap
//
//  [zhenbinx]
//
////////////////////////////////////////////////////////////////////////////////////////
int
CCaret::RotateCaretBitmap(BYTE *pbmSrcBits, int iW, int iH, BYTE *pbmDestBits)
{
    Assert (iW > 0);
    Assert (iH > 0);
    Assert (pbmDestBits);
    Assert (pbmSrcBits);
    Assert (sizeof(WORD) == sizeof(BYTE) + sizeof(BYTE));

    //
    // Dest: (x, y)      --> located at y * iH + x 
    // Src : (y, iH - x) --> located at (iH - 1 - x)*iW + y
    //
    int  nDestBase        = 0;
    int  nSrcBase         = (iH - 1) * iW;
    BYTE maskBit          = 0x80;
    int  nBytesPerSrcLine = ((iW + 16) / 16) * 2;
    BOOL fDestNeedPadding = (iH % 16) == 0 ? FALSE : TRUE;
    BOOL fOneBytePadding  = ((iH + 8 ) / 8) % 2 == 0 ? FALSE : TRUE;
    BYTE *pDestByte       = pbmDestBits;
    BYTE *pSrcByte;       
    for (int y = 0; y < iW; y++)        // destBits height -- iW
    {
        int nDestLoc = nDestBase;
        int nSrcLoc  = nSrcBase;
        pSrcByte   = pbmSrcBits + (nSrcLoc/iW) * nBytesPerSrcLine + (nSrcLoc % iW)/8;
        for (int x = 0; x < iH; x++)    // destBits width -- iH
        {
            Assert ( nDestLoc >= 0 && nDestLoc <= iW * iH - 1);
            Assert ( nSrcLoc  >= 0 && nSrcLoc  <= iH * iW - 1);
            
            int  nSrcShift;
            int  nDestShift;
            BYTE byteSrc;

            if (0 == x%8)
            {
                if (x)  // do not advance the first byte
                {
                    pDestByte++;          // advance one byte
                }
                *pDestByte = '\0';    // zero out it first
            }
            //
            // Cacluate dest pixel location
            //
            nDestShift = x % 8;
            //
            // Cacluate src pixel location -- this should be optimized away in the future 
            //
            nSrcShift  = (nSrcLoc % iW) % 8;

            //
            // Copy src pixel into dest pixel
            //
            byteSrc   = (*pSrcByte) & (maskBit >> nSrcShift);
            *pDestByte |=  ((byteSrc << nSrcShift) >>  nDestShift);

            // 
            // advance destination pixel
            // Dest: (x + 1, y)      --> located at [(y * iH) + x] + 1
            // Src : (y, iH - x - 1) --> located at [(iH-1-x)*iW + y] - iW;
            //
            nDestLoc ++;
            nSrcLoc  -= iW;
            pSrcByte -= nBytesPerSrcLine;   // this is hacky 
        }
        
        //
        // Padding to word boundary so that we can go to next scan line
        //
        if (fDestNeedPadding && fOneBytePadding)
        {
            *(++pDestByte) = '\0';
        }

        //
        // Start a new scan line for the destination buffer
        //
        pDestByte++;
        
        //
        // advance to destination line
        // Dest: (x, y + 1)   --> located at [(y * iH + x)] + iH;
        // Src : (y+1, iH-x)   --> located at [(iH-1-x) * iW + y] + 1;
        //
        nDestBase += iH;
        nSrcBase  += 1;
    }

    Assert( (int)((iH % 16 == 0 ? iH : iH + 16) / 16 * 2 * 5)  == (int) (pDestByte - pbmDestBits) );
    return (int)(pDestByte - pbmDestBits);
}

//+-------------------------------------------------------------------------
//
//  Method:     DeferUpdateCaret
//
//  Synopsis:   Deferes the call to update caret
//
//  Returns:    None
//
//--------------------------------------------------------------------------
void
CCaret::DeferUpdateCaret( BOOL fScroll )
{
    if( _fCanPostDeferred )
    {
        // Kill pending calls if any
        GWKillMethodCall(this, ONCALL_METHOD(CCaret, DeferredUpdateCaret, deferredupdatecaret), 0);
        
        if( fScroll || _fTyping )
        {
            if( _fTyping )
            {
                _fTyping = FALSE;
            }
            
            // Kill pending scrolling calls if any
            GWKillMethodCall(this, ONCALL_METHOD(CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll), 0);
            // Defer the update caret scroll call
            IGNORE_HR(GWPostMethodCall(this,
                                       ONCALL_METHOD(CCaret, DeferredUpdateCaretScroll, deferredupdatecaretscroll),
                                       (DWORD_PTR)_pDoc, FALSE, "CCaret::DeferredUpdateCaretScroll")); // There can be only one caret per cdoc
        }
        else
        {
            // Defer the update caret call
            IGNORE_HR(GWPostMethodCall(this,
                                       ONCALL_METHOD(CCaret, DeferredUpdateCaret, deferredupdatecaret),
                                       (DWORD_PTR)_pDoc, FALSE, "CCaret::DeferredUpdateCaret")); // There can be only one caret per cdoc
        }
    }
}


void
CCaret::DeferredUpdateCaret( DWORD_PTR dwContext )
{
    DWORD_PTR dwDoc = (DWORD_PTR)_pDoc;
    CDoc * pInDoc = (CDoc *) dwContext;

    if( _fPainting > 0 )
    {
        _fUpdateEndPaint = TRUE;
    }
    else if( dwDoc == dwContext && pInDoc->_state >= OS_INPLACE )
    {
        UpdateScreenCaret( FALSE , FALSE );
    }
}


void
CCaret::DeferredUpdateCaretScroll( DWORD_PTR dwContext )
{
    DWORD_PTR dwDoc = (DWORD_PTR)_pDoc;
    CDoc * pInDoc = (CDoc *) dwContext;

    if( _fPainting > 0 )
    {
        _fUpdateScrollEndPaint = TRUE;
    }
    else if( dwDoc == dwContext && pInDoc->_state >= OS_INPLACE )
    {
        UpdateScreenCaret( TRUE, FALSE );
    }
}


BOOL
CCaret::DocHasFocus()
{
    
    BOOL fOut = FALSE;
    HWND hwHasFocus = GetFocus();
    fOut = ( _pDoc->_pInPlace != NULL                   && 
             _pDoc->_pInPlace->_hwnd != NULL            && 
             hwHasFocus != NULL && 
             _pDoc->_pInPlace->_hwnd == hwHasFocus );

    return fOut;
}


LONG
CCaret::GetCp(CMarkup *pMarkup)
{
    HRESULT  hr;
    LONG     cp = 0;
    BOOL     fPositioned;

    hr = THR( _pDPCaret->IsPositioned(&fPositioned) );

    if (SUCCEEDED(hr) && fPositioned)
    {
        cp = _pDPCaret->GetCp();
        if (pMarkup && pMarkup != _pDPCaret->Markup() )
        {
            //
            // Walk up the parent chain
            // to get the correct CP
            //
            CMarkup         *pSlaveMarkup;

            pSlaveMarkup = _pDPCaret->Markup();
            while (pSlaveMarkup)
            {
                if (pMarkup == pSlaveMarkup->GetParentMarkup())
                {
                    CElement        *pElem;
                    CTreePos        *pStPos;

                    pElem = pSlaveMarkup->Root();
                    if (pElem && pElem->HasMasterPtr())
                    {
                        pElem = pElem->GetMasterPtr();
                        Assert(pElem);
                        if (pElem)
                        {
                            pElem->GetTreeExtent(&pStPos, NULL);
                            Assert(pStPos);
                            if (pStPos)
                            {
                                cp = pStPos->GetCp();
                            }
                        }
                    }
                    break;
                }
                else
                {
                    pSlaveMarkup = pSlaveMarkup->GetParentMarkup();
                }
            }
        }
    }

    return cp;
}

CMarkup *
CCaret::GetMarkup()
{
    HRESULT  hr;
    CMarkup *pMarkup = NULL;
    BOOL     fPositioned;

    hr = THR( _pDPCaret->IsPositioned(&fPositioned) );

    if (SUCCEEDED(hr) && fPositioned)
    {
        pMarkup = _pDPCaret->Markup();
    }

    return pMarkup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CCaret::SetHeightAndReflow
//
//  Synopsis:   Sets the height of the caret, and determines if the line
//              where the caret is at needs to be re-measured.  This also
//              determines whether or not the caret display needs to be
//              deferred.
//
//  Arguments:  lHeight = new height of caret
//              pfDefer = Should the caret display be deferred?
//
//  Returns:    void
//
//--------------------------------------------------------------------------
void
CCaret::SetHeightAndReflow(LONG lHeight, BOOL *pfDefer)
{
    CTreeNode       *pNode = NULL;
    CFlowLayout     *pFlowLayout = NULL;
    CNotification   nf;
    BOOL            fDefer = FALSE;

    Assert( pfDefer );

    // See if the height has changed
    if( lHeight != _height )
    {
        CMarkupPointer mp(_pDoc);
        
        _height = lHeight;

        if (SUCCEEDED(_pDPCaret->PositionMarkupPointer(&mp)))
        {
            pNode = mp.CurrentScope(MPTR_SHOWSLAVE);
            Assert( pNode );

            pFlowLayout = pNode->GetFlowLayout();
            Assert( pFlowLayout );

            // Create the notification, we need to remeasure our line
            nf.CharsResize( GetCp(NULL), 1, pNode );
            pFlowLayout->GetContentMarkup()->Notify( nf );

            // Don't display the caret yet, let the line remeasure first
            fDefer = TRUE;
        }
    }       

    *pfDefer = fDefer;
}

//+---------------------------------------------------------------------------
//
//  Member:     IsInsideElement
//
//  Synopsis: Is the caret positioned inside a given element ?
//
//----------------------------------------------------------------------------


HRESULT
CCaret::IsInsideElement( CElement* pElement )
{
    HRESULT hr = S_OK;
    CMarkupPointer* pMPCaret = NULL;
    CMarkupPointer* pMPElement = NULL ;
    CTreeNode* pMasterNode = NULL ;
    
    if ( ! IsPositioned() )
    {
        hr = S_FALSE;
        goto Cleanup;
    }        

    hr = THR( _pDoc->CreateMarkupPointer( & pMPCaret ));
    if ( hr )
        goto Cleanup;
        
    if ( _pDPCaret->Markup() != pElement->GetMarkup() )
    {
        pMasterNode = GetNodeContainer(0)->GetNodeInMarkup( pElement->GetMarkup() ); 
        if ( pMasterNode )
        {
            pElement = pMasterNode->Element();
        }            

        hr = THR( pMPCaret->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        hr = THR( _pDPCaret->PositionMarkupPointer( pMPCaret) );
        if ( hr )
            goto Cleanup;
    }

    hr = THR( _pDoc->CreateMarkupPointer( & pMPElement ));
    if ( hr )
        goto Cleanup;

    hr = THR( pMPElement->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin ));
    if ( hr )
        goto Cleanup;

    if ( pMPCaret->IsRightOfOrEqualTo( pMPElement ) )
    {
        hr = THR( pMPElement->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ));
        if ( hr )
            goto Cleanup;

        if ( pMPCaret->IsLeftOfOrEqualTo( pMPElement ) )
        {
            hr = S_OK;
        }
        else
            hr = S_FALSE;
        
    }
    else
        hr = S_FALSE;
            
Cleanup:
    ReleaseInterface( pMPCaret );
    ReleaseInterface( pMPElement );

    RRETURN1( hr, S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltcalc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltcalc.cxx
//
//  Contents:   CTableLayout calculating layout methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LSM_HXX
#define X_LSM_HXX
#include "lsm.hxx"
#endif

//#define TABLE_PERF 1
#ifdef TABLE_PERF
#include "icapexp.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

MtDefine(CTableLayoutCalculateMinMax_aryReducedSpannedCells_pv, Locals, "CTableLayout::CalculateMinMax aryReducedSpannedCells::_pv")
MtDefine(CalculateLayout, PerfPigs, "CTableLayout::CalculateLayout")

MtDefine(UsingFixedBehaviour, LayoutMetrics, "Using CTable FixedBehaviour")
MtDefine(UsingFixedBehaviour1, UsingFixedBehaviour, "EnsureCells")
MtDefine(UsingFixedBehaviour2, UsingFixedBehaviour, "AdjustHeight")
MtDefine(UsingFixedBehaviour3, UsingFixedBehaviour, "Enable FORCE")

MtDefine(NotUsingFixedBehaviour, LayoutMetrics, "NOT Using CTable FixedBehaviour")

DeclareTag(tagTableRecalc,        "TableRecalc",  "Allow incremental recalc")
DeclareTag(tagTableChunk,         "TableChunk",   "Trace table chunking behavior")
DeclareTag(tagTableCalc,          "TableCalc",    "Trace Table/Cell CalcSize calls")
DeclareTag(tagTableDump,          "TableDump",    "Dump table sizes after CalcSize")
DeclareTag(tagTableSize,          "TableSize",    "Check min cell size two ways")
DeclareTag(tagTableMinAssert,     "TableMinAssert", "Assert if SIZEMODE_MINWIDTH is used")
DeclareTag(tagTableCellSizeCheck, "TableCellCheck",  "Check table cell size against min size")

DeclareTag(tagTableLayoutBlock,   "TableLayoutBlock", "PPV CalcSize fns");

ExternTag(tagCalcSize);

PerfTag(tagTableMinMax, "TableMinMax", "CTable::CalculateMinMax")
PerfTag(tagTableLayout, "TableLayout", "CTable::CalculateLayout")
PerfTag(tagTableColumn, "TableColumn", "CTable::CalculateColumns")
PerfTag(tagTableRow,    "TableRow",    "CTable::CalculateRow")
PerfTag(tagTableSet,    "TableCell",   "CTable::SetCellPositions")

// Wrappers to make is easier to profile table cell size calcs.
void CalculateCellMinMax (CTableCellLayout *pCellLayout,
                          CTableCalcInfo * ptci,
                          SIZE *psize)
{
    pCellLayout->CalcSize(ptci, psize);
}

void CalculateCellMin (CTableCellLayout *pCellLayout,
                       CTableCalcInfo * ptci,
                       SIZE *psize)
{
    pCellLayout->_fMinMaxValid = FALSE;
    ptci->_smMode = SIZEMODE_MINWIDTH;
    pCellLayout->CalcSize(ptci, psize);
    ptci->_smMode = SIZEMODE_MMWIDTH;
    pCellLayout->_fMinMaxValid = TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateMinMax
//
//  Synopsis:   Calculate min/max width of table
//
//  Return:     sizeMin.cx, sizeMax,cx, if they are < 0 it means CalcMinMax
//              have failed during incremental recalc to load history
//
//--------------------------------------------------------------------------

MtDefine( TableHistoryUsed, Metrics, "Table History Used");

void
CTableLayout::CalculateMinMax(CTableCalcInfo * ptci, BOOL fIncrementalMinMax)
{
    SIZEMODE        smMode = ptci->_smMode; // save
    int             cR, cC;
    CTableColCalc * pColCalc = NULL;
    CTableColCalc * pSizedColCalc;
    int             cCols = GetCols();
    CTableRow **    ppRow;
    CTableRowLayout * pRowLayout;
    int             cRows = GetRows();
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CTableCaption **ppCaption;
    int             cColSpan, cRowSpan;
    SIZE            size;
    long            xTablePadding = 0;
    int             cSpanned = 0;   // number of cells with colSpan > 1
    long            xMin=0, xMax=0;
    long            cxWidth, dxRemainder;
    int             cUnsizedCols, cSizedColSpan;
    BOOL            fMinMaxCell;
    const CWidthUnitValue * puvWidth = NULL;
    BOOL            fTableWidthSpecifiedInPercent;
    long            xTableWidth = GetSpecifiedPixelWidth(ptci, &fTableWidthSpecifiedInPercent);
    CTableColCalc * pColLastNonVirtual = NULL;  // last non virtual column
    int             cReducedSpannedCells;
    CTableColCalc * pColCalcSpanned;
    int             i, iCS;
    CPtrAry<CTableCell *>   aryReducedSpannedCells(Mt(CTableLayoutCalculateMinMax_aryReducedSpannedCells_pv));
    int             iPixelWidth;
    CTable        * pTable = Table();
    CTreeNode     * pNode;
    BOOL            fRowDisplayNone;
    BOOL            fAlwaysMinMaxCells = _fAlwaysMinMaxCells;
    
    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    //  If user specified size in the layout in CSS1 strict mode this size should 
    //  correspond to content size and should not include padding and border. 
    BOOL fStrictCSS1Document =      pTable->HasMarkupPtr() 
                                &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();

    BOOL            fCookUpEmbeddedTableWidthForNetscapeCompatibility = (xTableWidth == 0 &&
                        !fTableWidthSpecifiedInPercent && !pTable->IsAligned());

    if (fCookUpEmbeddedTableWidthForNetscapeCompatibility)
    {
        CLayout * pParentLayout = _cNestedLevel == 0 ? NULL : GetUpdatedParentLayout(ptci->GetLayoutContext());

        if (pParentLayout 
            && (   pParentLayout->Tag() == ETAG_TD 
                || pParentLayout->Tag() == ETAG_TH
                || pParentLayout->Tag() == ETAG_CAPTION))
        {
            pCellLayout = DYNCAST(CTableCellLayout, pParentLayout);

            // Only apply Nav compatibility width when there is nothing
            // else aligned to this table.
            if (!pCellLayout->_fAlignedLayouts)
            {
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                xTableWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
            }
        }
        fCookUpEmbeddedTableWidthForNetscapeCompatibility = (xTableWidth != 0);
    }

#if 0
    int xRowMin, xRowMax;
#endif

    PerfLog(tagTableMinMax, this, "+CalculateMinMax");

    ptci->_smMode = SIZEMODE_MMWIDTH;

    // Calc and cache border and other values
    CalculateBorderAndSpacing(ptci);

    _sizeMin.cx = 0;
    _sizeMax.cx = 0;

    size.cx = 0;
    size.cy = 0;

    _cNonVirtualCols = 0;
    _cSizedCols  = min(cCols, pTable->GetAAcols());
    cUnsizedCols = cCols - _cSizedCols;
    _fCols = !cUnsizedCols;
    fAlwaysMinMaxCells |=  ((ptci->_grfLayout & LAYOUT_FORCE) && _cSizedCols);


    if (fIncrementalMinMax)
    {
        Assert (_iLastRowIncremental);
        cR = (cRows - GetFooterRows()) - _cCalcedRows;
        i = GetNextRow(_iLastRowIncremental);
        ppRow  = &_aryRows[i];
        goto   IncrementalMinMaxEntry;
    }

    // ensure columns

    if (_aryColCalcs.Size() < cCols)
    {
        _aryColCalcs.EnsureSize(cCols);
        _aryColCalcs.SetSize(cCols);
    }

    // reset column values
    for (i = 0, pColCalc = _aryColCalcs; i < cCols; i++, pColCalc++)
    {
        pColCalc->Clear();
        CTableCol *pCol = GetCol(i);
        if (pCol && pCol->IsDisplayNone())
        {
            pColCalc->_fDisplayNone = TRUE;
        }
    }

    if (IsHistoryAvailable())
    {
        LoadHistory(pTable->_pStreamHistory, ptci);

        ClearInterface(&pTable->_pStreamHistory);

        if (_fUsingHistory)
        {
            if (cCols)
                pColLastNonVirtual = &_aryColCalcs[cCols - 1];

            MtAdd(Mt(TableHistoryUsed), +1, 0);

            goto endMinMax;
        }
        else
        {
            // load history have failed (_fUsingHistory == FALSE)
            if (_fIncrementalRecalc)
            {
                // if we are in the middle of the incremental recalc, stop it right here
                _fIncrementalRecalc = FALSE;
                if (!_fCompleted)
                {
                    // if we are not completed Ensure full MinMax path 
                    // (table will request resize at the compleetion, so we don't need to do it here).
                    _sizeMin.cx = -1;
                    _sizeMax.cx = -1;
                    goto EmergencyExit;
                }   // if we are completed then do full MinMax path now
            }
        }
    }
    else
    {
        _fUsingHistory = FALSE;
    }

    if (IsFixed())
    {
        // Set Columns Width
        CTableCol   *pCol;
        int         iSpecMinSum  = 0;
        int         iSpecedCols  = 0;
        int         iDisplayNoneCols  = 0;
        int         iBigNumber   = INT_MAX/2;
        int         iColumnWidth = 1;
        int         iColSpan;
        int         iFirstRow = GetFirstRow();
        BOOL        fSpecifiedColWidth;
        pRowLayout = _aryRows.Size()? _aryRows[iFirstRow]->RowLayoutCache(): NULL;
        int         ip;
        BOOL        fCellSpecifiedWidth;
        int         iSpan;

        if (pRowLayout && (pRowLayout->GetCells() < cCols))
        {
            pRowLayout->EnsureCells(cCols);
        }

        // go through specified columns and set the colCalcs accordingly
        for (int i = 0; i < _aryColCalcs.Size(); i++)
        {
            fCellSpecifiedWidth = FALSE;

            pCol = i < _aryCols.Size()? _aryCols[i] : NULL;
            if (pCol && pCol->IsDisplayNone())
            {
                iDisplayNoneCols++;
                continue;
            }
            if (pCol && !pCol->IsDisplayNone())
            {
                Assert(pCol->_iCol  == i);  // sanity check
                iColSpan = pCol->Cols();
                Assert (iColSpan >= 1);
                pNode = pCol->GetFirstBranch();
                // Get col's width (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();
                fSpecifiedColWidth = puvWidth->IsSpecified();
            }
            else
            {
                iColSpan = 1;
                fSpecifiedColWidth = FALSE;
            }

            if (   !fSpecifiedColWidth 
                && ((pCol && iColSpan == 1) || !pCol)
                && pRowLayout 
                && IsReal(pRowLayout->_aryCells[i]))
            {
                pCell = Cell(pRowLayout->_aryCells[i]);
                Assert (pCell);
                pNode = pCell->GetFirstBranch();
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();
                fSpecifiedColWidth = puvWidth->IsSpecified();
                if (fSpecifiedColWidth)
                {
                    iColSpan = pCell->ColSpan();
                    fCellSpecifiedWidth = TRUE;
                }
            }
            if (fSpecifiedColWidth)
            {
                if (puvWidth->IsSpecifiedInPixel())
                {
                    iPixelWidth = puvWidth->GetPixelWidth(ptci, pTable); 
                    if (    fStrictCSS1Document 
                        &&  IsReal(pRowLayout->_aryCells[i])    )
                    {
                        pCellLayout = Cell(pRowLayout->_aryCells[i])->Layout(ptci->GetLayoutContext());
                        
                        // Table is always horizontal => fVerticalLayoutFlow = FALSE
                        iPixelWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE);
                    }
                }
                else
                {
                    ip = puvWidth->GetPercent();
                    iPixelWidth = _sizeParent.cx*ip/100;
                }
                iColumnWidth = iPixelWidth;

                if (fCellSpecifiedWidth)
                {
                    iColumnWidth /= iColSpan;
                    iSpan = iColSpan;
                }
                else
                {
                    iSpan = 1;
                }

                for (int j = 0 ; j < iColSpan; j++)
                {
                    pColCalc = &_aryColCalcs[i + j];
                    // if it is a cell specified width with the colSpan > 1 and it is the last column, then
                    if (fCellSpecifiedWidth && iColSpan > 1 && j == iColSpan - 1)
                    {
                        // this is the size of the last column
                        iColumnWidth = iPixelWidth - (iColSpan - 1)*iColumnWidth;
                    }
                    pColCalc->AdjustForCol(puvWidth, iColumnWidth, ptci, iSpan);
                    iSpecedCols++;
                }
                iSpecMinSum += iPixelWidth;

            }
            _fCols = _fCols && fSpecifiedColWidth;

            i += iColSpan - 1;
        }

        // If any columns didn't specify a width, set their min to 1 (almost zero) and
        // their max to infinity (sums maximally add up to INT_MAX/2).  These values
        // make CTableLayout::CalculateColumns distribute any available width equally
        // among the unspecified columns.
        if (cCols - iSpecedCols - iDisplayNoneCols)
        {
            Assert (iSpecedCols < cCols);

            iColumnWidth = max(1, (iBigNumber - iSpecMinSum)/(cCols - iSpecedCols));

            for (cC = cCols, pColCalc = _aryColCalcs;
                cC > 0;
                cC--, pColCalc++)
            {
                if (pColCalc->_fDisplayNone)
                    continue;
                if (!pColCalc->IsWidthSpecified())
                {
                    pColCalc->_xMin = 1;
                    pColCalc->_xMax = iColumnWidth;
                }
            }
        }

        if (cCols)
            pColLastNonVirtual = &_aryColCalcs[cCols - 1];

        goto endMinMax;
    }


    // this variables are set for the case of non incremental MinMax calculation.
    cR = cRows;
    ppRow = _aryRows;

IncrementalMinMaxEntry:
    if (_cNestedLevel > SECURE_NESTED_LEVEL)
    {
        if (cCols)
            pColLastNonVirtual = &_aryColCalcs[cCols - 1];
        goto endMinMax;
    }

    //
    // Determine the number of fixed size columns (if any)
    // (If the COLS attribute is specified, assume the user intended
    //  for it to work and disregard any differences between the
    //  the number of columns specified through it and those
    //  actually in the table)
    //

    // collect min/max information for all the cells and columns
    // (it is safe to directly walk the row array since the order in which
    //  header/body/footer rows are encountered makes no difference)

    _fZeroWidth  = TRUE;

    for ( ;     // cR and ppRow must be set (look above for the comment)
        cR > 0;
        cR--, ppRow++)
    {
        pRowLayout = (*ppRow)->RowLayoutCache();

        // Ensure the row contains an entry for all columns
        // (It will not if subsequent rows have more cells)
        if (pRowLayout->GetCells() < cCols)
        {
            pRowLayout->EnsureCells(cCols);
        }

        pRowLayout->_uvHeight.SetNull();

        Assert(pRowLayout->GetCells() == cCols);
        ppCell = pRowLayout->_aryCells;

        fRowDisplayNone = pRowLayout->GetFirstBranch()->IsDisplayNone();

        //  (bug #110409) This is a fix for crash in CFlowLayout::CalcSozeCore() .
        //  Generally in minmax mode we do not calc percent size of children. 
        //  But if APE is nested and has percent height we'd better have 
        //  CTableCalcInfo members initialized : 
        ptci->_pRow = *ppRow;
        ptci->_pFFRow = (*ppRow)->GetFirstBranch()->GetFancyFormat();
        ptci->_pRowLayout = (CTableRowLayoutBlock *)(*ppRow)->GetUpdatedLayout(ptci->GetLayoutContext());

        for (cC = cCols, pColCalc = _aryColCalcs ;
             cC > 0;
             cC -= cColSpan, ppCell += cColSpan, pColCalc += cColSpan)
        {
            if (pColCalc->IsDisplayNone())
            {
                cColSpan = 1;
                continue;
            }
            pCell = Cell(*ppCell);

            if (IsReal(*ppCell))
            {
                pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                if (pColCalc > pColLastNonVirtual)
                {
                    pColLastNonVirtual = pColCalc;
                }

                cColSpan = pCell->ColSpan();

                // if row style is display==none, don't calculate min-max for it's cells
                if (fRowDisplayNone)
                    continue;

                cRowSpan = pCell->RowSpan();
                pNode = pCell->GetFirstBranch();
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                iPixelWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pNode->GetFancyFormat()->GetWidth();

                if (cR == cRows)
                {
                    pColCalc->_fWidthInFirstRow = puvWidth->IsSpecified();

                    for (iCS = 1, pColCalcSpanned = pColCalc + 1;
                         iCS < cColSpan;
                         iCS++, pColCalcSpanned++)
                    {
                        pColCalcSpanned->_fWidthInFirstRow = pColCalc->_fWidthInFirstRow;
                    }
                }

                fMinMaxCell        = (cC <= cUnsizedCols           ||
                                      !pColCalc->_fWidthInFirstRow ||
                                      (cR == cRows && puvWidth->IsSpecifiedInPercent()));
                _fCols = _fCols && !fMinMaxCell;

                //
                // For fixed size columns, use the supplied width for their min/max
                // (But ensure it is no less than that needed to display borders)
                //

                if (!fMinMaxCell)
                {
                    if (cR == cRows)
                    {
                        // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                        xMin =
                        xMax = puvWidth->GetPixelWidth(ptci, pTable, 0) + pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE);
                    }
                    else
                    {
                        xMin =
                        xMax = pColCalc->_xMax;
                    }
                }

                //
                // For non-fixed size columns, determine their min/max values
                //

                if (fMinMaxCell || fAlwaysMinMaxCells)
                {
                    WHEN_DBG ( BOOL fNeededMinWidth = FALSE; )

                    //
                    // Attempt to get min/max in a single pass
                    //

                    if (   fAlwaysMinMaxCells 
                        || (   (_fHavePercentageInset || (_fForceMinMaxOnResize && pCellLayout->_fForceMinMaxOnResize))  
                            && pCellLayout->_fMinMaxValid) )
                    {
                        pCellLayout->_sizeMax.SetSize(-1, -1);
                        pCellLayout->_sizeMin.SetSize(-1, -1);
                        pCellLayout->_fMinMaxValid = FALSE;
                    }
                    CalculateCellMinMax(pCellLayout, ptci, &size);
                    if (_fZeroWidth && !pCellLayout->NoContent())
                        _fZeroWidth = FALSE;

                    // if cell has a space followed by <br>, if we would have used history the text would create an extra 
                    // line for that <br>, since we would give the text exact width and it breaks after the space and then
                    // creates another line when it encounters <br> 
                    // ( it doesn't do look aside for <br> to catch this situation). bug #49599
                    if (pCellLayout->GetDisplay()->GetNavHackPossible())
                    {
                        _fDontSaveHistory = TRUE;
                        // _fForceMinMaxOnResize = TRUE;  // set it only during NATURAL calc, since we don't want to do minmax more then once.
                        pCellLayout->_fForceMinMaxOnResize = TRUE;  
                    }
                    else
                    {
                        pCellLayout->_fForceMinMaxOnResize = FALSE;
                    }


                    //
                    // If minimum width could not be reliably calculated, request it again
                    //

                    if (    pCellLayout->_fAlignedLayouts 
#if DBG == 1
                        ||  IsTagEnabled(tagTableSize)
#endif
                       )
                    {
                        SIZE sizeMin;
                        sizeMin.cx = sizeMin.cy = 0;

                        WHEN_DBG ( fNeededMinWidth = TRUE; )
                        CalculateCellMin(pCellLayout, ptci, &sizeMin);
#if DBG == 1
                        Assert(!IsTagEnabled(tagTableSize) || sizeMin.cx == size.cy);
                        Assert(!IsTagEnabled(tagTableMinAssert));
#endif

                        size.cy = max(sizeMin.cx, size.cy);
                        // we need to set correct value for _sizeMin, so next time FlowLayout returns correct min value
                        if (pCellLayout->_sizeMin.cu != size.cy)
                            pCellLayout->_sizeMin.SetSize(size.cy, -1);
                    }

                    //
                    // For normal min/max cases, use the returned value
                    //

                    if (fMinMaxCell)
                    {
                        xMax = size.cx;
                        xMin = size.cy;
                        Assert (fNeededMinWidth || xMax >= xMin);

//                        if (pCellLayout->IsWhiteSpacesOnly())
//                        {
//                            xMin = 0;
//                        }

                        // If a user set value exists, set the cell's maximum value
                        if (cC <= cUnsizedCols && puvWidth->IsSpecified() && puvWidth->IsSpecifiedInPixel() && iPixelWidth)
                        {
                            xMax = iPixelWidth;
                            // Ensure supplied width is not less than that of the minimum content width
                        }
                        if (xMax < xMin)
                        {
                            xMax = xMin;
                        }
                    }

                    //
                    // For fixed size cells, increase the min/max only
                    // if the calculated min is greater
                    //

                    else
                    {
                        Assert(cC > cUnsizedCols);
                        xMin =
                        xMax = max((long)xMax, size.cy);
                    }
                }


                //
                // For non-spanned cells, move the min/max (and possibly the
                // specified width) into the column structure
                //

                if (cColSpan == 1)
                {
                    pColCalc->AdjustForCell(this, iPixelWidth, puvWidth,
                                        (cC <= cUnsizedCols || !pColCalc->_fWidthInFirstRow),
                                        cR == cRows, ptci, xMin, xMax);
                }

                //
                // For spanned cells, distribute the width over the affected cells
                //

                else
                {

                    // if the spanned cell is exactly at the end of the table, then it is a potential
                    // case gor ignoring colSpans
                    if (cCols - cC == _iLastNonVirtualCol)
                    {
                        aryReducedSpannedCells.Append(pCell);
                    }

                    // Netscape compatibility (garantee for 1 + _xCellSpacing pixels per column)
                    int iMakeMeLikeNetscape = (cColSpan - 1)*(_xCellSpacing + 1);
                    if (iMakeMeLikeNetscape > pCellLayout->_sizeMin.cu)
                    {
                        pCellLayout->_sizeMax.SetSize(pCellLayout->_sizeMax.cu + iMakeMeLikeNetscape - pCellLayout->_sizeMin.cu, -1);
                        pCellLayout->_sizeMin.SetSize(iMakeMeLikeNetscape, -1);
                    }

                    //
                    // For non-fixed size spanned cells, simply note that the cell spans
                    // (The distribution cannot take place until after all cells in the
                    //  all the rows are have their min/max values determined)
                    //

                    if (    (   cC <= cUnsizedCols
                            || (    fMinMaxCell
                                &&  cR == cRows))
                        ||  (   (fAlwaysMinMaxCells)
                            &&  cR != cRows))
                    {
                        cSpanned++;
                        Assert (!pCellLayout->GetFirstBranch()->IsDisplayNone());
                        Assert(pCellLayout->_fMinMaxValid);
                        // NETSCAPE: uses special algorithm for calculating min/max of virtual columns
                        for (iCS = 0, pColCalcSpanned = pColCalc; iCS < cColSpan; iCS++, pColCalcSpanned++)
                        {
                            pColCalcSpanned->_cVirtualSpan++;
                        }
                    }

                    //
                    // For fixed size cells, distribute the space immediately
                    // (Fixed size cells whose widths are either unspecified or are
                    //  a percentage will have their widths set during CalculateColumns)
                    //

                    else if (!fMinMaxCell && cR == cRows)
                    {
                        Assert(cC > cUnsizedCols);

                        cxWidth       = xMax;
                        cSizedColSpan = min(cColSpan, _cSizedCols - (cCols - cC));

                        //
                        // Divide the user width over the affected columns
                        //

                        dxRemainder  = cxWidth - ((cSizedColSpan - 1) * _xCellSpacing);
                        cxWidth      = dxRemainder / cSizedColSpan;
                        dxRemainder -= cxWidth * cSizedColSpan;

                        //
                        // Set the min/max and width of the affected columns
                        //

                        Assert(cSizedColSpan <= (_aryColCalcs.Size() - (pColCalc - (CTableColCalc *)&_aryColCalcs[0])));
                        pSizedColCalc = pColCalc;

                        do
                        {

                            pSizedColCalc->Set(cxWidth + (dxRemainder > 0
                                                            ? 1
                                                            : 0));
                            if (pSizedColCalc > pColLastNonVirtual)
                            {
                                pColLastNonVirtual = pSizedColCalc;
                            }
                            pSizedColCalc++;
                            cSizedColSpan--;
                            dxRemainder--;

                        } while (cSizedColSpan);
                    }
                }

                if (!fStrictCSS1Document && cRowSpan == 1)
                {
                    pRowLayout->AdjustHeight(pNode, ptci, pTable);
                }
            }
            else
            {
                cColSpan = 1;
            }
            Assert(pColCalc->_xMin <= pColCalc->_xMax);
        }
    }

    //
    // If cells were spanned, check them again now
    //

    if (cSpanned)
    {
        cReducedSpannedCells = 0;
        for (int i=0; i < aryReducedSpannedCells.Size(); i++)
        {
            pCell = aryReducedSpannedCells[i];
            pCellLayout = pCell->Layout(ptci->GetLayoutContext());

            pColCalc = _aryColCalcs;
            pColCalc += pCell->ColIndex();
            cColSpan = pCell->ColSpan();
            BOOL fIgnoreSpan = TRUE;
            if (pColCalc->_cVirtualSpan != 1)
            {
                CTableColCalc *pColCalcSpannedPrev = pColCalc;
                pColCalcSpanned = pColCalc + 1;
                for (iCS = 1; iCS < cColSpan; iCS++, pColCalcSpanned++)
                {
                    Assert (pColCalcSpanned->_cVirtualSpan <= pColCalcSpannedPrev->_cVirtualSpan);
                    if (pColCalcSpanned->_cVirtualSpan !=
                        pColCalcSpannedPrev->_cVirtualSpan)
                    {
                        fIgnoreSpan = FALSE;
                        pColLastNonVirtual = pColCalcSpanned;
                    }
                    pColCalcSpannedPrev = pColCalcSpanned;
                }
            } // else we can ignore the SPAN
            if (fIgnoreSpan)
            {
                // Table is always horizontal => fVerticalLayoutFlow = FALSE
                iPixelWidth = pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
                // Get cell's width in table coordinate system (table is always horizontal => physical width)
                puvWidth = (const CWidthUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetWidth();
                pColCalc->AdjustForCell(this, iPixelWidth, puvWidth, TRUE, TRUE, ptci, pCellLayout->_sizeMin.cu, pCellLayout->_sizeMax.cu);
                cReducedSpannedCells++;
            }
        }
        if (cSpanned - cReducedSpannedCells)
        {
            AdjustForColSpan(ptci, pColLastNonVirtual, fIncrementalMinMax);
        }
    }

    if (   (_fCompleted && _fCalcedOnce)    // if min max path was more then once,
        || ptci->_fDontSaveHistory)         // or there are still not loaded images
    {
        _fDontSaveHistory = TRUE;           // then don't save the history.
    }

endMinMax:

    if (_pAbsolutePositionCells)
    {
        CTableCellLayout *pCellLayout;
        CTableCell      **ppCell;
        int               cCells;
        for (cCells = _pAbsolutePositionCells->Size(), ppCell = *_pAbsolutePositionCells ;  cCells > 0; cCells--, ppCell++)
        {
            pCellLayout = (*ppCell)->Layout(ptci->GetLayoutContext());
            CalculateCellMinMax(pCellLayout, ptci, &size);
        }
    }

    // calculate min/max table width and height

    xMin = xMax = 0;

    // sum up columns and check width

    if (cCols)
    {
        for (pColCalc = _aryColCalcs; pColCalc <= pColLastNonVirtual; pColCalc++)
        {
            xMin += pColCalc->_xMin;
            xMax += pColCalc->_xMax;
            if (!_fUsingHistory && !pColCalc->_fVirtualSpan && !pColCalc->IsDisplayNone())
            {
                _cNonVirtualCols++;
            }
        }
    }

    if (_sizeMin.cx < xMin)
    {
        _sizeMin.cx = xMin;
    }
    if (_sizeMax.cx < xMax)
    {
        _sizeMax.cx = xMax;
    }

    // add border space and padding

    if (_sizeMin.cx != 0 || _sizeMax.cx != 0)
    {
        // NETSCAPE: doesn't add the border or spacing if the table is empty.

        xTablePadding = _aiBorderWidths[SIDE_RIGHT] + _aiBorderWidths[SIDE_LEFT] + _cNonVirtualCols * _xCellSpacing + _xCellSpacing;
        _sizeMin.cx += xTablePadding;
        _sizeMax.cx += xTablePadding;
    }

    if (fCookUpEmbeddedTableWidthForNetscapeCompatibility)
    {
        if ( _sizeMax.cx < xTableWidth ||
             (_cNonVirtualCols == 1 && !(--pColCalc)->IsWidthSpecifiedInPixel()))
        {
            xTableWidth = 0;    //  DON'T CookUpEmbeddedTableWidthForNetscapeCompatibility
        }
    }

    // check if caption forces bigger width

    // NOTE:   NETSCAPE: does not grow the table width to match that of the caption, yet
    //         we do. If this becomes a problem, we can alter the table code to maintain
    //         a larger RECT which includes both the caption and table while the table
    //         itself is rendered within that RECT to its normal size. I've avoided adding
    //         this for now since it is not trivial. (brendand)

    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
         cC > 0;
         cC--, ppCaption++)
    {
        CTableCellLayout *pCaptionLayout = (*ppCaption)->Layout(ptci->GetLayoutContext());

        // Captions don't always have/need layout (replacing the above call w/ GetUpdatedLayout() doesn't
        // necessarily result in a layout ptr).  Added if() check; bug #75543.
        if ( pCaptionLayout )
        {
            pCaptionLayout->CalcSize(ptci, &size);

            if (_fZeroWidth && !pCaptionLayout->NoContent())
                _fZeroWidth = FALSE;

            if (_sizeMin.cx < size.cy)
            {
                _sizeMin.cx = size.cy;
            }

            // NETSCAPE: Ensure the table is wide enough for the minimum CAPTION width only
            //           (see above comments) (brendand)
            if (_sizeMax.cx < size.cy)
            {
                _sizeMax.cx = size.cy;

            }

            // If the table contains only a CAPTION, then use its maximum width for the table
            if (!GetRows() && _sizeMax.cx < size.cx)
            {
                _sizeMax.cx = size.cx;
            }

            /*
            _sizeMin.cy += size.cy;
            _sizeMax.cy += size.cy;
            */
        }
    }


    // If user specified the width of the table, we want to restrict max to the
    // specified width.
    // NS/IE compatibility, any value <= 0 is treated as <not present>
    if (xTableWidth)
    {
        if (xTableWidth > _sizeMin.cx)
        {
            _sizeMin.cx =
            _sizeMax.cx = xTableWidth;
        }
    }

    Assert(_sizeMin.cx <= _sizeMax.cx);

EmergencyExit:
    ptci->_smMode = smMode; // restore

    PerfLog(tagTableMinMax, this, "-CalculateMinMax");
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForColSpan
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
CTableLayout::AdjustForColSpan(CTableCalcInfo * ptci, CTableColCalc *pColLastNonVirtual, BOOL fIncrementalMinMax)
{
    int             cR, cC;
    int             iCS;
    CTableColCalc * pColCalc=0;
    CTableColCalc * pColCalcLast=0;
    CTableColCalc * pColCalcBase;
    int             cCols = GetCols();
    CTableRow **    ppRow;
    CTableRowLayout * pRowLayout;
    int             cRows = GetRows();
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    int             cColSpan, cRowSpan;
    int             xMin, xMax;
    int             cUnsizedCols;
    const CWidthUnitValue * puvWidth = NULL;
    CTable      *   pTable = ptci->Table();
    BOOL            fAlwaysMinMaxCells =  _fAlwaysMinMaxCells || ((ptci->_grfLayout & LAYOUT_FORCE) && _cSizedCols);

    cUnsizedCols = cCols - _cSizedCols;

    //
    // have to run through again and check column widths for spanned cells
    // if the sum of widths of the spanned columns are smaller then the
    // width of the cell we have to distribute the extra width
    // amongst the columns to make sure the cell will fit
    // (it is safe to directly walk the row array since the order in which
    //  header/body/footer rows are encountered makes no difference)
    //

    if (fIncrementalMinMax)
    {
        Assert (_iLastRowIncremental);
        cR = (cRows - GetFooterRows()) - _cCalcedRows;
        int i = GetNextRow(_iLastRowIncremental);
        ppRow  = &_aryRows[i];
    }
    else
    {
        cR = cRows;
        ppRow = _aryRows;
    }
    for ( ; cR > 0; cR--, ppRow++)
    {
        pRowLayout = (*ppRow)->RowLayoutCache();
        Assert(pRowLayout);

        if (pRowLayout->IsDisplayNone())
            continue;

        Assert(pRowLayout->GetCells() == cCols);
        ppCell = pRowLayout->_aryCells;

        for (cC = cCols, pColCalcBase = _aryColCalcs;
            cC > 0;
            cC -= cColSpan, ppCell += cColSpan, pColCalcBase += cColSpan)
        {
            if (pColCalcBase->IsDisplayNone())
            {
                cColSpan = 1;
                continue;
            }
            pCell = Cell(*ppCell);

            if (!IsReal(*ppCell))
            {
                cColSpan = 1;
            }
            else
            {
                pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                cColSpan = pCell->ColSpan();
                cRowSpan = pCell->RowSpan();

                // if the cell spans across multiple columns
                Assert (pColCalcBase <= pColLastNonVirtual);
                if (cColSpan > 1 &&
                    (fAlwaysMinMaxCells || cC <= cUnsizedCols) &&
                    pColCalcBase < pColLastNonVirtual)
                {
                    //
                    // cell is spanned, get min and max size and distribute it amongst columns
                    //

                    int iWidth = 0;     // Width (user specified) of this cell
                    int iWidthMin = 0;  // Min width of all the columns spanned accross this cell
                    int iWidthMax = 0;  // Max width of all the columns spanned accross this cell

                    int iUser = 0;      // Width of the pixel's (user) specified columns spanned accross this cell
                    int iUserMin = 0;   // Min width of those columns
                    int iUserMax = 0;   // Max width of those columns
                    int cUser = 0;      // Number of spanned columns that specified pixel's width

                    int iPercent = 0;   // %% width of the %% specified columns spanned accross this cell
                    int iPercentMin = 0;// Min width of those columns
                    int iPercentMax = 0;// Max width of those columns
                    int cPercent = 0;   // Number of columns scpecified with %%

                    int iMax = 0;       // Max width of normal columns (no width were scpecifed)
                    int cMax = 0;       // Number of columns that need Max distribution (normal column, no width specified)

                    int iMinMaxDelta = 0; // the delta between iWidthMax and iWidthMin (all the columns)

                    int xAdjust;        // adjustment to the width of this cell to account
                                        // cell spacing
                    int iMinSum;        // calculated actual Min sum of all the columns
                    int xDistribute;    // Width to distribute between normal columns.
                    int iOriginalColMin;
                    int iOriginalColMax;
                    int cRealColSpan = cColSpan;    // colSpan which doesn't include virtual columns
                    int  cVirtualSpan = 0;    // number of virtual columns
                    BOOL fColWidthSpecified;// set if there is a width spec on column
                    BOOL fColWidthSpecifiedInPercent; // set if there is a width spec in %% on column
                    BOOL fDoNormalMax;      // Do normal Max distribution
                    BOOL fDoNormalMin;      // Do normal Min distribution
                    int  iColMinWidthAdjust;// Adjust the coulmn min by
                    int  iColMaxWidthAdjust;// Adjust the coulmn max by
                    int  iCellPercent = 0;  // the specified %% of the spanned cell
                    int  iColPercent = 0;   // the calculated %% of the column
                    int  iColsPercent = 0;  // total sum of %% for all the columns
                    int  iNormalMin = 0;    // delta between the cell's Min and all the columns Min
                    int  iNormalMax = 0;    // delta between the cell's Max and all the columns Max
                    int  iNormalMaxForPercentColumns = 0;
                    int  iNormalMinForPercentColumns = 0;
                    int  xDistributeMax;
                    int  xDistributeMin;
                    int  xPercent;
                    int  iExtraMax = 0;
                    int  iNewPercentMax = 0;
                    int  cNewPercent = 0;

                    Assert(!pCellLayout->GetFirstBranch()->IsDisplayNone());
                    Assert(pCellLayout->_fMinMaxValid);

                    //
                    // sum up percent and user width columns for later distribution
                    //

                    for (iCS = 0; iCS < cColSpan; iCS++)
                    {
                        pColCalc = pColCalcBase + iCS;  // pColCalc is the column that this Cell is spanned accross

                        if (pColCalc->IsDisplayNone())
                        {
                            cRealColSpan--;
                            continue;
                        }

                        if (pColCalc->IsWidthSpecified())
                        {   // if the size of the coulumn is set, then
                            if (pColCalc->IsWidthSpecifiedInPercent())
                            {
                                iPercent += pColCalc->GetPercentWidth();
                                iPercentMin += pColCalc->_xMin;
                                iPercentMax += pColCalc->_xMax;
                                cPercent++;
                            }
                            else
                            {
                                iUser += pColCalc->GetPixelWidth(ptci, pTable);
                                iUserMin += pColCalc->_xMin;
                                iUserMax += pColCalc->_xMax;
                                cUser++;
                            }
                        }

                        if (pColCalc->_xMax)
                        {
                            iWidthMin += pColCalc->_xMin;
                            iWidthMax += pColCalc->_xMax;
                            if (pColCalc->_fVirtualSpan)
                            {
                                // NETSCAPE: we need to account for the virtual columns
                                cVirtualSpan++;
                            }
                        }
                        else
                        {
                            if (pColCalc <= pColLastNonVirtual)
                            {
                                // NETSCAPE: we need to account for the virtual columns
                                cVirtualSpan++;
                                // NETSCAPE: For each virtual column (due to the colSpan)
                                // they give extra 1 + cellSpacing pixels
                                pColCalc->_xMin =
                                pColCalc->_xMax = _xCellSpacing + 1;
                                iWidthMin += pColCalc->_xMin;
                                iWidthMax += pColCalc->_xMax;
                            }
                            else
                            {
                                // Don't count virtual columns at the end of the table
                                // when distributing.
                                cRealColSpan--;
                            }
                        }
                    }
                    iColsPercent = iPercent;
                    iCellPercent = (cRealColSpan == cPercent) ? iColsPercent : 100;

                    // don't take cell spacing into account
                    xAdjust = (cRealColSpan - cVirtualSpan - 1) * _xCellSpacing;
                    if (xAdjust < 0)
                    {
                        xAdjust = 0;
                    }

                    xMax = pCellLayout->_sizeMax.cu;    // max width of this cell

                    // Get cell's width in table coordinate system (table is always horizontal => physical width)
                    puvWidth = (const CWidthUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetWidth();

                    // use user set value if set
                    if (puvWidth->IsSpecified() && puvWidth->IsSpecifiedInPixel())
                    {
                        iWidth = puvWidth->GetPixelWidth(ptci, pTable);
                        if (iWidth < 0)
                        {
                            iWidth = 0;
                        }

                        if(xMax < iWidth)
                        {
                            xMax = iWidth;
                        }
                    }
                    xMin = pCellLayout->_sizeMin.cu;    // min width of this cell

                    Assert(xMax >= 0);
                    Assert(xMin >= 0);

                    if (xMax < xMin)
                    {
                        xMax = xMin;
                    }

                    cMax = cRealColSpan - cPercent - cUser;
                    iMax = iWidthMax - iPercentMax - iUserMax;

                    xDistribute = xMax;

                    //
                    // Now check if the cell width is specified by the user
                    //
                    if (puvWidth->IsSpecified())
                    {
                        if (puvWidth->IsSpecifiedInPercent())
                        {
                            // if there is percentage over distribute it
                            // amongst the non-percent columns
                            iCellPercent = puvWidth->GetPercent();
                            iPercent = iCellPercent - iColsPercent;
                            if (iPercent < 0)
                            {
                                iPercent = 0;
                            }
                            iUser = 0;
                        }
                        else
                        {
                            // if there is width over the user set widths and the percentage
                            // distribute it amongst the normal columns
                            iUser =  iWidth - MulDivQuick(iWidth, iPercent, iCellPercent) - iUser;
                            if (iUser < 0)
                            {
                                iUser = 0;
                            }
                            iPercent = 0;
                            xDistribute = iWidth;
                        }
                    }
                    else
                    {
                        iUser = 0;
                        iPercent = 0;
                    }

                    //---------------------------------------------
                    // 1. DO MIN and %% DISTRIBUTION
                    //---------------------------------------------
                    if (cPercent)
                    {
                        if (iCellPercent < iColsPercent)
                        {
                            iCellPercent = iColsPercent;
                        }
                        if (xDistribute - xAdjust - iWidthMax > 0)
                        {
                            iNormalMaxForPercentColumns = MulDivQuick(xDistribute - xAdjust, iColsPercent, iCellPercent) - iPercentMax;
                            if (iNormalMaxForPercentColumns < 0)
                            {
                                iNormalMaxForPercentColumns = 0;
                            }
                            iNormalMax = MulDivQuick(xDistribute - xAdjust, iCellPercent - iColsPercent, iCellPercent) - (iWidthMax - iPercentMax);
                            if (iNormalMax < 0)
                            {
                                iNormalMax = 0;
                            }
                        }
                        if (xMin - xAdjust - iWidthMin > 0)
                        {
                            iNormalMinForPercentColumns = MulDivQuick(xMin - xAdjust, iColsPercent, iCellPercent) - iPercentMin;
                            if (iNormalMinForPercentColumns < 0)
                            {
                                iNormalMinForPercentColumns = 0;
                            }
                            iNormalMin = MulDivQuick(xMin - xAdjust, iCellPercent - iColsPercent, iCellPercent) - (iWidthMin - iPercentMin);
                            if (iNormalMin < 0)
                            {
                                iNormalMin = 0;
                            }
                        }
                    }
                    else
                    {
                        Assert (iPercentMin == 0 && iPercentMax == 0);

                        // if the spanned cell min width is greater then width of the spanned columns, then set the iNormalMin
                        if (xMin - xAdjust - iWidthMin > 0)
                        {
                            iNormalMin = xMin - xAdjust - iWidthMin;
                        }

                        // only adjust max if there is a normal column without the width set
                        if (xDistribute - xAdjust - iWidthMax > 0)
                        {
                            iNormalMax = xDistribute - xAdjust - iWidthMax;
                        }
                    }

                    iMinMaxDelta = (iWidthMax - iPercentMax) - (iWidthMin - iPercentMin);
                    if (iMinMaxDelta < 0)
                    {
                        iMinMaxDelta = 0;
                    }

                    //
                    // go thru the columns and adjust the widths
                    //
                    iMinSum = 0;
                    for (iCS = 0; iCS < cRealColSpan; iCS++)
                    {
                        iColMinWidthAdjust = 0; // Adjust the coulmn min by
                        iColMaxWidthAdjust = 0; // Adjust the coulmn max by

                        pColCalc = pColCalcBase + iCS;
                        if (pColCalc->IsDisplayNone())
                        {
                            continue;
                        }
                        fColWidthSpecified = pColCalc->IsWidthSpecified();
                        fColWidthSpecifiedInPercent = pColCalc->IsWidthSpecifiedInPercent();
                        fDoNormalMax = fColWidthSpecifiedInPercent? (iNormalMaxForPercentColumns != 0)
                                                                  : (iNormalMax != 0);      // Do normal Max distribution
                        fDoNormalMin = fColWidthSpecifiedInPercent? (iNormalMinForPercentColumns != 0)
                                                                  : (iNormalMin != 0);      // Do normal Min distribution
                        iOriginalColMin = pColCalc->_xMin;
                        iOriginalColMax = pColCalc->_xMax;

                        if ((iPercent && !fColWidthSpecifiedInPercent) || fColWidthSpecifiedInPercent)
                        {
                            // Do distribution of Min Max for %% columns
                            if (fColWidthSpecifiedInPercent)
                            {
                                iColPercent = pColCalc->GetPercentWidth();
                                xDistributeMax = iNormalMaxForPercentColumns + iPercentMax;
                                xDistributeMin = iNormalMinForPercentColumns + iPercentMin;
                                xPercent = iColsPercent;
                            }
                            else
                            {
                                // set percent if overall is percent width
                                Assert (cRealColSpan - cPercent > 0);
                                iColPercent =
                                    iWidthMax - iPercentMax
                                        ? MulDivQuick(iOriginalColMax, iPercent, iWidthMax - iPercentMax)
                                        : MulDivQuick(iPercent, 1, cRealColSpan - cPercent); // use MulDivQuick to round up...
                                pColCalc->SetPercentWidth(iColPercent);
                                xDistributeMax = iNormalMax + iWidthMax - iPercentMax;
                                xDistributeMin = iNormalMin + iWidthMin - iPercentMin;
                                xPercent = iPercent;
                            }

                            if (fDoNormalMax)
                            {
                                Assert (xPercent);
                                int iNewColMax = MulDivQuick(xDistributeMax, iColPercent, xPercent);
                                if (iNewColMax > pColCalc->_xMax)
                                {
                                    pColCalc->_xMax = iNewColMax;
                                }
                                fDoNormalMax = FALSE;
                            }
                            if (fDoNormalMin)
                            {
                                int iNewColMin = MulDivQuick(xDistributeMin, iColPercent, xPercent);
                                if (iNewColMin > pColCalc->_xMin)
                                {
                                    pColCalc->_xMin = iNewColMin;
                                }
                                fDoNormalMin = FALSE;
                            }
                            if (pColCalc->_xMin > pColCalc->_xMax)
                            {
                                pColCalc->_xMax = pColCalc->_xMin;
                            }
                            iNewPercentMax += pColCalc->_xMax;
                            cNewPercent++;
                        }

                        if (fDoNormalMin)
                        {
                            iColMinWidthAdjust =
                                fDoNormalMax
                                ? MulDivQuick(iOriginalColMax, iNormalMin, iWidthMax - iPercentMax)
                                : iMinMaxDelta
                                    ? MulDivQuick(iOriginalColMax - iOriginalColMin, iNormalMin, iMinMaxDelta)
                                    : iWidthMin - iPercentMin
                                        ? MulDivQuick(iOriginalColMin, iNormalMin, iWidthMin - iPercentMin)
                                        : MulDivQuick(iNormalMin, 1, cRealColSpan - cPercent); // use MulDivQuick to round up...
                        }

                        //if (!pColCalc->_fVirtualSpan)
                        //{
                            if (iCS > cRealColSpan - cVirtualSpan)
                            {
                                // Note: the first virtual column is not cet as being VirtualSpan
                                // Netscape: virtual columns min/max is calculated only once!
                                pColCalc->_fVirtualSpan = TRUE;
                                pColCalc->_pCell = pCell;
                            }
                            pColCalc->_xMin += iColMinWidthAdjust;
                        //}
                        if (pColCalc->_xMin > pColCalc->_xMax)
                        {
                            // make sure that by distrubuting extra into columns _xMin we didn't exeed _xMax
                            pColCalc->_xMax = pColCalc->_xMin;

                            //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
                            //          don't propagate the user's width to the column.
                            if (pColCalc->_fWidthFromCell && pColCalc->IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified())
                            {
                                // reset the column uvWidth
                                pColCalc->_fDontSetWidthFromCell = TRUE;
                                pColCalc->ResetWidth();
                            }
                            iExtraMax += pColCalc->_xMax - iOriginalColMax;
                        }
                        iMinSum += pColCalc->_xMin;
                    }

                    Assert (pColCalc->_xMin >=0 && pColCalc->_xMax >= 0);

                    // if the sum of all the column's Mins is less then the cell's min then
                    // adjust all the  columns...
                    if ((iMinSum -= xMin - xAdjust) < 0)
                    {
                        pColCalc->_xMin -= iMinSum; // adjust min of last column
                        // this will adjust col max to user setting
                        if (pColCalc->_xMin > pColCalc->_xMax)
                        {
                            iExtraMax += pColCalc->_xMin - pColCalc->_xMax;
                            pColCalc->_xMax = pColCalc->_xMin;
                        }
                    }
                    Assert (pColCalc->_xMin >=0 && pColCalc->_xMax >= 0);

                    pColCalcLast = pColCalc;
                    //---------------------------------------------
                    // 2. DO MAX DISTRIBUTION
                    //---------------------------------------------
                    // only adjust max if there is a normal column without the width set
                    iNormalMax = xDistribute - xAdjust - (iWidthMax + iExtraMax + iNewPercentMax - iPercentMax);
                    if (iNormalMax > 0)
                    {
                        //
                        // go thru the columns and adjust the widths
                        //
                        iMinSum = 0;    // just reusing variable, in this context it means the sum of adjustments
                        for (iCS = 0; iCS < cRealColSpan; iCS++)
                        {
                            iColMaxWidthAdjust = 0; // Adjust the coulmn max by

                            pColCalc = pColCalcBase + iCS;
                            if (pColCalc->IsDisplayNone())
                                continue;
                            fColWidthSpecified = pColCalc->IsWidthSpecified();
                            fColWidthSpecifiedInPercent = pColCalc->IsWidthSpecifiedInPercent();
                            fDoNormalMax = !fColWidthSpecifiedInPercent;
                            iOriginalColMax = pColCalc->_xMax;

                            if (fDoNormalMax)
                            {
                                // adjust pColCalc max later because it can effect min calculation down here...
                                iColMaxWidthAdjust =
                                  iWidthMax + iExtraMax - iPercentMax
                                    ? MulDivQuick(iOriginalColMax, iNormalMax, iWidthMax + iExtraMax - iPercentMax)
                                    : MulDivQuick(iNormalMax, 1, cRealColSpan - cNewPercent); // use MulDivQuick to round up...

                                // if (!pColCalc->_fVirtualSpan) // || pColCalc->_pCell == pCell)
                                // {
                                    pColCalc->_xMax += iColMaxWidthAdjust;
                                    iMinSum += iColMaxWidthAdjust;
                                    pColCalcLast = pColCalc;

                                    //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
                                    //          don't propagate the user's width to the column.
                                    if (pColCalc->_fWidthFromCell && pColCalc->IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified() && iColMaxWidthAdjust)
                                    {
                                        // reset the column uvWidth
                                        pColCalc->_fDontSetWidthFromCell = TRUE;
                                        pColCalc->ResetWidth();
                                    }
                                // }
                            }
                        }
                        if (iMinSum < iNormalMax && pColCalcLast)
                        {
                            // adjust last column
                            pColCalcLast->_xMax += iNormalMax - iMinSum;
                        }
                    }
                }
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     SetCellPositions
//
//  Synopsis:   Set the final cell positions for the row
//
//--------------------------------------------------------------------------

void
CTableLayout::SetCellPositions(
    CTableCalcInfo * ptci,
    long        xTableWidth, 
    BOOL        fPositionSpannedCell, 
    BOOL        fSizeSpannedCell)
{
    Assert(ptci->GetLayoutContext() || (!fPositionSpannedCell && !fSizeSpannedCell));

    CTableRow * pRow = ptci->_pRow;
    Assert(pRow);

    if (pRow->GetFirstBranch()->IsDisplayNone())
    {
        // (olego: bug IE6 #27391) if the row has "display: none" set, there is nothing to do here
        return;
    }

    SIZEMODE        smMode = ptci->_smMode;
    int             cyAvailSafe   = ptci->_cyAvail;
    int             yConsumedSafe = ptci->_yConsumed;
    DWORD           grfLayoutSafe = ptci->_grfLayout;
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CDispNode *     pDispNode;
    int             cC;
    int             cCols = GetCols();
    CSize           sizeCell;
    int             iCellRowIndex;
    int             cCellRowSpan;
    CTableColCalc * pColCalc;
    CTable      *   pTable = ptci->_pTable;
    BOOL            fRTL = pTable->GetFirstBranch()->GetParaFormat()->HasRTL(TRUE);
    BOOL            fSetCellPositionOld;
    BOOL            fGlobalNormalCalcOld = ptci->_fGlobalNormalCalc;
    BOOL            fGlobalSetCalcOld = ptci->_fGlobalSetCalc;
    BOOL            fPositionParentTableGrid = IsGridAndMainDisplayNodeTheSame();
    BOOL            fStrictCSS1Document =   pTable->HasMarkupPtr() 
                                        &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();
    CPoint          ptRow;

    CTableRowLayoutBlock * pRowLayout = ptci->_pRowLayout;
    CTableRowLayout * pRowLayoutCache = pRow->RowLayoutCache();
    Assert(pRowLayout && pRowLayoutCache);

    // This check tells us that in browse-mode the rowLayout is the same as the rowCache.
    // when paginating a table this is not true.
    Check((ptci->GetLayoutContext() == NULL) == (pRowLayout == pRowLayoutCache));
 
    Assert(TestLock(CElement::ELEMENTLOCK_SIZING));

    PerfLog(tagTableSet, this, "+SetCellPositions");

    ptci->_smMode = SIZEMODE_SET;

    if (fStrictCSS1Document)
    {
        // During set cell position turn LAYOUT_FORCE flag OFF 
        ptci->_grfLayout &= (DWORD)(~LAYOUT_FORCE);
    }
    
    ptRow.x = pRowLayout->GetXProposed();
    ptRow.y = pRowLayout->GetYProposed();

    if (ptci->_pFFRow->_fPositioned)
    {
        if(   ptci->_pFFRow->_bPositionType == stylePositionrelative 
           && fPositionParentTableGrid)
        {
            // Note if the relatively positioned row will be positioned by the table grid display node,
            // then we need to subtract the border width, if the row will be positioned by the table node
            // which has a caption dsiplay node inside and the table grid node, then we are fine (since
            // border is included by the table grid node).
            if(!fRTL)
                ptRow.x -= _aiBorderWidths[SIDE_LEFT];
            else
                ptRow.x += _aiBorderWidths[SIDE_RIGHT];

            ptRow.y -= _aiBorderWidths[SIDE_TOP];
        }
        
        pRow->ZChangeElement(0, &ptRow, ptci->GetLayoutContext());     
                                             // relative rows will be positioned under the MAIN table display node 
                                             // absolute rows will be positioned under the "BODY" display node 
    }

    ptci->_fIgnorePercentChild =    !fStrictCSS1Document 
                                // Next four lines check for PPV case. In PPV nothing should be ignored since 
                                // in this case no proper break info is generated as well as flags set to pci. 
                                &&  (   !ElementCanBeBroken() 
                                    ||  !ptci->GetLayoutContext() 
                                    ||  !ptci->GetLayoutContext()->ViewChain() 
                                    ||  ptci->GetLayoutContext() == GetContentMarkup()->GetCompatibleLayoutContext()    )
                                &&  !ptci->_fTableHasUserHeight
    //  Row contains the summary of height information set to row and/or any of cells belonging to it. 
    //  If the row isn't provided with height information we want to prohibit child(ren) with percentage 
    //  height to be CalcSize'd.
                                &&  !pRowLayoutCache->IsHeightSpecified() 
    //  This check is "against" CSS spec, but is needed for backward compatibility with IE 5.0 (bugs #109130; #109202)
                                &&  !ptci->_pFFRow->IsHeightPercent();


    if (!ptci->_cGlobalNestedCalcs)
    {
        //  If the table is topmost initialize global state 
        ptci->_fGlobalSetCalc = TRUE;
    }

    //  _fGlobalNormalCalc should be turned OFF 
    ptci->_fGlobalNormalCalc = FALSE;


    ppCell = pRowLayoutCache->_aryCells;
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
            continue;
        pCell = Cell(*ppCell);
        if (pCell)
        {
            pCellLayout = pCell->Layout(ptci->GetLayoutContext()); 

            cCellRowSpan =  pCell->RowSpan();
            
            if (IsSpanned(*ppCell))
            {
                iCellRowIndex = pCell->RowIndex();
                
                // if ends in this row and this is the first column of the cell
                if ((  iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition() || fSizeSpannedCell)
                    && pCell->ColIndex() == cCols - cC)
                {
                    CTreeNode *pNode = pCell->GetFirstBranch();
                    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext()));
                    const CCharFormat  *pCF = pNode->GetCharFormat(LC_TO_FC(pti->GetLayoutContext()));
                    const CUnitValue &cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                    BOOL fIgnorePercentChildSafe = ptci->_fIgnorePercentChild;

                    pCellLayout->GetApparentSize(&sizeCell);
                    sizeCell.cy = ptRow.y + pRowLayout->_yHeight - pCellLayout->GetYProposed();

                    fSetCellPositionOld = ptci->_fSetCellPosition;

                    ptci->_fSetCellPosition = TRUE;
                    if (ptci->GetLayoutContext())
                    {
                        ptci->_cyAvail = cyAvailSafe - (pCellLayout->GetYProposed() + _cyFooterHeight + _yCellSpacing + _aiBorderWidths[SIDE_BOTTOM]);
                        ptci->_yConsumed = 0;
                    }

                    //  For a row-spanned cell get height specified information directly from fancy format...
                    ptci->_fIgnorePercentChild = !ptci->_fTableHasUserHeight && !pFF->IsHeightPercent() && cuvHeight.IsNullOrEnum();

                    pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                    ptci->_fSetCellPosition = fSetCellPositionOld;

#if DBG==1
                    {
                        BOOL fValidWidth = !pCellLayout->GetDisplay();
                        if (!fValidWidth)
                        {
                            BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                            LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetClientHeight() : pCellLayout->GetClientWidth();
                            // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                            lWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE);
                            fValidWidth =    (sizeCell.cx == lWidth) 
                                          || (  (lWidth - sizeCell.cx == 1)// Allow for rounding error on print scaling.
                                             && pCellLayout->ElementOwner()->GetMarkup()->IsPrintMedia());
                        }
                        Check( (pCellLayout->ContainsVertPercentAttr()) 
                            ||  pCellLayout->IsDisplayNone()
                            ||  fValidWidth);
                    }
#endif
                    ptci->_fIgnorePercentChild = fIgnorePercentChildSafe;
                }
            }

            if (!IsSpanned(*ppCell) || fPositionSpannedCell)
            {
                if (ptci->_pFFRow->_fPositioned)
                {
                    // need to position cell relative to the row
                    // Note positioned row is including cell spacing, therefore we need to adjust Y position of the
                    // cell by vertical spacing
                    pCellLayout->SetYProposed(0 + _yCellSpacing);   // 0 - means relative to the row
                }
                else
                {
                    pCellLayout->SetYProposed(ptRow.y);
                }
                if (    cCellRowSpan == 1 
                    //  (bug # 100284)
                    ||  fSizeSpannedCell)
                {
                    pCellLayout->GetApparentSize(&sizeCell);

                    if (    sizeCell.cy != pRowLayout->_yHeight
                        ||  pCellLayout->ContainsVertPercentAttr() 
                        ||  pCell->GetFirstBranch()->GetParaFormat()->_bTableVAlignment == htmlCellVAlignBaseline  )
                    {
                        sizeCell.cy = pRowLayout->_yHeight;

                        fSetCellPositionOld = ptci->_fSetCellPosition;

                        ptci->_fSetCellPosition = TRUE;
                        if (ptci->GetLayoutContext())
                        {
                            ptci->_cyAvail = cyAvailSafe - (ptRow.y + _cyFooterHeight + _yCellSpacing + _aiBorderWidths[SIDE_BOTTOM]);
                            ptci->_yConsumed = 0;
                        }
                        pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                        ptci->_fSetCellPosition = fSetCellPositionOld;

#if DBG==1
                        {
                            BOOL fValidWidth = !pCellLayout->GetDisplay();
                            if (!fValidWidth)
                            {
                                BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                                LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetClientHeight() : pCellLayout->GetClientWidth();
                                // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                                lWidth += pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE);
                                fValidWidth =    (sizeCell.cx == lWidth)
                                                 // Allow for rounding error on print scaling.
                                              || (   (  (lWidth - sizeCell.cx == 1)
                                                     // in paginated tables GetClient*() incorrectly returns g_Zero.size because only 1 dim is set.
                                                     || (sizeCell.cx == (fLayoutFlowChanged 
                                                                        ? pCellLayout->GetHeight() 
                                                                        : pCellLayout->GetWidth())))
                                                  && pCellLayout->ElementOwner()->GetMarkup()->IsPrintMedia());
                            }
                            Check( (pCellLayout->ContainsVertPercentAttr()) 
                                ||  _cNestedLevel > SECURE_NESTED_LEVEL
                                ||  pRowLayout->IsDisplayNone()
                                ||  fValidWidth);
                        }
#endif
                    }
                }

                if (IsNaturalMode(smMode))
                {
                    const CFancyFormat * pFF = pCellLayout->GetFirstBranch()->GetFancyFormat();
                    CPoint               pt;

                    // Note: NOT POSITIONED cells located in the display tree under the table's GRID node 
                    // or under the rows
                    // Note: RELATIVELY positioned cells live in the display tree outside the table's grdi display node or
                    // under the rows if they are positioned

                    pt.x = pCellLayout->GetXProposed();
                    pt.y = pCellLayout->GetYProposed();
                    
                    // adjust the proposed position if the cell is not positioned
                    // or it is positioned and the row is not positioned and cell is directly 
                    // under the grid node.
                    // or if cell is relatively positioned and the row is also positioned
                    if (   !pFF->_fPositioned  
                        || (!ptci->_pFFRow->_fPositioned && fPositionParentTableGrid)
                        || ptci->_pFFRow->_fPositioned  )
                    {
                        if(!fRTL)
                            pt.x -= _aiBorderWidths[SIDE_LEFT];
                        else
                            pt.x += _aiBorderWidths[SIDE_RIGHT];

                        if (!ptci->_pFFRow->_fPositioned)
                            pt.y -= (_aiBorderWidths[SIDE_TOP] + ptci->TableLayout()->_yTableTop);
                    }

                    if(fRTL)
                    {
                        pt.x = xTableWidth + pt.x
                             - _aiBorderWidths[SIDE_RIGHT]
                             - _aiBorderWidths[SIDE_LEFT];

                        // If an RTL cell has "overflow:visible", it should actually be 
                        // positioned further to the left (unlike LTR)
                        if (pFF->GetOverflowX() == styleOverflowVisible)
                        {
                            pt.x -= pCellLayout->GetDisplay()->GetRTLOverflow();
                        }
                    }
                            
                    if (pFF->_fPositioned)
                    {
                        // relative cells will be positioned outside the table's grid display node (if the row is not positioned)
                        Assert (pFF->_bPositionType == stylePositionrelative);
                        pCell->ZChangeElement(0, &pt, ptci->GetLayoutContext());
                    }
                    else
                    {
                        pDispNode = pCellLayout->GetElementDispNode();
                        if (pDispNode)
                        {
                            // NOTE:   We need some table-calc scratch space so that we don't have to use _ptProposed as the holder
                            //         of the suggested x/y (which is finalized with this call) (brendand)
                            //         Also, the scratch space needs to operate using the coordinates within the table borders since
                            //         the display tree translates taking borders into account (brendand)
                            pCellLayout->SetPosition(pt, TRUE);
                        }
                    }
                }
            }
        }
    }

    ptci->_grfLayout = grfLayoutSafe;
    ptci->_smMode    = smMode;
    ptci->_yConsumed = yConsumedSafe;
    ptci->_cyAvail   = cyAvailSafe;
    ptci->_fIgnorePercentChild = FALSE;

    ptci->_fGlobalNormalCalc = fGlobalNormalCalcOld; 
    ptci->_fGlobalSetCalc = fGlobalSetCalcOld; 

    PerfLog(tagTableSet, this, "-SetCellPositions");
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeAndPositionCaption
//
//  Synopsis:   Size and position a CAPTION
//
//  Arguments:  ptci      - Current CCalcInfo
//              pCaption - CTableCaption to position
//              pt       - Point at which to position the caption
//
//-----------------------------------------------------------------------------
void
CTableLayout::SizeAndPositionCaption(
    CTableCalcInfo *ptci,
    CSize *         psize,
    CLayout **      ppLayoutSibling,
    CDispNode *     pDispNodeSibling,
    CTableCaption * pCaption,
    POINT *         ppt, 
    BOOL            fCaptionCanBeBroken)
{
    Assert(ptci->GetLayoutContext() || !fCaptionCanBeBroken);

    CTableCellLayout *  pCaptionLayout = pCaption->Layout(ptci->GetLayoutContext());

    Assert(psize);
    Assert(pDispNodeSibling);

    if ( pCaptionLayout )
    {
        pCaptionLayout->SetXProposed(ppt->x);

        if (!pCaptionLayout->NoContent() || (pCaptionLayout->_fContainsRelative || pCaptionLayout->_fAutoBelow))
        {
            SIZE    sizeCaption;
            int     cyAvailSafe = ptci->_cyAvail;
            int     yConsumedSafe = ptci->_yConsumed;

            if (ptci->GetLayoutContext())
            {
                ptci->_cyAvail  -= ptci->_yConsumed;
                ptci->_yConsumed = 0;

                if (!fCaptionCanBeBroken)
                {
                    pCaptionLayout->SetElementCanBeBroken(FALSE);
                }
            }

            sizeCaption.cx = psize->cx;
            sizeCaption.cy = 1;
            pCaptionLayout->CalcSize(ptci, &sizeCaption);

            ptci->_cyAvail = cyAvailSafe;
            ptci->_yConsumed = yConsumedSafe;

            pCaptionLayout->SetYProposed(ppt->y);
            psize->cy += sizeCaption.cy;

            if (ptci->IsNaturalMode())
            {
                HRESULT hr;

                hr = AddLayoutDispNode(ptci,
                                       pCaptionLayout,
                                       NULL,
                                       pDispNodeSibling,
                                       ppt,
                                       (pCaption->_uLocation == CTableCaption::CAPTION_TOP));

                if (    hr == S_OK
                    &&  ppLayoutSibling)
                {
                    *ppLayoutSibling = pCaptionLayout;
                }
            }

            ppt->y           += sizeCaption.cy;
        }
        else
        {
            pCaptionLayout->_sizeCell.cx     = psize->cx;
            pCaptionLayout->_sizeCell.cy     = 0;
            pCaptionLayout->SetYProposed(0);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustRowHeights
//
//  Synopsis:   Distribute any extra height of a rowspan'd cell over the
//              spanned rows
//
//  NOTE: This routine will adjust the _sizeProposed for the table along
//        with the heights and sizes of the affected rows. However, it
//        depends upon the caller of this routine (e.g., CalculateRow) to
//        increase _sizeProposed by that of the last affected row.
//
//--------------------------------------------------------------------------

void
CTableLayout::AdjustRowHeights(
    CTableCalcInfo *ptci,
    CSize *         psize,
    CTableCell *    pCell)
{
    CSize       sizeCell;
    int         iRow  = pCell->RowIndex();
    int         cRows = pCell->RowSpan();
    int         cyRows;
    int         iRowCurrent;
    int         iRowLast;
    long        cyRowsActual;
    long        cyCell;
    CTable     *pTable = ptci->Table();
    CTableRowLayoutBlock   * pRowLayout = NULL;
    const CHeightUnitValue * puvHeight;
    BOOL                    fViewChain = (   ptci->GetLayoutContext()
                                          && ptci->GetLayoutContext()->ViewChain() != NULL
                                          && ElementCanBeBroken());
    CLayoutContext         * pLayoutContext = ptci->GetLayoutContext();

    Assert(cRows > 1);
    iRowLast = iRow + cRows - 1;

    // First, determine the height of the rowspan'd cell
    //--------------------------------------------------------------------
    pCell->Layout(pLayoutContext)->GetApparentSize(&sizeCell);


    if (fViewChain)
    {
        long cyCellHeightInLastRow = sizeCell.cy;

        for (iRowCurrent = iRow; iRowCurrent < iRowLast; iRowCurrent++)
        {
            CTableRow *pTableRow = GetRow(iRowCurrent);
            Assert(pTableRow);

            if (!pTableRow->CurrentlyHasLayoutInContext(pLayoutContext))
                continue;

            pRowLayout = DYNCAST(CTableRowLayoutBlock, pTableRow->GetUpdatedLayout(pLayoutContext));
            cyCellHeightInLastRow -= pRowLayout->_yHeight;
        }

        Assert(ptci->_pRowLayout == DYNCAST(CTableRowLayoutBlock, GetRow(iRowLast)->GetUpdatedLayout(pLayoutContext)));

        if (ptci->_pRowLayout->_yHeight < cyCellHeightInLastRow)
        {
            ptci->_pRowLayout->_yHeight = cyCellHeightInLastRow;
        }
        return;
    }

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    //---------------------------------------------------------------------------------------------
    puvHeight = (const CHeightUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetHeight();
    cyCell    = (!puvHeight->IsSpecified() || puvHeight->IsSpecifiedInPercent()
                        ? 0
                        : puvHeight->GetPixelHeight(ptci, pTable));
    cyRows    = max(sizeCell.cy, cyCell);


    // Next, determine the height of the spanned rows, based on the compatible/default layout
    //---------------------------------------------------------------------------------------
    pRowLayout   = DYNCAST(CTableRowLayoutBlock, GetRow(iRowLast)->GetUpdatedLayout(pLayoutContext));
    cyRowsActual = (pRowLayout->GetYProposed() + pRowLayout->_yHeight) 
                    - GetRow(iRow)->GetUpdatedLayout(pLayoutContext)->GetYProposed();


    // Last, if the cell height is greater, distribute the difference over the spanned rows
    //--------------------------------------------------------------------
    if (   cyRows > cyRowsActual 
        && cyRowsActual)
    {
        long    dyProposed = 0;
        long    dyHeight   = (cyRows - cyRowsActual);
        long    dyRow = 0;

        // Distribute the difference proportionately across affected rows
        for (iRowCurrent = iRow; iRowCurrent <= iRowLast; iRowCurrent++)
        {
            pRowLayout = DYNCAST(CTableRowLayoutBlock, GetRow(iRowCurrent)->GetUpdatedLayout(pLayoutContext));
            pRowLayout->SetYProposed(pRowLayout->GetYProposed() + dyProposed);

            if (dyProposed < dyHeight)
            {
                dyRow = MulDivQuick(pRowLayout->_yHeight, dyHeight, cyRowsActual);

                dyRow = min(dyRow, dyHeight - dyProposed);

                pRowLayout->_yHeight         += dyRow;
                dyProposed                   += dyRow;
            }
            else 
            {
                dyRow = 0;
            }
        }

        // pRowLayout is now the last layout the rowspan covers
        //
        // If the total height differs (due to round-off error),use the last 
        // row to make up the difference
        // NETSCAPE: Navigator always uses the last row, even if it has zero height
        cyRowsActual = (pRowLayout->GetYProposed() + pRowLayout->_yHeight) 
                       - GetRow(iRow)->GetUpdatedLayout(pLayoutContext)->GetYProposed();

        Assert(0 <= (cyRows - cyRowsActual));

        pRowLayout->_yHeight += cyRows - cyRowsActual;
        dyRow                += cyRows - cyRowsActual;

        // Adjust total table height
        // (The last row is excluded since the caller of this routine adds its height to the table)
        psize->cy += dyHeight - dyRow;

        // the heights are usually different when we are paginiating the rows in print preview
        Assert(   psize->cy == pRowLayout->GetYProposed() 
               || (   pLayoutContext
                   && ElementOwner()->IsPrintMedia()));
    }
}



//+-------------------------------------------------------------------------
//
//  Method:     CalculateRow
//
//  Synopsis:   Calculate the cell heights and the row height
//
//  Returns:    TRUE if a did not fit in the determined column width
//              FALSE otherwise
//
//--------------------------------------------------------------------------

BOOL
CTableLayout::CalculateRow(
    CTableCalcInfo *    ptci,
    CSize *             psize,
    CLayout **          ppLayoutSibling,
    CDispContainer *    pDispNode, 
    BOOL                fRowCanBeBroken,
    BOOL                fAdjustVertSpannedCell, 
    int                 yRowFromTop)
{
    SIZEMODE        smMode    = ptci->_smMode;
    DWORD           grfLayout = ptci->_grfLayout;
    CTableCell **   ppCell;
    CTableCell *    pCell;
    CTableCellLayout * pCellLayout;
    CTableColCalc * pColCalc;
    int             cC, cColSpan, iCS;
    long            iWidth = 0;
    SIZE            sizeCell;
    int             cUnsizedCols;
    int             cCols = GetCols();
    BOOL            fCellSizeTooLarge  = FALSE;
    BOOL            fAdjustForRowspan  = FALSE;
    CTable      *   pTable = ptci->_pTable;

    Assert (pTable == Table());

    BOOL            fRTL = pTable->GetFirstBranch()->GetParaFormat()->HasRTL(TRUE);
    int             cCellRowSpan;
    int             iCellRowIndex;
    CLayout *       pLayoutSiblingCell = *ppLayoutSibling;
    BOOL            fSetNewSiblingCell = TRUE;
    BOOL            fGlobalNormalCalcOld = ptci->_fGlobalNormalCalc;
    BOOL            fGlobalSetCalcOld = ptci->_fGlobalSetCalc;
    CTableRow *     pRow = ptci->_pRow;

    Assert(pRow);

    CTableRowLayoutBlock * pRowLayout = ptci->_pRowLayout;
    CTableRowLayout * pRowLayoutCache = pRow->RowLayoutCache();

    Assert(pRowLayout && pRowLayoutCache);

    CLayoutContext *  pLayoutContext  = ptci->GetLayoutContext();

    BOOL            fRowDisplayNone = pRowLayout->GetFirstBranch()->IsDisplayNone();
    BOOL            fViewChain      = pLayoutContext && pLayoutContext->ViewChain();

    AssertSz(fViewChain || (fRowCanBeBroken == FALSE && fAdjustVertSpannedCell == FALSE && yRowFromTop == 0), 
        "Illegal usage of PPV parameters in browse mode.");
    
    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    //  If user specified size in the layout in CSS1 strict mode this size should 
    //  correspond to content size and should not include padding and border. 
    BOOL fStrictCSS1Document =      pTable->HasMarkupPtr() 
                                &&  pTable->GetMarkupPtr()->IsStrictCSS1Document();

    // current offset in the row
    long            iLeft = 0;
    long            xPos;
    int             cyAvailSafe   = ptci->_cyAvail;
    int             yConsumedSafe = ptci->_yConsumed;

    if (fViewChain)
    {
        ptci->_cyAvail  -= ptci->_yConsumed;
        CheckSz(ptci->_cyAvail >= 0, "Negative available height in CalculateRow()");

        ptci->_yConsumed = 0; 

        Assert(ptci->_pFFRow->_bPositionType != stylePositionabsolute || !fRowCanBeBroken);

        if (!fRowCanBeBroken)
        {
            pRowLayout->SetElementCanBeBroken(FALSE);
        }
        else if (ptci->_cyAvail <= 0)
        {
            ptci->_fLayoutOverflow = TRUE;
        }
    }
                              
    PerfLog(tagTableRow, this, "+CalculateRow");

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    ptci->_smMode    = SIZEMODE_NATURAL;
    ptci->_grfLayout = ptci->_grfLayout & (LAYOUT_TASKFLAGS | LAYOUT_FORCE);

    //
    // Determine the number of sized columns (if any)
    //

    cUnsizedCols = cCols - _cSizedCols;

    // to calc baseline
    pRowLayout->_yBaseLine = -1;

    pRowLayout->_yHeight  = 0;
    // int iff = pRow->GetFirstBranch()->GetFancyFormatIndex();    // ensure compute format on the row.

    if (fRowDisplayNone)
        goto ExtractFromTree;

    if (ptci->_pFFRow->_fPositioned)
    {
        HRESULT hr = pRowLayout->EnsureDispNode(ptci, TRUE);
        if (!FAILED(hr))
        {
            // all the cells will be parented to the row's disp node container
            pDispNode = DYNCAST(CDispContainer, pRowLayout->GetElementDispNode());
            fSetNewSiblingCell = FALSE;
            pLayoutSiblingCell = NULL;
        }
    }


    if (IsFixedBehaviour())
    {
        if (pRowLayoutCache->GetCells() < cCols)
        {
            MtAdd( Mt(UsingFixedBehaviour1), 1, 0 );
            pRowLayoutCache->EnsureCells(cCols);
        }
    }

    Assert(pRowLayoutCache->GetCells() == cCols);

    if (!fStrictCSS1Document)
    {
        if (IsFixedBehaviour() || _cSizedCols)
        {   // if we have rowspan cells we can not be sure that the final rowSpan value is not 1, therefore we have to loop

            // clear caches only for fixed layout tables and tables after navigation (bug # 14950). 
            if (IsFixedBehaviour())
            {
                pRowLayoutCache->_uvHeight.SetNull();
                pRowLayoutCache->AdjustHeight(pRow->GetFirstBranch(), ptci, pTable); 
            
                if (IsFixed())
                {
                    //  For fixed layout tables also adjust for minHeight
                    pRowLayoutCache->AdjustMinHeight(pRow->GetFirstBranch(), ptci, pTable); 
                }
            }

            ppCell = pRowLayoutCache->_aryCells;
            for (cC = 0; cC < cCols; cC++, ppCell++)
            {
                if (IsReal(*ppCell))
                {
                    Assert(Cell(*ppCell));
                    pCell = Cell(*ppCell);

                    if (pCell->RowSpan() == 1)
                    {
                        CTreeNode *pCellTreeNode = pCell->GetFirstBranch();

                        // adjust height of the row for specified height of the cell
                        MtAdd( Mt(UsingFixedBehaviour2), 1, 0 );
                        pRowLayoutCache->AdjustHeight(pCellTreeNode, ptci, pTable); 
                    
                        if (IsFixed())
                        {
                            //  For fixed layout tables also adjust for minHeight
                            pRowLayoutCache->AdjustMinHeight(pCellTreeNode, ptci, pTable); 
                        }
                    }
                }
            }
        }
        if (pRowLayoutCache->IsHeightSpecified())
        {
            if (!pRowLayoutCache->IsHeightSpecifiedInPercent())
            {
                pRowLayout->_yHeight = pRowLayoutCache->GetPixelHeight(ptci);
                // In PPV we want to correct the height.
                if (fViewChain)
                {
                    //  This is how much space is available to fill
                    int cyAvail = ptci->_cyAvail - ptci->_yConsumed;
                    
                    // if the row is broken yRowFromTop is the previously comsumed height. 
                    pRowLayout->_yHeight -= yRowFromTop;

                    //  if the row height is still more than available height correct it
                    if (cyAvail < pRowLayout->_yHeight)
                    {
                        pRowLayout->_yHeight = cyAvail;
                    }

                    //  defencive code 
                    if (pRowLayout->_yHeight < 0)
                    {
                        pRowLayout->_yHeight = 0;
                    }
                }
            }
        }
    }
    else 
    {
        CTreeNode *pNodeRow     = pRow->GetFirstBranch();
        const CCharFormat *pCF  = pNodeRow->GetCharFormat(LC_TO_FC(ptci->LayoutContext()));
        if (pCF->_fUseUserHeight)
        {
            CHeightUnitValue uvHeight = ptci->_pFFRow->GetHeight();
            pRowLayout->_yHeight = uvHeight.YGetPixelValue(ptci, _sizeProposed.cy, 
                pNodeRow->GetFontHeightInTwips(&uvHeight)); 

            // In PPV we want to correct the height.
            if (fViewChain)
            {
                //  This is how much space is available to fill
                int cyAvail = ptci->_cyAvail - ptci->_yConsumed;
                
                // if the row is broken yRowFromTop is the previously comsumed height. 
                pRowLayout->_yHeight -= yRowFromTop;

                //  if the row height is still more than available height correct it
                if (cyAvail < pRowLayout->_yHeight)
                {
                    pRowLayout->_yHeight = cyAvail;
                }

                //  defencive code 
                if (pRowLayout->_yHeight < 0)
                {
                    pRowLayout->_yHeight = 0;
                }
            }
        }
    }

    if(!fRTL)
        xPos = _aiBorderWidths[SIDE_LEFT] + _xCellSpacing;
    else
        xPos = -(_aiBorderWidths[SIDE_RIGHT] + _xCellSpacing);

    pRowLayout->SetXProposed(xPos);
    pRowLayout->SetYProposed(fSetNewSiblingCell? 
                              psize->cy : 
                              psize->cy - _yCellSpacing);   // positioned rows include horsizontal and vertical cellSpacing

ExtractFromTree:

    if (!ptci->_cGlobalNestedCalcs)
    {
        //  If the table is topmost initialize global state 
        ptci->_fGlobalNormalCalc = TRUE;
    }

    //  _fGlobalSetCalc should be turned OFF 
    ptci->_fGlobalSetCalc = FALSE;

    ppCell = pRowLayoutCache->_aryCells;

    for (cC = 0, pColCalc = _aryColCalcs;
         cC < cCols;
         cC++, ppCell++, pColCalc++)
    {
        if (!IsEmpty(*ppCell))
        {
            pCell = Cell(*ppCell);
            pCellLayout = pCell->Layout(pLayoutContext);

            if (pColCalc->IsDisplayNone() || fRowDisplayNone)
            {
                CDispNode *pDispNodeOld = pCellLayout->GetElementDispNode();
                if (!IsSpanned(*ppCell) && pDispNodeOld)
                {
                    GetView()->ExtractDispNode(pDispNodeOld);
                }
                continue;
            }

            cCellRowSpan = pCell->RowSpan();
            iCellRowIndex = pCell->RowIndex();

            if (IsSpanned(*ppCell))
            {
                // if cell ends in this row adjust row height
                if (    iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition() 
                    &&  pCell->ColIndex() == cC )
                {
                    //
                    // Skip the cell if it begins in this row
                    // (Since its size is applied when it is first encountered)
                    //

                    if (iCellRowIndex != pRowLayoutCache->RowPosition())
                    {
                        fAdjustForRowspan = TRUE;
                    }
#if DBG==1
                    //
                    // This must have been a COLSPAN'd cell, ROWSPAN should be equal to one
                    //

                    else
                    {
                        Assert(cCellRowSpan == 1);
                    }
#endif
                    if (fViewChain)
                    {
                        Assert(pLayoutContext);

                        //  If spanned cell is broken we must inform table about it
                        CLayoutBreak *pLayoutBreak; 

                        pLayoutContext->GetEndingLayoutBreak(pCell, &pLayoutBreak); 
                        if (    pLayoutBreak 
                            &&  pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW  )
                        {
                            ptci->_fLayoutOverflow = TRUE;
                        }
                    }
                }

            }

            if (    !IsSpanned(*ppCell) 
                ||  (   fAdjustVertSpannedCell
                    &&  cCellRowSpan > 1 
                    //  (bug #95332)
                    &&  pCell->ColIndex() == cC )   )
            {
                // Track if we run into a COLS at this table nesting level.
                BOOL fTableContainsCols = ptci->_fTableContainsCols;
                ptci->_fTableContainsCols = FALSE;

                cColSpan = pCell->ColSpan();

                // calc cell width
                iWidth = pColCalc->_xWidth;
                CTableColCalc *pColCalcTemp;

                for (iCS = 1; iCS < cColSpan; iCS++)
                {
                    pColCalcTemp = pColCalc + iCS;
                    if (pColCalcTemp->_xWidth)
                    {
                        iWidth  += pColCalcTemp->_xWidth;
                        if (!pColCalcTemp->_fVirtualSpan)
                        {
                            iWidth  += _xCellSpacing;
                        }
                    } // else pure virtual (cell was already adjusted for it).
                }

                //
                // If this is a fixed size cell, set its min/max values
                // (Since CalcSize(SIZEMODE_MMWIDTH) is not invoked on fixed size cells,
                //  these values may not have been set)
                //


                if (cC < _cSizedCols && !pCellLayout->_fMinMaxValid)
                {
                    pCellLayout->_sizeMin.SetSize(iWidth, -1);
                    pCellLayout->_sizeMax.SetSize(iWidth, -1);
                    pCellLayout->_fMinMaxValid = TRUE;
                }

                // get cell height
                sizeCell.cx = iWidth;
                sizeCell.cy = 0;
                pCellLayout->_fContentsAffectSize = TRUE;
                pCellLayout->SetElementCanBeBroken(pCellLayout->ElementCanBeBroken() && fRowCanBeBroken);

                pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
                
                if (pCellLayout->_fForceMinMaxOnResize)
                {
                    _fForceMinMaxOnResize = TRUE;   // need to force min max on resize; bug #66432
                }

                //
                // If the sized cell is larger than the supplied width and it was
                // not min/max calculated, note the fact for our caller
                // (This can occur since sized columns take their width from user supplied
                //  values rather than the content of the cell)
                //

                // Cell overflow should only occur if we are dealing with fixed sized cells,
                // either at this level or in an embedded table.
                if ((ptci->_fTableContainsCols || cC < _cSizedCols) && sizeCell.cx > iWidth && !_fAlwaysMinMaxCells)
                {
                    pCellLayout->ResetMinMax();
                    fCellSizeTooLarge = TRUE;
                }

                // Restore potential table sibling's _fTableContainsCols.
                ptci->_fTableContainsCols |= fTableContainsCols || cC < _cSizedCols;

                //
                // 1. _yBaseLine on the row is used only for the cells with the specified baseline
                //    alignment.
                // 2. NETSCAPE: Baseline is taken from ALL the cells in the row
                //

                if (pCellLayout->_yBaseLine > pRowLayout->_yBaseLine)
                {
                    pRowLayout->_yBaseLine = pCellLayout->_yBaseLine;
                }


#if DBG == 1
                if (IsTagEnabled(tagTableCellSizeCheck))
                {
                    BOOL fLayoutFlowChanged = pCellLayout->GetFirstBranch()->GetFancyFormat()->_fLayoutFlowChanged;
                    LONG lWidth = fLayoutFlowChanged ? pCellLayout->GetDisplay()->GetHeight() : pCellLayout->GetDisplay()->GetWidth();
                    // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingMode = FALSE
                    Assert(iWidth >= lWidth + pCellLayout->GetBorderAndPaddingWidth(ptci, FALSE, TRUE));
                }
#endif

                {
                    const CFancyFormat *pFFCell = pCell->GetFirstBranch()->GetFancyFormat();

                    if (    IsNaturalMode(smMode)
                        &&  !pFFCell->_fPositioned  )
                    {
                        pLayoutSiblingCell = AddLayoutDispNode(ptci, pCellLayout, pDispNode, pLayoutSiblingCell);
                    }

                    if(!fRTL)
                        xPos = pRowLayout->GetXProposed() + iLeft;
                    else
                        xPos = pRowLayout->GetXProposed() - iLeft - iWidth;

                    pCellLayout->SetXProposed(xPos);

                    pCellLayout->SetYProposed(pRowLayout->GetYProposed());

                    // if not spanned beyond this row use this height
                    if (    (   cCellRowSpan == 1 
                            ||  (fViewChain && (iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition()))    ) 
                        &&  sizeCell.cy > pRowLayout->_yHeight
                        // (bug # 104206) To prevent content clipping in fixed broken rows in print view. 
                        // NOTE : code in CTableCellLayout::CalcSizeCore makes sure that this part of broken row 
                        // less or equal to the row height in compatible layout context.
                        &&  (   fViewChain 
                            ||  fStrictCSS1Document
                            ||  !(  IsFixed()
                            &&  pRowLayoutCache->IsHeightSpecifiedInPixel() 
                            &&  pFFCell->GetMinHeight().IsNullOrEnum()  )   )   )
                    {
                        pRowLayout->_yHeight = sizeCell.cy;
                    }
                }
            }
        }

        if (pColCalc->_xWidth)
        {
            iLeft  += pColCalc->_xWidth;

            if (!pColCalc->_fVirtualSpan)
            {
                iLeft  += _xCellSpacing;
            }
        }
    }

    //
    // If any cells were too large, exit immediately
    // (The row will be re-sized again with the proper widths)
    //

    if (fCellSizeTooLarge)
        goto Cleanup;

    // NETSCAPE: In Navigator, empty rows are 1 pixel high
    if (!pRowLayout->_yHeight && !fRowDisplayNone)
    {
        pRowLayout->_yHeight = ptci->DeviceFromDocPixelsX(1);
    }

    // NOTE: if there is baseline alignment in the row we DON'T NEED to recalculate the row height
    // since
    // NETSCAPE: NEVER grows the cells based on baseline alignment
    // If any rowspan'd cells ended in this row, adjust the row heights.
    //

    if (fAdjustForRowspan)
    {
        for (cC = 0, ppCell = pRowLayoutCache->_aryCells;
             cC < cCols;
             cC++, ppCell++)
        {
            if (!IsEmpty(*ppCell))
            {
                if (IsSpanned(*ppCell))
                {
                    pCell = Cell(*ppCell);
                    pCellLayout = pCell->Layout(ptci->GetLayoutContext());
                    cCellRowSpan = pCell->RowSpan();
                    iCellRowIndex = pCell->RowIndex();

                    if (   iCellRowIndex != pRowLayoutCache->RowPosition()    // the cell starts in one of the previous rows, AND
                        && iCellRowIndex +  cCellRowSpan - 1 == pRowLayoutCache->RowPosition()   // ends in this row, AND
                        && pCellLayout->ColIndex() == cC)              // it is a first column of the spanned cell
                    {
                        AdjustRowHeights(ptci, psize, pCell);
                    }
                }
            }
        }
    }

    pRowLayout->SetSizeThis( FALSE );

    ptci->_smMode    = smMode;
    ptci->_grfLayout = grfLayout;

    if (fRowDisplayNone)
        goto Cleanup;

    if (    !fStrictCSS1Document
        &&  pRowLayout->PercentHeight())
    {
        _fHavePercentageRow = TRUE;
    }

    if ( pRowLayout->_fAutoBelow && !pRowLayout->ElementOwner()->IsZParent() )
    {
         _fAutoBelow = TRUE;
    }

    if (fSetNewSiblingCell)
    {
        *ppLayoutSibling = pLayoutSiblingCell;
    }
    else
    {
        // need to set the size on the display node of the row
        CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                  pRowLayout->_yHeight + _yCellSpacing + _yCellSpacing);
        if (pRow->IsDisplayNone())
            sz.cy = 0;
        pDispNode->SetSize(sz, NULL, FALSE);
        xPos = pRowLayout->GetXProposed();
        pRowLayout->SetXProposed(xPos - _xCellSpacing);
    }

Cleanup:
    ptci->_fGlobalNormalCalc = fGlobalNormalCalcOld; 
    ptci->_fGlobalSetCalc = fGlobalSetCalcOld; 

    ptci->_yConsumed = yConsumedSafe;
    ptci->_cyAvail   = cyAvailSafe;

    PerfLog(tagTableRow, this, "-CalculateRow");
    return fCellSizeTooLarge;
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateRows
//
//  Synopsis:   Calculate the row heights and table height
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateRows(
    CTableCalcInfo * ptci,
    CSize *     psize)
{
    CTableLayoutBlock * pTableLayout = ptci->TableLayout();
    CTableRowLayoutBlock *pRowLayoutBlock;
    CTableRowLayout * pRowLayoutCache;
    CTableRow       * pRow;
    CTable          * pTable = ptci->Table();
    int             cR, cRows = GetRows();
    int             iRow;
    int             iPercent, iP;
    long            iMul, iDiv;
    int             iDelta;
    long            iNormalMin, iUserMin;
    long            iNormal, iUser;
    long            yHeight, yDelta;
    long            yTableHeight;
    int             yTablePadding;
    int             cAdjust;
    BOOL            fUseAllRows;
    long            iExtra;
#if DBG == 1
    int             cLoop;
#endif
    int             cOutRows = 0;

    Assert(pTableLayout);

    yTablePadding = 2 * _yBorder + cRows * _yCellSpacing + _yCellSpacing;

    // calc sum known % and known width

    iPercent = 0;
    iMul = 0;
    iDiv = 1;
    iUserMin = 0;
    iNormalMin = 0;

    for (cR = cRows, iRow = GetFirstRow();
        cR > 0;
        cR--, iRow = GetNextRow(iRow))
    {
        pRow = _aryRows[iRow];
        if (!pRow->_fCompleted)
        {
            Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
            yTablePadding -= _yCellSpacing;
            cOutRows++;
            continue;
        }
        ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
        if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
        {
            yTablePadding -= _yCellSpacing;
            cOutRows++;
            continue;
        }
        pRowLayoutCache = pRow->RowLayoutCache();
        Assert(pRowLayoutCache);

        yHeight = ((CTableRowLayoutBlock *)pRow->GetUpdatedLayout(ptci->GetLayoutContext()))->_yHeight;
        if (pRowLayoutCache->IsHeightSpecified())
        {
            if (pRowLayoutCache->IsHeightSpecifiedInPercent())
            {
                iP = pRowLayoutCache->GetPercentHeight();

                // remember max height/% ratio
                if (iP)
                {
                    if (yHeight * iDiv > iP * iMul)
                    {
                        iMul = yHeight;
                        iDiv = iP;
                    }
                }

                if (iPercent + iP > 100)
                {
                    iP = 100 - iPercent;
                    iPercent = 100;
                    pRowLayoutCache->SetPercentHeight(iP);
                }
                else
                {
                    iPercent += iP;
                }
            }
            else
            {
                Assert(yHeight >= pRowLayoutCache->GetPixelHeight(ptci));
                iUserMin += yHeight;
            }
        }
        else
        {
            iNormalMin += yHeight;
        }
    }

    iP = 100 - iPercent;
    if (iP < 0)
    {
        iP = 0;
    }

    // Table is always horizontal => physical height
    CHeightUnitValue uvHeight = GetFirstBranch()->GetFancyFormat()->GetHeight();

    // if we are calculating min/max and percent is set ignore user setting
    if (uvHeight.IsSpecified() && !(uvHeight.IsSpecifiedInPercent() &&
        (  ptci->_smMode == SIZEMODE_MMWIDTH
        || ptci->_smMode == SIZEMODE_MINWIDTH
        )))
    {
        yTableHeight = uvHeight.GetPercentSpecifiedHeightInPixel(ptci, pTable, pTableLayout->_sizeParent.cy) - yTablePadding;
    }
    else
    {
        // if user height is not given back calculate it from the max height/% ratio
        if (iPercent)
        {
            // check if the remaining user and normal columns are requiring bigger percentage
            if (iP)
            {
                if ((iUserMin + iNormalMin) * iDiv > iP * iMul)
                {
                    iMul = iUserMin + iNormalMin;
                    iDiv = iP;
                }
            }
            yTableHeight = MulDivQuick(100, iMul, iDiv);
        }
        else
        {
            yTableHeight = iUserMin + iNormalMin;
        }
    }

    // if current height is already bigger we cannot do anything...
    if (psize->cy - pTableLayout->_yTableTop >= yTableHeight + yTablePadding)
    {
        return;
    }

    // cache width remaining for normal and user columns
    yHeight = MulDivQuick(iP, yTableHeight, 100);

    // distribute remaining percentage amongst normal and user rows
    if (iUserMin)
    {
        iUser = iUserMin;
        if (iNormalMin)
        {
            iNormal = iNormalMin;
            if (iUser + iNormal < yHeight)
            {
                iNormal = yHeight - iUser;
            }
        }
        else
        {
            iNormal = 0;
            if (iUser < yHeight)
            {
                iUser = yHeight;
            }
        }
    }
    else
    {
        iUser = 0;
        if (iNormalMin)
        {
            iNormal = iNormalMin;
            if (iNormal < yHeight)
            {
                iNormal = yHeight;
            }
        }
        else
        {
            iNormal = 0;
        }
    }

    iP = MulDivQuick(100, yTableHeight - iUser - iNormal, yTableHeight);

    psize->cy = pTableLayout->_yTableTop + _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

    // distribute extra height
    iNormal -= iNormalMin;
    iUser   -= iUserMin;

    // remember how many can be adjusted
    cAdjust = 0;

    for (cR = cRows, iRow = GetFirstRow();
        cR > 0;
        cR--, iRow = GetNextRow(iRow))
    {
        pRow = _aryRows[iRow];
        pRowLayoutCache = pRow->RowLayoutCache();
        pRowLayoutBlock = (CTableRowLayoutBlock *)(pRow->GetUpdatedLayout(ptci->GetLayoutContext()));
        Assert(pRowLayoutBlock && pRowLayoutCache);

        ptci->_pRow = pRow;
        ptci->_pRowLayout = pRowLayoutBlock;
        ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

        if (!pRow->_fCompleted)
        {
            Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
            continue;
        }
        if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
            continue;
        
        if (!pRowLayoutCache->IsHeightSpecified() && iNormalMin)
        {
            yHeight = pRowLayoutBlock->_yHeight + MulDivQuick(iNormal, pRowLayoutBlock->_yHeight, iNormalMin);
        }
        else if (pRowLayoutCache->IsHeightSpecifiedInPercent())
        {
            yHeight = iPercent
                        ? MulDivQuick(yTableHeight,
                                    MulDivQuick(iP, pRowLayoutCache->GetPercentHeight(), iPercent),
                                    100)
                        : 0;
            if (yHeight < pRowLayoutBlock->_yHeight)
            {
                yHeight = pRowLayoutBlock->_yHeight;
            }
        }
        else if (iUserMin)
        {
            yHeight = pRowLayoutBlock->_yHeight + MulDivQuick(iUser, pRowLayoutBlock->_yHeight, iUserMin);
        }
        pRowLayoutBlock->_yHeightOld = pRowLayoutBlock->_yHeight;
        pRowLayoutBlock->_yHeight    = yHeight;

        if (ptci->_pFFRow->_bPositionType == stylePositionrelative)
        {
            CDispContainer *pDispNode = DYNCAST(CDispContainer, pRowLayoutBlock->GetElementDispNode());
            Assert (pDispNode);
            CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                      yHeight + _yCellSpacing + _yCellSpacing);
            pRowLayoutBlock->SetYProposed(psize->cy - _yCellSpacing);
            pDispNode->SetSize(sz, NULL, FALSE);
        }
        else
        {
            pRowLayoutBlock->SetYProposed(psize->cy);
        }
        SetCellPositions(ptci, psize->cx);

        psize->cy += yHeight + _yCellSpacing;
        // we can adjust this row since it is more than min height
        if (yHeight > pRowLayoutBlock->_yHeightOld)
        {
            cAdjust++;
        }
    }

    // adjust for table border

    psize->cy += _aiBorderWidths[SIDE_BOTTOM];
#if DBG == 1
    cLoop = 0;
#endif

    // this is used to keep track of extra adjustment couldn't be applied
    iExtra = 0;

    if (cRows - cOutRows)
    {
      while ((yDelta = yTableHeight + yTablePadding - (psize->cy - pTableLayout->_yTableTop)) != 0)
      {
        fUseAllRows = FALSE;
        if (yDelta > 0)
        {
            if (cAdjust == 0)
            {
                // use all the rows if we add...
                cAdjust = cRows - cOutRows;
                fUseAllRows = TRUE;
            }
        }
        
        // distribute rounding error
        if(!cAdjust)
            break;

        iMul = yDelta / cAdjust;
        iDiv = yDelta % cAdjust;
        iDelta = iDiv > 0 ? 1 : iDiv < 0 ? -1 : 0;

        psize->cy = pTableLayout->_yTableTop + _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

        // recalc cAdjust again
        cAdjust = 0;

        for (cR = cRows, iRow = GetFirstRow();
            cR > 0;
            cR--, iRow = GetNextRow(iRow))
        {
            pRow = _aryRows[iRow];
            pRowLayoutCache = pRow->RowLayoutCache();
            pRowLayoutBlock = (CTableRowLayoutBlock *)(pRow->GetUpdatedLayout(ptci->GetLayoutContext()));
            Assert(pRowLayoutBlock && pRowLayoutCache);

            ptci->_pRow = pRow;
            ptci->_pRowLayout = pRowLayoutBlock;
            ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

            if (!pRow->_fCompleted)
            {
                Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
                continue;
            }
            if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                continue;

            yHeight = pRowLayoutBlock->_yHeight;
            if (    yHeight > pRowLayoutBlock->_yHeightOld
                ||  (   yDelta > 0
                    &&  fUseAllRows))
            {
                yHeight += iMul + iDelta + iExtra;

                // if we went below min we have to adjust back...
                if (yHeight <= pRowLayoutBlock->_yHeightOld)
                {
                    iExtra  = yHeight - pRowLayoutBlock->_yHeightOld;
                    yHeight = pRowLayoutBlock->_yHeightOld;
                }
                else
                {
                    cAdjust++;
                    iExtra = 0;
                }

                iDiv -= iDelta;
                if (!iDiv)
                {
                    iDelta = 0;
                }
            }
            pRowLayoutBlock->_yHeightOld = pRowLayoutBlock->_yHeight;
            pRowLayoutBlock->_yHeight    = yHeight;

            if (ptci->_pFFRow->_bPositionType == stylePositionrelative)
            {
                CDispContainer *pDispNode = DYNCAST(CDispContainer, pRowLayoutBlock->GetElementDispNode());
                Assert (pDispNode);
                CSize  sz(psize->cx - _aiBorderWidths[SIDE_RIGHT] - _aiBorderWidths[SIDE_LEFT], 
                          yHeight + _yCellSpacing + _yCellSpacing);
                pRowLayoutBlock->SetYProposed(psize->cy - _yCellSpacing);
                pDispNode->SetSize(sz, NULL, FALSE);
            }
            else
            {
                pRowLayoutBlock->SetYProposed(psize->cy);
            }

            SetCellPositions(ptci, psize->cx);

            psize->cy += yHeight + _yCellSpacing;
        }

        // adjust for table border
        psize->cy += _aiBorderWidths[SIDE_BOTTOM];

#if DBG == 1
        cLoop++;
        Assert(cLoop < 5);
#endif
      }   // end of (while) loop
      

    }
    else
    {
        psize->cy += yTableHeight;
    }// end of if (cRows)

    Assert(iExtra == 0);
    Assert(psize->cy - pTableLayout->_yTableTop == yTableHeight + yTablePadding);
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateColumns
//
//  Synopsis:   Calculate column widths and table width
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateColumns(
    CTableCalcInfo * ptci,
    CSize *     psize)
{
    CTableColCalc * pColCalc;
    int     cC, cCols = GetCols();
    int     iPercentColumn, iPercent, iP;
    long    iMul, iDiv, iDelta;
    int     iPercentMin;
    long    iUserMin, iUserMax;
    long    iMin, iMax;
    long    iWidth;
    long    iNormal, iUser;
    BOOL    fUseMax = FALSE, fUseMin = FALSE, fUseMaxMax = FALSE;
    BOOL    fUseUserMax = FALSE, fUseUserMin = FALSE, fUseUserMaxMax = FALSE;
    BOOL    fSubtract = FALSE, fUserSubtract = FALSE;
    long    xTableWidth, xTablePadding;
    int     cAdjust;
    long    iExtra;
    BOOL    fUseAllColumns;
    CTable * pTable = ptci->Table();
    CTableLayoutBlock *pTableLayout = ptci->TableLayout();
    int     cDisplayNoneCols = 0;

#if DBG == 1
    int cLoop;
#endif

    PerfLog(tagTableColumn, this, "+CalculateColumns");

    xTablePadding = _aiBorderWidths[SIDE_RIGHT] + _aiBorderWidths[SIDE_LEFT] + _cNonVirtualCols * _xCellSpacing + _xCellSpacing;

    //
    // first calc sum known percent, user set and 'normal' widths up
    //
    iPercent = 0;
    iPercentMin = 0;
    iUserMin = iUserMax = 0;
    iMin = iMax = 0;

    //
    // we also keep track of the minimum width-% ratio necessary to
    // display the table with the columns at max width and the right
    // percent value
    //
    iMul = 0;
    iDiv = 1;

    //
    // Keep track of the first column which introduces a percentage width
    //

    iPercentColumn = INT_MAX;
    _fHavePercentageCol = FALSE;

    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            cDisplayNoneCols++;
            continue;
        }
        if (pColCalc->IsWidthSpecified())
        {
            if (pColCalc->IsWidthSpecifiedInPercent())
            {
                _fHavePercentageCol = TRUE;
                if (iPercentColumn > (cCols - cC))
                {
                    iPercentColumn = cCols - cC;
                }

                iP = pColCalc->GetPercentWidth();

                if (iP < 0)
                {
                    iP = 0;
                }
                // if we are over 100%, cut it back
                if (iPercent + iP > 100)
                {
                    iP = 100 - iPercent;
                    iPercent = 100;
                    pColCalc->SetPercentWidth(iP);
                }
                else
                {
                    iPercent += iP;
                }

                // remember max width/% ratio
                if (iP == 0)
                {
                    iP = 1; // at least non empty cell should get 1%
                }
                if (pColCalc->_xMax * iDiv > iP * iMul)
                {
                    iMul = pColCalc->_xMax;
                    iDiv = iP;
                }

                iPercentMin += pColCalc->_xMin;
            }
            else
            {
                iUserMax += pColCalc->_xMax;
                iUserMin += pColCalc->_xMin;
            }
        }
        else
        {
            Assert (pColCalc->_xMax >= 0 && pColCalc->_xMin >=0 );
            iMax += pColCalc->_xMax;
            iMin += pColCalc->_xMin;
        }
    }

    // iP is what remained left from the 100%
    iP = 100 - iPercent;
    Assert (iP >= 0);

    // Table is always horizontal => physical width
    CWidthUnitValue uvWidth = GetFirstBranch()->GetFancyFormat()->GetWidth();

    //
    // If COLS was specified and there one or more columns percentage sized columns,
    // then default the table width to 100%
    // (When all columns are of fixed size, their sizes take precedence over any
    //  explicitly specified table width. Additionally, normal table sizing should
    //  be used if the only non-fixed size columns are those outside the range
    //  specified by COLS.)
    //

    if (!uvWidth.IsSpecified() && _cSizedCols > iPercentColumn)
    {
        uvWidth.SetPercent(100);
    }

    //
    // NS/IE compatibility, any value <= 0 is treated as <not present>
    //

    if (uvWidth.GetUnitValue() <= 0)
    {
        uvWidth.SetNull();
    }

    //
    // if uvWidth is set we use that value except when we are being called to
    // calculate for min/max and the width is percent since the parent information
    // is bogus then
    //
    if (uvWidth.IsSpecified() && !(uvWidth.IsSpecifiedInPercent() &&
        (  ptci->_smMode == SIZEMODE_MMWIDTH
        || ptci->_smMode == SIZEMODE_MINWIDTH
        )))
    {
        xTableWidth = uvWidth.GetPercentSpecifiedWidthInPixel(ptci, pTable, pTableLayout->_sizeParent.cx);
        if (xTableWidth < _sizeMin.cx)
        {
            xTableWidth = _sizeMin.cx;
        }
        // if we want to limit the tabble width, then
        //        if (xTableWidth > MAX_TABLE_WIDTH)
        //        {
        //            xTableWidth = MAX_TABLE_WIDTH;
        //        }
    }
    else
    {
        //
        // pTableLayout->_sizeParent.cx can be set to 0 in the following cases:
        //     1) user specified 0 as width/height for the parent element,
        //        in this case ptci->_sizeParentForVert.cx is also set to 0.
        //     2) table is sized in NATURALMIN mode. In this mode 
        //        _sizeParent.cx is set to 0 inside CTableLayout::CalculateLayout, 
        //        but we keep original value in _sizeParentForVert.cx, so use it 
        //        in column width calculations.
        //     3) table is contained in something with a specified width of 0 (or 1!)
        // It will prevent to size table differently in case of NATURALMIN and NATURAL mode.
        //
        LONG lParentWidth = pTableLayout->_sizeParent.cx;
        if (lParentWidth == 0 && ptci->_sizeParent.cx == 0)
            lParentWidth = ptci->_sizeParentForVert.cx;

        // if user width is not given back calculate it from the max width/% ratio
        if (iPercent)
        {
            // check if the remaining user and normal columns are requiring bigger ratio
            if (iP)
            {
                if ((iUserMax + iMax) * iDiv> iP * iMul)
                {
                    iMul = iUserMax + iMax;
                    iDiv = iP;
                }
            }

            //
            // if there is percentage left or there are only percentage columns use the ratio
            // to back-calculate the table width
            //
            if (iP || (iUserMax + iMax) == 0)
            {
                // iP > 0 means the total percent specified columns = 100 - iP

                // TODO (112603, olego) (bug #108425).
                // Problem,
                // Given:   iMul = INT_MAX/2;       // came from pColCalc->_xMax
                //          iDiv = 50;              // percent value
                // Find:    xTableWidth using equation below.
                //
                // xTableWidth = MulDivQuick(100, iMul, iDiv) + xTablePadding;
                //
                // Answer:  due to numerical overflow xTableWidth becomes negative and 
                //          subsequent check (see code below) will return wrong result, 
                //          (found in hi-res mode). 
                //
                // I don't think this is a great idea to mix floating point with integer 
                // arithmetic so it's needed to be improved.

                // xTableWidth = MulDivQuick(100, iMul, iDiv) + xTablePadding;
                double dTableWidth = double(iMul) 
                                   * 100.0 
                                   / double(iDiv) 
                                   + double(xTablePadding); 

                if (dTableWidth > double(INT_MAX/2)) 
                {
                    xTableWidth = INT_MAX/2;
                }
                else 
                {
                    xTableWidth = IntNear(dTableWidth);
                }

                if (xTableWidth > lParentWidth)
                {
                    xTableWidth = lParentWidth;
                }
            }
            else
            {
                // otherwise use parent width
                xTableWidth = lParentWidth;
            }
            if (xTableWidth < _sizeMin.cx)
            {
                xTableWidth = _sizeMin.cx;
            }
        }
        else
        {
            if (_sizeMax.cx < lParentWidth)
            {
                // use max value if that smaller the parent size
                xTableWidth = _sizeMax.cx;
            }
            else if (_sizeMin.cx > lParentWidth)
            {
                // have to use min if that is bigger the parent
                xTableWidth = _sizeMin.cx;
            }
            else
            {
                // use parent between min and max
                xTableWidth = lParentWidth;
            }
        }
    }

    // if there are no columns, set proposed and return
    if (!cCols)
    {
        psize->cx = xTableWidth;
        return;
    }

    //
    // If all columns are of fixed size, set the table width to the sum and return
    //

    if (_fCols &&
        (!uvWidth.IsSpecified() || (xTableWidth <= (iUserMin + iMin + xTablePadding))))
    {
        Assert(iPercent == 0);
        Assert(iMax == iMin);
        Assert(iUserMax == iUserMin);
        // set the width of the columns
        for (cC = cCols, pColCalc = _aryColCalcs;
            cC > 0;
            cC--, pColCalc++)
        {
            pColCalc->_xWidth = pColCalc->_xMin;
        }
        psize->cx = iUserMin + iMin + xTablePadding;
        return;
    }

    // subtract padding width which contains border and cellspacing
    if (xTableWidth >= xTablePadding)
    {
        xTableWidth -= xTablePadding;
    }

    if (iMax + iUserMax)
    {
        // cache width remaining for normal and user columns over percent columns (iWidth)
        iWidth = MulDivQuick(iP, xTableWidth, 100);
        if (iWidth < iUserMin + iMin)
        {
            iWidth = iUserMin + iMin;
        }
        if (iWidth > xTableWidth - iPercentMin)
        {
            iWidth = xTableWidth - iPercentMin;
        }
    }
    else
    {
        // all widths is for percent columns
        iWidth = 0;
    }

    //
    // distribute remaining width amongst normal and user columns
    // first try to use max width for user columns and normal columns
    //
    if (iUserMax)
    {
        iUser = iUserMax;
        if (iUser > iWidth)
        {
            iUser = iWidth;
        }
        if (iMax)
        {
            iNormal = iMin;
            if (iUser + iNormal <= iWidth)
            {
                iNormal = iWidth - iUser;
            }
            else
            {
                iUser = iUserMin;
                if (iUser + iNormal <= iWidth)
                {
                    iUser = iWidth - iNormal;
                }
            }
        }
        else
        {
            iNormal = 0;
            if (iUser < iWidth)
            {
                iUser = iWidth;
            }
        }
    }
    else
    {
        iUser = 0;
        if (iMax)
        {
            iNormal = iMin;
            if (iNormal < iWidth)
            {
                iNormal = iWidth;
            }
        }
        else
        {
            iNormal = 0;
        }
    }

    if (iNormal > iMax)
    {
        fUseMaxMax = TRUE;
    }
    else if (iNormal == iMax)
    {
        fUseMax = TRUE;
    }
    else if (iNormal == iMin)
    {
        fUseMin = TRUE;
    }
    else if (iNormal < iMax)
    {
        fSubtract = TRUE;
    }

    if (iUser > iUserMax)
    {
        fUseUserMaxMax = TRUE;
    }
    else if (iUser == iUserMax)
    {
        fUseUserMax = TRUE;
    }
    else if (iUser == iUserMin)
    {
        fUseUserMin = TRUE;
    }
    else if (iUser < iUserMax)
    {
        fUserSubtract = TRUE;
    }

    // calculate real percentage of percent columns in the table now using the final widths
    iP = xTableWidth ? MulDivQuick(100, xTableWidth - iUser - iNormal, xTableWidth)
                     : 0;

    // start with the padding
    psize->cx = xTablePadding;

    // remember how many columns can be adjusted
    cAdjust = 0;

    //
    // now go and calculate column widths by distributing the extra width over
    // the min width or subtracting the extra width from max
    //
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
            continue;

        if (!pColCalc->IsWidthSpecified())
        {
            // adjust normal column by adding to min or subtracting from max
            pColCalc->_xWidth =
                fSubtract ?
                    pColCalc->_xMax - MulDivQuick(pColCalc->_xMax - pColCalc->_xMin,
                        iMax - iNormal,
                        iMax - iMin) :
                fUseMaxMax?
                    pColCalc->_xMax + MulDivQuick(pColCalc->_xMax, iNormal - iMax, iMax) :
                fUseMax ?
                    pColCalc->_xMax :
                fUseMin ?
                    pColCalc->_xMin :
                iMax ?
                    pColCalc->_xMin +
                    MulDivQuick(pColCalc->_xMax, iNormal - iMin, iMax) :
                    0;
        }
        else if (pColCalc->IsWidthSpecifiedInPercent())
        {
            //
            // if percent first calculate the width from the percent
            //
            iWidth = iPercent ?
                MulDivQuick(xTableWidth,
                    MulDivQuick(iP, pColCalc->GetPercentWidth(), iPercent),
                    100) :
                0;
            //
            // make sure it is over the min width
            //
            iWidth -= pColCalc->_xMin;
            if (iWidth < 0)
            {
                iWidth = 0;
            }
            pColCalc->_xWidth = pColCalc->_xMin + iWidth;
        }
        else
        {
            // adjust user column by adding to min or subtracting from max
            pColCalc->_xWidth =
                fUserSubtract   // table needs to be (iUserMax - iUser) pixels shorter, so subtract pixels
                                // from columns proportionally to (pColCalc->_xMax - pColCalc->_xMin)
                    ? pColCalc->_xMax - MulDivQuick(pColCalc->_xMax - pColCalc->_xMin,
                                                    iUserMax - iUser,
                                                    iUserMax - iUserMin)
                    :
                fUseUserMaxMax
                    ? pColCalc->_xMax + MulDivQuick(pColCalc->_xMax, iUser - iUserMax, iUserMax)
                    :
                fUseUserMax
                    ? pColCalc->_xMax
                    :
                fUseUserMin
                    ? pColCalc->_xMin
                    :
                iUserMax
                    ? pColCalc->_xMin + MulDivQuick(pColCalc->_xMax,
                                                    iUser - iUserMin,
                                                    iUserMax)
                    : 0;
        }
        Assert(pColCalc->_xWidth >= pColCalc->_xMin);

        // we can adjust this col since it is more than min width
        if (pColCalc->_xWidth > pColCalc->_xMin)
        {
            cAdjust++;
        }
        psize->cx += pColCalc->_xWidth;
    }

    // this is used to keep track of extra adjustment couldn't be applied
    iExtra = 0;

    // distribute rounding error

#if DBG == 1
    cLoop = 0;
#endif

    while (xTableWidth && (iWidth = xTableWidth + xTablePadding - psize->cx) != 0)
    {
        fUseAllColumns = FALSE;
        if (iWidth > 0)
        {
            if (cAdjust == 0)
            {
                // use all the cols if we add...
                cAdjust = cCols - cDisplayNoneCols;
                if (!cAdjust)
                    break;
                fUseAllColumns = TRUE;
            }
        }

        // the above protection for cAdjust doesn't happen if iWidth is neg.
        if (cAdjust==0)
            break;

        iMul = iWidth / cAdjust;                    // iMul is the adjustment for every column
        iDiv = iWidth % cAdjust;                    // left-over adjustment for all the columns
        iDelta = iDiv > 0 ? 1 : iDiv < 0 ? -1 : 0;  // is the +/- 1 pixel that is added to every column
        iExtra = 0;

        // start with the padding
        psize->cx = xTablePadding;

        // recalc cAdjust again
        cAdjust = 0;

        for (cC = cCols, pColCalc = _aryColCalcs;
            cC > 0;
            cC--, pColCalc++)
        {
            if (pColCalc->IsDisplayNone())
                continue;

            if (pColCalc->_xWidth > pColCalc->_xMin || (iWidth > 0 && fUseAllColumns))
            {
                pColCalc->_xWidth += iMul + iDelta + iExtra;
                // if we went below min we have to adjust back...

                if (pColCalc->_xWidth <= pColCalc->_xMin)
                {
                    iExtra = pColCalc->_xWidth - pColCalc->_xMin;
                    pColCalc->_xWidth = pColCalc->_xMin;
                }
                else
                {
                    iExtra = 0;
                    cAdjust++;
                }

                iDiv -= iDelta;
                if (!iDiv)
                {
                    iDelta = 0; // now left-over for every column is 0
                }
            }
            psize->cx += pColCalc->_xWidth;
        }
#if DBG == 1
        cLoop++;
        Assert(cLoop < 5);
#endif
    }

    Assert(!xTableWidth || (xTableWidth + xTablePadding == psize->cx) || (cCols == cDisplayNoneCols));
    PerfLog(tagTableColumn, this, "-CalculateColumns");
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateHeadersOrFootersRows
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
void 
CTableLayoutBlock::CalculateHeadersOrFootersRows(
    BOOL                fHeaders,
    CTableCalcInfo *    ptci, 
    CSize *             psize, 
    CDispContainer *    pDispNodeTableInner)
{
    Assert(ptci);
    Assert(psize);

    CTableLayout *  pTableLayoutCache = ptci->TableLayoutCache();
    CTableRow *     pRow;
    CLayout *       pLayoutSiblingCell = NULL;
    int             iR, cR;
    BOOL            fRedoMinMax;

    Assert(pTableLayoutCache);

    cR = fHeaders ? pTableLayoutCache->GetHeaderRows() : pTableLayoutCache->GetFooterRows();

    if (cR > 0)
    {
        for (iR = fHeaders ? pTableLayoutCache->GetFirstHeaderRow() : pTableLayoutCache->GetFirstFooterRow(); 
            cR > 0; 
            cR--, iR = pTableLayoutCache->GetNextRow(iR))
        {
            pRow = pTableLayoutCache->_aryRows[iR];

            Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

            ptci->_pRow = pRow;
            ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(ptci->GetLayoutContext());
            ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();

            fRedoMinMax = pTableLayoutCache->CalculateRow(ptci, psize, &pLayoutSiblingCell, pDispNodeTableInner);
            Assert(!fRedoMinMax);

            if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                continue;

            //  if table has percent height the real row height may be bigger when calculated. 
            //  do correnction using compatible layout
            int cyHeightCompat = ((CTableRowLayoutBlock *)pRow->GetUpdatedLayout(GetContentMarkup()->GetCompatibleLayoutContext()))->_yHeight;
            if (ptci->_pRowLayout->_yHeight < cyHeightCompat)
            {
                Assert(ptci->_pRowLayout->PercentHeight());
                ptci->_pRowLayout->_yHeight = cyHeightCompat;
            }

            psize->cy += ptci->_pRowLayout->_yHeight + pTableLayoutCache->_yCellSpacing;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CalculateLayout
//
//  Synopsis:   Calculate cell layout in the table
//
//--------------------------------------------------------------------------

void
CTableLayoutBlock::CalculateLayout(
    CTableCalcInfo * ptci,
    CSize *     psize,
    BOOL        fWidthChanged,
    BOOL        fHeightChanged)
{
    // Should be here only if print view
    Assert(!Table()->HasLayoutPtr() && Table()->HasLayoutAry());

    // Should have layout context
    Assert(ptci->GetLayoutContext());

    CTable         * pTable = ptci->Table();
    CTableLayout   * pTableLayoutCache = ptci->TableLayoutCache();

    // This should not be incremental recalc :
    Assert(fWidthChanged || fHeightChanged || IsSizeThis() || (!pTableLayoutCache->IsFixedBehaviour() && !pTableLayoutCache->IsRepeating()));

    SIZEMODE         smMode = ptci->_smMode;
    CSize            sizeTable;
    CTableCaption ** ppCaption;
    CDispContainer * pDispNodeTableOuter;
    CDispContainer * pDispNodeTableInner;
    CLayout        * pLayoutSiblingCell;
    int              cR, cRowsCalced, iR, iRowFirst;
    int              cC, iC;
    BOOL             fRedoMinMax    = FALSE;
    CTableRow      * pRow = NULL;
    int              cRows = pTableLayoutCache->GetRows();
    BOOL             fForceMinMax    = fWidthChanged && (pTableLayoutCache->_fHavePercentageInset || pTableLayoutCache->_fForceMinMaxOnResize);
    int              yTopInvalidRegion = 0;
    int              yCellSpacing;
    CLayoutBreak *          pLayoutBreak;
    CTableLayoutBreak *     pTableBreakStart = NULL; 
    CLayoutContext *        pLayoutContext = ptci->GetLayoutContext();
    BOOL                    fViewChain = (pLayoutContext->ViewChain() != NULL && ElementCanBeBroken());
    BOOL                    fCompatCalc = !fViewChain && pLayoutContext == GetContentMarkup()->GetCompatibleLayoutContext();
    int                     aiRowStart[TABLE_BREAKTYPE_MAX]; 
    int                     iRowBreak = -1;
    int                     yFromTop = 0;
    TABLE_BREAKTYPE         breakTypePrev = TABLE_BREAKTYPE_UNDEFINED; 
    TABLE_BREAKTYPE         breakTypeCurr = TABLE_BREAKTYPE_UNDEFINED; 
    LAYOUT_OVERFLOWTYPE     overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
    LAYOUT_OVERFLOWTYPE     overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
    BOOL                    fRepeatHeaders = FALSE;
    BOOL                    fRepeatFooters = FALSE;
    BOOL                    fDoNotPositionRows = FALSE;
    BOOL                    fNoCompatPass = !pTableLayoutCache->_aryColCalcs.Size();
    CPeerHolder           * pPH = ElementOwner()->GetLayoutPeerHolder();

    TraceTagEx((tagTableLayoutBlock, TAG_NONAME|TAG_INDENT,
                "(CTableLayoutBlock: CalculateLayout %S pass - this=0x%x, e=[0x%x,%d]",
                fCompatCalc ? TEXT("COMPAT") : TEXT("BLOCK"), this, ElementOwner(), ElementOwner()->SN() ));

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    Assert(pTableLayoutCache->CanRecalc());

    Assert(ptci->_yConsumed == 0 
        && "Improper CCalcInfo members handling ???");

#ifdef  TABLE_PERF
    ::StartCAP();
#endif

    PerfLog(tagTableLayout, this, "+CalculateLayout");

    if (!pTableLayoutCache->HasCaptions() && !cRows) // if the table is empty
    {
        pTableLayoutCache->_sizeMax =  g_Zero.size;
        pTableLayoutCache->_sizeMin =  g_Zero.size;
        *psize   =  g_Zero.size;
        sizeTable = g_Zero.size;
        pTableLayoutCache->_fZeroWidth = TRUE;
    }
    else
    {
        iRowFirst = -1;
        cRowsCalced = 0;

        aiRowStart[TABLE_BREAKTYPE_TCS]            = 0;
        aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS]    = 0;
        aiRowStart[TABLE_BREAKTYPE_ROWS]           = -1;
        aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS] = 0;
        _fLayoutBreakType = LAYOUT_BREAKTYPE_LAYOUTCOMPLETE;

        // retrieve break info 
        if (fViewChain)
        {
            pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);

            if (pLayoutBreak)
            {
                if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE)
                {
                    pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                    if (pLayoutBreak)
                    {
                        pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
                        pLayoutContext->SetLayoutBreak(ElementOwner(), pLayoutBreak);
                    }
                    GetSize(psize); // return original size (bug fix #71810)
                    return;
                }
                else 
                {
                    Assert(pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);

                    pTableBreakStart = DYNCAST(CTableLayoutBreak, pLayoutBreak);
                    breakTypePrev    = pTableBreakStart->TableBreakType();
                    overflowTypePrev = pTableBreakStart->OverflowType();
                    aiRowStart[breakTypePrev] = pTableBreakStart->Row();
                    fRepeatHeaders   = pTableBreakStart->RepeatHeaders();
                    fRepeatFooters   = pTableBreakStart->RepeatFooters();
                }

                TraceTagEx((tagTableLayoutBlock, TAG_NONAME,
                            "* CTableLayoutBlock: Got starting break info : %d row of %S",
                            pTableBreakStart->Row(), 
                            (breakTypePrev == TABLE_BREAKTYPE_UNDEFINED)
                            ? TEXT("Undefined")
                            : (breakTypePrev == TABLE_BREAKTYPE_TCS) 
                                ? TEXT("Tc's")
                                : (breakTypePrev == TABLE_BREAKTYPE_TOPCAPTIONS) 
                                    ? TEXT("Top captions")
                                    : (breakTypePrev == TABLE_BREAKTYPE_ROWS) 
                                        ? TEXT("Rows") 
                                        : (breakTypePrev == TABLE_BREAKTYPE_BOTTOMCAPTIONS) 
                                            ? TEXT("Bottom captions")
                                            : TEXT("[ERROR : prohibited value !!!]"))
                            
                           );
            }
            else 
            {
                //  retrieve values for repeated headers / footers 
                if (pTableLayoutCache->GetHeaderRows())
                {
                    CTreeNode * pNode = pTableLayoutCache->_pHead->GetFirstBranch();
                    const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;
                    fRepeatHeaders = (pFF != NULL && pFF->_bDisplay == styleDisplayTableHeaderGroup);
                }

                if (pTableLayoutCache->GetFooterRows())
                {
                    CTreeNode * pNode = pTableLayoutCache->_pFoot->GetFirstBranch();
                    const CFancyFormat * pFF = pNode ? pNode->GetFancyFormat() : NULL;
                    fRepeatFooters = (pFF != NULL && pFF->_bDisplay == styleDisplayTableFooterGroup);
                }

                TraceTagEx((tagTableLayoutBlock, TAG_NONAME,
                            "* CTableLayoutBlock: Got starting break info : from the beginning") );
            }
        }

        ptci->_fTableHasUserHeight = !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull();

        // reset perentage based rows
        pTableLayoutCache->_fHavePercentageRow = FALSE;

        // Create measurer.
        CLSMeasurer me;

        ptci->_pme = &me;

        //
        // Determine the cell widths/heights and row heights
        //

        do
        {
            //
            //  MIN MAX CALCULATION
            //  

            // calculate min/max only if that information is dirty or forced to do it
            // NOTE:   It would be better if tables, rows, and cells all individually tracked
            //         their min/max dirty state through a flag (as cells do now). This would
            //         allow CalculateMinMax to be more selective in the rows/cells it
            //         processed. (brendand)

            //  If this is view chain case we should have min max calc'ed in compatible calc phase
            //  but, if it wasn't done we better do it now to prevent crashes
            if (   (  !fViewChain
                    || fNoCompatPass)
                && (pTableLayoutCache->_sizeMin.cx <= 0 
                    ||  pTableLayoutCache->_sizeMax.cx <= 0 
                    || (ptci->_grfLayout & LAYOUT_FORCE) 
                    || fRedoMinMax 
                    || fForceMinMax))
            {
                TraceTag((tagTableCalc, "CTableLayout::CalculateLayout - calling CalculateMinMax (0x%x)", pTable));
                pTableLayoutCache->_fAlwaysMinMaxCells = pTableLayoutCache->_fAlwaysMinMaxCells || fRedoMinMax;
                pTableLayoutCache->CalculateMinMax(ptci, FALSE /* incremental min max*/);

                if (pTableLayoutCache->_sizeMin.cx < 0)
                {
                    return; // it means that we have failed incremental recalc, 
                            // because we have failed to load history
                }
            }

            Check(  pTableLayoutCache->IsFixed() 
                ||  (pTableLayoutCache->_sizeMin.cx != -1 && pTableLayoutCache->_sizeMax.cx != -1));

            pTableLayoutCache->_fForceMinMaxOnResize = FALSE;   // initialize to FALSE; (TRUE - means need to force min max on resize; bug #66432)

            //
            // Ensure display tree nodes exist
            // (Only do this the first time through the loop)
            //

            if (!fRedoMinMax)
            {
                EnsureTableDispNode(ptci, (ptci->_grfLayout & LAYOUT_FORCE));
            }

            pDispNodeTableOuter  = GetTableOuterDispNode();
            pDispNodeTableInner  = GetTableInnerDispNode();
            pLayoutSiblingCell = NULL;

            // Force is only needed during min/max calculations; or if there were no MinMax calc performed
            if (    !pTableLayoutCache->IsFixed() 
                // When cloning disp nodes need to make sure that all disp nodes are re-created 
                // thus forcing layout. 
                &&  !ptci->_fCloneDispNode   )
            {
                MtAdd( Mt(UsingFixedBehaviour3), 1, 0 );
                ptci->_grfLayout = (ptci->_grfLayout & ~LAYOUT_FORCE);
            }

            psize->cy = 0;

            //
            //  COLUMNs CALCULATION
            //  

            //  If this is view chain case we should have columns calc'ed in compatible calc phase
            if (   !fViewChain
                || fNoCompatPass)

            {
                psize->cx = 0;

                //
                // first calc columns and table width
                // the table layout is defined by the columns widths and row heights which in
                // turn will finalize the cell widths and heights
                //

                pTableLayoutCache->CalculateColumns(ptci, psize);
            }
            else
            {
                // restore width from cache _sizeIncremental
                psize->cx = pTableLayoutCache->_sizeIncremental.cx;
            }

            yCellSpacing = pTableLayoutCache->_yCellSpacing;

            CPoint  pt(0, 0);

            //
            //  TCs CALCULATION
            //  

            // do tc only if it is needed so
            if (breakTypePrev <= TABLE_BREAKTYPE_TCS) 
            {
                //
                // Size top CAPTIONs and TCs
                // NOTE: Position TCs on top of all CAPTIONs
                //

                ptci->_smMode = SIZEMODE_NATURAL;

                for (iC = aiRowStart[TABLE_BREAKTYPE_TCS], 
                        cC = pTableLayoutCache->_aryCaptions.Size(), 
                        ppCaption = &pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_TCS]]; 
                    iC < cC;
                    iC++, ppCaption++)
                {
                    if ((*ppCaption)->Tag() == ETAG_TC)
                    {
                        Assert((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP);
                        ptci->_pRowLayout = NULL;
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt, fViewChain);

                        Assert(psize->cy == pt.y);

                        if (fViewChain)
                        {
                            if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                            {
                                breakTypeCurr = TABLE_BREAKTYPE_TCS; 
                                iRowBreak = iC; 

                                if (!ptci->_fLayoutOverflow)
                                {
                                    //  restore hieght only if the whole row doesn't fit
                                    pt.y = psize->cy = ptci->_yConsumed; 
                                }
                                //  save width for next time calculations 
                                pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                                break;
                            }
                            //  save height of the columns which fit 
                            ptci->_yConsumed = pt.y;
                        }
                    }
                }

                ptci->_smMode = smMode;
            }

            //
            //  TOP CAPTIONs CALCULATION
            //  

            if (breakTypePrev <= TABLE_BREAKTYPE_TOPCAPTIONS && breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED) 
            {
                ptci->_smMode = SIZEMODE_NATURAL;

                for (iC = aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS], 
                        cC = pTableLayoutCache->_aryCaptions.Size(), 
                        ppCaption = &pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_TOPCAPTIONS]];
                     iC < cC;
                     iC++, ppCaption++)
                {
                    if (    (*ppCaption)->Tag() != ETAG_TC
                        &&  (*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                    {
                        ptci->_pRowLayout = NULL;
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt, fViewChain);

                        Assert(psize->cy == pt.y);

                        if (fViewChain)
                        {

                            if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                            {
                                breakTypeCurr = TABLE_BREAKTYPE_TOPCAPTIONS;
                                iRowBreak = iC; 

                                if (!ptci->_fLayoutOverflow)
                                {
                                    //  restore hieght only if the whole row doesn't fit
                                    pt.y = psize->cy = ptci->_yConsumed; 
                                }
                                //  save width for next time calculations 
                                pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                                break;
                            }
                            //  save height of the columns which fit 
                            ptci->_yConsumed = pt.y;
                        }
                    }
                }

                ptci->_smMode = smMode;
            }

            // set _sizeParent in ptci
            ptci->SizeToParent(psize);

            // remember table top 
            _yTableTop = psize->cy;

            //
            //  ROWs CALCULATION
            //  

            //
            // Initialize the table height to just below the captions and top border
            //
            psize->cy += pTableLayoutCache->_aiBorderWidths[SIDE_TOP] + yCellSpacing;

            if (fViewChain)
            {
                ptci->_yConsumed = psize->cy;
            }

            Assert(pTableLayoutCache->AssertTableLayoutCacheCurrent()); 

            //
            // Calculate natural cell/row sizes
            // NOTE: Since the COLS attribute assigns column widths without examining every cell
            //       of every row, it is possible that a cell will contain content which cannot
            //       fit within the assigned size. If that occurs, all rows/cells before that
            //       point must be sized again to the larger width to prevent overflow.
            //

            if (breakTypePrev <= TABLE_BREAKTYPE_ROWS && breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED)
            {
                Assert(!fViewChain
                    || (   pTableLayoutCache->_cyHeaderHeight != -1 
                        && pTableLayoutCache->_cyHeaderHeight != -1));

                Assert(!fRepeatHeaders 
                    || aiRowStart[TABLE_BREAKTYPE_ROWS] == -1
                    || !pTableLayoutCache->IsHeaderRow(aiRowStart[TABLE_BREAKTYPE_ROWS]));

                Assert(!fRepeatFooters
                    || aiRowStart[TABLE_BREAKTYPE_ROWS] == -1 
                    || !pTableLayoutCache->IsFooterRow(aiRowStart[TABLE_BREAKTYPE_ROWS]));

                if (fViewChain)
                {
                    if (!fRepeatHeaders)
                    {
                        pTableLayoutCache->_cyHeaderHeight = 0;
                    }

                    if (!fRepeatFooters)
                    {
                        pTableLayoutCache->_cyFooterHeight = 0;
                    }

                    //  recognize emergency case :- there is no enough from for our headers
                    if (   (fRepeatHeaders || fRepeatFooters)
                        && (ptci->_cyAvail 
                        // TODO (112605, olego) : current way to determind if we need to push 
                        // to the next page if headers and / or footers are repeated is not 
                        // consistent. We need to think about more reasonable value (or logic) 
                        // instead of just using yCellSpacing * 2. It will probably give awful 
                        // reasult if yCellSpacing is zero or too big. 
                        - (ptci->_yConsumed + yCellSpacing * 2)
                        - pTableLayoutCache->_cyHeaderHeight
                        - pTableLayoutCache->_cyFooterHeight) <= 0)
                    {
                        // if this is the first page - break to the next page 
                        if (breakTypePrev < TABLE_BREAKTYPE_ROWS)
                        {
                            breakTypeCurr = TABLE_BREAKTYPE_ROWS;
                            fDoNotPositionRows = TRUE;
                            break;
                        }
                        else 
                        {
                            Assert(breakTypePrev == TABLE_BREAKTYPE_ROWS);

                            // this is at least second page and there is no space 
                            // for headers and/or footers - do not respect CSS attributes 
                            fRepeatHeaders = 
                            fRepeatFooters = FALSE;

                            pTableLayoutCache->_cyHeaderHeight = 
                            pTableLayoutCache->_cyFooterHeight = 0;
                        }
                    }
                }

                iRowFirst = iR = aiRowStart[TABLE_BREAKTYPE_ROWS] != -1 
                    ? aiRowStart[TABLE_BREAKTYPE_ROWS] 
                        : pTableLayoutCache->GetFirstRow(fRepeatHeaders, fRepeatFooters);

                cR = (  cRows 
                    &&  iR < pTableLayoutCache->GetRows() 
                    &&  (cRows - (fRepeatHeaders ? pTableLayoutCache->GetHeaderRows() : 0) 
                               - (fRepeatFooters ? pTableLayoutCache->GetFooterRows() : 0) > 0) )
                        ? pTableLayoutCache->GetRemainingRows(iR, fRepeatHeaders, fRepeatFooters) : 0;

                //  NOTE : every time CalculateHeadersOrFootersRows() produce the same layout 
                //  it needs more omptimization here. 
                if (fRepeatHeaders)
                {
                    //  Should get here only if view chain
                    Assert(fViewChain);
                    CalculateHeadersOrFootersRows(TRUE, ptci, psize, pDispNodeTableInner);
                }

                if (fViewChain)
                {
                    ptci->_yConsumed =  psize->cy 
                                    +   pTableLayoutCache->_cyFooterHeight 
                                    +   yCellSpacing 
                                    +   pTableLayoutCache->_aiBorderWidths[SIDE_BOTTOM];
                }

                for (cRowsCalced = 0; cR > 0; cRowsCalced++, cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);

                    if (fViewChain) 
                    {
                        //  page-break-before support
                        if (    pTableLayoutCache->RowHasPageBreakBefore(ptci) 
                            && (   breakTypePrev    != TABLE_BREAKTYPE_ROWS
                                || iR != iRowFirst) 
                        )
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKBEFORE;
                            iRowBreak        = iR;
                        
                            Assert(iRowBreak <= pTableLayoutCache->GetLastRow());
                        
                            break;
                        }
                        //  if there is no available height for the row
                        else if (   ptci->_cyAvail <= ptci->_yConsumed
                                // do not break if the first row AND no other content 
                                // on the page (preventing infinite pagination) 
                                &&  (iR != iRowFirst || ptci->_fHasContent) )   
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW;
                            iRowBreak        = iR;

                            break;
                        }
                    }

                    fRedoMinMax = pTableLayoutCache->CalculateRow(ptci, psize, &pLayoutSiblingCell, 
                                                pDispNodeTableInner, 
                                                fViewChain && ptci->_pFFRow->_bPositionType != stylePositionabsolute, 
                                                fViewChain && iR == iRowFirst, 
                                                (fViewChain && iR == iRowFirst && pTableBreakStart) 
                                                ? pTableBreakStart->YFromTop(iR) : 0)
                                &&  !pTableLayoutCache->_fAlwaysMinMaxCells;

                    // stop calculating rows when need to redo MinMax (since the cell in the row was too large to fit).
                    if (fRedoMinMax)
                    {
                        break;
                    }

                    Assert (ptci->_pRow == pRow);

                    if ((pRow->IsDisplayNone() || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                        continue;

                    if (fViewChain)
                    {
                        //  if table has percent height the real row height may be bigger when calculated. 
                        //  do correnction using compatible layout
                        CTableRowLayoutBlock *pRowLayoutCompat;
                        LAYOUT_OVERFLOWTYPE   overflowType;

                        pRowLayoutCompat = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(GetContentMarkup()->GetCompatibleLayoutContext());
                        Assert(pRowLayoutCompat);

                        int cyHeightCompat = pRowLayoutCompat->_yHeight - 
                            (pTableBreakStart ? pTableBreakStart->YFromTop(iR) : 0);

                        if (ptci->_pRowLayout->_yHeight < cyHeightCompat)
                        {
                            int cyAvail = ptci->_cyAvail - ptci->_yConsumed;

                            CheckSz(ptci->_pRowLayout->_yHeight <= min(cyHeightCompat, cyAvail), 
                                "Descreasing the row height ???");

                            if (cyAvail < cyHeightCompat)
                            {
                                ptci->_pRowLayout->_yHeight = cyAvail;

                                // if we use calculated available height to set row height this means that 
                                // the row doesn't fit into the current page and layout overflow flag should be raised. 
                                // (in most cases _fLayoutOverflow is already set by table cell calc size code ,
                                // but for example if table cell has little content and big height value specified 
                                // content fit and _fLayoutOverflow will be FALSE, we still need to break though - bug #106158).
                                if (pRow->RowLayoutCache()->IsHeightSpecified()) 
                                {
                                    ptci->_fLayoutOverflow = TRUE;
                                }
                            }
                            else 
                            {
                                ptci->_pRowLayout->_yHeight = cyHeightCompat;
                            }

                            if (ptci->_pFFRow->_bPositionType == stylePositionrelative) 
                            {
                                //  if the row is relative update its disp node size.
                                CDispNode *pDispNode = ptci->_pRowLayout->GetElementDispNode();
                                Assert(pDispNode);

                                if (pDispNode)
                                {
                                    CSize size = pDispNode->GetSize();
                                    size.cy = ptci->_pRowLayout->_yHeight + yCellSpacing + yCellSpacing;
                                    pDispNode->SetSize(size, NULL, FALSE);
                                }
                            }
                        }

                        psize->cy        += ptci->_pRowLayout->_yHeight;
                        ptci->_yConsumed += ptci->_pRowLayout->_yHeight;

                        if (
                            // overflow condition
                                (   overflowType = LAYOUT_OVERFLOWTYPE_OVERFLOW, 
                                    ptci->_fLayoutOverflow 
                                || (ptci->_cyAvail <= ptci->_yConsumed)) 
                            // page-break-after support 
                            || (    overflowType = LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER, 
                                    pTableLayoutCache->RowHasPageBreakAfter(ptci)))
                        {
                            breakTypeCurr    = TABLE_BREAKTYPE_ROWS;
                            overflowTypeCurr = overflowType;
                            iRowBreak        = iR;

                            yFromTop = ptci->_pRowLayout->_yHeight + (pTableBreakStart ? pTableBreakStart->YFromTop(iR) : 0);

                            if (!ptci->_fLayoutOverflow)
                            {
                                if (cR == 1)
                                {
                                    // if this is the last row to calc 
                                    // clear the break 
                                    breakTypeCurr    = TABLE_BREAKTYPE_UNDEFINED; 
                                    overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW; 
                                    iRowBreak        = -1; 
                                    yFromTop         = 0;
                                }
                                else 
                                {
                                    iRowBreak        = pTableLayoutCache->GetNextRow(iR);
                                    yFromTop         = 0;
                                }
                            }

                            Assert(iRowBreak < pTableLayoutCache->GetRows() && 
                                "Wrong break conditions !");

                            cRowsCalced++;
                            break;
                        }

                        psize->cy        += yCellSpacing;
                        ptci->_yConsumed += yCellSpacing;

                    }
                    else 
                    {
                        psize->cy += ptci->_pRowLayout->_yHeight + yCellSpacing;
                    }
                }

                //  NOTE : every time CalculateHeadersOrFootersRows() produce the same layout 
                //  it needs more omptimization here. 
                if (fRepeatFooters)
                {
                    //  Should get here only if view chain
                    Assert(fViewChain);
                    CalculateHeadersOrFootersRows(FALSE, ptci, psize, pDispNodeTableInner);
                }
            }

            AssertSz(!fRedoMinMax || fCompatCalc,
                "Redo mix max calculation in print view should only occur during compat calc.");

            //
            // If any cells proved too large for the pre-determined size,
            // force a min/max recalculation
            // NOTE: This should only occur when the COLS attribute has been specified
            //

            Assert(!fRedoMinMax || pTableLayoutCache->_cSizedCols || ptci->_fTableContainsCols);

        //
        // If a cell within a row returned a width greater than its minimum,
        // force a min/max pass over all cells (if not previously forced)
        // (When COLS is specified, not all cells are min/max'd - If the page author
        //  included content which does not fit in the specified width, this path
        //  is taken to correct the table)
        //

        } while (fRedoMinMax);

        pTableLayoutCache->_sizeIncremental = *psize;

        // set the positions of all cells
        if (   !fDoNotPositionRows 
            && breakTypePrev <= TABLE_BREAKTYPE_ROWS 
            && breakTypeCurr != TABLE_BREAKTYPE_TCS 
            && breakTypeCurr != TABLE_BREAKTYPE_TOPCAPTIONS)
        {
            if (fRepeatHeaders && (cR = pTableLayoutCache->GetHeaderRows()) > 0)
            {
                //  Should get here only if view chain
                Assert(fViewChain);

                for (iR = pTableLayoutCache->GetFirstHeaderRow(); 
                    cR > 0; 
                    cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    pTableLayoutCache->SetCellPositions(ptci, psize->cx);
                }
            }

            for (iR = iRowFirst, cR = cRowsCalced; 
                cR > 0; 
                cR--, iR = pTableLayoutCache->GetNextRow(iR))
            {
                pRow = pTableLayoutCache->_aryRows[iR];

                //  in print view we don't deal with these cases yet 
                Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                pTableLayoutCache->SetCellPositions(ptci, psize->cx, fViewChain && iR == iRowFirst, fViewChain && cR == 1);
            }

            if (fRepeatFooters && (cR = pTableLayoutCache->GetFooterRows()) > 0)
            {
                //  Should get here only if view chain
                Assert(fViewChain);

                for (iR = pTableLayoutCache->GetFirstFooterRow(); 
                    cR > 0; 
                    cR--, iR = pTableLayoutCache->GetNextRow(iR))
                {
                    pRow = pTableLayoutCache->_aryRows[iR];

                    //  in print view we don't deal with these cases yet 
                    Assert(pRow->_fCompleted && !pTableLayoutCache->IsGenerated(iR) && !pRow->_fNeedDataTransfer);

                    ptci->_pRow = pRow;
                    ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout(pLayoutContext);
                    ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                    pTableLayoutCache->SetCellPositions(ptci, psize->cx);
                }
            }
        }

        // adjust for table border

        psize->cy += pTableLayoutCache->_aiBorderWidths[SIDE_BOTTOM];

        // adjust table height if necessary (if view chain this should be done during compatible calc)
        if (!fViewChain)
        {
            if (    ElementOwner()->HasMarkupPtr() 
                &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                if (GetFirstBranch()->GetCharFormat()->_fUseUserHeight)
                {
                    pTableLayoutCache->CalculateRows(ptci, psize);
                }
            }
            else 
            {
                if (    !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull() 
                    ||  pTableLayoutCache->_fHavePercentageRow   )
                {
                    pTableLayoutCache->CalculateRows(ptci, psize);
                }
            }
        }

        // At this point rows are calc'ed so save headers / footers height if needed 
        if (fCompatCalc)
        {
            pTableLayoutCache->_cyHeaderHeight = 
            pTableLayoutCache->_cyFooterHeight = 0;

            for (iR = 0; iR < cRows; ++iR)
            {
                int *cyRows;

                if (pTableLayoutCache->IsHeaderRow(iR))
                {
                    cyRows = &(pTableLayoutCache->_cyHeaderHeight);
                }
                else if (pTableLayoutCache->IsFooterRow(iR))
                {
                    cyRows = &(pTableLayoutCache->_cyFooterHeight);
                }
                else 
                {
                    // headers / footers rows are first rows in the array, so as soon as current 
                    // row is body row we may stop.
                    break;
                }

                (*cyRows) += ((CTableRowLayoutBlock *)
                    ((pTableLayoutCache->_aryRows[iR])->GetUpdatedLayout(pLayoutContext)))->_yHeight + yCellSpacing;
            }
        }

        //
        // Save the size of the table (excluding CAPTIONs)
        //

        sizeTable.cx = psize->cx;
        sizeTable.cy = (breakTypeCurr == TABLE_BREAKTYPE_TCS 
            || breakTypeCurr == TABLE_BREAKTYPE_TOPCAPTIONS 
            || (breakTypeCurr == TABLE_BREAKTYPE_ROWS && fDoNotPositionRows)
            || breakTypePrev == TABLE_BREAKTYPE_BOTTOMCAPTIONS) ? 0
            : psize->cy - _yTableTop;

        //
        // Position the display node which holds the cells
        //

        if (_fHasCaptionDispNode)
        {
            pDispNodeTableOuter->SetPosition(CPoint(0, _yTableTop));
        }

        //
        // Size bottom CAPTIONs
        //

        if (breakTypeCurr == TABLE_BREAKTYPE_UNDEFINED)
        {
            CPoint          pt(0, psize->cy);
            BOOL            fInsertedBottomCaption = FALSE;
            CLayout *       pLayoutSiblingCaption = NULL;

            if (fViewChain)
            {
                ptci->_yConsumed = pt.y;
            }
            ptci->_smMode = SIZEMODE_NATURAL;

            for (iC = aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS], 
                    cC = pTableLayoutCache->_aryCaptions.Size(), 
                    ppCaption = &(pTableLayoutCache->_aryCaptions[aiRowStart[TABLE_BREAKTYPE_BOTTOMCAPTIONS]]);
                 iC < cC;
                 iC++, ppCaption++)
            {
                if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    Assert((*ppCaption)->Tag() != ETAG_TC);

                    ptci->_pRowLayout = NULL;

                    if (fViewChain && ptci->_cyAvail <= ptci->_yConsumed)
                    {
                        breakTypeCurr = TABLE_BREAKTYPE_BOTTOMCAPTIONS;
                        iRowBreak     = 0; 
                        break;
                    }

                    if (fInsertedBottomCaption)
                    {
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, *ppCaption, &pt, fViewChain);
                    }
                    else
                    {
                        pTableLayoutCache->SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, pDispNodeTableOuter, *ppCaption, &pt);
                        fInsertedBottomCaption = pLayoutSiblingCaption != NULL;
                    }

                    Assert(psize->cy == pt.y);

                    if (fViewChain)
                    {
                        if (ptci->_fLayoutOverflow || ptci->_cyAvail <= pt.y)
                        {
                            breakTypeCurr = TABLE_BREAKTYPE_BOTTOMCAPTIONS; 
                            iRowBreak = iC; 

                            if (!ptci->_fLayoutOverflow)
                            {
                                //  restore hieght only if the whole row doesn't fit
                                pt.y = psize->cy = ptci->_yConsumed; 
                            }
                            //  save width for next time calculations 
                            pTableLayoutCache->_sizeIncremental.cx = psize->cx;
                            break; 
                        }
                        ptci->_yConsumed = pt.y;
                    }
                }
            }
            ptci->_smMode = smMode;
        }

        if (pTableLayoutCache->_pAbsolutePositionCells)
        {
            int               cCells;
            CTableCell      **ppCell;
            CPoint          pt(0,0);
            int             yConsumedSafe = ptci->_yConsumed;

            ptci->_yConsumed = 0; // each layout should start with _yConsumed == 0 (#22575)

            for (cCells = pTableLayoutCache->_pAbsolutePositionCells->Size(), ppCell = *pTableLayoutCache->_pAbsolutePositionCells ;  
                cCells > 0; 
                cCells--, ppCell++)
            {
                pTableLayoutCache->CalcAbsolutePosCell(ptci, (*ppCell));
                (*ppCell)->ZChangeElement(0, &pt, pLayoutContext);
            }

            ptci->_yConsumed = yConsumedSafe;
        }

        if (fViewChain)
        {
            if (breakTypeCurr != TABLE_BREAKTYPE_UNDEFINED)
            {
                //  table has no more room to fill so put break info 
                pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, overflowTypeCurr);
                DYNCAST(CTableLayoutBreak, pLayoutBreak)->SetTableLayoutBreak(breakTypeCurr, 
                    iRowBreak, yFromTop, fRepeatHeaders, fRepeatFooters);
            }
            else
            {
                //  table fits entirely 
                pLayoutBreak = pLayoutContext->CreateBreakForLayout(this);
                pLayoutBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
            }

            if (pLayoutBreak)
            {
                pLayoutContext->SetLayoutBreak(ElementOwner(), pLayoutBreak);
                _fLayoutBreakType = pLayoutBreak->LayoutBreakType();
            }
        }
    }

    //
    // Size the display nodes
    //

    if (   pTableLayoutCache->_aryColCalcs.Size() == 0  // set the size to 0, if there is no real content
        && pTableLayoutCache->_aryCaptions.Size() == 0) // (there are no real cells nor captions)
    {
        sizeTable.cy = psize->cy = 0;  // NETSCAPE: doesn't add the border or spacing or height if the table is empty.
    }


    // at this point the size has been computed, so try to delegate 
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
    {
        POINT pt;
        CDispContainer *pDispNodeTableOuter = NULL;
        pt.x = pt.y = 0;

        DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, ptci, *psize, &pt, psize);

        // this will do table invalidation
        pTableLayoutCache->SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 

        pDispNodeTableOuter= pTableLayoutCache->GetTableOuterDispNode();
        if (   pDispNodeTableOuter
            && (pt.x !=0 || pt.y !=0))
        {
            CSize sizeInsetTemp(pt.x, pt.y);
            pDispNodeTableOuter->SetInset(sizeInsetTemp);
        }
    }
    else
    {
        // this will do table invalidation
        pTableLayoutCache->SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 
    }

    if (ElementOwner()->IsAbsolute())
    {
        ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
    }

    //
    // Make sure we have a display node to render cellborder if we need one
    // (only collapsed borders, rules or frame)
    //

    if (psize->cx || psize->cy)
    {
        pTableLayoutCache->EnsureTableBorderDispNode(ptci);
    }

#ifdef PERFMETER
    if (pTableLayoutCache->_fCalcedOnce)
    {
        MtAdd(Mt(CalculateLayout), +1, 0);
    }
#endif
    pTableLayoutCache->_fCalcedOnce = TRUE;

    PerfLog(tagTableLayout, this, "-CalculateLayout");

    TraceTagEx((tagTableLayoutBlock, TAG_NONAME|TAG_OUTDENT,
                ")CTableLayoutBlock: CalculateLayout %S pass - this=0x%x, e=[0x%x,%d]",
                fCompatCalc ? TEXT("COMPAT") : TEXT("BLOCK"), this, ElementOwner(), ElementOwner()->SN() ));

#ifdef  TABLE_PERF
    ::StopCAP();
#endif
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateLayout
//
//  Synopsis:   Calculate cell layout in the table
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateLayout(
    CTableCalcInfo * ptci,
    CSize *     psize,
    BOOL        fWidthChanged,
    BOOL        fHeightChanged)
{
    Assert(Table()->HasLayoutPtr() && !Table()->HasLayoutAry());

    SIZEMODE         smMode = ptci->_smMode;
    CSize            sizeTable;
    CTableCaption ** ppCaption;
    CDispContainer * pDispNodeTableOuter;
    CDispContainer * pDispNodeTableInner;
    CLayout *        pLayoutSiblingCell;
    int              cR, iR;
    int              cC;
    int              yCaption;
    BOOL             fRedoMinMax    = FALSE;
    BOOL             fTopCaption    = FALSE;

    BOOL             fIncrementalRecalc = !fWidthChanged && !fHeightChanged &&
                                        !_fDirtyBeforeLastRowIncremental &&
                                        (IsFixedBehaviour() || IsRepeating());
    CTableRow      * pRow = NULL;
    int              cRows = GetRows();
    int              cRowsIncomplete = 0;
    CTable         * pTable = ptci->Table();
    BOOL             fForceMinMax    = fWidthChanged && (_fHavePercentageInset || _fForceMinMaxOnResize);
    int              iLastRowIncremental = _iLastRowIncremental;
    BOOL             fIncrementalMinMax = FALSE;
    int              yTopInvalidRegion = 0;
    BOOL             fNeedDataTransfer;
    BOOL             fFooterRow;
    CPeerHolder    * pPH = ElementOwner()->GetLayoutPeerHolder();

    //  Rough check to make sure we are not out of rows limits while calc'ing incrementaly
    Assert(!fIncrementalRecalc || !iLastRowIncremental || iLastRowIncremental < cRows);

    CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

    Assert (CanRecalc());

    _fBottomCaption = FALSE;

    if (fIncrementalRecalc)
    {
        if (IsRepeating())
        {
            fIncrementalRecalc =   IsGenerationInProgress();
            // Check if readyState have changed from interactive to complete
            if (_fDatabindingRecentlyFinished)
            {
                fIncrementalRecalc = TRUE;  // last chunk of data have arived; we still can do incremental recalc
            }
            fIncrementalMinMax = _iLastRowIncremental && !IsFixedBehaviour();
            Assert (!fIncrementalMinMax || _cCalcedRows); // if we do incremental min max _cCalcedRows should not be 0
        }
        else
        {
            // do incremental recalc only when loading is not complete and there are new rows
            fIncrementalRecalc = _cCalcedRows != (cRows - (_pFoot? _pFoot->_cRows : 0));
            if (!fIncrementalRecalc)
            {
                // if it is a fixed style table and there are no new rows to claculate, just return
                GetSize(psize); // return original size (bug fix #71810)
                return;
            }
        }
    }

    _fDatabindingRecentlyFinished = FALSE;

#ifdef  TABLE_PERF
    ::StartCAP();
#endif

    PerfLog(tagTableLayout, this, "+CalculateLayout");

    if (!_aryCaptions.Size() && !cRows) // if the table is empty
    {
        _sizeMax =  g_Zero.size;
        _sizeMin =  g_Zero.size;
        *psize   =  g_Zero.size;
        sizeTable = g_Zero.size;
        _fZeroWidth = TRUE;
    }
    else
    {    
        ptci->_fTableHasUserHeight = !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull();

        // reset perentage based rows
        _fHavePercentageRow = FALSE;

        // Create measurer.
        CLSMeasurer me;

        ptci->_pme = &me;

        //
        // Determine the cell widths/heights and row heights
        //--------------------------------------------------------------------------------------
        do
        {
            // calculate min/max only if that information is dirty or forced to do it
            // NOTE:   It would be better if tables, rows, and cells all individually tracked
            //         their min/max dirty state through a flag (as cells do now). This would
            //         allow CalculateMinMax to be more selective in the rows/cells it
            //         processed. (brendand)
            if (_sizeMin.cx <= 0 || _sizeMax.cx <= 0 || (ptci->_grfLayout & LAYOUT_FORCE) || fRedoMinMax || fForceMinMax || fIncrementalMinMax)
            {
                TraceTag((tagTableCalc, "CTableLayout::CalculateLayout - calling CalculateMinMax (0x%x)", pTable));
                _fAlwaysMinMaxCells = _fAlwaysMinMaxCells || fRedoMinMax;

                // if it is an incremental recal, do min max calculation only for the first time or when table is growing
                if (!fIncrementalRecalc || (_cCalcedRows == 0) || fRedoMinMax || fIncrementalMinMax)
                {
                    // do min max
                    int xSizeMinOld = _sizeMin.cx;
                    int xSizeMaxOld = _sizeMax.cx;

                    CalculateMinMax(ptci, fIncrementalMinMax);
                    if (_sizeMin.cx < 0)
                    {
                        return; // it means that we have failed incremental recalc, 
                                // because we have failed to load history
                    }

                    if (!fIncrementalMinMax || xSizeMinOld != _sizeMin.cx || xSizeMaxOld != _sizeMax.cx)
                    {
                        // reset incremental recalc variables
                        // this will force CalculateColumns and recalc all the rows.
                        _cCalcedRows = 
                        iLastRowIncremental = 
                        _iLastRowIncremental = 0;   
                    }
                }
            }

            _fForceMinMaxOnResize = FALSE;   // initialize to FALSE; (TRUE - means need to force min max on resize; bug #66432)

            //
            // Ensure display tree nodes exist
            // (Only do this the first time through the loop)
            //

            if (!fRedoMinMax)
            {
                EnsureTableDispNode(ptci, (ptci->_grfLayout & LAYOUT_FORCE));
            }

            pDispNodeTableOuter  = GetTableOuterDispNode();
            pDispNodeTableInner  = GetTableInnerDispNode();
            pLayoutSiblingCell = NULL;


            // Force is only needed during min/max calculations; or if there were no MinMax calc performed
            if (!IsFixed())
            {
                MtAdd( Mt(NotUsingFixedBehaviour), 1, 0 );
                ptci->_grfLayout = (ptci->_grfLayout & ~LAYOUT_FORCE);
            }

            psize->cy = 0;

            // if it is an incremental recal, calculate columns only for the first time
            if (!fIncrementalRecalc  || (_cCalcedRows == 0))
            {
                CPoint  pt(0, 0);

                psize->cx = 0;

                //
                // first calc columns and table width
                // the table layout is defined by the columns widths and row heights which in
                // turn will finalize the cell widths and heights
                //

                CalculateColumns(ptci, psize);

                iLastRowIncremental = 
                _iLastRowIncremental = 0;

                //
                // Size top CAPTIONs and TCs
                // NOTE: Position TCs on top of all CAPTIONs
                //

                ptci->_smMode = SIZEMODE_NATURAL;

                for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                     cC > 0;
                     cC--, ppCaption++)
                {
                    if ((*ppCaption)->Tag() == ETAG_TC)
                    {
                        Assert((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP);
                        ptci->_pRowLayout = NULL;
                        SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt);
                    }
                    else
                    {
                        if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                        {
                            fTopCaption = TRUE;
                        }
                        else
                        {
                            _fBottomCaption = TRUE;
                        }
                    }
                }

                yCaption = pt.y;

                if (fTopCaption)
                {
                    for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                         cC > 0;
                         cC--, ppCaption++)
                    {
                        CPoint  pt(0, yCaption);

                        if (    (*ppCaption)->Tag() != ETAG_TC
                            &&  (*ppCaption)->_uLocation == CTableCaption::CAPTION_TOP)
                        {
                            ptci->_pRowLayout = NULL;
                            SizeAndPositionCaption(ptci, psize, pDispNodeTableOuter, *ppCaption, &pt);
                        }

                        yCaption = pt.y;
                    }
                }
                ptci->_smMode = smMode;

                // set _sizeParent in tci

                ptci->SizeToParent(psize);

                // remember table top

                _yTableTop = psize->cy;

                //
                // Initialize the table height to just below the captions and top border
                //

                psize->cy += _aiBorderWidths[SIDE_TOP] + _yCellSpacing;

                cR = cRows;
                iR = GetFirstRow();

            }
            else
            {
                // in case of the incremenatl recalc
                cR = cRows - _cCalcedRows;
                iR = GetNextRow(iLastRowIncremental);
                *psize = _sizeIncremental;
                yTopInvalidRegion = psize->cy;
            }

            //
            // Calculate natural cell/row sizes
            // NOTE: Since the COLS attribute assigns column widths without examining every cell
            //       of every row, it is possible that a cell will contain content which cannot
            //       fit within the assigned size. If that occurs, all rows/cells before that
            //       point must be sized again to the larger width to prevent overflow.
            //

            fNeedDataTransfer = FALSE;
            for (; cR > 0; cR--, iR = GetNextRow(iR))
            {
                pRow = _aryRows[iR];
                if (!pRow->_fCompleted)
                {
                    Assert (!_fCompleted && IsFixedBehaviour());  // if row is not completed, table also should not be completed
                    continue;
                }
                if (IsGenerated(iR) && pRow->_fNeedDataTransfer)
                {
                    fNeedDataTransfer = TRUE;
                    continue;
                }

                fFooterRow = IsFooterRow(iR);
                if (fNeedDataTransfer && !fFooterRow)
                {
                    // this is a case where data-bound template consists of multiple rows and not all of them
                    // participate in data transfer
                    continue;
                }

                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout();
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                if (!fIncrementalRecalc || iR >= _cCalcedRows || fFooterRow)
                {
                    // calculate row (in case of incremental recalc - calculate only new rows)
                    fRedoMinMax = CalculateRow(ptci, psize, &pLayoutSiblingCell, pDispNodeTableInner)
                                &&  !_fAlwaysMinMaxCells;

                    // stop calculating rows when need to redo MinMax (since the cell in the row was too large to fit).
                    if (fRedoMinMax)
                        break;
                }

                Assert (ptci->_pRow == pRow);

                if ((pRow->IsDisplayNone()  || ptci->_pFFRow->_bPositionType == stylePositionabsolute) && !pRow->_fCrossingRowSpan)
                    continue;

                psize->cy += ptci->_pRowLayout->_yHeight + _yCellSpacing;

                if (!fFooterRow)
                {
                    // data was not transfered
                    _iLastRowIncremental = iR;
                    _sizeIncremental = *psize;
                }
            }

            //
            // If any cells proved too large for the pre-determined size,
            // force a min/max recalculation
            // NOTE: This should only occur when the COLS attribute has been specified
            //

            Assert(!fRedoMinMax || _cSizedCols || ptci->_fTableContainsCols);

        //
        // If a cell within a row returned a width greater than its minimum,
        // force a min/max pass over all cells (if not previously forced)
        // (When COLS is specified, not all cells are min/max'd - If the page author
        //  included content which does not fit in the specified width, this path
        //  is taken to correct the table)
        //

        } while (fRedoMinMax);

        // set the positions of all cells
        if (!fIncrementalRecalc  || (_cCalcedRows == 0))
        {
            cR = cRows;
            iR = GetFirstRow();
        }
        else
        {
            // in case of the incremenatl recalc
            cR = cRows - _cCalcedRows;
            iR = GetNextRow(iLastRowIncremental);
        }

        fNeedDataTransfer = FALSE;
        for (;
             cR > 0;
             cR--, iR = GetNextRow(iR))
        {
            pRow = _aryRows[iR];
            if (!pRow->_fCompleted)
            {
                Assert (!_fCompleted && IsFixedBehaviour());    // if row is not completed, table also should not be completed
                Assert ( cR == 1 + (_pFoot? _pFoot->_cRows: 0) );   // last row
                cRowsIncomplete++;
                continue;
            }
            if (IsGenerated(iR) && pRow->_fNeedDataTransfer)
            {
                cRowsIncomplete++;
                fNeedDataTransfer = TRUE;
                continue;
            }

            fFooterRow = IsFooterRow(iR);
            if (fNeedDataTransfer && !fFooterRow)
            {
                // this is a case where data-bound template consists of multiple rows and not all of them
                // participate in data transfer. However if a row is added to the middle of a table, then
                // all following rows are not calculated
                cRowsIncomplete++;
                continue;
            }
            if (!fIncrementalRecalc || iR >= _cCalcedRows || fFooterRow)
            {
                ptci->_pRow = pRow;
                ptci->_pRowLayout = (CTableRowLayoutBlock *)pRow->GetUpdatedLayout();
                ptci->_pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
                SetCellPositions(ptci, psize->cx);
            }
        }

        // adjust for table border

        psize->cy += _aiBorderWidths[SIDE_BOTTOM];

        // adjust table height if necessary
        // Table is always horizontal => physical height
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            if (GetFirstBranch()->GetCharFormat()->_fUseUserHeight)
            {
                CalculateRows(ptci, psize);
            }
        }
        else 
        {
            if (    !GetFirstBranch()->GetFancyFormat()->GetHeight().IsNull() 
                ||  _fHavePercentageRow )
            {
                CalculateRows(ptci, psize);
            }
        }

        //
        // Save the size of the table (excluding CAPTIONs)
        //

        sizeTable.cx = psize->cx;
        sizeTable.cy = psize->cy - _yTableTop;

        //
        // Position the display node which holds the cells
        //

        if (_fHasCaptionDispNode)
        {
            pDispNodeTableOuter->SetPosition(CPoint(0, _yTableTop));
        }

        //
        // Size bottom CAPTIONs
        //

        if (_fBottomCaption)
        {
            CPoint          pt(0, psize->cy);
            BOOL            fInsertedBottomCaption = FALSE;
            CLayout *       pLayoutSiblingCaption = NULL;

            ptci->_smMode = SIZEMODE_NATURAL;

            for (cC = _aryCaptions.Size(), ppCaption = _aryCaptions;
                 cC > 0;
                 cC--, ppCaption++)
            {
                if ((*ppCaption)->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    Assert((*ppCaption)->Tag() != ETAG_TC);

                    ptci->_pRowLayout = NULL;
                    if (fInsertedBottomCaption)
                    {
                        SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, *ppCaption, &pt);
                    }
                    else
                    {
                        SizeAndPositionCaption(ptci, psize, &pLayoutSiblingCaption, pDispNodeTableOuter, *ppCaption, &pt);
                        fInsertedBottomCaption = pLayoutSiblingCaption != NULL;
                    }
                }
            }
            ptci->_smMode = smMode;
        }

        if (_pAbsolutePositionCells)
        {
            int               cCells;
            CTableCell      **ppCell;
            CPoint          pt(0,0);
            for (cCells = _pAbsolutePositionCells->Size(), ppCell = *_pAbsolutePositionCells ;  cCells > 0; cCells--, ppCell++)
            {
                CalcAbsolutePosCell(ptci, (*ppCell));
                (*ppCell)->ZChangeElement(0, &pt);
            }
        }
    }

    // cache sizing/recalc data
    _cDirtyRows = 0;
    _cCalcedRows = cRows - cRowsIncomplete; // cache the number of rows that were calculated (needed for incremental recalc)
    if (_pFoot)
    {
        _cCalcedRows -= _pFoot->_cRows;     // _cCalcedRows excludes foot rows
        Assert (_cCalcedRows >=0);
    }

    //
    // Size the display nodes
    //

    if (   _aryColCalcs.Size() == 0  // set the size to 0, if there is no real content
        && _aryCaptions.Size() == 0) // (there are no real cells nor captions)
    {
        sizeTable.cy = psize->cy = 0;  // NETSCAPE: doesn't add the border or spacing or height if the table is empty.
    }


    // at this point the size has been computed, so try to delegate
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
    {
        POINT pt;
        CDispContainer *pDispNodeTableOuter = NULL;
        pt.x = pt.y = 0;

        DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, ptci, *psize, &pt, psize);

        // this will do table invalidation
        SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 

        pDispNodeTableOuter = GetTableOuterDispNode();
        if (   pDispNodeTableOuter
            && (pt.x !=0 || pt.y !=0))
        {
            CSize sizeInsetTemp(pt.x, pt.y);
            pDispNodeTableOuter->SetInset(sizeInsetTemp);
        }
    }
    else
    {
        // this will do table invalidation
        SizeTableDispNode(ptci, *psize, sizeTable, yTopInvalidRegion); 
    }

    if (ElementOwner()->IsAbsolute())
    {
        ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
    }

    //
    // Make sure we have a display node to render cellborder if we need one
    // (only collapsed borders, rules or frame)
    //

    if (psize->cx || psize->cy)
        EnsureTableBorderDispNode(ptci);

#ifdef PERFMETER
    if (!_fIncrementalRecalc && _fCalcedOnce )
    {
        MtAdd(Mt(CalculateLayout), +1, 0);
    }
#endif

    _fIncrementalRecalc = FALSE;

    _fCalcedOnce = TRUE;

    _fDirtyBeforeLastRowIncremental = FALSE;

    PerfLog(tagTableLayout, this, "-CalculateLayout");


#ifdef  TABLE_PERF
    ::StopCAP();
#endif
}

void
CTableLayout::CalcAbsolutePosCell(CTableCalcInfo *ptci, CTableCell *pCell)
{
    CSize              sizeCell;
    CTableCellLayout * pCellLayout;
    CTable           * pTable = ptci->Table();
    const CHeightUnitValue * puvHeight;

    Assert(pCell);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    puvHeight = (const CHeightUnitValue *)&pCell->GetFirstBranch()->GetFancyFormat()->GetHeight();

    pCellLayout = pCell->Layout(ptci->GetLayoutContext());
    pCellLayout->_fContentsAffectSize = TRUE;
    // Table is always horizontal => fVerticalLayoutFlow = FALSE
    sizeCell.cx = (int)pCellLayout->GetSpecifiedPixelWidth(ptci, FALSE);
    if (sizeCell.cx <= 0)
    {
        // NOTE(SujalP): If something changed in an abs pos'd cell, then
        // this function does not redo the min-max.
        // It uses the old max value and calls CalcSizeAtUserWidth. The new
        // width might be greater because of the changes, and we will size the
        // cell incorrectly in some cases. The right fix is for the table
        // to do a min-max pass on the cell over here to correctly get its max size.

        // If this is ppv case _sizeMax should be picked up from the corresponding 
        // cell in compatible layout context... (#22349)
        if (    ptci->GetLayoutContext() 
            &&  ptci->GetLayoutContext()->ViewChain()   )
        {
            CTableCellLayout * pCellLayoutCompat = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompat);

            sizeCell.cx = (int)pCellLayoutCompat->_sizeMax.cu;
        }
        else 
        {
            sizeCell.cx = (int)pCellLayout->_sizeMax.cu;
        }
    }
    
    sizeCell.cy = 0;
    pCellLayout->CalcSizeAtUserWidth(ptci, &sizeCell);
    
    // if the height of the cell is specified, take it.
    if (puvHeight->IsSpecified())
    {
        int iPixelHeight = puvHeight->GetPixelHeight(ptci, pTable);
        if (iPixelHeight > sizeCell.cy)
        {
            sizeCell.cy = iPixelHeight;
            pCellLayout->SizeDispNode(ptci, sizeCell);
        }
    }

    pCellLayout->SetYProposed(0);
    pCellLayout->SetXProposed(0);

    return;
}

//+--------------------------------------------------------------------------------------
//
// Layout methods overriding CLayout
//
//---------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CalcSizeVirtual, CTableLayout
//
//  Synopsis:   Calculate the size of the table
//
//              note, layoutBehaviors are now used for filters and so need to apply to tables.
//              this is threaded through this function only where size is actually calculated.
//
//--------------------------------------------------------------------------

DWORD
CTableLayout::CalcSizeVirtual( CCalcInfo * pci,
                               SIZE *      psize,
                               SIZE *      psizeDefault)
{
    Assert(pci);
    Assert(psize);
    Assert(pci->_smMode != SIZEMODE_SET);
    Assert(ElementOwner());

    AssertSz(  pci->GetLayoutContext() == NULL 
            || (!IsSizeThis() && !_fForceLayout), 
            "In PPV Table Layout Cache _fSizeThis and _fForceLayout should NOT be used !");

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    CScopeFlag      csfCalcing(this);
    DWORD           grfReturn = (pci->_grfLayout & LAYOUT_FORCE);
    CTable        * pTable    = Table();
    CTableLayoutBlock * pTableLayout = pci->GetLayoutContext() == NULL ? this  
        : (CTableLayoutBlock *)pTable->GetUpdatedLayout(pci->GetLayoutContext());
    CPeerHolder   * pPH       = ElementOwner()->GetLayoutPeerHolder();
    BOOL    fViewChain        =   pci->GetLayoutContext() 
                               && pci->GetLayoutContext()->ViewChain();

    // Ignore requests on incomplete tables
#if DBG == 1
    if (!IsTagEnabled(tagTableRecalc))
#endif
    if (!CanRecalc() && !IsCalced())
    {
        psize->cx =
        psize->cy = 0;

        if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
            pTableLayout->SetSizeThis(FALSE);

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        return grfReturn;
    }

    else if (TestLock(CElement::ELEMENTLOCK_BLOCKCALC) || !CanRecalc())
    {
        switch (pci->_smMode)
        {
        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
            pTableLayout->SetSizeThis(FALSE);

        case SIZEMODE_SET:
        case SIZEMODE_FULLSIZE:
            pTableLayout->GetSize(psize);
            break;

        case SIZEMODE_MMWIDTH:
            psize->cx = _sizeMax.cx;
            psize->cy = _sizeMin.cx;
            break;

        case SIZEMODE_MINWIDTH:
            *psize = _sizeMin;
            break;
        }

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        return grfReturn;
    }

    TraceTag((tagTableCalc, "CTableLayout::CalcSize - Enter (0x%x), smMode = %x, grfLayout = %x", pTable, pci->_smMode, pci->_grfLayout));

    CTableCalcInfo tci(pci, pTable, this);
    Assert(pTableLayout == tci.TableLayout());

    CSize sizeOriginal = g_Zero.size;

    if (pTableLayout->_fForceLayout)
    {
        pTableLayout->_fForceLayout   = FALSE;
        tci._grfLayout |= LAYOUT_FORCE;
        grfReturn      |= LAYOUT_FORCE;
    }

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        _fAutoBelow   = FALSE;
        _fPositionSet = FALSE;
    }

    EnsureTableLayoutCache();

    _cNestedLevel = tci._cNestedCalcs;

    // Table is always horizontal => physical width and height
    CTreeNode *         pNode = GetFirstBranch();
    const CFancyFormat * pFF  = pNode->GetFancyFormat();
    CWidthUnitValue  uvWidth  = pFF->GetWidth();
    CHeightUnitValue uvHeight = pFF->GetHeight();

    // For NS/IE compatibility, treat negative values as not present
    if (uvWidth.GetUnitValue() <= 0)
        uvWidth.SetNull();
    if (uvHeight.GetUnitValue() <= 0)
        uvHeight.SetNull();

    if (tci._smMode == SIZEMODE_NATURAL || tci._smMode == SIZEMODE_NATURALMIN)
    {
        long    cxParent;
        BOOL    fWidthChanged;
        BOOL    fHeightChanged;

        if (tci._smMode == SIZEMODE_NATURALMIN)
        {
            //
            // In NATURALMIN mode (TABLE inside TD) _sizeParent.cx or _sizeParent.cx
            // is set to lMaximumWidth. 
            // In this mode we want to get real table size, but in case of %width or 
            // %height, we use _sizeParent to get this information. But because of
            // lMaximumWidth we are returning wrong value, so in case of NATURALMIN 
            // mode set parent size to 0, to ignore sizes and get real table size.
            // NOTE: we will do the right thing in NATURAL mode.
            //
            tci.SizeToParent(0, 0);
        }

        pTableLayout->GetSize(&sizeOriginal);

        //
        // Determine the appropriate parent width
        // (If width is a percentage, use the full parent size as the parent width;
        //  otherwise, use the available size as the parent width)
        //

        cxParent = (uvWidth.IsSpecified() && PercentWidth()
                            ? tci._sizeParent.cx
                            : psize->cx);

        // 
        // Calculate propsed size 
        // 
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            const CCharFormat * pCF = pNode->GetCharFormat();

            //  _sizeProposed.cx does not matter since 
            //  1) table code already handles calculation of table width properly 
            //  2) table's width does not directly participate in table's children 
            //     width computantions
            _sizeProposed.cx = 0;
            
            if (pCF->_fUseUserHeight)
            {
                _sizeProposed.cy = uvHeight.YGetPixelValue(pci, pci->_sizeParent.cy, 
                    pNode->GetFontHeightInTwips(&uvHeight));
            }
            else 
            {
                _sizeProposed.cy = 0;
            }
        }

        // 
        //  (bug IE6 # 18002) this is a hack: 
        //  1. to prevent unnecessary calculation of table during percent second calc pass. 
        //  2. to preserve layout engine rendering as mush as possible in Trident compat 
        //     rendering mode. 
        // 
        //  If the table has a percent width and this is a percent second calc 
        //  (pci->_fPercentSecondPass == TRUE) lets compare new parent width with 
        //  our original width, because if the table defines the width of its parent, 
        //  parent size at percent second pass is equal to what the table returned 
        //  the first time (original width) 
        // 

        if (    ElementOwner()->HasMarkupPtr()
            &&  !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() 
            &&  pci->_fPercentSecondPass
            &&  PercentWidth()  )
        {
            fWidthChanged =     (tci._grfLayout & LAYOUT_FORCE)
                            ||  _sizeMax.cx < 0
                            ||  (   (_fHavePercentageCol || _fHavePercentageInset || _fForceMinMaxOnResize || PercentWidth())
                                &&  cxParent != sizeOriginal.cx)
                            ||  (   cxParent < sizeOriginal.cx
                                &&  sizeOriginal.cx > _sizeMin.cx)
                            ||  (   cxParent > sizeOriginal.cx
                                &&  sizeOriginal.cx < _sizeMax.cx);
        }
        else 
        {
            //
            // Table width changes if
            //  a) Forced to re-examine
            //  b) Min/max values are dirty
            //  c) Width  is a percentage and parent width has changed
            //  d) Width  is not specified and the available space has changed
            //  d) Parent is smaller/equal to table minimum and table is greater than minimum
            //  e) Parent is greater/equal to table maximum and table is less than maximum
            //

            fWidthChanged =     (tci._grfLayout & LAYOUT_FORCE)
                            ||  _sizeMax.cx < 0
                            ||  (   (_fHavePercentageCol || _fHavePercentageInset || _fForceMinMaxOnResize || PercentWidth())
                                &&  cxParent != pTableLayout->_sizeParent.cx)
                            ||  (   cxParent < pTableLayout->_sizeParent.cx
                                &&  sizeOriginal.cx > _sizeMin.cx)
                            ||  (   cxParent > pTableLayout->_sizeParent.cx
                                &&  sizeOriginal.cx < _sizeMax.cx);
        }

        fHeightChanged = (PercentHeight() && tci._sizeParent.cy != pTableLayout->_sizeParent.cy);

        //
        // Calculate a new size if
        //  a) The table is dirty
        //  b) Table width changed
        //  c) Height is a percentage and parent height has changed
        //  d) Not completed loading (table size is always dirty while loading)
        //

        pTableLayout->SetSizeThis(  pTableLayout->IsSizeThis()  
                                ||  fWidthChanged 
                                ||  fHeightChanged
                                ||  !_fCompleted );

        //
        // If the table needs it, recalculate its size
        //

        if ( pTableLayout->IsSizeThis() )
        {
            CSize   size = g_Zero.size;
            BOOL    fIncrementalRecalc = _fIncrementalRecalc;

            // Cache parent size
            pTableLayout->_sizeParent.cx = cxParent;
            pTableLayout->_sizeParent.cy = tci._sizeParent.cy;

            //
            // If There is a peer that wants full_delegation of the sizing...        
            //-------------------------------------------------------------------
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
            {
                POINT pt;
                pt.x = pt.y = 0;

                DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, pPH, &tci, *psize, &pt, psize);

                SizeTableDispNode(&tci, *psize, *psize, 0); 
            }
            else
            {
                if (fViewChain)
                {
                    //  If table is absolute positioned prohibit breaking 
                    if (pTable->IsAbsolute())
                    {
                        pTableLayout->SetElementCanBeBroken(FALSE);
                    }

                    // 
                    //  Defensive code if there is no available height to fill prohibit breaking 
                    //
                    if (pci->_cyAvail <= 0)
                    {
                        pTableLayout->SetElementCanBeBroken(FALSE);
                    }
                }

                //
                //  if this is top table and this is print view mode do compatible calc pass.
                //                              //  do calculations in working layout context if 
                if (_cNestedLevel == 0          // 1. we are top level table (otherwise we should be called from top level)
                    && fViewChain               // 2. there is a view chain
                    && pTableLayout->ElementCanBeBroken()   //  3. we are allowed to break
                   )
                {
                    //  NOTE (olego): here is the assumpion has been made that the page where table 
                    //  is starting is called to calc size _first_. if this is not true a wrong property 
                    //  will be set to compatible layout context.

                    CLayoutBreak *pLayoutBreak;

                    pci->GetLayoutContext()->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
                    if (pLayoutBreak == NULL)
                    {
                        CLayoutContext *pLayoutContextCompat;

                        Assert(pTableLayout->GetContentMarkup());
                        pLayoutContextCompat = pTableLayout->GetContentMarkup()->GetUpdatedCompatibleLayoutContext(pci->GetLayoutContext());
                        Assert(pLayoutContextCompat);

                        CTableCalcInfo      TCI(pci, pTable, this);
                        CTableLayoutBlock  *pTableLayoutCompat = (CTableLayoutBlock *)pTable->GetUpdatedLayout(pLayoutContextCompat);
                        Assert(pTableLayoutCompat);

                        TCI.SetLayoutContext(pLayoutContextCompat);
                        TCI._pTableLayout = pTableLayoutCompat;

                        // Cache parent size
                        pTableLayoutCompat->_sizeParent.cx = cxParent;
                        pTableLayoutCompat->_sizeParent.cy = tci._sizeParent.cy;

                        pTableLayoutCompat->CalculateLayout(&TCI, &size, fWidthChanged, fHeightChanged);
                    }
                }

                pTableLayout->CalculateLayout(&tci, &size, fWidthChanged, fHeightChanged);
            }

            *psize      = size;

            pTableLayout->SetSizeThis( FALSE );
            grfReturn  |= LAYOUT_THIS |
                          (size.cx != sizeOriginal.cx
                                ? LAYOUT_HRESIZE
                                : 0)  |
                          (size.cy != sizeOriginal.cy
                                ? LAYOUT_VRESIZE
                                : 0);

            if (fIncrementalRecalc)
            {
                 _dwTimeEndLastRecalc = GetTickCount();
                 _dwTimeBetweenRecalc += 1000;  // increase the interval between the incremental reaclcs by 1 sec.
            }

#if DBG == 1
            if (IsTagEnabled(tagTableDump))
            {
                DumpTable(_T("CalcSize(SIZEMODE_NATURAL)"));
            }
#endif
        }
        else
        {
            // Otherwise, propagate the request through default handling
            *psize = sizeOriginal;
        }

        if(HasMapSizePeer())
            GetApparentSize(psize);
        
    }
    else if (  tci._smMode == SIZEMODE_MMWIDTH
            || tci._smMode == SIZEMODE_MINWIDTH
            )
    {
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);
            POINT             pt;

            pt.x = pt.y = 0;

            // Delegate to the layoutBehavior
            pTableLayout->DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                                           pPH, 
                                           pci, 
                                           *psize, 
                                           &pt, 
                                           psize);
        }
        else 
        {
            if (_sizeMax.cx < 0 || (tci._grfLayout & LAYOUT_FORCE))
            {
                CElement::CLock   Lock(pTable, CElement::ELEMENTLOCK_SIZING);

                CalculateBorderAndSpacing(&tci);
                CalculateMinMax(&tci);

                pTableLayout->SetSizeThis( TRUE );

                //
                // If an explicit width exists, then use that width (or the minimum
                // width of the table when the specified width is too narrow) for
                // both the minimum and maximum
                //

                if (    uvWidth.IsSpecified()
                    &&  !uvWidth.IsSpecifiedInPercent())
                {
                    long    cxWidth = uvWidth.GetPixelWidth(&tci, pTable);

                    if (cxWidth < _sizeMin.cx)
                    {
                        cxWidth = _sizeMin.cx;
                    }
                    else if (cxWidth > _sizeMin.cx)
                    {
                        _sizeMin.cx = cxWidth;
                    }

                    if (cxWidth < _sizeMax.cx)
                    {
                        _sizeMax.cx = cxWidth;
                    }
                }
            }

            if (tci._smMode == SIZEMODE_MMWIDTH)
            {
                psize->cx = _sizeMax.cx;
                psize->cy = _sizeMin.cx;
            }
            else
            {
                *psize = _sizeMin;
            }

            // at this point the MM size has been computed, so try to delegate 
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                POINT pt;

                pt.x = pt.y = 0;
                pTableLayout->DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                               pPH, 
                                               pci, 
                                               *psize, 
                                               &pt, 
                                                psize);
            }
        }

        //  At this point we want to update psize with a new information accounting filter 
        //  for MIN MAX Pass inside table cell.
        if (HasMapSizePeer())
        {
            // DelegateMapSize doesn't work when cy is 0. Trick it.
            if (tci._smMode == SIZEMODE_MINWIDTH)
                psize->cy = psize->cx;

            //  At this point we want to update psize with a new information accounting filter 
            CRect rectMapped(CRect::CRECT_EMPTY);
            // Get the possibly changed size from the peer
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cy = psize->cx = rectMapped.Width();
            }

            if (tci._smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
      
    }
    else
    {
        // super properly handles layoutBehavior delegation
        grfReturn = super::CalcSizeVirtual(&tci, psize, NULL);
    }

    TraceTag((tagTableCalc, "CTableLayout::CalcSize - Exit (0x%x)", pTable));


    // If this table is nested, propagate out _fTableContainsCols, if set.
    if (pci->_fTableCalcInfo && tci._fTableContainsCols)
        ((CTableCalcInfo *) pci)->_fTableContainsCols = TRUE;


    if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
    {
        //
        //  Reset dirty state and remove posted layout request
        //

        _fDirty = FALSE;

        //
        // If any absolutely positioned sites need sizing, do so now
        //

        if (HasRequestQueue())
        {
            //
            //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
            //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
            //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
            //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
            //  See bugs 69335, 72059, et. al. (greglett)
            //
            CTableCalcInfo  TCI(pci, pTable, this);
            TCI._grfLayout |= LAYOUT_MEASURE;
            ProcessRequests(&TCI, sizeOriginal);
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }

    if (pci->_fTableCalcInfo && tci._fDontSaveHistory)
    {
        ((CTableCalcInfo *)pci)->_fDontSaveHistory = TRUE;  // propagate save history flag up.
    }

    if (fViewChain)
    {
        pci->_fLayoutOverflow = (pTableLayout->_fLayoutBreakType == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CTableLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetSpecifiedPixelWidth
//
//  Synopsis:   get user width
//
//  Returns:    returns user's specified width of the table (0 if not set or
//              if specified in %%)
//              if user set's width <= 0 it will be ignored
//-------------------------------------------------------------------------

long
CTableLayout::GetSpecifiedPixelWidth(CTableCalcInfo * ptci, BOOL *pfSpecifiedInPercent)
{
    // Table is always horizontal => physical width
    CWidthUnitValue uvWidth = GetFirstBranch()->GetFancyFormat()->GetWidth();

    long     xTableWidth = 0;
    BOOL     fSpecifiedInPercent = FALSE;
    CTable * pTable = ptci->Table();

    // NS/IE compatibility, any value <= 0 is treated as <not present>
    if ( uvWidth.GetUnitValue() <= 0 )
    {
        uvWidth.SetNull();
    }

    if (uvWidth.IsSpecified())
    {
        if (uvWidth.IsSpecifiedInPixel())
        {
            xTableWidth = uvWidth.GetPixelWidth(ptci, pTable);
        }
        else
        {
            fSpecifiedInPercent = TRUE;
        }
    }

    if (pfSpecifiedInPercent)
    {
        *pfSpecifiedInPercent = fSpecifiedInPercent;
    }

    return xTableWidth;
}


BOOL CTableLayout::IsGenerationInProgress()
{
    
    Assert (IsRepeating());

    BOOL             fNotFirstChunkOfData = _cCalcedRows > (_pHead? _pHead->_cRows: 0);
    BOOL             fIncrementalRecalc = FALSE;

    if (fNotFirstChunkOfData)
    {
        CTable          *pTable = Table();

        // do incremental recalc only when in a process of fetching rows and populating the table
            // or at the completion of the data set if it is not the first chunk of data.
        fIncrementalRecalc =   pTable->_readyStateTable == READYSTATE_INTERACTIVE;
    }
    return fIncrementalRecalc;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::RowHasPageBreakBefore
//
//  Synopsis:   checks if the row passed thru ptci or any of row's cells 
//              has page-break-before set. 
//              Also sets CCalcInfo::_fPageBreakLeft/Right
//
//-------------------------------------------------------------------------
BOOL 
CTableLayout::RowHasPageBreakBefore(CTableCalcInfo * ptci)
{
    Assert(ptci->_pRow);

    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableColCalc *     pColCalc;
    int                 cC;
    int                 cCols;
    CTreeNode *         pNode;
    const CFancyFormat* pFF;

    pNode = ptci->_pRow->GetFirstBranch();
    pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

    if (pFF && !!GET_PGBRK_BEFORE(pFF->_bPageBreaks))
    {
        ptci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
        ptci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
        return TRUE;
    }

    Assert(ptci->_pRow->RowLayoutCache());

    ppCell = ptci->_pRow->RowLayoutCache()->_aryCells;
    cCols = GetCols();
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone() || IsSpanned(*ppCell))
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pNode = pCell->GetFirstBranch();
            pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

            if (pFF && !!GET_PGBRK_BEFORE(pFF->_bPageBreaks))
            {
                ptci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
                ptci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::RowHasPageBreakAfter 
//
//  Synopsis:   checks if the row passed thru ptci or any of row's cells 
//              has page-break-after set. 
//              Also sets CCalcInfo::_fPageBreakLeft/Right
//
//-------------------------------------------------------------------------
BOOL 
CTableLayout::RowHasPageBreakAfter (CTableCalcInfo * ptci)
{
    Assert(ptci->_pRow);

    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableColCalc *     pColCalc;
    CTableRowLayout *   pRowLayoutCache;
    int                 cC;
    int                 cCols;
    CTreeNode *         pNode;
    const   CFancyFormat* pFF;
    BOOL                fPageBreakAfterFound;

    pNode = ptci->_pRow->GetFirstBranch();
    pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

    if (pFF && !!GET_PGBRK_AFTER(pFF->_bPageBreaks))
    {
        ptci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
        ptci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
        return TRUE;
    }

    pRowLayoutCache = ptci->_pRow->RowLayoutCache();
    Assert(pRowLayoutCache);

    ppCell = pRowLayoutCache->_aryCells;
    cCols = GetCols();
    fPageBreakAfterFound = FALSE;
    for (cC = cCols, pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pNode = pCell->GetFirstBranch();
            pFF   = pNode ? pNode->GetFancyFormat(LC_TO_FC(ptci->LayoutContext())) : NULL;

            if (pFF && !!GET_PGBRK_AFTER(pFF->_bPageBreaks))
            {
                int cCellRowSpan = pCell->RowSpan();

                if (IsSpanned(*ppCell))
                {
                    int iCellRowIndex = pCell->RowIndex();

                    // if ends in this row and this is the first column of the cell
                    if ((  iCellRowIndex + cCellRowSpan - 1 == pRowLayoutCache->RowPosition())
                        && pCell->ColIndex() == cCols - cC)
                    {
                        fPageBreakAfterFound = TRUE;
                    }
                }
                else if (cCellRowSpan == 1)
                {
                    fPageBreakAfterFound = TRUE;
                }

                if (fPageBreakAfterFound)
                {
                    ptci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft);
                    ptci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight);
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableLayout::ResetRowMinMax 
//
//  Synopsis:   resets minmax valid on all cells belonging to given row
//
//-------------------------------------------------------------------------
void 
CTableLayout::ResetRowMinMax(CTableRowLayout *pRowLayoutCache)
{
    CTableCell **       ppCell;
    CTableCell *        pCell;
    CTableCellLayout *  pCellLayout;
    CTableColCalc *     pColCalc;
    int                 cC;
    CMarkup *           pMarkup;
    CLayoutContext *    pLayoutContextCompat;

    if (_fTLCDirty || !pRowLayoutCache)
        return;

    // its ok to be dirty, because we are just resetting anyhow
    WHEN_DBG( BOOL fDisableTLCAssert = _fDisableTLCAssert; _fDisableTLCAssert = TRUE; )

    cC = GetCols();

    WHEN_DBG( _fDisableTLCAssert = fDisableTLCAssert; )

    if (_aryColCalcs.Size() < cC)
    {
        //  We are not ready yet
        return;
    }

    pMarkup = GetContentMarkup();
    pLayoutContextCompat = (pMarkup && pMarkup->HasCompatibleLayoutContext()) 
        ? pMarkup->GetCompatibleLayoutContext() : NULL;

    ppCell = pRowLayoutCache->_aryCells;
    for (pColCalc = _aryColCalcs;
        cC > 0;
        cC--, ppCell++, pColCalc++)
    {
        if (pColCalc->IsDisplayNone())
        {
            continue;
        }

        pCell = Cell(*ppCell);
        if (pCell)
        {
            pCellLayout = (CTableCellLayout *)pCell->GetUpdatedLayout(pLayoutContextCompat);
            Assert(pCellLayout);

            pCellLayout->ResetMinMax();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltdata.cxx
//
//  Contents:   CTableLayout databinding methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx" // CTreePosList in CTableLayout::Notify
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

// DB support

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"  // DB stuff in Notify
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include <rowbind.hxx>
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

//+----------------------------------------------------------------------------------------------
//  Databind support methods
//-----------------------------------------------------------------------------------------------

#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     Populate
//
//  Synopsis:   Populate the table with repeated rows if the DataSrc property is
//              specified.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::Populate()
{
    HRESULT                     hr;
    int                         cInsertNewRowAt;
    CDataLayerCursor            *pdlcCursor;

    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        return S_OK;

    hr = EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cInsertNewRowAt = GetHeadFootRows();

    Assert ((_fRefresh && _pDetailGenerator) || (!_fRefresh && !_pDetailGenerator));
    Assert(Table()->GetDBMembers());
    Assert(Table()->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT));

    // get the DLCursor from the binder
    hr = Table()->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->GetDLCursor(&pdlcCursor);
    if (hr)
        goto Cleanup;

    if (!_fRefresh)
    {
        _pDetailGenerator = new CDetailGenerator();    // expanded table
        if (!_pDetailGenerator)
            goto MemoryError;

        Doc()->_fBroadcastStop = TRUE;

        _pDetailGenerator->SetTemplateCount(GetRows() - cInsertNewRowAt);
    }

    hr = _pDetailGenerator->Init (pdlcCursor, Table(), cInsertNewRowAt,
                                  Table()->GetAAdataPageSize());
    if (hr)
        goto Error;

    if (!_fRefresh)
    {
        hr = _pDetailGenerator->PrepareForCloning();
        if (hr)
            goto Cleanup;

        // Remove the templates from _aryRows
        RemoveTemplate();

        if ( THR(EnsureTableLayoutCache()) )
            goto Error;

        Assert (GetRows() == cInsertNewRowAt);
    }
    hr = _pDetailGenerator->Generate ();

Cleanup:

    _fRefresh = FALSE;

    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (_pDetailGenerator)
    {
        _pDetailGenerator->Detach();
        delete _pDetailGenerator;
        _pDetailGenerator = NULL;
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     Refresh (regenerate)
//
//  Synopsis:   Populate the table with repeated rows when setting the new
//              RepeatSrc property.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CTableLayout::refresh()
{
    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    if (_pDetailGenerator)
    {
        hr = DeleteGeneratedRows();
        if (hr)
            goto Cleanup;

        hr = Populate();
        if (hr)
            goto Cleanup;
    }

Cleanup:
#endif

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     GetTemplate
//
//  Synopsis:   create the template for repeating rows.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::GetTemplate(BSTR * pbstr)
{
    HRESULT    hr = E_FAIL;
    int i;

    if (ElementOwner()->IsInMarkup())
    {
        IStream * pstm;

        hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
        if (hr)
            goto Cleanup;

        {
            CStreamWriteBuff swb(pstm, CP_UCS_2);

            hr = THR( swb.Init() );
            if( hr )
                goto Cleanup;

            swb.SetFlags(WBF_ENTITYREF|WBF_DATABIND_MODE);

            hr = EnsureTableLayoutCache();
            if (hr)
                goto Cleanup;

            // append each TBODY to the template
            for (i=0; i<_aryBodys.Size(); ++i)
            {
                CTreeSaver ts(_aryBodys[i], &swb);
                
                swb.SetElementContext(_aryBodys[i]);

                // if the body is synthesized, ts.Save won't write out its begin
                // and end tags.  But we want them in the template, so write
                // them out explicitly.  One reason we want them:  setting
                // borders=groups will write borders between each template
                // instance.
                _aryBodys[i]->WriteTag(&swb, FALSE, TRUE);
                ts.Save();
                _aryBodys[i]->WriteTag(&swb, TRUE, TRUE);
            }

            swb.Terminate();
        }

        hr = GetBStrFromStream(pstm, pbstr, TRUE);

        ReleaseInterface(pstm);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     DeleteGeneratedRows (private)
//
//  Synopsis:   Remove the generated rows, preparing for refresh
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableLayout::DeleteGeneratedRows()
{
    HRESULT hr = S_OK;

    if (_pDetailGenerator)
    {
        _fRefresh = TRUE;

        // delete all the generated rows

        _pDetailGenerator->ReleaseGeneratedRows();   // need to delete Xfer thunks, before deleting rows

        RemoveTemplate();
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     RemoveRowsAndTheirSections
//
//  Synopsis:   Removes all rows in the given range and their sectionsw.
//              Can't remove header/footer.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::RemoveRowsAndTheirSections ( int iRowStart, int iRowFinish )
{
    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        return S_OK;
    {
        HRESULT         hr;
        CTableSection * pSection = NULL;
        int             iBodyStart = 0;
        int             iBodyFinish = 0;
        int             i;

        // This function should only be called to remove rows that make up one
        // or more complete template instances.  In particular, it shouldn't be
        // called for tables that aren't databound.  A general RemoveRows would
        // have to deal with row spans and other issues that don't arise in
        // databound tables.
        
        Assert(IsRepeating());
        
        //
        // Are there any rows to remove?
        //
        
        Assert(GetHeadFootRows() <= iRowStart  &&  iRowFinish < GetRows());
        
        if (iRowStart > iRowFinish)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Delete the rows by deleting spans of consecutive runs.
        // The runs owned by the given rows may be non-consecutive, so be careful.
        // We delete the rows back-to-front, because each call to RemoveRuns
        // blows away and rebuilds _aryRows (via monster walk).
        //
        
        for (i=0; i < _aryBodys.Size(); i++)
        {
            pSection = _aryBodys[i];
            if (iRowStart >= pSection->_iRow && iRowStart < pSection->_iRow + pSection->_cRows)
            {
                iBodyStart = i;
            }
            if (iRowFinish >= pSection->_iRow && iRowFinish < pSection->_iRow + pSection->_cRows)
            {
                iBodyFinish = i;
                break;
            }
        }

        Assert (iBodyFinish >= iBodyStart);

        hr = RemoveBodys(iBodyStart, iBodyFinish);

    Cleanup:
        RRETURN( hr );
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     RemoveBodys
//
//  Synopsis:   Removes all bodys in the given range.  Can't remove header/footer.
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::RemoveBodys (int iBodyStart, int iBodyFinish)
{
    HRESULT         hr = S_OK;

    // Don't generate or remove rows when a table is not in the tree
    if (!Table()->_fEnableDatabinding)
        goto Cleanup;

    {
        CMarkupPointer pStart( Doc() ), pEnd( Doc() );
        
        BOOL            fRemoveAll;
        int             iBodyFinishNext;

        _fRemovingRows = TRUE;

        Verify(OpenView());

        // This function should only be called to remove bodys that make up one
        // or more complete template instances.  In particular, it shouldn't be
        // called for tables that aren't databound.  A general RemoveBodys would
        // have to deal with row spans and other issues that don't arise in
        // databound tables.
        Assert(IsRepeating());
        
        //
        // Are there any bodys to remove?
        //
        Assert(0 <= iBodyStart  &&  iBodyFinish < _aryBodys.Size());
        if (iBodyStart > iBodyFinish)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        fRemoveAll = iBodyStart == 0 && iBodyFinish == GetBodys() - 1;

        //
        // Delete the bodys by deleting spans of consecutive runs.
        // The bodys may be non-consecutive, so be careful.
        // We delete the bodys back-to-front.
        //
        
        iBodyFinishNext = iBodyFinish;
        while (iBodyStart <= iBodyFinishNext)
        {
            int iBodyFinishDelete = iBodyFinishNext;

            // set gaps to surround the last body

            hr = THR( pStart.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_BeforeBegin ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pEnd.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_AfterEnd ) );

            if (hr)
                goto Cleanup;
            
            // augment the span as long as the bodys are consecutive
            while (iBodyStart <= --iBodyFinishNext)
            {
                CMarkupPointer pNextEnd ( Doc() );

                hr = THR( pNextEnd.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;
                
                if (pNextEnd.IsEqualTo( & pStart ))
                {
                    hr = THR( pStart.MoveAdjacentToElement( _aryBodys[iBodyFinishNext], ELEM_ADJ_BeforeBegin ) );

                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    break;
                }
            }

            // This is one of the few places where a table is modified.
            // Mark the TLC dirty now.
            Table()->InvalidateCollections();

            if (fRemoveAll && iBodyFinishNext<iBodyStart && iBodyFinishDelete==iBodyFinish)
            {
                ReleaseRowsAndSections(FALSE, TRUE);  // fReleaseHeaderFooter = FALSE, fReleaseTCs = TRUE
            }
            else
            {
                ReleaseBodysAndTheirRows(iBodyFinishNext + 1, iBodyFinishDelete);
            }

            // remove the consecutive bodys
            hr = THR( Doc()->Remove( & pStart, & pEnd ) );

            if (hr)
                goto Cleanup;

            _fRemovingRows = FALSE;

        }

        Resize();
    }

Cleanup:
    _fRemovingRows = FALSE;     // in case of goto (error condition) we want to restore the flag
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     RowIndex2RecordNumber
//
//  Synopsis:   find the database position of a given row
//
//  Arguments:  iRow        index of desired row
//
//  Returns:    index of corresponding database record
//
//-----------------------------------------------------------------------------

long
CTableLayout::RowIndex2RecordNumber(int iRow)
{
    Assert(IsRepeating());
    return _pDetailGenerator->RowIndex2RecordNumber(iRow);
}
#endif // NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\cglyph.cxx ===
//+---------------------------------------------------------------------
//
//   File:      cglyph.cxx
//
//  Contents:   CGlyph Class which manages the information for glyphs and makes it available at rendering time.
//
//  Classes:    CGlyph
//              CGlyphTreeType
//
//------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "cglyph.hxx"

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif


MtDefine(CGlyph,        CDoc,       "CGlyph")
MtDefine(CTreeObject,    CGlyph,     "CTreeObject")
MtDefine(CTreeList,      CTreeObject, "CTreeList")
MtDefine(GyphInfoType,  CTreeObject, "GyphInfoType")
    
    
//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyph()     
//
//  Synopsis:   Initializes the class' static data.  
//  
//----------------------------------------------------------------------------
CGlyph::CGlyph(CDoc * pDoc)
{
    _pDoc               = pDoc;
    s_levelSize [0]     = NUM_STATE_ELEMS; 
    s_levelSize [1]     = NUM_POS_ELEMS;
    s_levelSize [2]     = NUM_ALIGN_ELEMS;
    s_levelSize [3]     = NUM_ORIENT_ELEMS;
    _pchBeginDelimiter     = NULL;
    _pchEndDelimiter       = NULL;
    _pchEndLineDelimiter   = NULL;
    _pchDefaultImgURL      = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::Init()     
//
//  Synopsis:   Makes the necessary memory allocations and initializations  
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::Init ()
{
    HRESULT     hr  = S_OK;
    TCHAR szBuffer[256];
    _XMLStack       = new CList;

    if (!_XMLStack)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _gHashTable     = new CPtrBagCi<CGlyphTreeType *>(TRUE);
    if (!_gHashTable)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pDoc->GetEditingString(IDS_BEGIN_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;

     _pchBeginDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchBeginDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchBeginDelimiter , szBuffer);

    hr = _pDoc->GetEditingString(IDS_END_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;
    _pchEndDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchEndDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchEndDelimiter , szBuffer);

    hr = _pDoc->GetEditingString(IDS_END_LINE_DELIMITER , szBuffer, ARRAY_SIZE(szBuffer));
    if (hr)
        goto Cleanup;
    _pchEndLineDelimiter = new TCHAR[_tcslen(szBuffer)+1];
     if (!_pchEndLineDelimiter)
     {
         hr = E_OUTOFMEMORY ;
         goto Cleanup;
     }
     _tcscpy(_pchEndLineDelimiter , szBuffer);

        
    hr = ConstructResourcePath (szBuffer);
    if (hr)
        goto Cleanup;

    _tcscat (szBuffer, DEFAULT_IMG_NAME);
    _pchDefaultImgURL = new TCHAR [_tcslen(szBuffer)+1];
    if (!_pchDefaultImgURL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy (_pchDefaultImgURL, szBuffer);

Cleanup:
    RRETURN (hr);
}


HRESULT 
CGlyph::ConstructResourcePath (TCHAR szBuffer [])
{
    HRESULT     hr = S_OK;

    HINSTANCE hResourceLibrary = NULL;
    hr = _pDoc->GetEditResourceLibrary(&hResourceLibrary);
    if (hr)
        goto Cleanup;
    
    _tcscpy(szBuffer, _T("res://"));

    if (!GetModuleFileName(
            hResourceLibrary,
            szBuffer + _tcslen(szBuffer),
            pdlUrlLen - _tcslen(szBuffer) - 1))
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(szBuffer, _T('/'));
        if (p)
        {
            int iLen = _tcslen(++p);
            memmove(szBuffer + 6, p, sizeof(TCHAR) * iLen);
            szBuffer[6 + iLen] = _T('\0');
        }
    
    }
#endif

    _tcscat (szBuffer, _T("/"));

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::~CGlyph()     
//
//  Synopsis:   First deletes the contents of the hash table, which is in 
//              charge of keeping track of glyphs for XML tags. Then, 
//              deletes the hash table, and finally iterates through the 
//              static array which keeps track of all the identified 
//              tags and deletes the contents of that as well.                 
//  
//              Note:   The sole putpose of _XMLStack is in fact to keep
//                      track of the information entered into the hash 
//                      table, because this implementation of a hash table
//                      does not have a handy way of iterating through it.
//
//----------------------------------------------------------------------------    
CGlyph::~CGlyph()                    
{
    RemoveGlyphTableContents ();
    delete _pchBeginDelimiter;
    delete _pchEndDelimiter;
    delete _pchEndLineDelimiter;
    delete _pchDefaultImgURL;
    delete _gHashTable;
    delete _XMLStack;
 
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::RemoveGlyphTableContents ()
//
//  Synopsis:   This method deletes all of the CGlyphTreeType structures
//              that we have. It begins by popping the entire stack 
//              of data that is contained in the hash table, and then
//              iterates through the static array which is reserved for
//              the known tags.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::RemoveGlyphTableContents ()
{
    CGlyphTreeType * XMLTree;
    int count;
 
    if (_XMLStack)
    {
        _XMLStack->Pop ((void**) &XMLTree);
        while (XMLTree)
        {
            delete XMLTree;
            _XMLStack->Pop ((void**) &XMLTree);
        }
    }
    for (count = 0; count <= ETAG_LAST; count++)
    {
        if ( _gIdentifiedTagArray [count] != NULL )
        {
            delete _gIdentifiedTagArray [count];
            _gIdentifiedTagArray [count] = NULL;
        }
    }
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ReplaceGlyphTableContents
//
//  Synopsis:   This public method is called to purge the glyph information
//              and reconstruct the new data given a BSTR input.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::ReplaceGlyphTableContents (BSTR inputStream)
{
    HRESULT hr;

    hr = THR( RemoveGlyphTableContents () );
    if (FAILED (hr))
        RRETURN (hr);
    hr = THR( ParseGlyphTable (inputStream, TRUE) );
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AddToGlyphTable
//
//  Synopsis:   This public method is used to insert new information
//              using a table formatted in a BSTR
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::AddToGlyphTable (BSTR inputStream)
{
    return ( ParseGlyphTable (inputStream, TRUE) );
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::RemoveFromGlyphTable 
//
//  Synopsis:   This public method is used to delete a rule from the table.
//              If this rule is not found ERROR_NOT_FOUND is returned.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::RemoveFromGlyphTable (BSTR inputStream)
{
    return ( ParseGlyphTable (inputStream, FALSE) );
}



HRESULT 
CGlyph::AddSynthesizedRule (const TCHAR imgName [], ELEMENT_TAG eTag, GLYPH_STATE_TYPE eState, GLYPH_POSITION_TYPE ePos, 
                            GLYPH_ALIGNMENT_TYPE eAlign, GLYPH_ORIENTATION_TYPE eOrient, PTCHAR tagName )
{
    HRESULT                 hr                  = S_OK;
    CGlyphInfoType *        gInfo               = NULL;
    TCHAR                   pchImgURL [256];

    hr = ConstructResourcePath(pchImgURL);
    if (hr)
        goto Cleanup;
        
    _tcscat (pchImgURL, imgName);

    gInfo = new CGlyphInfoType;
    if (gInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo->pImageContext = NULL;
    gInfo->width = gInfo->height = gInfo->offsetX = gInfo->offsetY = DEFAULT_GLYPH_SIZE;
    gInfo->pchImgURL = new TCHAR [_tcslen(pchImgURL)+1];
    if (!gInfo->pchImgURL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy (gInfo->pchImgURL, pchImgURL);
    if (tagName == NULL)
    {
        hr = THR( InsertIntoTable (gInfo, eTag, eState, eAlign, ePos, eOrient, TRUE) );
    }
    else
    {
        hr = THR( InsertIntoTable (gInfo, tagName, eState, eAlign, ePos, eOrient, TRUE) );
    }
    if (FAILED (hr))
    {
        delete gInfo;
        goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::Exec   
//
//  Synopsis:   This method is used to implement various IDM command executions.
//              Nothing too complicated, except that it also takes charge of 
//              informing text whether it has shifted from a no-info state
//              to a state where CGlyph needs to be querried for glyph info.   
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::Exec(
        GUID * pguidCmdGroup,
        UINT idm,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT                 hr          =   S_OK;

    switch (idm)
    {
    case IDM_SHOWALLTAGS:
        AddSynthesizedRule (_T("unknown.gif"), ETAG_NULL);
        hr = Exec (pguidCmdGroup, IDM_SHOWUNKNOWNTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
    case IDM_SHOWMISCTAGS:
        hr = Exec (pguidCmdGroup, IDM_SHOWALIGNEDSITETAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWSCRIPTTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWSTYLETAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWCOMMENTTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWAREATAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWUNKNOWNTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        hr = Exec (pguidCmdGroup, IDM_SHOWWBRTAGS, nCmdexecopt, pvarargIn, pvarargOut);
        if ( FAILED(hr) )
            break;
        AddSynthesizedRule (_T("abspos.gif"), ETAG_NULL, GST_DEFAULT, GPT_ABSOLUTE, GAT_DEFAULT, GOT_DEFAULT);
        break;
    case IDM_SHOWALIGNEDSITETAGS:
        AddSynthesizedRule (_T("leftalign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_LEFT, GOT_DEFAULT);
        AddSynthesizedRule (_T("centeralign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_CENTER, GOT_DEFAULT);
        AddSynthesizedRule (_T("rightalign.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_RIGHT, GOT_DEFAULT);
        break;
    case IDM_SHOWSCRIPTTAGS:
        AddSynthesizedRule (_T("script.gif"), ETAG_SCRIPT);
        break;
    case IDM_SHOWSTYLETAGS:
        AddSynthesizedRule (_T("style.gif"), ETAG_STYLE);
        break;
    case IDM_SHOWCOMMENTTAGS:
        AddSynthesizedRule (_T("comment.gif"), ETAG_COMMENT);
        AddSynthesizedRule (_T("comment.gif"), ETAG_RAW_COMMENT);
        break;
    case IDM_SHOWAREATAGS:
        AddSynthesizedRule (_T("area.gif"), ETAG_AREA);
        break;
    case IDM_SHOWUNKNOWNTAGS:
        AddSynthesizedRule (_T("unknown.gif"), ETAG_NULL, GST_DEFAULT, GPT_DEFAULT, GAT_DEFAULT, GOT_DEFAULT, DEFAULT_XML_TAG_NAME);
        break;
    case IDM_SHOWWBRTAGS:
        AddSynthesizedRule (_T("wordbreak.gif"), ETAG_WBR);
        AddSynthesizedRule (_T("br.gif"), ETAG_BR);
        break;
    case IDM_EMPTYGLYPHTABLE:
        {
            hr = THR(RemoveGlyphTableContents ());
            break;
        }
    case IDM_ADDTOGLYPHTABLE:
        if (!pvarargIn->bstrVal)
            break;
        hr = THR( AddToGlyphTable (pvarargIn->bstrVal) );
        break;
    case IDM_REMOVEFROMGLYPHTABLE:
        if (!pvarargIn->bstrVal)
            break;
        hr = THR( RemoveFromGlyphTable (pvarargIn->bstrVal) );
        break;
    case IDM_REPLACEGLYPHCONTENTS:
        if (!pvarargIn->bstrVal)
           break;
        hr = THR( ReplaceGlyphTableContents (pvarargIn->bstrVal) );
        break;
    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
    }
    
    RRETURN (hr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ParseGlyphTable 
//
//  Synopsis:   This is the main method in the glyph table parsing from 
//              a BSTR. It begins by setting a PTCHAR that will walk 
//              down the BSTR as we are parsing it. Then, it enters a 
//              while loop until it runs into the end of the BSTR. 
//              Within the While loop, we first need to decide whether the
//              first entry is a tag ID or a tag name. If the first entry 
//              consists only of decimals, we conclude that is is a tag ID,
//              Then, we dispatch the parsing of the rest of the rule 
//              accordingly.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::ParseGlyphTable (BSTR inputStream, BOOL addToTable)
{
    PTCHAR      pchInStream = inputStream;
    PTCHAR      pchThisSection;
    HRESULT     hr = S_OK;

    if (_tcslen (pchInStream) < _tcslen (_pchBeginDelimiter))
        goto Cleanup;
    pchInStream = _tcsstr (pchInStream, _pchBeginDelimiter);
    while (pchInStream)
    {
        GetThisSection (pchInStream, pchThisSection);
        if (pchThisSection == NULL)    //If the tag ID/name field is empty, we make it default
        {
            pchThisSection = new TCHAR [5];
            if (!pchThisSection)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _itot (ETAG_UNKNOWN, pchThisSection, 10);
        }
        if (_tcsspn (pchThisSection, DECIMALS) == _tcsclen(pchThisSection))   //If this rule specifies a tag ID
        {
            IDParse (pchInStream, pchThisSection, addToTable);    
        }
        else    //If this rule specifies a tag name
        {
            XMLParse (pchInStream, pchThisSection, addToTable);
        }
        delete pchThisSection;
        // Goto next rule
        if (pchInStream)           
            pchInStream = _tcsstr (pchInStream, _pchEndLineDelimiter);
        if (pchInStream)
            pchInStream = pchInStream + _tcsclen (_pchEndLineDelimiter);
        if (pchInStream)
            pchInStream = _tcsstr (pchInStream, _pchBeginDelimiter);
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::ParseBasicInfo 
//
//  Synopsis:   This method parses the basic Glyph info which is common
//              to both tags with identified ID's and others (i.e. XML's).
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::ParseBasicInfo (PTCHAR & pchInStream, BasicGlyphInfoType & newRule)
{
    HRESULT             hr = S_OK;
    LONG                temp;

    //Initialize the Fields
    newRule.eState = GST_DEFAULT;
    newRule.eAlign = GAT_DEFAULT;
    newRule.ePos = GPT_DEFAULT;
    newRule.eOrient = GOT_DEFAULT;
    newRule.width = newRule.height = newRule.offsetX = newRule.offsetY = DEFAULT_GLYPH_SIZE;

    GetThisSection (pchInStream, newRule.pchImgURL);
    if (newRule.pchImgURL == NULL)
    {
        newRule.pchImgURL = new TCHAR [_tcsclen(_pchDefaultImgURL)+1];
        if (!newRule.pchImgURL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(newRule.pchImgURL, _pchDefaultImgURL);
        goto Cleanup;
    }


    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eState  =   (GLYPH_STATE_TYPE)          temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eAlign  =   (GLYPH_ALIGNMENT_TYPE)      temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.ePos    =   (GLYPH_POSITION_TYPE)       temp;

    if (!NextIntSection (pchInStream, temp))
        goto Cleanup;
    newRule.eOrient =   (GLYPH_ORIENTATION_TYPE)    temp;

    if (!NextIntSection (pchInStream, newRule.width))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.height))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.offsetX))
        goto Cleanup;
    if (!NextIntSection (pchInStream, newRule.offsetY))
        goto Cleanup;

Cleanup:
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::IDParse 
//
//  Synopsis:   This nethod takes care of the parsing of rules where the
//              tag is identified by its ID. It begins by setting the 
//              correct tag ID, and then parsing the rest of the info
//              which is common to rules with ID's and names, and finally
//              enters the information.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::IDParse (PTCHAR & pchInStream, PTCHAR & pchThisSection, BOOL addToTable)
{
    HRESULT             hr;
    PTCHAR              pchTagName;
    ELEMENT_TAG_ID      tagID = (ELEMENT_TAG_ID)  _ttol(pchThisSection);
    extern ELEMENT_TAG  ETagFromTagId ( ELEMENT_TAG_ID tagID );

    if (   tagID <= TAGID_NULL
        || tagID == TAGID_UNKNOWN
        || tagID >= TAGID_COUNT
       )
    {
        hr = THR( _pDoc->GetNameForTagID (tagID, &pchTagName));
        if (hr || !pchTagName)
            goto Cleanup;
        hr = THR( XMLParse (pchInStream, pchTagName, addToTable) );
    }
    else
    {
        IDGlyphTableType    newRule;
        hr = THR( ParseBasicInfo (pchInStream, newRule.basicInfo) ); 
        if (hr)
            goto Cleanup;
        newRule.eTag = ETagFromTagId(tagID);
        hr = THR( NewEntry (newRule, addToTable) );
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::XMLParse 
//
//  Synopsis:   This nethod takes care of the parsing of rules where the
//              tag is identified by its name. It begins by setting the 
//              correct tag name, and then parsing the rest of the info
//              which is common to rules with ID's and names, and finally
//              enters the information.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::XMLParse (PTCHAR & pchInStream, PTCHAR & pchThisSection, BOOL addToTable)
{
    XMLGlyphTableType   newRule;
    HRESULT             hr;

    newRule.pchTagName = new TCHAR [_tcsclen(pchThisSection)+1];
    if (!newRule.pchTagName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcscpy(newRule.pchTagName, pchThisSection);
    hr = THR( ParseBasicInfo (pchInStream, newRule.basicInfo) ); 
    if (hr)
        goto Cleanup;
    hr = THR( NewEntry (newRule, addToTable) );

Cleanup:
    delete newRule.pchTagName;
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::NextIntSection 
//
//  Synopsis:   This method parses between a _pchBeginDelimiter and _pchEndDelimiter,
//              expecting to find an integer there. If this section is not 
//              empty, the 'result' parameter is set to the integer 
//              translation of the string, and TRUE is returned. If not,
//              'result' is left unchanges, and FALSE is returned.
//  
//              Note:   Both the return value and the setting of
//                      'result' are used by 'ParseBasicInfo,' depending
//                      on whether we need to typecase a dummy variable.
//
//----------------------------------------------------------------------------
BOOL
CGlyph::NextIntSection (PTCHAR & pchInStream, LONG & result)
{
    PTCHAR  pchThisSection  = NULL;
    BOOL    f_rVal          = FALSE;

    if (pchInStream == NULL) // We leave and the default value remains
    {
        goto Cleanup;
    }
    GetThisSection (pchInStream, pchThisSection);
    if (pchThisSection == NULL)
    {
        goto Cleanup;
    }
    result = _ttol(pchThisSection);
    f_rVal = TRUE;

Cleanup:
    delete pchThisSection;
    return (f_rVal);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetThisSection 
//
//  Synopsis:   This method is used to retrieve a section in the input 
//              stream that we are parsing. What is does is localize the
//              the next input field, and then constructs a TCHAR string
//              out of that.
//  
//              Note:   In case the caller does not need to preserve 
//                      'newString', the latter should be deleted 
//                      when no longer need by the caller.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetThisSection (PTCHAR & pchSectionBegin, PTCHAR & pchNewString)
{
    PTCHAR      pchSectionEnd;
    PTCHAR      pchRuleEnd;
    int         beginLen;
    int         endLen;
    HRESULT     hr = S_OK;

    AssertSz(pchSectionBegin, "Parser Should Have Popped Out Before Passing In a Null"); 
    pchNewString = NULL;
    pchRuleEnd      = _tcsstr (pchSectionBegin, _pchEndLineDelimiter);
    if (!pchRuleEnd)    //  Messed up syntax - Try to recover cleanly
    {
        goto Cleanup;
    }
    pchSectionEnd = _tcsstr (pchSectionBegin, _pchBeginDelimiter);
    if (!pchSectionEnd || pchRuleEnd < pchSectionEnd)    // The next non-empty field is for another rule 
    {
        goto Cleanup;
    }

    // Now, we can begin
    pchSectionBegin = pchSectionEnd;
    beginLen = _tcsclen(pchSectionBegin);
    AssertSz (pchSectionBegin && CompareUpTo (pchSectionBegin, _pchBeginDelimiter, _tcsclen(_pchBeginDelimiter)) == 0, "Illegal Input Stream");
    pchSectionBegin = pchSectionBegin + _tcsclen (_pchBeginDelimiter);
    if (!pchSectionBegin)
    {
        goto Cleanup;
    }
    pchSectionEnd = _tcsstr (pchSectionBegin, _pchEndDelimiter);
    if (!pchSectionEnd)
    {
        goto Cleanup;
    }
    beginLen = _tcsclen(pchSectionBegin);
    endLen = _tcsclen(pchSectionEnd);
    if (beginLen == endLen) //Check if this field is empty
    {
        goto Cleanup;
    }
    pchNewString = new TCHAR [beginLen-endLen+1];
    if (!pchNewString)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _tcsncpy (pchNewString, pchSectionBegin, beginLen-endLen);
    pchNewString[beginLen-endLen] = '\0';
    pchSectionBegin = pchSectionEnd + _tcsclen (_pchEndDelimiter);
    
Cleanup:
    return (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CompareUpTo 
//
//  Synopsis:   This method return TRUE or FALSE depending on whether 
//              two strings are identical up to a certain number of 
//              characters.
//
//----------------------------------------------------------------------------
int
CGlyph::CompareUpTo (PTCHAR first, PTCHAR second, int numToComp)
{
    int count;
    int firstLen = _tcslen (first);
    int secondLen = _tcslen (second);

    for (count = 0; count < numToComp; count++)
        if (((count >= firstLen) || (count >= secondLen)) || (first[count] != second[count]))
            break;
    if (count == numToComp)
        return 0;
    else return 1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InitGInfo 
//
//  Synopsis:   Creates a CGlyphInfoType and sets it to its default values,
//              specified in basicInfo.
//  
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InitGInfo (pCGlyphInfoType & gInfo, BasicGlyphInfoType & basicInfo)
{
    HRESULT hr = NOERROR;

    gInfo = new CGlyphInfoType;
    if (gInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo->pImageContext    = NULL;
    gInfo->pchImgURL           = basicInfo.pchImgURL;
    gInfo->width            = basicInfo.width;
    gInfo->height           = basicInfo.height;
    gInfo->offsetX          = basicInfo.offsetX;
    gInfo->offsetY          = basicInfo.offsetY;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::NewEntry
//
//  Synopsis:   This version of NewEntry is used to enter a new struct into
//              the database of Glyph info, where the name of a tag has been
//              specified.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::NewEntry (XMLGlyphTableType & gTableElem, BOOL addToTable )
{
    HRESULT         hr = S_OK;
    CGlyphInfoType * gInfo;

    hr = THR( InitGInfo (gInfo, gTableElem.basicInfo) );
    if ( FAILED (hr) )
        goto Cleanup;
    hr = THR( InsertIntoTable (gInfo, gTableElem.pchTagName, gTableElem.basicInfo.eState, gTableElem.basicInfo.eAlign, 
        gTableElem.basicInfo.ePos, gTableElem.basicInfo.eOrient, addToTable) );
    if (!addToTable)
        delete gInfo;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     
//
//  Synopsis:   This version of NewEntry is used to enter a new struct into
//              the database of Glyph info, where the tag is identified
//              by its tag ID.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::NewEntry(IDGlyphTableType & gTableElem, BOOL addToTable)
{
    HRESULT hr = NOERROR;

    CGlyphInfoType * gInfo;
    hr = THR( InitGInfo (gInfo, gTableElem.basicInfo) );
    if ( FAILED (hr) )
        goto Cleanup;
    hr = THR( InsertIntoTable (gInfo, gTableElem.eTag, gTableElem.basicInfo.eState, gTableElem.basicInfo.eAlign, 
        gTableElem.basicInfo.ePos, gTableElem.basicInfo.eOrient, addToTable) );

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InsertIntoTable 
//
//  Synopsis:   This method adds a new entry into the database of 
//              CGlyphInfoTypes when the tag has been identified by its name.
//              First, if the tag name is empty, or null it is set to the 
//              default value of ETAG_NULL. Next, if we attempt to resolve 
//              this tag name with a tag ID. If we have been able to attach
//              the tag name with an ID, we enter the new info into the
//              static array that contains info for tags with identified
//              ID's. If that is not the case, we enter the info into
//              the hash table which is reserved for tags that we can 
//              not resolve into an ID.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InsertIntoTable (CGlyphInfoType * gInfo, PTCHAR pchTagName, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                         GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient,
                         BOOL addToTable)
{
    CGlyphTreeType *    infoTable;
    HRESULT             hr;

    ELEMENT_TAG         eTag;
    hr = THR( AttemptToResolveTagName (pchTagName, eTag) );
    if (FAILED (hr))
    {
        delete gInfo;
        goto Cleanup;
    }
    
    if ( !IsGenericTag (eTag) && _tcscmp (pchTagName, DEFAULT_XML_TAG_NAME) != 0 && !(eTag == NULL))
    {
        hr = THR( InsertIntoTable (gInfo, eTag, eState, eAlign, ePos, eOrient, addToTable) );
        goto Cleanup;
    }

    infoTable = _gHashTable->GetCi(pchTagName);

    if (infoTable == NULL)
    {
        infoTable = new CGlyphTreeType();
        if (infoTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        hr = THR( _gHashTable->SetCi (pchTagName, infoTable) );
        if (FAILED (hr) )
        {
            delete infoTable;
            goto Cleanup;
        }
        _XMLStack->Push ((void**)infoTable);
    }
    if (infoTable != NULL)
    {
        hr = THR( infoTable->AddRule (gInfo, eState, eAlign, ePos, eOrient, addToTable, this) );
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InsertIntoTable 
//
//  Synopsis:   This method enters a CGlyphInfoType struct into the static
//              array. If ever an unidentified tag ID is passed in, 
//              this entry is ignored.
//  
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InsertIntoTable (CGlyphInfoType * gInfo, ELEMENT_TAG eTag, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                         GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient,
                         BOOL addToTable)
{
    CGlyphTreeType *    infoTable;
    HRESULT             hr = S_OK;

    if (eTag >= ETAG_LAST)
    {
        delete gInfo;
        goto Cleanup;
    }
    if (_gIdentifiedTagArray[eTag] == NULL)
    {
        infoTable = new CGlyphTreeType();
        if (infoTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _gIdentifiedTagArray[eTag] = infoTable;
    }
    else 
    {
        infoTable = _gIdentifiedTagArray[eTag];
    }
    if (infoTable != NULL)
    {
        hr = THR( infoTable->AddRule (gInfo, eState, eAlign, ePos, eOrient, addToTable, this) );
    }

Cleanup:
    RRETURN (hr);

}







//+---------------------------------------------------------------------------
//
//  Member:     CALLBACK OnImgCtxChange
//
//  Synopsis:   This is the callback function that is used to invalidate 
//              the page when a new image has finished downloading for the 
//              first time.
//
//----------------------------------------------------------------------------
void CALLBACK 
CGlyph::OnImgCtxChange( VOID * pvImgCtx, VOID * pv )
{
    ((CDoc *)pv)->GetView()->Invalidate();
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::InitRenderTagInfo 
//
//  Synopsis:   None
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::InitRenderTagInfo (CGlyphRenderInfoType * renderTagInfo)
{
    HRESULT hr = S_OK;

    if (renderTagInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    renderTagInfo->pImageContext = NULL;
    renderTagInfo->width = 0;
    renderTagInfo->height = 0;
    renderTagInfo->offsetX = 0;
    renderTagInfo->offsetY = 0;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CompleteInfoProcessing 
//
//  Synopsis:   Once the CGlyphInfoType structure has been found, this method
//              is used to set up the information to send it back to 
//              rendering.
//  
//              Note:   This method unfifes the code path for XML and normal
//                      tags.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CompleteInfoProcessing (CGlyphInfoType * localInfo, CGlyphRenderInfoType * pTagInfo, void * invalidateInfo)
{
    HRESULT hr = S_OK;

    AssertSz (localInfo, "This point should only be reached if a valid query was made");
        
    // Bitmap handle has not been loaded yet
    // i.e. this is the first time this image is requested
    if (localInfo->pImageContext == NULL) 
    {
         hr = THR( GetImageContext (localInfo, invalidateInfo, localInfo->pImageContext) );
         if (FAILED (hr) )
             goto Cleanup;
    }
    pTagInfo->pImageContext = localInfo->pImageContext;
    pTagInfo->width = localInfo->width;
    pTagInfo->height = localInfo->height;
    pTagInfo->offsetX = localInfo->offsetX;
    pTagInfo->offsetY = localInfo->offsetY;

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AttemptToResolveTagName 
//
//  Synopsis:   Retrieves that tag info given a tag name. If the tag name
//              is resolvable into an ID. the the codepath goes to the ID-
//              identified glyphs. If not, we go on to looking in the hash
//              table.
//  
//              Note:   The attempt to resolve tag names into ID's is the 
//                      same as the point where new info is entered.
//
//----------------------------------------------------------------------------
    

HRESULT
CGlyph::AttemptToResolveTagName (PTCHAR pchTagName, ELEMENT_TAG & eTag)
{
    HRESULT hr  = S_OK;

    AssertSz (pchTagName, "Tag name cannot be NULL");
    eTag = ETAG_NULL;
    if (pchTagName == NULL)
    {
        eTag = ETAG_UNKNOWN;
    }
    else
    {
        //
        // If the name has a colon in it - assume it's an XML namespace tag.
        //
        if ( _tcsstr( pchTagName, _T(":") ) > 0 )
        {
            eTag = ETAG_GENERIC;
        }
        else
            eTag = EtagFromName (pchTagName, _tcslen(pchTagName));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetTagInfo 
//
//  Synopsis:   Retrieves that tag info given a ptp. It first searches for
//              a location in the data where the the ID's resolve (an entry
//              for the specific tag or an entry for the dafaults). Then,
//              if we can find the info, the return struct is set.
//  
//              Note:   The attempt to resolve tag names into ID's is the 
//                      same as the point where new info is entered.
//
//----------------------------------------------------------------------------



HRESULT
CGlyph::GetTagInfo (CTreePos * ptp, GLYPH_ALIGNMENT_TYPE eAlign, 
                    GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, 
                    void * invalidateInfo, CGlyphRenderInfoType * pTagInfo)
{  
    CGlyphTreeType *            infoTree        = NULL;
    CGlyphInfoType *            localInfo       = NULL;
    HRESULT                     hr              = S_OK;
    ELEMENT_TAG                 eTag;
    GLYPH_STATE_TYPE            eState;
    CTreeNode *                 pNode;

    pTagInfo->pImageContext = NULL;

    if ( !ptp || !ptp->IsNode() )
        goto Cleanup;
    
    pNode = ptp->Branch ();
    eTag = pNode->Tag();

    //
    // HACKHACK: ETAG_COMMENT can turn into ETAG_RAW_COMMENT.  The parser
    // guys don't understand why but don't want to change it.  So, we need to 
    // unify these so that all comments render glyphs (bug 100991)
    //

    if (eTag == ETAG_RAW_COMMENT)
    {
        eTag = ETAG_COMMENT;        
    }

    if (  (eTag == ETAG_NULL)
        || !ptp->IsEdgeScope()
        || (   ptp->IsEndNode()
            && pNode->Element()->IsNoScope()
           )
       )
        goto Cleanup;

    eState = (GLYPH_STATE_TYPE)!(ptp->IsBeginElementScope());
    if (eTag == ETAG_UNKNOWN || IsGenericTag (eTag))        //. If it is a generic (i.e. known XML tag), we go off to the XML tag search path
    {
        hr = THR( GetXMLTagInfo (ptp, eState, eAlign, ePos, eOrient, invalidateInfo, pTagInfo) );
        goto Cleanup;
    }

    infoTree = _gIdentifiedTagArray[eTag];  // First, we try to see if we have info for this specific tag
    if (infoTree)
    {
        hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
        if (FAILED (hr))
            goto Cleanup;
    }
    
    if (!localInfo) // If we don't have info for the specific tag
    {
        infoTree = _gIdentifiedTagArray[ETAG_UNKNOWN];  // We first try the ETAG default
        if (infoTree)
        {
            hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
        if (!localInfo)
        {
            hr = THR( AttemptFinalDefault (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
    }

    if (!localInfo)
        goto Cleanup;

    hr = THR( CompleteInfoProcessing (localInfo, pTagInfo, invalidateInfo) );

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetTagInfo 
//
//  Synopsis:   Retrieves that tag info given an ptp, and knowing that it 
//              point to a generic tag.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetXMLTagInfo (CTreePos * ptp, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, 
                    GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, 
                    void * invalidateInfo, CGlyphRenderInfoType * pTagInfo)
{  
    CGlyphTreeType *            infoTree        = NULL;
    CGlyphInfoType *            localInfo       = NULL;
    CElement*                   pElement;
    HRESULT                     hr              = S_OK;
    TCHAR                       *strLookupName  = NULL;
    size_t                      strLen;
    

    if (!ptp->Branch())
        goto Cleanup;
    pElement = ptp->Branch()->Element();

    //
    // Construct a string that is NameSpace:TagName
    //
    if (pElement->Namespace())
    {
        strLen = _tcslen(pElement->Namespace()) + _tcslen(_T(":")) + _tcslen(pElement->TagName()) + 1 /* term */;
        strLookupName = new TCHAR[strLen];
        if (!strLookupName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strLookupName, pElement->Namespace());
        _tcscat(strLookupName, _T(":") );
        _tcscat(strLookupName, pElement->TagName() );
    }
    else
    {
        strLen = _tcslen(pElement->TagName()) + 1 /* term */;
        strLookupName = new TCHAR[strLen];
        if (!strLookupName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strLookupName, pElement->TagName());
    }
    
    infoTree = _gHashTable->GetCi( strLookupName ); // Attempt to find entry for specific XML tag
    if (infoTree)
    {
        hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
        if (FAILED (hr))
            goto Cleanup;
    }


    if (!localInfo) // Attempt to find default entry for all XML's
    {
        infoTree = _gHashTable->GetCi(DEFAULT_XML_TAG_NAME);
        if (infoTree)
        {
            hr = THR( infoTree->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
        if (!localInfo) // Attempt final default for all tags (ETAGS and XMLs)
        {
            hr = THR( AttemptFinalDefault (ptp, localInfo, eState, eAlign, ePos, eOrient) );
            if (FAILED (hr))
                goto Cleanup;
        }
    }

    if (!localInfo)
        goto Cleanup;

    hr = THR( CompleteInfoProcessing (localInfo, pTagInfo, invalidateInfo) );

Cleanup:
    if (strLookupName)
        delete[] strLookupName;
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::AttemptFinalDefault 
//
//  Synopsis:   This is the final default condition, where we tet if the table
//              contains an entry for ETAG_NULL, which is the final default
//              that everything falls through to.
//  
//----------------------------------------------------------------------------
HRESULT
CGlyph::AttemptFinalDefault (CTreePos * ptp, pCGlyphInfoType & localInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                             GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient)
{
    CGlyphTreeType *    infoTable   = NULL;
    HRESULT             hr          = S_OK;

    infoTable = _gIdentifiedTagArray[ETAG_NULL];
    if (infoTable)
        hr = THR( infoTable->GetGlyphInfo (ptp, localInfo, eState, eAlign, ePos, eOrient) );

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::GetImageContext 
//
//  Synopsis:   Creates the image context, and sets the callback function
//              after having created the invalidation stack and mande the 
//              first entry to it.   
//  
//              Note:   We pass in a pointer to the gInfo into the callback.
//                      This is an elegant way of keeping track of what needs
//                      to be invalidated when an image is done loading,
//                      because whenever we want to display an image and it
//                      is not loaded, we know the CGlyphInfoType, so we 
//                      can add the invalidation info in the stack.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::GetImageContext (CGlyphInfoType * gInfo, void * pvCallback, pIImgCtx & newImageContext)
{
    HRESULT     hr      = S_OK;

    newImageContext = NULL;
    hr = THR( CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (LPVOID*)&newImageContext) );
    if (SUCCEEDED(hr))
    {
        hr = THR( newImageContext->Load(gInfo->pchImgURL, IMGCHG_COMPLETE) );
        if ( SUCCEEDED( hr ))
        {
            hr = THR( newImageContext->SetCallback( OnImgCtxChange, _pDoc ) );
        }
        if ( SUCCEEDED( hr ))
        {
            hr = THR( newImageContext->SelectChanges( IMGCHG_COMPLETE, 0, TRUE) );
        }
        if ( FAILED( hr ))
        {
            newImageContext->Release();
            return hr;
        }
    }           

    RRETURN (hr); 
}




//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::CGlyphTreeType 
//
//  Synopsis:   Creates the frst level of the tree and initializes it.
//  
//----------------------------------------------------------------------------
CGlyph::CGlyphTreeType::CGlyphTreeType ()
{
    _infoTree = new CTreeList (s_levelSize [0]);
    if (_infoTree == NULL)
    {
        goto Cleanup;
    }

Cleanup:
    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::~CGlyphTreeType 
//
//----------------------------------------------------------------------------
CGlyph::CGlyphTreeType::~CGlyphTreeType ()
{
    delete _infoTree;
}






//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::TransformInfoToArray
//
//  Synopsis:   Converts glyph access information into indexes along the
//              the various levels of the tree.
//  
//              Note:   This is one of the only two methods that needs to be changed to
//                      modify the searching priority.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CGlyphTreeType::TransformInfoToArray (GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign, GLYPH_POSITION_TYPE ePos, 
                                     GLYPH_ORIENTATION_TYPE eOrient, int indexArray [])
{
    indexArray [TREEDEPTH_STATE]            = eState;
    indexArray [TREEDEPTH_POSITIONINING]    = ePos;
    indexArray [TREEDEPTH_ALIGNMENT]        = eAlign;
    indexArray [TREEDEPTH_ORIENTATION]      = eOrient;
    return (S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::ComputeLevelIndex
//
//  Synopsis:   Takes a ptpt and retrieves the specific details that are 
//              are needed to iterate through the next level in the tree.
//              This allows us to querry for specific info from the 
//              CTreePos only as needed.
//
//----------------------------------------------------------------------------
HRESULT
CGlyph::CGlyphTreeType::ComputeLevelIndex (CTreePos * ptp, int index [], int levelCount)
{
    HRESULT             hr          = S_OK;
    CTreeNode *         pNode       = ptp->Branch ();
    htmlControlAlign    alignment;
    CFlowLayout *       pLayout;
    LCID                curKbd;

    AssertSz ((levelCount >= 0) && (levelCount < NUM_INFO_LEVELS), "levelCount needs to be within bounds");
    AssertSz (index [levelCount] == COMPUTE, "index [levelCount] == COMPUTE is why we called this in the first place");

    switch (levelCount)
    {
    case TREEDEPTH_STATE : 
        if ( ptp->IsEndElementScope () )
            index [levelCount] = GST_CLOSE;
        else
            index [levelCount] = GST_OPEN;
        break;
    case TREEDEPTH_POSITIONINING : 
        if ( pNode->IsPositionStatic () )
            index [levelCount] = GPT_STATIC;
        else if ( pNode->IsAbsolute () )
            index [levelCount] = GPT_ABSOLUTE;
        else if ( pNode->IsRelative () )
            index [levelCount] = GPT_RELATIVE;
        else 
            index [levelCount] = GPT_DEFAULT;
        break;
    case TREEDEPTH_ALIGNMENT:
        alignment   = pNode->GetSiteAlign ();

        if ( alignment == htmlBlockAlignLeft )
            index [levelCount] = GAT_LEFT;
        else if ( alignment == htmlBlockAlignCenter )
            index [levelCount] = GAT_CENTER;
        else if ( alignment == htmlBlockAlignRight )
            index [levelCount] = GAT_RIGHT;
        else 
            index [levelCount] = GAT_DEFAULT;
        break;
    case TREEDEPTH_ORIENTATION:
        pLayout     = pNode->GetFlowLayout();
        if (!pLayout)
        {
            index [levelCount] = GOT_DEFAULT;
            break;
        }
        curKbd      = LOWORD(GetKeyboardLayout(0));

        if(IsRtlLCID(curKbd))       // RIGHT-LEFT
           index [levelCount] = GOT_RIGHT_TO_LEFT;
        else 
           index [levelCount] = GOT_LEFT_TO_RIGHT;
        break;
    default:
        AssertSz (0, "We should always be at a level that we know about and can resolve");
    }
    
    return (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::AddRule
//              CGlyph::CGlyphTreeType::InsertIntoTree
//
//  Synopsis:   This method adds a new rule (CGlyphInfoType struct) into
//              a tree. It searches for the location, creating levels 
//              if necessary, and inserting the new info.
//  
//              Note:   Rules that map on to the same location are resolved
//                      by deleting the old rule and replacing it by the new
//                      one. This allows for a handy way of overwriting
//                      a rule.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::CGlyphTreeType::AddRule (CGlyphInfoType * gInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                  GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient, BOOL addToTable, CGlyph * glyphTable)
{
    int indexArray [NUM_INFO_LEVELS];
    HRESULT     hr = S_OK;

    TransformInfoToArray (eState, eAlign, ePos, eOrient, indexArray);
    hr = THR( InsertIntoTree (gInfo, indexArray, addToTable, glyphTable) );
    if (hr == S_OK)
        glyphTable->_pDoc->ForceRelayout();
    RRETURN (hr);
}


HRESULT
CGlyph::CGlyphTreeType::InsertIntoTree (CGlyphInfoType * gInfo, int index [], BOOL addToTable, CGlyph * glyphTable)
{
    int         levelCount;
    CTreeList *     thisLevel = _infoTree;
    CTreeList *     newLevel;
    HRESULT     hr = S_OK;
    
    for (levelCount = 0; levelCount < NUM_INFO_LEVELS-1; levelCount ++)
    {
        if ((*thisLevel)[index[levelCount]] == NULL)
        {
            if (!addToTable)
            {
                goto Cleanup;
            }
            newLevel = new CTreeList(s_levelSize[levelCount+1]);
            if (newLevel == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            (*thisLevel)[index[levelCount]] = newLevel;
        }
        else 
        {
            newLevel = DYNCAST(CTreeList, (*thisLevel)[index[levelCount]]);    
        }
        thisLevel = newLevel;
    }
    // Rule collisions are handled by preserving the last one
    if ((*thisLevel)[index[levelCount]] != NULL)
    {
        delete (*thisLevel)[index[levelCount]]; 
        (*thisLevel)[index[levelCount]] = NULL;
    }
    else if (!addToTable)       //Tried to delete non-existing rule
    {
        goto Cleanup;
    }
    if (addToTable)
    {
        (*thisLevel)[index[levelCount]] = gInfo;
    }

Cleanup:
    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGlyph::CGlyphTreeType::GetGlyphInfo
//              CGlyph::CGlyphTreeType::GetFromTree
//
//  Synopsis:   Retrieves the pointer to a CGlyphInfoType struct from a tree.
//              The search performed is depth-first. We begin by looking 
//              for the exact rule specified, and as we climb back up
//              We try each default.
//
//----------------------------------------------------------------------------
HRESULT 
CGlyph::CGlyphTreeType::GetGlyphInfo (CTreePos * ptp, pCGlyphInfoType & gInfo, GLYPH_STATE_TYPE eState, GLYPH_ALIGNMENT_TYPE eAlign,
                             GLYPH_POSITION_TYPE ePos, GLYPH_ORIENTATION_TYPE eOrient)
{
    int indexArray [NUM_INFO_LEVELS];
    HRESULT     hr = S_OK;

    TransformInfoToArray (eState, eAlign,  ePos, eOrient, indexArray);
    hr = THR( GetFromTree (ptp, gInfo, indexArray) );
    RRETURN (hr);
}


HRESULT
CGlyph::CGlyphTreeType::GetFromTree (CTreePos * ptp, pCGlyphInfoType & gInfo, int index [])
{
    int         levelCount = 0;
    CTreeObject *  thisLevel = DYNCAST(CTreeList, _infoTree);
    HRESULT     hr = S_OK;
    CList *     traversalStack = new CList;

    if (!traversalStack)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    gInfo = NULL;
    while ((levelCount < NUM_INFO_LEVELS) || ((thisLevel==NULL) && levelCount > 0))
    {
        if (index[levelCount] == COMPUTE)
        {
            hr = THR( ComputeLevelIndex (ptp, index, levelCount));
        }

        if ( FAILED( hr ) )
            goto Cleanup;

        if (thisLevel == NULL)
        {
            traversalStack->Pop((void**)(&thisLevel));
            levelCount --;
            if (thisLevel == NULL)
            {
                goto Cleanup;
            }
            if (index[levelCount] == s_levelSize[levelCount]-1)
            {
                thisLevel = NULL;
            }
            else 
            {
                index[levelCount] = s_levelSize[levelCount]-1;
            }
        }
        else
        {
            traversalStack->Push ((void**)thisLevel);
            thisLevel = ( *DYNCAST(CTreeList, thisLevel) ) [index[levelCount]];
            if (thisLevel && thisLevel->IsInfoType ())
            {
                gInfo =  DYNCAST(CGlyphInfoType, thisLevel); 
                goto Cleanup;
            }
            levelCount ++;
        }
    }

Cleanup:
    delete traversalStack;
    return hr;
}
            





CGlyph::CList::CList ()
{
    _elemList = NULL;
}

CGlyph::CList::~CList ()
{
    void * dummy;

    while (_elemList != NULL)
    {
        Pop (&dummy);
    }
}


HRESULT 
CGlyph::CList::Push (void * pushed)
{
    ListElemType * newElem = new ListElemType;

    if (newElem == NULL)
        return E_OUTOFMEMORY;

    newElem->elem = pushed;
    newElem->next = _elemList;
    _elemList = newElem;
    return (S_OK);
}

HRESULT 
CGlyph::CList::Pop (void ** popped)
{
    ListElemType * toDelete = _elemList;

    if (_elemList == NULL)
    {
        *popped = NULL;
        goto Cleanup;
    }
    *popped = _elemList->elem;
    _elemList = _elemList->next;
    delete toDelete;

Cleanup:
    return S_OK;
}



CGlyph::CTreeList::CTreeList (LONG numObjects)
{
    int count;

    _numObjects = numObjects;
    _nextLevel = new CTreeObject * [numObjects];
    if (!_nextLevel)
        return;
    for (count = 0; count < numObjects; count ++)
        _nextLevel [count] = NULL;
}
        
CGlyph::CTreeList::~CTreeList () 
{
    int count;

    for (count = 0; count < _numObjects; count ++)
        delete _nextLevel [count];
    delete _nextLevel; 
}

CGlyph::CTreeObject * & 
CGlyph::CTreeList::operator[](int index)
{
    static  CTreeObject * s_pNULL = NULL;
    AssertSz (s_pNULL == NULL, "Invalid Flag Set To NULL");

    if ((index >= 0) && (index < _numObjects))
        return (_nextLevel [index]);
    else
        return s_pNULL;
}


CGlyph::CGlyphInfoType::~CGlyphInfoType () 
{ 
    ReleaseInterface(pImageContext);
    delete pchImgURL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltcell.cxx ===
//  Microsoft Forms
    //  Copyright (C) Microsoft Corporation, 1994-1996
    //
    //  File:       ltcell.cxx
    //
    //  Contents:   Implementation of CTableCellLayout and related classes.
    //
    //----------------------------------------------------------------------------
    
    #include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
    
    #ifndef X_LTABLE_HXX_
    #define X_LTABLE_HXX_
    #include "ltable.hxx"
    #endif
    
    #ifndef X_LTCELL_HXX_
    #define X_LTCELL_HXX_
    #include "ltcell.hxx"
    #endif
    
    #ifndef X_LTROW_HXX_
    #define X_LTROW_HXX_
    #include "ltrow.hxx"
    #endif
    
    #ifndef X_DISPDEFS_HXX_
    #define X_DISPDEFS_HXX_
    #include "dispdefs.hxx"
    #endif
    
    #ifndef X_DISPNODE_HXX_
    #define X_DISPNODE_HXX_
    #include "dispnode.hxx"
    #endif
    
    ExternTag(tagTableRecalc);
    ExternTag(tagTableCalc);
    ExternTag(tagLayoutTasks);
    ExternTag(tagCalcSize);
    ExternTag(tagTableBorder);
    
    extern const WORD s_awEdgesFromTableFrame[htmlFrameborder+1];
    extern const WORD s_awEdgesFromTableRules[htmlRulesall+1];
    
    MtDefine(CTableCellLayout, Layout, "CTableCellLayout")
    MtDefine(CTableCellLayoutBreak_pv, ViewChain, "CTableLayoutBreak_pv");
    
    const CLayout::LAYOUTDESC CTableCellLayout::s_layoutdesc =
    {
        LAYOUTDESC_TABLECELL    |
        LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
    };
    
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::GetAutoSize, CTxtEdit
    //
    //  Synopsis:   Return if autosize
    //
    //  Returns:    TRUE if autosize
    //
    //-------------------------------------------------------------------------
    
    BOOL
    CTableCellLayout::GetAutoSize() const
    {
        return _fContentsAffectSize;
    }
    
    //-----------------------------------------------------------------------------
    //
    //  Member:     Notify
    //
    //  Synopsis:   Respond to a tree notification
    //
    //  Arguments:  pnf - Pointer to the tree notification
    //
    //-----------------------------------------------------------------------------
    void
    CTableCellLayout::Notify(
        CNotification * pnf)
    {
        if (Tag() == ETAG_CAPTION && pnf->IsType(NTYPE_ZERO_GRAY_CHANGE))
               return ;
    
        Assert(!pnf->IsReceived(_snLast));
    
        // ignore focus notifications
        Assert(pnf->Element() != ElementOwner()         ||
               (LayoutContext() && pnf->IsType(NTYPE_ELEMENT_RESIZE))   ||  //  Due to changing of nf type in PPV
               ElementOwner()->HasSlavePtr()            ||
               pnf->IsType(NTYPE_ELEMENT_REMEASURE)     ||
               pnf->IsType(NTYPE_DISPLAY_CHANGE)        ||
               pnf->IsType(NTYPE_VISIBILITY_CHANGE)     ||
               pnf->IsType(NTYPE_ELEMENT_MINMAX)        ||
               pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)  || 
               pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER)   ||      // TODO (112607, michaelw) remove this when ADORNERS is turned off
               IsInvalidationNotification(pnf));
    
        if (    pnf->Element() == ElementOwner()
            &&  pnf->IsType(NTYPE_ELEMENT_RESIZE)   )
        {
            Assert(LayoutContext());
            return ;
        }

        BOOL            fWasDirty = IsDirty() || IsSizeThis();
        CTable *        pTable    = Table();
        CTableLayout *  pTableLayout   = pTable
                                        ? pTable->TableLayoutCache()
                                        : NULL;
    
        //
        //  Stand-alone cells behave like normal text containers
        //
    
        if (!pTable)
        {
            super::Notify(pnf);
            return;
        }
    
        if (pnf->IsType(NTYPE_ELEMENT_MINMAX))
        {
            if (pTableLayout)
                pTableLayout->_fDontSaveHistory = TRUE;
        }
        //
        //  First, start with default handling
        //  (But prevent posting a layout request)
        //
    
        if (    (   pTableLayout
                &&  pTableLayout->CanRecalc())
            ||  (   !pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)
                &&  !pnf->IsType(NTYPE_RANGE_ENSURERECALC)))
        {
            CSaveNotifyFlags    snf(pnf);
    
            pnf->SetFlag(NFLAGS_DONOTLAYOUT);
            super::Notify(pnf);
            if (   IsEditable()
                && (     pnf->IsTextChange()
                     ||  pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                     ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                     ||  pnf->IsType(NTYPE_CHARS_RESIZE)))
            {
                pTableLayout->ResetMinMax();
            }
        }
    
        if ( pnf->IsType(NTYPE_DISPLAY_CHANGE) )
        {
            CElement *pElem = pnf->Element();
            if (   pElem == ElementOwner()
                || pElem->IsRoot())             // this case covers disply change on the style sheet. (bug #77806)
                                                // TODO (112607) : what we should really check here is if the style sheet display changes
                                                // and this is a cell's style, then call HandlePositionDisplayChnage()
            {
                HandlePositionDisplayChange();
            }
        }
        //
        //  Resize the cell if content has changed
        //
        //  (If the notification is not being forwarded, then take it over;
        //   otherwise, post a new, resize notification)
        //
        //  TODO (112607, brendand) : We could do better than this for "fixed" tables
        //
        if (   IsDirty()
            ||  (   pnf->IsType(NTYPE_ELEMENT_MINMAX)   // inside of me there is an element who needs to be min-maxed
                &&  !TestLock(CElement::ELEMENTLOCK_SIZING)
                &&  !pnf->Node()->IsAbsolute()))
        {
            Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    
            if (!fWasDirty)
            {
                Assert(!IsSizeThis());
    
                if (    pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED)
                    &&  pnf->IsHandled())
                {
                    pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                }
                else
                {
                    ElementOwner()->ResizeElement();
                }
            }
            // In databinding, if a row is added into the middle of a table, then it is not calced right away.
            // Instead it is left _fSizeThis (but with no layoutTask) and not included in the table height.
            // after the bind Event (and text injection) DataTransferServiced() allows the table to now calculate
            // the row but now we need a layout task to initiate the process.  Since the cell WAS dirty, most
            // notification code assumes that a task is alreay posted.  Here we need to do otherwise.
            // see bug 88896.  PERF - becarful here.
            else if (   pnf->IsTextChange()
                     && !pnf->Node()->IsAbsolute()
                     && !TestLock(CElement::ELEMENTLOCK_SIZING)
                     && IsDirty()
                     && pTableLayout 
                     && pTableLayout->CanRecalc()
    #ifndef NO_DATABINDING
                     && IsGenerated()
    #endif
                    )
            {
                ElementOwner()->SendNotification(NTYPE_ELEMENT_RESIZE);
            }
        }
    
    }
    
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::HandlePositionDisplayChange
    //
    //  Synopsis:   Process position/display property changes on the cell
    //
    //-------------------------------------------------------------------------
    
    void
    CTableCellLayout::HandlePositionDisplayChange()
    {
        CTable *pTable = Table();
        CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    
        if (pTableLayout)
        {
            BOOL fDoRowSpans = pTableLayout->IsTableLayoutCacheCurrent();
            // the reason I have introduced fDoRowSpans is to be able to do this function regardless if 
            // the layout cache state is current or not (think of the case where Column display attr is changed, 
            // and this function will be called for all the cells in this column (so all the rows will be covered anyway)).
            if (Tag() == ETAG_TD || Tag() == ETAG_TH)
            {
                CTableRow *pRow = Row();
                int iRowSpan = fDoRowSpans? TableCell()->RowSpan() : 1;
                Assert (iRowSpan >=1);
                while (pRow)
                {
                    // neigboring cells in the row need to update their caches
                    CTableRowLayout *pRowLayout = pRow->RowLayoutCache();
                    Assert (pRowLayout);
                    for (int i= ColIndex(); i < pRowLayout->_aryCells.Size(); i++)
                    {
                        CTableCell *pCell = pRowLayout->_aryCells[i];
                        if (IsReal(pCell))
                        {
                            if (fDoRowSpans)
                                iRowSpan = max(iRowSpan, pCell->RowSpan());
                            pCell->EnsureFormatCacheChange (ELEMCHNG_CLEARCACHES);
                        }
                    }
                    --iRowSpan;
                    if (iRowSpan)
                    {
                        Assert (fDoRowSpans);
                        pRow = pTableLayout->_aryRows[pTableLayout->GetNextRow(pRowLayout->RowPosition())];
                    }
                    else
                    {
                        pRow = NULL;
                    }
                }
            }
            pTableLayout->MarkTableLayoutCacheDirty();
            SetSizeThis( TRUE ); // all we want is to enusre disp node (ensure correct layer ordering).
            pTableLayout->Resize();
        }
        
        return;
    }
    
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::CalcSizeCore, CTableCellLayout
    //
    //  Synopsis:   Calculate the size of the object
    //
    //--------------------------------------------------------------------------
    DWORD
    CTableCellLayout::CalcSizeCore(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            return (CalcSizeCoreCSS1Strict(pci, psize, psizeDefault));
        }

        return (CalcSizeCoreCompat(pci, psize, psizeDefault));
    }
    
    DWORD
    CTableCellLayout::CalcSizeCoreCompat(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        TraceTagEx((tagCalcSize, TAG_NONAME, "+(CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

        CSaveCalcInfo   sci(pci, this);
        CScopeFlag      csfCalcing(this);
        DWORD           grfReturn;
        int             cx = psize->cx;
        CTable        * pTable;
        CTableLayout  * pTableLayout;
        CDisplay      * pdp = GetDisplay();
        CTreeNode     * pNodeSelf = GetFirstBranch();
        const CCharFormat * pCF   = pNodeSelf->GetCharFormat(LC_TO_FC(LayoutContext()));
        const CFancyFormat * pFF  = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
        ELEMENT_TAG     etag = Tag();
        BOOL            fIgnoreZeroWidth = FALSE;
        BOOL            fFixedSizeCell = FALSE;
        CTableCell    * pCell;
        BOOL            fSetSize = FALSE;
        BOOL            fSetCellPosition = FALSE;
        CLayoutContext * pLayoutContext = pci->GetLayoutContext();
        CTableCalcInfo * ptci = NULL;
        BOOL             fViewChain;
        CTableCellLayout * pCellLayoutCompatible = NULL;

        if (pci->_fTableCalcInfo)
        {
            ptci = (CTableCalcInfo *) pci;
            
            pTable       = ptci->Table();
            pTableLayout = ptci->TableLayoutCache();
            fSetCellPosition = ptci->_fSetCellPosition;
        }
        else
        {
            pTable = Table();
            if (pTable)
                pTableLayout = pTable->TableLayoutCache();
            else
            {
                // this cell is not in the table (therefore it is a most likely DOM created homeless cell).
                *psize    =
                _sizeCell = g_Zero.size;
                TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
                return pci->_grfLayout;
            }
        }
    
        fViewChain = (ElementCanBeBroken() && pLayoutContext != NULL && pLayoutContext->ViewChain() != NULL);
    
        if (_fForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;
        }
    
        TraceTag((tagTableCalc, "CTableCellLayout::CalcSize - Enter (0x%x), Table = 0x%x, smMode = %x, grfLayout = %x", this, pTable, pci->_smMode, pci->_grfLayout));
    
        Assert (pdp);
        pdp->SetWordWrap(!pCF->HasNoBreak(TRUE));
    
        // NOTE: Alex disagrees with this. (OliverSe)
        // pdp->SetCaretWidth(0);  // NOTE: for cells we don't adjust the width of the cells for the caret (_dxCaret = 0).
    
        pCell = TableCell();
    
        Assert(pci);
        Assert(psize);
        Assert(   pci->_smMode == SIZEMODE_MMWIDTH 
               || (pTable && pTable->TestLock(CElement::ELEMENTLOCK_SIZING)) 
               || pCell->IsPositioned()
               || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
        Assert(pTableLayout && pTableLayout->IsCalced());
    
        //  Check that table cell is absolute or relative and it is called 
        //  directly from CLayout::HandlePostitionRequest to clone its disp node.
        Assert(ptci || !pci->_fCloneDispNode || (pLayoutContext && pCell->IsPositioned()));
        
        grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    
        if (pci->_grfLayout & LAYOUT_FORCE)
        {
            SetSizeThis( TRUE );
            _fAutoBelow        = FALSE;
            _fPositionSet      = FALSE;
            _fContainsRelative = FALSE;
        }
    
        Assert (pTableLayout && pTableLayout->_cNestedLevel != -1);
        if (!pTableLayout || pNodeSelf->IsDisplayNone() || pTableLayout->_cNestedLevel > SECURE_NESTED_LEVEL)
        {
            *psize    =
            _sizeCell = g_Zero.size;
            TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
            return grfReturn;
        }
    
    
        if (    fViewChain 
            &&  !IsCaption(etag)
            //  This piece of code is for insets support in broken cells but 
            //  it doesn't make sense if the cell is vertical (bug # 99917).
            &&  !pCell->HasVerticalLayoutFlow()   )
        {
            Assert(pLayoutContext != GetContentMarkup()->GetCompatibleLayoutContext());

            CLayoutBreak *     pLayoutBreakBeg;
            CDispNode *        pDispNodeCompatible;
            int                yFromTop;

            pCellLayoutCompatible = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompatible);

            pDispNodeCompatible = pCellLayoutCompatible->_pDispNode;

            if (pDispNodeCompatible && pDispNodeCompatible->HasInset())
            {
                yFromTop = 0;

                pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                if (pLayoutBreakBeg)
                {
                    yFromTop = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                }

                if (yFromTop < pDispNodeCompatible->GetInset().cy)
                {
                    pci->_cyAvail -= pDispNodeCompatible->GetInset().cy - yFromTop;
                    if (pci->_cyAvail < 1) 
                    {
                        pci->_cyAvail = 1;
                    }
                }
            }

            //  ask pre-calced cell if it has content
            _fElementHasContent = !pCellLayoutCompatible->NoContent();
        }

    #if DBG == 1
        if (pci->_smMode == SIZEMODE_NATURAL)
        {
            pci->_yBaseLine = -1;
        }
    #endif   

        grfReturn = super::CalcSizeCore(pci, psize, psizeDefault);

        if (    pci->IsNaturalMode()
            &&  !(grfReturn & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE))   )
        {
            *psize = _sizeCell;
        }


        if (fViewChain && !IsCaption(etag))
        {
            if (    fSetCellPosition
                //  or if cell is called to clone disp node directly
                ||  (!ptci && pci->_fCloneDispNode)  )
            {
                //  do adjustment only during set cell position pass
                CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                int yFromTop;

                if (ptci)
                {
                    Assert( ptci->_pRowLayout 
                        &&  (   pCell->RowSpan() > 1 
                            ||  ptci->_pRowLayout == (CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))  );
                    yFromTop = ptci->_pRowLayout->_yHeight;
                }
                else 
                {
                    yFromTop = ((CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))->_yHeight; 
                }

                pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 

                if (pLayoutBreakEnd)
                {
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                    if (pLayoutBreakBeg)
                    {
                        yFromTop += DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                    }

                    BOOL fFlowBroken = GetDisplay()->LineCount() 
                                        && (pLayoutBreakEnd->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
                    DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->SetTableCellLayoutBreak(yFromTop, fFlowBroken);
                }
            }
            else if (pci->_fLayoutOverflow && ptci)
            {
                // but in non-Set passes, we need to determine if there is a rowspan, and 
                // if so, don't allow a SetEndOfRect to bubble up.  If this happens and the 
                // rowspan would cause a pagebreak, the row dispnode will clip at the content 
                // height of the other cells and not the available height, thus clipping this cell.

                // the comment above is true when row spanned cell does not end in this row 
                int cCellRowSpan = pCell->RowSpan();

                if (    cCellRowSpan > 1
                    &&  (pCell->RowIndex() + cCellRowSpan - 1) != ptci->_pRow->_iRow    )
                {
                    pci->_fLayoutOverflow = FALSE;
                }
            }
        }
    
        if (pTableLayout->IsFixed() && !IsCaption(etag))
        {
            // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
            CTableRowLayout *pRowLayoutCache = Row()->RowLayoutCache();

            if (psize->cx > cx)
            {
                // Check if we need to clip the content of the cell
                if (pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed) != styleOverflowVisible)
                {
                    // we need to clip the content of the cell
                    EnsureDispNodeIsContainer();
                    fSetSize = TRUE;
                }
            }
            if (pci->_smMode != SIZEMODE_NATURALMIN)
            {
                _sizeCell.cx = psize->cx = cx;
            }
            
            if (    pRowLayoutCache->IsHeightSpecifiedInPixel() 
                &&  pFF->GetMinHeight().IsNullOrEnum()  )
            {
                if (pCell->RowSpan() == 1)
                {
                    long yRowHeight  = ((CTableRowLayoutBlock *)Row()->GetUpdatedLayout(pLayoutContext))->_yHeight;

                    // (bug # 104206) To prevent content clipping in fixed broken rows in print view. 
                    // NOTE : This code makes sure that this part of broken row 
                    // less or equal to the row height in compatible layout context.
                    if (fViewChain && pCellLayoutCompatible)
                    {
                        _sizeCell.cy     = min(psize->cy, pCellLayoutCompatible->_sizeCell.cy);
                    }
                    else 
                    {
                        _sizeCell.cy     = min(psize->cy, yRowHeight);
                        psize->cy        = yRowHeight;
                    }
                }
                else
                {
                    if (!fSetCellPosition)  // don't reset _sizeCell during set cell position (bug #47838)
                    {
                        _sizeCell.cy = psize->cy;
                    }
                }
                fFixedSizeCell = TRUE;
                CDispNode * pDispNode = GetElementDispNode();
                pDispNode->SetSize(*psize, NULL, FALSE);
                fIgnoreZeroWidth = TRUE;
            }
        }
    
        if (   pci->_smMode == SIZEMODE_NATURAL 
            || pci->_smMode == SIZEMODE_NATURALMIN
            || pci->_smMode == SIZEMODE_SET)
        {
            if (grfReturn & LAYOUT_THIS)
            {
                CBorderInfo bi(FALSE); // no init
    
                if (pci->_smMode != SIZEMODE_SET)
                {
    
                    // If the cell is empty, set its height to zero.
                    if ((NoContent() && !fIgnoreZeroWidth) && (!pTable->IsDatabound() || pTableLayout->IsRepeating()))
                    {
                        // Null out cy size component.
                        psize->cy = 0;
                        fSetSize  = TRUE;
                    }
    
                    // If the cell has no height, but does have borders
                    // Then ensure enough space for the horizontal borders
                    if (    psize->cy == 0
                        &&  GetCellBorderInfo(pci, &bi, FALSE, FALSE, 0, pTable, pTableLayout))
                    {
                        Assert(pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN);
                        psize->cy += bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];
                        fSetSize   = TRUE;
                    }
                    
                    // At this point, we should have a display node.
                    if (fSetSize)
                    {
                        Assert(GetElementDispNode());
                        SizeDispNode(pci, *psize);
                    }
    
                    Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                           || pTableLayout->IsFixedBehaviour() 
                           || pCell->IsAbsolute()
                           || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
                }
    
                Assert(pci->_yBaseLine != -1);
                _yBaseLine = pci->_yBaseLine;
    
                //
                // Save the true height of the cell (which may differ from the height of the containing
                // row and thus the value kept in _sizeProposed); However, only cache this value when
                // responding to a NATURAL size request or if the cell contains children whose
                // heights are a percentage of the cell (since even during a SET operation those can
                // change in size thus affecting the cell size).
    
                if (!fFixedSizeCell)
                {
                    if (   pci->_smMode == SIZEMODE_NATURAL
                        || pci->_smMode == SIZEMODE_NATURALMIN
                        || ContainsVertPercentAttr())
                    {
                        _sizeCell = *psize;
                    }
                    //
                    // In case of SET mode and changed layout flow get true size of the cell from 
                    // the display. 
                    // Need this value to vertical align cell's contents. In SET mode we don't modify 
                    // _sizeCell, but it might change in case of sizing for differing layout flows - 
                    // in this case update _sizeCell.
                    //
                    else if (pFF->_fLayoutFlowChanged)
                    {
                        CRect rcBorders;
                        _pDispNode->GetBorderWidths(&rcBorders);

                        GetDisplay()->GetSize(&_sizeCell);
                        _sizeCell.cx += rcBorders.left + rcBorders.right;
                        _sizeCell.cy += rcBorders.top + rcBorders.bottom;
                    }
                }
                Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                       || pCell->IsAbsolute()
                       || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
    
                if (   (    (_fContainsRelative || _fAutoBelow)
                         && !ElementOwner()->IsZParent() )  
                    || pFF->_fPositioned)
                {
                    CLayout *pLayout = GetUpdatedParentLayout(pLayoutContext);
                    pLayout->_fAutoBelow = TRUE;
                }
            }
    
    #ifdef NO_DATABINDING
            // Assert(_fMinMaxValid || pTableLayout->IsFixedBehaviour());
    #else
            // TODO, track bug 13696): 70458, need to investigate further why the MinMax is invalid.
            // Assert(_fMinMaxValid || IsGenerated() || pTableLayout->IsFixedBehaviour() || pCell->IsAbsolute());
    #endif
            // TODO, track bug 13696): alexa: the following assert breaks Final96 page (manual DRT), need to investigate.
            // Assert(_xMin <= _sizeCell.cx);
    
            pci->_yBaseLine = _yBaseLine;
        }
    
        else if (  pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
        {
            //
            // NETSCAPE: If NOWRAP was specified along with a fixed WIDTH,
            //           use the fixed WIDTH as a min/max (if not smaller than the content)
            //
    
            if (pFF->_fHasNoWrap)
            {
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
                {
                    psize->cx =
                    psize->cy = max((long)_sizeMin.cu,
                                    cuvWidth.XGetPixelValue(pci, 0,
                                              pNodeSelf->GetFontHeightInTwips(&cuvWidth)));
                    _sizeMin.SetSize(psize->cx, -1);
                    _sizeMax.SetSize(psize->cx, -1);
                }
            }
    
        }
    
        TraceTag((tagTableCalc, "CTableCell::CalcSize - Exit (0x%x)", this));
        TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return grfReturn;
    }
    

    DWORD
    CTableCellLayout::CalcSizeCoreCSS1Strict(CCalcInfo * pci, 
                                   SIZE      * psize, 
                                   SIZE      * psizeDefault)
    {
        TraceTagEx((tagCalcSize, TAG_NONAME, "+(CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

        CSaveCalcInfo   sci(pci, this);
        CScopeFlag      csfCalcing(this);
        LONG            cx = psize->cx;
        DWORD           grfReturn;
        CTable        * pTable;
        CTableLayout  * pTableLayout;
        CDisplay      * pdp = GetDisplay();
        CTreeNode     * pNodeSelf = GetFirstBranch();
        const CCharFormat * pCF   = pNodeSelf->GetCharFormat(LC_TO_FC(LayoutContext()));
        const CFancyFormat * pFF  = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
        ELEMENT_TAG     etag = Tag();
        CTableCell    * pCell;
        BOOL            fSetSize = FALSE;
        BOOL            fSetCellPosition = FALSE;
        CLayoutContext * pLayoutContext = pci->GetLayoutContext();
        CTableCalcInfo * ptci = NULL;
        BOOL             fViewChain;
        CTableCellLayout * pCellLayoutCompatible = NULL;

        if (pci->_fTableCalcInfo)
        {
            ptci = (CTableCalcInfo *) pci;
            
            pTable       = ptci->Table();
            pTableLayout = ptci->TableLayoutCache();
            fSetCellPosition = ptci->_fSetCellPosition;
        }
        else
        {
            pTable = Table();
            if (pTable)
                pTableLayout = pTable->TableLayoutCache();
            else
            {
                // this cell is not in the table (therefore it is a most likely DOM created homeless cell).
                *psize    =
                _sizeCell = g_Zero.size;
                TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
                return pci->_grfLayout;
            }
        }
    
        fViewChain = (ElementCanBeBroken() && pLayoutContext != NULL && pLayoutContext->ViewChain() != NULL);
    
        if (_fForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;
        }
    
        TraceTag((tagTableCalc, "CTableCellLayout::CalcSize - Enter (0x%x), Table = 0x%x, smMode = %x, grfLayout = %x", this, pTable, pci->_smMode, pci->_grfLayout));
    
        Assert (pdp);
        pdp->SetWordWrap(!pCF->HasNoBreak(TRUE));
    
        // NOTE: Alex disagrees with this. (OliverSe)
        // pdp->SetCaretWidth(0);  // NOTE: for cells we don't adjust the width of the cells for the caret (_dxCaret = 0).
    
        pCell = TableCell();
    
        Assert(pci);
        Assert(psize);
        Assert(   pci->_smMode == SIZEMODE_MMWIDTH 
               || (pTable && pTable->TestLock(CElement::ELEMENTLOCK_SIZING)) 
               || pCell->IsPositioned()
               || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
        Assert(pTableLayout && pTableLayout->IsCalced());
    
        //  Check that table cell is absolute or relative and it is called 
        //  directly from CLayout::HandlePostitionRequest to clone its disp node.
        Assert(ptci || !pci->_fCloneDispNode || (pLayoutContext && pCell->IsPositioned()));
        
        grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    
        if (pci->_grfLayout & LAYOUT_FORCE)
        {
            SetSizeThis( TRUE );
            _fAutoBelow        = FALSE;
            _fPositionSet      = FALSE;
            _fContainsRelative = FALSE;
        }
    
        Assert (pTableLayout && pTableLayout->_cNestedLevel != -1);
        if (!pTableLayout || pNodeSelf->IsDisplayNone() || pTableLayout->_cNestedLevel > SECURE_NESTED_LEVEL)
        {
            *psize    =
            _sizeCell = g_Zero.size;
            TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
            return grfReturn;
        }
    
    
        if (    fViewChain 
            &&  !IsCaption(etag)
            //  This piece of code is for insets support in broken cells but 
            //  it doesn't make sense if the cell is vertical (bug # 99917).
            &&  !pCell->HasVerticalLayoutFlow()   )
        {
            Assert(pLayoutContext != GetContentMarkup()->GetCompatibleLayoutContext());

            CLayoutBreak *     pLayoutBreakBeg;
            CDispNode *        pDispNodeCompatible;
            int                yFromTop;

            pCellLayoutCompatible = (CTableCellLayout *)pCell->Layout(GetContentMarkup()->GetCompatibleLayoutContext());
            Assert(pCellLayoutCompatible);

            pDispNodeCompatible = pCellLayoutCompatible->_pDispNode;

            if (pDispNodeCompatible && pDispNodeCompatible->HasInset())
            {
                yFromTop = 0;

                pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                if (pLayoutBreakBeg)
                {
                    yFromTop = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                }

                if (yFromTop < pDispNodeCompatible->GetInset().cy)
                {
                    pci->_cyAvail -= pDispNodeCompatible->GetInset().cy - yFromTop;
                    if (pci->_cyAvail < 1) 
                    {
                        pci->_cyAvail = 1;
                    }
                }
            }

            //  ask pre-calced cell if it has content
            _fElementHasContent = !pCellLayoutCompatible->NoContent();
        }

    #if DBG == 1
        if (pci->_smMode == SIZEMODE_NATURAL)
        {
            pci->_yBaseLine = -1;
        }
    #endif   

        //
        // Calculate proposed size
        //

        // psize->cx is adjusted (if necessary in CalcSizeAtUserWidth, so we can use it here)
        _sizeProposed.cx = psize->cx - GetBorderAndPaddingWidth(pci, FALSE); 

        if (pCF->_fUseUserHeight)
        {
            CHeightUnitValue uvHeight = pFF->GetHeight();

            _sizeProposed.cy = uvHeight.YGetPixelValue(pci, pTableLayout->_sizeProposed.cy, 
                pNodeSelf->GetFontHeightInTwips(&uvHeight));
        }
        else 
        {
            _sizeProposed.cy = 0;
        }

        grfReturn = super::CalcSizeCore(pci, psize, psizeDefault);

        if (fViewChain && !IsCaption(etag))
        {
            if (    fSetCellPosition
                //  or if cell is called to clone disp node directly
                ||  (!ptci && pci->_fCloneDispNode)  )
            {
                //  do adjustment only during set cell position pass
                CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                int yFromTop;

                if (ptci)
                {
                    Assert( ptci->_pRowLayout 
                        &&  (   pCell->RowSpan() > 1 
                            ||  ptci->_pRowLayout == (CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))  );
                    yFromTop = ptci->_pRowLayout->_yHeight;
                }
                else 
                {
                    yFromTop = ((CTableRowLayoutBlock *)(pCell->Row()->GetUpdatedLayout(pLayoutContext)))->_yHeight; 
                }

                pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 

                if (pLayoutBreakEnd)
                {
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);

                    if (pLayoutBreakBeg)
                    {
                        yFromTop += DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->YFromTop();
                    }

                    BOOL fFlowBroken = GetDisplay()->LineCount() 
                                        && (pLayoutBreakEnd->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW);
                    DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->SetTableCellLayoutBreak(yFromTop, fFlowBroken);
                }
            }
            else if (pci->_fLayoutOverflow && ptci)
            {
                // but in non-Set passes, we need to determine if there is a rowspan, and 
                // if so, don't allow a SetEndOfRect to bubble up.  If this happens and the 
                // rowspan would cause a pagebreak, the row dispnode will clip at the content 
                // height of the other cells and not the available height, thus clipping this cell.

                // the comment above is true when row spanned cell does not end in this row 
                int cCellRowSpan = pCell->RowSpan();

                if (    cCellRowSpan > 1
                    &&  (pCell->RowIndex() + cCellRowSpan - 1) != ptci->_pRow->_iRow    )
                {
                    pci->_fLayoutOverflow = FALSE;
                }
            }
        }
    
        if (pTableLayout->IsFixed() && !IsCaption(etag))
        {
            // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
            if (psize->cx > cx)
            {
                // Check if we need to clip the content of the cell
                if (pFF->GetLogicalOverflowX(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed) != styleOverflowVisible)
                {
                    // we need to clip the content of the cell
                    EnsureDispNodeIsContainer();
                    fSetSize = TRUE;
                }
            }
            if (pci->_smMode != SIZEMODE_NATURALMIN)
            {
                _sizeCell.cx = psize->cx = cx;
            }
        }
    
        if (   pci->_smMode == SIZEMODE_NATURAL 
            || pci->_smMode == SIZEMODE_NATURALMIN
            || pci->_smMode == SIZEMODE_SET)
        {
            if (grfReturn & LAYOUT_THIS)
            {
                if (pci->_smMode != SIZEMODE_SET)
                {
                    // If the cell is empty -- reset its height.
                    if (    NoContent() 
                        && (!pTable->IsDatabound() || pTableLayout->IsRepeating())  )
                    {
                        psize->cy = pCF->_fUseUserHeight ? _sizeProposed.cy : 0;

                        // 
                        // Save cell content size 
                        // 
                        _sizeCell = *psize;

                        fSetSize  = TRUE;
                    }
                    else 
                    {
                        // 
                        // Save cell content size 
                        // 
                        _sizeCell = *psize;

                        // 
                        // Adjust cell height
                        //
                        long  yBorderAndPaddingHeight = GetBorderAndPaddingHeight(pci, FALSE); 

                        if (psize->cy < (_sizeProposed.cy + yBorderAndPaddingHeight))
                        {
                            psize->cy = _sizeProposed.cy + yBorderAndPaddingHeight;
                            fSetSize  = TRUE;
                        }
                    }
                    
                    // At this point, we should have a display node.
                    if (fSetSize)
                    {
                        Assert(GetElementDispNode());
                        SizeDispNode(pci, *psize);
                    }
    
                    Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                           || pTableLayout->IsFixedBehaviour() 
                           || pCell->IsAbsolute()
                           || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
                }
                //
                // In case of SET mode and changed layout flow get true size of the cell from 
                // the display. 
                // Need this value to vertical align cell's contents. In SET mode we don't modify 
                // _sizeCell, but it might change in case of sizing for differing layout flows - 
                // in this case update _sizeCell.
                //
                else if (pFF->_fLayoutFlowChanged)
                {
                    CRect rcBorders;
                    _pDispNode->GetBorderWidths(&rcBorders);

                    GetDisplay()->GetSize(&_sizeCell);
                    _sizeCell.cx += rcBorders.left + rcBorders.right;
                    _sizeCell.cy += rcBorders.top + rcBorders.bottom;
                }

                Assert(   pTable->TestLock(CElement::ELEMENTLOCK_SIZING) 
                       || pCell->IsAbsolute()
                       || !pci->_fTableCalcInfo);  // this happens in trees tress when a TD is not calced from a table 
    
                if (   (    (_fContainsRelative || _fAutoBelow)
                         && !ElementOwner()->IsZParent() )  
                    || pFF->_fPositioned)
                {
                    CLayout *pLayout = GetUpdatedParentLayout(pLayoutContext);
                    pLayout->_fAutoBelow = TRUE;
                }

                Assert(pci->_yBaseLine != -1);
                _yBaseLine = pci->_yBaseLine;
            }
    
            pci->_yBaseLine = _yBaseLine;
        }
    
        else if (  pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
        {
            //
            // NETSCAPE: If NOWRAP was specified along with a fixed WIDTH,
            //           use the fixed WIDTH as a min/max (if not smaller than the content)
            //
    
            if (pFF->_fHasNoWrap)
            {
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
                {
                    psize->cx =
                    psize->cy = max((long)_sizeMin.cu,
                                    cuvWidth.XGetPixelValue(pci, 0,
                                              pNodeSelf->GetFontHeightInTwips(&cuvWidth)));
                    _sizeMin.SetSize(psize->cx, -1);
                    _sizeMax.SetSize(psize->cx, -1);
                }
            }
    
        }
    
        TraceTag((tagTableCalc, "CTableCell::CalcSize - Exit (0x%x)", this));
        TraceTagEx((tagCalcSize, TAG_NONAME, "-)CTableCellLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return grfReturn;
    }
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::GetBorderAndPaddingCore
    //
    //  Synopsis:   Calculate the size of the horizontal/vertical left border, right
    //              border, and paddings for this cell.
    //
    //--------------------------------------------------------------------------
    int CTableCellLayout::GetBorderAndPaddingCore(BOOL fWidth, CDocInfo const *pdci, BOOL fVertical, BOOL fOnlyBorder)
    {
        CBorderInfo     borderinfo(FALSE);
        CTable *        pTable = Table();
        CTableLayout *  pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;
        int             acc = 0;
        CTreeNode *     pTreeNode = ElementOwner()->GetFirstBranch();
    
        if (!fOnlyBorder)
        {
            const CFancyFormat * pFF = pTreeNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  * pCF = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            if (fWidth)
            {
                acc = pFF->GetLogicalPadding(SIDE_LEFT, fVertical, pCF->_fWritingModeUsed).XGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this))
                    + pFF->GetLogicalPadding(SIDE_RIGHT, fVertical, pCF->_fWritingModeUsed).XGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this));
            }
            else
            {
                acc = pFF->GetLogicalPadding(SIDE_TOP, fVertical, pCF->_fWritingModeUsed).YGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this))
                    + pFF->GetLogicalPadding(SIDE_BOTTOM, fVertical, pCF->_fWritingModeUsed).YGetPixelValue(pdci, 0, pTreeNode->GetFontHeightInTwips((CUnitValue*)this));
            }
        }
    
        if (GetCellBorderInfo(pdci, &borderinfo, FALSE, FALSE, 0, pTable, pTableLayout))
        {
            // Writing mode useage does not matter, since the table will always be horizontal, and if the
            // cell is vertical, then we always want to flip.
            BOOL    fFlip = pTreeNode->GetCharFormat()->HasVerticalLayoutFlow() ^ (!!fVertical);
            P_SIDE  borderOne, borderTwo;
    
            if (fWidth ^ fFlip)
            {
                borderOne = SIDE_LEFT;
                borderTwo = SIDE_RIGHT;
            }
            else
            {
                borderOne = SIDE_TOP;
                borderTwo = SIDE_BOTTOM;
            }

            acc += borderinfo.aiWidths[borderOne] + borderinfo.aiWidths[borderTwo];
        }
    
        return acc;
    }
    
    //+-------------------------------------------------------------------------
    //
    //  Method:     CTableCellLayout::CalcSizeAtUserWidth
    //
    //  Synopsis:   Calculate the size of the object based applying the user's
    //              specified width. This function is invented to match Netscape
    //              behaviour, who are respecting the user width for laying out
    //              the text (line braking is done on the user's specified width)
    //              regardless to the calculated size of the cell.
    //
    //--------------------------------------------------------------------------
    
    DWORD
    CTableCellLayout::CalcSizeAtUserWidth(CCalcInfo * pci, SIZE * psize)
    {

        WHEN_DBG(SIZE psizeIn = *psize);
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0
        
        int     cx          = psize->cx;
        // Table is always horizontal => fVerticalLayoutFlow = FALSE
        int     cxUserWidth = GetSpecifiedPixelWidth(pci, FALSE);
        BOOL    fAdjustView = FALSE;
        CTableLayout * pTableLayout = NULL;
        DWORD   grfReturn;
    #if DBG == 1
        int     cxMin;
    #endif
    
        if (pci->_fTableCalcInfo)
        {
            CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
            
            pTableLayout = ptci->TableLayoutCache();
        }
        else
        {
            if (Table())
                pTableLayout = Table()->TableLayoutCache();
        }
    
        //
        // If a non-inherited user set value exists, respect the User's size and calculate
        // the cell with that size, but set the different view for the cell.
        // NOTE: This is only applys to cells in columns without a fixed
        //       size (that is, covered by the COLS attribute)
        //
    
        if (    pTableLayout
            &&  ColIndex() >= pTableLayout->_cSizedCols
            &&  cxUserWidth
            &&  !TableCell()->_fInheritedWidth
            &&  cxUserWidth < cx)
        {
            // We should not try to render the cell in a view less then insets of the cell + 1 pixel
    
    #if DBG==1
            // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
            cxMin = GetBorderAndPaddingWidth(pci, FALSE) + 1;
            Assert (cxMin <= cxUserWidth);
    #endif
            psize->cx   = cxUserWidth;
            fAdjustView = TRUE;
        }
    
        // Recursive call to non-virtual CalcSize; this is a known safe exception
        // to the "don't call CalcSize recursively" rule.  We need to call the
        // non-virtual CalcSize because we needs its vertical layout logic.
        grfReturn = CalcSize(pci, psize, NULL);
    
        //
        // Re-adjust the view width if necessary
        //
    
        if (fAdjustView)
        {
            CTreeNode * pNodeSelf    = GetFirstBranch();
            const CFancyFormat * pFF = pNodeSelf->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            if (pTableLayout->IsFixed() && !IsCaption(Tag()))
            {
                // For the fixed style tables, regardless to the MIN width we might clip the content of the cell
                // Check if we need to clip the content of the cell
    
                // Table is always horizontal => fVerticalLayoutFlow = FALSE and fWritingModeUsed = FALSE
                if (pFF->GetLogicalOverflowX(FALSE, FALSE) == styleOverflowVisible)
                {
                    CSize sizeCell;
                    GetApparentSize(&sizeCell);
                    if (sizeCell.cx >= cx)
                    {
                        fAdjustView = FALSE;
                    }
                }
            }
            psize->cx = cx;
            if (fAdjustView)
            {
                if (pFF->_fLayoutFlowChanged)
                {
                    ((CSize *)psize)->Flip();
                    SizeDispNode(pci, *psize);
                    ((CSize *)psize)->Flip();
                }
                else
                    SizeDispNode(pci, *psize);
    
                SizeContentDispNode(CSize(GetDisplay()->GetMaxWidth(), GetDisplay()->GetHeight()));
            }
        }
    
        return grfReturn;
    }
    
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::Resize
    //
    //  Synopsis:   request to resize cell layout
    //
    //----------------------------------------------------------------------------
    
    void
    CTableCellLayout::Resize()
    {
    #if DBG == 1
        if (!IsTagEnabled(tagTableRecalc))
    #endif
        if (TableLayout() && 
            !TableLayout()->_fCompleted)
            return;
    
        ElementOwner()->ResizeElement();
    }
    
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CLayout::DrawClientBorder
    //
    //  Synopsis:   Draw the border
    //
    //  Arguments:  prcBounds       bounding rect of display leaf
    //              prcRedraw       rect to be redrawn
    //              pSurface        surface to render into
    //              pDispNode       pointer to display node
    //              pClientData     client-dependent data for drawing pass
    //              dwFlags         flags for optimization
    //
    //  Notes:
    //
    //----------------------------------------------------------------------------
    
    void
    CTableCellLayout::DrawClientBorder(const RECT * prcBounds, const RECT * prcRedraw, CDispSurface * pDispSurface, CDispNode * pDispNode, void * pClientData, DWORD dwFlags)
    {
        CElement * pElement;
        CTreeNode * pNode;
        const CFancyFormat * pFF;
    
        if (NoContent())
            return;
    
        pElement = ElementOwner();
    
        if (pElement->Tag() != ETAG_CAPTION)
        {
            pNode = pElement->GetFirstBranch();
            if (!pNode)
                return;
    
            pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            if (pFF->_bDisplay == styleDisplayNone)
                return;
    
            if (   pFF->_bPositionType != stylePositionabsolute
                && pFF->_bPositionType != stylePositionrelative)
            {
                CTableLayout * pTableLayout = NULL;
    
                if (Table())
                    pTableLayout = Table()->TableLayoutCache();

                if (   pTableLayout
                    && (   pTableLayout->_fCollapse 
                        || pTableLayout->_fRuleOrFrameAffectBorders))
                    return;
            }
        }
    
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
    
    //+---------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::DrawBorderHelper
    //
    //  Synopsis:   Paint the table cell's border if it has one.  Called from
    //              CTableCellLayout::Draw.
    //
    //----------------------------------------------------------------------------
    
    #define BorderFlag(border) \
       ((border == SIDE_LEFT) ? BF_LEFT : \
       ((border == SIDE_TOP) ? BF_TOP : \
       ((border == SIDE_RIGHT) ? BF_RIGHT : BF_BOTTOM)))
    #define BorderOrientation(border) ((border == SIDE_LEFT || border == SIDE_TOP)?1:-1)
    #define TopLeft(border) (border == SIDE_LEFT || border == SIDE_TOP)
    #define TopRight(border) (border == SIDE_RIGHT || border == SIDE_TOP)
    
    void
    CTableCellLayout::DrawBorderHelper(CFormDrawInfo *pDI, BOOL * pfShrunkDCClipRegion)
    {
        CTable *        pTable = Table();
        CTableLayout *  pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;
        htmlRules       trRules = pTable ? pTable->GetAArules() : htmlRulesNotSet;
        CBorderInfo     borderinfo(FALSE);  // no init
        CRect           rcInset;
        CRect           rcBorder;
        RECT            rcBorderVisible;
        WORD            grfBorderCollapseAdjustment = 0;
        ELEMENT_TAG     etag = Tag();
        CDispNode *     pDispNode = GetElementDispNode();
        BOOL            fRTLTable = (pTableLayout && pTableLayout->IsRightToLeft());
        // The following two variables are used for correcting border connections in right to left tables
        // This is a cascading hack that precipitates from the way borders are drawn. If the cell connects
        // to the table's border on either the left or right side, the flag will be set to alert us to
        // do the adjustment just before we draw.
        BOOL            fRTLLeftAdjust = FALSE, fRTLRightAdjust = FALSE;
    
        Assert(pTableLayout && (pTableLayout->_fCollapse || pTableLayout->_fRuleOrFrameAffectBorders));
        Assert(pfShrunkDCClipRegion);
    
        if (!pDispNode)
        {
            return;
        }
    
        pDispNode->GetApparentBounds(&rcInset);
    
        rcBorder = rcInset;

        TraceTag((tagTableBorder, "init rcBorder = (%d,%d, %d,%d)",
            rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right));

        GetCellBorderInfo(pDI, &borderinfo, TRUE, TRUE, pDI->GetDC(), pTable, pTableLayout, pfShrunkDCClipRegion);
    
        if (   pTableLayout 
            && pTableLayout->_fCollapse 
            && !IsCaption(etag))
        {
            int border;
            int widthBorderHalfInset;
            LONG *pnInsetSide, *pnBorderSide;
    
            for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
            {
                BOOL fCellBorderAtTableBorder = FALSE;
    
                // Set up current border for generic processing.
                switch (border)
                {
                case SIDE_LEFT:
                    pnInsetSide = &(rcInset.left);
                    pnBorderSide = &(rcBorder.left);
                    if(!fRTLTable)
                        fCellBorderAtTableBorder = (ColIndex() == 0);
                    else
                        fRTLLeftAdjust = fCellBorderAtTableBorder = (ColIndex()+TableCell()->ColSpan() == pTableLayout->_cCols);
                    break;
                case SIDE_TOP:
                    pnInsetSide = &(rcInset.top);
                    pnBorderSide = &(rcBorder.top);
                    fCellBorderAtTableBorder = (Row()->RowLayoutCache()->RowPosition() == 0);
                    break;
                case SIDE_RIGHT:
                    pnInsetSide = &(rcInset.right);
                    pnBorderSide = &(rcBorder.right);
                    if(!fRTLTable)
                        fCellBorderAtTableBorder = (ColIndex()+TableCell()->ColSpan() == pTableLayout->_cCols);
                    else
                        fRTLRightAdjust = fCellBorderAtTableBorder = (ColIndex() == 0);
                    break;
                default: // case SIDE_BOTTOM:
                    pnInsetSide = &(rcInset.bottom);
                    pnBorderSide = &(rcBorder.bottom);
                    fCellBorderAtTableBorder = (Row()->_iRow+TableCell()->RowSpan()-1 == pTableLayout->GetLastRow());
                    break;
                }
    
                // If the cell border coincides with the table border, no
                // collapsing takes place because the table border takes
                // precedence over cell borders.
                if (fCellBorderAtTableBorder)
                {
                    if (!borderinfo.aiWidths[border])
                    {
                        grfBorderCollapseAdjustment |= BorderFlag(border);
                    }
                    *pnInsetSide += borderinfo.aiWidths[border] * BorderOrientation(border); // * +/-1
                    continue;
                }
    
                // Half the border width (signed) is what we are going to modify the rects by.
                widthBorderHalfInset = ((borderinfo.aiWidths[border]+(!fRTLTable ? (TopLeft(border)?1:0) : (TopRight(border)?1:0)))>>1) * BorderOrientation(border); // * +/-1
    
                // The inset rect shrinks only by half the width because our neighbor
                // accomodates the other half.
                *pnInsetSide += widthBorderHalfInset;
    
                // If we are rendering our own border along this border...
                if (borderinfo.wEdges & BorderFlag(border))
                {
                    // The rcBorder grows by half the width so we can draw outside our rect.
                    *pnBorderSide -= ((borderinfo.aiWidths[border]+(!fRTLTable ? (TopLeft(border)?0:1) : (TopRight(border)?0:1)))>>1) * BorderOrientation(border); // * +/-1
                }
                else
                {
                    // The rcBorder shrinks (just like the inset rect) by half to let the
                    // neighbor draw half of its border in this space.
                    *pnBorderSide += widthBorderHalfInset;
    
                    // Make sure border rendering code doesn't get confused by neighbor's
                    // measurements.
                    borderinfo.aiWidths[border] = 0;
                    grfBorderCollapseAdjustment |= BorderFlag(border);
                }
            }
        }
        else
        {
            if (pTableLayout && pTableLayout->_fCollapse)
            {
                Assert(IsCaption(etag));
                int border = (DYNCAST(CTableCaption, TableCell())->IsCaptionOnBottom()) ? SIDE_TOP : SIDE_BOTTOM;
    
                if (!borderinfo.aiWidths[border])
                    grfBorderCollapseAdjustment |= BorderFlag(border);
            }
    
            rcInset.left   += borderinfo.aiWidths[SIDE_LEFT];
            rcInset.top    += borderinfo.aiWidths[SIDE_TOP];
            rcInset.right  -= borderinfo.aiWidths[SIDE_RIGHT];
            rcInset.bottom -= borderinfo.aiWidths[SIDE_BOTTOM];
        }
    
        //
        // Determine the RECT for and, if necessary, draw borders
        //
    
        if (trRules != htmlRulesNotSet && pTableLayout)
        {
            if (!(borderinfo.wEdges & BF_TOP))
                rcBorder.top -= pTableLayout->CellSpacingY();
            if (!(borderinfo.wEdges & BF_BOTTOM))
                rcBorder.bottom += pTableLayout->CellSpacingY();
            if (!(borderinfo.wEdges & BF_LEFT))
                rcBorder.left -= pTableLayout->CellSpacingX();
            if (!(borderinfo.wEdges & BF_RIGHT))
                rcBorder.right += pTableLayout->CellSpacingX();
        }
    
        //
        // Render the border if visible.
        //

        TraceTag((tagTableBorder, "visible rcBorder = (%d,%d, %d,%d)  rcInset = (%d,%d, %d,%d)",
            rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right,
            rcInset.top, rcInset.bottom,  rcInset.left, rcInset.right));
    
        rcBorderVisible = rcBorder;
    
        if (rcBorderVisible.left < rcBorderVisible.right  &&
            rcBorderVisible.top  < rcBorderVisible.bottom &&
            (rcBorderVisible.left   < rcInset.left  ||
             rcBorderVisible.top    < rcInset.top   ||
             rcBorderVisible.right  > rcInset.right ||
             rcBorderVisible.bottom > rcInset.bottom ))
        {
            // Adjust for collapsed pixels on all edges drawn by
            // neighbors (or the table border).  We have to do this,
            // so that the border drawing code properly attaches our
            // own borders with the neighbors' borders.  This has to
            // happen after the clipping above.
            if (grfBorderCollapseAdjustment)
            {
                if (grfBorderCollapseAdjustment & BF_LEFT)
                    rcBorder.left -= (fRTLLeftAdjust?0:1);
                if (grfBorderCollapseAdjustment & BF_TOP)
                    rcBorder.top--;
                if (grfBorderCollapseAdjustment & BF_RIGHT)
                    rcBorder.right += (fRTLRightAdjust?2:1);
                if (grfBorderCollapseAdjustment & BF_BOTTOM)
                    rcBorder.bottom++;
            }

            if (LayoutContext())
            {
                AdjustBordersForBreaking(&borderinfo);
            }

            TraceTag((tagTableBorder, "draw rcBorder = (%d,%d, %d,%d)",
                rcBorder.top, rcBorder.bottom,  rcBorder.left, rcBorder.right));
    
            ::DrawBorder(pDI, &rcBorder, &borderinfo);
        }
    }
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::PaintSelectionFeedback
    //
    //  Synopsis:   Paints the object's selection feedback, if it exists and
    //              painting it is appropriate
    //
    //  Arguments:  hdc         HDC to draw on.
    //              prc         Rect to draw in
    //              dwSelInfo   Additional info about the selection
    //
    //-------------------------------------------------------------------------
    
    void
    CTableCellLayout::PaintSelectionFeedback(CFormDrawInfo *pDI, RECT *prc, DWORD dwSelInfo)
    {
        // no selection feedback on table cells
    }
    
    //+------------------------------------------------------------------------
    //
    //  Member:     CTableCellLayout::GetSpecifiedPixelWidth
    //  
    //  Synopsis:   get user specified pixel width
    //
    //  Returns:    returns user's width of the cell (0 if not set or
    //              specified in %%)
    //              if user set's width <= 0 it will be ignored
    //-------------------------------------------------------------------------
    
    int
    CTableCellLayout::GetSpecifiedPixelWidth(CDocInfo const * pdci, BOOL fVerticalLayoutFlow)
    {
        int iUserWidth = 0;
    
        // If a user set value exists, respect the User's size and calculate
        // the cell with that size, but set the different view for the cell.
    
        CTableCell *pCell = TableCell();
        CTreeNode *pNode = pCell->GetFirstBranch();
    
        const CWidthUnitValue *punit = (CWidthUnitValue *)&pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->GetLogicalWidth(fVerticalLayoutFlow, pNode->GetCharFormat()->_fWritingModeUsed);
    
        if (punit->IsSpecified() && punit->IsSpecifiedInPixel())
        {
            iUserWidth = punit->GetPixelWidth(pdci, pCell);
            if (iUserWidth <= 0)    // ignore 0-width
            {
                iUserWidth = 0;
            }
            else
            {
                iUserWidth += GetBorderAndPaddingWidth(pdci, fVerticalLayoutFlow);
            }
        }
    
        return iUserWidth;
    }
    
    #ifndef NO_DATABINDING
    BOOL CTableCellLayout::IsGenerated()
    {
        ELEMENT_TAG etag = Tag();
        return etag != ETAG_CAPTION && 
               etag != ETAG_TC && 
               TableLayout() && 
               TableLayout()->IsGenerated(TableCell()->RowIndex());
    }
    #endif
    
    DWORD
    CTableCellLayout::CalcSizeVirtual(CCalcInfo * pci,
                                      SIZE      * psize,
                                      SIZE      * psizeDefault)
    {
        DWORD dwRet = super::CalcSizeVirtual(pci, psize, psizeDefault);
    
        WHEN_DBG(SIZE psizeIn = *psize);    // this is more interesting than saving psize before calling super
        WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0
        
        //
        // NOTE: VAlign code (below) has been moved from CTableCellLayout::CalcSizeCore
        // because sizes calculated in CFlowLayout::CalcSizeEx are needed to VAling
        // properly.
        // CTableCellLayout::CalcSizeCore is to early in the call stack to get it done right.
        //
    
        CDispNode * pDispNode = GetElementDispNode();
        if (pci->IsNaturalMode() &&  pDispNode)
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    
            //
            // Set the inset offset for the display node content
            //
            if (pDispNode->HasInset())
            {
                styleVerticalAlign  va;
                htmlCellVAlign      cellVAlign;
                long                cy;
                ELEMENT_TAG         etag;
    
                CLayoutContext * pLayoutContext = pci->GetLayoutContext();
                const CParaFormat * pPF = pNode->GetParaFormat(LC_TO_FC(LayoutContext()));
    
                cellVAlign  = (htmlCellVAlign)pPF->_bTableVAlignment;
                etag        = Tag();
    
                if (   cellVAlign != htmlCellVAlignBaseline
                    || etag == ETAG_CAPTION)
                {
                    va = (cellVAlign == htmlCellVAlignMiddle
                                ? styleVerticalAlignMiddle
                                : cellVAlign == htmlCellVAlignBottom
                                        ? styleVerticalAlignBottom
                                        : styleVerticalAlignTop);
                    cy = _sizeCell.cy;
                }
                else
                {
                    int yBaselineRow = ((CTableRowLayoutBlock *)Row()->GetUpdatedLayout(pLayoutContext))->_yBaseLine;
    
                    if (_yBaseLine != -1 && yBaselineRow != -1)
                    {
                        va = styleVerticalAlignBaseline;
    
                        cy = yBaselineRow - _yBaseLine;
                        if (cy + _sizeCell.cy > psize->cy)
                        {
                            cy = psize->cy - _sizeCell.cy;
                        }
                    }
                    else
                    {
                        va = styleVerticalAlignTop;
                        cy = _sizeCell.cy;
                    }
                }
    
                CTableCalcInfo * ptci = NULL;
                if (pci->_fTableCalcInfo)
                    ptci = (CTableCalcInfo *) pci;
    
                if (    pLayoutContext
                    &&  pLayoutContext->ViewChain()
                    &&  !IsCaption(etag)
                        //  do adjustment only during set cell position pass
                    &&  (   (ptci && ptci->_fSetCellPosition) 
                        //  or if cell is called directly to clone disp node
                        ||  (!ptci && pci->_fCloneDispNode)) )
                {
                    CLayoutBreak * pLayoutBreakBeg, *pLayoutBreakEnd;
                    BOOL fFlowBrokenBeg = FALSE;
                    BOOL fFlowBrokenEnd = FALSE;
    
                    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreakBeg);
                    if (pLayoutBreakBeg)
                    {
                        fFlowBrokenBeg = DYNCAST(CTableCellLayoutBreak, pLayoutBreakBeg)->IsFlowBroken();
                    }
    
                    pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreakEnd); 
                    if (pLayoutBreakEnd)
                    {
                        fFlowBrokenEnd = DYNCAST(CTableCellLayoutBreak, pLayoutBreakEnd)->IsFlowBroken();
                    }
    
                    if (va == styleVerticalAlignMiddle)
                    {
                        if (fFlowBrokenBeg != fFlowBrokenEnd)
                        {
                            va = fFlowBrokenEnd ? styleVerticalAlignBottom : styleVerticalAlignTop;
                        }
                    }
                    else if (va == styleVerticalAlignBaseline && fFlowBrokenBeg)
                    {
                        va = styleVerticalAlignTop;
                        cy = _sizeCell.cy;
                    }
                }
    
                SizeDispNodeInsets(va, cy, pDispNode);
            }
            //
            // Update cy value to display node height, in case of changed layout flow
            //
            if (   pFF->_fLayoutFlowChanged
                && (pci->_smMode == SIZEMODE_NATURALMIN || pci->_smMode == SIZEMODE_NATURAL))
            {
                psize->cy = max(psize->cy, pDispNode->GetSize().cy);
            }
        }
    
        return dwRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltdraw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltdraw.cxx
//
//  Contents:   CTableLayout drawing methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif


MtDefine(CTableLayoutDrawSiteList_aryElements_pv, Locals, "CTableLayout::DrawSiteList aryElements::_pv")
MtDefine(CTableLayout_pBorderInfoCellDefault, CTableLayout, "CTableLayout::_pBorderInfoCellDefault")
MtDefine(CTableLayout_pTableBorderRenderer, CTableLayout, "CTableLayout::_pTableBorderRenderer")

extern const WORD s_awEdgesFromTableFrame[htmlFrameborder+1];
extern const WORD s_awEdgesFromTableRules[htmlRulesall+1];

ExternTag(tagTableRecalc);
DeclareTag(tagNoExcludeClip, "Tables", "Don't exclude cliprects in GetCellBorderInfo")
DeclareTag(tagNoExcludeClipCorners, "Tables", "Don't exclude corner cliprects in GetCellBorderInfo")
DeclareTag(tagNoInflateRect, "Tables", "Don't inflate invalid rect in collapsed tables")
DeclareTag(tagNoBorderInfoCache, "Tables", "Don't use the tablewide borderinfo cache")
DeclareTag(tagDontComeOnIn, "Tables", "Rule out no-border cells for corner rendering")
DeclareTag(tagClipInsetRect, "Tables", "Clip corner out from inset rect")
DeclareTag(tagNoCollapsedBorders, "Tables", "Disable rendering of collapsed borders")
DeclareTag(tagRedCollapsedBorders, "Tables", "Render collapsed borders in red")
DeclareTag(tagTableBorder, "Tables", "Trace border drawing")


//+--------------------------------------------------------------------------------------
//
// Drawing methods overriding CLayout
//
//---------------------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::GetCellBorderInfoDefault
//
//  Synopsis:   Retrieves a single table cell's borderinfo.
//
//  Arguments:  pdci [in]         Docinfo
//              pborderinfo [out] Pointer to borderinfo structure to be filled
//              fRender [in]      Is this borderinfo needed for rendering or
//                                layout? (render retrieves more info, e.g. colors)
//
//  Returns:    TRUE if the cell has at least one border.  FALSE otherwise.
//
//  Note:       This routine makes use of a tablewide cell-border default cache
//              to retrieve normal cell borderinfos faster (memcpy).  If the cache
//              doesn't exist, it creates it as a side-effect once we encounter
//              the first cell with default border settings.
//
//              We retrieve border settings by first inheriting defaults from the
//              table, and then relying on CElement::GetBorderInfo() to override
//              the defaults.
//
//-------------------------------------------------------------------------

DWORD
CTableCellLayout::GetCellBorderInfoDefault(
    CDocInfo const *pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fRender,
    BOOL            fAllPhysical,                                           
    CTable *        pTable,
    CTableLayout *  pTableLayout
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CTableCell *    pCell        = TableCell();
    BOOL            fNotCaption  = !IsCaption(pCell->Tag());
    CTreeNode *     pCellNode    = pCell->GetFirstBranch();
    BOOL            fOverrideTablewideBorderSettings = pCellNode->GetCascadedborderOverride();

    BOOL            fUseBorderCache = !fOverrideTablewideBorderSettings   WHEN_DBG( && !IsTagEnabled(tagNoBorderInfoCache) )
                                    && pTableLayout 
                                    && (pTableLayout->CanRecalc() && pTableLayout->_sizeMax.cx != -1)
                                    && !pTableLayout->_fRuleOrFrameAffectBorders
                                    && fNotCaption
                                    && !pCell->HasVerticalLayoutFlow();
    
    if (!pTableLayout || (!pTableLayout->_fBorder && fUseBorderCache) || pCellNode->IsDisplayNone())
    {
        memset(pborderinfo, 0, sizeof(CBorderInfo));
        goto Done;
    }

    if (pTableLayout->_fBorderInfoCellDefaultCached && fUseBorderCache)
    {
        Assert(pTableLayout->_pBorderInfoCellDefault && "CTableLayout::_fBorderInfoCellDefaultCached should imply CTableLayout::_pBorderInfoCellDefault");
        memcpy(pborderinfo, pTableLayout->_pBorderInfoCellDefault, sizeof(CBorderInfo));
        goto Done;
    }

    // Make sure we are retrieving everything everything if we are going to cache this guy.
    fRender |= fUseBorderCache;

    // Initialize border info.
    pborderinfo->Init();

    // Inherit default settings from table.
    if (pTableLayout->_fBorder && fNotCaption)
    {
        int                  xBorder = pTableLayout->BorderX() ? 1 : 0;
        int                  yBorder = pTableLayout->BorderY() ? 1 : 0;
        WORD                 wEdges;
        WORD                 wFrameEdges;
        htmlRules            trRules = htmlRulesNotSet;
        htmlFrame            hf = htmlFrameNotSet;

        wFrameEdges = s_awEdgesFromTableFrame[hf];
        wEdges      = s_awEdgesFromTableRules[trRules];

        if ( pTableLayout->EnsureTableLayoutCache() )
            return FALSE;

        if (pTableLayout->_fRuleOrFrameAffectBorders)
        {

            htmlRules trRules = pTable->GetAArules();
            htmlFrame hf = pTable->GetAAframe();

            Assert(htmlFrameNotSet == 0);
            Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
            Assert(htmlRulesNotSet == 0);
            Assert(trRules < ARRAY_SIZE(s_awEdgesFromTableRules));

            wFrameEdges = s_awEdgesFromTableFrame[hf];
            wEdges      = s_awEdgesFromTableRules[trRules];


            if (trRules == htmlRulesgroups)
            {
                CTableCol * pColGroup;
                CTableSection * pSection;

                pColGroup = pTableLayout->GetColGroup(ColIndex());

                if (pColGroup)
                {
                    if (pColGroup->_iCol == ColIndex())
                    {
                        wEdges |= BF_LEFT;
                    }
                    if (pColGroup->_iCol + pColGroup->_cCols == (ColIndex() + pCell->ColSpan()))
                    {
                        wEdges |= BF_RIGHT;
                    }
                }

                pSection = Row()->Section();
                if (pSection->_iRow == pCell->RowIndex())
                {
                    wEdges |= BF_TOP;
                }
                if (pSection->_iRow + pSection->_cRows == (pCell->RowIndex() + pCell->RowSpan()))
                {
                    wEdges |= BF_BOTTOM;
                }
            }
        }

        //
        // Adjust edges of perimeter cells to match the FRAME/BORDER setting
        //

        if ( ColIndex() == 0 )
        {
            if ( wFrameEdges & BF_LEFT )
                wEdges |= BF_LEFT;
            else
                wEdges &= ~BF_LEFT;
        }
        if ( ColIndex()+pCell->ColSpan() == pTableLayout->GetCols() )
        {
            if ( wFrameEdges & BF_RIGHT )
                wEdges |= BF_RIGHT;
            else
                wEdges &= ~BF_RIGHT;
        }
        if ( pCell->RowIndex() == pTableLayout->GetFirstRow() )
        {
            if ( wFrameEdges & BF_TOP )
                wEdges |= BF_TOP;
            else
                wEdges &= ~BF_TOP;
        }
        if ( pCell->RowIndex() + pCell->RowSpan() - 1 == pTableLayout->GetLastRow() )   // NOTE (alexa): potential problem going across the section
        {
            if ( wFrameEdges & BF_BOTTOM )
                wEdges |= BF_BOTTOM;
            else
                wEdges &= ~BF_BOTTOM;
        }

        if (wEdges & BF_TOP)
        {
            pborderinfo->aiWidths[SIDE_TOP]    = yBorder;
            pborderinfo->abStyles[SIDE_TOP]    = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_BOTTOM)
        {
            pborderinfo->aiWidths[SIDE_BOTTOM] = yBorder;
            pborderinfo->abStyles[SIDE_BOTTOM] = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_LEFT)
        {
            pborderinfo->aiWidths[SIDE_LEFT]   = xBorder;
            pborderinfo->abStyles[SIDE_LEFT]   = fmBorderStyleSunkenMono;
        }

        if (wEdges & BF_RIGHT)
        {
            pborderinfo->aiWidths[SIDE_RIGHT]  = xBorder;
            pborderinfo->abStyles[SIDE_RIGHT]  = fmBorderStyleSunkenMono;
        }
    }

    pCell->CElement::GetBorderInfo( (CDocInfo *)pdci, pborderinfo, fRender, fAllPhysical FCCOMMA FCPARAM);   //  This will scale the borders.

    // If this is a default cell, it means we have no cache since we got here, so
    // create the cache.
    if (fUseBorderCache)
    {
        Assert(fRender && "Caching an incomplete borderinfo");
        Assert(!pTableLayout->_fBorderInfoCellDefaultCached);
        Assert(pTableLayout->_fBorder);

        if (!pTableLayout->_pBorderInfoCellDefault)
            pTableLayout->_pBorderInfoCellDefault = (CBorderInfo *)MemAlloc(Mt(CTableLayout_pBorderInfoCellDefault), sizeof(CBorderInfo));

        if (pTableLayout->_pBorderInfoCellDefault)
        {
            memcpy(pTableLayout->_pBorderInfoCellDefault, pborderinfo, sizeof(CBorderInfo));
            pTableLayout->_fBorderInfoCellDefaultCached = TRUE;
        }
    }

Done:
    if (    pborderinfo->wEdges )
    {
        return (    pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}


//+------------------------------------------------------------------------
//
//  Macros:     Some useful macros for accessing table cell neighbors.
//
//  Synopsis:   Retrieve adjacent borders.  These macros are useful
//              because they facilitate keeping the code border-independent,
//              i.e. avoiding the replication of common code four times.
//
//              Used by CTableCell::GetCellBorderInfo() below to resolve
//              collapsed border precendence.
//
//  Description:  Opposite:       Retrieves the border on the other side, e.g. left -> right
//                NextBorder:     Next border in clockwise direction, e.g. top -> right
//                PreviousBorder: Previous, counterclockwise border, e.g.: top -> left
//                TopLeft:        Is border top or left as opposed to bottom or right?
//                TopBottom:      Does border have vertical neighbor?
//                LeftRight:      Does border have horizontal neighbor?
//                TopRight:       Is border top or right?
//                LeftBottom:     Is border left or bottom?
//                RightBottom:    Is border right or bottom?
//                BorderFlag:     Retrieves borderflag corresponding to border.
//
//+------------------------------------------------------------------------

#define Opposite(border) ((border + 2) % 4)
#define NextBorder(border) ((border + 1) % 4)
#define PreviousBorder(border) ((border + 3) % 4)
#define TopLeft(border) (border == SIDE_LEFT || border == SIDE_TOP)
#define TopBottom(border) (border == SIDE_TOP || border == SIDE_BOTTOM)
#define LeftRight(border) (border == SIDE_LEFT || border == SIDE_RIGHT)
#define TopRight(border) (border == SIDE_TOP || border == SIDE_RIGHT)
#define LeftBottom(border) (border == SIDE_LEFT || border == SIDE_BOTTOM)
#define RightBottom(border) (border == SIDE_RIGHT || border == SIDE_BOTTOM)
#define BorderFlag(border) \
   ((border == SIDE_LEFT) ? BF_LEFT : \
   ((border == SIDE_TOP) ? BF_TOP : \
   ((border == SIDE_RIGHT) ? BF_RIGHT : BF_BOTTOM)))


//+------------------------------------------------------------------------
//
//  Member:     CTableCellLayout::GetCellBorderInfo
//
//  Synopsis:   Retrieves a table cell's borderinfo.  For normal (non-collapsed)
//              tables, simply calls GetCellBorderInfoDefault.  For collapsed
//              borders, also calls GetCellBorderInfoDefault on cell neighbors
//              to resolve collapse border precedence.
//
//  Arguments:  pdci [in]         Docinfo
//              pborderinfo [out] Pointer to borderinfo structure to be filled
//              fRender [in]      Is this borderinfo needed for rendering or
//                                layout? (render retrieves more info, e.g. colors)
//              hdc [in]          When rendering, can provide device context for
//                                clipping out spanned neighbors and border corners.
//              pfShrunkDCClipRegion [out] Set if the clipregion of hdc is shrunk.
//
//  Returns:    TRUE if this cell is responsible for at least one border.
//              FALSE otherwise.
//
//  Note:       For normal borders (non-collapsed), this routine simply calls
//              GetCellBorderInfoDefault() and returns.
//
//              Collapsed borders: During layout (fRender==FALSE), we allocate
//              space for half the cell borders, retrieving borderinfos from
//              neighbors and resolving border precedence.  During rendering,
//              we also indicate in the borderinfo which borders this cell
//              is responsible for drawing and clip out cellspan-neighbor borders
//              and border corners where necessary.
//
//-------------------------------------------------------------------------

DWORD
CTableCellLayout::GetCellBorderInfo(
    CDocInfo const *pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fRender,
    BOOL            fAllPhysical,                                    
    XHDC            hdc,
    CTable *        pTable,
    CTableLayout *  pTableLayout,
    BOOL *          pfShrunkDCClipRegion
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD           dnbDefault;
    CDocInfo        DI;
    CTableCell    * pCell = NULL;
    CTreeNode     * pNode;
    const CFancyFormat * pFF;

    if (!pTable)       pTable = Table();
    if (!pTableLayout) pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    BOOL               fRTLTable = pTable? pTable->GetFirstBranch()->GetParaFormat(FCPARAM)->HasRTL(TRUE) : FALSE;

    if (!pdci)
    {
        DI.Init(ElementOwner());
        pdci = &DI;
    }

    dnbDefault = GetCellBorderInfoDefault(pdci, pborderinfo, fRender, TRUE, pTable, pTableLayout);

    pCell = TableCell();
    pNode = pCell->GetFirstBranch();
    if (!pNode)
        goto Done;
    
    if (!pTableLayout || !pTableLayout->_fCollapse)
        goto Done;

    pFF = pNode->GetFancyFormat();
    if (   pFF->_bPositionType == stylePositionabsolute
        || pFF->_bPositionType == stylePositionrelative)
        goto Done;

    Assert(IsCaption(Tag()) || !fRender || pfShrunkDCClipRegion);

    // Deal with collapsed borders.
    if (!IsCaption(Tag()))
    {
        CTableRow * pRow = Row();
        CTableRowLayout * pRowLayout = pRow->RowLayoutCache();
        int         colspan=pCell->ColSpan(), rowspan=pCell->RowSpan();
        int         border;
        int         aryCornerBorderWidths[/*8*/] = {0, 0, 0, 0, 0, 0, 0, 0};

        if ( pTableLayout->EnsureTableLayoutCache() )
            return FALSE;

        for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
        {
            int     iCol;
            if(!fRTLTable)
                iCol = ColIndex() + ((border == SIDE_RIGHT) ? colspan : ((border == SIDE_LEFT) ? -1 : 0));
            else
                iCol = ColIndex() + ((border == SIDE_LEFT) ? colspan : ((border == SIDE_RIGHT) ? -1 : 0));
            int     iRow = pRow->_iRow;
            BOOL    fOwnBorder = TRUE, fCellAtTableBorder = FALSE, fOwnBorderPartially = FALSE, fFirstSweep = TRUE;
            BOOL    fTopLeft = TopLeft(border);
            BOOL    fTopRight = TopRight(border);
            int     widthMax = pborderinfo->aiWidths[border];
            long    widthMaxMin = MAXLONG, widthSegment;

            // Compute visually next or previous row.
            if (border == SIDE_BOTTOM)
            {
                //do
                {
                    iRow = pTableLayout->GetNextRowSafe(iRow+rowspan-1);
                }
                // Skip over incomplete rows.
                //while (iRow < pTableLayout->GetRows() && !pTableLayout->_aryRows[iRow]->_fCompleted);
            }
            else if (border == SIDE_TOP)
                iRow = pTableLayout->GetPreviousRow(iRow);

            do
            {
                if (iCol < 0 || iCol >= pTableLayout->_cCols || iRow < 0 || iRow >= pTableLayout->GetRows())
                {
                    fCellAtTableBorder = TRUE;
                    break;
                }

                CTableCell       *pNeighborCell   = Cell(pTableLayout->_aryRows[iRow]->RowLayoutCache()->_aryCells[iCol]);
                CTableCellLayout *pNeighborLayout = (pNeighborCell) 
                                                        ? pNeighborCell->Layout(((CDocInfo*)pdci)->GetLayoutContext()) 
                                                        : NULL;
                CBorderInfo biNeighbor(FALSE);  // no init
                BOOL fNeighborHasBorders = pNeighborLayout && pNeighborLayout->GetCellBorderInfoDefault(pdci, &biNeighbor, FALSE, TRUE, pTable, pTableLayout);
                BOOL fNeighborHasOppositeBorder = fNeighborHasBorders && (biNeighbor.aiWidths[Opposite(border)]);

                if (fNeighborHasOppositeBorder)
                {
                    pNode = pNeighborCell->GetFirstBranch();
                    Assert(pNode);
                    pFF = pNode->GetFancyFormat();
                    if (pFF->_bPositionType != stylePositionrelative && pFF->_bPositionType != stylePositionabsolute)
                    {
                        // Make sure that this cell and neighbor each have a border.
                        if (widthMax < biNeighbor.aiWidths[Opposite(border)] + (fOwnBorder && (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0)))
                        {
                            widthMax = biNeighbor.aiWidths[Opposite(border)];
                            fOwnBorder = FALSE;
                        }
                        else if (pborderinfo->aiWidths[border] >= biNeighbor.aiWidths[Opposite(border)] + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))
                        {
                            fOwnBorderPartially = TRUE;
                        }
                    }
                }

                widthSegment = (!fNeighborHasOppositeBorder || pborderinfo->aiWidths[border] >= biNeighbor.aiWidths[Opposite(border)])
                            ? pborderinfo->aiWidths[border] : biNeighbor.aiWidths[Opposite(border)];

                if (widthSegment < widthMaxMin)
                    widthMaxMin = widthSegment;

                // If rendering, set up cliprect (and information for cliprect).
                if (fRender)
                {
                    if ( fNeighborHasOppositeBorder && (colspan>1 || rowspan>1) && WHEN_DBG( !IsTagEnabled(tagNoExcludeClip) && )
                         (pborderinfo->aiWidths[border] < biNeighbor.aiWidths[Opposite(border)] + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0)) )
                    {
                        CRect   rcNeighbor, rcBorder;

                        // Exclude clip rect (ignore if fails).
                        Assert(GetElementDispNode());

                        // Get Rect without subtracting inset.
                        pNeighborLayout->GetRect(&rcNeighbor, fAllPhysical ? COORDSYS_TRANSFORMED : COORDSYS_PARENT);

                        // If we are RTLTable we need to offset for off by one error
                        if(fRTLTable)
                            rcNeighbor.OffsetX(-1);

                        rcBorder.left   = ((biNeighbor.aiWidths[SIDE_LEFT]+1)>>1);
                        rcBorder.top    = ((biNeighbor.aiWidths[SIDE_TOP]+1)>>1);
                        rcBorder.right  = (biNeighbor.aiWidths[SIDE_RIGHT]>>1);
                        rcBorder.bottom = (biNeighbor.aiWidths[SIDE_BOTTOM]>>1);

                        Verify(ExcludeClipRect(hdc,
                                               rcNeighbor.left   - rcBorder.left,
                                               rcNeighbor.top    - rcBorder.top,
                                               rcNeighbor.right  + rcBorder.right,
                                               rcNeighbor.bottom + rcBorder.bottom));


                        Assert(pfShrunkDCClipRegion);
                        *pfShrunkDCClipRegion = TRUE;
                    }

                    if (fFirstSweep || !fRTLTable ? LeftBottom(border) : RightBottom(border))
                        aryCornerBorderWidths[(2*border+7)%8] = biNeighbor.aiWidths[PreviousBorder(border)];
                    if (fFirstSweep || !fRTLTable ? TopRight(border) : TopLeft(border))
                        aryCornerBorderWidths[2*border] = biNeighbor.aiWidths[NextBorder(border)];
                }

                if (TopBottom(border))
                    iCol++;
                else
                    iRow++;

                fFirstSweep = FALSE;
            } while (   (TopBottom(border) 
                     && iCol- ColIndex()<colspan) 
                     || (LeftRight(border) 
                     && iRow-pRowLayout->RowPosition() < rowspan));

            if (fCellAtTableBorder)
            {
                CBorderInfo biTable;

                // If the table has borders, don't reserve any space for collapsed cell borders.
                if (pTableLayout->GetTableBorderInfo((CDocInfo *) pdci, &biTable, FALSE, FALSE)
                    && (biTable.wEdges & BorderFlag(border)))
                {
                    pborderinfo->wEdges &= ~BorderFlag(border);
                    pborderinfo->aiWidths[border] = 0;
                }
                // else change nothing: Cell borders are laid out and rendered in full
                // and uncollapsed.
            }
            else if (fOwnBorder || (fOwnBorderPartially && fRender))
            {
                // This cell is responsible for drawing borders along the entire edge.
                // If we are in the rendering mode (fRender), we return the full
                // width (no change necessary).
                Assert(widthMax == pborderinfo->aiWidths[border] || (fOwnBorderPartially && fRender));

                if (!fRender)
                {
                    // Because neighboring cells each provide half the space for
                    // collapsed borders, we divide the border width by 2 during
                    // layout (!fRender).  We round up for bottom and right borders.
                    pborderinfo->aiWidths[border] = (pborderinfo->aiWidths[border]+(!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))>>1;
                }
            }
            else
            {
                // One of the neighbors is responsible for drawing borders along at least
                // part of the edge because its border is wider.
                Assert(widthMax + (!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0) > pborderinfo->aiWidths[border]);

                // If we are in render mode, clear the border edge since our neighbor
                // is drawing the edge.  During layout, we budget for half the neighbor's
                // space. We round up for bottom and right borders.
                if (fRender)
                {
                    pborderinfo->wEdges &= ~BorderFlag(border);

                    // Return border width, even though it is not drawn so that caller
                    // can set up cliprects correctly.
                    pborderinfo->aiWidths[border] = widthMaxMin;

                    // If space is needed for neighbor's border, mark wEdges for adjustment.
                    if (pborderinfo->aiWidths[border])
                        pborderinfo->wEdges |= BF_ADJUST;
                }
                else
                {
                    pborderinfo->aiWidths[border] = (widthMaxMin+(!fRTLTable ? fTopLeft?1:0 : fTopRight?1:0))>>1;

                    // During layout, make sure the bit in wEdges is set when we need to make
                    // space for a neighbor's edge.
                    if (pborderinfo->aiWidths[border])
                    {
                        Assert(!fRender && "Only set wEdges for neighbor's borders when we are not rendering");
                        pborderinfo->wEdges |= BorderFlag(border);
                    }
                }
            }

            // Cache maximal bottom and trail width encountered.
            if (border == SIDE_BOTTOM && pRowLayout->_yWidestCollapsedBorder < widthMax)
                pRowLayout->_yWidestCollapsedBorder = widthMax;
            else if (!fRTLTable ? border == SIDE_RIGHT && pTableLayout->_xWidestCollapsedBorder < widthMax
                                : border == SIDE_LEFT && pTableLayout->_xWidestCollapsedBorder < widthMax)
                pTableLayout->_xWidestCollapsedBorder = widthMax;
        }

        // Border corners: If we are in rendering mode, make sure the border corners
        // have no overlap.  For corners we apply the same precedence rules as for edges.
        if (fRender)
        {
            for (border = SIDE_TOP ; border <= SIDE_LEFT ; border++)
            {
                int     iCol;
                if(!fRTLTable)
                    iCol = ColIndex() + ((NextBorder(border) == SIDE_RIGHT) ? colspan : ((NextBorder(border) == SIDE_LEFT) ? -1 : 0))
                                  + ((border == SIDE_RIGHT) ? colspan : ((border == SIDE_LEFT) ? -1 : 0));
                else
                    iCol = ColIndex() + ((NextBorder(border) == SIDE_LEFT) ? colspan : ((NextBorder(border) == SIDE_RIGHT) ? -1 : 0))
                                  + ((border == SIDE_LEFT) ? colspan : ((border == SIDE_RIGHT) ? -1 : 0));

                int     iRow = pRowLayout->RowPosition();

                // If we don't render any edge touching this corner, we don't need to clip.
                if (!(pborderinfo->wEdges & BorderFlag(border)) && !(pborderinfo->wEdges & BorderFlag(NextBorder(border))))
                    continue;

                // Compute visually next or previous row.
                if (border == SIDE_BOTTOM || NextBorder(border) == SIDE_BOTTOM)
                    iRow = pTableLayout->GetNextRowSafe(iRow+rowspan-1);
                else if (border == SIDE_TOP || NextBorder(border) == SIDE_TOP)
                    iRow = pTableLayout->GetPreviousRow(iRow);


                // Cell at table border?
                if (iCol < 0 || iCol >= pTableLayout->_cCols || iRow < 0 || iRow >= pTableLayout->GetRows())
                    continue;

                CTableCell *pNeighborCell = pTableLayout->_aryRows[iRow]->RowLayoutCache()->_aryCells[iCol];
                BOOL fReject = !IsReal(pNeighborCell);
                pNeighborCell = Cell(pNeighborCell);

                if (!pNeighborCell)
                    continue;

                CTableCellLayout * pNeighborLayout = pNeighborCell->Layout(((CDocInfo*)pdci)->GetLayoutContext());
                int colspanN = pNeighborCell->ColSpan(),
                    rowspanN = pNeighborCell->RowSpan();


                int borderRTLSensitive = !fRTLTable ? border : (3 - border);

                // Reject certain col/rowspans.
                switch(borderRTLSensitive)
                {
                case SIDE_TOP:
                    // Reject rowspans in top-right corner because there is no corner problem.
                    if (!fReject && rowspanN > 1)
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of rowspan (using assumption
                    // that rowspans don't cross sections).
                    if (fReject && colspanN == 1)
                        fReject = (iRow - pNeighborCell->Row()->_iRow + 1 != rowspanN);
                    break;
                case SIDE_RIGHT:
                    // In bottom-right corner, no colspans or rowspans cause a corner problem.
                    Assert(!fReject || colspanN>1 || rowspanN>1);
                    break;
                case SIDE_BOTTOM:
                    // Reject colspans in bottom-left corner because there is no corner problem.
                    if (!fReject && colspanN > 1)
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of colspan.
                    if (fReject && rowspanN == 1)
                        fReject = (iCol - pNeighborLayout->ColIndex() + 1 != colspanN);
                    break;
                case SIDE_LEFT:
                    // In top-left corner, no colspans or rowspans cause a corner problem.
                    if (!fReject && (colspanN > 1 || rowspanN > 1))
                    {
                        fReject = TRUE;
                        break;
                    }

                    // Reject only if not last cell of rowspan (using assumption
                    // that rowspans don't cross sections).
                    if (fReject)
                        fReject = (iRow - pNeighborCell->Row()->_iRow + 1 != rowspanN)
                               || (iCol - pNeighborLayout->ColIndex() + 1 != colspanN);
                    break;
                }

                if (fReject)
                    continue;

                Assert(pNeighborCell);

                CBorderInfo biNeighbor(FALSE); // No init
                pNeighborLayout->GetCellBorderInfoDefault(pdci, &biNeighbor, FALSE, TRUE, pTable, pTableLayout);

                // 1. Find the competing opposite candidate width.
                int widthWinnerX = 0,
                    widthWinnerY = 0;
                CRect rcNeighbor;

                // When table have fixed layout, some cells might not be calc'ed yet, and thus might
                // not have a display node yet.  In that case, don't address corner rendering problem.
                // This is also possible when tables are page-broken (printing).
                if (!pNeighborLayout->_pDispNode)
                {
                    Assert(  ( pNeighborLayout->IsSizeThis() && pTableLayout->IsFixedBehaviour() )
                           || ((CDocInfo*)pdci)->GetLayoutContext() );
                    continue;
                }

                pNeighborLayout->GetRect(&rcNeighbor, fAllPhysical ? COORDSYS_TRANSFORMED : COORDSYS_PARENT);

                // If we are RTLTable we need to offset for off by one error
                if(fRTLTable)
                    rcNeighbor.OffsetX(-1);

                WHEN_DBG( if (!IsTagEnabled(tagDontComeOnIn)) )
                {
                    int xOppositeWidth = aryCornerBorderWidths[2*border];
                    int yOppositeWidth = aryCornerBorderWidths[2*border+1];
                    BOOL fWinnerX, fWinnerY;
                    BOOL fTopLeft = TopLeft(border), fTopLeftNext = TopLeft(NextBorder(border));
                    BOOL fTopRight = TopRight(border), fTopRightNext = TopRight(NextBorder(border));

                    // Round 1: Have the two borders of the corner neighbor compete against the
                    // borders of the two direct neighbors.
                    if (xOppositeWidth < biNeighbor.aiWidths[Opposite(NextBorder(border))])
                        xOppositeWidth = biNeighbor.aiWidths[Opposite(NextBorder(border))];
                    if (yOppositeWidth < biNeighbor.aiWidths[Opposite(border)])
                        yOppositeWidth = biNeighbor.aiWidths[Opposite(border)];

                    // Round 2: Have the borders of this cell compete against the winner of
                    // round 1.
                    fWinnerX = pborderinfo->aiWidths[NextBorder(border)] >= xOppositeWidth;
                    fWinnerY = pborderinfo->aiWidths[border] >= yOppositeWidth;

                    // Set the width to the winners of round 2.
                    widthWinnerX = fWinnerX ? (-((pborderinfo->aiWidths[NextBorder(border)]+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1))
                                            : ((xOppositeWidth+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1);
                    widthWinnerY = fWinnerY ? (-((pborderinfo->aiWidths[border]+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1))
                                            : ((yOppositeWidth+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1);

                    if (fWinnerX || fWinnerY)
                    {
#if DBG == 1
                    // If both edges are winning, avoid the inset rect.
                    // Note: This condition assumes that wider borders win.  This will no longer be the case
                    // when we implement borders on other table elements such as rows which always win over
                    // table cell border in IE5, BETA2.  Then two winners doesn't necessarily mean we are
                    // cutting into our neighbor's inset rect.
                        if (IsTagEnabled(tagClipInsetRect) && fWinnerX && fWinnerY)
                        {
                            widthWinnerX = -((xOppositeWidth+(!fRTLTable ? (fTopLeftNext?0:1) : (fTopRightNext?0:1)))>>1);
                            widthWinnerY = -((yOppositeWidth+(!fRTLTable ? (fTopLeft?0:1) : (fTopRight?0:1)))>>1);
                        }
                        else
#endif // DBG==1
                            continue;
                    }
                }

                // 2. Make room for winning edge or inset.

                switch (border)
                {
                case SIDE_TOP:
                    rcNeighbor.left   -= widthWinnerX;
                    rcNeighbor.bottom += widthWinnerY;
                    break;
                case SIDE_RIGHT:
                    rcNeighbor.top    -= widthWinnerX;
                    rcNeighbor.left   -= widthWinnerY;
                    break;
                case SIDE_BOTTOM:
                    rcNeighbor.right  += widthWinnerX;
                    rcNeighbor.top    -= widthWinnerY;
                    break;
                case SIDE_LEFT:
                    rcNeighbor.bottom += widthWinnerX;
                    rcNeighbor.right  += widthWinnerY;
                    break;
                }

                // Actually exclude winning or inset rect of neighbor.
                if ( WHEN_DBG(!IsTagEnabled(tagNoExcludeClipCorners) &&) !IsRectEmpty(&rcNeighbor))
                {
                    // Exclude clip rect (ignore if fails).
                    Verify(ExcludeClipRect(hdc, rcNeighbor.left, rcNeighbor.top, rcNeighbor.right, rcNeighbor.bottom));
                    Assert(pfShrunkDCClipRegion);
                    *pfShrunkDCClipRegion = TRUE;
                }

            }
        }
    }
    else if (dnbDefault != DISPNODEBORDER_NONE)
    {
        // Collapse caption.
        Assert(IsCaption(Tag()));
        CBorderInfo biTable;

        // If the table has borders, we need to zero out the touching caption border.
        if (pTableLayout->GetTableBorderInfo((CDocInfo *) pdci, &biTable, FALSE, FALSE))
        {
            int border = (DYNCAST(CTableCaption, pCell)->IsCaptionOnBottom()) ? SIDE_TOP : SIDE_BOTTOM;

            // If the table has a border on the corresponding side, zero out caption border.
            if (biTable.wEdges & BorderFlag(Opposite(border)))
            {
                pborderinfo->wEdges &= ~BorderFlag(border);
                pborderinfo->aiWidths[border] = 0;
            }
        }

    }

    // We should only finish this way, if we had to collapse borders.
    Assert(pTableLayout->_fCollapse);

Done:

    // If we are asked to compute logical borderinfo, then we will still compute the
    // physical borderinfo in the code above and then switch it here. This way we
    // do not have to redo the code above for logical props (whew!)
    if (   !fAllPhysical
        && pCell
        && pCell->HasVerticalLayoutFlow()
       )
    {
        pborderinfo->FlipBorderInfo();
    }
    
    if ( pborderinfo->wEdges )
    {
        return (    pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_BOTTOM]
                &&  pborderinfo->aiWidths[SIDE_LEFT] == pborderinfo->aiWidths[SIDE_RIGHT]
                &&  pborderinfo->aiWidths[SIDE_TOP]  == pborderinfo->aiWidths[SIDE_LEFT]
                        ? DISPNODEBORDER_SIMPLE
                        : DISPNODEBORDER_COMPLEX);
    }
    return DISPNODEBORDER_NONE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::GetTableBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTableLayout::GetTableBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fRender, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    htmlFrame   hf = Table()->GetAAframe();
    WORD        wEdges;
    DWORD       wRet;
    
    if ( _xBorder || _yBorder )
    {
        Assert(htmlFrameNotSet == 0);
        Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
        wEdges = s_awEdgesFromTableFrame[hf];

        if (wEdges & BF_TOP)
        {
            pborderinfo->aiWidths[SIDE_TOP]    = _yBorder;
            pborderinfo->abStyles[SIDE_TOP]    = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_BOTTOM)
        {
            pborderinfo->aiWidths[SIDE_BOTTOM] = _yBorder;
            pborderinfo->abStyles[SIDE_BOTTOM] = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_LEFT)
        {
            pborderinfo->aiWidths[SIDE_LEFT]   = _xBorder;
            pborderinfo->abStyles[SIDE_LEFT]   = fmBorderStyleRaisedMono;
        }

        if (wEdges & BF_RIGHT)
        {
            pborderinfo->aiWidths[SIDE_RIGHT]  = _xBorder;
            pborderinfo->abStyles[SIDE_RIGHT]  = fmBorderStyleRaisedMono;
        }
    }

    wRet = Table()->CElement::GetBorderInfo( pdci, pborderinfo, fRender, fAllPhysical FCCOMMA FCPARAM);

    return  (   hf != htmlFrameNotSet
            &&  wRet == DISPNODEBORDER_NONE)
        ?   DISPNODEBORDER_COMPLEX
        :   wRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CalculateBorderAndSpacing
//
//  Synopsis:   Calculate and cache border, cellspacing, cellpadding
//
//--------------------------------------------------------------------------

void
CTableLayout::CalculateBorderAndSpacing(CDocInfo * pdci)
{
    CTable    * pTable = Table();
    CUnitValue  cuv;
    CUnitValue  uvDefaultborder;
    CBorderInfo borderinfo;
    CTreeNode * pNodeSelf = GetFirstBranch();
    htmlRules   trRules = pTable->GetAArules();
    htmlFrame   hf  = pTable->GetAAframe();

    // TODO (112612, olego):  we should have gereric mechanism to provide min/max limitation for 
    // different resolutions !!!

    // max allowed border space
    long xMaxBorderSpaceInScreenPixels = MAX_BORDER_SPACE;
    long yMaxBorderSpaceInScreenPixels = MAX_BORDER_SPACE;
    // max allowed cell spacing
    long xMaxCellSpacingInScreenPixels = MAX_CELL_SPACING;
    long yMaxCellSpacingInScreenPixels = MAX_CELL_SPACING;
    CLayoutContext *pLayoutContext = pdci->GetLayoutContext();

    _fRuleOrFrameAffectBorders =
        (trRules != htmlRulesNotSet && trRules != htmlRulesall) ||  // only when there are no groups/rows/cols rules
        (hf != htmlFrameNotSet);                                    // only when FRAME attribute is not set on table

    cuv = pTable->GetAAborder();

    if (cuv.IsNull())
    {
        _xBorder = 0;
        _yBorder = 0;

        Assert(hf < ARRAY_SIZE(s_awEdgesFromTableFrame));
        WORD wFrameEdges = s_awEdgesFromTableFrame[hf];

        if (trRules != htmlRulesNotSet || hf != htmlFrameNotSet)
        {
            uvDefaultborder.SetValue(1, CUnitValue::UNIT_PIXELS);
            switch(trRules)
            {
                case htmlRulesrows:
                    _yBorder = 1;
                    break;

                case htmlRulesgroups:
                case htmlRulesall:
                    _yBorder = 1;
                    // fall through
                case htmlRulescols:
                    _xBorder = 1;
                    break;
            }

            if ( _xBorder == 0 && ((wFrameEdges & BF_LEFT) || (wFrameEdges & BF_RIGHT)) )
                _xBorder = 1;

            if ( _yBorder == 0 && ((wFrameEdges & BF_TOP) || (wFrameEdges & BF_BOTTOM)) )
                _yBorder = 1;
        }
    }
    else
    {
        // get border space
        long lFontHeight = pNodeSelf->GetFontHeightInTwips(&cuv);

        _xBorder = cuv.XGetPixelValue(NULL, 0, lFontHeight);    //  NULL to prevent transformation to device.
        _yBorder = cuv.YGetPixelValue(NULL, 0, lFontHeight);

        // use 1 if negative and restrict it .. use TagNotAssignedDefault for 1
        if (_xBorder < 0)
        {
            uvDefaultborder.SetValue ( 1,CUnitValue::UNIT_PIXELS );

            _xBorder = 1;
            _yBorder = 1;
        }

        if (pLayoutContext && pLayoutContext->GetMedia() != mediaTypeNotSet)
        {
            //  Since introduction of hi-res mode checks for min/max became less trivial...
            xMaxBorderSpaceInScreenPixels = pdci->DeviceFromDocPixelsX(MAX_BORDER_SPACE);
            yMaxBorderSpaceInScreenPixels = pdci->DeviceFromDocPixelsY(MAX_BORDER_SPACE);
        }

        if (_xBorder > xMaxBorderSpaceInScreenPixels)
        {
            _xBorder = xMaxBorderSpaceInScreenPixels;
        }
        if (_yBorder > yMaxBorderSpaceInScreenPixels)
        {
            _yBorder = yMaxBorderSpaceInScreenPixels;
        }
    }


    _fBorder = ( _yBorder != 0 ) || ( _xBorder != 0 );


    GetTableBorderInfo(pdci, &borderinfo, FALSE, FALSE);
    memcpy(_aiBorderWidths, borderinfo.aiWidths, 4*sizeof(int));

    cuv = pTable->GetAAcellSpacing();

    if (cuv.IsNull())
    {
        CUnitValue uvDefaultCellSpacing;
        uvDefaultCellSpacing.SetValue (_fCollapse?0:2, CUnitValue::UNIT_PIXELS);
        _xCellSpacing = uvDefaultCellSpacing.XGetPixelValue(pdci, 0, 1);
        _yCellSpacing = uvDefaultCellSpacing.YGetPixelValue(pdci, 0, 1);
    }
    else
    {
        long SpaceFontHeight = pNodeSelf->GetFontHeightInTwips(&cuv);

        _xCellSpacing = max(0L,cuv.XGetPixelValue(pdci, 0, SpaceFontHeight));
        _yCellSpacing = max(0L,cuv.YGetPixelValue(pdci, 0, SpaceFontHeight));

        if (pLayoutContext && pLayoutContext->GetMedia() != mediaTypeNotSet)
        {
            //  Since introduction of hi-res mode checks for min/max became less trivial...
            xMaxCellSpacingInScreenPixels = pdci->DeviceFromDocPixelsX(MAX_CELL_SPACING);
            yMaxCellSpacingInScreenPixels = pdci->DeviceFromDocPixelsY(MAX_CELL_SPACING);
        }

        if (_xCellSpacing > xMaxCellSpacingInScreenPixels)
        {
            _xCellSpacing = xMaxCellSpacingInScreenPixels;
        }
        if (_yCellSpacing > yMaxCellSpacingInScreenPixels)
        {
            _yCellSpacing = yMaxCellSpacingInScreenPixels;
        }
    }

    _xCellPadding =
    _yCellPadding = 0;
}


//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    pSite (if found), NULL otherwise
//
//  NOTE:       This routine and GetNextLayout walk through the captions
//              and rows on the table. Negative cookies represent
//              CAPTIONs rendered at the top. Cookies in the range 0 to
//              one less than the number of rows represent rows. Positive
//              cookies greater than or equal to the number of rows
//              represent CAPTIONs rendered at the bottom. Since all the
//              CAPTIONs are kept in a single array, regardless where they
//              are rendered, the cookie may skip by more then one when
//              walking through the CAPTIONs. The cookie end-points are:
//
//                  Top-most CAPTION    - (-1 - _aryCaptions.Size())
//                  Top-most ROW        - (-1)
//                  Bottom-most ROW     - (GetRows())
//                  Bottom-most CAPTION - (GetRows() + _aryCaptions.Size())
//
//              If you change the way the cookie is implemented, then
//              please also change the GetCookieForSite funciton.
//
//-------------------------------------------------------------------------

CLayout *
CTableLayout::GetFirstLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw )
{
    // NOTE: This routine always walks the actual array (after ensuring
    //       it is in-sync with the current state of the tree)

    Assert(!fRaw);

    {
        if ( EnsureTableLayoutCache() )
            return NULL;
    }

    *pdw = fBack
            ? DWORD( GetRows() ) + DWORD( _aryCaptions.Size() )
            : DWORD( -1 ) - DWORD( _aryCaptions.Size() );

    return CTableLayout::GetNextLayout( pdw, fBack, fRaw );
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//  Note:       See comment on GetFirstLayout
//
//-------------------------------------------------------------------------

CLayout *
CTableLayout::GetNextLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw )
{
    int i, cRows, cCaptions;

    // NOTE: This routine always walks the actual array (after ensuring
    //       it is in-sync with the current state of the tree)

    Assert(!fRaw);

    {
        if ( EnsureTableLayoutCache() )
            return NULL;
    }

    i         = *pdw;
    cRows     = GetRows();
    cCaptions = _aryCaptions.Size();

    Assert(i >= (-1 - _aryCaptions.Size()));
    Assert(i <= (GetRows() + _aryCaptions.Size()));

    if (fBack)
    {
        i--;

        // While the cookie is past the end of the row array,
        // look for a caption which renders at the bottom
        for ( ; i >= cRows; i--)
        {
            if (_aryCaptions[i-cRows]->_uLocation == CTableCaption::CAPTION_BOTTOM)
            {
                *pdw = (DWORD)i;
                return _aryCaptions[i-cRows]->GetUpdatedLayout(LayoutContext());
            }
        }

        // While the cookie is before the rows,
        // look for a caption which renders at the top
        if (i < 0)
        {
            for ( ; (cCaptions+i) >= 0; i--)
            {
                if (_aryCaptions[cCaptions+i]->_uLocation == CTableCaption::CAPTION_TOP)
                {
                    *pdw = (DWORD)i;
                    return _aryCaptions[cCaptions+i]->GetUpdatedLayout(LayoutContext());
                }
            }

            return NULL;
        }

        // Otherwise, fall through and return the row
    }

    else
    {
        i++;

        // While the cookie is before the rows,
        // look for a caption which renders at the top
        for ( ; i < 0; i++)
        {
            if (_aryCaptions[cCaptions+i]->_uLocation == CTableCaption::CAPTION_TOP)
            {
                *pdw = (DWORD)i;
                return _aryCaptions[cCaptions+i]->GetUpdatedLayout(LayoutContext());
            }
        }

        // While the cookie is past the end of the row array,
        // look for a caption which renders at the bottom
        if (i >= cRows)
        {
            for ( ; i < (cRows+cCaptions); i++)
            {
                if (_aryCaptions[i-cRows]->_uLocation == CTableCaption::CAPTION_BOTTOM)
                {
                    *pdw = (DWORD)i;
                    return _aryCaptions[i-cRows]->GetUpdatedLayout(LayoutContext());
                }
            }

            return NULL;
        }

        // Otherwise, fall through and return the row
    }

    Assert( i >= 0 && i < GetRows());
    *pdw = (DWORD)i;
    return _aryRows[i]->GetUpdatedLayout(LayoutContext());
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::Draw
//
//  Synopsis:   Paint the table
//
//----------------------------------------------------------------------------

void
CTableLayout::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    if ( EnsureTableLayoutCache() )
        return;

#if DBG == 1
    if (!IsTagEnabled(tagTableRecalc))
#endif
    if (!IsCalced())    // return if table is not calculated
        return;

    super::Draw(pDI, pDispNode);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CTableBorderRenderer::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown)
    {
        *ppv = this;
    }

    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::DrawClient
//
//  Synopsis:   Draws collapsed, ruled, or framed table cell borders
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CTableBorderRenderer::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    Assert(pDI);
    Assert(pDispNode->IsFlowNode());
    Assert(_pTableLayoutBlock);

    AssertSz(!pDI->GetLayoutContext(), "Currently we shouldn't be getting a context passed in this way" );

    // DrawCellBorders needs to know what context it's drawing in,
    // so it can draw the right subset of rows/cells.
    pDI->SetLayoutContext( _pTableLayoutBlock->LayoutContext() );

    TableLayoutCache()->DrawCellBorders(
        pDI,
        prcBounds,
        prcRedraw,
        pDispSurface,
        pDispNode,
        cookie,
        pClientData,
        dwFlags);

    pDI->SetLayoutContext( NULL );
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CTableBorderRenderer::DumpDebugInfo
//
//  Synopsis:   Dump display tree debug information
//
//----------------------------------------------------------------------------

void
CTableBorderRenderer::DumpDebugInfo(
    HANDLE           hFile,
    long             level,
    long             childNumber,
    CDispNode const* pDispNode,
    void *           cookie)
{
    WriteString(hFile, _T("<tag>Table Border Renderer</tag>\r\n"));
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CTableLayout::DrawCellBorders
//
//  Synopsis:   Draws collapsed, ruled, or framed table cell borders
//
//  Arguments:  pTLB            CTableLayoutBlock for which we're drawing borders.
//                               pTLB == this for cases w/o context (non-print).
//              prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
// NOTE (paulnel) - 'lead' refers to left in left to right (LTR) and right in 
//                         right to left (RTL)
//                  'trail' refers to right in LTR and left in RTL
//----------------------------------------------------------------------------

WHEN_DBG(COLORREF g_crRotate = 255;)

void
CTableLayout::DrawCellBorders(
    CFormDrawInfo * pDI,
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    XHDC            hdc = pDI->GetDC(TRUE);
    CTableRowLayout * pRowLayout;
    int iRow, iRowTop, iRowBottom, iRowPrevious, iRowNext;
    int iCol, iColLead, iColTrail;
    int yRowTop, yRowBottom, xColLead, xColTrail;

    // TODO RTL 112514 PERF: this version of IsRightToLeft is expensive - it goes to the element;
    //                       there is no such flag on table layout. Need to look at profile to see
    //                       if it should be cached on CTableLayout.
    BOOL fRightToLeft = IsRightToLeft();
    Assert(!fRightToLeft || !IsTagEnabled(tagDebugRTL)); 
    
    CRect rcDraw((CRect)*prcRedraw);

    HRGN hrgnClipOriginal;

    CLayoutContext *pLayoutContext = pDI->GetLayoutContext();

    if (!IsTableLayoutCacheCurrent())
        return;

    // If the table has no rows, we are done.
    if (!GetRows())
        return;

    // if there is no calculated columns. (the right fix would be to remove all the display nodes from the tree on FlushGrid, bug #64931)
    if (!_aryColCalcs.Size())
        return;

    // Remember the original clip rect
    hrgnClipOriginal = CreateRectRgn(0,0,1,1);
    // NOTE (greglett) GetHackDC is what it sounds like - a hack.  See definition for more info.
    if (hrgnClipOriginal)
        GetClipRgn(hdc.GetHackDC(), hrgnClipOriginal);

#if DBG==1
    COLORREF crOld = 0x0;

    if (IsTagEnabled(tagNoCollapsedBorders))
        return;

    if (_pBorderInfoCellDefault && IsTagEnabled(tagRedCollapsedBorders))
    {
        crOld = _pBorderInfoCellDefault->acrColors[0][0];

        _pBorderInfoCellDefault->acrColors[0][0] = _pBorderInfoCellDefault->acrColors[0][1] = _pBorderInfoCellDefault->acrColors[0][2] =
        _pBorderInfoCellDefault->acrColors[1][0] = _pBorderInfoCellDefault->acrColors[1][1] = _pBorderInfoCellDefault->acrColors[1][2] =
        _pBorderInfoCellDefault->acrColors[2][0] = _pBorderInfoCellDefault->acrColors[2][1] = _pBorderInfoCellDefault->acrColors[2][2] =
        _pBorderInfoCellDefault->acrColors[3][0] = _pBorderInfoCellDefault->acrColors[3][1] = _pBorderInfoCellDefault->acrColors[3][2] = g_crRotate;

        g_crRotate = (g_crRotate << 8);
        if (!g_crRotate)
            g_crRotate = 255;
    }
#endif // DBG==1

    //
    // Obtain subgrid of table borders to be rendered.
    // (If we are collapsing borders, make sure the invalid rect is
    // large enough to include neighboring borders so that collapsed
    // neighbors get a chance to draw their borders.)
    //

    //
    // iRowTop.
    //

    yRowTop    =
    yRowBottom = 0;
    pRowLayout = GetRowLayoutFromPos(rcDraw.top, &yRowTop, &yRowBottom, NULL, pLayoutContext);
    iRowTop = pRowLayout ? pRowLayout->RowPosition() : GetFirstRow();
    if (iRowTop != GetFirstRow())
    {
        iRowPrevious = GetPreviousRowSafe(iRowTop);
        Assert(iRowPrevious >= 0);

        // Only expand when redraw rect infringes on maximum border area.
        if (_fCollapse && rcDraw.top < yRowTop + ((_aryRows[iRowPrevious]->RowLayoutCache()->_yWidestCollapsedBorder+1)>>1)
            WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
        {
            iRowTop = iRowPrevious;
        }
    }

    //
    // iRowBottom.
    //

    // Note that the bottom, right coordinates are outside the clip-rect (subtract 1).
    yRowTop    =
    yRowBottom = 0;
    pRowLayout = GetRowLayoutFromPos(rcDraw.bottom-1, &yRowTop, &yRowBottom, NULL, pLayoutContext);
    iRowBottom = pRowLayout ? pRowLayout->RowPosition() : GetLastRow();
    if (iRowBottom != GetLastRow())
    {
        iRowNext = GetNextRowSafe(iRowBottom);
        Assert(iRowNext < GetRows());

        // Only expand when cliprect infringes on maximum border area.
        if (_fCollapse && rcDraw.bottom >= yRowBottom - ((pRowLayout->_yWidestCollapsedBorder)>>1)
            WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
        {
            iRowBottom = iRowNext;
        }
    }

    //
    // iColLead.
    //

    iColLead = GetColExtentFromPos(!fRightToLeft ? rcDraw.left: rcDraw.right, &xColLead, &xColTrail, fRightToLeft);
    if (iColLead == -1)
        iColLead = 0;

    // Only expand when cliprect infringes on maximum border area.
    if (   _fCollapse
        && iColLead > 0
        && (!fRightToLeft 
            ? rcDraw.left < xColLead + ((_xWidestCollapsedBorder+1)>>1)
            : rcDraw.right > xColLead - (_xWidestCollapsedBorder>>1))
        WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
    {
        iColLead--;
    }

    //
    // iColTrail.
    //

    // Note that the bottom, right coordinates are outside the clip-rect (subtract 1).
    iColTrail = GetColExtentFromPos(!fRightToLeft ? rcDraw.right-1 : rcDraw.left+1, &xColLead, &xColTrail, fRightToLeft);
    if (iColTrail == -1)
        iColTrail = GetCols()-1;

    // Only expand when cliprect infringes on maximum border area.
    if (   _fCollapse
        && iColTrail < GetCols()-1
        && (!fRightToLeft
            ? rcDraw.right >= xColTrail - (_xWidestCollapsedBorder>>1)
            : rcDraw.left <= xColTrail + ((_xWidestCollapsedBorder+1)>>1))
        WHEN_DBG( && !IsTagEnabled(tagNoInflateRect) ) )
    {
        iColTrail++;
    }

    TraceTag((tagTableBorder, "rcDraw: (%ld,%ld, %ld,%ld)  rcCells: (%d,%d, %d,%d), cells: (%d,%d, %d,%d)",
                rcDraw.top, rcDraw.bottom,  rcDraw.left, rcDraw.right,
                yRowTop, yRowBottom,  xColLead, xColTrail,
                iRowTop, iRowBottom,  iColLead, iColTrail));

    Assert(iRowTop    >= 0 && iRowTop    < GetRows());
    Assert(iRowBottom >= 0 && iRowBottom < GetRows());
    Assert(iColLead   >= 0 && iColLead   < GetCols());
    Assert(iColTrail  >= 0 && iColTrail  < GetCols());

    for ( iRow = iRowTop ; ; iRow = GetNextRowSafe(iRow) )
    {
        CTableRow *pTRow = GetRow(iRow);
        if(!pTRow)
            continue;
        CTableRowLayout * pRowLayout = pTRow->RowLayoutCache();
        int iColSpan;
        Assert(pRowLayout);

        for ( iCol = iColLead ; iCol <= iColTrail ; iCol += iColSpan )
        {
            CTableCell * pCell = Cell(pRowLayout->_aryCells[iCol]);
            if (pCell)
            {
                AssertSz( pRowLayout->LayoutContext() == NULL, "Since pRowLayout is the row cache, it shouldn't have context" );
                if ( pLayoutContext && !pCell->CurrentlyHasLayoutInContext( pLayoutContext ) )
                {
                    iColSpan = 1;
                    continue;
                }

                CTableCellLayout * pCellLayout = pCell->Layout(pLayoutContext);
                const CFancyFormat * pFF = pCell->GetFirstBranch()->GetFancyFormat();
                if (!pFF->_fPositioned)
                {
                    BOOL fShrunkDCClipRegion = FALSE;

                    pCellLayout->DrawBorderHelper(pDI, &fShrunkDCClipRegion);
                
                    // If the clip region was modified, restore the original one.
                    // NOTE (greglett) GetHackDC is what it sounds like - a hack.  See definition for more info.
                    if (fShrunkDCClipRegion)
                        SelectClipRgn(hdc.GetHackDC(), hrgnClipOriginal);

                }
                iColSpan = pCell->ColSpan() - ( iCol - pCellLayout->ColIndex() );
            }
            else
            {
                iColSpan = 1;
            }
        }

        // Finished last row?
        if (iRow == iRowBottom)
            break;
    }

#if DBG==1
    if (_pBorderInfoCellDefault && IsTagEnabled(tagRedCollapsedBorders) )
    {
        _pBorderInfoCellDefault->acrColors[0][0] =
        _pBorderInfoCellDefault->acrColors[0][1] =
        _pBorderInfoCellDefault->acrColors[0][2] =
        _pBorderInfoCellDefault->acrColors[1][0] =
        _pBorderInfoCellDefault->acrColors[1][1] =
        _pBorderInfoCellDefault->acrColors[1][2] =
        _pBorderInfoCellDefault->acrColors[2][0] =
        _pBorderInfoCellDefault->acrColors[2][1] =
        _pBorderInfoCellDefault->acrColors[2][2] =
        _pBorderInfoCellDefault->acrColors[3][0] =
        _pBorderInfoCellDefault->acrColors[3][1] =
        _pBorderInfoCellDefault->acrColors[3][2] = crOld;
    }
#endif // DBG==1

    // Cleanup:
    if (hrgnClipOriginal)
        DeleteObject(hrgnClipOriginal);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientPainterInfo
//
//-----------------------------------------------------------------------------

DWORD
CTableLayout::GetClientPainterInfo(
                                CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if (GetElementDispNode() != pDispNodeFor)       // if draw request is for dispNode other then primary
        return 0;                                   // then no drawing at all the dispNode

    return GetPeerPainterInfo(pAryClientInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltrowcol.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltrow.cxx
//
//  Contents:   Implementation of CTableCellLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

MtDefine(CTableRowLayoutBlock, Layout, "CTableRowLayoutBlock");
MtDefine(CTableRowLayout, Layout, "CTableRowLayout");
MtDefine(CTableRowLayout_aryCells_pv, CTableRowLayout, "CTableRowLayout::_aryCells::_pv");
MtDefine(CTableRowLayout_pDisplayNoneCells_pv, CTableRowLayout, "CTableRowLayout::_pDisplayNoneCells::_pv");

const CLayout::LAYOUTDESC CTableRowLayoutBlock::s_layoutdesc =
{
    0,                              // _dwFlags
};

const CLayout::LAYOUTDESC CTableRowLayout::s_layoutdesc =
{
    0,                              // _dwFlags
};


//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::~CTableRowLayoutBlock
//
//  Synopsis:   
//
//-------------------------------------------------------------------------
CTableRowLayoutBlock::~CTableRowLayoutBlock()
{
}

//+---------------------------------------------------------------------
//
// Function:     CTableLayoutBlock::Init
//
// Synopsis:     
//
//+---------------------------------------------------------------------
HRESULT
CTableRowLayoutBlock::Init()
{
    HRESULT hr = super::Init();

    // Table rows are breakable if their markup's master is a layoutrect
    SetElementAsBreakable();

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::GetPositionInFlow
//
//  Synopsis:   Return the in-flow position of a site
//
//-------------------------------------------------------------------------

void
CTableRowLayoutBlock::GetPositionInFlow(CElement * pElement, CPoint * ppt)
{
    CTableLayout * pTableLayout;

    Assert(GetFirstBranch()->GetUpdatedParentLayoutElement() == Table());

    pTableLayout = TableLayoutCache();
    if (pTableLayout)
    {
        pTableLayout->GetPositionInFlow(pElement, ppt);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::Draw
//
//  Synopsis:   Paint the background
//
//----------------------------------------------------------------------------

void
CTableRowLayoutBlock::Draw(CFormDrawInfo *, CDispNode *)
{
    AssertSz(FALSE, "Table row doesn't draw itself");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::Notify
//
//  Synopsis:   Notification handler.
//
//----------------------------------------------------------------------------

void
CTableRowLayoutBlock::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    if (pnf->IsType(NTYPE_ELEMENT_MINMAX))
    {
        Assert(     pnf->Element() == ElementOwner()
                ||  pnf->IsFlagSet(NFLAGS_SENDUNTILHANDLED));    // Necessary to allow ChangeTo below

        CTable *        pTable = Table();
        CTableLayout *  pTableLayoutCache =   pTable
                                            ? pTable->TableLayoutCache()
                                            : NULL;

        if (    pTableLayoutCache 
            &&  pTableLayoutCache->CanRecalc() 
            &&  !pTableLayoutCache->TestLock(CElement::ELEMENTLOCK_SIZING)   )
        {
            pTableLayoutCache->_fDontSaveHistory = TRUE;
            pTableLayoutCache->ResetRowMinMax(RowLayoutCache());
        }

        pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
    }
    else if (   !IsInvalidationNotification(pnf)
            ||  ElementOwner() != pnf->Element()
            ||  GetElementDispNode())
    {
        super::Notify(pnf);
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for an element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CTableRowLayoutBlock::RegionFromElement(
    CElement *          pElement,
    CDataAry<RECT> *    paryRects,
    RECT *              prcBound,
    DWORD               dwFlags)
{
    CTableLayout *pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        pTableLayout->RegionFromElement(pElement, paryRects, prcBound, dwFlags);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableRowLayoutBlock::ShowSelected
//
//  Synopsis:   Show the selected range.
//
//----------------------------------------------------------------------------

void 
CTableRowLayoutBlock::ShowSelected(
            CTreePos* ptpStart, 
            CTreePos* ptpEnd, 
            BOOL fSelected, 
            BOOL fLayoutCompletelyEnclosed )           
{
    CTableLayout * pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        pTableLayout->ShowSelected(ptpStart, ptpEnd, fSelected, fLayoutCompletelyEnclosed );
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CTableRowLayout::destructor
//
//  Note:       The display none cache must be deleted in the destructor
//
//-------------------------------------------------------------------------

CTableRowLayout::~CTableRowLayout()
{
    ClearRowLayoutCache();
}

//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//  Note:       If you change the way the cookie is implemented, then
//              please also change the GetCookieForSite funciton.
//
//-------------------------------------------------------------------------

CLayout *
CTableRowLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    // TODO (dmitryt, tracking bug IE6/13701) fRaw is always FALSE, never actually used. Can be removed.
    *pdw = fBack ? (DWORD)_aryCells.Size() : (DWORD)-1;
    return CTableRowLayout::GetNextLayout(pdw, fBack);
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    site
//
//-------------------------------------------------------------------------

CLayout *
CTableRowLayout::GetNextLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    // TODO (dmitryt, tracking bug IE6/13701) fRaw is always FALSE, never actually used. Can be removed.
    int i;
    CTableCell * pCell;

    for (;;)
    {
        i = (int)*pdw;
        if (fBack)
        {
            if (i > 0)
            {
                i--;
            }
            else
            {
                return NULL;
            }
        }
        else
        {
            if (i < _aryCells.Size() - 1)
            {
                i++;
            }
            else
            {
                return NULL;
            }
        }
        *pdw = (DWORD)i;
        pCell = _aryCells[i];
        if (IsReal(pCell))
        {
            return pCell->GetUpdatedLayout();
        }
    }
}

CDispNode *
CTableRowLayout::GetElementDispNode(CElement *  pElement) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
                        : NULL);
}


//
// virtual: helper function to calculate absolutely positioned child layout
//
void        
CTableRowLayoutBlock::CalcAbsolutePosChild(CCalcInfo *pci, CLayout *pLayout)
{
    CTable *            pTable = Table();
    CTableLayout *      pTableLayoutCache = pTable ? pTable->TableLayoutCache() : NULL;
    CTableLayoutBlock * pTableLayoutBlock = pTable 
        ? (CTableLayoutBlock *)pTable->GetUpdatedLayout(pci->GetLayoutContext()) : NULL;

    //  NOTE (greglett)  Originally, the ETAG_TD and ETAG_TH check below was simply an assert.  A tree stress bug
    //  created a situation where a DIV was the child - the ptr casting was causing a crash.  I don't think it should
    //  ever occur in a real document situation.  Since it isn't valid, and shouldn't happen, just exit. (#71211)

    if ((pLayout->Tag() == ETAG_TD || pLayout->Tag() == ETAG_TH) && pTableLayoutCache)
    {
        Assert(pTableLayoutBlock);

        CTableCalcInfo tci(pTable, pTableLayoutBlock);
        pTableLayoutCache->CalcAbsolutePosCell(&tci, (CTableCell *)pLayout->ElementOwner());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AddCell
//
//  Synopsis:   Add a cell to the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::AddCell(CTableCell * pCell)
{
    HRESULT         hr = S_OK;
    CTableLayout  * pTableLayout = TableLayoutCache();
    int             cCols = _aryCells.Size();
    CTableRow     * pRow = TableRow();

    Assert(pCell);

    int             cColSpan = pCell->ColSpan();
    int             cRowSpan = 1;
    int             iAt = 0;
    CTableCell *    pCellOverlap = NULL;
    BOOL            fAbsolutePositionedRow = FALSE;
    BOOL            fDisplayNoneRow = FALSE;
    BOOL            fDisplayNoneCell = FALSE;

    // fill first empty cell

    while (iAt < cCols && !IsEmpty(_aryCells[iAt]))
        iAt++;

    // tell cell where it is
    pCell->_iCol = iAt;

    CTreeNode *pNode = pCell->GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat();
    const CParaFormat * pPF = pNode->GetParaFormat();
    const CCharFormat * pCF = pNode->GetCharFormat();
    BOOL fCellVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

    if (!pTableLayout)
        goto Cleanup;

    // WHINING: we should set this flag based on _dp._fContainsHorzPercentAttr, but it doesn't work correctly
    pTableLayout->_fHavePercentageInset |= (   pFF->GetLogicalPadding(SIDE_LEFT, fCellVertical, fWritingModeUsed).IsPercent()
                                            || pFF->GetLogicalPadding(SIDE_RIGHT, fCellVertical, fWritingModeUsed).IsPercent()
                                            || pPF->_cuvTextIndent.IsPercent());

    cRowSpan = pCell->GetAArowSpan();
    Assert (cRowSpan >= 1);
    if (cRowSpan > 1)
    {
        pRow->_fHaveRowSpanCells = TRUE;
        const CFancyFormat * pFFRow = pRow->GetFirstBranch()->GetFancyFormat();
        if (pFFRow->_bPositionType == stylePositionabsolute)
            fAbsolutePositionedRow = TRUE;
        if (pFFRow->_bDisplay == styleDisplayNone)
            fDisplayNoneRow = TRUE;
    }

    fDisplayNoneCell = pFF->_bDisplay == styleDisplayNone;
    
    if (   fDisplayNoneRow 
        || fAbsolutePositionedRow 
        || fDisplayNoneCell)
    {
        hr = AddDisplayNoneCell(pCell);
        if (hr)
            goto Cleanup;
        goto Done;
    }

    if (pFF->_bPositionType == stylePositionabsolute)
    {
        hr = AddDisplayNoneCell(pCell);
        if (hr)
            goto Cleanup;
        hr = pTableLayout->AddAbsolutePositionCell(pCell);
        if (hr)
            goto Cleanup;
        goto Done;
    }

    // expand row

    if (cCols < iAt + cColSpan)
    {
        hr = EnsureCells(iAt + cColSpan);
        if (hr)
            goto Cleanup;

        hr = pTableLayout->EnsureCols(iAt + cColSpan);
        if (hr)
            goto Cleanup;

        EnsureCells(iAt + cColSpan);
    }

    pTableLayout->SetLastNonVirtualCol(iAt);

    Assert(IsEmpty(_aryCells[iAt]));
    SetCell(iAt, pCell);

    if (cRowSpan != 1)
    {
        hr = pTableLayout->EnsureRowSpanVector(iAt + cColSpan);
        if (hr)
            goto Cleanup;
        pTableLayout->AddRowSpanCell(iAt, cRowSpan);

        // 71720: Turn off _fAllRowsSameShape optimization when we run into rowspanned cells.
        // Note we are not using RowSpan() because we haven't seen the next row yet to see if it is in the same section.
        pTableLayout->_fAllRowsSameShape = FALSE;
    }

    pTableLayout->_cTotalColSpan += cColSpan;   // total number of col spans for this row

    cColSpan--;

    while (cColSpan--)
    {
        ++iAt;
        if (!IsEmpty(_aryCells[iAt]))
        {
            pCellOverlap = Cell(_aryCells[iAt]);
            if (pCellOverlap->ColIndex() == iAt)
            {
                // overlapped cell is always spanned
                SetCell(iAt, MarkSpannedAndOverlapped(pCellOverlap));
            }
        }
        else
        {
            SetCell(iAt, MarkSpanned(pCell));
        }
    }

Done:
    // increment the number of real cells
    _cRealCells++;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDisplayNoneCell
//
//  Synopsis:   Add a display-none cell to the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::AddDisplayNoneCell(CTableCell * pCell)
{
    HRESULT hr;
    CDispNode * pDispNode = NULL;

    Assert (pCell);

    CTableCellLayout *pCellLayout = pCell->Layout();
    Assert (pCellLayout);

    if (!_pDisplayNoneCells)
    {
        _pDisplayNoneCells = new  (Mt(CTableRowLayout_pDisplayNoneCells_pv)) CPtrAry<CTableCell *> (Mt(CTableRowLayout_pDisplayNoneCells_pv));
        if (!_pDisplayNoneCells)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    hr = _pDisplayNoneCells->Append(pCell);
    if (!hr)
        pCell->AddRef();

    pDispNode = pCellLayout->GetElementDispNode();
    if (pDispNode)
    {
        GetView()->ExtractDispNode(pDispNode);
    }

    pCellLayout->_fDisplayNoneCell = TRUE;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCells
//
//  Synopsis:   Make sure there are at least cCells number of slots in the row
//
//----------------------------------------------------------------------------

HRESULT
CTableRowLayout::EnsureCells(int cCells)
{
    int c = _aryCells.Size();
    HRESULT hr = _aryCells.EnsureSize(cCells);
    if (hr)
        goto Cleanup;

    Assert(c <= cCells);
    _aryCells.SetSize(cCells);
    while (cCells-- > c)
    {
        // don't go through the SetCell call here because MarkEmpty is a 
        // special value that should not be addref'd
        _aryCells[cCells] = ::MarkEmpty();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearRowLayoutCache
//
//  Synopsis:   Empty the array of cells.
//
//----------------------------------------------------------------------------

void
CTableRowLayout::ClearRowLayoutCache()
{
    // don't allow access to this array after this call
    if (TableRow())
        TableRow()->InvalidateCollections();

    ReleaseAllCells();
    _cRealCells = 0;
    if (_pDisplayNoneCells)
    {
        _pDisplayNoneCells->ReleaseAll();
        _pDisplayNoneCells->DeleteAll();
        delete _pDisplayNoneCells;

        _pDisplayNoneCells = NULL;
    }

}


//+------------------------------------------------------------------------
//
//  Member:     AdjustHeightCore
//
//  Synopsis:   adjust height of the row for specified height / minHeight (puvHeight)
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustHeightCore(
                    const CHeightUnitValue  *puvHeight,     //  height to adjust to 
                    CCalcInfo               *pci, 
                    CTable                  *pTable 
                    )
{
    Assert(puvHeight && puvHeight->IsSpecified() && pci && pTable);

    // set row unit height if not set or smaller then the cell height
    if (!IsHeightSpecified())
    {
        goto Adjustment;
    }
    else if (puvHeight->IsSpecifiedInPercent())
    {
        // set if smaller
        if (IsHeightSpecifiedInPercent())
        {
            if (GetHeightUnitValue() < puvHeight->GetUnitValue())
            {
                goto Adjustment;
            }
        }
        else
        {
            // percent has precedence over normal height
            goto Adjustment;
        }
    }
    else if (!IsHeightSpecifiedInPercent())
    {
        // set if smaller
        if (GetPixelHeight(pci) < puvHeight->GetPixelHeight(pci, pTable))
        {
            goto Adjustment;
        }
    }
    return;

Adjustment:
    _uvHeight = *puvHeight;
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     AdjustHeight
//
//  Synopsis:   adjust height of the row for specified height of the node
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustHeight(CTreeNode *pNode, CCalcInfo *pci, CTable *pTable)
{
    Assert(pNode);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    const CHeightUnitValue * puvHeight = (const CHeightUnitValue *)&pNode->GetFancyFormat()->GetHeight();
    if (puvHeight->IsSpecified())
    {
        AdjustHeightCore(puvHeight, pci, pTable); 
    }
}

//+------------------------------------------------------------------------
//
//  Member:     AdjustMinHeight
//
//  Synopsis:   adjust height of the row for specified minHeight of the node
//
//-------------------------------------------------------------------------
void 
CTableRowLayout::AdjustMinHeight(CTreeNode *pNode, CCalcInfo *pci, CTable *pTable)
{
    Assert(TableLayoutCache() && TableLayoutCache()->IsFixed());    //  This adjustment is for fixed layout tables only
    Assert(pNode);

    // Get cell's height in table coordinate system (table is always horizontal => physical height)
    const CHeightUnitValue * puvMinHeight = (const CHeightUnitValue *)&pNode->GetFancyFormat()->GetMinHeight();
    if (puvMinHeight->IsSpecified())
    {
        AdjustHeightCore(puvMinHeight, pci, pTable); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\table\ltpos.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ltpos.cxx
//
//  Contents:   CTableLayout positioning methods.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif


ExternTag(tagTableRecalc);
ExternTag(tagLayout);


//+----------------------------------------------------------------------------
//
//  Member:     GetPositionInFlow
//
//  Synopsis:   Return the position of a layout derived from its position within
//              the document text flow
//
//  Arguments:  pLayout - Layout to position
//              ppt     - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------

void
CTableLayoutBlock::GetPositionInFlow(CElement *pElement, CPoint  *ppt)
{
    Assert(ppt);

    CLayoutContext  *pLayoutContext = LayoutContext();
    Assert(pElement->CurrentlyHasLayoutInContext(pLayoutContext) && "Layout MUST exist in the layout context.");

    CLayout *pLayout = pElement->CurrentlyHasLayoutInContext(pLayoutContext) ? pElement->GetUpdatedLayout(pLayoutContext) : NULL;
    Assert(pLayout && "We are in deep trouble if the element passed in doesn't have a layout");

    if (!pLayout)
    {
        *ppt = g_Zero.pt;
        return;
    }

    BOOL fRTL = IsRightToLeft();

    //
    // Locate the layout within the document
    //

    ppt->x = pLayout->GetXProposed();
    ppt->y = pLayout->GetYProposed();

    if(fRTL)
    {
        CTableLayout *pTableLayoutCache = Table()->TableLayoutCache();
        Assert(pTableLayoutCache);

        // TODO RTL 112514: this is close, but not exactly same as in SetCellPositions
        int xTableWidth = GetWidth();
        
        ppt->x = xTableWidth + ppt->x
               - pTableLayoutCache->_aiBorderWidths[SIDE_LEFT];

        // TODO RTL 112514: this looks like a total hack, and it is.
        //                  there shouldn't be any RTL-specific code for Y, 
        //                  but the result is wrong unless we do this, and we don't ever get here
        //                  in LTR case, so there is no way to check if the standard calculation 
        //                  is correct
        ppt->y -= pTableLayoutCache->_aiBorderWidths[SIDE_TOP];

    }
    else if (pElement->Tag() != ETAG_TR)
    {
        // this code should be in sync with CTableLayout::SetCellPositions()
        CTableCell *pTableCell      = DYNCAST(CTableCell, pElement);
        BOOL        fPositionedRow  = pTableCell->Row()->IsPositioned(); 

        // adjust the proposed position if the cell is not positioned
        // or it is positioned and the row is not positioned and cell is directly 
        // under the grid node.
        // or if cell is relatively positioned and the row is also positioned
        if (   !pTableCell->IsPositioned() 
            || (!fPositionedRow && IsGridAndMainDisplayNodeTheSame())
            || fPositionedRow  )
        {
            CTableLayout * pTableLayoutCache = Table()->TableLayoutCache();
            Assert(pTableLayoutCache);

            ppt->x -= pTableLayoutCache->_aiBorderWidths[SIDE_LEFT];

            if (!fPositionedRow)
                ppt->y -= (pTableLayoutCache->_aiBorderWidths[SIDE_TOP] + _yTableTop);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     AddLayoutDispNode
//
//  Synopsis:   Add the display node of passed layout
//
//  Arguments:  pci            - CalcInfo (used for retrieving layout context) 
//              pLayout        - Layout whose display node is to be added
//              pDispContainer - CDispNode which should contain the display node
//              pDispSibling   - Left-hand sibling display node
//              ppt            - Pointer to POINT with position or NULL
//              fBefore        - FALSE to add as next sibling, TRUE to add as previous sibling
//
//              NOTE: Either pDispContainer or pDispSibling must be supplied, the
//                    other may be NULL
//
//  Returns:    S_OK if added, S_FALSE if ignored, E_FAIL otherwise
//-----------------------------------------------------------------------------
HRESULT
CTableLayout::AddLayoutDispNode(
    CTableCalcInfo *    ptci,
    CLayout *           pLayout,
    CDispContainer *    pDispContainer,
    CDispNode *         pDispNodeSibling,
    const POINT *       ppt,
    BOOL                fBefore)
 {
    CDispNode * pDispNode;
    HRESULT     hr = S_OK;
    CPoint      ptTopRight = g_Zero.pt;

    Assert(pLayout);
    Assert(pLayout != this);
    Assert(pDispContainer || pDispNodeSibling);

    if (ptci->TableLayout()->_pDispNode == NULL)
    {
        goto Error;
    }

    pDispNode = pLayout->GetElementDispNode();

    if (!pDispNode)
        goto Error;

    Assert(pDispNode != pDispNodeSibling);
    Assert(pDispNode->IsOwned());
    Assert(pDispNode->IsFlowNode());

    if (!pLayout->IsDisplayNone())
    {
        if (ppt)
        {
            pLayout->SetPosition(*ppt, TRUE);
        }

        if (pDispNodeSibling)
        {
            pDispNodeSibling->InsertSiblingNode(pDispNode, (CDispNode::BeforeAfterEnum)fBefore);

        }
        else
        {
            pDispContainer->InsertFirstChildInFlow(pDispNode);
        }

    }
    else
    {
        GetView()->ExtractDispNode(pDispNode);
        hr = S_FALSE;
    }

    return hr;

Error:
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureTableBorderDispNode
//
//  Synopsis:   Manage the lifetime of the table border display node during measuring
//
//  Arugments:  pdci   - Current CDocInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed
//              E_FAIL  otherwise
//
//-----------------------------------------------------------------------------

HRESULT
CTableLayout::EnsureTableBorderDispNode(CTableCalcInfo * ptci)
{
    CDispContainer *    pDispNodeTableGrid;
    CTableLayoutBlock * pTableLayoutBlock = ptci->TableLayout();
    CTableBorderRenderer *pTableBorderRenderer = pTableLayoutBlock->GetTableBorderRenderer();
    HRESULT hr = S_OK;

    Assert(pTableLayoutBlock->_pDispNode != NULL);

    // Locate the display node that anchors all cells.  This will be the
    // parent of the border display node if one is needed.
    pDispNodeTableGrid = pTableLayoutBlock->GetTableOuterDispNode();

    Assert(pDispNodeTableGrid);

    if ((_fCollapse || _fRuleOrFrameAffectBorders) && GetRows())
    {
        CDispLeafNode * pDispLeafNew = NULL;
        CDispLeafNode * pDispLeafCurrent = NULL;
        CRect   rcClientRect;
        SIZE    size;

        if ( !pTableBorderRenderer )
        {
            pTableBorderRenderer = new CTableBorderRenderer(pTableLayoutBlock);
            if (!pTableBorderRenderer)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pTableLayoutBlock->SetTableBorderRenderer( pTableBorderRenderer );
        }
        else
        {
            if( pTableBorderRenderer->_pDispNode )
                pDispLeafCurrent = DYNCAST(CDispLeafNode, pTableBorderRenderer->_pDispNode);
        }

        // if we don't have a disp node, or are changing directions, create a new node
        if ( !pTableBorderRenderer->_pDispNode )
        {
            // Create display leaf node (this border dispnode has no border of
            // its own)
            pDispLeafNew = CDispLeafNode::New(pTableBorderRenderer);

            if (!pDispLeafNew)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Assert(!pDispLeafNew->IsOwned());
            // The border display node is in the flow layer (highest z-order among flow display nodes).
            pDispLeafNew->SetLayerFlow();

            Assert(!pDispLeafCurrent);  // thise could only happen when we replaced 
                                        // disp nodes on direction change

            pDispNodeTableGrid->InsertChildInFlow(pDispLeafNew);

            pTableBorderRenderer->_pDispNode = pDispLeafNew;
        }
        else
        {
            pDispLeafNew = DYNCAST(CDispLeafNode, pTableBorderRenderer->_pDispNode);
            // Make sure border display node is last in list (highest z order among display node FLOW layers).

            // If we have a "next" (right) sibling, reinsert the border display node in the last position
            if (pDispLeafNew->GetNextFlowNode())
            {
                GetView()->ExtractDispNode(pDispLeafNew);
                pDispNodeTableGrid->InsertChildInFlow(pDispLeafNew);
            }
        }

        Assert(pDispLeafNew);

        // Make sure the border display node has the right size.
        // Size should always be adjusted for table borders since we
        // just finished a layout.
        pDispNodeTableGrid->GetClientRect(&rcClientRect, CLIENTRECT_CONTENT);
        rcClientRect.GetSize(&size);
        pDispLeafNew->SetSize(size, NULL, FALSE);
    }
    else if ( pTableBorderRenderer )
    {
        CDispNode * pDispNode = pTableBorderRenderer->_pDispNode;

        if (pDispNode)
        {
            pDispNode->Destroy();
            pTableBorderRenderer->_pDispNode = NULL;
        }

        pTableBorderRenderer->Release();
        pTableLayoutBlock->SetTableBorderRenderer(NULL);
    }

Cleanup:

    RRETURN(hr);
}


void
CTableLayoutBlock::EnsureContentVisibility(
    CDispNode * pDispNode,
    BOOL        fVisible)
{
    // take care of visibility of collapsed border display node
    if (    pDispNode == GetElementDispNode())
    {
        // first handle collapsed and frame borders
        if (   (   Table()->TableLayoutCache()->_fCollapse
                ||  Table()->TableLayoutCache()->_fRuleOrFrameAffectBorders)
            &&  _pTableBorderRenderer
            &&  _pTableBorderRenderer->_pDispNode)
        {
            _pTableBorderRenderer->_pDispNode->SetVisible(fVisible);
        }

        // now handle caption dispNode
        if (   _fHasCaptionDispNode
            && GetCaptionDispNode())
        {
            GetTableOuterDispNode()->SetVisible(fVisible);
        }
    }
}

//+====================================================================================
//
// Method: EnsureTableFatHitTest
//
// Synopsis: Ensure the FatHit Test bit on the DispNode is set appropriately. 
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
//
// TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
//

HRESULT             
CTableLayout::EnsureTableFatHitTest(CDispNode* pDispNode)
{
    pDispNode->SetFatHitTest( GetFatHitTest() );

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: GetFatHitTest
//
// Synopsis: Get whether this table layout requires "fat" hit testing.
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
//
// TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
//

BOOL
CTableLayout::GetFatHitTest()
{
    return ( IsEditable() &&
             CellSpacingX() == 0 && 
             CellSpacingY() == 0 &&
             BorderX() <= 1 && 
             BorderY() <= 1 ) ;
}

#ifdef NEVER 
//+----------------------------------------------------------------------------
//
//  Member:     GetTableSize
//
//  Synopsis:   Return the current width/height of the table
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------
void
CTableLayout::GetTableSize(
    CSize * psize)
{
    CDispNode * pDispNode;

    Assert(psize);

    pDispNode = GetTableOuterDispNode();

    if (pDispNode)
    {
        *psize = pDispNode->GetSize();
    }
    else
    {
        *psize = g_Zero.size;
    }
}
#endif // NEVER 


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNode
//
//  Synopsis:   Adjust the size of the table layout display node
//
//  Arugments:  pci       - Current CCalcInfo
//              size      - Size including CAPTIONs
//              sizeTable - Size excluding CAPTIONs
//
//-----------------------------------------------------------------------------
void
CTableLayout::SizeTableDispNode(
    CTableCalcInfo *ptci,
    const SIZE &    size,
    const SIZE &    sizeTable,
    int             yTopInvalidRegion)

{
    CElement *          pElement = ElementOwner();
    CDispContainer *    pDispNodeTableOuter;
    CDispNode *         pDispNodeElement;
    BOOL                fInvalidateAll;
    DISPNODEBORDER      dnb;
    CSize               sizeOriginal;
    CDoc *              pDoc;
    CTableLayoutBlock * pTableLayout;
    CRect               rcpMapped;
    CRect *             prcpMappedElement = NULL;
    CRect *             prcpMappedOuter = NULL;

    Assert(ptci);

    pTableLayout = ptci->TableLayout();

    if (pTableLayout->_pDispNode == NULL)
    {
        goto Cleanup;
    }

    //
    //  Locate the display node that anchors all cells
    //  (If a separate CAPTIONs display node exists, the display node for cells
    //   will be the only unowned node in the flow layer)
    //

    pDispNodeElement    = pTableLayout->GetElementDispNode();
    pDispNodeTableOuter = pTableLayout->GetTableOuterDispNode();

    //
    // Invalidate the entire table area if its size has changed.
    //

    sizeOriginal = pDispNodeElement->GetSize();

    fInvalidateAll = sizeOriginal != sizeTable;

    //
    //  Set the border size (if any)
    //  NOTE: These are set before the size because a change in border widths
    //        forces a full invalidation of the display node. If a full
    //        invalidation is necessary, less code is executed when the
    //        display node's size is set.
    //

    dnb            = pDispNodeTableOuter->GetBorderType();
    pDoc           = Doc();

    if (dnb != DISPNODEBORDER_NONE)
    {
        CRect       rcBorderWidths;
        CRect       rc;
        CBorderInfo bi;

        pDispNodeTableOuter->GetBorderWidths(&rcBorderWidths);

        pElement->GetBorderInfo(ptci, &bi, FALSE, FALSE);

        rc.left   = bi.aiWidths[SIDE_LEFT];
        rc.top    = bi.aiWidths[SIDE_TOP];
        rc.right  = bi.aiWidths[SIDE_RIGHT];
        rc.bottom = bi.aiWidths[SIDE_BOTTOM];

        if (rc != rcBorderWidths)
        {
            if (dnb == DISPNODEBORDER_SIMPLE)
            {
                pDispNodeTableOuter->SetBorderWidths(rc.top);
            }
            else
            {
                pDispNodeTableOuter->SetBorderWidths(rc);
            }

            fInvalidateAll = TRUE;
        }
    }

    //
    //  Determine if a full invalidation is necessary
    //  (A full invalidation is necessary only when there is a fixed
    //   background located at a percentage of the width/height)
    //

    if (    !fInvalidateAll
        &&  pDispNodeTableOuter->HasBackground()
        &&  pDispNodeTableOuter->IsScroller()
        &&  pDispNodeTableOuter->HasFixedBackground())
    {
        const CFancyFormat *    pFF = GetFirstBranch()->GetFancyFormat();

        // Logical/Physical does not matter when we get bg pos here because
        // 1) Tables are always horizontal
        // 2) We are checking both X and Y here
        fInvalidateAll =    pFF->_lImgCtxCookie
                    &&  (   pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT
                        ||  pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
    }

    //
    //  If there are any behaviors that want to map the size, find out the details
    //  now so we can tell the disp node.
    //

    if (DelegateMapSize(size, &rcpMapped, static_cast<CCalcInfo *>(ptci)))
    {
        if (pTableLayout->_fHasCaptionDispNode)
        {
            prcpMappedElement = &rcpMapped;
        }
        else
        {
            prcpMappedOuter = &rcpMapped;
        }
    }

    //
    //  Size the table node
    //

    if (yTopInvalidRegion)
    {
        // invalidate only the part of the table, starting from the yTopInvalidRegion till the bottom
        CRect rcInvalid;

        Assert (yTopInvalidRegion <= sizeTable.cy);
        rcInvalid.left =0;
        rcInvalid.right = sizeTable.cx;
        rcInvalid.top = yTopInvalidRegion;
        rcInvalid.bottom =  sizeTable.cy;
        fInvalidateAll = FALSE;
        pDispNodeTableOuter->SetSize(sizeTable, prcpMappedOuter, fInvalidateAll);
        pDispNodeTableOuter->Invalidate(rcInvalid, COORDSYS_PARENT);
    }
    else
    {
        pDispNodeTableOuter->SetSize(sizeTable, prcpMappedOuter, fInvalidateAll);
    }

    //
    //  Finally, if CAPTIONs exist, size that node as well
    //

    if (pTableLayout->_fHasCaptionDispNode)
    {
        pDispNodeElement->SetSize(size, prcpMappedElement, fInvalidateAll);
    }

    //
    //  If the display node has an explicit user transformation, set details
    //

    if (pDispNodeElement->HasUserTransform())
    {
        SizeDispNodeUserTransform(ptci, size, pDispNodeElement);
    }

    //
    //  If the display node has an explicit user clip, size it
    //

    if (pDispNodeElement->HasUserClip())
    {
        SizeDispNodeUserClip(ptci, size, pDispNodeElement);
    }

    //
    //  Fire related events
    //

    if (    (CSize &)size != sizeOriginal
        &&  !IsDisplayNone()
        &&  pDoc->_state >= OS_INPLACE
        &&  pElement->GetMarkup()->Window()
        &&  pElement->GetMarkup()->Window()->_fFiredOnLoad)
    {
        pDoc->GetView()->AddEventTask(pElement, DISPID_EVMETH_ONRESIZE);
    }

    if (pElement->ShouldFireEvents())
    {
        if (size.cx != sizeOriginal.cx)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETWIDTH);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTWIDTH);
        }

        if (size.cy != sizeOriginal.cy)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETHEIGHT);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTHEIGHT);
        }
    }
Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyFlowDispNodes
//
//  Synopsis:   Destroy any created flow nodes
//
//-----------------------------------------------------------------------------
void
CTableLayout::DestroyFlowDispNodes()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\ctlrange.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       txtsrang.cxx
//
//  Contents:   Implementation of Control Range
//
//  Class:      CAutoTxtSiteRange
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif


#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "siterang.hdl"

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

MtDefine(CAutoTxtSiteRange, ObjectModel, "CAutoTxtSiteRange")
MtDefine(CAutoTxtSiteRange_aryElements_pv, CAutoTxtSiteRange, "CAutoTxtSiteRange::_aryElements::_pv")
MtDefine(CAutoTxtSiteRangeIterator, ObjectModel, "CAutoTxtSiteRangeIterator")

// IOleCommandTarget methods

BEGIN_TEAROFF_TABLE(CAutoTxtSiteRange, IOleCommandTarget)
    TEAROFF_METHOD(CAutoTxtSiteRange, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CAutoTxtSiteRange, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CAutoTxtSiteRange::s_classdesc =
{
    0,                              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLControlRange,     // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CAutoTxtSiteRange constructor
//
//-------------------------------------------------------------------------

CAutoTxtSiteRange::CAutoTxtSiteRange(CElement * pElementOwner)
    : _aryElements(Mt(CAutoTxtSiteRange_aryElements_pv))
{
    _pElementOwner = pElementOwner;   
}


CAutoTxtSiteRange::~CAutoTxtSiteRange()
{
    int             iElement;
    CElementSegment **ppSegment = NULL;
    
    _EditRouter.Passivate();

    for ( iElement = _aryElements.Size(), ppSegment = _aryElements;
            iElement > 0;
            iElement--, ppSegment++ )
    {
        delete *ppSegment;
    }

    _aryElements.DeleteAll();
    
}


//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLControlRange)
        QI_TEAROFF(this, IOleCommandTarget, (IHTMLControlRange *)this)
        QI_INHERITS(this, IHTMLControlRange)
        QI_INHERITS(this, IHTMLControlRange2)
        QI_INHERITS(this, ISegmentList)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    } 

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   defer to base object
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::CloseErrorInfo(HRESULT hr)
{
    return _pElementOwner->CloseErrorInfo(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   add any element that can have a laypout to the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::addElement(IHTMLElement *pDisp)
{
    HRESULT hr = E_POINTER;
    CElement *pElement;

    if (!pDisp)
        goto Cleanup;

    hr = THR(pDisp->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    return add(pElement);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CAutoTxtSiteRange::add(IHTMLControlElement *pDisp)
{
    HRESULT hr = E_POINTER;
    CElement *pElement;

    if (!pDisp)
        goto Cleanup;

    hr = THR(pDisp->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr)
        goto Cleanup;

    return add(pElement);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     add
//
//  Synopsis:   add a site to the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::add(CElement *pElement)
{
    HRESULT     hr = E_INVALIDARG;
    ELEMENT_TAG eTag;
    CTreeNode * pNode;

    Assert(pElement);

    //
    // Check to see whether this element is a "site"
    //
    pNode = pElement->GetFirstBranch();
    if (! (pNode && pNode->ShouldHaveLayout()) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
        
    //
    // Do not allow table content to be added per bug 44154
    //
    eTag = pElement->Tag();
    switch (eTag)
    {
    case ETAG_BODY:
    case ETAG_TD:
    case ETAG_TR:
    case ETAG_TH:
    case ETAG_TC:
    case ETAG_CAPTION:
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    //
    // Verify that the element being added is within the hierarchy
    // of the owner
    //
    pNode = pElement->GetFirstBranch();
    if ( (pNode == NULL) || (pNode->SearchBranchToRootForScope( _pElementOwner ) == NULL) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // It's OK to add the element
    //
    hr = THR( AddElement( pElement) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CAutoTxtSiteRange::AddElement( CElement* pElement )
{
    IHTMLElement    *pElem = NULL;
    CElementSegment *pSegment = NULL;
    HRESULT         hr;
    
    pSegment = new CElementSegment();
    if( !pSegment )
        goto Error;

    // Retrieve the IHTMLElement, and initialize our segment        
    IFC( pElement->QueryInterface(IID_IHTMLElement, (void **)&pElem) );
    IFC( pSegment->Init( pElem ) );

    // Add it
    IFC( _aryElements.Append( pSegment ) );
    
Cleanup:

    ReleaseInterface( pElem );
    
    RRETURN ( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     delete
//
//  Synopsis:   remove a site from the range
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::remove(long lIndex)
{
    CElementSegment *pSegment = NULL;
    HRESULT         hr = S_OK;

    if ( lIndex < 0 || lIndex >= _aryElements.Size() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pSegment = _aryElements.Item(lIndex);
    
    _aryElements.Delete(lIndex);

    pSegment->Release();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     Select
//
//  Synopsis:   turn this range into the selection, but only if there are
//      sites selected
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::select ( void )
{

    HRESULT         hr = CTL_E_METHODNOTAPPLICABLE;   
    CElement        *pElement = NULL;
    IElementSegment *pISegmentAdded = NULL;
    ISegmentList    *pSegmentList = NULL;
    IHTMLElement    *pIElement = NULL;
    CTreeNode       *pMyNode;
    CDoc            *pDoc = _pElementOwner->Doc();
    int             i;

    if (! _aryElements.Size() )
    {
        //
        // We now place the caret in the edit context
        //
        hr = pDoc->NotifySelection (
                                    EDITOR_NOTIFY_CARET_IN_CONTEXT , 
                                    (IUnknown*) (IHTMLControlRange*) this );   
    }
    else
    {

        // Make the owner current
        if ( pDoc->_state >= OS_INPLACE )
        {
            //
            // NOTE: this was an access fix - with OLE Sites not going UI Active
            // on selecting away from them. Changing currencty should do this "for free".
            //
            if (!_pElementOwner->HasCurrency() && (pDoc->_pElemCurrent->_etag == ETAG_OBJECT))
                pDoc->_pElemCurrent->YieldUI( _pElementOwner );              
        }

        //
        // TODO: (tracking bug 111961) - We should just QI for our own ISegmentList interface and
        // pass this to Select.
        //
        CSegmentList segmentList;
        BOOL		fIsPrimary;
        IFC( segmentList.SetSelectionType( SELECTION_TYPE_Control ));

        for ( i = 0; i < _aryElements.Size(); i ++ )
        {
            IFC( LookupElement( _aryElements.Item(i), &pElement ) );
            
            pMyNode = pElement->GetFirstBranch();
            Assert( pMyNode );
            if ( ! pMyNode )
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IFC( _aryElements.Item(i)->GetElement(&pIElement) );
            IFC( segmentList.AddElementSegment( pIElement, &pISegmentAdded));      
            Assert(pISegmentAdded);
            if (pISegmentAdded)
            {
	         IFC( _aryElements.Item(i)->IsPrimary(&fIsPrimary));
	         IFC( pISegmentAdded->SetPrimary(fIsPrimary) );
            }            
            ClearInterface( &pIElement );
            ClearInterface( &pISegmentAdded );
        }

        // Select these segments
        IFC( segmentList.QueryInterface( IID_ISegmentList, (void **)&pSegmentList ) );
        IFC( pDoc->Select(pSegmentList));
    }

Cleanup:                                    

    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIElement );

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Getlength
//
//  Synopsis:   SiteRange object model
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::get_length(long * plSize)
{
    *plSize = _aryElements.Size();

    RRETURN(SetErrorInfo(S_OK));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   SiteRange object model Method
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::item ( long lIndex, IHTMLElement ** ppElem )
{
    HRESULT     hr = E_INVALIDARG;
    CElementSegment *pSegment;

    if (! ppElem)
        goto Cleanup;

    *ppElem = NULL;

    // Check Index validity, too low
    if (lIndex < 0)
        goto Cleanup;

    // ... too high
    if (lIndex >=_aryElements.Size())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // ... just right    
    pSegment = _aryElements[ lIndex ];

    if (! pSegment )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR( pSegment->GetElement(ppElem));
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     scrollIntoView
//
//  Synopsis:   scroll the first control into view
//
//-------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::scrollIntoView (VARIANTARG varargStart)
{
    HRESULT         hr = CTL_E_METHODNOTAPPLICABLE;
    CElementSegment *pSegment = NULL;
    CElement        *pElement = NULL;

    if (! _aryElements.Size() )
        goto Cleanup;

    //
    // Multiple selection not supported, only the first item
    // is scrolled into view
    //
    pSegment = _aryElements[ 0 ]; 
    if (! pSegment )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    IFC( LookupElement( pSegment, &pElement ) );
    IFC( pElement->scrollIntoView(varargStart) );

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     commonParentElement()
//
//  Synopsis:   Return the common parent for elements in the control range
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoTxtSiteRange::commonParentElement ( IHTMLElement ** ppParent )
{
    HRESULT         hr = S_OK;
    LONG            nSites;
    CTreeNode       *pNodeCommon;
    int             i;
    CElement        *pElement = NULL;

    //
    // Check incoming pointer
    //
    if (!ppParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppParent = NULL;

    nSites = _aryElements.Size();

    if (nSites <= 0)
        goto Cleanup;

    //
    // Loop through the elements to find their common parent
    //
    IFC( LookupElement( _aryElements[0], &pElement ) );
    pNodeCommon = pElement->GetFirstBranch();
    
    for(i = 1; i < nSites; i++)
    {
        IFC( LookupElement( _aryElements[i], &pElement ) );
        pNodeCommon = pElement->GetFirstBranch()->GetFirstCommonAncestor(pNodeCommon, NULL);
    }

    if (! pNodeCommon)
        goto Cleanup;

    hr = THR( pNodeCommon->Element()->QueryInterface( IID_IHTMLElement, (void **) ppParent ) );
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo(hr) );

}


//+--------------------------------------------------------------------------
//
// Member : CTxtSiteRange::Exec
//
// Sysnopsis : deal with commands related to sites in text
//
//+--------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT         hr = S_OK;
    int             iElement;
    CDoc         *  pDoc;
    CElement     *  pElement = NULL;
    AAINDEX         aaindex;
    IUnknown *      pUnk = NULL;
    
    Assert( _pElementOwner );
    pDoc = _pElementOwner->Doc();
    Assert( pDoc );

    aaindex = FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
    if (aaindex != AA_IDX_UNKNOWN)
    {
        hr = THR(GetUnknownObjectAt(aaindex, &pUnk));
        if (hr)
            goto Cleanup;
    }
    
    //
    // Allow the elements a chance to handle the command
    //
    for ( iElement = 0; iElement < _aryElements.Size(); iElement++ )
    {
        IFC( LookupElement( _aryElements.Item( iElement ), &pElement ) );

        if (pUnk)
        {
            pElement->AddUnknownObject(
                DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
        }
        
        hr = THR( pElement->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
        if (pUnk)
        {
            pElement->FindAAIndexAndDelete(
                DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        }
        
        if (hr)
            break;
    }

    //
    // Route the command using the edit router, unless all 
    // elements handled it already
    //
    if (hr || !pElement)
    {
        hr = THR( _EditRouter.ExecEditCommand(pguidCmdGroup,
                                        nCmdID, nCmdexecopt,
                                        pvarargIn, pvarargOut,
                                        (IUnknown *) (IHTMLControlRange *)this, 
                                        pDoc ) );                
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN(hr);
}


VOID 
CAutoTxtSiteRange::QueryStatusSitesNeeded(MSOCMD *pCmd, INT cSitesNeeded)
{
    pCmd->cmdf = (cSitesNeeded <= _aryElements.Size()) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED; 
}
//+--------------------------------------------------------------------------
//
// Member : CAutoTxtSiteRange::QueryStatus
//
// Sysnopsis : deal with commands related to sites in text
//
//+--------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::QueryStatus(
    GUID * pguidCmdGroup,
    ULONG cCmds,
    MSOCMD rgCmds[],
    MSOCMDTEXT * pcmdtext)
{
    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;
    CDoc  *     pDoc;
    DWORD       cmdID;

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert( _pElementOwner );
    pDoc = _pElementOwner->Doc();
    Assert( pDoc );
    
    cmdID = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (cmdID)
    {        
    case IDM_DYNSRCPLAY:
    case IDM_DYNSRCSTOP:

    case IDM_BROWSEMODE:
    case IDM_EDITMODE:
    case IDM_REFRESH:
    case IDM_REDO:
    case IDM_UNDO:
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        break;
        
    case IDM_SIZETOCONTROLWIDTH:
    case IDM_SIZETOCONTROLHEIGHT:
    case IDM_SIZETOCONTROL:
        QueryStatusSitesNeeded(pCmd, 2);
        break;

    case IDM_SIZETOFIT:
        QueryStatusSitesNeeded(pCmd, 1);
        break;
        
    case IDM_CODE:
    break;

    case IDM_OVERWRITE:
    case IDM_SELECTALL:
    case IDM_CLEARSELECTION:
        // Delegate this command to document
        if(_pElementOwner != NULL && _pElementOwner->Doc()!= NULL)
        {
            hr = _pElementOwner->Doc()->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
        break;
    break;

    default:
        // Make sure we have at least one contol
        QueryStatusSitesNeeded(pCmd, 1);

        if (pCmd->cmdf == MSOCMDSTATE_DISABLED)
        {
            break;
        }

        // Delegate to the edit router
        hr = _EditRouter.QueryStatusEditCommand(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext,
                    (IUnknown *) (IHTMLControlRange *)this,
                    NULL,                                       // No CMarkup ptr for Ranges
                    pDoc );

    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandSupported(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandEnabled(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandState(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandIndeterm(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(CBase::queryCommandText(bstrCmdId, pcmdText));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(CBase::queryCommandValue(bstrCmdId, pvarRet));
}


//+------------------------------------------------------------------------
//
//  Member:     CAutoTxtSiteRange::execCommand
//
//  Synopsis:
//
//-------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT varValue,
                                        VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    BOOL fAllow;

    Assert(_pElementOwner);
    
    if (_pElementOwner->HasMarkupPtr())
    {
        hr = THR(_pElementOwner->GetMarkupPtr()->AllowClipboardAccess(bstrCmdId, &fAllow));
        if (hr || !fAllow)
            goto Cleanup;           // Fail silently

        hr = CBase::execCommand(bstrCmdId, showUI, varValue);

        if (pfRet)
        {
            // We return false when any error occures
            *pfRet = hr ? VB_FALSE : VB_TRUE;
            hr = S_OK;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CAutoTxtSiteRange::execCommandShowHelp(BSTR cmdId, VARIANT_BOOL *pfRet)
{
    HRESULT   hr;
    DWORD     dwCmdId;

    // Convert the command ID from string to number
    hr = CmdIDFromCmdName(cmdId, &dwCmdId);
    if(hr)
        goto Cleanup;

    hr = THR(CBase::execCommandShowHelp(cmdId));

Cleanup:
    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( peType )
    {
        *peType = SELECTION_TYPE_Control; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::IsEmpty
//
//  Synopsis:   Determines whether the segment list is empty or not
//
//  Arguments:  pfEmpty = Empty pointer to BOOL
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::IsEmpty( BOOL *pfEmpty )
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = (_aryElements.Size() == 0) ? TRUE :FALSE; 
        hr = S_OK;
    }        

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::CreateIterator
//
//  Synopsis:   Creates an iterator that can be used to iterate over the 
//              segments in our list.
//
//  Arguments:  pIIter = Iterator to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::CreateIterator( ISegmentListIterator **pIIter )
{
    HRESULT hr = S_OK;

    CAutoTxtSiteRangeIterator *pListIter = new CAutoTxtSiteRangeIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    IFC( pListIter->Init( &_aryElements ) );
    IFC( pListIter->QueryInterface(IID_ISegmentListIterator, (void **)pIIter) );
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRange::LookupElement
//
//  Synopsis:   Retrieves a CElement based on a CElementSegment.
//
//  Arguments:  pSegment = CElementSegment to lookup
//              pElement = Elemen to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRange::LookupElement( CElementSegment *pSegment, CElement **ppElement )
{
    IHTMLElement    *pIElement = NULL;
    HRESULT         hr = E_FAIL;

    Assert( pSegment && ppElement );

    if( pSegment && ppElement )
    {
        IFC( pSegment->GetElement(&pIElement) );
        IFC( pIElement->QueryInterface( CLSID_CElement, (void **)ppElement ) );
    }        

Cleanup:
    ReleaseInterface( pIElement );
    RRETURN(hr);
}    

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::CSegmentListIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoTxtSiteRangeIterator::CAutoTxtSiteRangeIterator()
{
    Assert( _parySegments == NULL );
    _ulRefs = 1;
    _nIndex = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::CAutoTxtSiteRangeIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoTxtSiteRangeIterator::~CAutoTxtSiteRangeIterator()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pFirst = Pointer to first segment
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::Init(CPtrAry<CElementSegment *> *parySegments)
{
    _parySegments = parySegments;
    _nIndex = 0;
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoTxtSiteRangeIterator::First()
{
    _nIndex = 0;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoTxtSiteRangeIterator::Current(ISegment **pISegment)
{
    CElementSegment *pSegment = NULL;
    HRESULT         hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (pISegment != NULL) && (_nIndex < _parySegments->Size() ) )
    {
        pSegment = _parySegments->Item(_nIndex);
           
        hr = pSegment->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::IsDone(void)
{
    return (_nIndex == _parySegments->Size() ) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CAutoTxtSiteRangeIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _nIndex++;
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoTxtSiteRangeIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CAutoTxtSiteRangeIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\doc2.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_EPARA_HXX_
#define X_EPARA_HXX_
#include "epara.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif


#pragma warning(disable:4706) /* assignment within conditional expression */

//+------------------------------------------------------------------------
//
//  Memeber:    GetRunOwnerBranch
//
//  Synopsis:   Locates the highest CSite which owns runs but also
//              occurs beneath pSitecontext
//
//  Arguments:  brElement    - The node from which to begin searching
//              pSiteContext - The context of the owner; that is,
//                             when not NULL, return the highest run
//                             owner in the tree beneath the passed
//                             site. Passing NULL returns the lowest
//                             site in the tree which owns the run
//
//  Returns:    branch which owns the passed iRun or the passed brElement
//              if pSiteContext is the only owner in the chain
//
//-------------------------------------------------------------------------

CTreeNode *
CMarkup::GetRunOwnerBranch(
    CTreeNode * pNode,
    CLayout *   pLayoutContext )
{
    CTreeNode * pNodeLayoutOwnerBranch;
    CTreeNode * pNodeLayoutBranch;
    CElement  * pElementLytCtx = pLayoutContext ? pLayoutContext->ElementOwner() : NULL;

    Assert( pNode );
    Assert( pNode->GetUpdatedNearestLayout(pLayoutContext->LayoutContext()) );
    Assert( !pElementLytCtx || pElementLytCtx->IsRunOwner() );
    
    pNodeLayoutBranch      = pNode->GetUpdatedNearestLayoutNode();
    pNodeLayoutOwnerBranch = NULL;

    do
    {
        CLayout * pLayout;
        
        // set this to the new branch every step
        
        pLayout = pNodeLayoutBranch->GetUpdatedLayout( pLayoutContext->LayoutContext() );

        // if we hit the context get out
        
        if (SameScope( pNodeLayoutBranch, pElementLytCtx ))
        {
            // if we don't have an owner yet the context
            // branch is returned

            if(!pNodeLayoutOwnerBranch)
                pNodeLayoutOwnerBranch = pNodeLayoutBranch;

            break;
        }

        if (pNodeLayoutBranch->Element()->IsRunOwner())
        {
            pNodeLayoutOwnerBranch = pNodeLayoutBranch;

            if (!pElementLytCtx)
                break;
        }

        pNodeLayoutBranch = pNodeLayoutBranch->GetUpdatedParentLayoutNode();
    }
    while ( pNodeLayoutBranch );

#if DBG == 1
    if (pNodeLayoutBranch)
    {
        Assert( pNodeLayoutOwnerBranch );
        Assert( pNodeLayoutOwnerBranch->Element()->IsRunOwner() );
    }
#endif

    return (pNodeLayoutBranch
                ? pNodeLayoutOwnerBranch
                : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     ClearRunCaches
//
//  Synopsis:   This method invalidates cached information associated with a
//              range of runs.
//
//-----------------------------------------------------------------------------

//
// This function is not optimized at all.  It just runs around
// and does the same thing as the function above
//

HRESULT
CMarkup::ClearCaches ( CTreePos * ptpStart, CTreePos * ptpFinish )
{
    CTreePos * ptpCurr, *ptpAfterFinish = ptpFinish->NextTreePos();

    for(ptpCurr = ptpStart;
        ptpCurr != ptpAfterFinish;
        ptpCurr = ptpCurr->NextTreePos())
    {
        if(ptpCurr->IsBeginNode())
        {
            ptpCurr->Branch()->VoidCachedInfo();

            if (ptpCurr->IsEdgeScope())
            {
                CElement * pElementCur = ptpCurr->Branch()->Element();

                // Clear caches on the slave
                if (pElementCur->HasSlavePtr())
                {
                    CTreePos    *ptpStartSlave, *ptpFinishSlave;
                    CElement    *pElementSlave = pElementCur->GetSlavePtr();
                    
                    Assert(pElementSlave->IsInMarkup());
                    pElementSlave->GetTreeExtent(&ptpStartSlave, &ptpFinishSlave);
                    pElementSlave->GetMarkup()->ClearCaches(ptpStartSlave, ptpFinishSlave);
                }
            }
        }
    }

    return S_OK;
}

HRESULT
CMarkup::ClearRunCaches (DWORD dwFlags, CElement *pElement)
{
    CTreePos *  ptpStart            = NULL;
    CTreePos *  ptpEnd;
    BOOL        fClearAllFormats    = dwFlags & ELEMCHNG_CLEARCACHES;
    BOOL        fSettingViewLink    = dwFlags & ELEMCHNG_SETTINGVIEWLINK;
    BOOL        fEnteringView       = dwFlags & ELEMCHNG_ENTERINGVIEW;

    Assert(pElement);
    pElement->GetTreeExtent( & ptpStart, & ptpEnd );

    if (fSettingViewLink)
    {
        // Clear this bit since we don't want to propagate it.
        dwFlags &= ~ELEMCHNG_SETTINGVIEWLINK;
    }

    if (ptpStart)
    {
        CTreePos *ptpAfterFinish = ptpEnd->NextTreePos();

        for( ; ptpStart != ptpAfterFinish; ptpStart = ptpStart->NextTreePos())
        {
            if(ptpStart->IsBeginNode())
            {
                CTreeNode * pNodeCur     = ptpStart->Branch();
                CElement  * pElementCur  = pNodeCur->Element();
                BOOL        fNotifyFormatChange = FALSE;

                if (fEnteringView)
                {
                    CNotification nf;

                    nf.ElementEnterview1(pElementCur );
                    pElementCur->Notify(&nf);
                }
                if(fClearAllFormats)
                {
                    // clear the formats on the node
                    pNodeCur->VoidCachedInfo();
                    fNotifyFormatChange = TRUE;
                }
                else if (pElement == pElementCur || pElementCur->_fInheritFF)
                {
                    pNodeCur->VoidFancyFormat();
                    fNotifyFormatChange = pElement == pElementCur;
                }


                // if the node comming into scope is a new element
                // notify the element of a format cache change.
                if (fNotifyFormatChange && ptpStart->IsEdgeScope())
                {
                    if (pElementCur->CurrentlyHasAnyLayout())
                    {
                        pElementCur->GetLayoutInfo()->OnFormatsChange(dwFlags);
                    }

                    // Clear caches on the slave
                    if (    pElementCur->HasSlavePtr()
                        // (olego) but don't let go down into layoutRects -- 
                        // this will crash our non-incremental calc of layoutRects. (IE6 14804)
                        &&  !pElementCur->IsLinkedContentElement()  )
                    {
                        CElement * pElementSlave = pElementCur->GetSlavePtr();

                        if (pElementSlave->IsInMarkup())
                        {
                            DWORD   dwFlagsNew  = dwFlags;

                            if (fSettingViewLink && pElementCur == pElement)
                            {
                                dwFlagsNew |= ELEMCHNG_ENTERINGVIEW;
                            }
                            pElementSlave->GetMarkup()->ClearRunCaches(dwFlagsNew, pElementSlave);
                        }
                    }
                }
            }
        }
    }
    else if (pElement->GetFirstBranch())
    {
        // this could happen, when element's are temporarily parented to the
        // rootsite.
        pElement->GetFirstBranch()->VoidCachedInfo();
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     RunsAffected
//
//  Synopsis:   Adds a change event to the CTextChanges object which
//              describes the fact that the chars between two runs have
//              been affected (their tree context changed).
//
//-------------------------------------------------------------------------


HRESULT
CMarkup::RangeAffected ( CTreePos *ptpLeft, CTreePos *ptpRight )
{
    HRESULT         hr;
    CNotification   nf;
    long            cp, cch;
    CTreeNode *     pNodeNotify = NULL;
    CTreePos *      ptpStart = ptpLeft, *ptpAfterLast;

    // clear all of the caches
    hr = THR( ClearCaches( ptpLeft, ptpRight ) );
    if (hr)
        goto Cleanup;

    Assert( ptpLeft && ptpRight );
    ptpAfterLast = ptpRight->NextTreePos();

    // Send the CharsResize notification
    cp  = ptpStart->GetCp();
    cch = 0;

    Assert( cp >= 0 );

    // Note: notifications for the WCH_NODE characters go
    // to intersting places.  For WCH_NODE characters inside
    // of an inclusion, the notifations go to nodes at the
    // bottom of the inclusion.  Also, for edges, notifications
    // go to the parent of the element, not the element itself.
    // This way, noscope elements to not get any notifications
    // in this loop.

    while( ptpStart != ptpAfterLast )
    {
        if( ptpStart->IsNode() )
        {
            // if we are entering an inclusion
            // then remember the first node as the
            // one to send the left half of 
            // the notification to
            if(     ! pNodeNotify 
                &&  ptpStart->IsEndNode() 
                &&  ! ptpStart->IsEdgeScope() )
            {
                pNodeNotify = ptpStart->Branch();
            }

            if( ptpStart->IsBeginElementScope() )
            {
                cch++;
            }

            // send a notification if we hit the edge
            // of a layout
            if(     cch 
                &&  ptpStart->IsEdgeScope() 
                &&  ptpStart->Branch()->ShouldHaveLayout() )
            {
/*
        (dmitryt) APPHACK for ExcelXP Web data import dialog (IE 6 35827)
        this piece of code should look like this:
    
                if( ! pNodeNotify )
                    pNodeNotify = ptpStart->Branch();

                //no assert neccessary. Assert( !pNodeNotify->Element()->IsNoScope() || g_fInExcelXP);

        ... but we don't have enough testing time now at the end of IE 6.0 to do generic fix.
        TODO: do this for IE6.1.
*/

                extern BOOL g_fInExcelXP;


                if( ! pNodeNotify )
                    pNodeNotify = ptpStart->IsBeginNode() && !g_fInExcelXP
                        ? ptpStart->Branch()->Parent()
                        : ptpStart->Branch();

                Assert( !pNodeNotify->Element()->IsNoScope() || g_fInExcelXP);

// end of APPHACK for ExcelXP

                nf.CharsResize( cp, cch, pNodeNotify );
                //(dmitryt) set NFLAGS_FORCE to ensure recalc of no-scope layouts (IE5 bug 112722)
                // this flag will set CFlowLayout::_fDTRForceLayout which tells us "force fill recalc
                // of any layout that happen to be in a dirty text range"
                nf.SetFlag(NFLAGS_FORCE);   
                Notify( nf );

                cp += cch;
                cch = 0;
            }
            
            // If we hit an edge, clear pNodeNotify.  Either we sent
            // a notification or we didn't. Either way, we are done
            // with this inclusion so we don't have to remember pNodeNotify
            if( ptpStart->IsEdgeScope() )
            {
                pNodeNotify = NULL;
            }

            if( ptpStart->IsEndElementScope() )
                cch++;
        }
        else if( ptpStart->IsText() )
        {
            cch += ptpStart->Cch();
        }

        ptpStart = ptpStart->NextTreePos();
    }

    // Finish off any notification left over
    if( cch )
    {
        if( !pNodeNotify )
        {
            CTreePosGap tpg( ptpStart, TPG_LEFT );
            pNodeNotify = tpg.Branch();
        }

        nf.CharsResize( cp, cch, pNodeNotify );
        Notify( nf );
    }

Cleanup:
    RRETURN( hr );
}

#if 0
This routine is not currently needed and may not even be correct!
//+------------------------------------------------------------------------
//
//  Member:     EnsureSidAfterCharsInserted
//
//  Arguments:  pNodeNotify     - the node to send changes to
//              ptpText         - the text pos to examine
//              ich             - the character to start with
//              cch             - the count of characters added
//
//  Synopsis:   Runs through the chracters added and splits off
//              new runs for new script IDs as needed
//
//  Returns:    S_OK if successful
//
//-------------------------------------------------------------------------
HRESULT CMarkup::EnsureSidAfterCharsInserted(
    CTreeNode * pNodeNotify,
    CTreePos *  ptpText,
    long        ichStart,
    long        cch )
{
    Assert( ptpText && ptpText->IsText() );
    Assert( cch > 0 && cch <= ptpText->Cch() );
    Assert( ichStart < ptpText->Cch() );

    HRESULT         hr = S_OK;
    CMarkupUndo     mu( this );
    CTxtPtr         tp( this, ptpText->GetCp() + ichStart );
    long            ichCurr = ichStart;
    long            ichLastAdded = ichStart + cch - 1;
    long            ichLastInRun = ptpText->Cch() - 1;
    CTreePos *      ptpCurr = ptpText;
    long            sidCurr = ptpText->Sid();
    long            sidOrig = sidCurr;
    TCHAR           chCurr = tp.GetChar();
    BOOL            fFirst = TRUE;

    //
    // Iterate through all of the characters added
    //

    for( ; ichCurr <= ichLastAdded; ichCurr++ )
    {
        long    sidNew;

        if( ! fFirst )
            chCurr = tp.NextChar();

        fFirst = FALSE;

        sidNew = ScriptIDFromCh( chCurr );

        // NOTE (t-johnh): This can be a LOT smarter about when
        // to split, as right now, we get excessive fragmentation.
        // This should be using AreDifferentSids, which currently
        // sits in doc.cxx to see when different sids can coexist.
        // HOWEVER, it also needs to be smarter about sidCurr - 
        // sidCurr should represent the sid of the combination of
        // all characters previous in the text pos.

        sidNew = FoldScriptIDs( sidCurr, sidNew );

        if( sidCurr != sidNew )
        {
            if( ichCurr )
            {
                //
                // Split the run at this ich
                //

                mu.TextPosSplit( ptpCurr );

                hr = THR( Split( ptpCurr, ichCurr, sidNew ) );
                if (hr)
                    goto Cleanup;

                Doc()->InvalidateTreeCache();

                // I'm turning this off as it can break linebreaking.
#if NEVER
                // NOTE: this is dangerous as it plays with the run
                // before the run being examined.  The calling code must
                // be aware that the run that it passed in may be invalid
                // after the call! -- Do we really want to do this merging?

                // If this is the fist time we've split, and
                // the new characters start at the beginning of the run, 
                // try to join the left run (with the new characters) with
                // the previous run
                if( nRunsAdded == 0 && ichStart == 0)
                {
                    CTreePos *ptpPrev = ptpCurr->PreviousTreePos();

                    if( ptpPrev->IsText() && ptpPrev->Sid() == ptpCurr->Sid() )
                    {
                        Assert( long(tp.GetCp()) - ichCurr == ptpPrev->GetCp() + ptpPrev->Cch() );
                        nf.RunsJoined( tp.GetCp() - ichCurr, ptpPrev->Index(), ptpPrev->Cch(), pNodeNotify );
                        mu.TextPosJoined( ptpPrev );

                        hr = THR( Join( ptpPrev ) );
                        if (hr)
                            goto Cleanup;

                        nRunsAdded --;

                        Doc()->InvalidateTreeCache();

                        Notify( nf );

                        ptpCurr = ptpPrev;
                    }

                }
#endif

                // We are now examining the added pos
                ptpCurr = ptpCurr->NextTreePos();
                Assert( ptpCurr && ptpCurr->IsText() );

                // Update all of ich's
                ichLastAdded -= ichCurr;
                ichLastInRun -= ichCurr;
                ichCurr = 0;

            }
            else
            {
                // Set the sid for the current run since
                // the run wasn't split, this didn't get
                // set that way.
                mu.TextPosSidChanged( ptpCurr );
                ptpCurr->DataThis()->_sid = sidNew;
            }
        }
        
        //
        // Set up for the next loop
        //

        sidCurr = sidNew;
    }

    //
    // The characters were inserted into the middle
    // of the run.  Split after those characters and give
    // the run the original sid.
    // NOTE: we may want to reexamine this later as if everything
    // left is neutral, we don't want to split again.
    //
    Assert( sidCurr == ptpCurr->Sid() );
    if( sidOrig != sidCurr && ichCurr && ichCurr <= ichLastInRun )
    {
        // Advance to catch up with the ich
        tp.AdvanceCp(1);

        mu.TextPosSplit( ptpCurr );

        hr = THR( Split( ptpCurr, ichCurr, sidOrig ) );
        if (hr)
            goto Cleanup;

        Doc()->InvalidateTreeCache();

#if NEVER
        // Same comment as above
        if( nRunsAdded == 0 && ichStart == 0)
        {
            CTreePos *ptpPrev = ptpCurr->PreviousTreePos();

            if( ptpPrev->IsText() && ptpPrev->Sid() == ptpCurr->Sid() )
            {
                Assert( long(tp.GetCp()) - ichCurr == ptpPrev->GetCp() + ptpPrev->Cch() );
                nf.RunsJoined( tp.GetCp() - ichCurr, ptpPrev->Index(), ptpPrev->Cch(), pNodeNotify );
                mu.TextPosJoined( ptpPrev );

                hr = THR( Join( ptpPrev ) );
                if (hr)
                    goto Cleanup;

                nRunsAdded --;

                Doc()->InvalidateTreeCache();

                Notify( nf );

                ptpCurr = ptpPrev;
            }
        }
#endif
    }

Cleanup:
    RRETURN(hr);
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     SetTextID
//
//  Arguments:  ptpgStart   - where to start setting
//              ptpgEnd     - where to stop setting
//
//  Synopsis:   Gives a unique textID to every chunk of text in the given
//              range.
//
//  Returns:    S_OK if successful
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::SetTextID(
    CTreePosGap *   ptpgStart,
    CTreePosGap *   ptpgEnd,
    long *plNewTextID )
{
    HRESULT hr = S_OK;
    long lTxtID;

    Assert( ! HasUnembeddedPointers() );

    EnsureTotalOrder( ptpgStart, ptpgEnd );

    Assert( ptpgStart && ptpgStart->IsPositioned() && ptpgStart->GetAttachedMarkup() == this );
    Assert( ptpgEnd && ptpgEnd->IsPositioned() && ptpgEnd->GetAttachedMarkup() == this );

    CTreePos *  ptpFirst, * ptpCurr, *ptpStop;
    CDoc *      pDoc = Doc();

    if ( !plNewTextID )
        plNewTextID = &lTxtID;

    *plNewTextID = 0;

    ptpFirst = ptpgStart->AdjacentTreePos( TPG_LEFT );
    ptpCurr = ptpFirst;
    ptpStop = ptpgEnd->AdjacentTreePos( TPG_RIGHT );

    ptpgStart->UnPosition();
    ptpgEnd->UnPosition();

    SplitTextID( ptpCurr, ptpStop );

    ptpCurr = ptpCurr->NextTreePos();

    while( ptpCurr != ptpStop )
    {
        Assert( ptpCurr );

        if( ptpCurr->IsNode() )
        {
            *plNewTextID = 0;
        }

        if( ptpCurr->IsText() )
        {
            if( *plNewTextID == 0 )
            {
                *plNewTextID = ++(pDoc->_lLastTextID);
            }

            hr = THR( SetTextPosID( &ptpCurr, *plNewTextID ) );
            if (hr)
                goto Cleanup;

        }

        ptpCurr = ptpCurr->NextTreePos();
    }

    if( !*plNewTextID )
    {
        CTreePos * ptpNew;
        CTreePosGap tpgInsert( ptpCurr, TPG_RIGHT );

        ptpNew = NewTextPos(0, sidDefault, *plNewTextID = ++(pDoc->_lLastTextID));

        hr = THR(Insert(ptpNew, &tpgInsert));
        if(hr)
            goto Cleanup;
    }

    Verify( ! ptpgStart->MoveTo( ptpFirst, TPG_RIGHT ) );
    Verify( ! ptpgEnd->MoveTo( ptpStop, TPG_LEFT ) );

Cleanup:
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member:     GetTextID
//
//  Arguments:  ptpg        - where
//
//  Synopsis:   Finds the TextID for any text to the right of the gap
//              passed in.
//
//  Returns:    -1 if no text is to the right
//              0  if text to right has no ID assigned
//              otherwise, the textID to the right
//
//-------------------------------------------------------------------------
long 
CMarkup::GetTextID( 
    CTreePosGap * ptpg )
{
    Assert( ptpg && ptpg->IsPositioned() && ptpg->GetAttachedMarkup() == this );

    CTreePos * ptp = ptpg->AdjacentTreePos( TPG_RIGHT );

    while( ! ptp->IsNode() )
    {
        if( ptp->IsText() )
            return ptp->TextID();

        ptp = ptp->NextTreePos();
        Assert( ptp );
    }

    return -1;
}

//+------------------------------------------------------------------------
//
//  Member:     FindTextID
//
//  Arguments:  lTextID     - IN the id to scan for
//              ptpgStart   - IN/OUT where to start scanning
//              ptpgEnd     - OUT the end of the extent
//
//  Synopsis:   Find the extent of lTextID.  Start searching at ptpgStart.
//              Set ptpgStart to the beginning and ptpgEnd to the end of
//              the extent
//
//  Returns:    S_OK if text ID found
//              S_FALSE if text ID not found
//              error otherwise
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::FindTextID(
    long            lTextID,
    CTreePosGap *   ptpgStart,
    CTreePosGap *   ptpgEnd )
{
    Assert( ptpgStart && ptpgStart->IsPositioned() && ptpgStart->GetAttachedMarkup() == this );
    Assert( ptpgEnd );

    CTreePos * ptpLeft, *ptpRight, *ptpFound = NULL;

    ptpLeft = ptpgStart->AdjacentTreePos( TPG_LEFT );
    ptpRight = ptpgStart->AdjacentTreePos( TPG_RIGHT );

    //
    // Start from ptpgStart and search both directions at the same time.
    //

    while( ptpLeft || ptpRight )
    {
        if( ptpLeft )
        {
            if( ptpLeft->IsText() && ptpLeft->TextID() == lTextID )
            {
                ptpRight = ptpLeft;

                // Starting at ptpLeft, loop to the left
                // looking for all of consecutive text poses 
                // with TextID of lTextID
                do
                {
                    if( ptpLeft->IsText() )
                    {
                        if( ptpLeft->TextID() == lTextID )
                        {
                            ptpFound = ptpLeft;
                        }
                        else
                        {
                            break;
                        }
                    }
                    ptpLeft = ptpLeft->PreviousTreePos();
                }
                while( !ptpLeft->IsNode() );

                ptpLeft = ptpFound;

                break;
            }

            ptpLeft = ptpLeft->PreviousTreePos();
        }

        if( ptpRight )
        {
            if( ptpRight->IsText() && ptpRight->TextID() == lTextID )
            {
                ptpLeft = ptpRight;

                // Starting at ptpRight, loop to the right
                // looking for all of consecutive text poses 
                // with TextID of lTextID
                do
                {
                    if( ptpRight->IsText() )
                    {
                        if( ptpRight->TextID() == lTextID )
                        {
                            ptpFound = ptpRight;
                        }
                        else
                        {
                            break;
                        }
                    }
                    ptpRight = ptpRight->NextTreePos();
                }
                while( !ptpRight->IsNode() );

                ptpRight = ptpFound;

                break;
            }
            ptpRight = ptpRight->NextTreePos();
        }
    }

    if( ptpFound )
    {
        Verify( !ptpgStart->MoveTo( ptpLeft, TPG_LEFT ) );
        Verify( !ptpgEnd->MoveTo( ptpRight, TPG_RIGHT ) );

        return S_OK;
    }

    return S_FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     SplitTextID
//
//  Arguments:  ptpLeft     - The left side of the split
//              ptpRight    - The right side to split
//
//  Synopsis:   If text to the left of ptpLeft has the same ID
//              as the text to the right of ptpRight, give the
//              fragment after ptpRight a new ID
//
//-------------------------------------------------------------------------
void
CMarkup::SplitTextID(
    CTreePos *   ptpLeft,
    CTreePos *   ptpRight )
{
    Assert( ptpLeft && ptpRight );

    Assert( ! HasUnembeddedPointers() );

    //
    // Find a text pos to the left if any
    //
    
    while ( ptpLeft )
    {
        if( ptpLeft->IsNode() )
        {
            ptpLeft = NULL;
            break;
        }

        if( ptpLeft->IsText() )
        {
            break;
        }

        ptpLeft = ptpLeft->PreviousTreePos();
    }

    //
    // Find one to the right
    //
    
    while ( ptpRight )
    {
        if( ptpRight->IsNode() )
        {
            ptpRight = NULL;
            break;
        }

        if( ptpRight->IsText() )
        {
            break;
        }

        ptpRight = ptpRight->NextTreePos();
    }

    //
    // If we have one to the left and right and they
    // both have the same ID (that isn't 0) we want
    // to give the fragment to the right a new ID.
    //
    
    if(     ptpLeft 
        &&  ptpRight 
        &&  ptpRight->TextID()
        &&  ptpLeft->TextID() == ptpRight->TextID() )
    {
        long lCurrTextID = ptpRight->TextID();
        long lNewTextID = ++(Doc()->_lLastTextID);

        while( ptpRight && !ptpRight->IsNode() )
        {
            if( ptpRight->IsText() )
            {
                if( ptpRight->TextID() == lCurrTextID )
                {
                    WHEN_DBG( CTreePos * ptpOld = ptpRight );
                    Verify( ! SetTextPosID( &ptpRight, lNewTextID ) );
                    Assert( ptpOld == ptpRight );
                }
                else
                {
                    break;
                }
            }

            ptpRight = ptpRight->NextTreePos();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\disp2.cxx ===
//+----------------------------------------------------------------------------
// File: disp2.cxx
//
// Description: Utility function on CDisplay
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_LSM_HXX
#define X_LSM_HXX
#include "lsm.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifdef MULTI_LAYOUT
#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif
#endif // MULTI_LAYOUT

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#pragma warning(disable:4706) /* assignment within conditional expression */

MtDefine(CDisplayShowSelectedRange_aryInvalRects_pv, Locals, "CDisplay::ShowSelectedRange aryInvalRects::_pv");
MtDefine(CDisplayRegionFromElement_aryChunks_pv, Locals, "CDisplay::RegionFromElement::aryChunks_pv");
MtDefine(CDisplayGetWigglyFromRange_aryWigglyRect_pv, Locals, "CDisplay::GetWigglyFromRange::aryWigglyRect_pv");

DeclareTag(tagNotifyLines, "NotifyLines", "Fix-up a line cch from Notify");
DeclareTag(tagRFEGeneral, "RFE", "General trace");
DeclareTag(tagRFEClipToVis, "RFE", "Clip to Visible trace");

DeclareLSTag(tagDumpLineCache, "Dump line cache info in DumpLines");

// ================================  Line info retrieval  ====================================

/*
 *  CDisplay::YposFromLine(ili)
 *
 *  @mfunc
 *      Computes top of line position
 *
 *  @rdesc
 *      top position of given line (relative to the first line)
 *      Computed by accumulating CLineCore _yHeight's for each line with
 *      _fForceNewLine true.
 */
LONG CDisplay::YposFromLine(
    CCalcInfo * pci,
    LONG        ili,       //@parm Line we're interested in
    LONG      * pyHeight_IgnoreNeg)
{
    LONG yPos;
    CLineCore * pli;
    LONG yPosMax = 0;
    
    // if the flowlayout is hidden, all we have is zero height lines.
    if(GetFlowLayout()->IsDisplayNone())
        return 0;


    if(!WaitForRecalcIli(ili, pci))          // out of range, use last valid line
    {
        ili = LineCount() -1;
        ili = (ili > 0) ? ili : 0;
    }

    yPos = 0;
    for (long i=0; i < ili; i++)
    {
        pli = Elem(i);
        if (pli->_fForceNewLine)
        {
            yPos += pli->_yHeight;
            if (yPosMax < yPos)
            {
                yPosMax = yPos;
            }
        }
    }

    if (pyHeight_IgnoreNeg)
    {
        *pyHeight_IgnoreNeg = yPosMax;
    }
    
    return yPos;
}


/*
 *  CDisplay::CpFromLine(ili, pyHeight)
 *
 *  @mfunc
 *      Computes cp at start of given line
 *      (and top of line position relative to this display)
 *
 *  @rdesc
 *      cp of given line
 */
LONG CDisplay::CpFromLine (
    LONG ili,               // Line we're interested in (if <lt> 0 means caret line)
    LONG *pyHeight) const   // Returns top of line relative to display
{
    long    cp = GetFlowLayout()->GetContentFirstCpForBrokenLayout();
    long    y  = 0;
    CLineCore * pli;

    for (long i=0; i < ili; i++)
    {
        pli = Elem(i);
        if (pli->_fForceNewLine)
        {
            y += pli->_yHeight;
        }
        cp += pli->_cch;
    }

    if(pyHeight)
        *pyHeight = y;

    return cp;
}

//+----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Adjust all internal caches in response to a text change
//              within a nested CTxtSite
//
//  Arguments:  pnf - Notification that describes the change
//
//  NOTE: Only those caches which the notification manager is unaware of
//        need updating (e.g., _dcpCalcMax). Others, such as outstanding
//        change transactions, are handled by the notification manager.
//
//-----------------------------------------------------------------------------

inline BOOL LineIsNotInteresting(CLinePtr& rp)
{
    return rp->IsFrame() || rp->IsClear();
}

void
CDisplay::Notify(CNotification * pnf)
{
    CFlowLayout *   pFlowLayout    = GetFlowLayout();
    CElement *      pElementFL     = pFlowLayout->ElementOwner();
    BOOL            fIsDirty       = pFlowLayout->IsDirty();
    long            cpFirst        = pFlowLayout->GetContentFirstCp();
    long            cpDirty        = cpFirst + pFlowLayout->Cp();
    long            cchNew         = pFlowLayout->CchNew();
    long            cchOld         = pFlowLayout->CchOld();
    long            cpMax          = _dcpCalcMax;
    long            cchDelta       = pnf->CchChanged();
#if DBG==1
    long            dcpLastCalcMax = _dcpCalcMax;
    long            iLine          = -1;
    long            cchLine        = -1;
#endif

    //
    // If no lines yet exist, exit
    //

    if (!LineCount())
        goto Cleanup;

    //
    // Determine the end of the line array
    // (This is normally the maximum calculated cp, but that cp must
    //  be adjusted to take into account outstanding changes.
    //  Changes which overlap the maximum calculated cp effectively
    //  move it to the first cp affected by the change. Changes which
    //  come entirely before move it by the delta in characters of the
    //  change.)
    //

    if (    fIsDirty
        &&  pFlowLayout->Cp() < cpMax)
    {
        if (pFlowLayout->Cp() + cchOld >= cpMax)
        {
            cpMax = pFlowLayout->Cp();
        }
        else
        {
            cpMax += cchNew - cchOld;
        }
    }

    //
    // If the change is past the end of the line array, exit
    //

    if ((pnf->Cp(cpFirst) - cpFirst) > cpMax)
        goto Cleanup;

    //
    // If the change is entirely before or after any pending changes,
    // update the cch of the affected line, the maximum calculated cp,
    // and, if necessary, the first visible cp
    // (Changes which occur within the range of a pending change,
    //  need not be tracked since the affected lines will be completely
    //  recalculated. Additionally, the outstanding change which
    //  represents those changes will itself be updated (by other means)
    //  to cover the changes within the range.)
    // NOTE: The "old" cp must be used to search the line array
    //

    if (    cchDelta
        &&  (   !fIsDirty
            ||  pnf->Cp(cpFirst) <  cpDirty
            ||  pnf->Cp(cpFirst) >= cpDirty + cchNew))
    {
        CLinePtr    rp(this);
        long        cchCurrent  = pFlowLayout->GetContentTextLength();
        long        cchPrevious = cchCurrent - (fIsDirty
                                                    ? cchNew - cchOld
                                                    : 0);
        long        cpPrevious  = !fIsDirty || pnf->Cp(cpFirst) < cpDirty
                                        ? pnf->Cp(cpFirst)
                                        : pnf->Cp(cpFirst) + (cchOld - cchNew);

        //
        // Adjust the maximum calculated cp
        // (Sanitize the value as well - invalid values can result when handling notifications from
        //  elements that extend outside the layout)
        //

        _dcpCalcMax += cchDelta;
        if (_dcpCalcMax < 0)
        {
            _dcpCalcMax = 0;
        }
        else if (_dcpCalcMax > cchPrevious)
        {
            _dcpCalcMax = cchPrevious;
        }

        //----------------------------------------------------------------------------------
        //
        // BEGIN HACK ALERT! BEGIN HACK ALERT! BEGIN HACK ALERT! BEGIN HACK ALERT! 
        //
        // All the code here to find out the correct line to add or remove chars from.
        // Its impossible to accurately detect a line to which characters can be added.
        // So this code makes a best attempt!
        //
        //

        //
        // Find and adjust the affected line
        //
        rp.RpSetCp(cpPrevious, FALSE, FALSE);

        if (cchDelta > 0)
        {
            //
            // We adding at the end of the site?
            //
            if (pnf->Handler()->GetLastCp() == pnf->Cp(cpFirst) + cchDelta)
            {
                //
                // We are adding to the end of the site, we need to go back to a line which
                // has characters so that we can tack on these characters to that line.
                // Note that we have to go back _atleast_ once so that its the prev line
                // onto which we tack on these characters.
                //
                // Note: This also handles the case when the site was empty (no chars) and
                // we are adding characters to it. In this case we will add to the first
                // line prior to the site, because there is no line in the line array where
                // we can add these chars (since it was empty in the first place). If we
                // cannot find a line with characters before this line -- could be we are
                // adding chars to an empty table at beg. of doc., then we will find the
                // line _after_ cp to add it. If we cannot find that either then we will
                // bail out.
                //

                //
                // So go back once only if we were ambigously positioned (We will be correctly
                // positioned if this is last line and last cp of handler is the last cp of this
                // flowlayout). Dont do anything if you cannot go back -- in that
                // case we will go forward later on.
                //
                if (rp.RpGetIch() == 0)
                    rp.PrevLine(FALSE, FALSE);

                //
                // OK, so look backwards to find a line with characters.
                //
                while (LineIsNotInteresting(rp))
                {
                    if (!rp.PrevLine(FALSE, FALSE))
                        break;
                }

                //
                // If we broke out of the while look above, it would mean that we did not
                // find an interesting line before the one at which we were positioned.
                // This should only happen when we have an empty site (like table) at the
                // beginning of the document. In this case we will go forward (the code
                // outside this if block) to find a line. YUCK! This is not ideal but is
                // the best we can do in this situation.
                //
            }

            //
            // We will fall into the following while loop in 3 cases:
            // 1) When we were positioned at the beginning of the site: In this case
            //    we have to make sure that we add the chars to an interesting line.
            //    (note the 3rd possibility, i.e. adding in the middle of a site is trivial
            //    since the original RpSetCp will position us to an interesting line).
            // 2) We were positioned at the end of the site but were unable to find a prev
            //    line, hence we are now looking forward.
            //
            // If we cannot find _any_ interesting line then we shrug our shoulders
            // and bail out.
            //
            while (LineIsNotInteresting(rp))
            {
                if (!rp.NextLine(FALSE, FALSE))
                    goto Cleanup;
            }


            // NOTE: Arye - It shouldn't be necessary to do this here, it should be possible
            // to do it only in the case where we're adding to the end. Since this code
            // is likely to go away with the display tree I'm not going to spend a lot of
            // time making that work right now.
            // Before this, however, in edit mode we might end up on the last (BLANK) line.
            // This is bad, nothing is there to change the number of characters,
            // so just back up.
            if (rp->_cch == 0 && pElementFL->IsEditable(/*fCheckContainerOnly*/FALSE) &&
                rp.GetLineIndex() == LineCount() - 1)
            {
                do  
                {
                    if (!rp.PrevLine(FALSE, FALSE))
                        goto Cleanup;
                } while(LineIsNotInteresting(rp));
            }

            //
            // Right, if we are here then we have a line into which we can pour
            // the characters.
            //
        }

        //
        // We are removing chars. Easy problem; just find a line from which we can remove
        // the chars!
        //
        else
        {
            while (!rp->_cch)
            {
                if (!rp.NextLine(FALSE, FALSE))
                {
                    Assert("No Line to goto, doing nothing");
                    goto Cleanup;
                }
            }
        }

        //
        //
        // END HACK ALERT! END HACK ALERT! END HACK ALERT! END HACK ALERT! END HACK ALERT! 
        //
        //----------------------------------------------------------------------------------

        Assert(rp.GetLineIndex() >= 0);

        // (IEv60 33838) : The assert started to fire in debug on IA64, when ITGWEB was showing "Access Denied" page.
        //Assert(cchDelta > 0 || !rp.GetLineIndex() || ( rp->_cch + cchDelta ) >= 0);
        Check(cchDelta > 0 || !rp.GetLineIndex() || ( rp->_cch + cchDelta ) >= 0);

        WHEN_DBG(iLine = rp.GetLineIndex());
        WHEN_DBG(cchLine = rp->_cch);

        //
        // Update the number of characters in the line
        // (Sanitize the character count if the delta is too large - this can happen for
        //  notifications from elements that extend outside the layout)
        //

        rp->_cch += cchDelta;
        if (!rp.GetLineIndex())
        {
            rp->_cch = max(rp->_cch, 0L);
        }
        else if (rp.IsLastTextLine())
        {
            rp->_cch = min(rp->_cch, rp.RpGetIch() + (cchPrevious  - (cpPrevious - cpFirst)));
        }
        Assert(cchDelta > 0 || !rp.GetLineIndex() || rp->_cch >= 0);
    }

Cleanup:
#if DBG==1
    if (iLine >= 0)
    {
        TraceTagEx((tagNotifyLines, TAG_NONAME,
                    "NotifyLine: (%d) Element(0x%x,%S) ChldNd(%d) dcp(%d) cchDelta(%d) line(%d) cch(%d,%d) dcpCalcMax(%d,%d)",
                    pnf->SerialNumber(),
                    pFlowLayout->ElementOwner(),
                    pFlowLayout->ElementOwner()->TagName(),
                    pnf->Node()->_nSerialNumber,
                    pnf->Cp(cpFirst) - cpFirst,
                    cchDelta,
                    iLine,
                    cchLine, max(0L, cchLine + cchDelta),
                    dcpLastCalcMax, _dcpCalcMax));
    }
    else
    {
        TraceTagEx((tagNotifyLines, TAG_NONAME,
                    "NotifyLine: (%d) Element(0x%x,%S) dcp(%d) dcpCalcMax(%d) delta(%d) IGNORED",
                    pnf->SerialNumber(),
                    pFlowLayout->ElementOwner(),
                    pFlowLayout->ElementOwner()->TagName(),
                    pnf->Cp(cpFirst) - cpFirst,
                    _dcpCalcMax,
                    cchDelta));
    }
#endif
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     LineFromPos
//
//  Synopsis:   Computes the line at a given x/y and returns the appropriate
//              information
//
//  Arguments:  dwBlockID - Layout block ID of this line array
//              prc      - CRect that describes the area in which to look for the line
//              pyLine   - Returned y-offset of the line (may be NULL)
//              pcpLine  - Returned cp at start of line (may be NULL)
//              grfFlags - LFP_xxxx flags
//
//  Returns:    Index of found line (-1 if no line is found)
//
//-----------------------------------------------------------------------------
LONG CDisplay::LineFromPos (
    const CRect &   rc,
    LONG *          pyLine,
    LONG *          pcpLine,
    DWORD           grfFlags,
    LONG            iliStart,
    LONG            iliFinish) const
{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElement    = pFlowLayout->ElementOwner();
    CLineCore   *   pli;
    CLineOtherInfo *ploi;
    long            ili;
    long            yli;
    long            cpli;
    long            iliCandidate;
    long            yliCandidate;
    long            cpliCandidate;
    BOOL            fCandidateWhiteHit;
    long            yIntersect;
    BOOL            fInBrowse = !pElement->IsEditable(FALSE FCCOMMA LC_TO_FC(pFlowLayout->LayoutContext()));

    CRect myRc( rc );

    if( myRc.top < 0 )
        myRc.top = 0;
    if (myRc.bottom < 0)
        myRc.bottom = 0;
    
    Assert(myRc.top    <= myRc.bottom);
    Assert(myRc.left   <= myRc.right);
    //
    //  If hidden or no lines exist, return immediately
    //

    if (    (   pElement->IsDisplayNone(LC_TO_FC(pFlowLayout->LayoutContext()))
            &&  pElement->Tag() != ETAG_BODY)
        ||  LineCount() == 0)
    {
        ili  = -1;
        yli  = 0;
        cpli = GetFirstCp();
        goto FoundIt;
    }

    if (iliStart < 0)
        iliStart = 0;

    if (iliFinish < 0)
        iliFinish = LineCount();

    Assert(iliStart < iliFinish && iliFinish <= LineCount());

    ili  = iliStart;
    pli  = Elem(ili);;
    ploi = pli->oi();
    
    if (iliStart > 0)
    {
        yli  = -pli->GetYTop(ploi);
        cpli = CpFromLine(ili);
        // REVIEW olego(sidda): 12-10-98 xsync. Is cpli computed correctly here for page view case?
    }
    else
    {
        yli  = 0;
        cpli = pFlowLayout->GetContentFirstCpForBrokenLayout(); // MULTI_LAYOUT
    }

    iliCandidate  = -1;
    yliCandidate  = -1;
    cpliCandidate = -1;
    fCandidateWhiteHit = TRUE;

    //
    //  Set up to intersect top or bottom of the passed rectangle
    //

    yIntersect = (grfFlags & LFP_INTERSECTBOTTOM
                        ? myRc.bottom - 1
                        : myRc.top);

    //
    //  Examine all lines that intersect the passed offsets
    //

    while ( ili < iliFinish
        &&  yIntersect >= yli + _yMostNeg)
    {
        pli = Elem(ili);
        ploi = pli->oi();
        
        //
        //  Skip over lines that should be ignored
        //  These include:
        //      1. Lines that do not intersect
        //      2. Hidden and dummy lines
        //      3. Relative lines (when requested)
        //      4. Line chunks that do not intersect the x-offset
        //      5. Its an aligned line and we have been asked to skip aligned lines
        //
        
        if (    yIntersect >= yli + min(0l, pli->GetYLineTop(ploi))
            &&  yIntersect < yli + max(0l, pli->GetYLineBottom(ploi))
            &&  !pli->_fHidden
            &&  (   !pli->_fDummyLine
                ||  !fInBrowse)
            &&  (   !pli->_fRelative
                ||  !(grfFlags & LFP_IGNORERELATIVE))
            &&  (   pli->_fForceNewLine
                ||  (!pli->_fRTLLn
                            ? myRc.left <= pli->GetTextRight(ploi, ili == LineCount() - 1)
                            : myRc.left >= pli->GetRTLTextLeft(ploi)))
            &&  (   (!pli->IsFrame()
                ||   !(grfFlags & LFP_IGNOREALIGNED)))
           )

        {
            //
            //  If searching for the top-most line in z-order,
            //  then save the "hit" line and continue the search
            //  NOTE: Progressing up through the z-order, multiple lines can be hit.
            //        Hits on text always win over hits on whitespace.
            //

            if (grfFlags & LFP_ZORDERSEARCH)
            {
                BOOL    fWhiteHit =  (!pli->_fRTLLn
                                     ? /*LTR*/  (   myRc.left < ploi->GetTextLeft() - (pli->_fHasBulletOrNum
                                                                                     ? ploi->_xLeft
                                                                                     : 0)
                                                ||  myRc.left > pli->GetTextRight(ploi, ili == LineCount() -1))
                                     : /*RTL*/  (   myRc.left < pli->GetRTLTextLeft(ploi)
                                                ||  myRc.left > pli->GetRTLTextRight(ploi) - (pli->_fHasBulletOrNum
                                                                                            ? pli->_xRight
                                                                                            : 0)))
                                ||  (   yIntersect >= yli
                                    &&  yIntersect <  (yli + pli->GetYTop(ploi)))
                                ||  (   yIntersect >= (yli + pli->GetYBottom(ploi))
                                    &&  yIntersect <  (yli + pli->_yHeight));

                if (    iliCandidate < 0
                    ||  !fWhiteHit
                    ||  fCandidateWhiteHit)
                {
                    iliCandidate       = ili;
                    yliCandidate       = yli;
                    cpliCandidate      = cpli;
                    fCandidateWhiteHit = fWhiteHit;
                }
            }

            //
            //  Otherwise, the line is found
            //

            else
            {
                goto FoundIt;
            }

        }

        if(pli->_fForceNewLine)
        {
            yli += pli->_yHeight;
        }

        cpli += pli->_cch;
        ili++;
    }

    //
    // if we are lookig for an exact line hit and
    // do not have a candidate line, it's a miss
    //
    if (iliCandidate < 0 && grfFlags & LFP_EXACTLINEHIT)
    {
        return -1;
    }

    Assert(ili <= LineCount());


    //
    // we better have a candidate, if yIntersect < yli + _yMostNeg
    //
    Assert( iliCandidate >= 0 || yIntersect >= yli + _yMostNeg || (grfFlags & LFP_IGNORERELATIVE));

    //
    //  No intersecting line was found, take either the candidate or last line
    //
    
    //
    //  ili == LineCount() - is TRUE only if the point we are looking for is
    //  below all the content or we found a candidate line but are performing
    //  a Z-Order search on a layout with lines with negative margin.
    //
    if (    ili == iliFinish

    //
    //  Here we don't really need to check if iliCandidate >= 0. It is added
    //  to make the code more robust to handle cases like a negative yIntersect
    //  passed in.
    //
        ||  (   yIntersect < yli + _yMostNeg
            &&  iliCandidate >= 0))
    {
        //
        //  If a candidate line was found, use it
        //

        if (iliCandidate >= 0)
        {
            // The following assert is invalid when we have line height(see bug 26107)
            //Assert(yliCandidate  >= 0);

            Assert(cpliCandidate >= 0);

            ili  = iliCandidate;
            yli  = yliCandidate;
            cpli = cpliCandidate;
        }

        //
        //  Otherwise use the last line
        //

        else
        {
            Assert(pli);
            Assert(ploi);
            Assert(ili > 0);
            Assert(LineCount());

            ili--;

            if (pli->_fForceNewLine)
            {
                yli -= pli->_yHeight;
            }

            cpli -= pli->_cch;
        }

        //
        //  Ensure that frame lines are not returned if they are to be ignored
        //

        if (grfFlags & LFP_IGNOREALIGNED)
        {
            pli = Elem(ili);
            
            if (pli->IsFrame())
            {
                while(pli->IsFrame() && ili)
                {
                    ili--;
                    pli = Elem(ili);
                }

                if(pli->_fForceNewLine)
                    yli -= pli->_yHeight;
                cpli -= pli->_cch;
            }
        }
    }

FoundIt:
    Assert(ili < LineCount());

    if(pyLine)
    {
        *pyLine = yli;
    }

    if(pcpLine)
    {
        *pcpLine = cpli;
    }

    return ili;
}

//==============================  Point <-> cp conversion  ==============================

LONG CDisplay::CpFromPointReally(
    POINT       pt,               // Point to compute cp at (client coords)
    CLinePtr  * const prp,         // Returns line pointer at cp (may be NULL)
    CMarkup **  ppMarkup,          // Markup which cp belongs to (in case of viewlinking)   
    DWORD       dwCFPFlags,       // flags to CpFromPoint
    BOOL      * pfRightOfCp,
    LONG      * pcchPreChars,
    BOOL      * pfHitGlyph)
{
    CMessage      msg;
    HTC           htc;
    CTreeNode   * pNodeElementTemp = NULL; // keep compiler happy
    DWORD         dwFlags = HT_SKIPSITES | HT_VIRTUALHITTEST | HT_IGNORESCROLL | HT_HTMLSCOPING;
    LONG          cpHit;
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CTreeNode   * pNode = pFlowLayout->GetFirstBranch();
    CRect         rcClient;

    Assert(pNode);

    CElement  * pContainer = pNode->GetContainer();

    if (   pContainer
        && pContainer->Tag() == ETAG_BODY
        && pContainer->GetMarkup()->IsStrictCSS1Document()
       )
    {
        CElement *pContainerOld = pContainer;
        pContainer = pContainer->GetFirstBranch()->Parent()->SafeElement();
        if (   !pContainer
            || pContainer->Tag() != ETAG_HTML
           )
        {
            pContainer = pContainerOld;
        }
    }

    if (pfHitGlyph)
        *pfHitGlyph = FALSE;

    pFlowLayout->GetContentRect(&rcClient, COORDSYS_GLOBAL);

    if (pt.x < rcClient.left)
        pt.x = rcClient.left;
    if (pt.x >= rcClient.right)
        pt.x = rcClient.right - 1;
    if (pt.y < rcClient.top)
        pt.y = rcClient.top;
    if (pt.y >= rcClient.bottom)
        pt.y = rcClient.bottom - 1;
    
    msg.pt = pt;

    if (dwCFPFlags & CFP_ALLOWEOL)
        dwFlags |= HT_ALLOWEOL;
    if (!(dwCFPFlags & CFP_IGNOREBEFOREAFTERSPACE))
        dwFlags |= HT_DONTIGNOREBEFOREAFTER;
    if (!(dwCFPFlags & CFP_EXACTFIT))
        dwFlags |= HT_NOEXACTFIT;

    //
    // Ideally I would have liked to perform the hit test on _pFlowLayout itself,
    // however when we have relatively positioned lines, then this will miss
    // some lines (bug48689). To avoid missing such lines we have to hittest
    // from the ped. However, doing that has other problems when we are
    // autoselecting. For example, if the point is on a table, the table finds
    // the closest table cell and passes that table cell the message to
    // extend a selection. However, this hittest hits the table and
    // msg._cpHit is not initialized (bug53706). So in this case, do the CpFromPoint
    // in the good ole' traditional manner.
    //

    // Note (yinxie): I changed GetPad()->HitTestPoint to GetContainer->HitTestPoint
    // for the flat world, container is the new notion to replace ped
    // this will ix the bug (IE5 17135), the bugs mentioned above are all checked
    // there is no regression.

    // HACKHACK (grzegorz) CElement::HitTestPoint can call EnsureView, at this point
    // there is possibility to change the tree or to navigate to a different location.
    // Hence pElementFL can be removed from the tree. In this case return an error.

    CElement * pElementFL = pFlowLayout->ElementOwner();
    pElementFL->AddRef();
    htc = (pContainer) 
            ? pContainer->HitTestPoint(&msg, &pNodeElementTemp, dwFlags)
            : HTC_NO;
    BOOL fRemovedFromTree = !pElementFL->GetFirstBranch();
    pElementFL->Release();
    if (fRemovedFromTree)
        return -1;

    // Take care of INPUT which contains its own private ped. If cpHit is inside the INPUT,
    // change it to be the cp of the INPUT in its contaning ped.
    //if (htc >= HTC_YES && pNodeElementTemp && pNodeElementTemp->Element()->IsMaster())
    //{
    //    msg.resultsHitTest.cpHit = pNodeElementTemp->Element()->GetFirstCp();
    //}
    if (    htc >= HTC_YES
        &&  pNodeElementTemp
        &&  (   pNodeElementTemp->IsContainer()
             && pNodeElementTemp->GetContainer() != pContainer
            )
       )
    {
        htc= HTC_NO;
    }

    if (htc >= HTC_YES && msg.resultsHitTest._cpHit >= 0)
    {
        cpHit = msg.resultsHitTest._cpHit;
        if (prp)
        {
            prp->RpSet(msg.resultsHitTest._iliHit, msg.resultsHitTest._ichHit);
        }
        if (pfRightOfCp)
            *pfRightOfCp = msg.resultsHitTest._fRightOfCp;
        if (pcchPreChars)
            *pcchPreChars = msg.resultsHitTest._cchPreChars;
        if (pfHitGlyph)
            *pfHitGlyph = msg.resultsHitTest._fGlyphHit;
        if(ppMarkup && pNodeElementTemp)
            *ppMarkup = pNodeElementTemp->GetMarkup();
    }
    else
    {
        CPoint ptLocal(pt);
        CTreePos *ptp = NULL;
        //
        // We now need to convert pt to client coordinates from global coordinates
        // before we can call CpFromPoint...
        //
        pFlowLayout->TransformPoint(&ptLocal, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
        cpHit = CpFromPoint(ptLocal, prp, &ptp, NULL, dwCFPFlags,
                            pfRightOfCp, NULL, pcchPreChars, NULL);
        if(ppMarkup && ptp)
            *ppMarkup = ptp->GetMarkup();
    }
    return cpHit;
}

LONG
CDisplay::CpFromPoint(
    POINT       pt,                     // Point to compute cp at (site coords)
    CLinePtr  * const prp,         // Returns line pointer at cp (may be NULL)
    CTreePos ** pptp,             // pointer to return TreePos corresponding to the cp
    CLayout  ** ppLayout,          // can be NULL
    DWORD       dwFlags,
    BOOL      * pfRightOfCp,
    BOOL      * pfPseudoHit,
    LONG      * pcchPreChars,
    CCalcInfo * pci)
{
    CCalcInfo   CI;
    CRect       rc;
    LONG        ili;
    LONG        cp;
    LONG        yLine;

    CFlowLayout *pFlowLayout = GetFlowLayout();

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    // Get line under hit
    pFlowLayout->GetClientRect(&rc);

    rc.MoveTo(pt);

    ili = LineFromPos(
        rc, &yLine, &cp, LFP_ZORDERSEARCH | LFP_IGNORERELATIVE |
                                        (!ppLayout
                                            ? LFP_IGNOREALIGNED
                                            : 0) |
                                        (dwFlags & CFP_NOPSEUDOHIT
                                            ? LFP_EXACTLINEHIT
                                            : 0));
    if(ili < 0)
        return -1;
        
                         
    return CpFromPointEx(ili, yLine, cp, pt, prp, pptp, ppLayout,
                         dwFlags, pfRightOfCp, pfPseudoHit,
                         pcchPreChars, NULL, NULL, pci);
                        
}

LONG
CDisplay::CpFromPointEx(
    LONG       ili,
    LONG       yLine,
    LONG       cp,
    POINT      pt,                      // Point to compute cp at (site coords)
    CLinePtr  *const prp,               // Returns line pointer at cp (may be NULL)
    CTreePos **pptp,                    // pointer to return TreePos corresponding to the cp
    CLayout  **ppLayout,                // can be NULL
    DWORD      dwFlags,
    BOOL      *pfRightOfCp,
    BOOL      *pfPseudoHit,
    LONG      *pcchPreChars,
    BOOL      *pfGlyphHit,
    BOOL      *pfBulletHit,
    CCalcInfo *pci)
{
    CFlowLayout *pFlowLayout = GetFlowLayout();
    CElement    *pElementFL  = pFlowLayout->ElementOwner();
    CCalcInfo    CI;
    CLineCore   *pli = Elem(ili);
    CLineFull    lif;
    LONG         cch = 0;
    LONG         dx = 0;
    BOOL         fPseudoHit = FALSE;
    CTreePos    *ptp = NULL;
    CTreeNode   *pNode;
    LONG         cchPreChars = 0;
    LONG         yProposed = 0;
    
    if (pfGlyphHit)
        *pfGlyphHit = FALSE;

    if (pfBulletHit)
        *pfBulletHit = FALSE;
    
    if (!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    if (   dwFlags & CFP_IGNOREBEFOREAFTERSPACE
        && (   pli == NULL
            || (   !pli->_fRelative
                && pli->_fSingleSite
               )
           )
       )
    {
        return -1 ;
    }

    if (pli)
    {
        lif = *pli;
        if (   lif.IsFrame()
            && !lif._fHasFloatedFL
           )
        {
            if(ppLayout)
            {
                *ppLayout = lif.AO_GetUpdatedLayout(&lif, LayoutContext());
            }
            cch = 0;

            if(pfRightOfCp)
                *pfRightOfCp = TRUE;

            fPseudoHit = TRUE;
        }
        else
        {
            if (    !(dwFlags & CFP_IGNOREBEFOREAFTERSPACE)
                &&  lif._fHasNestedRunOwner
                &&  yLine + lif._yHeight <= pt.y)
            {
                // If the we are not ignoring whitespaces and we have hit a line
                // which has a nested runowner, but are BELOW the line (happens when
                // that line is the last line in the document) then we want
                // to be at the end of that line. The measurer would put us at the
                // beginning or end depending upon the X position.
                cp += lif._cch;
            }
            else
            {
                // Create measurer
                CLSMeasurer me(this, pci);
                LONG yHeightRubyBase = 0;

                AssertSz((pli != NULL) || (ili == 0),
                         "CDisplay::CpFromPoint invalid line pointer");

                 if (!me._pLS)
                    return -1;

                // Get character in the line
                me.SetCp(cp, NULL);

                // The y-coordinate should be relative to the baseline, and positive going up
                cch = lif.CchFromXpos(me, pt.x, yLine + lif._yHeight - lif._yDescent - pt.y, &dx, 
                                       dwFlags & CFP_EXACTFIT, &yHeightRubyBase, pfGlyphHit, &yProposed);
                cchPreChars = me._cchPreChars;
                
                if (pfRightOfCp)
                    *pfRightOfCp = dx < 0;

                if (ppLayout)
                {
                    ptp = me.GetPtp();
                    if (ptp->IsBeginElementScope())
                    {
                        pNode = ptp->Branch();
                        if (   pNode->ShouldHaveLayout()
                            && pNode->IsInlinedElement()
                           )
                        {
                            AssertSz( (pNode->Element()->GetFirstCp() >= GetFirstCp()), "Found element outside display -- don't know context!" );
                            AssertSz( (pNode->Element()->GetLastCp() <= GetLastCp()), "Found element outside display -- don't know context!" );                            
                            *ppLayout = pNode->GetUpdatedLayout( LayoutContext() );
                        }
                        else
                        {
                            *ppLayout = NULL;
                        }
                    }
                }

                // Don't allow click at EOL to select EOL marker and take into account
                // single line edits as well

                if (!(dwFlags & CFP_ALLOWEOL) && cch && cch == lif._cch)
                {
                    long cpPtp;

                    ptp = me.GetPtp();
                    Assert(ptp);

                    cpPtp = ptp->GetCp();

                    //
                    // cch > 0 && we are not in the middle of a text run,
                    // skip past all the previous node/pointer tree pos's.
                    // and position the measurer just after text.
                    if(cp < cpPtp && cpPtp == me.GetCp())
                    {
                        while (cp < cpPtp)
                        {
                            CTreePos *ptpPrev = ptp->PreviousTreePos();

                            if (!ptpPrev->GetBranch()->IsDisplayNone())
                            {
                                if (ptpPrev->IsText())
                                    break;
                                if (ptpPrev->IsNode() && ptpPrev->ShowTreePos())
                                    break;
                                if (   ptpPrev->IsEndElementScope()
                                    && ptpPrev->Branch()->ShouldHaveLayout()
                                   )
                                    break;
                            }
                            ptp = ptpPrev;
                            Assert(ptp);
                            cch   -= ptp->GetCch();
                            cpPtp -= ptp->GetCch();
                        }

                        while(ptp->GetCch() == 0)
                            ptp = ptp->NextTreePos();
                    }
                    else if (pElementFL->GetFirstBranch()->GetParaFormat()->HasInclEOLWhite(TRUE))
                    {
                        CTxtPtr tpTemp(GetMarkup(), cp + cch);
                        if (tpTemp.GetPrevChar() == WCH_CR)
                        {
                            cch--;
                            if (cp + cch < cpPtp)
                                ptp = NULL;
                        }
                    }

                    me.SetCp(cp + cch, ptp);
                }

                // Check if the pt is within bounds *vertically* too.
                if (dwFlags & CFP_IGNOREBEFOREAFTERSPACE)
                {
                    LONG top, bottom;
                    
                    ptp = me.GetPtp();
                    if (   ptp->IsBeginElementScope()
                        && ptp->Branch()->ShouldHaveLayout()
                        && ptp->Branch()->IsInlinedElement()
                       )
                    {
                        AssertSz( (ptp->Branch()->Element()->GetFirstCp() >= GetFirstCp()), "Found element outside display -- don't know context!" );
                        AssertSz( (ptp->Branch()->Element()->GetLastCp() <= GetLastCp()), "Found element outside display -- don't know context!" );

                        // Hit a site. Check if we are within the boundaries
                        // of the site.
                        RECT rc;
                        CLayout *pLayout = ptp->Branch()->GetUpdatedLayout( LayoutContext() );
                        
                        pLayout->GetRect(&rc);

                        top = rc.top;
                        bottom = rc.bottom;
                    }
                    else
                    {
                        GetTopBottomForCharEx(pci,
                                              &top,
                                              &bottom,
                                              yLine,
                                              &lif,
                                              pt.x,
                                              yProposed,
                                              me.GetPtp(),
                                              pfBulletHit
                                             );
                        top -= yHeightRubyBase;
                        bottom -= yHeightRubyBase;
                    }

                    // NOTE (t-ramar): this is fine for finding 99% of the
                    // pseudo hits, but if someone has a ruby with wider base
                    // text than pronunciation text, or vice versa, hits in the
                    // whitespace that results will not register as pseudo hits.
                    if (    pt.y <  top
                        ||  pt.y >= bottom
                        ||  pt.x <  lif.GetTextLeft()
                        ||  pt.x >= lif.GetTextRight(ili == LineCount() - 1))
                    {
                        fPseudoHit = TRUE;
                    }
                }
                
                cp = (LONG)me.GetCp();

                ptp = me.GetPtp();
            }
        }
    }

    if(prp)
        prp->RpSet(ili, cch);

    if(pfPseudoHit)
        *pfPseudoHit = fPseudoHit;

    if(pcchPreChars)
        *pcchPreChars = cchPreChars;

    if(pptp)
    {
        LONG ich;

        *pptp = ptp ? ptp : pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &ich, TRUE);
    }

    return cp;
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::PointFromTp(tp, prcClient, fAtEnd, pt, prp, taMode,
//                                    pci, pfComplexLine, pfRTLFlow)
//
// Synopsis:    return the origin that corresponds to a given text pointer,
//              relative to the view
//
//-----------------------------------------------------------------------------
#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif

LONG CDisplay::PointFromTp(
    LONG        cp,         // point for the cp to be computed
    CTreePos *  ptp,        // tree pos for the cp passed in, can be NULL
    BOOL fAtEnd,            // Return end of previous line for ambiguous cp
    BOOL fAfterPrevCp,      // Return the trailing point of the previous cp (for an ambigous bidi cp)
    POINT &pt,              // Returns point at cp in client coords
    CLinePtr * const prp,   // Returns line pointer at tp (may be null)
    UINT taMode,            // Text Align mode: top, baseline, bottom
    CCalcInfo *pci,         // This can be NULL
    BOOL *pfComplexLine,    // This can be NULL
    BOOL *pfRTLFlow)        // This can be NULL // RTL note: this is only non NULL in ViewServices
{
    CFlowLayout * pFL = GetFlowLayout();
    CLinePtr    rp(this);
    BOOL        fLastTextLine;
    CCalcInfo   CI;
    BOOL        fRTLLine;
    BOOL        fAtEndOfRubyBase;
    RubyInfo rubyInfo = {-1, 0, 0};

    //
    // If cp points to a node position somewhere between ruby base and ruby text, 
    // then we have to remember for later use that we are at the end of ruby text
    // (fAtEndOfRubyBase is set to TRUE).
    // If cp points to a node at the and of ruby element, then we have to move
    // cp to the beginning of text which follows ruby or to the beginning of block
    // element, whichever is first.
    //
    fAtEndOfRubyBase = FALSE;

    CTreePos * ptpNode = ptp ? ptp : GetMarkup()->TreePosAtCp(cp, NULL, TRUE);
    LONG cpOffset = 0;
    while ( ptpNode && ptpNode->IsNode() )
    {
        ELEMENT_TAG eTag = ptpNode->Branch()->Element()->Tag();
        if ( eTag == ETAG_RT )
        {
            fAtEndOfRubyBase = ptpNode->IsBeginNode();
            break;
        }
        else if ( eTag == ETAG_RP )
        {
            if (ptpNode->IsBeginNode())
            {
                //
                // At this point we check where the RP tag is located: before or 
                // after RT tag. If this is before RT tag then we set fAtEndOfRubyBase
                // to TRUE, in the other case we do nothing.
                //
                // If RT tag is a parent of RP tag then we are after RT tag. 
                // In the other case we are before RT tag.
                //
                CTreeNode * pParent = ptpNode->Branch()->Parent();
                while ( pParent )
                {
                    if ( pParent->Tag() == ETAG_RUBY )
                    {
                        fAtEndOfRubyBase = TRUE;
                        break;
                    }
                    else if ( pParent->Tag() == ETAG_RT )
                    {
                        break;
                    }
                    pParent = pParent->Parent();
                }
            }
            break;
        }
        else if ( ptpNode->IsEndNode() && eTag == ETAG_RUBY )
        {
            for (;;)
            {
                cpOffset++;
                ptpNode = ptpNode->NextTreePos();
                if ( !ptpNode || !ptpNode->IsNode() || 
                    ptpNode->Branch()->Element()->IsBlockElement() )
                {
                    cp += cpOffset;
                    break;
                }
                cp = min(cp, GetLastCp()); // Keep it inside the range
            }
            break;
        }
        cpOffset++;
        ptpNode = ptpNode->NextNonPtrTreePos();
    }

    if(!pci)
    {
        CI.Init(pFL);
        pci = &CI;
    }

    if (pFL->IsDisplayNone() ||
        !WaitForRecalc(cp, -1, pci))
        return -1;

    if(!rp.RpSetCp(cp, fAtEnd))
        return -1;

    if (!WaitForRecalc(min(cp + rp->_cch, GetLastCp()), -1, pci))
        return -1;

    if(!rp.RpSetCp(cp, fAtEnd))
        return -1;

#if DBG==1
    CLineCore * pliDbg = rp.CurLine();
#endif

    // Determine line's RTL
    if (rp.IsValid())
        fRTLLine = rp->_fRTLLn;
    else if(ptp)
        fRTLLine = ptp->GetBranch()->GetParaFormat()->HasRTL(TRUE);
    else
    {
        // RTL note: this looks like defensive code. It is hard to tell if we ever get here, 
        //           partly because the result is only used by ViewServices. 
        //           If curious about why this code is here, uncommend this assert.
        // Assert(0); 
        fRTLLine = IsRTLDisplay();
    }

    if(pfRTLFlow)
        *pfRTLFlow = fRTLLine;

    pt.y = YposFromLine(pci, rp, NULL);
    pt.x = rp.IsValid()
        ? rp.oi()->_xLeft + rp.oi()->_xLeftMargin + (fRTLLine ? rp->_xWidth : 0)
                : 0;
                    
    fLastTextLine = rp.IsLastTextLine();

    {
        CLSMeasurer me(this, pci);
        if (!me._pLS)
            return -1;

        // Backup to start of line
        if(rp.GetIch())
            me.SetCp(cp - rp.RpGetIch(), NULL);
        else
            me.SetCp(cp, ptp);

        // And measure from there to where we are
        me.NewLine(*rp);

        Assert(rp.IsValid());

        me._li._xLeft = rp.oi()->_xLeft;
        me._li._xLeftMargin = rp.oi()->_xLeftMargin;
        me._li._xWidth = rp->_xWidth;
        me._li._xRight = rp->_xRight;
        me._li._xRightMargin = rp.oi()->_xRightMargin;
        me._li._fRTLLn = rp->_fRTLLn;

        // can we also add the _cch and _cchWhite here so we can pass them to 
        // the BidiLine stuff?
        me._li._cch = rp->_cch;
        me._li._cchWhite = rp.oi()->_cchWhite;

        LONG xCalc = me.MeasureText(rp.RpGetIch(), rp->_cch, fAfterPrevCp, pfComplexLine, pfRTLFlow, &rubyInfo);

        // Remember we ignore trailing spaces at the end of the line
        // in the width, therefore the x value that MeasureText finds can
        // be greater than the width in the line so we truncate to the
        // previously calculated width which will ignore the spaces.
        // pt.x += min(xCalc, rp->_xWidth);
        //
        // Why anyone would want to ignore the trailing spaces at the end
        // of the line is beyond me. For certain, we DON'T want to ignore
        // them when placing the caret at the end of a line with trailing
        // spaces. If you can figure out a reason to ignore the spaces,
        // please do, just leave the caret placement case intact. - Arye
        if (!fRTLLine)
            pt.x += xCalc;
        else
            pt.x -= xCalc;
    }

    if (prp)
        *prp = rp;

    if(rp >= 0 && taMode != TA_TOP)
    {
        // Check for vertical calculation request
        if (taMode & TA_BOTTOM)
        {
            const CLineCore *pli = Elem(rp);
            const CLineOtherInfo *ploi = pli->oi();
            
            if(pli && ploi)
            {
                pt.y += pli->_yHeight;
                if ( rubyInfo.cp != -1 && !fAtEndOfRubyBase )
                {
                    pt.y -= rubyInfo.yHeightRubyBase + ploi->_yDescent - ploi->_yTxtDescent;
                }
                
                if (!pli->IsFrame() &&
                    (taMode & TA_BASELINE) == TA_BASELINE)
                {
                    if ( rubyInfo.cp != -1 && !fAtEndOfRubyBase )
                    {
                        pt.y -= rubyInfo.yDescentRubyText;
                    }
                    else
                    {
                        pt.y -= ploi->_yDescent;
                    }
                }
            }
        }

        // Do any specical horizontal calculation
        if (taMode & TA_CENTER)
        {
            CLSMeasurer me(this, pci);

            if (!me._pLS)
                return -1;

            me.SetCp(cp, ptp);

            me.NewLine(*rp);

            pt.x += (me.MeasureText(1, rp->_cch) >> 1);
        }
    }

    return rp;
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//+----------------------------------------------------------------------------
//
// Function:    AppendRectToElemRegion
//
// Synopsis:    Utility function for region from element, which appends the
//              given rect to region if it is within the clip range and
//              updates the bounding rect.
//
//-----------------------------------------------------------------------------
void  AppendRectToElemRegion(CDataAry <RECT> * paryRects, RECT * prcBound,
                             RECT * prcLine, CPoint & ptTrans,
                             LONG cp, LONG cpClipStart, LONG cpClipFinish
                             )
{
    if(ptTrans.x || ptTrans.y)
        OffsetRect(prcLine, ptTrans.x, ptTrans.y);

    if(cp >= cpClipStart && cp <= cpClipFinish)
    {
        paryRects->AppendIndirect(prcLine);
    }

    if(prcBound)
    {
        if(!IsRectEmpty(prcLine))
        {
            UnionRect(prcBound, prcBound, prcLine);
        }
        else if (paryRects->Size() == 1)
        {
            *prcBound = *prcLine;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:    RcFromAlignedLine
//
// Synopsis:    Utility function for region from element, which computes the
//              rect for a given aligned line
//
//-----------------------------------------------------------------------------
void
RcFromAlignedLine(RECT * prcLine, CLineCore * pli, CLineOtherInfo *ploi, LONG yPos,
                  BOOL fBlockElement, BOOL fFirstLine, BOOL fRTLDisplay,
                  long xParentLeftIndent, long xParentRightIndent)
{
    CSize size;

    long xProposed = pli->AO_GetXProposed(ploi);
    long yProposed = pli->AO_GetYProposed(ploi);

    pli->AO_GetSize(ploi, &size);

    // add the curent line to the region
    prcLine->top = yProposed + yPos + ploi->_yBeforeSpace;

    if(!fRTLDisplay)
    {
        prcLine->left = xProposed + ploi->_xLeftMargin + ploi->_xLeft;
        prcLine->right = prcLine->left + size.cx;
    }
    else
    {
        prcLine->right = ploi->_xLeftMargin + pli->_xLineWidth + ploi->_xNegativeShiftRTL - pli->_xRight - xProposed;
        prcLine->left = prcLine->right - size.cx;
    }

    prcLine->bottom = prcLine->top + size.cy;
}

//+----------------------------------------------------------------------------
//
// Function:    ComputeIndentsFromParentNode
//
// Synopsis:    Compute the indent for a given Node and a left and/or
//              right aligned site that a current line is aligned to.
//
//-----------------------------------------------------------------------------

void 
CDisplay::ComputeIndentsFromParentNode(CCalcInfo * pci,         // (IN)
                                       CTreeNode * pNode,       // (IN) node we want to compute indents for
                                       DWORD  dwFlags,          // (IN) flags from RFE
                                       LONG * pxLeftIndent,     // (OUT) the node is indented this many pixels from left edge of the layout
                                       LONG * pxRightIndent)    // (OUT) ...
{
    CElement  * pElement = pNode->Element();
    CElement  * pElementFL = GetFlowLayoutElement();
    LONG        xParentLeftPadding = 0, xParentRightPadding = 0;
    LONG        xParentLeftBorder = 0, xParentRightBorder = 0;

    const CParaFormat *pPF = pNode->GetParaFormat();
    BOOL  fInner = pNode->Element() == pElementFL;

    Assert(pNode);

    LONG xParentWidth = pci->_sizeParent.cx;
    if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
        || pPF->_cuvRightIndentPercent.GetUnitValue()
       )
    {
        xParentWidth = pNode->GetParentWidth(pci, xParentWidth);
    }
    
    // GetLeft/RightIndent returns the cumulative CSS margin (+ some other gunk
    // like list bullet offsets).
    
    LONG xLeftMargin  = pPF->GetLeftIndent(pci, fInner, xParentWidth);
    LONG xRightMargin = pPF->GetRightIndent(pci, fInner, xParentWidth);

    // We only want to include the area for the bullet for hit-testing;
    // we _don't_ draw backgrounds and borders around the bullet for list items.
    if (    dwFlags == RFE_HITTEST
        &&  pPF->_bListPosition != styleListStylePositionInside
        &&  (   IsGenericBlockListItem(pNode)
            ||  pElement->IsFlagAndBlock(TAGDESC_LIST)))

    {
        if (!pPF->HasRTL(fInner))
        {
            xLeftMargin -= pPF->GetBulletOffset(pci);
        }
        else
        {
            xRightMargin -= pPF->GetBulletOffset(pci);
        }
    }

    // Compute the padding and border space cause by the current
    // element's ancestors (up to the layout).
    if ( pNode->Element() == pElementFL )
    {
        // If the element in question is actually the layout owner,
        //b then we don't want to offset by our own border/padding,
        // so set the values to 0.
        Assert(xParentLeftPadding + xParentLeftBorder +
               xParentRightPadding + xParentRightBorder == 0);
    }
    else
    {
        // We need to get the cumulative sum of our ancestor's borders/padding.
        if (pNode->Parent())
            pNode->Parent()->Element()->ComputeHorzBorderAndPadding( pci, 
                                pNode->Parent(),     pElementFL,
                                &xParentLeftBorder,  &xParentLeftPadding,
                                &xParentRightBorder, &xParentRightPadding );
                                
        // The return results of ComputeHorzBorderAndPadding() DO NOT include
        // the border or padding of the layout itself; this makes sense for
        // borders, because the layout's border is outside the bounds we're
        // interested in.  However, we do want to account for the layout's
        // padding since that's inside the bounds.  We fetch that separately
        // here, and add it to the cumulative padding.

        long lPadding[SIDE_MAX];
        GetPadding( pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH );
        
        xParentLeftPadding += lPadding[SIDE_LEFT];
        xParentRightPadding += lPadding[SIDE_RIGHT];
    }

    // The element is indented by the sum of CSS margins and ancestor
    // padding/border.  This indent value specifically ignores aligned/floated
    // elements, per CSS!
    *pxLeftIndent = xLeftMargin + xParentLeftBorder + xParentLeftPadding;
    *pxRightIndent = xRightMargin + xParentRightBorder + xParentRightPadding;
}

//+----------------------------------------------------------------------------
//
// Member:      RegionFromElement
//
// Synopsis:    for a given element, find the set of rects (or lines) that this
//              element occupies in the display. The rects returned are relative
//              the site origin.
//              Certain details about the returned region are determined by the
//              call type parameter:..
//
//-----------------------------------------------------------------------------

void
CDisplay::RegionFromElement(CElement       * pElement,  // (IN)
                            CDataAry<RECT> * paryRects, // (OUT)
                            CPoint         * pptOffset, // == NULL, point to offset the rects by (IN param)
                            CFormDrawInfo  * pDI,       // == NULL
                            DWORD dwFlags,              // == 0
                            LONG cpClipStart,           // == -1, (IN)
                            LONG cpClipFinish,          // == -1, (IN) clip range
                            RECT * prcBound             // == NULL, (OUT param) returns bounding rect that ignores clipping
                            )
{
    RegionFromElementCore(pElement,     paryRects,
                          pptOffset,    pDI,
                          dwFlags,      cpClipStart,
                          cpClipFinish, prcBound);
    
    if (dwFlags & RFE_SCREENCOORD)
    {
        CFlowLayout *       pFL = GetFlowLayout();
        // Transform the relative offset to global coords if caller specified
        // RFE_SCREENCOORD.        
        for (LONG i = 0; i < paryRects->Size(); i++)
        {
            pFL->TransformRect(&paryRects->Item(i), COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
        }
        if (prcBound)
            pFL->TransformRect(prcBound,  COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    }
}

void
CDisplay::RegionFromElementCore(CElement       * pElement,  // (IN)
                           CDataAry<RECT> * paryRects, // (OUT)
                           CPoint         * pptOffset, // == NULL, point to offset the rects by (IN param)
                           CFormDrawInfo  * pDI,       // == NULL
                           DWORD dwFlags,              // == 0
                           LONG cpClipStart,           // == -1, (IN)
                           LONG cpClipFinish,          // == -1, (IN) clip range
                           RECT * prcBound             // == NULL, (OUT param) returns bounding rect that ignores clipping
                          )
{
    CFlowLayout *       pFL = GetFlowLayout();
    CElement *          pElementFL = pFL->ElementOwner();
    CTreePos *          ptpStart;
    CTreePos *          ptpFinish;
    CCalcInfo           CI;
    RECT                rcLine;
    CRect               rcClipWork = g_Zero.rc;        // RECT used for doing various fClipVisible work
    CPoint              ptTrans = g_Zero.pt;
    LONG                cchAdvance = 0;

    Assert( pElement->IsInMarkup() );

    // clear the array before filling it
    paryRects->SetSize(0);
    if(prcBound)
        memset(prcBound, 0, sizeof(RECT));

    if(pElementFL->IsDisplayNone() || !pElement || pElement->IsDisplayNone() ||
       (pElement->Tag() == ETAG_ROOT && !pElement->HasMasterPtr()) || 
       (pElementFL->Tag() == ETAG_ROOT && !pElementFL->HasMasterPtr()) )
        return;

    if (pElement == pElementFL)
    {
        pFL->GetContentTreeExtent(&ptpStart, &ptpFinish);
    }
    else
    {
        pElement->GetTreeExtent(&ptpStart, &ptpFinish);
    }
    Assert(ptpStart && ptpFinish);

    // now that we have the scope of the element, find its range.
    // and compute the rects (lines) that contain the range.
    {
        CTreePos          * ptpElemStart;
        CTreePos          * ptpElemFinish;
        CTreeNode         * pNode = pElement->GetFirstBranch();
        CLSMeasurer         me(this, pDI);
        CMarkup           * pMarkup = pFL->GetContentMarkup();
        BOOL                fBlockElement;
        BOOL                fTightRects = (dwFlags & RFE_TIGHT_RECTS);
        BOOL                fIgnoreBlockness = (dwFlags & RFE_IGNORE_BLOCKNESS);
        BOOL                fIncludeAlignedElements = !(dwFlags & RFE_IGNORE_ALIGNED);
        BOOL                fIgnoreClipForBoundRect = (dwFlags & RFE_IGNORE_CLIP_RC_BOUNDS);
        BOOL                fIgnoreRel = (dwFlags & RFE_IGNORE_RELATIVE);
        BOOL                fNestedRel = (dwFlags & RFE_NESTED_REL_RECTS);
        BOOL                fScrollIntoView = (dwFlags & RFE_SCROLL_INTO_VIEW);
        BOOL                fClipToVisible = (dwFlags & RFE_CLIP_TO_VISIBLE); // perf optimization; if true, don't compute region for lines that aren't visible
        BOOL                fOnlyBackground = (dwFlags & RFE_ONLY_BACKGROUND);
        BOOL                fNoExtent = (dwFlags & RFE_NO_EXTENT) ? TRUE : FALSE;
        BOOL                fNeedToMeasureLine;
        LONG                cp, cpStart, cpFinish, cpElementLast;
        LONG                cpElementStart, cpElementFinish;
        LONG                iCurLine, iFirstLine, ich;
        LONG                yPos;
        LONG                xParentRightIndent = 0;
        LONG                xParentLeftIndent = 0;
        LONG                yTop;
        BOOL                fFirstLine;
        CLinePtr            rp(this);
        BOOL                fRestorePtTrans = FALSE;
        CStackDataAry<CChunk, 8> aryChunks(Mt(CDisplayRegionFromElement_aryChunks_pv));

        if (!me._pLS)
            goto Cleanup;
    
        // Do we treat the element we're finding the region for
        // as a block element?  Things that influence this decision:
        // If RFE_SELECTION was specified, it means we're doing
        // finding a region for selection, which is always character
        // based (never block based).  RFE_SELECTION causes fIgnoreBlockness to light up.
        // The only time RFE should get called on an element that
        // needs layout is when the pElement == pElementFL.  When
        // this happens, even though the element _is_ block, we
        // want to treat it as though it isn't, since the caller
        // in this situation wants the rects of some text that's
        // directly under the layout (e.g. "x" in <BODY>x<DIV>...</DIV></BODY>)
        // NOTE: (KTam) this would be a lot more obvious if we changed
        // the !pElement->ShouldHaveLayout() condition to pElement != pElementFL
        fBlockElement =  !fIgnoreBlockness &&
                          pElement->IsBlockElement() &&
                         !pElement->ShouldHaveLayout();          
    
        if (pDI)
        {
            CI.Init(pDI, pFL);
        }
        else
        {
            CI.Init(pFL);
        }
    
        long            xParentWidth;
        long            yParentHeight;
        // Fetch parent's width and height (i.e. view width & height minus padding)
        GetViewWidthAndHeightForChild(&CI, &xParentWidth, &yParentHeight);
        CI.SizeToParent(xParentWidth, yParentHeight);
    
        // If caller hasn't specified non-relative behaviour, then account for
        // relativeness on the layout by fetching the relative offset in ptTrans.
        if(!fIgnoreRel)
            pNode->GetRelTopLeft(pElementFL, &CI, &ptTrans.x, &ptTrans.y);
    
        // Combine caller-specified offset (if any) into relative offset.
        if(pptOffset)
        {
            ptTrans.x += pptOffset->x;
            ptTrans.y += pptOffset->y;
        }

        cpStart  = pFL->GetContentFirstCpForBrokenLayout();
        cpFinish = pFL->GetContentLastCpForBrokenLayout();
    
        // get the cp range for the element
        cpElementStart  = ptpStart->GetCp();
        cpElementFinish = ptpFinish->GetCp();
    
        // Establish correct cp's and treepos's, including clipping stuff..
        // We may have elements overlapping multiple layout's, so clip the cp range
        // to the current flow layout's bounds,
        cpStart       = max(cpStart, cpElementStart);
        cpFinish      = min(cpFinish, cpElementFinish);
        cpElementLast = cpFinish;
    
        // clip cpFinish to max calced cp
        cpFinish      = min(cpFinish, GetMaxCpCalced());
    
        if( cpStart != cpElementStart )
            ptpStart  = pMarkup->TreePosAtCp(cpStart, &ich);
        ptpElemStart = ptpStart;
    
        if( cpFinish != cpElementFinish )
            ptpFinish = pMarkup->TreePosAtCp(cpFinish, &ich);
        ptpElemFinish = ptpFinish;

        // This is a perf optimization for drawing backgrounds of large elements:
        // if only part of the element is visible, there's no point computing the region
        // of the element that isn't visible, since we're not going to draw there.
        if ( fClipToVisible )
        {
            // If we have been asked to clip to the visible region, start from the first visible cp...
            LONG cpFirstVisible;

            pFL->_pDispNode->GetClippedBounds( &rcClipWork, COORDSYS_FLOWCONTENT );

            if (LineFromPos( rcClipWork, NULL, &cpFirstVisible, 0) < 0 )
                goto Cleanup;

            cpStart = max(cpStart, cpFirstVisible);

            // The client rect of the display's layout determines the
            // visible area we clip to.  From now on, each time we finish
            // processing a line, we see whether we've gone past the bottom
            // of the visible area.
            pFL->GetClientRect( &rcClipWork );   // store client rect in rcClipWork so we can check in later before appending rects

            TraceTagEx((tagRFEClipToVis, TAG_NONAME,
                        "RFE Clip To Visible: FL(0x%x,e=0x%x,%S, dn=0x%x) E(0x%x,%S), cpStart=%d, ClipRect(%d,%d,%d,%d), ptTrans(%d,%d) ptOffset(%d,%d)",
                        pFL,
                        pFL->ElementOwner(),
                        pFL->ElementOwner()->TagName(),
                        pFL->_pDispNode,
                        pElement,
                        pElement->TagName(),
                        cpStart,
                        rcClipWork.top, rcClipWork.left, rcClipWork.bottom, rcClipWork.right,
                        ptTrans.x, ptTrans.y,
                        pptOffset->x, pptOffset->y));
        }
    
        if(cpClipStart < cpStart)
            cpClipStart = cpStart;
        if(cpClipFinish == -1 || cpClipFinish > cpFinish)
            cpClipFinish = cpFinish;

        // VS7 has a scenario where this happens (bug #101633)
        if(cpClipStart > cpClipFinish)
            cpClipStart = cpClipFinish;

        if ( !fIgnoreClipForBoundRect )
        {
            if(cpStart != cpClipStart)
            {
                cpStart  = cpClipStart;
                ptpStart = pMarkup->TreePosAtCp(cpStart, &ich);
            }
            if(cpFinish != cpClipFinish)
            {
                cpFinish = cpClipFinish;
                ptpFinish = pMarkup->TreePosAtCp(cpFinish, &ich);
            }
        }
    
        if(!LineCount())
            return;
    
        // NOTE: we pass in absolute cp here so RpSetCp must call
        // pElementFL->GetFirstCp while we have just done this.  We
        // should optimize this out by having a relative version of RpSetCp.
    
        // skip frames and position it at the beginning of the line
        rp.RpSetCp(cpStart, /* fAtEnd = */ FALSE, TRUE, /* fSupportBrokenLayout= */ TRUE);
        
        // (cpStart - rp.GetIch) == cp of beginning of line (pointed to by rp)
 