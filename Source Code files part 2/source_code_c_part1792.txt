);
    if( !hDisplayDC )
        return FALSE;

    /* Go load strings */
    if (!InitStrings (hInstance))
        return FALSE;

    InitLocale();     // localize strings etc.

    /* Load the arrow and hourglass cursors. */
    hStdCursor= LoadCursor( NULL,
           (LPTSTR) (INT_PTR) (GetSystemMetrics(SM_PENWINDOWS) ? IDC_ARROW : IDC_IBEAM ));
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    /* Load accelerators. */
    hAccel= LoadAccelerators(hInstance, TEXT("MainAcc"));
    if( !hWaitCursor || !hAccel )
        return FALSE;

    if( !hPrevInstance )
    {
       if( !NPRegister( hInstance ) )
          return (FALSE);
    }

    hInstanceNP= hInstance;

    /* init. fields of PRINTDLG struct.. */
    /* Inserted here since command line print statements are valid. */
    g_PageSetupDlg.lStructSize   = sizeof(PAGESETUPDLG);
    g_PageSetupDlg.hDevMode      = NULL;
    g_PageSetupDlg.hDevNames     = NULL;
    g_PageSetupDlg.hInstance     = hInstance;
    SetPageSetupDefaults();

    //
    // Pick up information saved in registry
    //

    GetGlobals();


    hwndNP= CreateWindow(  szNotepad, 
                           TEXT(""),
                           WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                           WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | 0,
                           g_WPleft,     // x
                           g_WPtop,      // y
                           g_WPDX,       // width
                           g_WPDY,       // height
                           (HWND)NULL,   // parent or owner
                           (HMENU)NULL,  // menu or child window
                           hInstance,    // application instance
                           NULL);        // window creation data

    g_PageSetupDlg.hwndOwner     = hwndNP;

    if( !hwndNP )
        return FALSE;
   
    // On multimon machines, the previous position stored of notepad may
    // not be in the display area. call SetWindowPlacement to fix this.

    // If the information specified in WINDOWPLACEMENT would result in a window 
    // that is completely off the screen, the system will automatically adjust 
    // the coordinates so that the window is visible, taking into account 
    // changes in screen resolution and multiple monitor configuration. 

    // g_WPDX and g_WPDY are CW_USEDEFAULT when notepad is started for the
    // first time on the user machine.
    if (g_WPDX != CW_USEDEFAULT && g_WPDY != CW_USEDEFAULT)
    {
        memset(&wp, 0, sizeof(wp));
        wp.length = sizeof(wp);        
        wp.rcNormalPosition.left = g_WPleft;
        wp.rcNormalPosition.right = g_WPleft + g_WPDX;
        wp.rcNormalPosition.top = g_WPtop;
        wp.rcNormalPosition.bottom = g_WPtop + g_WPDY;

        // don't check the return value; if this call fails for any reason,
        // just go on with the position of the notepad in the above CreateWindow() call.
        SetWindowPlacement(hwndNP, &wp);
    }

    /* File Drag Drop support added 03/26/91 - prototype only. w-dougw   */
    /* All processing of drag/drop files is done the under WM_DROPFILES  */
    /* message.                                                          */
    DragAcceptFiles( hwndNP,TRUE ); /* Process dragged and dropped files. */

    GetClientRect( hwndNP, (LPRECT) &rcT1 );

    if (!(hwndEdit = CreateWindowEx(WS_EX_CLIENTEDGE,
                     TEXT("Edit"), TEXT(""),
                     (fWrap) ? ES_STD : (ES_STD | WS_HSCROLL),
                     0, 0, rcT1.right, rcT1.bottom - 100,
                     hwndNP, (HMENU)ID_EDIT, hInstance, (LPVOID)NULL)))
        return FALSE;


    // create a status window.
    hwndStatus = CreateStatusWindow ((fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS, TEXT(""), hwndNP, ID_STATUS_WINDOW);
    if ( !hwndStatus )
        return FALSE;
    UpdateStatusBar( TRUE );

    GetClientRect( hwndStatus, (LPRECT) &rcStatus );

    // determine height of statusbar window and save...
    dyStatus = rcStatus.bottom - rcStatus.top;

    iParts[0] = 3 * (rcStatus.right-rcStatus.left)/4;
    iParts[1] = -1;

    // Divide the status window into two parts
    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 
 

    // handle word wrap now if set in registry

    SendMessage( hwndEdit, EM_FMTLINES, fWrap, 0L );  // tell MLE

	// if wordwrap, disable the statusbar
    if (fWrap)
    {
        hMenu = GetMenu(hwndNP);
        EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_GRAYED);
    }

    FontStruct.lfHeight= -MulDiv(iPointSize,
                                 GetDeviceCaps(hDisplayDC,LOGPIXELSY),
                                 720);
    hFont= CreateFontIndirect( &FontStruct );

    //
    // Make sure the font mapper gives us the same face name.
    //
    // If the locale changes, a font that use to work just fine gets mapped to
    // a different facename because of support for the charset does not exist
    // in the new locale.
    //
    // In this case, we will find one lfCharSet that does exist for this FaceName
    // and use that for the CreateFontIndirect.
    //

    {
        HFONT hPrev;
        TCHAR szTextFace[LF_FACESIZE];

        // Get the facename that was really used.

        hPrev= SelectObject( hDisplayDC, hFont );
        GetTextFace( hDisplayDC, sizeof(szTextFace)/sizeof(TCHAR), (LPTSTR) &szTextFace );
        SelectObject( hDisplayDC, hPrev );

        // if not the same, get a lfCharSet that does exist in this font

        if( lstrcmpi( szTextFace, FontStruct.lfFaceName ) != 0 )
        {
            EnumFonts( hDisplayDC, FontStruct.lfFaceName, (FONTENUMPROC) EnumProc, (LPARAM) &FontStruct );
            DeleteObject( hFont );   

            hFont= CreateFontIndirect( &FontStruct );
        }
    }

    SendMessage (hwndEdit, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
    ReleaseDC( NULL, hDisplayDC );

    /* we will not verify that a unicode font is available until
    ** we actually need it.  Perhaps we'll get lucky, and only deal
    ** with ascii files.
    */

    szSearch[0] = (TCHAR) 0;
    /*
     * Win32s does not allow local memory handles to be passed to Win3.1.
     * So, hEdit is used for transferring text to and from the edit control.
     * Before reading text into it, it must be reallocated to a proper size.
     */
    hEdit = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, ByteCountOf(1));

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    /* get visible window on desktop; helps taskman  find it */
    SetTitle( szUntitled );
    ShowWindow( hwndNP, cmdShow );
    SetCursor( hStdCursor );

    /* Scan for initial /A or /W to override automatic file typing for
     * 'notepad /p file' or 'notepad file'
     */
    lpCmdLine= SkipBlanks( lpCmdLine );
    fInitFileType= FT_UNKNOWN;
    if( !lstrncmpi( TEXT("/A"), lpCmdLine ) )
        fInitFileType= FT_ANSI;
    else if( !lstrncmpi( TEXT("/W"), lpCmdLine ) )
        fInitFileType= FT_UNICODE;

    if( fInitFileType != FT_UNKNOWN )    // skip over option
        lpCmdLine= SkipBlanks( lpCmdLine+2 );

    /* check for /.SETUP option first.
       if /.SETUP absent, check for SHELL options /P
       Whenever a SHELL option is processed, post a WM_CLOSE msg.
       */
    if( iSta= ProcessSetupOption( lpCmdLine ) )
    {
        if( iSta == IDCANCEL )
        {
            return( FALSE );
        }
    }
    else if( ProcessShellOptions( lpCmdLine, cmdShow ) )
    {
        PostMessage( hwndNP, WM_CLOSE, 0, 0L );
        return TRUE;
    }
    else if( *lpCmdLine )
    {
        /* Get the filename. */
        GetFileName( szFileName, lpCmdLine );
        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // hnd of file attrs to copy

        if( fp == INVALID_HANDLE_VALUE )
        {
           // If the file can't be opened, maybe the user wants a new
           // one created.

           if( GetLastError() == ERROR_FILE_NOT_FOUND )
           {
              INT iSta;

              iSta= AlertBox( hwndNP, szNN, szFNF, szFileName,
                     MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
              if( iSta == IDCANCEL )
              {
                  return( FALSE );
              }

              if( iSta == IDYES )
              {
                 fp= CreateFile( szFileName,            // filename
                                 GENERIC_READ|GENERIC_WRITE,  // access
                                 FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                 NULL,                  // security descrp
                                 OPEN_ALWAYS,           // how to create
                                 FILE_ATTRIBUTE_NORMAL, // file attributes
                                 NULL);                 // hnd of file attrs
              }

           }
           else
           {
               AlertUser_FileFail(szFileName);
               // now open an untitled file instead of the file that we failed
               // to read.
               SetTitle( szUntitled );
               lstrcpy(szFileName, szUntitled);
           }
        }

        if( fp != INVALID_HANDLE_VALUE )
        {
           LoadFile( szFileName, fInitFileType );   // get file specified on command line
        }
    }

    CreateFilter( szOpenFilterSpec );
    CreateFilter( szSaveFilterSpec );

    /* init. some fields of the OPENFILENAME struct used by fileopen and
     * filesaveas, but NEVER changed.
     */
    memset( &OFN, 0, sizeof(OFN) );
    OFN.lStructSize       = sizeof(OPENFILENAME);
    OFN.hwndOwner         = hwndNP;
    OFN.nMaxFile          = MAX_PATH;
    OFN.hInstance         = hInstance;

    /* init.fields of the FINDREPLACE struct used by FindText() */
    memset( &FR, 0, sizeof(FR) );
    FR.lStructSize        = sizeof(FINDREPLACE);       /* Don't hard code it */
    FR.hwndOwner          = hwndNP;


    /* Force a scroll to current selection (which could be at eof if
       we loaded a log file.) */
    {
       DWORD  dwStart, dwEnd;

       SendMessage( hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd );
       SendMessage( hwndEdit, EM_SETSEL, dwStart, dwEnd );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }



    if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
        /*
         * If current HKL is Japanese, handle the result string at once.
         */
        SendMessage(hwndEdit, EM_SETIMESTATUS,
                                EMSIS_COMPOSITIONSTRING, EIMES_GETCOMPSTRATONCE);
    }

     return TRUE;
}

/* ** Notepad class registration proc */
BOOL NPRegister (HANDLE hInstance)
{
    WNDCLASSEX   NPClass;
    PWNDCLASSEX  pNPClass = &NPClass;

/* Bug 12191: If Pen Windows is running, make the background cursor an
 * arrow instead of the edit control ibeam.  This way the user will know
 * where they can use the pen for writing vs. what will be considered a
 * mouse action.   18 October 1991       Clark Cyr
 */
    pNPClass->cbSize        = sizeof(NPClass);
    pNPClass->hCursor       = LoadCursor(NULL, GetSystemMetrics(SM_PENWINDOWS)
                                               ? IDC_ARROW : IDC_IBEAM);
    pNPClass->hIcon         = LoadIcon(hInstance,
                                      (LPTSTR) MAKEINTRESOURCE(ID_ICON));

    pNPClass->hIconSm       = LoadImage(hInstance,
                                        MAKEINTRESOURCE(ID_ICON),
                                        IMAGE_ICON, 16, 16,
                                        LR_DEFAULTCOLOR);
    pNPClass->lpszMenuName  = (LPTSTR) MAKEINTRESOURCE(ID_MENUBAR);
    pNPClass->hInstance     = hInstance;
    pNPClass->lpszClassName = szNotepad;
    pNPClass->lpfnWndProc   = NPWndProc;
    pNPClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    pNPClass->style         = 0; // was CS_BYTEALIGNCLIENT (obsolete)
    pNPClass->cbClsExtra    = 0;
    pNPClass->cbWndExtra    = 0;

    if (!RegisterClassEx((LPWNDCLASSEX)pNPClass))
        return (FALSE);

    return (TRUE);
}


/* Get Locale info from the Registry, and initialize global vars  */

void FAR InitLocale (void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\precomp.h ===
#define WIN31
#include "notepad.h"
#include <shellapi.h>
#include <cderr.h>
#include <winnlsp.h>   // for NORM_STOP_ON_NULL

#include <string.h>

//
// We need to define BYTE_ORDER_MARK, and figure
// out how to get the system to tell us a font is a 
// unicode font, and then we can eliminate uconvert.h
//
#include "uconvert.h"
#include "uniconv.h"
#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>
#include <time.h>
#include <winspool.h>
#include "dlgs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\npprint.c ===
/*
 * npprint.c -- Code for printing from notepad.
 * Copyright (C) 1984-1995 Microsoft Inc.
 */

#define NOMINMAX
#include "precomp.h"

//#define DBGPRINT

/* indices into chBuff */
#define LEFT   0
#define CENTER 1
#define RIGHT  2

INT     tabSize;                    /* Size of a tab for print device in device units*/
HWND    hAbortDlgWnd;
INT     fAbort;                     /* true if abort in progress      */
INT     yPrintChar;                 /* height of a character          */


RECT rtMargin;

/* left,center and right string for header or trailer */
#define MAXTITLE MAX_PATH
TCHAR chBuff[RIGHT+1][MAXTITLE];

/* date and time stuff for headers */
#define MAXDATE MAX_PATH
#define MAXTIME MAX_PATH
TCHAR szFormattedDate[MAXDATE]=TEXT("Y");   // formatted date (may be internationalized)
TCHAR szFormattedTime[MAXTIME]=TEXT("Y");   // formatted time (may be internaltionalized)
SYSTEMTIME PrintTime;                       // time we started printing


INT xPrintRes;          // printer resolution in x direction
INT yPrintRes;          // printer resolution in y direction
INT yPixInch;           // pixels/inch
INT xPhysRes;           // physical resolution x of paper
INT yPhysRes;           // physical resolution y of paper

INT xPhysOff;           // physical offset x
INT yPhysOff;           // physical offset y

INT dyTop;              // width of top border (pixels)
INT dyBottom;           // width of bottom border
INT dxLeft;             // width of left border
INT dxRight;            // width of right border

INT iPageNum;           // global page number currently being printed

/* define a type for NUM and the base */
typedef long NUM;
#define BASE 100L

/* converting in/out of fixed point */
#define  NumToShort(x,s)   (LOWORD(((x) + (s)) / BASE))
#define  NumRemToShort(x)  (LOWORD((x) % BASE))

/* rounding options for NumToShort */
#define  NUMFLOOR      0
#define  NUMROUND      (BASE/2)
#define  NUMCEILING    (BASE-1)

#define  ROUND(x)  NumToShort(x,NUMROUND)
#define  FLOOR(x)  NumToShort(x,NUMFLOOR)

/* Unit conversion */
#define  InchesToCM(x)  (((x) * 254L + 50) / 100)
#define  CMToInches(x)  (((x) * 100L + 127) / 254)

void     DestroyAbortWnd(void) ;
VOID     TranslateString(TCHAR *);

BOOL CALLBACK AbortProc(HDC hPrintDC, INT reserved)
{
    MSG msg;

    while( !fAbort && PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE) )
    {
       if( !hAbortDlgWnd || !IsDialogMessage( hAbortDlgWnd, (LPMSG)&msg ) )
       {
          TranslateMessage( (LPMSG)&msg );
          DispatchMessage( (LPMSG)&msg );
       }
    }
    return( !fAbort );

    UNREFERENCED_PARAMETER(hPrintDC);
    UNREFERENCED_PARAMETER(reserved);
}


INT_PTR CALLBACK AbortDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HMENU hSysMenu;

    switch( msg )
    {
       case WM_COMMAND:
          fAbort= TRUE;
          DestroyAbortWnd();
          return( TRUE );

       case WM_INITDIALOG:
          hSysMenu= GetSystemMenu( hwnd, FALSE );
          SetDlgItemText( hwnd, ID_FILENAME,
             fUntitled ? szUntitled : PFileInPath(szFileName) );
          SetFocus( hwnd );
          return( TRUE );

       case WM_INITMENU:
          EnableMenuItem( hSysMenu, (WORD)SC_CLOSE, (DWORD)MF_GRAYED );
          return( TRUE );
    }
    return( FALSE );

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}


/*
 * print out the translated header/footer string in proper position.
 * uses globals xPrintWidth, ...
 *
 * returns 1 if line was printed, otherwise 0.
 */

INT PrintHeaderFooter (HDC hDC, INT nHF)
{
    SIZE    Size;    // to compute the width of each string
    INT     yPos;    // y position to print
    INT     xPos;    // x position to print

    if( *chPageText[nHF] == 0 )   // see if anything to do
        return 0;                // we didn't print

    TranslateString( chPageText[nHF] );

    // figure out the y position we are printing

    if( nHF == HEADER )
        yPos= dyTop;
    else
        yPos= yPrintRes - dyBottom - yPrintChar;

    // print out the various strings
    // N.B. could overprint which seems ok for now

    if( *chBuff[LEFT] )     // left string
    {
        TextOut( hDC, dxLeft, yPos, chBuff[LEFT], lstrlen(chBuff[LEFT]) );
    }

    if( *chBuff[CENTER] )   // center string
    {
        GetTextExtentPoint32( hDC, chBuff[CENTER], lstrlen(chBuff[CENTER]), &Size );
        xPos= (xPrintRes-dxRight+dxLeft)/2 - Size.cx/2;
        TextOut( hDC, xPos, yPos, chBuff[CENTER], lstrlen(chBuff[CENTER]) );
    }

    if( *chBuff[RIGHT] )    // right string
    {
        GetTextExtentPoint32( hDC, chBuff[RIGHT], lstrlen(chBuff[RIGHT]), &Size );
        xPos= xPrintRes - dxRight - Size.cx;
        TextOut( hDC, xPos, yPos, chBuff[RIGHT], lstrlen(chBuff[RIGHT]) );
    }
    return 1;              // we did print something
}
/*
 * GetResolutions
 *
 * Gets printer resolutions.
 * sets globals: xPrintRes, yPrintRes, yPixInch
 *
 */

VOID GetResolutions(HDC hPrintDC)
{
    xPrintRes = GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes = GetDeviceCaps( hPrintDC, VERTRES );
    yPixInch  = GetDeviceCaps( hPrintDC, LOGPIXELSY );

    xPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALWIDTH );
    yPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALHEIGHT );

    xPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETX );
    yPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETY );
}

/* GetMoreText
 *
 * Gets the next line of text from the MLE, returning a pointer
 * to the beginning and just past the end.
 *
 * linenum    - index into MLE                                   (IN)
 * pStartText - start of MLE                                     (IN)
 * ppsStr     - pointer to where to put pointer to start of text (OUT)
 * ppEOL      - pointer to where to put pointer to just past EOL (OUT)
 *
 */

VOID GetMoreText( INT linenum, PTCHAR pStartText, PTCHAR* ppsStr, PTCHAR* ppEOL )
{
    INT Offset;        // offset in 'chars' into edit buffer
    INT nChars;        // number of chars in line

    Offset= (INT)SendMessage( hwndEdit, EM_LINEINDEX, linenum, 0 );

    nChars= (INT)SendMessage( hwndEdit, EM_LINELENGTH, Offset, 0 );

    *ppsStr= pStartText + Offset;

    *ppEOL= (pStartText+Offset) + nChars;
}

#ifdef DBGPRINT
TCHAR dbuf[100];
VOID ShowMargins( HDC hPrintDC )
{
    INT xPrintRes, yPrintRes;
    RECT rct;
    HBRUSH hBrush;

    xPrintRes= GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes= GetDeviceCaps( hPrintDC, VERTRES );
    hBrush= GetStockObject( BLACK_BRUSH );

    if ( hBrush )
    {
        SetRect( &rct, 0,0,xPrintRes-1, yPrintRes-1 );
        FrameRect( hPrintDC, &rct, hBrush );
        SetRect( &rct, dxLeft, dyTop, xPrintRes-dxRight, yPrintRes-dyBottom );
        FrameRect( hPrintDC, &rct, hBrush );
    }
}

VOID PrintLogFont( LOGFONT lf )
{
    wsprintf(dbuf,TEXT("lfHeight          %d\n"), lf.lfHeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"), lf.lfWidth         ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"), lf. lfEscapement   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"), lf.lfOrientation   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"), lf.lfWeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"), lf.lfItalic        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderline       %d\n"), lf.lfUnderline     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"), lf.lfStrikeOut     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"), lf.lfCharSet       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"), lf.lfOutPrecision  ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecison    %d\n"), lf.lfClipPrecision ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"), lf.lfQuality       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"), lf.lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"), lf.lfFaceName      ); ODS(dbuf);
}
#endif

// GetPrinterDCviaDialog
//
// Use the common dialog PrintDlgEx() function to get a printer DC to print to.
//
// Returns: valid HDC or INVALID_HANDLE_VALUE if error.
//

HDC GetPrinterDCviaDialog( VOID )
{
    PRINTDLGEX pdTemp;
    HDC hDC;
    HRESULT hRes;

    //
    // Get the page setup information
    //

    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
    }

    //
    // Initialize the dialog structure
    //

    ZeroMemory( &pdTemp, sizeof(pdTemp) );

    pdTemp.lStructSize= sizeof(pdTemp);

    pdTemp.hwndOwner= hwndNP;
    pdTemp.nStartPage= START_PAGE_GENERAL;
    
    // FEATURE: We turn off multiple copies seen 'notepad' doesn't do it.
    //          But this will work on many print drivers esp. if using EMF printing.
    //          We may want to add our own code to do the multiple copies

    pdTemp.Flags= PD_NOPAGENUMS  | PD_RETURNDC | PD_NOCURRENTPAGE |
                  PD_USEDEVMODECOPIESANDCOLLATE  |
                  PD_NOSELECTION | 0;

    // if use set printer in PageSetup, use it here too.

    if( g_PageSetupDlg.hDevMode )
    {
        pdTemp.hDevMode= g_PageSetupDlg.hDevMode;
    }

    if( g_PageSetupDlg.hDevNames )
    {
        pdTemp.hDevNames= g_PageSetupDlg.hDevNames;
    }


    //
    // let user select printer
    //

    hRes= PrintDlgEx( &pdTemp );

    //
    // get DC if valid return
    //

    hDC= INVALID_HANDLE_VALUE;

    if( hRes == S_OK )
    {
        if( (pdTemp.dwResultAction == PD_RESULT_PRINT) || (pdTemp.dwResultAction == PD_RESULT_APPLY) )
        {
            if( pdTemp.dwResultAction == PD_RESULT_PRINT )
            {
                hDC= pdTemp.hDC;
            }
            
            //
            // Get the page setup information for the printer selected in case it was
            // the first printer added by the user through notepad.
            //
            if( !g_PageSetupDlg.hDevMode ) 
            {
                g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
                PageSetupDlg(&g_PageSetupDlg);
                g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
            }

            // change devmode if user pressed print or apply
            g_PageSetupDlg.hDevMode= pdTemp.hDevMode;
            g_PageSetupDlg.hDevNames= pdTemp.hDevNames;
        }       
    }

    // FEATURE: free hDevNames

    return( hDC );
}

INT NpPrint( PRINT_DIALOG_TYPE type)
{
    HDC hPrintDC;

    SetCursor( hWaitCursor );

    switch( type )
    {
        case UseDialog:
            hPrintDC= GetPrinterDCviaDialog();
            break;
        case NoDialogNonDefault:
            hPrintDC= GetNonDefPrinterDC();
            break;
        case DoNotUseDialog:
        default:
            hPrintDC= GetPrinterDC();
            break;
    }

    if( hPrintDC == INVALID_HANDLE_VALUE )
    {
        SetCursor( hStdCursor );
        return( 0 );   // message already given
    }

    return( NpPrintGivenDC( hPrintDC ) );

}

INT NpPrintGivenDC( HDC hPrintDC )
{
    HANDLE     hText= NULL;          // handle to MLE text
    HFONT      hPrintFont= NULL;     // font to print with
    HANDLE     hPrevFont= NULL;      // previous font in hPrintDC

    BOOL       fPageStarted= FALSE;  // true if StartPage called for this page
    BOOL       fDocStarted=  FALSE;  // true if StartDoc called
    PTCHAR     pStartText= NULL;     // start of edit text (locked hText)
    TEXTMETRIC Metrics;
    TCHAR      msgbuf[MAX_PATH];     // Document name for tracking print job
    INT        nLinesPerPage;        // not inc. header and footer
    // iErr will contain the first error discovered ie it is sticky
    // This will be the value returned by this function.
    // It does not need to translate SP_* errors except for SP_ERROR which should be
    // GetLastError() right after it is first detected.
    INT        iErr=0;               // error return
    DOCINFO    DocInfo;
    LOGFONT    lfPrintFont;          // local version of FontStruct
    LCID       lcid;                 // locale id

    fAbort = FALSE;
    hAbortDlgWnd= NULL;

    SetCursor( hWaitCursor );

    GetResolutions( hPrintDC );

    // Get the time and date for use in the header or trailer.
    // We use the GetDateFormat and GetTimeFormat to get the
    // internationalized versions.

    GetLocalTime( &PrintTime );       // use local, not gmt

    lcid= GetUserDefaultLCID();

    GetDateFormat( lcid, DATE_LONGDATE, &PrintTime, NULL, szFormattedDate, MAXDATE );

    GetTimeFormat( lcid, 0,             &PrintTime, NULL, szFormattedTime, MAXTIME );


   /*
    * This part is to select the current font to the printer device.
    * We have to change the height because FontStruct was created
    * assuming the display.  Using the remembered pointsize, calculate
    * the new height.
    */

    lfPrintFont= FontStruct;                          // make local copy
    lfPrintFont.lfHeight= -(iPointSize*yPixInch)/(72*10);
    lfPrintFont.lfWidth= 0;

    //
    // convert margins to pixels
    // ptPaperSize is the physical paper size, not the printable area.
    // do the mapping in physical units
    //

    SetMapMode( hPrintDC, MM_ANISOTROPIC );

    SetViewportExtEx( hPrintDC,
                      xPhysRes,
                      yPhysRes,
                      NULL );

    SetWindowExtEx( hPrintDC,
                    g_PageSetupDlg.ptPaperSize.x,
                    g_PageSetupDlg.ptPaperSize.y,
                    NULL );

    rtMargin = g_PageSetupDlg.rtMargin;

    LPtoDP( hPrintDC, (LPPOINT) &rtMargin, 2 );

    SetMapMode( hPrintDC,MM_TEXT );    // restore to mm_text mode

    hPrintFont= CreateFontIndirect(&lfPrintFont);

    if( !hPrintFont )
    {
        goto ErrorExit;
    }

    hPrevFont= SelectObject( hPrintDC, hPrintFont );
    if( !hPrevFont )
    {
        goto ErrorExit;
    }

    SetBkMode( hPrintDC, TRANSPARENT );
    if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
    {
        goto ErrorExit;
    }

    // The font may not a scalable (say on a bubblejet printer)
    // In this case, just pick some font
    // For example, FixedSys 9 pt would be non-scalable

    if( !(Metrics.tmPitchAndFamily & (TMPF_VECTOR | TMPF_TRUETYPE )) )
    {
        // remove just created font

        hPrintFont= SelectObject( hPrintDC, hPrevFont );  // get old font
        DeleteObject( hPrintFont );

        memset( lfPrintFont.lfFaceName, 0, LF_FACESIZE*sizeof(TCHAR) );

        hPrintFont= CreateFontIndirect( &lfPrintFont );
        if( !hPrintFont )
        {
            goto ErrorExit;
        }

        hPrevFont= SelectObject( hPrintDC, hPrintFont );
        if( !hPrevFont )
        {
            goto ErrorExit;
        }

        if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
        {
            goto ErrorExit;
        }
    }
    yPrintChar= Metrics.tmHeight+Metrics.tmExternalLeading;  /* the height */

    tabSize = Metrics.tmAveCharWidth * 8; /* 8 ave char width pixels for tabs */

    // compute margins in pixels

    dxLeft=   max(rtMargin.left - xPhysOff,0);
    dxRight=  max(rtMargin.right  - (xPhysRes - xPrintRes - xPhysOff), 0 );
    dyTop=    max(rtMargin.top  - yPhysOff,0);
    dyBottom= max(rtMargin.bottom - (yPhysRes - yPrintRes - yPhysOff), 0 );

#ifdef DBGPRINT
    {
        TCHAR dbuf[100];
        RECT rt= g_PageSetupDlg.rtMargin;
        POINT pt;

        wsprintf(dbuf,TEXT("Print pOffx %d  pOffy %d\n"),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETX),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETY));
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALWIDTH: %d\n"), xPhysRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("HORZRES: %d\n"),xPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALOFFSETX: %d\n"),xPhysOff);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("LOGPIXELSX: %d\n"),
                 GetDeviceCaps(hPrintDC,LOGPIXELSX));
        ODS(dbuf);

        GetViewportOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Viewport org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        GetWindowOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Window org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PrintRes x: %d  y: %d\n"),xPrintRes, yPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PaperSize  x: %d  y: %d\n"),
                 g_PageSetupDlg.ptPaperSize.x,
                 g_PageSetupDlg.ptPaperSize.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("unit margins:  l: %d  r: %d  t: %d  b: %d\n"),
                 rt.left, rt.right, rt.top, rt.bottom);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("pixel margins: l: %d  r: %d  t: %d  b: %d\n"),
                 rtMargin.left, rtMargin.right, rtMargin.top, rtMargin.bottom);
        ODS(dbuf);

        wsprintf(dbuf,TEXT("dxLeft %d  dxRight %d\n"),dxLeft,dxRight);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("dyTop %d  dyBot %d\n"),dyTop,dyBottom);
        ODS(dbuf);
    }
#endif


    /* Number of lines on a page with margins  */
    /* two lines are used by header and footer */
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    if( *chPageText[HEADER] )
        nLinesPerPage--;
    if( *chPageText[FOOTER] )
        nLinesPerPage--;


    /*
    ** There was a bug in NT once where a printer driver would
    ** return a font that was larger than the page size which
    ** would then cause Notepad to constantly print blank pages
    ** To keep from doing this we check to see if we can fit ANYTHING
    ** on a page, if not then there is a problem so quit.  MarkRi 8/92
    */
    if( nLinesPerPage <= 0 )
    {
FontTooBig:
        MessageBox( hwndNP, szFontTooBig, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );

        SetLastError(0);          // no error

ErrorExit:
        iErr= GetLastError();     // remember the first error

ExitWithThisError:                // preserve iErr (return SP_* errors)

        if( hPrevFont )
        {
            SelectObject( hPrintDC, hPrevFont );
            DeleteObject( hPrintFont );
        }

        if( pStartText )          // were able to lock hText
            LocalUnlock( hText );

        if( fPageStarted )
        {
            if( EndPage( hPrintDC ) <= 0 )
            {
                // if iErr not already set then set it to the new error code.
                if( iErr == 0 )
                {
                    iErr= GetLastError();
                }
       
            }
        }    

        if( fDocStarted )
        {
            if( fAbort ) {
               AbortDoc( hPrintDC );
            }
            else {
               if( EndDoc( hPrintDC ) <= 0 )
               {
                   // if iErr not already set then set it to the new error code.
                   if (iErr == 0)
                   {
                       iErr= GetLastError();
                   }
               }
            }
        }    

        DeleteDC( hPrintDC );

        DestroyAbortWnd();

        SetCursor( hStdCursor );

        if (!fAbort)
        {
            return( iErr );
        }
        else
        {
            return( SP_USERABORT );
        }
    }



    if( (iErr= SetAbortProc (hPrintDC, AbortProc)) < 0 )
    {
        goto ExitWithThisError;
    }

    // get printer to MLE text
    hText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hText )
    {
        goto ErrorExit;
    }
    pStartText= LocalLock( hText );
    if( !pStartText )
    {
        goto ErrorExit;
    }

    GetWindowText( hwndNP, msgbuf, CharSizeOf(msgbuf) );

    EnableWindow( hwndNP, FALSE );    // Disable window to prevent reentrancy

    hAbortDlgWnd= CreateDialog(         hInstanceNP,
                              (LPTSTR)  MAKEINTRESOURCE(IDD_ABORTPRINT),
                                        hwndNP,
                                        AbortDlgProc);

    if( !hAbortDlgWnd )
    {
        goto ErrorExit;
    }

    DocInfo.cbSize= sizeof(DOCINFO);
    DocInfo.lpszDocName= msgbuf;
    DocInfo.lpszOutput= NULL;
    DocInfo.lpszDatatype= NULL; // Type of data used to record print job
    DocInfo.fwType= 0; // not DI_APPBANDING

    SetLastError(0);      // clear error so it reflects errors in the future

    if( StartDoc( hPrintDC, &DocInfo ) <= 0 )
    {
        iErr = GetLastError();
        goto ExitWithThisError;
    }
    fDocStarted= TRUE;


    // Basicly, this is just a loop surrounding the DrawTextEx API.
    // We have to calculate the printable area which will not include
    // the header and footer area.
    {
    INT iTextLeft;        // amount of text left to print
    INT iSta;              // status
    UINT dwDTFormat;       // drawtext flags
    DRAWTEXTPARAMS dtParm; // drawtext control
    RECT rect;             // rectangle to draw in
    UINT dwDTRigh = 0;     // drawtext flags (RTL)

    iPageNum= 1;
    fPageStarted= FALSE;

    // calculate the size of the printable area for the text
    // not including the header and footer

    ZeroMemory( &rect, sizeof(rect) );

    rect.left= dxLeft; rect.right= xPrintRes-dxRight;
    rect.top=  dyTop;  rect.bottom= yPrintRes-dyBottom;

    if( *chPageText[HEADER] != 0 )
    {
        rect.top += yPrintChar;
    }

    if( *chPageText[FOOTER] != 0 )
    {
        rect.bottom -= yPrintChar;
    }

    iTextLeft= lstrlen(pStartText);

    //Get the edit control direction.
    if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING)
        dwDTRigh = DT_RIGHT | DT_RTLREADING;


    while(  !fAbort && (iTextLeft>0) )
    {
        #define MAXSTATUS 100
        TCHAR szPagePrinting[MAXSTATUS+1];

        // update abort dialog box to inform user where we are in the printing
        _sntprintf( szPagePrinting, MAXSTATUS, szCurrentPage, iPageNum ); 
        SetDlgItemText( hAbortDlgWnd, ID_PAGENUMBER, szPagePrinting );

        PrintHeaderFooter( hPrintDC, HEADER );

        ZeroMemory( &dtParm, sizeof(dtParm) );

        dtParm.cbSize= sizeof(dtParm);
        dtParm.iTabLength= tabSize;

        dwDTFormat= DT_EDITCONTROL | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX |
                    DT_WORDBREAK | dwDTRigh | 0;

        if( StartPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= TRUE;

        #ifdef DBGPRINT
        ShowMargins(hPrintDC);
        #endif

        /* Ignore errors in printing.  EndPage or StartPage will find them */
        iSta= DrawTextEx( hPrintDC,
                          pStartText,
                          iTextLeft,
                          &rect,
                          dwDTFormat,
                          &dtParm);

        PrintHeaderFooter( hPrintDC, FOOTER );

        if( EndPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= FALSE;

        iPageNum++;

        // if we can't print a single character (too big perhaps)
        // just bail now.
        if( dtParm.uiLengthDrawn == 0 )
        {
            goto FontTooBig;
        }

        pStartText += dtParm.uiLengthDrawn;
        iTextLeft  -= dtParm.uiLengthDrawn;

    }


    }

    iErr=0;        // no errors
    goto ExitWithThisError;

}


VOID DestroyAbortWnd (void)
{
    EnableWindow(hwndNP, TRUE);
    DestroyWindow(hAbortDlgWnd);
    hAbortDlgWnd = NULL;
}



const DWORD s_PageSetupHelpIDs[] = {
    ID_HEADER_LABEL,       IDH_PAGE_HEADER,
    ID_HEADER,             IDH_PAGE_HEADER,
    ID_FOOTER_LABEL,       IDH_PAGE_FOOTER,
    ID_FOOTER,             IDH_PAGE_FOOTER,
    0, 0
};

/*******************************************************************************
*
*  PageSetupHookProc
*
*  DESCRIPTION:
*     Callback procedure for the PageSetup common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of PageSetup window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR CALLBACK PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    INT   id;    /* ID of dialog edit controls */
    POINT pt;

    switch (Message)
    {

        case WM_INITDIALOG:
            for (id = ID_HEADER; id <= ID_FOOTER; id++)
            {
                SendDlgItemMessage(hWnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hWnd, id, chPageText[id - ID_HEADER]);
            }

            SendDlgItemMessage(hWnd, ID_HEADER, EM_SETSEL, 0,
                               MAKELONG(0, PT_LEN-1));
            return TRUE;

        case WM_DESTROY:
            //  We don't know if the user hit OK or Cancel, so we don't
            //  want to replace our real copies until we know!  We _should_ get
            //  a notification from the common dialog code!
            for( id = ID_HEADER; id <= ID_FOOTER; id++ )
            {
                GetDlgItemText(hWnd, id, chPageTextTemp[id - ID_HEADER],PT_LEN);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {

                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);

            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/***************************************************************************
 * VOID TranslateString(TCHAR *src)
 *
 * purpose:
 *    translate a header/footer strings
 *
 * supports the following:
 *
 *    &&    insert a & char
 *    &f    current file name or (untitled)
 *    &d    date in Day Month Year
 *    &t    time
 *    &p    page number
 *    &p+num  set first page number to num
 *
 * Alignment:
 *    &l, &c, &r for left, center, right
 *
 * params:
 *    IN/OUT  src     this is the string to translate
 *
 *
 * used by:
 *    Header Footer stuff
 *
 * uses:
 *    lots of c lib stuff
 *
 ***************************************************************************/


VOID TranslateString (TCHAR * src)
{
    TCHAR        buf[MAX_PATH];
    TCHAR       *ptr;
    INT          page;
    INT          nAlign=CENTER;    // current string to add chars to
    INT          foo;
    INT          nIndex[RIGHT+1];  // current lengths of (left,center,right)
    struct tm   *newtime;
    time_t       long_time;
    INT          iLen;             // length of strings

    nIndex[LEFT]   = 0;
    nIndex[CENTER] = 0;
    nIndex[RIGHT]  = 0;


    /* Get the time we need in case we use &t. */
    time (&long_time);
    newtime = localtime (&long_time);


    while (*src)   /* look at all of source */
    {
        while (*src && *src != TEXT('&'))
        {
            chBuff[nAlign][nIndex[nAlign]] = *src++;
            nIndex[nAlign] += 1;
        }

        if (*src == TEXT('&'))   /* is it the escape char? */
        {
            src++;

            if (*src == szLetters[0] || *src == szLetters[1])
            {                      /* &f file name (no path) */
                if (!fUntitled)
                {
                    GetFileTitle(szFileName, buf, CharSizeOf(buf));
                }
                else
                {
                    lstrcpy(buf, szUntitled);
                }

                /* Copy to the currently aligned string. */
                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen (buf);
                }

            }
            else if (*src == szLetters[2] || *src == szLetters[3])  /* &P or &P+num page */
            {
                src++;
                page = 0;
                if (*src == TEXT('+'))       /* &p+num case */
                {
                    src++;
                    while (_istdigit(*src))
                    {
                        /* Convert to int on-the-fly*/
                        page = (10*page) + (*src) - TEXT('0');
                        src++;
                    }
                }

                wsprintf( buf, TEXT("%d"), iPageNum+page );  // convert to chars

                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );
                    nIndex[nAlign] += lstrlen (buf);
                }
                src--;
            }
            else if (*src == szLetters[4] || *src == szLetters[5])   /* &t time */
            {
                iLen= lstrlen( szFormattedTime );

                /* extract time */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedTime, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == szLetters[6] || *src == szLetters[7])   /* &d date */
            {
                iLen= lstrlen( szFormattedDate );

                /* extract day month day */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedDate, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == TEXT('&'))       /* quote a single & */
            {
                if( nIndex[nAlign] + 1 < MAXTITLE )
                {
                    chBuff[nAlign][nIndex[nAlign]] = TEXT('&');
                    nIndex[nAlign] += 1;
                }
            }
            /* Set the alignment for whichever has last occured. */
            else if (*src == szLetters[8] || *src == szLetters[9])   /* &c center */
                nAlign=CENTER;
            else if (*src == szLetters[10] || *src == szLetters[11]) /* &r right */
                nAlign=RIGHT;
            else if (*src == szLetters[12] || *src == szLetters[13]) /* &d date */
                nAlign=LEFT;

            src++;
        }
     }
     /* Make sure all strings are null-terminated. */
     for (nAlign= LEFT; nAlign <= RIGHT ; nAlign++)
        chBuff[nAlign][nIndex[nAlign]] = (TCHAR) 0;

}

/* GetPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */

HANDLE GetPrinterDC (VOID)
{
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    HDC hDC;


    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;
    }

    if( !g_PageSetupDlg.hDevNames )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    lpDevNames= (LPDEVNAMES) GlobalLock (g_PageSetupDlg.hDevNames);


    lpDevMode= NULL;

    if( g_PageSetupDlg.hDevMode )
       lpDevMode= (LPDEVMODE) GlobalLock( g_PageSetupDlg.hDevMode );

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    /* The lpszOutput name is null so CreateDC will use the current setting
     * from PrintMan.
     */

    hDC= CreateDC (((LPTSTR)lpDevNames)+lpDevNames->wDriverOffset,
                      ((LPTSTR)lpDevNames)+lpDevNames->wDeviceOffset,
                      NULL,
                      lpDevMode);

    GlobalUnlock( g_PageSetupDlg.hDevNames );

    if( g_PageSetupDlg.hDevMode )
        GlobalUnlock( g_PageSetupDlg.hDevMode );


    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* GetNonDefPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */
/*                        using the name of the Printer server */

HANDLE GetNonDefPrinterDC (VOID)
{
    HDC     hDC;
    HANDLE  hPrinter;
    DWORD   dwBuf;
    DRIVER_INFO_1  *di1;



    // open the printer and retrieve the driver name.
    if (!OpenPrinter(szPrinterName, &hPrinter, NULL))
    {
        return INVALID_HANDLE_VALUE;
    }

    // get the buffer size.
    GetPrinterDriver(hPrinter, NULL, 1, NULL, 0, &dwBuf);
    di1 = (DRIVER_INFO_1  *) LocalAlloc(LPTR, dwBuf);
    if (!di1)
    {
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 1, (LPBYTE) di1, dwBuf, &dwBuf))
    {
        LocalFree(di1);
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    // Initialize the PageSetup dlg to default values.
    // using default printer's value for another printer !!
    g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
    PageSetupDlg(&g_PageSetupDlg);
    g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;

    // create printer dc with default initialization.
    hDC= CreateDC (di1->pName, szPrinterName, NULL, NULL);

    // cleanup.
    LocalFree(di1);
    ClosePrinter(hPrinter);

    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* PrintIt() - print the file, giving popup if some error */

void PrintIt(PRINT_DIALOG_TYPE type)
{
    INT iError;
    TCHAR* szMsg= NULL;
    TCHAR  msg[400];       // message info on error

    /* print the file */

    iError= NpPrint( type );

    if(( iError != 0) &&
       ( iError != SP_APPABORT )     &&
       ( iError != SP_USERABORT ) )
    {
        // translate any known spooler errors
        if( iError == SP_OUTOFDISK   ) iError= ERROR_DISK_FULL;
        if( iError == SP_OUTOFMEMORY ) iError= ERROR_OUTOFMEMORY;
        if( iError == SP_ERROR       ) iError= GetLastError();
        /* SP_NOTREPORTED not handled.  Does it happen? */


        //
        // iError may be 0 because the user aborted the printing.
        // Just ignore.
        //

        if( iError == 0 ) return;

        // Get system to give reasonable error message
        // These will also be internationalized.

        if(!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           iError,
                           GetUserDefaultLangID(),
                           msg,  // where message will end up
                           CharSizeOf(msg), NULL ) )
        {
            szMsg= szCP;   // couldn't get system to say; give generic msg
        }
        else
        {
            szMsg= msg;
        }

        AlertBox( hwndNP, szNN, szMsg, fUntitled ? szUntitled : szFileName,
                  MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\npmisc.c ===
/*
 * misc notepad functions
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

BOOL fCase = FALSE;         // Flag specifying case sensitive search 
BOOL fReverse = FALSE;      // Flag for direction of search 

extern HWND hDlgFind;       // handle to modeless FindText window 

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive )
{
   TCHAR cLastCharU;
   TCHAR cLastCharL;
   INT   iLen;

   cLastCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cLastCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do
   {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive)
      {
         if (*lpLast != *lpSearch)
            continue;
      }
      else
      {
           if( !( *lpLast == cLastCharU || *lpLast == cLastCharL ) )
            continue;
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpLast, lpSearch, iLen))
            break;
      }
      else
      {
         //
         // compare whole string using locale specific comparison.
         // do not use C runtime version since it may be wrong.
         //

         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpLast,   iLen,
                    lpSearch, iLen) )
            break;
      }
   } while (TRUE);

   return lpLast;
}

LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive )
{
   TCHAR cFirstCharU;
   TCHAR cFirstCharL;
   int iLen = lstrlen(lpSearch);

   cFirstCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cFirstCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   while (*lpSource)
   {
      if (fCaseSensitive)
      {
         if (*lpSource != *lpSearch)
         {
            lpSource++;
            continue;
         }
      }
      else
      {
         if( !( *lpSource == cFirstCharU || *lpSource == cFirstCharL ) )
         {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpSource, lpSearch, iLen))
            break;
      }
      else
      {
         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpSource, iLen,
                    lpSearch, iLen) )
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
}


// search forward or backward in the edit control text for the given pattern
// It is the responsibility of the caller to set the cursor

BOOL Search (TCHAR * szKey)
{
    BOOL      bStatus= FALSE;
    TCHAR   * pStart, *pMatch;
    DWORD     StartIndex, LineNum, EndIndex;
    DWORD     SelStart, SelEnd, i;
    HANDLE    hEText;           // handle to edit text
    UINT      uSelState;
    HMENU     hMenu;
    BOOL      bSelectAll = FALSE;


    if (!*szKey)
        return( bStatus );

    SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);


    // when we finish the search, we highlight the text found, and continue 
    // the search after the end of the highlighted position (in forward 
    // case) or from the begining of the highlighted position in the reverse
    // direction (in reverse case). this would break if the user has 
    // selected all text. this hack would take care of it. (this is consistent
    // with VC editors' search too.

    hMenu = GetMenu(hwndNP);
    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if (uSelState == MF_GRAYED)
    {
        bSelectAll = TRUE;
        SelStart = SelEnd =0;
    }


    //
    // get pointer to edit control text to search
    //

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return( bStatus );
    }
    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return( bStatus );
    }

    if (fReverse)
    {
        // Get current line number 
        LineNum= (DWORD)SendMessage(hwndEdit, EM_LINEFROMCHAR, SelStart, 0);
        // Get index to start of the line
        StartIndex= (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, LineNum, 0);
        // Set upper limit for search text
        EndIndex= SelStart;
        pMatch= NULL;

        // Search line by line, from LineNum to 0
        i = LineNum;
        while (TRUE)
        {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            // current StartIndex is the upper limit for the next search 
            EndIndex= StartIndex;

            if (i)
            {
                // Get start of the next line
                i-- ;
                StartIndex = (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, i, 0);
            }
            else
               break ;
        }
    }
    else
    {
            pMatch= ForwardScan(pStart+SelEnd, szKey, fCase);
    }

    LocalUnlock(hEText);

    if (pMatch == NULL)
    {
        //
        // alert user on not finding any text unless it is replace all
        //
        if( !(FR.Flags & FR_REPLACEALL) )
        {
            HANDLE hPrevCursor= SetCursor( hStdCursor );
            AlertBox( hDlgFind ? hDlgFind : hwndNP,
                      szNN,
                      szCFS,
                      szSearch,
                      MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
            SetCursor( hPrevCursor );
        }
    }
    else
    {
        SelStart = (DWORD)(pMatch - pStart);
        SendMessage( hwndEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));

        // since we are selecting the found text, enable SelectAll again.
        if (bSelectAll)
        {
            EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
        }

        //
        // show the selected text unless it is replace all
        //

        if( !(FR.Flags & FR_REPLACEALL) )
        {
            SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            UpdateStatusBar( TRUE );
        }
        bStatus= TRUE;   // found
    }

    return( bStatus );
}

// Recreate notepad edit window, get text from old window and put in new window. 
// Called when user changes style from wrap on/off 
//
// Called with the style of the new window
//

BOOL NpReCreate( long style )
{
    RECT    rcT1;
    HWND    hwndT1;
    HANDLE  hT1;
    int     cchTextNew;
    TCHAR*  pchText;
    BOOL    fWrapIsOn = ((style & WS_HSCROLL) != 0);
    HCURSOR hPrevCursor;
    BOOL    bModified;     // modify flag from old edit buffer

    // if wordwrap, remove soft carriage returns 

    hPrevCursor= SetCursor( hWaitCursor );     // this may take some time...
    if( fWrapIsOn ) 
    {
        GotoAndScrollInView(1);  // get around MLE bug

        SendMessage(hwndEdit, EM_FMTLINES, FALSE, 0L);
    }

    bModified= (SendMessage( hwndEdit, EM_GETMODIFY, 0,0 ) != 0);

    cchTextNew= (int)SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0L );
    hT1= LocalAlloc( LMEM_MOVEABLE, ByteCountOf(cchTextNew + 1) );
    if( !hT1 )
    {
        // failed, restore wordwrap; insert soft carriage returns
        if( fWrapIsOn )
        {
            SendMessage(hwndEdit, EM_FMTLINES, TRUE, 0L);
        }
        SetCursor( hPrevCursor );
        return FALSE;
    }

    GetClientRect( hwndNP, (LPRECT)&rcT1 );

    //
    // save the current edit control text.
    //

    pchText= LocalLock (hT1);
    SendMessage( hwndEdit, WM_GETTEXT, cchTextNew+1, (LPARAM)pchText );
    hwndT1= CreateWindowEx( WS_EX_CLIENTEDGE,
        TEXT("Edit"),
        TEXT(""), // pchText
        style,
        0,
        0,
        rcT1.right,
        rcT1.bottom,
        hwndNP,
        (HMENU)ID_EDIT,
        hInstanceNP, NULL );
    if( !hwndT1 )
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )      // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        LocalUnlock(hT1);
        LocalFree(hT1);
        return FALSE;
    }

    //
    // The user can "add" styles to the edit window after it is
    // created (like WS_EX_RTLREADING) when language packs are installed.
    // Preserve these styles when changing the word wrap.
    //

    SetWindowLong( hwndT1 ,
                   GWL_EXSTYLE ,
                   GetWindowLong( hwndEdit , GWL_EXSTYLE )|WS_EX_CLIENTEDGE ) ;

    // Set font before set text to save time calculating
    SendMessage( hwndT1, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0) );

    if (!SendMessage (hwndT1, WM_SETTEXT, 0, (LPARAM) pchText))
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )   // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        DestroyWindow( hwndT1 );
        LocalUnlock( hT1 );
        LocalFree( hT1 );
        return FALSE;
    }
    LocalUnlock(hT1);


    DestroyWindow( hwndEdit );     // out with the old
    hwndEdit = hwndT1;             // in with the new

    // free the earlier allocated memory in hEdit

    if (hEdit)
        LocalFree(hEdit);

    hEdit = hT1;

    // limit text for safety's sake.

    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    ShowWindow(hwndNP, SW_SHOW);
    SendMessage( hwndEdit, EM_SETMODIFY, bModified, 0L );
    SetFocus(hwndEdit);

    SetCursor( hPrevCursor );   // restore cursor

    // redraw the status bar

    if( fStatus )
    {
        RECT rcClient;
        GetClientRect(hwndNP, &rcClient);
        NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
        UpdateStatusBar( TRUE );
        ShowWindow( hwndStatus, SW_SHOW );
   }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\nputf.c ===
/*
 * nputf.c  - Routines for utf text processing for notepad
 *
 *   Copyright (C) 1998-2001 Microsoft Inc.
 */

#include "precomp.h"


/* IsTextUTF8
 *
 * UTF-8 is the encoding of Unicode based on Internet Society RFC2279
 * ( See http://www.cis.ohio-state.edu/htbin/rfc/rfc2279.html )
 *
 * Basicly:
 * 0000 0000-0000 007F - 0xxxxxxx  (ascii converts to 1 octet!)
 * 0000 0080-0000 07FF - 110xxxxx 10xxxxxx    ( 2 octet format)
 * 0000 0800-0000 FFFF - 1110xxxx 10xxxxxx 10xxxxxx (3 octet format)
 * (this keeps going for 32 bit unicode) 
 * 
 *
 * Return value:  TRUE, if the text is in UTF-8 format.
 *                FALSE, if the text is not in UTF-8 format.
 *                We will also return FALSE is it is only 7-bit ascii, so the right code page
 *                will be used.
 *
 *                Actually for 7 bit ascii, it doesn't matter which code page we use, but
 *                notepad will remember that it is utf-8 and "save" or "save as" will store
 *                the file with a UTF-8 BOM.  Not cool.
 */


INT IsTextUTF8( LPSTR lpstrInputStream, INT iLen )
{
    INT   i;
    DWORD cOctets;  // octets to go in this UTF-8 encoded character
    UCHAR chr;
    BOOL  bAllAscii= TRUE;

    cOctets= 0;
    for( i=0; i < iLen; i++ ) {
        chr= *(lpstrInputStream+i);

        if( (chr&0x80) != 0 ) bAllAscii= FALSE;

        if( cOctets == 0 )  {
            //
            // 7 bit ascii after 7 bit ascii is just fine.  Handle start of encoding case.
            //
            if( chr >= 0x80 ) {  
               //
               // count of the leading 1 bits is the number of characters encoded
               //
               do {
                  chr <<= 1;
                  cOctets++;
               }
               while( (chr&0x80) != 0 );

               cOctets--;                        // count includes this character
               if( cOctets == 0 ) return FALSE;  // must start with 11xxxxxx
            }
        }
        else {
            // non-leading bytes must start as 10xxxxxx
            if( (chr&0xC0) != 0x80 ) {
                return FALSE;
            }
            cOctets--;                           // processed another octet in encoding
        }
    }

    //
    // End of text.  Check for consistency.
    //

    if( cOctets > 0 ) {   // anything left over at the end is an error
        return FALSE;
    }

    if( bAllAscii ) {     // Not utf-8 if all ascii.  Forces caller to use code pages for conversion
        return FALSE;
    }

    return TRUE;
}


/* IsInputTextUnicode
 * Verify if the input stream is in Unicode format.
 *
 * Return value:  TRUE, if the text is in Unicode format.
 *
 * 29 June 1998          
 */


INT IsInputTextUnicode  (LPSTR lpstrInputStream, INT iLen)
{
    INT  iResult= ~0; // turn on IS_TEXT_UNICODE_DBCS_LEADBYTE
    BOOL bUnicode;

    bUnicode= IsTextUnicode( lpstrInputStream, iLen, &iResult);

    // this code is not required as IsTextUnicode does the required checks
    // and it's legal to have a unicode char with a DBCS leading byte!

#ifdef UNUSEDCODE
{

    if (bUnicode                                         &&
       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    )
    {
        CPINFO cpiInfo;
        CHAR* pch= (CHAR*)lpstrInputStream;
        INT  cb;

        //
        // If the result depends only upon statistics, check
        // to see if there is a possibility of DBCS.
        // Only do this check if the ansi code page is DBCS
        //

        GetCPInfo( CP_ACP, &cpiInfo);

        if( cpiInfo.MaxCharSize > 1 )
        {
            for( cb=0; cb<iLen; cb++ )
            {
                if( IsDBCSLeadByte(*pch++) )
                {
                    return FALSE;
                }
            }
        }
     }
}

#endif

     return bUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\mkuni\mkuni.h ===
#define ID_ASCII                    105
#define ID_LATIN                    106
#define ID_LATIN_E                  107
#define ID_LATIN_X                  108
#define ID_PHONETIC                 109
#define ID_MODIFIER                 110
#define ID_DIACRITICAL              111
#define ID_GREEK                    112
#define ID_CYRILLIC                 113
#define ID_CYRILLIC_X               114
#define ID_HEBREW                   115
#define ID_CURRENCY                 116
#define ID_LETTERS                  117
#define ID_ARROWS                   118
#define ID_MATH                     119
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\dialogs.h ===
/* Dialog box ids */
#define DTPROP                      100
#define IDD_EDIT                    101
#define IDD_LISTBOX                 102
#define IDD_AUTO                    103
#define IDD_MANUAL                  104
#define IDD_UPDATE                  105
#define IDD_FREEZE                  106
#define IDD_CHANGE                  107
#define IDD_PLAY                    108

#define DTINVALIDLINK               200

#define DTCHANGETEXT                300
#define IDD_LABEL                   301
#define IDD_ICONTEXT                302

#define DTCHANGECMDTEXT             400
#define IDD_COMMAND                 401

#define DTFAILEDUPDATE              502
#define IDD_CONTINUEEDIT            503
#define IDD_UPDATEEXIT              504
#define IDD_TEXT                    505

#define ICONDLG                     600
#define IDD_NAME                    601
#define IDD_ICON                    602
#define IDD_BROWSE                  603
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\cmdlink.c ===
/* cmdlink.c - Handles command line/pseudo-link objects.
 */

#include "packager.h"
#include <shellapi.h>

DECLSPEC_IMPORT BOOL SafeOpenPromptForPackager(HWND hwnd, PCWSTR pszFile, BOOL bFromCommandLine);

DWORD CmlWaitForChildProc( LPVOID lpv ) 
{
    if (WaitForSingleObject((HANDLE)lpv, INFINITE) == 0) 
    {
        if (gfInvisible) 
        {
            PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    }

    CloseHandle((HANDLE)lpv);

    return 0;
}


void _CmlExecute(LPCSTR pszFile, LPCSTR pszParams)
{
    HRESULT hr;

    WCHAR szUrlName[MAX_PATH];
    WCHAR szDialogName[MAX_PATH];
    BOOL bResult;
    SHELLEXECUTEINFO sexi = {0};
    DWORD err = NO_ERROR;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFile, -1, szUrlName, ARRAYSIZE(szUrlName));
    StringCchCopyW(szDialogName, ARRAYSIZE(szDialogName), szUrlName);
    if(pszParams && *pszParams)
    {
        StringCchCatW(szDialogName, ARRAYSIZE(szDialogName), L" ");
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszParams, -1, szUrlName, ARRAYSIZE(szUrlName));
        StringCchCatW(szDialogName, ARRAYSIZE(szDialogName),szUrlName);
    }

    if(SafeOpenPromptForPackager(NULL, szDialogName, TRUE))
    {
        // Now we can execute the link file.
        sexi.cbSize = sizeof(sexi);
        sexi.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOZONECHECKS ;
        sexi.lpFile =  pszFile;
        sexi.lpParameters = pszParams;
        sexi.nShow = SW_SHOWNORMAL;

        if (ShellExecuteEx(&sexi)) 
        {
            if (sexi.hProcess != NULL)
            {
                // Start a thread to wait on the app and close packager once it has ended
                DWORD id;
                HANDLE hThd = CreateThread(NULL, 0, CmlWaitForChildProc, sexi.hProcess, 0, &id );
                if (hThd) 
                {
                    CloseHandle(hThd);
                }
                else
                {
                    CloseHandle(sexi.hProcess);
                    err = GetLastError();
                }
            } 
        } 
        else
        {
            err = GetLastError();
        }

        if (err != NO_ERROR)
            ErrorMessage((err == ERROR_NO_ASSOCIATION) ? E_FAILED_TO_FIND_ASSOCIATION : E_FAILED_TO_EXECUTE_COMMAND);
    }
}

/* CmlActivate() - Activate the command line/pseudo-linked file.
 */
VOID CmlActivate(LPCML lpcml)
{
    LPSTR pchTemp = lpcml->szCommand;
    CHAR chSave = 0;
    BOOL fInQuote = FALSE;

    /* skip leading spaces */
    while (*pchTemp && *pchTemp == CHAR_SPACE)
        pchTemp = CharNext(pchTemp);


    /* find first non-quoted space */
    for (; *pchTemp && (*pchTemp != CHAR_SPACE || fInQuote); pchTemp = CharNext(pchTemp))
    {
        if (*pchTemp == CHAR_QUOTE) 
        {
            fInQuote = !fInQuote;
        }
    }

    if (*pchTemp)
    {
        chSave = *pchTemp;
        *pchTemp++ = 0;
    }

    DPRINT("packager: Calling ShellExecute");
    _CmlExecute(lpcml->szCommand, pchTemp);
    DPRINT("packager: Back from ShellExecute");

    if (chSave)
        *(--pchTemp) = chSave;
}



/* CmlClone() -
 */
LPCML
CmlClone(
    LPCML lpcml
    )
{
    return CmlCreate(lpcml->szCommand, lpcml->fCmdIsLink);
}



/* CmlCreate() -
 */
LPCML
CmlCreateWorker(
    LPSTR lpstrCmd,
    BOOL fCmdIsLink,
    BOOL fFileName)
{
    HANDLE hdata = NULL;
    LPCML lpcml = NULL;

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE, sizeof(CML))) ||
        !(lpcml = (LPCML)GlobalLock(hdata)))
        goto errRtn;

    // Store the data in the window itself
    lpcml->hdata = hdata;
    lpcml->fCmdIsLink = fCmdIsLink;

    /*
     * If it is not a single filename,
     *      or the filename does not have a space in it,
     *      or the 'filename' has double qoute characters in it, then
     * just copy it without quoting.
     */
    if (!fFileName || strchr( lpstrCmd, CHAR_SPACE ) == NULL ||
            strchr( lpstrCmd, CHAR_QUOTE ) != NULL)

        StringCchCopy(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), lpstrCmd);

    else {
        LPSTR psz = lpcml->szCommand;
        *psz++ = CHAR_QUOTE;
        StringCchCopy(psz, ARRAYSIZE(lpcml->szCommand) - 1, lpstrCmd);
        StringCchCat(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), SZ_QUOTE);
    }
    CmlFixBounds(lpcml);

    return lpcml;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lpcml)
        GlobalUnlock(hdata);

    if (hdata)
        GlobalFree(hdata);

    return NULL;
}



/* CmlDelete() - Wipe out the command line.
 */
VOID
CmlDelete(
    LPCML lpcml
    )
{
    HANDLE hdata;

    if (lpcml)
    {
        GlobalUnlock(hdata = lpcml->hdata);
        GlobalFree(hdata);
    }
}



/* CmlDraw() - Draw the command line, centered nicely.
 */
VOID
CmlDraw(
    LPCML lpcml,
    HDC hdc,
    LPRECT lprc,
    INT xHSB,
    BOOL fFocus
    )
{
    HFONT hfont;
    RECT rcFocus;
    CHAR szDesc[CBSTRINGMAX];
    CHAR szFile[CBCMDLINKMAX];
    CHAR szMessage[CBSTRINGMAX + CBCMDLINKMAX];
    RECT rc;

    hfont = SelectObject(hdc, ghfontChild);

    if (lpcml->fCmdIsLink)
    {
        LoadString(ghInst, IDS_LINKTOFILE, szDesc, CharCountOf(szDesc));
        StringCchCopy(szFile, ARRAYSIZE(szFile), lpcml->szCommand);
        Normalize(szFile);
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, (LPSTR)szFile);

        DrawText(hdc, szMessage, -1, lprc, DT_SINGLELINE | DT_NOPREFIX |
            DT_CENTER | DT_VCENTER);

        if (fFocus)
        {
            rcFocus = *lprc;
            DrawText(hdc, szMessage, -1, &rcFocus, DT_CALCRECT | DT_SINGLELINE |
                DT_NOPREFIX | DT_LEFT | DT_TOP);
            OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) /
                2, (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
            DrawFocusRect(hdc, &rcFocus);
        }
    }
    else
    {
        rc = *lprc;

        // We should have scroll bars, the text is wider than the window
        if (rc.right < lpcml->rc.right)
        {
            rc.right = lpcml->rc.right;
            OffsetRect(&rc, -xHSB, 0);
        }

        DrawText(hdc, lpcml->szCommand, -1, &rc, DT_SINGLELINE | DT_NOPREFIX |
            DT_CENTER | DT_VCENTER);

        if (fFocus)
            DrawFocusRect(hdc, &rc);
    }

    if (hfont)
        SelectObject(hdc, hfont);
}



/* CmlFixBounds() -
 */
VOID
CmlFixBounds(
    LPCML lpcml
    )
{
    HDC hdc;
    HFONT hfont;

    // Figure out how large the text region will be
    if (*lpcml->szCommand)
    {
        if (hdc = GetWindowDC(ghwndFrame))
        {
            hfont = SelectObject(hdc, ghfontChild);

            SetRect(&(lpcml->rc), 0, 0, 20000, 100);
            DrawText(hdc, lpcml->szCommand, -1, &(lpcml->rc), DT_CALCRECT |
                DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

            if (hfont)
                SelectObject(hdc, hfont);

            ReleaseDC(ghwndFrame, hdc);
        }
    }
    else
    {
        SetRect(&(lpcml->rc), 0, 0, 0, 0);
    }

    PostMessage(ghwndPane[CONTENT], WM_FIXSCROLL, 0, 0L);
}



/* CmlReadFromNative() - Read a command line object from the native data.
 */
LPCML
CmlReadFromNative(
    LPSTR *lplpstr
    )
{
    BOOL fCmdIsLink;
    WORD w;
    CHAR szCmd[CBCMDLINKMAX];

    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    fCmdIsLink = (BOOL)w;
    StringCchCopy(szCmd, ARRAYSIZE(szCmd), *lplpstr);
    *lplpstr += lstrlen(szCmd) + 1;

    return CmlCreate(szCmd, fCmdIsLink);
}



/* CmlWriteToNative() - Write a command line object to the native data.
 */
DWORD
CmlWriteToNative(
    LPCML lpcml,
    LPSTR *lplpstr
    )
{
    WORD w;

    if (lplpstr)
    {
        w = (WORD)lpcml->fCmdIsLink;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        MemWrite(lplpstr, (LPSTR)lpcml->szCommand,
            lstrlen(lpcml->szCommand) + 1);
    }

    return sizeof(WORD) + lstrlen(lpcml->szCommand) + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\notepad\mkuni\mkuni.c ===
/****************************************************************************

    PROGRAM: MkUni.c

    PURPOSE: Creates a text file with unicode characters

    FUNCTIONS:

****************************************************************************/

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "mkuni.h"


#define REVERSE    0
#define LINE_SIZE  1000

#define ASCIIEOL TEXT("\r\n")
#define UNILINESEP 0x2028
#define UNIPARASEP 0x2029

struct __range {
	int	low;
	int	high;
	LPTSTR	pDes;
} range[] = {
            {0x20,  0x7f,   TEXT("ANSI") },
            {0xa0,  0xff,   TEXT("Latin") },
            {0x100, 0x17f,  TEXT("European Latin") },
            {0x180, 0x1f0,  TEXT("Extended Latin") },
            {0x250, 0x2a8,  TEXT("Standard Phonetic") },
            {0x2b0, 0x2e9,  TEXT("Modifier Letters") },
            {0x300, 0x341,  TEXT("Generic Diacritical") },
            {0x370, 0x3f5,  TEXT("Greek") },
            {0x400, 0x486,  TEXT("Cyrillic") },
            {0x490, 0x4cc,  TEXT("Extended Cyrillic") },
            {0x5b0, 0x5f5,  TEXT("Hebrew") },
            {0x0600,0x06F9, TEXT("Arabic") },
            {0x0900,0x0970, TEXT("Devanagari") },
            {0x0E00,0x0E5B, TEXT("Thai") },
            {0x1000,0x104C, TEXT("Tibetan") },
            {0x10A0,0x10FB, TEXT("Georgian") },
            {0x20a0,0x20aa, TEXT("Currency Symbols") },
            {0x2100,0x2138, TEXT("Letterlike Symbols") },
            {0x2153,0x2182, TEXT("Number Forms") },
            {0x2190,0x21ea, TEXT("Arrows") },
            {0x2200,0x22f1, TEXT("Math Operators") },
            {0x2500,0x257F, TEXT("Form and Chart Components") },
            {0x25A0,0x25EE, TEXT("Geometric Shapes") },
            {0x2600,0x266F, TEXT("Miscellaneous Dingbats") },
            {0x3000,0x303F, TEXT("CJK Symbols and Punctuations") },            
            {0x3040,0x309E, TEXT("Hiragana") },
            {0x3100,0x312C, TEXT("Bopomofo") },
            {0x3131,0x318E, TEXT("Hangul Elements") },
            {0,     0,      TEXT("terminating entry") },
            };

/****************************************************************************

    FUNCTION: putu(FILE*pf, TCHAR c)

    PURPOSE: writes a character to the file.
             (Reverses the order of leadbytes if the flag is set)

****************************************************************************/

void
putu(FILE*pf, TCHAR c)
{
    TCHAR chr=c;

    if( REVERSE )
        chr= ( c<<8 ) + ( ( c>>8 ) &0xFF);


	fwrite((void*)&chr, 1, sizeof(TCHAR), pf);
}


/****************************************************************************

    FUNCTION: putust(FILE*pf, LPTSTR pc)

    PURPOSE: writes a string to the file.

****************************************************************************/

void
putust(FILE*pf, LPTSTR pc)
{
	while (*pc)
		putu(pf, *pc++);
}


/****************************************************************************

    FUNCTION: main(int, char**)

    PURPOSE: write sample unicode file

****************************************************************************/

int _cdecl main(int argc, char**argv)
{
    struct __range*pr = range;
    int	    i;
    FILE    *pf;
    FILE    *pfo;
    char    lpstrLine[LINE_SIZE];

    if(!(pf = fopen("unicode.txt", "wb")))
        return FALSE;

    // Task1: Write all the unicode ranges and all the characters 
    // in those ranges to the output file.
    putu(pf, (TCHAR)0xfeff);
    while (pr->low != 0) {
    	putust(pf, TEXT("<<< "));
    	putust(pf, pr->pDes);
    	putust(pf, TEXT(" >>>"));
    	putust(pf, ASCIIEOL );
    	for (i=pr->low ; i<=pr->high ; i++)
    	    putu(pf, (TCHAR)i);
    	putust(pf, ASCIIEOL);
    	pr++;
    }

    putust(pf, TEXT("Unicode Line separator here ->"));
    putu(pf, UNILINESEP );
    putust(pf, TEXT("<- Unicode line separator"));
    putust( pf, ASCIIEOL );
    
    putust(pf, TEXT("Unicode Paragraph separator here ->"));
    putu(pf, UNIPARASEP );
    putust(pf, TEXT("<- Unicode paragraph separator"));
    putust( pf, ASCIIEOL );

    fclose( pf );

    // Task2: Write all the characters codes and information
    // on each character code to an output file.
    if (!(pf = fopen( "names2.txt", "r" )))
        return FALSE;

    if (!(pfo = fopen("unicodes.txt", "wb")))
        return FALSE;

    // The first character should be 0xFEFF in the file, 
    // indicating that it's an unicode file.
    putu( pfo, (TCHAR)0xfeff);

    // Read the input file (names2.txt) which has information
    // on every unicode character.
    do
    {
    WCHAR wLineBuffer[LINE_SIZE];
    int i, num;

        if (!memset(lpstrLine, 0, LINE_SIZE))
        {
            _tprintf(TEXT("Something wrong - failed in Memset!!\n") );
            break;
        }
       
        // fgets returns NULL on eof or on an error condition
        if( fgets( lpstrLine, LINE_SIZE, pf) == NULL )
        {
            if (!feof(pf))
               _tprintf(TEXT("Error occured while reading names2.txt.\n") );

            break;
        }

        i = 0;
        
        // Find the first newline (if there is any) and replace it by \0.
        while((lpstrLine[i]!= '\n') && (lpstrLine[i]!='\r') && (lpstrLine[i]!='\0'))
        {
            i++;
        }

        lpstrLine[i]= '\0';
       
        // If the line has the character code (for which info is given)
        // grab and "display" that.
        num= -1;
        sscanf( lpstrLine, "%x", &num);

        if( num != -1 )
        {
            putu( pfo, (TCHAR) num );
            putust( pfo, TEXT(": ") );
        }
        else
        {
            putust( pfo,TEXT("   ") );
        }
        // Convert it to the world of unicodes.
        if (MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpstrLine, -1, 
                        wLineBuffer, LINE_SIZE ))
            putust(pfo, wLineBuffer);

        putust( pfo, ASCIIEOL );

    }
    while( TRUE );

    fclose( pfo );
    fclose( pf );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\dlgprocs.c ===
/* dlgprocs.c - Packager-specific dialog routines.
 */

#include "packager.h"
#include <shellapi.h>
#include <commdlg.h>
#include "dialogs.h"
// #include "..\..\library\shell.h"

// HACK: Copied from shsemip.h
#ifdef WINNT
    WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPWSTR pwszIconPath, UINT cchIconPath, int *piIconIndex);
    int  PkgPickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
#else
    WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPSTR pwszIconPath, UINT cchIconPath, int *piIconIndex);
#   define PkgPickIconDlg(h, s, c, p)  PickIconDlg(h, s, c, p)
#endif

#define CBCUSTFILTER 40

static CHAR szPathField[CBPATHMAX];
static CHAR szDirField[CBPATHMAX];
static CHAR szStarDotEXE[] = "*.EXE";
static CHAR szShellDll[] = "shell32.dll";
static CHAR szCommand[CBCMDLINKMAX];
static CHAR szIconText[CBPATHMAX];



/*--------------------------------------------------------------------------*/
/*                                      */
/*  MyDialogBox() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

INT_PTR MyDialogBox(
    UINT idd,
    HWND hwndParent,
    DLGPROC lpfnDlgProc
    )
{
    return DialogBoxAfterBlock(MAKEINTRESOURCE(idd), hwndParent, lpfnDlgProc);
}



#ifdef WINNT
/*
 * NT's PickIconDlg is UNICODE only, so thunk it here
 */

/* PkgPickIconDlg() -
 *
 *  hwnd        - window
 *  pszIconPath - ANSI path for icon suggested icon file (also output buffer that holds real icon file)
 *  cchIconPath - size of the buffer in chars pointed to pszIconPath. NOT the string length!
 *  piIconIndex - receives the index of the icon
 *
 */
int  PkgPickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cchIconPath, int *piIconIndex) {
    WCHAR wszPath[MAX_PATH+1];
    int iRet;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszIconPath, -1, wszPath, ARRAYSIZE(wszPath));

    iRet = PickIconDlg(hwnd, wszPath, cchIconPath, piIconIndex);
    wszPath[MAX_PATH] = L'\0'; // Make sure text is zero terminated, even if it is garbage

    WideCharToMultiByte( CP_ACP, 0, wszPath, -1, pszIconPath, cchIconPath, NULL, NULL );

    return iRet;
}
#endif

/* IconDialog() -
 *
 */
BOOL
IconDialog(
    LPIC lpic
    )
{
    char szIconPath[MAX_PATH];
    int iDlgIcon = lpic->iDlgIcon;
    StringCchCopy(szIconPath, ARRAYSIZE(szIconPath), (*lpic->szIconPath) ? lpic->szIconPath : szShellDll);

    if (PkgPickIconDlg(ghwndPane[APPEARANCE],
                    szIconPath, sizeof(szIconPath)/sizeof(char), &iDlgIcon))
    {
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), szIconPath);
        lpic->iDlgIcon = iDlgIcon;
        GetCurrentIcon(lpic);
        return TRUE;
    }

    return FALSE;
}



/* ChangeCmdLine() - Summons the Command Line... dialog.
 *
 */
BOOL
ChangeCmdLine(
    LPCML lpcml
    )
{
    StringCchCopy(szCommand, ARRAYSIZE(szCommand), lpcml->szCommand);

    if (DialogBoxAfterBlock(MAKEINTRESOURCE(DTCHANGECMDTEXT),
        ghwndPane[CONTENT], fnChangeCmdText) != IDOK)
        return FALSE;

    StringCchCopy(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), szCommand);
    CmlFixBounds(lpcml);

    return TRUE;
}



/* ChangeLabel() - Summons the Label... dialog.
 *
 */
VOID
ChangeLabel(
    LPIC lpic
    )
{
    INT iPane = APPEARANCE;

    StringCchCopy(szIconText, ARRAYSIZE(szIconText), lpic->szIconText);

    if (DialogBoxAfterBlock(MAKEINTRESOURCE(DTCHANGETEXT),
        ghwndPane[iPane], fnChangeText)
        && lstrcmp(lpic->szIconText, szIconText))
    {
        // label has changed, set the undo object.
        if (glpobjUndo[iPane])
            DeletePaneObject(glpobjUndo[iPane], gptyUndo[iPane]);

        gptyUndo[iPane]  = ICON;
        glpobjUndo[iPane] = IconClone (lpic);
        StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), szIconText);
    }
}



/**************************** Dialog Functions ****************************/
/* fnChangeCmdText() - Command Line... dialog procedure.
 */
INT_PTR CALLBACK
fnChangeCmdText(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPSTR psz;

    switch (msg)
    {
        case WM_INITDIALOG:
            SetDlgItemText(hDlg, IDD_COMMAND, szCommand);
            SendDlgItemMessage(hDlg, IDD_COMMAND, EM_LIMITTEXT, CBCMDLINKMAX - 1, 0L);
            PostMessage(hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem(hDlg, IDD_COMMAND), 1L);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDD_LABEL:
                    PostMessage(hDlg, WM_NEXTDLGCTL,
                        (WPARAM)GetDlgItem(hDlg, IDD_COMMAND), 1L);
                    break;

                case IDOK:
                    GetDlgItemText(hDlg, IDD_COMMAND, szCommand, CBCMDLINKMAX);
                    /*
                     * Eat leading spaces to make Afrikaners in high places
                     * happy.
                     */
                    psz = szCommand;
                    while(*psz == CHAR_SPACE)
                        psz++;

                    if( psz != szCommand ) {
                        LPSTR pszDst = szCommand;

                        while(*psz) {
                            *pszDst++ = *psz++;
                        }

                        /* copy null across */
                        *pszDst = *psz;
                    }

                // FALL THROUGH TO IDCANCEL

                case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
            }
    }

    return FALSE;
}



/* fnProperties() - Link Properties... dialog
 */
INT_PTR CALLBACK
fnProperties(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndLB = GetDlgItem(hDlg, IDD_LISTBOX);

    switch (msg)
    {
    case WM_REDRAW:
        SendMessage(hwndLB, WM_SETREDRAW, 0, 0L);

    case WM_INITDIALOG:
        {
            BOOL fChangeLink = TRUE;
            HANDLE hData = NULL;
            LONG otFocus;
            LPSTR lpstrData = NULL;
            LPSTR lpstrTemp;
            LPOLEOBJECT lpObject;
            LPVOID lpobjFocus;
            LPVOID lpobjFocusUndo;
            OLEOPT_UPDATE update;
            CHAR szType[CBMESSAGEMAX];
            CHAR szFull[CBMESSAGEMAX * 4];
            INT idButton;
            INT iPane;

            iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
            lpobjFocus = glpobj[iPane];
            lpobjFocusUndo = glpobjUndo[iPane];
            lpObject = ((LPPICT)lpobjFocus)->lpObject;

            // Reset the list box
            SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

            if (msg == WM_INITDIALOG)
            {
                // If it wasn't a link it doesn't belong
                OleQueryType(lpObject, &otFocus);

                if (otFocus != OT_LINK)
                {
                    ghwndError = ghwndFrame;
                    EndDialog(hDlg, TRUE);
                    break;
                }

                PicSaveUndo(lpobjFocus);
                ghwndError = hDlg;
            }

            //
            // Redrawing the string, get the update options and
            // the button state for IDD_AUTO/IDD_MANUAL.
            //
            Error(OleGetLinkUpdateOptions(lpObject, &update));

            switch (update)
            {
            case oleupdate_always:
                LoadString(ghInst, IDS_AUTO, szType, CBMESSAGEMAX);
                idButton    = IDD_AUTO;
                break;

            case oleupdate_oncall:
                LoadString(ghInst, IDS_MANUAL, szType, CBMESSAGEMAX);
                idButton    = IDD_MANUAL;
                break;

            default:
                LoadString(ghInst, IDS_CANCELED, szType, CBMESSAGEMAX);
                idButton = -1;

                // Disable the change link button
                fChangeLink = FALSE;
            }

            //
            // Retrieve the server name (try it from Undo
            // if the object has been frozen)
            //
            if (Error(OleGetData(lpObject, gcfLink, &hData)) || !hData)
            {
                OleQueryType(lpObject, &otFocus);
                if (otFocus != OT_STATIC)
                {
                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                    return TRUE;
                }

                if (gptyUndo[iPane] == PICTURE &&
                    (Error(OleGetData(((LPPICT)lpobjFocusUndo)->lpObject,
                    gcfLink, &hData)) || !hData))
                {
                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                    return TRUE;
                }
            }

            // The link format is:  "szClass0szDocument0szItem00"
            if (hData && (lpstrData = GlobalLock(hData)))
            {
                // Retrieve the server's class ID
                RegGetClassId(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                // Display the Document and Item names
                while (*lpstrData++)
                    ;

                // Strip off the path name and drive letter
                lpstrTemp = lpstrData;
                while (*lpstrTemp)
                {
                    if (*lpstrTemp == '\\' || *lpstrTemp == ':')
                        lpstrData = lpstrTemp + 1;

                    if (gbDBCS)
                    {
                        lpstrTemp = CharNext(lpstrTemp);
                    }
                    else
                    {
                        lpstrTemp++;
                    }
                }

                // Append the file name
                StringCchCat(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                // Append the item name
                while (*lpstrData++)
                    ;

                StringCchCat(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                GlobalUnlock(hData);
            }
            else
            {
                StringCchCopy(szFull, ARRAYSIZE(szFull), "\t\t\t");
            }

            // Append the type of link
            StringCchCat(szFull, ARRAYSIZE(szFull), szType);

            // Draw the link in the list box
            SendMessage(hwndLB, LB_INSERTSTRING, (WPARAM) - 1, (LPARAM)szFull);

            if (msg == WM_REDRAW)
            {
                SendMessage(hwndLB, WM_SETREDRAW, 1, 0L);
                InvalidateRect(hwndLB, NULL, TRUE);
                Dirty();
            }

            // Uncheck those buttons that shouldn't be checked
            if (IsDlgButtonChecked(hDlg, IDD_AUTO) && (idButton != IDD_AUTO))
                CheckDlgButton(hDlg, IDD_AUTO, FALSE);

            if (IsDlgButtonChecked(hDlg, IDD_MANUAL) && (idButton != IDD_MANUAL))
                CheckDlgButton(hDlg, IDD_MANUAL, FALSE);

            // Check the dialog button, as appropriate
            if ((idButton == IDD_AUTO) || (idButton == IDD_MANUAL))
                CheckDlgButton(hDlg, idButton, TRUE);

            // Enable the other buttons appropriately
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE),
                ((otFocus != OT_STATIC) && fChangeLink));
            EnableWindow(GetDlgItem(hDlg, IDD_EDIT), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_PLAY), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_AUTO), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), (otFocus != OT_STATIC));

            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDCANCEL:
                PostMessage(ghwndFrame, WM_COMMAND, IDM_UNDO, 0L);

            case IDOK:
                ghwndError = ghwndFrame;
                EndDialog(hDlg, TRUE);
                return TRUE;

            default:
                break;
        }

        SendMessage(ghwndPane[GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]],
            WM_COMMAND, wParam, 0L);

        switch (LOWORD(wParam))
        {
            // Dismiss the dialog on Edit/Activate
            case IDD_EDIT:
            case IDD_PLAY:
                ghwndError = ghwndFrame;
                EndDialog(hDlg, TRUE);
                return TRUE;

            default:
                break;
        }

        break;
    }

    return FALSE;
}



/* fnChangeText() - Label... dialog
 */
INT_PTR CALLBACK
fnChangeText(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hDlg, IDD_ICONTEXT, szIconText);
        SendDlgItemMessage(hDlg, IDD_ICONTEXT, EM_LIMITTEXT, 39, 0L);
        PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_ICONTEXT),
             1L);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_LABEL:
            PostMessage(hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem(hDlg, IDD_ICONTEXT), 1L);
            break;

        case IDOK:
            GetDlgItemText(hDlg, IDD_ICONTEXT, szIconText, CBMESSAGEMAX);
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
    }

    return FALSE;
}



/* fnInvalidLink() - Invalid Link dialog
 *
 * This is the two button "Link unavailable" dialog box.
 */
INT_PTR CALLBACK
fnInvalidLink(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDD_CHANGE:
            EndDialog(hDlg, LOWORD(wParam));
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\globals.c ===
//
// Module: globals.c
//
// Global variables for the Object Packager.
//
//

#include "packager.h"


INT gcxIcon;
INT gcyIcon;
INT gcxArrange;                     // Icon text wrap boundary
INT gcyArrange;
INT giXppli = DEF_LOGPIXELSX;       // Number of pixels per logical
INT giYppli = DEF_LOGPIXELSY;       // inch along width and height

BOOL gfEmbObjectOpen = FALSE;
BOOL gfBlocked = FALSE;
BOOL gfEmbedded = FALSE;            // Editing an embedded object?
BOOL gfInvisible = FALSE;           // Editing invisibly?
BOOL gfOleClosed = FALSE;           // Should we send Ole_Closed or not?
BOOL gfEmbeddedFlag = FALSE;        // Editing with /Embedded flag?
BOOL gfDocCleared = FALSE;
BOOL gfServer = FALSE;              // Is the server loaded?
BOOL gfDocExists = FALSE;

HANDLE ghInst;                      // Unique instance identifier
HACCEL ghAccTable;                  // Application specific accelerator table
HBRUSH ghbrBackground = NULL;       // Fill brush used to paint background
HFONT ghfontTitle = NULL;
HFONT ghfontChild;                  // Font for caption bar
HCURSOR ghcurWait;                  // Hourglass cursor

HWND ghwndFrame;                    // Main window
HWND ghwndBar[CCHILDREN];
HWND ghwndPane[CCHILDREN];
HWND ghwndPict;
HWND ghwndError = NULL;             // Parent window when Error popup happens

INT gnCmdShowSave;                  // Show flags; saved if started invisibly
UINT gcOleWait = 0;                 // OLE asynchronous transaction counter
LHCLIENTDOC glhcdoc = 0;	   // Handle to client document "link"
LPSAMPDOC gvlptempdoc = NULL;
LPAPPSTREAM glpStream = NULL;
LPOLECLIENT glpclient = NULL;
LPVOID glpobj[CCHILDREN];
LPVOID glpobjUndo[CCHILDREN];
HANDLE ghServer = NULL;             // Handle to server memory block
LPSAMPSRVR glpsrvr = NULL;          // Pointer to OLE server memory
LPSAMPDOC glpdoc = NULL;            // Pointer to current OLE document
DWORD gcbObject;
PANETYPE gpty[CCHILDREN];
PANETYPE gptyUndo[CCHILDREN];

OLECLIPFORMAT gcfFileName = 0;      // Clipboard format "FileName"
OLECLIPFORMAT gcfLink = 0;          // Clipboard format "ObjectLink"
OLECLIPFORMAT gcfNative = 0;        // Clipboard format "Native"
OLECLIPFORMAT gcfOwnerLink = 0;     // Clipboard format "OwnerLink"

CHAR gszClientName[CCLIENTNAMEMAX]; // Name of the client application
CHAR gszFileName[CBPATHMAX];
CHAR gszCaption[CCHILDREN][CBMESSAGEMAX];
CHAR gszProtocol[] = "StdFileEditing";
CHAR gszSProtocol[] = "Static";
CHAR gszTemp[] = "Fake Object";
CHAR gszAppClassName[] = "Package"; // Not NLS specific

CHAR szAppName[CBMESSAGEMAX];       // Application name
CHAR szUntitled[CBMESSAGEMAX];      // "(Untitled)" string FEATURE this is misnamed and used funny
CHAR szUndo[CBSHORTSTRING];         // "Undo %s" string
CHAR szContent[CBMESSAGEMAX];
CHAR szAppearance[CBMESSAGEMAX];
CHAR szDummy[CBSHORTSTRING];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\filedlgs.c ===
/* filedlgs.c - Handles the Windows 3.1 common dialogs.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include <commdlg.h>


static CHAR szCustFilterSpec[CBFILTERMAX];
static CHAR szFilterSpec[CBFILTERMAX];
static CHAR szLinkCaption[CBMESSAGEMAX];
static CHAR szImportFile[CBMESSAGEMAX];
static CHAR szExportFile[CBMESSAGEMAX];
static OPENFILENAME gofn;


static VOID AddExtension(LPOPENFILENAME lpOFN);



/* OfnInit() - Initializes the standard file dialog gofn structure.
 */
VOID
OfnInit(
    VOID
    )
{
    LPSTR lpstr;

    gofn.lStructSize         = sizeof(OPENFILENAME);
    gofn.hInstance           = ghInst;
    gofn.nMaxCustFilter      = CBFILTERMAX;
    gofn.nMaxFile            = CBPATHMAX;
    gofn.lCustData           = 0;
    gofn.lpfnHook            = NULL;
    gofn.lpTemplateName      = NULL;
    gofn.lpstrFileTitle      = NULL;

    LoadString(ghInst, IDS_IMPORTFILE, szImportFile, CBMESSAGEMAX);
    LoadString(ghInst, IDS_EXPORTFILE, szExportFile, CBMESSAGEMAX);
    LoadString(ghInst, IDS_CHANGELINK, szLinkCaption, CBMESSAGEMAX);
    LoadString(ghInst, IDS_ALLFILTER,  szFilterSpec, CBMESSAGEMAX);

    StringCchCat(szFilterSpec, ARRAYSIZE(szFilterSpec), "*.*");
}



/* OfnGetName() - Calls the standard file dialogs to get a file name
 */
BOOL
OfnGetName(
    HWND hwnd,
    UINT msg
    )
{
    gofn.hwndOwner           = hwnd;
    gofn.nFilterIndex        = 1;
    gofn.lpstrCustomFilter   = szCustFilterSpec;
    gofn.lpstrDefExt         = NULL;
    gofn.lpstrFile           = gszFileName;
    gofn.lpstrFilter         = szFilterSpec;
    gofn.lpstrInitialDir     = NULL;
    gofn.Flags               = OFN_HIDEREADONLY;

    Normalize(gszFileName);

    switch (msg)
    {
        case IDM_IMPORT:
            gofn.lpstrTitle = szImportFile;
            gofn.Flags |= OFN_FILEMUSTEXIST;

            return GetOpenFileName(&gofn);

        case IDM_EXPORT:
            gofn.lpstrTitle = szExportFile;
            gofn.Flags |= (OFN_PATHMUSTEXIST | OFN_NOREADONLYRETURN);

            return GetSaveFileName(&gofn);

        default:
            break;
    }

    return FALSE;
}



/* OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 */
HANDLE
OfnGetNewLinkName(
    HWND hwnd,
    HANDLE hData
    )
{
    BOOL fSuccess = FALSE;
    HANDLE hData2 = NULL;
    HANDLE hData3 = NULL;
    LPSTR lpstrData = NULL;
    LPSTR lpstrFile = NULL;
    LPSTR lpstrLink = NULL;
    LPSTR lpstrPath = NULL;
    LPSTR lpstrTemp = NULL;
    CHAR szDocFile[CBPATHMAX];
    CHAR szDocPath[CBPATHMAX];
    CHAR szServerFilter[4 * CBPATHMAX];

    // this may have to GlobalAlloc(), if a class supports
    // multiple extensions, like Pbrush then we could be in
    // trouble. I covered PBRUSH case by making array size 256

    // Get the link information
    if (!(lpstrData = GlobalLock(hData)))
        goto Error;

    // Figure out the link's path name and file name
    lpstrTemp = lpstrData;
    while (*lpstrTemp++)
        ;

    lpstrPath = lpstrFile = lpstrTemp;

    while (*(lpstrTemp = CharNext(lpstrTemp)))
    {
        if (*lpstrTemp == '\\')
            lpstrFile = lpstrTemp + 1;
    }

    // Copy the document name
    StringCchCopy(szDocFile, ARRAYSIZE(szDocFile), lpstrFile);
    *(lpstrFile - 1) = 0;

    // Copy the path name
    StringCchCopy(szDocPath, ARRAYSIZE(szDocPath), ((lpstrPath != lpstrFile) ? lpstrPath : ""));

    // If no directory, be sure the path points to the root
    if (lstrlen(szDocPath) == 2)
        StringCchCat(szDocPath, ARRAYSIZE(szDocPath), "\\");

    if (lpstrPath != lpstrFile)                 /* Restore the backslash */
        *(lpstrFile - 1) = '\\';

    while (*lpstrFile != '.' && *lpstrFile)     /* Get the extension */
        lpstrFile++;

    // Make a filter that respects the link's class name
    gofn.hwndOwner           = hwnd;
    gofn.nFilterIndex        = RegMakeFilterSpec(lpstrData, lpstrFile, szServerFilter);
    gofn.lpstrDefExt         = NULL;
    gofn.lpstrFile           = szDocFile;
    gofn.lpstrFilter         = szServerFilter;
    gofn.lpstrInitialDir     = szDocPath;
    gofn.lpstrTitle          = szLinkCaption;
    gofn.lpstrCustomFilter   = szCustFilterSpec;
    gofn.Flags               = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

    // If we get a file...
    if (GetOpenFileName(&gofn))
    {
        if (!(hData2 = GlobalAlloc(GMEM_ZEROINIT, CBPATHMAX *
            2)) || !(lpstrLink = lpstrTemp = GlobalLock(hData2)))
            goto Error;

        // ...add on the correct extension
        AddExtension(&gofn);

        // ... copy the server name
        while (*lpstrTemp++ = *lpstrData++)
            ;

        // ... copy the document name
        lstrcpy(lpstrTemp, szDocFile);
        lpstrTemp += lstrlen(lpstrTemp) + 1;
        lpstrData += lstrlen(lpstrData) + 1;

        // ... copy the item name
        while (*lpstrTemp++ = *lpstrData++)
            ;

        *lpstrTemp = 0;

        // ... and compress the memory block to minimal size
        GlobalUnlock(hData2);
        hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

        if (!hData3)
            hData3 = hData2;

        fSuccess = TRUE;
    }

Error:
    if (!fSuccess)
    {
        if (lpstrLink)
            GlobalUnlock(hData2);

        if (hData2)
            GlobalFree(hData2);

        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    return hData3;
}



/* Normalize() - Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 */
VOID
Normalize(
    LPSTR lpstrFile
    )
{
    LPSTR lpstrBackslash = NULL;
    LPSTR lpstrTemp = lpstrFile;
    BOOL fInQuote = FALSE;
    BOOL fQState = FALSE;

    while (*lpstrTemp)
    {
        if (*lpstrTemp == CHAR_QUOTE)
            fInQuote = !fInQuote;

        if (*lpstrTemp == '\\') {
            fQState = fInQuote;
            lpstrBackslash = lpstrTemp;
        }

        if (gbDBCS)
        {
            lpstrTemp = CharNext(lpstrTemp);
        }
        else
        {
            lpstrTemp++;
        }
    }

    if (lpstrBackslash) {
        if (fQState)
            *lpstrFile++ = CHAR_QUOTE;

        MoveMemory(lpstrFile, lpstrBackslash + 1,
            lstrlen(lpstrBackslash) * sizeof(lpstrBackslash[0]) );
    }
}



/* AddExtension() - Adds the extension corresponding to the filter dropdown.
 */
static VOID
AddExtension(
    LPOPENFILENAME lpOFN
    )
{
    LPSTR lpstrFilter = (LPSTR)lpOFN->lpstrFilter;

    // If the user didn't specify an extension, use the default
    if (lpOFN->nFileExtension == (UINT)lstrlen(lpOFN->lpstrFile)
        && lpOFN->nFilterIndex)
    {
        // Skip to the appropriate filter
        while (*lpstrFilter && --lpOFN->nFilterIndex)
        {
            while (*lpstrFilter++)
                ;

            while (*lpstrFilter++)
                ;
        }

        // If we got to the filter, retrieve the extension
        if (*lpstrFilter)
        {
            while (*lpstrFilter++)
                ;

            lpstrFilter++;

            // Copy the extension
            if (lpstrFilter[1] != '*')
                lstrcat(lpOFN->lpstrFile, lpstrFilter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\embed.c ===
/* embed.c - Contains the routines for pseudo-embedding objects.
 *
 * Copyright (c) Microsoft Corporation, 1991-
 *
 * Why is it called pseudo-embedding?  Because it is not embedding
 * the object in the OLE sense; rather, it just pulls the entire
 * file into memory.
 */
#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)

#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"
#include <wininet.h>
// #include <shell.h>        // For RealShellExecute() call.

#define OLEVERB_EDIT 1


static CHAR szDefTempFile[] = "PKG";
static OLECLIENTVTBL embClivtbl;
static BOOL bOleReleaseError = OLE_OK;
static HWND hTaskWnd;
static INT cEmbWait = 0;


DWORD MainWaitOnChild(LPVOID lpv);
static VOID ReplaceExtension(LPSTR lpstrTempFile, LPSTR lpstrOrigFile);
static DWORD GetFileLength(INT fh);
BOOL CALLBACK GetTaskWndProc(HWND hwnd, LPARAM lParam);
static BOOL EmbError(OLESTATUS retval);



BOOL _EmbExecute(LPCSTR pszFile, LPEMBED lpembed)
{
    DWORD err = NO_ERROR;
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
    sei.lpFile = pszFile;
    sei.nShow = SW_SHOWNORMAL;

    if (ShellExecuteEx(&sei)) 
    {
        if (lpembed->hContents)
        {
            GlobalFree(lpembed->hContents);
            lpembed->aTempName = AddAtom(pszFile);
            lpembed->dwSize    = 0;
            lpembed->hContents = NULL;
        }
        
        if (sei.hProcess)
        {
            // Start a thread to wait on the app and close packager once it has ended
            DWORD id;
            HANDLE hThd = CreateThread(NULL, 0, MainWaitOnChild, sei.hProcess, 0, &id );
            if (hThd) 
            {
                CloseHandle(hThd);
            }
            else
            {
                CloseHandle(sei.hProcess);
                err = GetLastError();
            }
        } 
        else
        {
            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    } 
    else
    {
        err = GetLastError();
    }

    if (err != NO_ERROR)
    {
        ErrorMessage((err == ERROR_NO_ASSOCIATION) ? E_FAILED_TO_FIND_ASSOCIATION : E_FAILED_TO_EXECUTE_COMMAND);
    }
    
    return  (err == NO_ERROR);
}

// Taken from shell code but slightly modified to eliminate problesm with finding ":" in the url
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case '\\':
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}

/* EmbActivate() - Performs activation of a pseudo-embedded file.
 *
 * Notes:  Assumes that lpstrFile is in the OEM character set.
 */
BOOL EmbActivate(LPEMBED lpembed, UINT wVerb)
{
    LPSTR lpFileData = NULL;

    CHAR szFileName[CBPATHMAX];
    CHAR szDefPath[CBPATHMAX];
    CHAR szTemp[CBPATHMAX];
    INT fh;
    BOOL fError = TRUE;
    LPSTR pExt = NULL;
    CHAR szCacheName[MAX_PATH];
    CHAR szUrlName[MAX_PATH + 20];
    FILETIME ftNow = {0};
    FILETIME ft = {0};
    SYSTEMTIME sysTime;
    ULONGLONG qwResult;
    //
    // If no hContents, we launched the server at some point...
    // so use the same temporary file name.
    //
    if (!lpembed->hContents)
    {
        if (lpembed->bOleSvrFile)
            return EmbDoVerb(lpembed, wVerb);

        if (lpembed->hTask)
        {
            hTaskWnd = NULL;
            EnumTaskWindows(lpembed->hTask, GetTaskWndProc, 0);

            if (hTaskWnd)
                BringWindowToTop(hTaskWnd);

            return TRUE;
        }

        if (!GetAtomName(lpembed->aTempName, szCacheName, ARRAYSIZE(szCacheName)))
            goto errRtn;
    }
    else
    {
        if (!GetAtomName(lpembed->aFileName, szFileName, ARRAYSIZE(szFileName))
            || !(lpFileData = GlobalLock(lpembed->hContents)))
            goto errRtn;

        GlobalUnlock(lpembed->hContents);

        // Find the extension -- we need it for the urlcache funcion
        pExt = PathFindExtension(szFileName);
        if('.' == *pExt)    // not expecting the '.'
            pExt++;

        GetSystemTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &ft);

        // Create a fake URL in the format expected -- While not totally unique, close enough for our purposes (4 billion)
        StringCchPrintf(szUrlName, ARRAYSIZE(szUrlName), TEXT("Packager%u:%s"), ft.dwLowDateTime, szFileName);
        // So, now I'm pointing at the ext, and I have a fake url name, so
        if(!CreateUrlCacheEntry(szUrlName, ARRAYSIZE(szCacheName), pExt, szCacheName, 0))
            goto errRtn;

        if ((fh = _lcreat(szCacheName, 0)) < 0)
            goto errRtn;

        if (_lwrite(fh, lpFileData, lpembed->dwSize) < lpembed->dwSize)
        {
            _lclose(fh);
            DeleteFile(szCacheName);
            goto errRtn;
        }

        _lclose(fh);

        // exire this in 12 hours (arbitrarily longer than a work day) since we can't always clean it up ourselves.
        // Normally we'd only care about it for a very short time, and it probably
        // wouldn't hurt to have it cleaned up if it was open anyway.
        SystemTimeToFileTime(&sysTime, &ftNow);
        // Copy the time into a quadword.
        qwResult = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
        qwResult += (12 * _HOUR);
        // Copy the result back into the FILETIME structure.
        ft.dwLowDateTime  = (DWORD) (qwResult & 0xFFFFFFFF );
        ft.dwHighDateTime = (DWORD) (qwResult >> 32 ); 

        if(!CommitUrlCacheEntry(
            szUrlName, 
            szCacheName,
            ft,
            ftNow,
            0,
            NULL,
            0,
            pExt,
            szUrlName))
        {
            goto errRtn;
        }

    }

    if (lpembed->bOleSvrFile)
    {
        fError = !EmbActivateThroughOle(lpembed, szCacheName, wVerb);
        if (!fError)
        {
            GlobalFree(lpembed->hContents);
            lpembed->aTempName = AddAtom(szCacheName);
            lpembed->dwSize    = 0;
            lpembed->hContents = NULL;
        }

        goto errRtn;
    }

    // Try to execute the file
    lpembed->hTask = NULL;
    fError = !_EmbExecute(szCacheName, lpembed);
    if (fError)
    {
        DeleteFile(szCacheName);
    }

errRtn:
    if (fError)
    {
        if (gfInvisible)
            PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
    }
    else
    {
        Dirty();
    }

    return !fError;
}


/*****************************************************************************\
* MainWaitOnChild
*
* Waits for the specified child process to exit, then posts a message
* back to the main window.
*
* Arguments:
*
*   LPVOID lpv - Handle to the child process to wait on.
*
* Returns:
*   0
*
\*****************************************************************************/

DWORD
MainWaitOnChild(
    LPVOID lpv
    )
{
    if (WaitForSingleObject((HANDLE)lpv, INFINITE) == 0)
    {
        PostMessage(ghwndFrame, WM_READEMBEDDED, 0, 0);
    }

    CloseHandle((HANDLE)lpv);

    GetLastError(); //This seems ominous

    return 0;
}



/* EmbCreate() - Performs the pseudo-embedding of a file.
 *
 * Notes:  Assumes that lpstrFile is in the OEM character set.
 *
 *         This function is used by File Import..., is called
 *         when the Embed modifier is used on Drag&Drop, and
 *         is also used when Paste-ing a File manager file.
 */
LPEMBED
EmbCreate(
    LPSTR lpstrFile
    )
{
    ATOM aFileName = 0;
    BOOL fError = TRUE;
    DWORD dwSize = 0;
    HANDLE hdata = NULL;
    HANDLE hFileData = NULL;
    LPEMBED lpembed = NULL;
    LPSTR lpFileData = NULL;
    INT fh = 0;

    if (lpstrFile)
    {
        if ((fh = _lopen(lpstrFile, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
        {
            ErrorMessage(IDS_ACCESSDENIED);
            goto errRtn;
        }

        // Seek to EOF, then to the top of the file.
        dwSize = GetFileLength(fh);
        if (0 == dwSize)
        {
            ErrorMessage(IDS_NOZEROSIZEFILES);
            goto errRtn;
        }

        if (!(aFileName = AddAtom(lpstrFile))
            || !(hFileData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
            || !(lpFileData = GlobalLock(hFileData)))
        {
            ErrorMessage(IDS_LOWMEM);
            goto errRtn;
        }

        if (_lread(fh, lpFileData, dwSize) != dwSize)
        {
            ErrorMessage(E_FAILED_TO_READ_FILE);
            goto errRtn;
        }
    }

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(EMBED)))
        || !(lpembed = (LPEMBED)GlobalLock(hdata)))
    {
        ErrorMessage(IDS_LOWMEM);
        goto errRtn;
    }

    lpembed->aFileName = aFileName;
    lpembed->dwSize = dwSize;
    lpembed->hContents = hFileData;
    lpembed->hdata = hdata;
    lpembed->bOleSvrFile = IsOleServerDoc(lpstrFile);
    fError = FALSE;

errRtn:
    if (fh)
        _lclose(fh);

    if (lpFileData)
        GlobalUnlock(hFileData);

    if (fError)
    {
        if (hdata)
            GlobalFree(hdata);

        if (aFileName)
            DeleteAtom(aFileName);

        if (hFileData)
            GlobalFree(hFileData);
    }

    return lpembed;
}



/* EmbDelete() - Deallocate the pseudo-embedded file.
 */
VOID
EmbDelete(
    LPEMBED lpembed
    )
{
    HANDLE  hdata;

    if (!lpembed)
        return;

    if (lpembed->lpLinkObj)
    {
        EmbRead(glpobj[CONTENT]);
        EmbDeleteLinkObject(lpembed);
    }
    else {
        /* If the task is active, there's nothing we can do */
#if 0
        if (lpembed->hSvrInst)
            TermToolHelp(lpembed);
#endif  //FEATURE: Does anything need to be done for this case? Like terminating the waiting thread, perhaps?
    }

    if (lpembed->aFileName)
    {
        DeleteAtom(lpembed->aFileName);
        lpembed->aFileName = 0;
    }

    if (lpembed->aTempName)
    {
        DeleteAtom(lpembed->aTempName);
        lpembed->aTempName = 0;
    }

    if (lpembed->hContents)
    {
        GlobalFree(lpembed->hContents);
        lpembed->dwSize = 0;
        lpembed->hContents = NULL;
    }

    GlobalUnlock(hdata = lpembed->hdata);
    GlobalFree(hdata);
}



/* EmbDraw() - Draw the pseudo-embedded object.
 *
 * Note:  This drawing is DESCRIPTION-ONLY.
 */
VOID
EmbDraw(
    LPEMBED lpembed,
    HDC hdc,
    LPRECT lprc,
    BOOL fFocus
    )
{
    RECT rcFocus;
    CHAR szEmbedFile[CBMESSAGEMAX];
    CHAR szFileName[CBPATHMAX];
    CHAR szMessage[CBMESSAGEMAX + CBPATHMAX];

    if (GetAtomName(lpembed->aFileName, szFileName, CBPATHMAX)
        && LoadString(ghInst, IDS_EMBEDFILE, szEmbedFile, CBMESSAGEMAX))
    {
        Normalize(szFileName);
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szEmbedFile, (LPSTR)szFileName);

        DrawText(hdc, szMessage, -1, lprc,
            DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        if (fFocus)
        {
            rcFocus = *lprc;
            DrawText(hdc, szMessage, -1, &rcFocus, DT_CALCRECT | DT_NOPREFIX |
                DT_LEFT | DT_TOP | DT_SINGLELINE);
            OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) /
                2, (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
            DrawFocusRect(hdc, &rcFocus);
        }
    }
}



/* EmbReadFromNative() - Reads a pseudo-embedded object from memory.
 *
 * Notes:  This function is called by GetNative().
 */
LPEMBED
EmbReadFromNative(
    LPSTR *lplpstr
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPEMBED lpembed = NULL;
    LPSTR lpData = NULL;
    CHAR szFileName[CBPATHMAX];

    MemRead(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
    MemRead(lplpstr, (LPSTR)szFileName, dwSize);
    MemRead(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));

    if (!(lpembed = EmbCreate(NULL))
        || !(hData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
        || !(lpData = GlobalLock(hData)))
        goto errRtn;

    MemRead(lplpstr, (LPSTR)lpData, dwSize);

    lpembed->aFileName = AddAtom(szFileName);
    lpembed->dwSize = dwSize;
    lpembed->hContents = hData;
    lpembed->bOleSvrFile = IsOleServerDoc(szFileName);
    fError = FALSE;

errRtn:
    if (lpData)
        GlobalUnlock(hData);

    if (fError)
    {
        if (hData)
            GlobalFree(hData);

        if (lpembed)
        {
            EmbDelete(lpembed);
            lpembed = NULL;
        }
    }

    return lpembed;
}



/* EmbWriteToNative() - Used to save pseudo-embed to memory.
 *
 * Note:  This function is called by GetNative().
 */
DWORD
EmbWriteToNative(
    LPEMBED lpembed,
    LPSTR *lplpstr
    )
{
    BOOL fError = TRUE;
    DWORD cBytes = 0;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPSTR lpData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szFileName[CBPATHMAX];
    INT fhTemp = -1;
    CHAR * hplpstr;

    if (!GetAtomName(lpembed->aFileName, szFileName, CBPATHMAX))
        goto errRtn;

    if (!lplpstr)
    {
        cBytes = lstrlen(szFileName) + 1 + sizeof(dwSize);
    }
    else
    {
        dwSize = lstrlen(szFileName) + 1;
        MemWrite(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
        MemWrite(lplpstr, (LPSTR)szFileName, dwSize);
    }

    // Read from memory if it's there; otherwise, it's executing
    if (lpembed->hContents)
    {
        cBytes += sizeof(lpembed->dwSize) + lpembed->dwSize;

        if (lplpstr)
        {
            if (!(lpFileData = GlobalLock(lpembed->hContents)))
                goto errRtn;

            MemWrite(lplpstr, (LPSTR)&(lpembed->dwSize), sizeof(lpembed->dwSize));
            MemWrite(lplpstr, (LPSTR)lpFileData, lpembed->dwSize);
        }
    } else {
        int i;

        if (!GetAtomName(lpembed->aTempName, szFileName, CBPATHMAX))
            goto errRtn;

        for (i = 0; i < 5; i++ ) {
            int j;

            fhTemp = _lopen(szFileName, OF_READ | OF_SHARE_DENY_WRITE);

            if (fhTemp != HFILE_ERROR) {
                break;
            }

            /*
             * We could not open the file.  It is probably still open by the
             * server.  Wait 5 seconds for the server to finish closing the
             * file and then try again.
             */
            for (j=0; j<25; j++) {
                MSG msg;
                PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
                Sleep(200);
            }
        }

        /*
         * If after 25 seconds we still could not open the file, then it
         * must be screwed
         */
        if (fhTemp == HFILE_ERROR)
            goto errRtn;

        dwSize = GetFileLength(fhTemp);

        if (!lplpstr)
            cBytes += sizeof(dwSize) + dwSize;
        else
        {
            MemWrite(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
            _lread(fhTemp, *lplpstr, dwSize);

            // Increment the pointer being read into
            hplpstr = *lplpstr;
            hplpstr += dwSize;
            *lplpstr = hplpstr;
        }
    }

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);
        if (!fError && lplpstr && !(lpembed->hTask || lpembed->lpLinkObj))
            DeleteFile(szFileName);
    }

    if (lpData)
        GlobalUnlock(hData);

    if (hData)
        GlobalFree(hData);

    if (lpFileData)
        GlobalUnlock(lpembed->hContents);

    return (fError ? ((DWORD)(-1L)) : cBytes);
}



/* EmbWriteToFile() - Used to save pseudo-embed to a file.
 *
 * Note:  This function is called by File Export...
 */
VOID
EmbWriteToFile(
    LPEMBED lpembed,
    INT fh
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPSTR lpData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szTempName[CBPATHMAX];
    INT fhTemp = -1;
    CHAR szMessage[CBMESSAGEMAX];

    // Read from memory if it's there
    if (lpembed->hContents)
    {
        if (!(lpFileData = GlobalLock(lpembed->hContents)))
            goto errRtn;

        if (_lwrite(fh, lpFileData, lpembed->dwSize) != lpembed->dwSize)
            goto errRtn;
    }
    else
    {
        // otherwise, it is/was executing
        if (lpembed->hTask && !gfInvisible)
        {
            // Object being edited, snapshot current contents?
            LoadString(ghInst, IDS_ASKCLOSETASK, szMessage, CBMESSAGEMAX);
            BringWindowToTop(ghwndFrame);
            switch (MessageBoxAfterBlock(ghwndError, szMessage, szAppName,
                 MB_OKCANCEL))
            {
                case IDOK:
                    break;

                case IDCANCEL:
                    return;
            }
        }

        if (!GetAtomName(lpembed->aTempName, szTempName, CBPATHMAX)
            || (fhTemp = _lopen(szTempName, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
            goto errRtn;

        dwSize = GetFileLength(fhTemp);
        while (dwSize && !(hData = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
            dwSize = dwSize >> 1;

        if (!dwSize || !(lpData = GlobalLock(hData)))
            goto errRtn;

        while (dwSize)
        {
            dwSize = _lread(fhTemp, lpData, dwSize);

            if (dwSize)
                _lwrite(fh, lpData, dwSize);
        }
    }

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);

        if (!fError && !lpembed->hTask)
            DeleteFile(gszFileName);
    }

    if (lpData)
        GlobalUnlock(hData);

    if (hData)
        GlobalFree(hData);

    if (lpFileData)
        GlobalUnlock(lpembed->hContents);
}



/* ReplaceExtension() - Replaces the extension of the temp file.
 *
 * This routine ensures that the temp file has the same extension as the
 * original file, so that the ShellExecute() will load the same file.
 */
static VOID
ReplaceExtension(
    LPSTR lpstrTempFile,
    LPSTR lpstrOrigFile
    )
{
    LPSTR lpstrBack = NULL;

    // Get temp file extension
    while (*lpstrTempFile)
    {
        if (*lpstrTempFile == '\\')
            lpstrBack = lpstrTempFile;

        if (gbDBCS)
        {
            lpstrTempFile = CharNext(lpstrTempFile);
        }
        else
        {
            lpstrTempFile++;
        }
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
        lpstrTempFile = lpstrBack + 1;

    // Get original file extension
    while (*lpstrOrigFile)
    {
        if (*lpstrOrigFile == '\\')
            lpstrBack = lpstrOrigFile;

        if (gbDBCS)
        {
            lpstrOrigFile = CharNext(lpstrOrigFile);
        }
        else
        {
            lpstrOrigFile++;
        }
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
    {
        lpstrOrigFile = lpstrBack + 1;

        // Move the extension on over
        lstrcpy(lpstrTempFile, lpstrOrigFile);
    }
    else
    {
         /* Wipe out the extension altogether */
        *lpstrTempFile = 0;
    }
}



/* GetFileLength() - Obtain the size of the temporary file used.
 *
 * Returns:         The length of the file in bytes.
 * Side effects:    Resets fh to the beginning of the file.
 */
static DWORD
GetFileLength(
    INT fh
    )
{
    DWORD dwSize;

    dwSize = _llseek(fh, 0L, 2);
    _llseek(fh, 0L, 0);

    return dwSize;
}



/* EmbRead() - Reads the contents back when the task has terminated.
 */
VOID
EmbRead(
    LPEMBED lpembed
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hFileData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szTempFileName[CBPATHMAX];
    INT fhTemp = -1;

    if (!lpembed || !lpembed->aTempName)
        return;

    if (!GetAtomName(lpembed->aTempName, szTempFileName, CBPATHMAX))
        return;

    if ((fhTemp = _lopen(szTempFileName, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
        goto errRtn;

    dwSize = GetFileLength(fhTemp);

    if (!(hFileData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
        || !(lpFileData = GlobalLock(hFileData))
        || (_lread(fhTemp, lpFileData, dwSize) != dwSize))
        goto errRtn;

    DeleteAtom(lpembed->aTempName);
    lpembed->aTempName  = 0;
    lpembed->dwSize     = dwSize;
    lpembed->hContents  = hFileData;
    lpembed->hTask      = NULL;

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);

        if (!fError)
            DeleteFile(szTempFileName);
    }

    if (lpFileData)
        GlobalUnlock(hFileData);

    if (fError && hFileData)
        GlobalFree(hFileData);
}



BOOL CALLBACK
GetTaskWndProc(
    HWND hwnd,
    LPARAM lParam
    )
{
    if (IsWindowVisible(hwnd))
    {
        hTaskWnd = hwnd;
        return FALSE;
    }

    return TRUE;
}



BOOL
EmbDoVerb(
    LPEMBED lpembed,
    UINT wVerb
    )
{
    if (wVerb == IDD_PLAY)
    {
        if (EmbError(OleActivate(lpembed->lpLinkObj, OLEVERB_PRIMARY, TRUE,
            TRUE, NULL, NULL)))
            return FALSE;
    }
    else
    {
        // it must be verb IDD_EDIT
        if (EmbError(OleActivate(lpembed->lpLinkObj, OLEVERB_EDIT, TRUE,
            TRUE, NULL, NULL)))
            return FALSE;
    }

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError != OLE_OK)
    {
        bOleReleaseError = OLE_OK;
        return FALSE;
    }

    // if the verb is IDD_PLAY then we need not do any more
    if (wVerb == IDD_PLAY)
        return TRUE;

    // If the verb is IDD_EDIT, then we must show the server, and we will do
    // that by calling server's show method
    if (EmbError((*(lpembed->lpLinkObj)->lpvtbl->Show)(lpembed->lpLinkObj,
        TRUE)))
        return FALSE;

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError != OLE_OK)
    {
        bOleReleaseError = OLE_OK;
        return FALSE;
    }

    return TRUE;
}



BOOL
EmbActivateThroughOle(
    LPEMBED lpembed,
    LPSTR lpdocname,
    UINT wVerb
    )
{
    bOleReleaseError = OLE_OK;

    if (!(lpembed->lpclient = PicCreateClient(&EmbCallBack, &embClivtbl)))
        return FALSE;

    if (EmbError(OleCreateLinkFromFile(gszProtocol, lpembed->lpclient, NULL,
        lpdocname, NULL, glhcdoc, gszCaption[CONTENT], &lpembed->lpLinkObj,
        olerender_none, 0)))
        return  FALSE;

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError == OLE_OK)
    {
        if (gfEmbObjectOpen = EmbDoVerb(lpembed, wVerb))
            return TRUE;
    }

    EmbDeleteLinkObject(lpembed);

    return FALSE;
}



/* EmbCallBack() - Routine that OLE client DLL calls when events occur.
 */
INT CALLBACK
EmbCallBack(
    LPOLECLIENT lpclient,
    OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject
    )
{
    switch (flags)
    {
    case OLE_CLOSED:
    case OLE_SAVED:
    case OLE_CHANGED:
        break;

    case OLE_RELEASE:
        if (cEmbWait)
            --cEmbWait;

        bOleReleaseError = OleQueryReleaseError(lpObject);
        break;

    default:
        break;
    }

    return 0;
}



VOID
EmbDeleteLinkObject(
    LPEMBED lpembed
    )
{
    HGLOBAL hg;

    bOleReleaseError = OLE_OK;

    if (!lpembed->lpLinkObj)
        return;

    WaitForObject(lpembed->lpLinkObj);

    if (!EmbError(OleDelete(lpembed->lpLinkObj)))
        WaitForObject (lpembed->lpLinkObj);

    lpembed->lpLinkObj = NULL;

    if (lpembed->lpclient)
    {
        if (hg = GlobalHandle(lpembed->lpclient))
        {
            GlobalUnlock(hg);
            GlobalFree(hg);
        }

        lpembed->lpclient = NULL;
    }

    gfEmbObjectOpen = FALSE;
    bOleReleaseError = OLE_OK;
}



static BOOL
EmbError(
    OLESTATUS retval
    )
{
    switch (retval)
    {
    case OLE_WAIT_FOR_RELEASE:
        cEmbWait++;
        return FALSE;

    case OLE_OK:
        return FALSE;

    default:
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\globals.h ===
//
// Module: globals.h
//
// Global variable declarations for the Object Packager.
//
//


extern INT gcxIcon;
extern INT gcyIcon;
extern INT gcxArrange;              // Icon text wrap boundary
extern INT gcyArrange;
extern INT giXppli;                 // Number of pixels per logical
extern INT giYppli;                 // inch along width and height

extern BOOL gfEmbObjectOpen;
extern BOOL gfBlocked;
extern BOOL gfEmbedded;             // Editing an embedded object?
extern BOOL gfInvisible;            // Editing invisibly?
extern BOOL gfOleClosed;            // Should we send Ole_Closed or not?
extern BOOL gfEmbeddedFlag;         // Editing with /Embedded flag?
extern BOOL gfDocCleared;
extern BOOL gfServer;               // Is the server loaded?
extern BOOL gfDocExists;
extern BOOL gbDBCS;                 // Are we running in DBCS mode?

extern HANDLE ghInst;               // Unique instance identifier
extern HACCEL ghAccTable;           // Application specific accelerator table
extern HBRUSH ghbrBackground;       // Fill brush used to paint background
extern HFONT ghfontTitle;
extern HFONT ghfontChild;           // Font for caption bar
extern HCURSOR ghcurWait;           // Hourglass cursor

extern HWND ghwndFrame;             // Main window
extern HWND ghwndBar[];
extern HWND ghwndPane[];
extern HWND ghwndPict;
extern HWND ghwndError;             // Parent window when Error popup happens

extern INT gnCmdShowSave;           // Show flags; saved if started invisibly
extern UINT gcOleWait;              // OLE asynchronous transaction counter
extern LHCLIENTDOC glhcdoc;         // Handle to client document "link"
extern LPSAMPDOC gvlptempdoc;
extern LPAPPSTREAM glpStream;
extern LPOLECLIENT glpclient;
extern LPVOID glpobj[];
extern LPVOID glpobjUndo[];
extern HANDLE ghServer;             // Handle to server memory block
extern LPSAMPSRVR glpsrvr;          // Pointer to OLE server memory
extern LPSAMPDOC glpdoc;            // Pointer to current OLE document
extern DWORD gcbObject;
extern PANETYPE gpty[];
extern PANETYPE gptyUndo[];

extern OLECLIPFORMAT gcfFileName;   // Clipboard format "FileName"
extern OLECLIPFORMAT gcfLink;       // Clipboard format "ObjectLink"
extern OLECLIPFORMAT gcfNative;     // Clipboard format "Native"
extern OLECLIPFORMAT gcfOwnerLink;  // Clipboard format "OwnerLink"

extern CHAR gszClientName[CCLIENTNAMEMAX];        // Name of the client application
extern CHAR gszFileName[];
extern CHAR gszCaption[][CBMESSAGEMAX];
extern CHAR gszProtocol[];
extern CHAR gszSProtocol[];
extern CHAR gszTemp[];
extern CHAR gszAppClassName[];      // Not NLS specific

extern CHAR szAppName[];            // Application name
extern CHAR szUntitled[CBMESSAGEMAX];           // "(Untitled)" string FEATURE this is misnamed and used funny
extern CHAR szUndo[];               // "Undo %s" string
extern CHAR szContent[];
extern CHAR szAppearance[];
extern CHAR szDummy[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\icon.c ===
/* icon.c - Handles Icon + Caption objects.
 */

#include "packager.h"
#include <shellapi.h>
// #include <shlapip.h>


static LPIC IconCreate(VOID);
void GetDisplayName(LPSTR szName, LPCSTR szPath);



/* IconClone() -
 *
 * Clones an appearance pane icon.
 */
LPIC
IconClone(
    LPIC lpic
    )
{
    LPIC lpicNew;

    if (lpicNew = IconCreate())
    {
        // Get the icon
        StringCchCopy(lpicNew->szIconPath, ARRAYSIZE(lpicNew->szIconPath), lpic->szIconPath);
        lpicNew->iDlgIcon = lpic->iDlgIcon;
        GetCurrentIcon(lpicNew);

        // Get the icon text
        StringCchCopy(lpicNew->szIconText, ARRAYSIZE(lpicNew->szIconText), lpic->szIconText);
    }

    return lpicNew;
}



/* IconCreate() -
 */
static LPIC
IconCreate(
    VOID
    )
{
    HANDLE hdata = NULL;
    LPIC lpic = NULL;

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE, sizeof(IC)))
        || !(lpic = (LPIC)GlobalLock(hdata)))
        goto errRtn;

    // Store the data in the window itself
    lpic->hdata = hdata;
    lpic->hDlgIcon = NULL;
    lpic->iDlgIcon = 0;
    *lpic->szIconPath = 0;
    *lpic->szIconText = 0;

    return lpic;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lpic)
        GlobalUnlock(hdata);

    if (hdata)
        GlobalFree(hdata);

    return NULL;
}



/* IconCreateFromFile() -
 *
 * Allows an appearance pane icon to be created automatically if
 * a file is dropped, imported, or pasted into the packager.
 */
LPIC
IconCreateFromFile(
    LPSTR lpstrFile
    )
{
    LPIC lpic;

    if (lpic = IconCreate())
    {
        // Get the icon
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), lpstrFile);
        lpic->iDlgIcon = 0;

        if (*(lpic->szIconPath))
            GetCurrentIcon(lpic);

        // Get the icon text
        GetDisplayName(lpic->szIconText, lpstrFile);
    }

    return lpic;
}



/* IconCreateFromObject() -
 *
 * Allows an appearance pane icon to be created automatically if an
 * OLE object is dropped into the appearance pane.
 */
LPIC
IconCreateFromObject(
    LPOLEOBJECT lpObject
    )
{
    DWORD otObject;
    HANDLE hdata;
    LPIC lpic = NULL;
    LPSTR lpdata;

    OleQueryType(lpObject, &otObject);

    if ((otObject == OT_LINK
        && Error(OleGetData(lpObject, gcfLink, &hdata)))
        || (otObject == OT_EMBEDDED
        && Error(OleGetData(lpObject, gcfOwnerLink, &hdata))))
        hdata = NULL;

    if (hdata && (lpdata = GlobalLock(hdata)))
    {
        if (lpic = IconCreate())
        {
            // Get the icon
            RegGetExeName(lpic->szIconPath, lpdata, CBPATHMAX);
            lpic->iDlgIcon = 0;
            GetCurrentIcon(lpic);

            // Get the icon text
            switch (otObject)
            {
            case OT_LINK:
                while (*lpdata++)
                    ;

                StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), lpdata);
                Normalize(lpic->szIconText);
                break;

            case OT_EMBEDDED:
                RegGetClassId(lpic->szIconText, ARRAYSIZE(lpic->szIconText), lpdata);
                break;
            }

            GlobalUnlock(hdata);
        }
    }

    return lpic;
}



/* IconDelete() - Used to clear the appearance pane of icon stuff.
 */
VOID
IconDelete(
    LPIC lpic
    )
{
    HANDLE hdata;

    if (!lpic)
        return;

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    GlobalUnlock(hdata = lpic->hdata);
    GlobalFree(hdata);
}



/* IconDraw() - Used to draw the icon and its caption.
 */
VOID
IconDraw(
    LPIC lpic,
    HDC hdc,
    LPRECT lprc,
    BOOL fFocus,
    INT cxImage,
    INT cyImage
    )
{
    BOOL fMF;
    HFONT hfont = NULL;
    RECT rcText;
    DWORD dwLayout;

    hfont = SelectObject(hdc, ghfontTitle);
    if (!(fMF = (cxImage && cyImage)))
    {
        // Figure out how large the text region will be
        if (*(lpic->szIconText))
        {
            SetRect(&rcText, 0, 0, gcxArrange - 1, gcyArrange - 1);
            DrawText(hdc, lpic->szIconText, -1, &rcText,
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);
        }
        else
        {
            SetRect(&rcText, 0, 0, 0, 0);
        }

        // Figure out the image dimensions
        cxImage = (gcxIcon > rcText.right) ? gcxIcon : rcText.right;
        cyImage = gcyIcon + rcText.bottom;
    }

    // Draw the icon
    if (lpic->hDlgIcon)
    {
        // Do not mirror the Icon.
        dwLayout = GetLayout(hdc);
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL)) {
            SetLayout(hdc, dwLayout | LAYOUT_BITMAPORIENTATIONPRESERVED);
        }
        DrawIcon(hdc, (lprc->left + lprc->right - gcxIcon) / 2,
            (lprc->top + lprc->bottom - cyImage) / 2, lpic->hDlgIcon);
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL)) {
            SetLayout(hdc, dwLayout);
        }
    }

    // Draw the icon text
    if (*(lpic->szIconText))
    {
        if (fMF)
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextAlign(hdc, TA_CENTER);
            TextOut(hdc, cxImage / 2, gcyIcon + 1, lpic->szIconText,
                lstrlen(lpic->szIconText));
        }
        else
        {
            OffsetRect(&rcText, (lprc->left + lprc->right - cxImage) / 2,
                (lprc->top + lprc->bottom - cyImage) / 2 + gcyIcon);
            DrawText(hdc, lpic->szIconText, -1, &rcText,
                DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);
        }
    }

    if (hfont)
        SelectObject(hdc, hfont);

    if (fFocus && cxImage && cyImage)
    {
        RECT rcFocus;

        SetRect(&rcFocus, (lprc->left + lprc->right - cxImage) / 2, (lprc->top +
            lprc->bottom - cyImage) / 2, (lprc->left + lprc->right + cxImage) /
            2, (lprc->top + lprc->bottom + cyImage) / 2);
        DrawFocusRect(hdc, &rcFocus);
    }
}



/* IconReadFromNative() - Used to retrieve the icon object from memory.
 */
LPIC
IconReadFromNative(
    LPSTR *lplpstr
    )
{
    LPIC lpic;
    WORD w;

    if (lpic = IconCreate())
    {
        StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), *lplpstr);
        *lplpstr += lstrlen(lpic->szIconText) + 1;
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), *lplpstr);
        *lplpstr += lstrlen(lpic->szIconPath) + 1;
        MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
        lpic->iDlgIcon = (INT)w;
        GetCurrentIcon(lpic);
    }

    return lpic;
}



/* IconWriteToNative() - Used to write the icon object to memory.
 */
DWORD
IconWriteToNative(
    LPIC lpic,
    LPSTR *lplpstr
    )
{
    DWORD cBytes;
    WORD w;

    if (lplpstr)
    {
        // Now, write out the icon text and the icon
        cBytes = lstrlen(lpic->szIconText) + 1;
        MemWrite(lplpstr, (LPSTR)lpic->szIconText, cBytes);

        cBytes = lstrlen(lpic->szIconPath) + 1;
        MemWrite(lplpstr, (LPSTR)lpic->szIconPath, cBytes);
        w = (WORD)lpic->iDlgIcon;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
    }

    return (lstrlen(lpic->szIconText) + 1 + lstrlen(lpic->szIconPath) + 1 +
        sizeof(WORD));
}



VOID
GetCurrentIcon(
    LPIC lpic
    )
{
    WORD wIcon = (WORD)lpic->iDlgIcon;

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    if (!(lpic->hDlgIcon = ExtractAssociatedIcon(ghInst, lpic->szIconPath,
            &wIcon)))
        lpic->hDlgIcon = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));

}

//
//  get the nice name to show to the user given a filename
//
//  FEATURE: we realy should just call the shell!!!
//
void GetDisplayName(LPSTR szName, LPCSTR szPath)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    BOOL   IsLFN;

    StringCchCopy(szName, MAX_PATH, szPath);    // verified

    h = FindFirstFile(szPath, &fd);

    if (h != INVALID_HANDLE_VALUE)
    {
        FindClose(h);
        StringCchCopy(szName, MAX_PATH, fd.cFileName);

        IsLFN = !(fd.cAlternateFileName[0] == 0 ||
            lstrcmp(fd.cFileName, fd.cAlternateFileName) == 0);

        if (!IsLFN)
        {
            AnsiLower(szName);
            AnsiUpperBuff(szName, 1);
        }
    }
    else
    {
        Normalize(szName);          // strip path part
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\function.h ===
//
// cmdlink.c
//

VOID CmlActivate(LPCML lpcml);
LPCML CmlClone(LPCML lpcml);
LPCML CmlCreateWorker(LPSTR lpstrCmd, BOOL fCmdIsLink, BOOL fFilename);

#define CmlCreate(lpstrCmd, fCmdIsLink)     \
        CmlCreateWorker(lpstrCmd, fCmdIsLink, FALSE)

#define CmlCreateFromFilename(lpstrCmd, fCmdIsLink) \
        CmlCreateWorker(lpstrCmd, fCmdIsLink, TRUE)

VOID CmlDelete(LPCML lpcml);
VOID CmlDraw(LPCML lpcml, HDC hdc, LPRECT lprc, INT xHSB, BOOL fFocus);
VOID CmlFixBounds(LPCML lpcml);
LPCML CmlReadFromNative(LPSTR *lplpstr);
DWORD CmlWriteToNative(LPCML lpcml, LPSTR *lplpstr);


//
// dlgprocs.c
//

INT_PTR MyDialogBox(UINT idd, HWND hwndParent, DLGPROC lpfnDlgProc);
BOOL IconDialog(LPIC lpic);
BOOL ChangeCmdLine(LPCML lpcml);
VOID ChangeLabel(LPIC lpic);
INT_PTR CALLBACK fnChangeCmdText(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnProperties(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnChangeText(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnInvalidLink(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


//
// embed.c
//

BOOL EmbActivate(LPEMBED lpembed, UINT wVerb);
LPEMBED EmbCreate(LPSTR lpstrFile);
VOID EmbDelete(LPEMBED lpembed);
VOID EmbDraw(LPEMBED lpembed, HDC hdc, LPRECT lprc, BOOL fFocus);
LPEMBED EmbReadFromNative(LPSTR *lplpstr);
DWORD EmbWriteToNative(LPEMBED lpembed, LPSTR *lplpstr);
VOID EmbWriteToFile(LPEMBED lpembed, INT fh);
VOID EmbRead(LPEMBED lpembed);
BOOL EmbDoVerb(LPEMBED lpembed, UINT wVerb);
BOOL EmbActivateThroughOle(LPEMBED lpembed, LPSTR lpdocname, UINT wVerb);
INT CALLBACK EmbCallBack(LPOLECLIENT lpclient, OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject);
VOID EmbDeleteLinkObject(LPEMBED lpembed);


//
// filedlgs.c
//

VOID OfnInit(VOID);
BOOL OfnGetName(HWND hwnd, UINT msg);
HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData);
VOID Normalize(LPSTR lpstrFile);


//
// icon.c
//

LPIC IconClone(LPIC lpic);
LPIC IconCreateFromFile(LPSTR lpstrFile);
LPIC IconCreateFromObject(LPOLEOBJECT lpObject);
VOID IconDelete(LPIC lpic);
VOID IconDraw(LPIC lpic, HDC hdc, LPRECT lprc, BOOL fFocus, INT cxImage,
    INT cyImage);
LPIC IconReadFromNative(LPSTR *lplpstr);
DWORD IconWriteToNative(LPIC lpic, LPSTR *lplpstr);
VOID GetCurrentIcon(LPIC lpic);


//
// packager.c
//

LRESULT CALLBACK FrameWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID SetTitle(BOOL fRegistering);
VOID InitFile(VOID);
VOID ErrorMessage(UINT id);
BOOL ProcessMessage(VOID);
LPSTR Contains(LPSTR lpString, LPSTR lpPattern);
VOID Dirty(VOID);
VOID DeregisterDoc(VOID);
VOID Raise(INT iPane);
INT_PTR MessageBoxAfterBlock(HWND hwndParent, LPSTR lpText, LPSTR lpCaption,
    UINT fuStyle);
INT_PTR DialogBoxAfterBlock(LPCSTR lpTemplate, HWND hwndParent,
    DLGPROC lpDialogFunc);


//
// pane.c
//

BOOL InitPaneClasses(VOID);
BOOL InitPanes(VOID);
VOID EndPanes(VOID);
LRESULT CALLBACK SubtitleWndProc(HWND hWnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
LRESULT CALLBACK PaneWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SplitterFrame(HWND hWnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
VOID DeletePane(INT iPane, BOOL fDeleteUndo);
VOID DeletePaneObject(LPVOID lpobj, INT objType);


//
// picture.c
//

BOOL InitClient(VOID);
VOID EndClient(VOID);
LPPICT PicCreate(LPOLEOBJECT lpObject, LPRECT lprcObject);
VOID PicDelete(LPPICT lppict);
BOOL PicDraw(LPPICT lppict, HDC hDC, LPRECT lprc, INT xHSB, INT yVSB,
    BOOL fPicture, BOOL fFocus);
LPPICT PicPaste(BOOL fPaste, LPSTR lpstrName);
BOOL Error(OLESTATUS olestat);
INT CALLBACK CallBack(LPOLECLIENT lpclient, OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject);
VOID WaitForObject(LPOLEOBJECT lpObject);
BOOL PicSetUpdateOptions(LPPICT lppict, UINT idCmd);
LPPICT PicReadFromNative(LPSTR *lplpstr, LPSTR lpstrName);
DWORD PicWriteToNative(LPPICT lppict, LPOLEOBJECT lpObject, LPSTR *lplpstr);
VOID Hourglass(BOOL fOn);
VOID PicActivate(LPPICT lppict, UINT idCmd);
VOID PicUpdate(LPPICT lppict);
VOID PicFreeze(LPPICT lppict);
VOID PicChangeLink(LPPICT lppict);
BOOL PicCopy(LPPICT lppict);
VOID PicSaveUndo(LPPICT lppict);
LPPICT PicFromFile(BOOL fEmbedded, LPSTR szFile);

typedef int (__stdcall *PCALL_BACK)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
LPOLECLIENT PicCreateClient(PCALL_BACK fnCallBack, LPOLECLIENTVTBL lpclivtbl);


//
// register.c
//

VOID RegInit(VOID);
VOID RegGetClassId(LPSTR lpstrName, DWORD nameBufferSize, LPSTR lpstrClass);
INT RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, LPSTR lpstrFilterSpec);
VOID RegGetExeName(LPSTR lpstrExe, LPSTR lpstrClass, DWORD dwBytes);


//
// server.c
//

BOOL InitServer(VOID);
VOID DeleteServer(LPSAMPSRVR lpsrvr);
VOID DestroyServer(VOID);
LPSAMPDOC InitDoc(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lptitle);
VOID ChangeDocName(LPSAMPDOC *lplpdoc, LPSTR lpname);
BOOL SendDocChangeMsg(LPSAMPDOC lpdoc, UINT options);
LPSAMPDOC CreateNewDoc(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lpstr);
LPSAMPDOC CreateDocFromFile(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lpstr);
BOOL CopyObjects(VOID);
LPSAMPITEM CreateNewItem(LPSAMPDOC lpdoc);
HANDLE GetNative(BOOL fClip);
BOOL PutNative(HANDLE hdata);
HANDLE GetLink(VOID);
HANDLE GetMF(VOID);
VOID InitEmbedded(BOOL fCreate);
LPSAMPITEM AddItem(LPSAMPITEM lpitem);
BOOL DeleteItem(LPSAMPITEM lpitem);
VOID EndEmbedding(VOID);


//
// stream.c
//

VOID SetFile(STREAMOP sop, INT fh, LPSTR *lplpstr);
DWORD ReadStream(LPAPPSTREAM lpStream, LPSTR lpstr, DWORD cb);
DWORD PosStream(LPAPPSTREAM lpStream, LONG pos, INT iorigin);
DWORD WriteStream(LPAPPSTREAM lpStream, LPSTR lpstr, DWORD cb);
DWORD MemRead(LPSTR *lplpStream, LPSTR lpItem, DWORD dwSize);
DWORD MemWrite(LPSTR *lplpStream, LPSTR lpItem, DWORD dwSize);


//
// virtable.c
//

OLESTATUS SrvrOpen(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrCreate(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
    LPSTR lpclassname, LPSTR lpdocname, LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrCreateFromTemplate(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
    LPSTR lpclassname, LPSTR lpdocname, LPSTR lptemplatename,
    LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrEdit(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, LPSTR lpclassname,
    LPSTR lpdocname, LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrExit(LPOLESERVER lpolesrvr);
OLESTATUS SrvrRelease(LPOLESERVER lpolesrvr);
OLESTATUS SrvrExecute(LPOLESERVER lpolesrvr, HANDLE hCmds);

OLESTATUS DocSave(LPOLESERVERDOC lpoledoc);
OLESTATUS DocClose(LPOLESERVERDOC lpoledoc);
OLESTATUS DocRelease(LPOLESERVERDOC lpoledoc);
OLESTATUS DocGetObject(LPOLESERVERDOC lpoledoc, LPSTR lpitemname,
    LPOLEOBJECT *lplpoleobject, LPOLECLIENT lpoleclient);
OLESTATUS DocSetHostNames(LPOLESERVERDOC lpoledoc, LPSTR lpclientName,
    LPSTR lpdocName);
OLESTATUS DocSetDocDimensions(LPOLESERVERDOC lpoledoc, LPRECT lprc);
OLESTATUS DocSetColorScheme(LPOLESERVERDOC lpoledoc, LPLOGPALETTE lppal);
OLESTATUS DocExecute(LPOLESERVERDOC lpoledoc, HANDLE hCmds);

OLESTATUS ItemDelete(LPOLEOBJECT lpoleobject);
OLESTATUS ItemGetData(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat,
    LPHANDLE lphandle);
OLESTATUS ItemSetData(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat,
    HANDLE hdata);
OLESTATUS ItemDoVerb(LPOLEOBJECT lpoleobject, UINT wVerb, BOOL fShow,
    BOOL fActivate);
OLESTATUS ItemShow(LPOLEOBJECT lpoleobject, BOOL fActivate);
OLESTATUS ItemSetBounds(LPOLEOBJECT lpoleobject, LPRECT lprc);
OLESTATUS ItemSetTargetDevice(LPOLEOBJECT lpoleobject, HANDLE h);
OLECLIPFORMAT ItemEnumFormats(LPOLEOBJECT lpobject, OLECLIPFORMAT cfFormat);
LPVOID ItemQueryProtocol(LPOLEOBJECT lpoleobject, LPSTR lpprotocol);
OLESTATUS ItemSetColorScheme(LPOLEOBJECT lpoleobject, LPLOGPALETTE lppal);

BOOL IsOleServerDoc(LPSTR lpdocname);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\ids.h ===
/*
 * ids.h - Header file for OLE demo's resource file.
 */


/* Application resource ID */
#define ID_APPLICATION  1
#define SPLIT           2

/* File menu */
#define IDM_UPDATE      0x101
#define IDM_IMPORT      0x102
#define IDM_EXPORT      0x103
#define IDM_EXIT        0x104
#define IDM_NEW         0x106

/* Edit menu */
#define POS_EDITMENU    1
#define IDM_UNDO        0x200
#define IDM_CUT         0x201
#define IDM_COPY        0x202
#define IDM_PASTE       0x203
#define IDM_PASTELINK   0x204
#define IDM_CLEAR       0x206
#define IDM_LINKS       0x208
#define IDM_INSERTICON  0x209
#define IDM_LABEL       0x20a
#define IDM_COMMAND     0x20b
#define IDM_COPYPACKAGE 0x20d
#define IDM_PICT        0x20e
#define IDM_DESC        0x20f
#define IDM_NEXTWINDOW  0x210

/* Object popup menu */
#define POS_OBJECT      12      // position of Object item in Edit menu
#define IDM_OBJECT      0x220
#define IDM_VERBMIN     0x221
#define IDM_VERBMAX     0x230


/* Help menu */
#define IDM_INDEX       0x0280
#define IDM_SEARCH      0x0281
#define IDM_USINGHELP   0x0282
#define IDM_ABOUT       0x0283


#define IDM_LINKDONE    0x307


/* Pop up menu */
#define IDM_EMBEDFILE   0x2c0
#define IDM_LINKFILE    0x2c1

/* String table constants */
#define IDS_APPNAME         0x100
#define IDS_UNTITLED        0x101
#define IDS_MAYBESAVE       0x102
#define IDS_FILTER          0x106
#define IDS_CHANGELINK      0x108
#define IDS_ALLFILTER       0x109
#define IDS_CONTENT         0x10f
#define IDS_DESCRIPTION     0x110
#define IDS_PICTURE         0x111
#define IDS_APPEARANCE      0x112
#define IDS_INSERTICON      0x113
#define IDS_VIEW            0x114
#define IDS_LINKTOFILE      0x115
#define IDS_IMPORTFILE      0x116
#define IDS_EXPORTFILE      0x117
#define IDS_EMBEDFILE       0x118
#define IDS_MAYBEUPDATE     0x119
#define IDS_FROZEN          0x11a
#define IDS_OBJECT          0x11b
#define IDS_ASKCLOSETASK    0x120
#define IDS_OVERWRITE       0x121
#define IDS_PRIMARY_VERB    0x122
#define IDS_SECONDARY_VERB  0x123
#define IDS_FAILEDUPDATE    0x124
#define IDS_OBJECT_MENU     0x125
#define IDS_UNDO_MENU       0x126
#define IDS_CONTENT_OBJECT  0x127
#define IDS_APPEARANCE_OBJECT 0x128
#define IDS_GENERIC         0x129
#define IDS_EDIT            0x12a
#define IDS_EMBNAME_CONTENT 0x12b
#define IDS_INVALID_FILENAME 0x12c
#define IDS_POPUPVERBS        0x12d
#define IDS_SINGLEVERB        0x12e

/* Error messages */
#define E_FAILED_TO_READ_FILE           0x201
#define E_FAILED_TO_SAVE_FILE           0x202
#define E_FAILED_TO_READ_OBJECT         0x206
#define E_FAILED_TO_DELETE_OBJECT       0x207
#define E_CLIPBOARD_COPY_FAILED         0x209
#define E_GET_FROM_CLIPBOARD_FAILED     0x20a
#define E_FAILED_TO_CREATE_CHILD_WINDOW 0x20b
#define E_FAILED_TO_CREATE_OBJECT       0x20c
#define E_UNEXPECTED_RELEASE            0x20e
#define E_FAILED_TO_LAUNCH_SERVER       0x20f
#define E_FAILED_TO_UPDATE              0x210
#define E_FAILED_TO_FREEZE              0x211
#define E_FAILED_TO_UPDATE_LINK         0x212
#define E_FAILED_TO_REGISTER_SERVER     0x214
#define E_FAILED_TO_REGISTER_DOCUMENT   0x215
#define E_FAILED_TO_RECONNECT_OBJECT    0x217
#define E_FAILED_TO_EXECUTE_COMMAND     0x21a
#define E_FAILED_TO_FIND_ASSOCIATION    0x21b

#define W_STATIC_OBJECT                 0x301
#define W_FAILED_TO_CLONE_UNDO          0x302
#define W_FAILED_TO_NOTIFY              0x305

#define IDS_AUTO                        0x400
#define IDS_MANUAL                      0x401
#define IDS_CANCELED                    0x402

#define IDS_BROWSE                      0x500
#define IDS_CHNGICONPROGS               0x508
#define IDS_ACCESSDENIED                0x509
#define IDS_LOWMEM                      0x510
#define IDS_NOICONSTITLE                0x511
#define IDS_NOICONSMSG                  0x512
#define IDS_NOZEROSIZEFILES             0x513
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\packgr32.c ===
#if 0
    This is a completely empty C file that is here only to placate the
    BUILD program.
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\packager.h ===
/* packager.h - Constants, types, and exports from the main module.
 */

#include <windows.h>
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#endif

#ifdef STRICT
#   undef STRICT
#   define PACKGR_STRICT
#endif

#define SERVERONLY
#include <ole.h>

#ifdef PACKGR_STRICT
#   define STRICT
#   undef PACKGR_STRICT
#endif

#include "ids.h"


#define HIMETRIC_PER_INCH   2540    // Number of HIMETRIC units per inch
#define DEF_LOGPIXELSX      96      // Default values for pixels per
#define DEF_LOGPIXELSY      96      // logical inch

#define KEYNAMESIZE         300     // Maximum registration key length

#define CCLIENTNAMEMAX      50      // Maximum length of client app name
#define CBCMDLINKMAX        500
#define CBMESSAGEMAX        128
#define CBSTRINGMAX         256     // Maximum lenght of a string in the res.
#define CBSHORTSTRING       20
#define CBFILTERMAX         50      // Max # chars in a filter specification
#define CBPATHMAX           260     // Most chars in a fully qual. filename

#define CharCountOf(a)      (sizeof(a) / sizeof(a[0]))

#define CITEMSMAX           100

#define APPEARANCE          0
#define CONTENT             1
#define CCHILDREN           2       // Number of panes which precede

#define OLE_PLAY            0
#define OLE_EDIT            1

#define WM_FIXSCROLL        (WM_USER+100)
#define WM_REDRAW           (WM_USER+101)
#define WM_READEMBEDDED     (WM_USER+102)


#define CHAR_SPACE          TEXT(' ')
#define CHAR_QUOTE          TEXT('"')

#define SZ_QUOTE            TEXT("\"")

typedef enum
{
    NOTHING,
    CMDLINK,
    ICON,
    PEMBED,
    PICTURE
} PANETYPE;


typedef enum
{
    SOP_FILE,
    SOP_MEMORY
}
STREAMOP;


typedef struct _APPSTREAM
{
    LPOLESTREAMVTBL lpstbl;
    INT fh;
} APPSTREAM, *LPAPPSTREAM;


typedef struct _EMBED           // embed
{
    ATOM aFileName;
    ATOM aTempName;
    DWORD dwSize;
    HANDLE hContents;
    HANDLE hdata;
    HANDLE hTask;
    HANDLE hSvrInst;
    BOOL bOleSvrFile;
    LPOLECLIENT lpclient;       // At activation time we check whether the file
    LPOLEOBJECT lpLinkObj;      // is a OLE server file. If so, we will create
                                // a link to it, and activate it in OLE fashion
} EMBED, *LPEMBED;


typedef struct _CML             // cml
{
    HANDLE hdata;
    RECT rc;                    // HACK:  Same location as in PICT
    BOOL fCmdIsLink;
    CHAR szCommand[CBCMDLINKMAX];
} CML, *LPCML;


typedef struct _IC              // ic
{
    HANDLE hdata;
    HICON hDlgIcon;
    CHAR szIconPath[CBPATHMAX];
    CHAR szIconText[CBPATHMAX];
    INT iDlgIcon;
} IC, *LPIC;


typedef struct _PICT            // pict
{
    HANDLE hdata;
    RECT rc;                    // HACK:  Same location as in CML
    LPOLEOBJECT lpObject;
    BOOL fNotReady;             // TRUE if object creation is not complete
} PICT, *LPPICT;


typedef struct _SAMPSRVR        // srvr
{
    OLESERVER olesrvr;          // Server
    HANDLE hsrvr;               // Handle to server memory block
    LHSERVER lhsrvr;            // Registration handle
} PBSRVR, *LPSAMPSRVR;


typedef struct _SAMPDOC         // doc
{
    OLESERVERDOC oledoc;        // Document
    HANDLE hdoc;                // Handle to document memory block
    LHSERVERDOC lhdoc;          // Registration handle
    ATOM aName;                 // Document name atom
} PBDOC, *LPSAMPDOC;


typedef struct _SAMPITEM        // item
{
    OLEOBJECT oleobject;        // Object
    HANDLE hitem;               // Handle to item memory block
    LPOLECLIENT lpoleclient;
    INT ref;                    // # of references to document
    ATOM aName;                 // Item name atom
} ITEM, *LPSAMPITEM;


#include "globals.h"

#include "function.h"


#if DBG_PRNT
#define DPRINT(s)   OutputDebugString(TEXT(s) TEXT("\n"))
#else
#define DPRINT(s)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\register.c ===
/* register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"

TCHAR gszAppName[] = "packager.exe";

/* RegInit() - Prepare the registration database for calls.
 */
VOID
RegInit(
    VOID
    )
{
    CHAR sz[CBMESSAGEMAX];
    CHAR szVerb[CBMESSAGEMAX];
    DWORD dwBytes = CBMESSAGEMAX;
    static TCHAR szAppClassID[] = TEXT("{0003000C-0000-0000-C000-000000000046}");



    // If the server is not in the registration database, add it
    if (RegQueryValue(HKEY_CLASSES_ROOT, gszAppClassName, sz, &dwBytes))
    {
        HKEY hkey;

        if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hkey))
            return;

        // Add the server name string
        LoadString(ghInst, IDS_FILTER, sz, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, gszAppClassName, REG_SZ, sz,
            lstrlen(sz) + 1);

        // Add the server execute string  (don't forget the terminating zero
        // on "packgr32.exe")

        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\server");
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, gszAppName,
                (lstrlen(gszAppName) + 1));

        // Primary verb
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\verb\\0");
        LoadString(ghInst, IDS_PRIMARY_VERB, szVerb, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szVerb, sizeof(szVerb));

        // Secondary verb
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\verb\\1");
        LoadString(ghInst, IDS_SECONDARY_VERB, szVerb, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szVerb, sizeof(szVerb));

        // CLSID
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\CLSID");
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szAppClassID, sizeof(szAppClassID));
        RegCloseKey(hkey);
    }

    // If the CLSID is not in the registration database, add it
    dwBytes = CBMESSAGEMAX;

    StringCchCopy(sz, ARRAYSIZE(sz), "CLSID\\");
    StringCchCat(sz, ARRAYSIZE(sz), szAppClassID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, sz, szVerb, &dwBytes))
    {
        HKEY hkey;

        if (RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkey))
            return;

        // Add the CLSID name string
        RegSetValue(hkey, szAppClassID, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        // Add the OLE class
        StringCchCopy(sz, ARRAYSIZE(sz), szAppClassID);
        StringCchCat(sz, ARRAYSIZE(sz), "\\Ole1Class");
        RegSetValue(hkey, sz, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        // Add the prog id
        StringCchCopy(sz, ARRAYSIZE(sz), szAppClassID);
        StringCchCat(sz, ARRAYSIZE(sz), "\\ProgID");
        RegSetValue(hkey, sz, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        RegCloseKey(hkey);
    }
}



/* RegGetClassId() - Retrieves the string name of a class.
 *
 * Note:  Classes are guaranteed to be in ASCII, but should
 *        not be used directly as a rule because they might
 *        be meaningless if running non-English Windows.
 */
VOID
RegGetClassId(
    LPSTR lpstrName,
    DWORD nameBufferSize,
    LPSTR lpstrClass
    )
{
    DWORD dwSize = KEYNAMESIZE;
    CHAR szName[KEYNAMESIZE];

    if (!RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, szName, &dwSize))
    {
        StringCchCopy(lpstrName, nameBufferSize, szName);  // potential overrun fixed
    }
    else
        StringCchCopy(lpstrName, nameBufferSize, lpstrClass);
}



/* RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * This function returns a filter spec, to be used in the "Change Link"
 * standard dialog box, which contains all the default extensions which
 * are associated with the given class name.  Again, the class names are
 * guaranteed to be in ASCII.
 *
 * Returns:  The index nFilterIndex stating which filter item matches the
 *           extension, or 0 if none is found.
 */
INT
RegMakeFilterSpec(
    LPSTR lpstrClass,
    LPSTR lpstrExt,
    LPSTR lpstrFilterSpec
    )
{
    DWORD dwSize;
    CHAR szClass[KEYNAMESIZE];
    CHAR szName[KEYNAMESIZE];
    CHAR szString[KEYNAMESIZE];
    UINT i;
    INT idWhich = 0;
    INT idFilterIndex = 0;
    LPSTR pMaxStr = lpstrFilterSpec + 4 * MAX_PATH; // Per caller size

    for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE);)
    {
        dwSize = KEYNAMESIZE;
        if (*szName == '.'              /* Default Extension... */  /* ... so, get the class name */
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)
            /* ... and if the class name matches (null class is wildcard) */
            && (!lpstrClass || !lstrcmpi(lpstrClass, szClass)))
        {
            /* ... get the class name string */
            dwSize = KEYNAMESIZE;
            if(!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize))
            {
                idWhich++;      /* Which item of the combo box is it? */

                // If the extension matches, save the filter index
                if (lpstrExt && !lstrcmpi(lpstrExt, szName))
                    idFilterIndex = idWhich;

                //
                // Copy over "<Class Name String> (*<Default Extension>)"
                // e.g. "Server Picture (*.PIC)"
                //

                // because lpstrFilterSpec changes, we need to check all the concats now
                if(lpstrFilterSpec + 
                    (lstrlen(szString) + 
                    lstrlen(" (*") + 
                    lstrlen(szName) +
                    lstrlen(")") +
                    lstrlen("*") +
                    lstrlen(szName) +
                    1) >= pMaxStr)
                {
                    break;
                }

                lstrcpy(lpstrFilterSpec, szString);
                lstrcat(lpstrFilterSpec, " (*");
                lstrcat(lpstrFilterSpec, szName);
                lstrcat(lpstrFilterSpec, ")");
                lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;

                // Copy over "*<Default Extension>" (e.g. "*.PIC")
                lstrcpy(lpstrFilterSpec, "*");  
                lstrcat(lpstrFilterSpec, szName);
                lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
            }
        }
    }

    // Add another NULL at the end of the spec
    *lpstrFilterSpec = 0;

    return idFilterIndex;
}



VOID
RegGetExeName(
    LPSTR lpstrExe,
    LPSTR lpstrClass,
    DWORD dwBytes
    )
{
    // Add the server execute string
    CHAR szServer[KEYNAMESIZE];
    if(SUCCEEDED(StringCchCopy(szServer,  ARRAYSIZE(szServer), lpstrClass)))
    {
        if(SUCCEEDED(StringCchCat(szServer, ARRAYSIZE(szServer), "\\protocol\\StdFileEditing\\server")))
        {
            RegQueryValue(HKEY_CLASSES_ROOT, szServer, lpstrExe, &dwBytes);
        }
        else
        {
            *lpstrExe = 0;
        }
    }
    else
    {
        *lpstrClass = 0;
        *lpstrExe = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\stream.c ===
/* stream.c - OLE stream I/O routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"


static LPSTR *glplpstr;
static STREAMOP gsop;



/* SetFile() - Set the file to be written.
 */
VOID
SetFile(
    STREAMOP sop,
    INT fh,
    LPSTR *lplpstr
    )
{
    switch (gsop = sop)
    {
        case SOP_FILE:
            glpStream->fh = fh;
            break;

        case SOP_MEMORY:
            gcbObject = 0L;
            glplpstr = lplpstr;
            break;
    }
}



/* ReadStream() - Read bytes from memory, from a file, or just count them.
 */
DWORD
ReadStream(
    LPAPPSTREAM lpStream,
    LPSTR lpstr,
    DWORD cb
    )
{
    switch (gsop)
    {
        case SOP_FILE:
            return _lread(lpStream->fh, lpstr, cb);
            break;

        case SOP_MEMORY:
            gcbObject += cb;

            if (glplpstr)
                MemRead(glplpstr, lpstr, cb);

            break;
    }

    return cb;
}



/* PosStream() - Reset the position of the file pointer.
 *
 * Note:  This is never used; luckily, or it would mess up the count.
 */
DWORD
PosStream(
    LPAPPSTREAM lpStream,
    LONG pos,
    INT iorigin)
{
    return _llseek(lpStream->fh, pos, iorigin);
}



/* WriteStream() - Write bytes to memory, to a file, or just count them.
 */
DWORD
WriteStream(
    LPAPPSTREAM lpStream,
    LPSTR lpstr,
    DWORD cb
    )
{
    switch (gsop)
    {
        case SOP_FILE:
            return _lwrite(lpStream->fh, lpstr, cb);

        case SOP_MEMORY:
            gcbObject += cb;

            if (glplpstr)
                MemWrite(glplpstr, lpstr, cb);

            break;
    }

    return cb;
}



/********************* Memory read/write functions ********************/
/* MemRead() - Read bytes from the memory (stream).
 */
DWORD
MemRead(
    LPSTR *lplpStream,
    LPSTR lpItem,
    DWORD dwSize
    )
{
    DWORD cb;
    CHAR *hpDest = lpItem;
    CHAR *hpSrc = *lplpStream;

    for (cb = dwSize; cb; cb--)
        *hpDest++ = *hpSrc++;

    *lplpStream = hpSrc;

    return dwSize;
}



/* MemWrite() - Write bytes to the memory (stream).
 */
DWORD
MemWrite(
    LPSTR *lplpStream,
    LPSTR lpItem,
    DWORD dwSize
    )
{
    DWORD cb;
    CHAR *hpDest = *lplpStream;
    CHAR *hpSrc = lpItem;

    for (cb = dwSize; cb; cb--)
        *hpDest++ = *hpSrc++;

    *lplpStream = hpDest;

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\pane.c ===
/* pane.c - This file contains the multi-pane handling routines.
 *
 * Copyright (c) 1991-, Microsoft Corporation.
 * All rights reserved.
 */


#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"


//#define  OLESVR_SUPPORT           /* enable support for OLE server files */


#define DRAG_EMBED  2                   // Ctrl + Drag
#define DRAG_LINK   6                   // Ctrl + Shift + Drag


static HBRUSH hbrBlack;                 // Black brush
static HCURSOR hcurSplit;
static HWND hwndDesc;
static HWND hwndInsertIcon = NULL;
static HWND hwndView = NULL;
static INT cxBorder;                    // WS_BORDER border width
static INT cyBorder;
static INT cxFudge = 0;                 // Fudge factors for good appearance
static INT cyFudge = 0;
static INT cxMinWidth;
static INT cxView;
static INT cxSplit;                     // Splitter bar width
static INT cxPict;
static INT cxDesc;
static INT cxInsertIcon;
static INT cxMin[CCHILDREN];
static INT cyHeight;
static INT xSplit = 0;
static CHAR szButton[] = "button";
static CHAR szStatic[] = "static";
static CHAR szPaneClass[] = "PaneClass";
static CHAR szSubtitleClass[] = "SubTitleClass";
static CHAR szDescription[CBMESSAGEMAX];
static CHAR szView[CBMESSAGEMAX];
static CHAR szPicture[CBMESSAGEMAX];
static CHAR szInsertIcon[CBMESSAGEMAX];
static CHAR szDropFile[CBPATHMAX];
static BOOL fHScrollEnable = FALSE;
static BOOL fVScrollEnable = FALSE;


static BOOL MakeWindows(VOID);
static INT GetTextLen(HDC hdc, LPSTR lpstr);
static VOID RecalibrateScroll(INT iPane, DWORD lParam);
static VOID Undo(INT iPane);
static VOID CalcWindows(BOOL fFirst);
static INT Constrain(INT x, INT right);
static VOID CopyOther(VOID);


/* InitPaneClasses() - Do application "global" initialization.
 *
 * This function registers the window classes used by the application.
 * Returns:  TRUE if successful.
 */
BOOL
InitPaneClasses(
    VOID
    )
{
    WNDCLASS  wc;

    wc.style            = 0;
    wc.lpfnWndProc      = SubtitleWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInst;
    wc.hIcon            = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(ID_APPLICATION);
    wc.lpszClassName    = szSubtitleClass;

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style            = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc      = PaneWndProc;
    wc.cbClsExtra       = 0;
    // Reserve space for the item specific data handle
    wc.cbWndExtra       = sizeof(LPVOID);
    wc.hInstance        = ghInst;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szPaneClass;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/* InitPanes() - Handles the instance-specific initialization.
 *
 * This function creates the main application window.
 * Returns:  TRUE if successful.
 */
BOOL
InitPanes(
    VOID
    )
{
    LOGFONT lf;
    CHARSETINFO csinfo;
    LCID lcid = GetThreadLocale();
    DWORD dwCp = GetACP();

    hbrBlack = GetStockObject(BLACK_BRUSH);
    hcurSplit = LoadCursor(ghInst, MAKEINTRESOURCE(SPLIT));
    gcxIcon = GetSystemMetrics(SM_CXICON);
    gcyIcon = GetSystemMetrics(SM_CYICON);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, &gcxArrange, FALSE);
    SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, &gcyArrange, FALSE);

    // ANSI app needs to make sure it has the right charset for text rendering
    if (TranslateCharsetInfo(&dwCp, &csinfo, TCI_SRCCODEPAGE))
        lf.lfCharSet = (BYTE) csinfo.ciCharset;

    // Lock down font size to 8 point size since we won't adjust window size 
    lf.lfHeight = -MulDiv(8, giYppli, 72);
    lf.lfWidth = 0;

    ghfontTitle = CreateFontIndirect(&lf);
    if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE)
        lf.lfWeight = FW_NORMAL;
    else
        lf.lfWeight = FW_BOLD;
    ghfontChild = CreateFontIndirect(&lf);


    if (!(ghfontTitle || ghfontChild))
    {
        if (ghfontTitle)
            DeleteObject(ghfontTitle);

        return FALSE;
    }

    LoadString(ghInst, IDS_CONTENT, gszCaption[CONTENT], CBMESSAGEMAX);
    LoadString(ghInst, IDS_VIEW, szView, CBMESSAGEMAX);
    LoadString(ghInst, IDS_DESCRIPTION, szDescription, CBMESSAGEMAX);
    LoadString(ghInst, IDS_PICTURE, szPicture, CBMESSAGEMAX);
    LoadString(ghInst, IDS_APPEARANCE, gszCaption[APPEARANCE], CBMESSAGEMAX);
    LoadString(ghInst, IDS_INSERTICON, szInsertIcon, CBMESSAGEMAX);

    // Create the window panes
    if (!MakeWindows())
        return FALSE;

    CalcWindows(TRUE);

    // Give the focus to the content pane
    PostMessage(ghwndPane[CONTENT], WM_LBUTTONDOWN, 0, 0L);

    return TRUE;
}



/* EndPaneInstance() - Instance-specific termination code.
 */
VOID
EndPanes(
    VOID
    )
{
    if (ghfontTitle)
        DeleteObject(ghfontTitle);

    if (ghfontChild)
        DeleteObject(ghfontChild);
}



/* MakeWindows() - Make the window panes.
 */
static BOOL
MakeWindows(
    VOID
    )
{
    if (ghwndBar[CONTENT] =
        CreateWindow(szSubtitleClass, gszCaption[CONTENT], WS_CHILD | WS_VISIBLE,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL))
    {

        hwndView = CreateWindow(szStatic, szView,
            WS_CHILD | WS_VISIBLE | SS_LEFT | SS_CENTERIMAGE,
            0, 0, 0, 0, ghwndBar[CONTENT], NULL, ghInst, NULL);

        hwndDesc = CreateWindow(szButton, szDescription,
            WS_CHILD | BS_AUTORADIOBUTTON | WS_VISIBLE | WS_GROUP,
            0, 0, 0, 0, ghwndBar[CONTENT], (HMENU)IDM_DESC, ghInst, NULL);

        ghwndPict = CreateWindow(szButton, szPicture,
            WS_CHILD | BS_AUTORADIOBUTTON | WS_VISIBLE,
            0, 0, 0, 0, ghwndBar[CONTENT], (HMENU)IDM_PICT, ghInst, NULL);


        if (hwndView && hwndDesc && ghwndPict)
        {
            // Use the appropriate dialog font
            SendMessage(ghwndBar[CONTENT], WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(hwndView, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(hwndDesc, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(ghwndPict, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
            EnableWindow(ghwndPict, FALSE);
        }
        else
        {
            goto Error;
        }
    }
    else
    {
        goto Error;
    }

    if (ghwndBar[APPEARANCE] =
        CreateWindow(szSubtitleClass, gszCaption[APPEARANCE],
        WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL))
    {
        hwndInsertIcon =
            CreateWindow(szButton, szInsertIcon,
            WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE,
            0, 0, 0, 0, ghwndBar[APPEARANCE], (HMENU)IDM_INSERTICON,
            ghInst, NULL);

        if (hwndInsertIcon)
        {
            SendMessage(ghwndBar[APPEARANCE], WM_SETFONT, (WPARAM)ghfontChild,
                 TRUE);
            SendMessage(hwndInsertIcon, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
        }
        else
        {
            goto Error;
        }
    }
    else
    {
        goto Error;
    }

    ghwndPane[APPEARANCE] =
        CreateWindowEx(WS_EX_CLIENTEDGE, szPaneClass, NULL,
        WS_BORDER | WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL);

    ghwndPane[CONTENT] =
        CreateWindowEx(WS_EX_CLIENTEDGE, szPaneClass, NULL,
        WS_BORDER | WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL);

    if (!ghwndPane[APPEARANCE] || !ghwndPane[CONTENT])
        goto Error;

    EnableScrollBar(ghwndPane[APPEARANCE], SB_HORZ, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[APPEARANCE], SB_VERT, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[CONTENT], SB_HORZ, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[CONTENT], SB_VERT, ESB_DISABLE_BOTH);

    DragAcceptFiles(ghwndPane[CONTENT], TRUE);

    return TRUE;

Error:
    if (ghwndBar[CONTENT])
    {
        if (hwndView)
            DestroyWindow(hwndView);

        if (hwndDesc)
            DestroyWindow(hwndDesc);

        if (ghwndPict)
            DestroyWindow(ghwndPict);

        DestroyWindow(ghwndBar[CONTENT]);
    }

    if (ghwndBar[APPEARANCE])
    {
        if (hwndInsertIcon)
            DestroyWindow(hwndInsertIcon);

        DestroyWindow(ghwndBar[APPEARANCE]);
    }

    if (ghwndPane[APPEARANCE])
        DestroyWindow(ghwndPane[APPEARANCE]);

    if (ghwndPane[CONTENT])
        DestroyWindow(ghwndPane[CONTENT]);

    return FALSE;
}



/* SubtitleWndProc() - "Appearance" and "Content" bar window procedure.
 */
LRESULT CALLBACK
SubtitleWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    RECT rcCaption;
    INT iPane;

    iPane = (hWnd == ghwndBar[CONTENT]);

    switch (msg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDM_INSERTICON:
                    Raise(APPEARANCE);
                    DeletePane(APPEARANCE, FALSE);

                    if (gptyUndo[APPEARANCE] != ICON)
                        glpobj[APPEARANCE] = IconCreateFromFile("");
                    else
                        glpobj[APPEARANCE] = IconClone(glpobjUndo[APPEARANCE]);

                    if (glpobj[APPEARANCE])
                        gpty[APPEARANCE] = ICON;

                    if (glpobj[APPEARANCE] && IconDialog(glpobj[APPEARANCE]))
                    {
                        InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                        Dirty();
                    }
                    else
                    {
                        IconDelete(glpobj[APPEARANCE]);
                        gpty[APPEARANCE] = NOTHING;
                        glpobj[APPEARANCE] = NULL;
                        SendMessage(ghwndPane[APPEARANCE], WM_COMMAND,
                            IDM_UNDO, 0);
                    }

                    break;

                case IDM_DESC:
                    if (!IsDlgButtonChecked(ghwndBar[CONTENT], IDM_DESC))
                        CheckRadioButton(ghwndBar[CONTENT], IDM_PICT,
                            IDM_DESC, IDM_DESC);

                    if (fHScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_HORZ,
                            ESB_DISABLE_BOTH);

                    if (fVScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_VERT,
                            ESB_DISABLE_BOTH);

                    InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);

                    goto defProcess;

                case IDM_PICT:
                    if (!IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT)
                        && IsWindowEnabled(GetDlgItem(ghwndBar[CONTENT],
                        IDM_PICT)))
                        CheckRadioButton(ghwndBar[CONTENT], IDM_PICT,
                            IDM_DESC, IDM_PICT);

                    if (fHScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_HORZ,
                            ESB_ENABLE_BOTH);

                    if (fVScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_VERT,
                            ESB_ENABLE_BOTH);

                    InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                    // Fall through

                default:
defProcess:
                    if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
                    {
                        if (gbDBCS)
                        {
                            /* 4-Oct-93 #2701 v-katsuy */
                             //win31#1203: 12/26/92:fixing Focus Line Scroll
                             //delete Focus Rect on another pane
                            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                        }
                        BringWindowToTop(ghwndPane[iPane]);
                        InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                        InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                        if (LOWORD(wParam) == IDM_PICT
                            || LOWORD(wParam) == IDM_DESC)
                            UpdateWindow(ghwndPane[CONTENT]);
                    }
            }

            break;

        case WM_LBUTTONDOWN:
            if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
                SendMessage(ghwndPane[iPane], WM_LBUTTONDOWN, 0, 0);

            break;

        case WM_PAINT:
            {
                HFONT hfontOld;

                GetClientRect(hWnd, &rcCaption);
                BeginPaint(hWnd, &ps);

                if (GetTopWindow(ghwndFrame) == ghwndPane[iPane])
                {
                    SetTextColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    SetBkColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHT));
                }
                else
                {
                    SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
                    SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
                }

                hfontOld = SelectObject(ps.hdc, ghfontChild);
                rcCaption.left += cxFudge;
                DrawText(ps.hdc, gszCaption[iPane], -1, &rcCaption,
                    DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
                SelectObject(ps.hdc, hfontOld);

                EndPaint(hWnd, &ps);
            }

            break;

        case WM_SIZE:
            if (iPane == APPEARANCE)
            {
                if (hwndInsertIcon)
                {
                    GetClientRect(hWnd, &rcCaption);

                    SetWindowPos(hwndInsertIcon, 0,
                        rcCaption.right - cxInsertIcon, cyFudge, 0, 0,
                        SWP_NOSIZE | SWP_NOZORDER);

                    InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                }
            }
            else
            {
                if (hwndView)
                {
                    BOOL bChinese = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE;
                    GetClientRect(hWnd, &rcCaption);
                    SetWindowPos(hwndView, 0,
                                 bChinese ?
                                   rcCaption.right - cxDesc - cxPict - cxView - 15 :
                                   rcCaption.right - cxDesc - cxPict - cxView,
                                   0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

                    SetWindowPos(hwndDesc, 0,
                                 rcCaption.right - cxDesc - cxPict,
                                 cyFudge, 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);

                    SetWindowPos(ghwndPict, 0,
                                 rcCaption.right - cxPict,
                                 cyFudge, 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);

                    InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                }
            }

            break;

        default:
            return DefWindowProc(hWnd, msg, wParam, lParam);
    }

    return 0L;
}



static INT
GetTextLen(
    HDC hdc,
    LPSTR lpstr
    )
{
    SIZE Size;

    GetTextExtentPoint32(hdc, lpstr, lstrlen(lpstr), &Size);

    return Size.cx + (cxFudge * 2);
}



LRESULT CALLBACK
PaneWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fFocus;
    LPVOID lpobjTemp;
    PAINTSTRUCT ps;
    RECT rc;
    CHAR szFile[CBPATHMAX];
    INT iOld;
    INT iPane;
    INT iPos;
    INT Max;
    INT Min;
    INT nBar;

    iPane = (hwnd == ghwndPane[CONTENT]);

    switch (msg)
    {
        case WM_HSCROLL:
        case WM_VSCROLL:
            // If not the content pane in picture mode, break
            if (gpty[iPane] == PICTURE
                && iPane == CONTENT
                && !IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT))
                break;

            // Can't scroll anything but cmd line and picture
            if (gpty[iPane] != PICTURE && gpty[iPane] != CMDLINK)
                break;

            nBar = (msg == WM_HSCROLL ? SB_HORZ : SB_VERT);
            iOld = iPos = GetScrollPos(hwnd, nBar);

            switch (LOWORD(wParam))
            {
                case SB_LINEUP:
                    iPos--;
                    break;

                case SB_LINEDOWN:
                    iPos++;
                    break;

                case SB_PAGEUP:
                case SB_PAGEDOWN:
                    GetClientRect(hwnd, &rc);
                    if (LOWORD(wParam) == SB_PAGEUP)
                        iPos -= (rc.bottom - rc.top + 1);
                    else
                        iPos += (rc.bottom - rc.top + 1);

                    break;

                case SB_THUMBPOSITION:
                    iPos = (INT)HIWORD(wParam);
                    break;
            }

            // Make sure that iPos is in the range
            GetScrollRange(hwnd, nBar, &Min, &Max);

            if (iPos < Min)
                iPos = Min;
            if (iPos > Max)
                iPos = Max;

            SetScrollPos(hwnd, nBar, iPos, TRUE);

            if (msg == WM_HSCROLL)
                ScrollWindow(hwnd, iOld - iPos, 0, NULL, NULL);
            else
                ScrollWindow(hwnd, 0, iOld - iPos, NULL, NULL);

            UpdateWindow(hwnd);
            break;

        case WM_LBUTTONDOWN:
            if (GetTopWindow(ghwndFrame) != hwnd)
            {
                BringWindowToTop(hwnd);
                InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
            }

            break;

        case WM_PAINT:
            GetClientRect(hwnd, &rc);
            BeginPaint(hwnd, &ps);
            if (fFocus = (ghwndPane[iPane] == GetTopWindow(ghwndFrame)))
            {
                SetTextColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                SetBkColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHT));
            }
            else
            {
                SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
                SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
            }

            switch (gpty[iPane])
            {
                case CMDLINK:
                    CmlDraw(glpobj[iPane], ps.hdc, &rc,
                        GetScrollPos(hwnd, SB_HORZ), fFocus);
                    break;

                case PEMBED:
                    EmbDraw(glpobj[iPane], ps.hdc, &rc, fFocus);
                    break;

                case ICON:
                    IconDraw(glpobj[iPane], ps.hdc, &rc, fFocus, 0, 0);
                    break;

                case PICTURE:
                    PicDraw(glpobj[iPane], ps.hdc, &rc,
                        GetScrollPos(hwnd, SB_HORZ),
                        GetScrollPos(hwnd, SB_VERT),
                        hwnd == ghwndPane[APPEARANCE] ||
                        IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT), fFocus);
                    break;

                default:
                    FillRect(ps.hdc, &rc, ghbrBackground);
                    break;
            }

            EndPaint(hwnd, &ps);
            break;

        case WM_FIXSCROLL:
            GetClientRect(hwnd, &rc);
            lParam = ((DWORD)rc.bottom << 16) | (DWORD)rc.right;

            // Fall through

        case WM_SIZE:
            if (gpty[iPane] == PICTURE || gpty[iPane] == CMDLINK)
                RecalibrateScroll(iPane, (DWORD)lParam);

            break;

        case WM_DESTROY:
            DeletePane(iPane, TRUE);
            break;

        case WM_DROPFILES:
            {
                BYTE bKeyState = 0;

                // Retrieve the file name
                DragQueryFile((HANDLE)wParam, 0, szDropFile, CBPATHMAX);

                DragFinish((HANDLE)wParam);

                // We got dropped on, so bring ourselves to the top
                BringWindowToTop(ghwndFrame);
                BringWindowToTop(hwnd);

                // See what the user wants us to do
                bKeyState = ((GetKeyState(VK_SHIFT) < 0) << 2)
                    | ((GetKeyState(VK_CONTROL) < 0) << 1)
                    | ((GetKeyState(VK_MENU) < 0));

                switch (bKeyState)
                {
                    case DRAG_LINK:
                        PostMessage(hwnd, WM_COMMAND, IDM_LINKFILE, 0L);
                        break;

                    case DRAG_EMBED:
                    default:
                        PostMessage(hwnd, WM_COMMAND, IDM_EMBEDFILE, 0L);
                        break;
                }

                break;
            }

        case WM_LBUTTONDBLCLK:
            // Alt + Double Click = Properties
            if (gpty[iPane] == PICTURE && GetKeyState(VK_MENU) < 0)
            {
                wParam = IDM_LINKS;
            }
            else
            {
                if (gpty[iPane] == PEMBED)
                {
                    //
                    // If the server is a OLE server, we want to activate in
                    // OLE fashion. But from users perspective it should not
                    // look like an object. So for non-objects double-click
                    // implies show the server. We should try to do the same
                    // thing while editing ole server files.
                    //
                    wParam = IDD_EDIT;
                }
                else
                {
                    wParam  = IDD_PLAY;
                }
            }

            msg = WM_COMMAND;
            lParam = 0;

            // Fall through

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDM_COPY:
                case IDM_CUT:
                    switch (gpty[iPane])
                    {
                        case PICTURE:
                            PicCopy(glpobj[iPane]);

                        default:
                            if (iPane == APPEARANCE)
                                CopyOther();
                            break;
                    }

                    if (LOWORD(wParam) == IDM_COPY)
                        break;

                    // Fall through to delete the selection

                case IDM_CLEAR:
                    DeletePane(iPane, FALSE);
                    break;

                case IDM_LINKS:
                    {
                        LONG objtype;

                        OleQueryType(((LPPICT)glpobj[iPane])->lpObject, &objtype);
                        if (objtype == OT_LINK)
                            DialogBoxAfterBlock(MAKEINTRESOURCE(DTPROP),
                                ghwndPane[iPane], fnProperties);

                        break;
                    }
                case IDM_LINKFILE:
                    if(SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), szDropFile)))
                    {
                        wParam = IDM_PASTELINK;
                        goto CreateFromFile;
                    }
                 
                    break;

                case IDM_EMBEDFILE:
                    if(SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), szDropFile)))
                    {
                        wParam = IDM_PASTE;
                        goto CreateFromFile;
                    }
                    break;

                case IDM_PASTE:
                case IDM_PASTELINK:
                    // Try to paste a file name from the File Manager
                    if (iPane == CONTENT)
                    {
                        HANDLE hdata;
                        LPSTR lpstrFile;

                        if (IsClipboardFormatAvailable(gcfFileName))
                        {
                            if (!OpenClipboard(ghwndFrame))
                                break;

                            if (!(hdata = GetClipboardData(gcfFileName)) || !(lpstrFile =
                                GlobalLock(hdata)))
                            {
                                CloseClipboard();
                                break;
                            }

                            StringCchCopy(szFile, ARRAYSIZE(szFile), lpstrFile);
                            GlobalUnlock(hdata);
                            CloseClipboard();

CreateFromFile:

#ifdef OLESVR_SUPPORT
                            if (IsOleServerDoc (szFile))
                            {
                                lpobjTemp = PicFromFile((wParam == IDM_PASTE),
                                    szFile);
                                if (!lpobjTemp)
                                {
                                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                                    break;
                                }

                                goto StuffNewObject;
                            }
                            else
                            {
#endif
                                DeletePane(CONTENT, FALSE);
                                if (wParam == IDM_PASTE)
                                {
                                    if (glpobj[CONTENT] = EmbCreate(szFile))
                                        gpty[CONTENT] = PEMBED;
                                }
                                else
                                {
                                    if (glpobj[CONTENT] =
                                           CmlCreateFromFilename(szFile, TRUE))
                                        gpty[CONTENT] = CMDLINK;
                                }
#ifdef OLESVR_SUPPORT
                            }
#endif
                            InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                            Dirty();

                            if (!gpty[APPEARANCE])
                            {
                                if (glpobj[APPEARANCE] =
                                    IconCreateFromFile(szFile))
                                {
                                    gpty[APPEARANCE] = ICON;
                                    InvalidateRect(ghwndPane[APPEARANCE],
                                        NULL, TRUE);
                                }
                            }

                            break;
                        }
                    }

                    // Not a file name, try to paste an OLE object
                    if (!(lpobjTemp = PicPaste(LOWORD(wParam) == IDM_PASTE,
                                                gszCaption[iPane])))
                    {
                        ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                        break;
                    }
#ifdef OLESVR_SUPPORT

StuffNewObject:

#endif
                    DeletePane(iPane, FALSE);
                    glpobj[iPane] = lpobjTemp;
                    gpty[iPane] = PICTURE;
                    SendMessage(ghwndPane[iPane], WM_FIXSCROLL, 0, 0L);
                    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
                    Dirty();

                    if (iPane == CONTENT)
                    {
                        EnableWindow(ghwndPict, TRUE);

                        if (!gpty[APPEARANCE])
                        {
                            if (glpobj[APPEARANCE] = IconCreateFromObject(
                                ((LPPICT)glpobj[iPane])->lpObject))
                            {
                                gpty[APPEARANCE] = ICON;
                                InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                            }
                        }
                    }

                    Dirty();
                    break;

                case IDD_EDIT:          /* Edit the icon form */
                case IDD_PLAY:
                    switch (gpty[iPane])
                    {
                        case CMDLINK:
                            CmlActivate(glpobj[iPane]);
                            break;

                        case PEMBED:
                            EmbActivate(glpobj[iPane], LOWORD(wParam));
                            break;

                        case PICTURE:
                            PicActivate(glpobj[iPane], LOWORD(wParam));
                            break;

                        default:
                            break;
                    }

                    break;

                case IDD_UPDATE:        /* Update the (link) object */
                    if (gpty[iPane] == PICTURE)
                        PicUpdate(glpobj[iPane]);

                    break;

                case IDD_FREEZE:        /* Make the object static */
                    if (gpty[iPane] == PICTURE)
                        PicFreeze(glpobj[iPane]);

                    break;

                case IDD_CHANGE:
                    if (gpty[iPane] == PICTURE)
                        PicChangeLink(glpobj[iPane]);

                    break;

                case IDM_UNDO:
                    Undo(iPane);
                    break;

                case IDD_AUTO:          /* Change the (link) update options */
                case IDD_MANUAL:
                    if (gpty[iPane] == PICTURE
                        && !PicSetUpdateOptions(glpobj[iPane], LOWORD(wParam)))
                        break;

                case IDM_LINKDONE:      /* The link update has completed */
                    PostMessage(ghwndError, WM_REDRAW, 0, 0L);
                    break;

                default:
                    break;
            }

            break;

        default:
            return (DefWindowProc(hwnd, msg, wParam, lParam));
    }

    return 0;
}



LRESULT CALLBACK
SplitterFrame(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT rc;

    switch (msg)
    {
        case WM_SIZE:
            if (wParam != SIZEICONIC && ghwndBar[APPEARANCE])
            {
                GetClientRect(hWnd, &rc);

                // Make sure the splitter bar is still valid
                xSplit = Constrain(xSplit, rc.right);
                CalcWindows(FALSE);

                // Invalidate the splitter bar, forcing a repaint
                rc.left = xSplit - cxSplit / 2 - cxBorder;
                rc.right = xSplit + cxSplit / 2 + cxBorder;
                InvalidateRect(hWnd, &rc, TRUE);
            }

            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rcBlack;

                BeginPaint(hWnd, &ps);
                GetClientRect(hWnd, &rc);

                SetRect(&rcBlack, xSplit - cxSplit / 2 - cxBorder,
                    rc.top, xSplit + cxSplit / 2 + cxBorder,
                    rc.top + cyHeight + cyBorder);
                FillRect(ps.hdc, &rcBlack, hbrBlack);

                SetRect(&rcBlack, xSplit - cxSplit / 2 - cxBorder,
                    rc.bottom - GetSystemMetrics(SM_CYHSCROLL) + 1,
                    xSplit + cxSplit / 2 + cxBorder,
                    rc.bottom);
                FillRect(ps.hdc, &rcBlack, hbrBlack);

                EndPaint(hWnd, &ps);
                break;
            }

        case WM_GETMINMAXINFO:
            {
                LPPOINT rgpt = (LPPOINT)lParam;

                rgpt[3].x = cxMinWidth;
                rgpt[3].y = cyHeight * 6;
                break;
            }

        case WM_LBUTTONDOWN:
            {
                MSG msg1;
                INT x;
                INT y;
                INT dy;
                HDC hdc;
                HCURSOR hcurOld;

                if (IsIconic(hWnd))
                    break;

                x  = LOWORD(lParam);
                GetClientRect(hWnd, &rc);
                y  = 0;
                dy = rc.bottom;

                // Constrain the splitter bar...
                x = Constrain(x, rc.right);
                hdc = GetDC(hWnd);

                // split bar loop
                PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy, PATINVERT);
                SetCapture(hWnd);
                hcurOld = SetCursor(hcurSplit);

                while (GetMessage(&msg1, NULL, 0, 0))
                {
                    if (msg1.message >= WM_MOUSEFIRST
                        && msg1.message <= WM_MOUSELAST)
                    {
                        if (msg1.message == WM_LBUTTONUP
                            || msg1.message == WM_LBUTTONDOWN)
                            break;

                        if (msg1.message == WM_MOUSEMOVE)
                        {
                            ScreenToClient(hWnd, &msg1.pt);
                            x = Constrain(x, rc.right);

                            // erase old
                            PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy,
                                PATINVERT);

                            // put down new
                            x = Constrain(msg1.pt.x, rc.right);
                            PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy,
                                PATINVERT);
                        }
                    }
                    else
                    {
                        DispatchMessage(&msg1);
                    }
                }

                SetCursor(hcurOld);
                ReleaseCapture();

                // Constrain the splitter bar...
                x = Constrain(x, rc.right);

                // erase old
                PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy, PATINVERT);

                ReleaseDC(hWnd, hdc);

                if (msg1.wParam != VK_ESCAPE)
                {
                    xSplit = x;
                    CalcWindows(FALSE);
                    InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                    InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                }

                break;
            }

        default:
            return FALSE;
    }

    return TRUE;
}



VOID
DeletePane(
    INT iPane,
    BOOL fDeleteUndo
    )
{
    // Delete the last Undo object
    if (glpobjUndo[iPane])
        DeletePaneObject(glpobjUndo[iPane], gptyUndo[iPane]);

    // If we don't wish to keep an undo, delete the object too!
    if (fDeleteUndo)
    {
        DeletePaneObject(glpobj[iPane], gpty[iPane]);
        gptyUndo[iPane] = NOTHING;
        glpobjUndo[iPane] = NULL;
    }
    else
    {
        gptyUndo[iPane] = gpty[iPane];
        glpobjUndo[iPane] = glpobj[iPane];
    }

    // Handle the buttons and such
    if (gpty[iPane] == PICTURE || gpty[iPane] == CMDLINK)
    {
        CHAR szUndoName[CBMESSAGEMAX];

        EnableScrollBar(ghwndPane[iPane], SB_HORZ, ESB_DISABLE_BOTH);
        EnableScrollBar(ghwndPane[iPane], SB_VERT, ESB_DISABLE_BOTH);

        if (gpty[iPane] == PICTURE)
        {
            if (iPane == CONTENT)
            {
                CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
                EnableWindow(ghwndPict, FALSE);
            }

            // If the Undo object isn't deleted already, rename it
            if (!fDeleteUndo)
            {
                if(SUCCEEDED(StringCchPrintf(szUndoName, ARRAYSIZE(szUndoName), szUndo, gszCaption[iPane])))
                {
                    OleRename(((LPPICT)glpobjUndo[iPane])->lpObject, szUndoName);
                }
            }
        }
    }

    glpobj[iPane] = NULL;
    gpty[iPane]   = NOTHING;

    if (IsWindow(ghwndPane[iPane]))
        InvalidateRect(ghwndPane[iPane], NULL, TRUE);
}



static VOID
RecalibrateScroll(
    INT iPane,
    DWORD lParam
    )
{
    INT cxDel;
    INT cyDel;
    BOOL bDesc = FALSE;
    LPPICT lppict = (LPPICT)glpobj[iPane];

    // Compute the amount of scrolling possible
    cxDel = lppict->rc.right - lppict->rc.left - (INT)(lParam & 0xffff);
    cyDel = lppict->rc.bottom - lppict->rc.top - (INT)(lParam >> 16);

    // Normalize the scroll bar lengths
    if (cxDel < 0)
        cxDel = 0;

    if (cyDel < 0)
        cyDel = 0;

    if (iPane == CONTENT)
    {
        bDesc = IsDlgButtonChecked(ghwndBar[iPane], IDM_DESC);
        fHScrollEnable = cxDel;
        fVScrollEnable = cyDel;
    }

    EnableScrollBar(ghwndPane[iPane], SB_HORZ,
        (cxDel && !bDesc) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

    EnableScrollBar(ghwndPane[iPane], SB_VERT,
        (cyDel && !bDesc) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

    // Ensure that the thumb is at a meaningful position
    if (GetScrollPos(ghwndPane[iPane], SB_HORZ) > cxDel)
        SetScrollPos(ghwndPane[iPane], SB_HORZ, cxDel, TRUE);

    if (GetScrollPos(ghwndPane[iPane], SB_VERT) > cyDel)
        SetScrollPos(ghwndPane[iPane], SB_VERT, cyDel, TRUE);
}



static VOID
Undo(
    INT iPane
    )
{
    DWORD ot;
    LPPICT lppict;
    LPVOID lpobjTemp;
    INT ptyTemp;

    if (gpty[iPane] == PICTURE)
    {
        lppict = glpobj[iPane];

        // Close the old object
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);
            if (ot != OT_STATIC)
                Error(OleClose(lppict->lpObject));
        }

        OleRename(lppict->lpObject, gszTemp);
    }

    if (gptyUndo[iPane] == PICTURE)
    {
        lppict = glpobjUndo[iPane];

        // Try to reconnect the new object if it's a link
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);
            if (ot == OT_LINK && Error(OleReconnect(lppict->lpObject)))
                ErrorMessage(E_FAILED_TO_RECONNECT_OBJECT);
        }

        OleRename(lppict->lpObject, gszCaption[iPane]);
    }

    if (gpty[iPane] == PICTURE)
    {
        CHAR szUndoName[CBMESSAGEMAX];

        lppict = glpobj[iPane];
        if(SUCCEEDED(StringCchPrintf(szUndoName, ARRAYSIZE(szUndoName), szUndo, gszCaption[iPane])))
        {
            OleRename(lppict->lpObject, szUndoName);
        }
    }

    // Handle the buttons and enable/disable scroll bars

    // Going from picture to non-picture, disable all special things
    if (gptyUndo[iPane] != PICTURE && gpty[iPane] == PICTURE)
    {
        if (iPane == CONTENT)
        {
            CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
            EnableWindow(ghwndPict, FALSE);
        }

        EnableScrollBar(ghwndPane[iPane], SB_HORZ, ESB_DISABLE_BOTH);
        EnableScrollBar(ghwndPane[iPane], SB_VERT, ESB_DISABLE_BOTH);
    }

    if (gptyUndo[iPane] == PICTURE || gptyUndo[iPane] == CMDLINK)
    {
        SendMessage(ghwndPane[iPane], WM_FIXSCROLL, 0, 0L);

        if (gptyUndo[iPane] == PICTURE)
        {
            // Going from non-picture to picture, enable button
            if (gpty[iPane] != PICTURE && iPane == CONTENT)
                EnableWindow(ghwndPict, TRUE);
        }
    }

    lpobjTemp = glpobj[iPane];
    glpobj[iPane] = glpobjUndo[iPane];
    glpobjUndo[iPane] = lpobjTemp;

    ptyTemp = gpty[iPane];
    gpty[iPane] = gptyUndo[iPane];
    gptyUndo[iPane] = ptyTemp;

    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
    Dirty();
}



static VOID
CalcWindows(
    BOOL fFirst
    )
{
    if (fFirst)
    {
        // Figure out the length of the text strings, and all dimensions
        HDC hdc = GetWindowDC(ghwndFrame);
        if (hdc)
        {
            cxBorder = GetSystemMetrics(SM_CXBORDER);
            cyBorder = GetSystemMetrics(SM_CYBORDER);
            cxFudge = cxBorder * 2;
            cyFudge = cyBorder * 2;
            cxSplit = cxBorder * 4;

            if (gbDBCS)
            {
                /* #3963 13-Dec-93 v-katsuy */
                /* ORIGINALBUG! Window width calculated for just "&Picture".
                 *  This width should be calculate
                 *  [Radiobutton] + [Text](not include '&').
                 */
                CHAR  szTemp[CBMESSAGEMAX];
                LPSTR lpText, lpTemp;

                for (lpText = szPicture, lpTemp = szTemp; *lpText; ) {
                    if (*lpText == '&')
                        lpText++;
                    else
                        *lpTemp++ = *lpText++;
                }
                *lpTemp = 0;
                cxPict = GetTextLen(hdc, szTemp) + cxFudge * 2
                       + GetSystemMetrics(SM_CXSIZE); // for radiobutton 

                for (lpText = szDescription, lpTemp = szTemp; *lpText; ) {
                    if (*lpText == '&')
                        lpText++;
                    else
                        *lpTemp++ = *lpText++;
                }
                *lpTemp = 0;
                cxDesc = GetTextLen(hdc, szTemp)
                       + GetSystemMetrics(SM_CXSIZE); // for radiobutton
            }
            else
            {
                cxPict = GetTextLen(hdc, szPicture) + cxFudge * 2;
                cxDesc = GetTextLen(hdc, szDescription);
            }

            cxView = GetTextLen(hdc, szView);
            cxInsertIcon = GetTextLen(hdc, szInsertIcon) + cxFudge;

            cxMin[CONTENT] = cxPict + cxDesc + cxView +
                GetTextLen(hdc, gszCaption[CONTENT]) + cxFudge;
            cxMin[APPEARANCE] = cxInsertIcon +
                GetTextLen(hdc, gszCaption[APPEARANCE]) + cxFudge;
            cyHeight = GetSystemMetrics(SM_CYMENU) + cyFudge * 2;
            ReleaseDC(ghwndFrame, hdc);

            cxMinWidth = cxMin[APPEARANCE] + cxMin[CONTENT] + cxSplit +
                GetSystemMetrics(SM_CXFRAME) + cxFudge;

            // Compute all the window sizes that we can
            SetWindowPos(ghwndFrame, 0, 0, 0,
                cxMinWidth + cxFudge * 20,
                cxMinWidth * 7 / 18,
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndInsertIcon, 0, 0, 0,
                cxInsertIcon - cxFudge,
                GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndView, 0, 0, 0,
                cxView, cyHeight - cyFudge,
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(ghwndPict, 0, 0, 0,
                (cxPict - cxFudge) << 1,
                GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndDesc, 0, 0, 0,
                cxDesc, GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
        }
    }
    else
    {
        RECT rc;

        GetClientRect(ghwndFrame, &rc);

        // Move the windows to the appropriate locations
        SetWindowPos(ghwndBar[APPEARANCE], 0, 0, 0,
            xSplit - cxSplit / 2 - cxBorder, cyHeight, SWP_NOZORDER);

        SetWindowPos(ghwndBar[CONTENT], 0,
            xSplit + cxSplit / 2 + cxBorder,
            0,
            rc.right - (xSplit + cxSplit / 2) + 1 - cxBorder,
            cyHeight,
            SWP_NOZORDER);

        SetWindowPos(ghwndPane[APPEARANCE], 0,
            -cxBorder,
            cyHeight,
            cxBorder + xSplit - cxSplit / 2,
            rc.bottom + cyBorder - cyHeight,
            SWP_NOZORDER);

        SetWindowPos(ghwndPane[CONTENT], 0,
            xSplit + cxSplit / 2,
            cyHeight,
            cxBorder + rc.right - (xSplit + cxSplit / 2) + 1,
            rc.bottom + cyBorder - cyHeight,
            SWP_NOZORDER);
    }
}



static INT
Constrain(
    INT x,
    INT right
    )
{
    // Constrain the splitter bar...
    if (x < cxMin[APPEARANCE] + cxSplit / 2 - 1)
        return cxMin[APPEARANCE] + cxSplit / 2 - 1;
    else if (x > (right - cxMin[CONTENT] - cxSplit / 2 + 1))
        return right - cxMin[CONTENT] - cxSplit / 2 + 1;

    return x;
}



/* CopyOther() - Copies the picture in appearance pane
 *
 * Returns:  none
 */
static VOID
CopyOther(
    VOID
    )
{
    HANDLE hdata;

    if (OpenClipboard(ghwndFrame))
    {
        Hourglass(TRUE);
        EmptyClipboard();

        if (hdata = GetMF())
            SetClipboardData(CF_METAFILEPICT, hdata);

        CloseClipboard();
        Hourglass(FALSE);
    }
}



VOID
DeletePaneObject(
    LPVOID lpobj,
    INT objType
    )
{
    switch (objType)
    {
        case CMDLINK:
            CmlDelete(lpobj);
            break;

        case PEMBED:
            EmbDelete(lpobj);
            break;

        case ICON:
            IconDelete(lpobj);
            break;

        case PICTURE:
            PicDelete(lpobj);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\server.c ===
/* server.c - This module contains the OLE server worker/public routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"


#define CBLINKMAX           260


/*
 * This server only supports one document per instance.  The items are
 * just rectangles over the document, possibly overlapping.
 */

static LHCLIENTDOC lhClipDoc = 0;
static OLESERVERDOCVTBL vdocvtbl;           // Document virtual table
static OLEOBJECTVTBL vitemvtbl;             // Item virtual table
static OLESERVERVTBL vsrvrvtbl;             // Server virtual table
static LPSAMPITEM vlpitem[CITEMSMAX];       // Pointers to active OLE items
static INT cItems = 0;                      // Number of active OLE items
static CHAR szClip[] = "Clipboard";


static VOID DeleteDoc(LPSAMPDOC lpdoc);
static BOOL SendItemChangeMsg(LPSAMPITEM lpitem, UINT options);
static INT FindItem(LPSAMPITEM lpitem);



/************ Server initialization and termination routines **********/
/* InitServer() - Initializes the OLE server
 */
BOOL
InitServer(
    VOID
    )
{
    // Allocate the server block
    if (!(ghServer = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(PBSRVR)))
        || !(glpsrvr = (LPSAMPSRVR)LocalLock(ghServer)))
        goto errRtn;

    // Initialize the server, document, and item virtual tables
    vsrvrvtbl.Open                  = SrvrOpen;
    vsrvrvtbl.Create                = SrvrCreate;
    vsrvrvtbl.CreateFromTemplate    = SrvrCreateFromTemplate;
    vsrvrvtbl.Edit                  = SrvrEdit;
    vsrvrvtbl.Exit                  = SrvrExit;
    vsrvrvtbl.Release               = SrvrRelease;
    vsrvrvtbl.Execute               = SrvrExecute;

    vdocvtbl.Save                   = DocSave;
    vdocvtbl.Close                  = DocClose;
    vdocvtbl.SetHostNames           = DocSetHostNames;
    vdocvtbl.SetDocDimensions       = DocSetDocDimensions;
    vdocvtbl.GetObject              = DocGetObject;
    vdocvtbl.Release                = DocRelease;
    vdocvtbl.SetColorScheme         = DocSetColorScheme;
    vdocvtbl.Execute                = DocExecute;

    vitemvtbl.QueryProtocol         = ItemQueryProtocol;
    vitemvtbl.Release               = ItemDelete;
    vitemvtbl.Show                  = ItemShow;
    vitemvtbl.DoVerb                = ItemDoVerb;
    vitemvtbl.GetData               = ItemGetData;
    vitemvtbl.SetData               = ItemSetData;
    vitemvtbl.SetTargetDevice       = ItemSetTargetDevice;
    vitemvtbl.SetBounds             = ItemSetBounds;
    vitemvtbl.EnumFormats           = ItemEnumFormats;
    vitemvtbl.SetColorScheme        = ItemSetColorScheme;


    // Try to register the server
    glpsrvr->olesrvr.lpvtbl = &vsrvrvtbl;
    if (Error(OleRegisterServer(gszAppClassName, (LPOLESERVER)glpsrvr,
        (LONG_PTR * )&glpsrvr->lhsrvr, ghInst, OLE_SERVER_MULTI)))
        goto errRtn;

    // Initialize the client name
    lstrcpy(gszClientName, "");

    return TRUE;

errRtn:
    ErrorMessage(E_FAILED_TO_REGISTER_SERVER);

    // If we failed, clean up
    if (glpsrvr)
    {
        LocalUnlock(ghServer);
        glpsrvr = NULL;
    }

    if (ghServer)
        LocalFree(ghServer);

    ghServer = NULL;

    return FALSE;
}



/* DeleteServer() - Revokes the OLE server.
 */
VOID
DeleteServer(
    LPSAMPSRVR lpsrvr
    )
{
    if (gfServer)
    {
        gfServer = FALSE;
        OleRevokeServer(lpsrvr->lhsrvr);
    }
}



/* DestroyServer() - Deallocates the OLE server.
 */
VOID
DestroyServer(
    VOID
    )
{
    if (ghServer)
    {
        // Release the server virtual table and info
        LocalUnlock(ghServer);
        LocalFree(ghServer);
        ghServer = NULL;

        // Destroy the window only when we're all through
        DestroyWindow(ghwndFrame);
        gfServer = FALSE;
    }
}



/********************* Document support functions ********************/
/* InitDoc() - Initialize and register the document with the OLE library.
 */
LPSAMPDOC
InitDoc(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lptitle
    )
{
    HANDLE hdoc = NULL;
    LPSAMPDOC lpdoc = NULL;

    if (!(hdoc = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(PBDOC)))
        || !(lpdoc = (LPSAMPDOC)LocalLock(hdoc)))
        goto errRtn;

    lpdoc->hdoc = hdoc;
    lpdoc->aName = GlobalAddAtom(lptitle);
    lpdoc->oledoc.lpvtbl = &vdocvtbl;

    if (!lhdoc)
    {
        if (Error(OleRegisterServerDoc(lpsrvr->lhsrvr, lptitle,
            (LPOLESERVERDOC)lpdoc, (LHSERVERDOC * ) & lpdoc->lhdoc)))
            goto errRtn;
    }
    else
    {
        lpdoc->lhdoc = lhdoc;
    }

    gfDocExists  = TRUE;
    gfDocCleared = FALSE;
    return lpdoc;

errRtn:
    ErrorMessage(E_FAILED_TO_REGISTER_DOCUMENT);

    // Clean up
    if (lpdoc)
        LocalUnlock(hdoc);

    if (hdoc)
        LocalFree(hdoc);

    return NULL;
}



/* DeleteDoc() - Notify the OLE library that the document is to be deleted.
 */
static VOID
DeleteDoc(
    LPSAMPDOC lpdoc
    )
{
    if (gfOleClosed)
        SendDocChangeMsg(lpdoc, OLE_CLOSED);

    OleRevokeServerDoc(lpdoc->lhdoc);
}



/* ChangeDocName() - Notify the OLE library that the document name is changing.
 */
VOID
ChangeDocName(
    LPSAMPDOC *lplpdoc,
    LPSTR lpname
    )
{
    // If the document exists, delete and re-register.
    if (*lplpdoc)
    {
        GlobalDeleteAtom((*lplpdoc)->aName);
        (*lplpdoc)->aName = GlobalAddAtom(lpname);

        //
        // If the document contains items, just notify the children.
        // If we aren't embedded, always delete and re-register.
        //
        OleRenameServerDoc((*lplpdoc)->lhdoc, lpname);
        if (gfEmbedded && cItems)
            return;

        DeleteDoc(*lplpdoc);
    }

    *lplpdoc = InitDoc(glpsrvr, 0, lpname);
}



/* SendDocChangeMsg() - Notify the client that the document has changed.
 */
BOOL
SendDocChangeMsg(
    LPSAMPDOC lpdoc,
    UINT options
    )
{
    BOOL fSuccess = FALSE;
    INT i;

    for (i = 0; i < cItems; i++)
    {
        if (SendItemChangeMsg(vlpitem[i], options))
            fSuccess = TRUE;
    }

    return fSuccess;
}



/* CreateNewDoc() - Called when a document is newly created.
 *
 * Returns: hDocument if document successfully created, NULL otherwise.
 * Note:    This function is only called when the document is being
 *          created through OLE actions.
 */
LPSAMPDOC
CreateNewDoc(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpstr
    )
{
    glpdoc = InitDoc(lpsrvr, lhdoc, lpstr);
    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpstr); 
    SetTitle(TRUE);

    return glpdoc;
}



/* CreateDocFromFile() - Called when a document is to be created from a file.
 *
 * Returns: hDocument if document successfully created, NULL otherwise.
 * Note:    This function is only called when the document is being
 *          created through OLE actions.  The file name is temporarily
 *          set to load the file, then it is reset to "".  This is so
 *          that we won't save back to the template if we exit.
 */
LPSAMPDOC
CreateDocFromFile(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpstr
    )
{
    // Initialize document
    if (!(glpdoc = InitDoc(lpsrvr, lhdoc, lpstr)) || !(*lpstr))
        return NULL;

    lstrcpy(szUntitled, lpstr); // This could overrun, but I don't see how I can check the length of the lpstr coming in
    SetTitle(TRUE);

    return glpdoc;
}



/********************** Item support functions ************************/
/* CopyObjects() - Copies selection to the clipboard.
 */
BOOL
CopyObjects(
    VOID
    )
{
    HANDLE hdata;

    // If we can't open the clipboard, fail
    if (!OpenClipboard(ghwndFrame))
        return FALSE;

    Hourglass(TRUE);

    // Empty the clipboard
    EmptyClipboard();

    //
    // Copy the clipboard contents.
    //
    // Start with Native Data - which will just contain all the objects
    // which intersect with the selection rectangle.
    //
    if (hdata = GetNative(TRUE))
    {
        SetClipboardData(gcfNative, hdata);
        OleSavedClientDoc(lhClipDoc);
    }

    if (lhClipDoc)
    {
        OleRevokeClientDoc(lhClipDoc);
    lhClipDoc = 0;
    }

    if (hdata = GetLink())
        SetClipboardData(gcfOwnerLink, hdata);

    //
    // Metafile data:  Re-invert the image before putting
    // it onto the clipboard.
    //
    if (hdata = GetMF())
        SetClipboardData(CF_METAFILEPICT, hdata);

    CloseClipboard();
    Hourglass(FALSE);

    return TRUE;
}



/* CreateNewItem() - Allocate a new item.
 *
 * Note:    lpitem->rc will be filled out by the caller.
 */
LPSAMPITEM
CreateNewItem(
    LPSAMPDOC lpdoc
    )
{
    HANDLE hitem = NULL;
    LPSAMPITEM lpitem = NULL;

    // Now create the item
    if (!(hitem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(ITEM)))
        || !(lpitem = (LPSAMPITEM)GlobalLock(hitem)))
        goto errRtn;

    lpitem->hitem = hitem;
    lpitem->oleobject.lpvtbl = &vitemvtbl;
    return lpitem;

errRtn:
    if (lpitem)
        GlobalUnlock(hitem);

    if (hitem)
        GlobalFree(hitem);

    return NULL;
}



/* SendItemChangeMsg() - Notify the client that the item has changed.
 */
static BOOL
SendItemChangeMsg(
    LPSAMPITEM lpitem,
    UINT options
    )
{
    if (lpitem->lpoleclient)
    {
        (*lpitem->lpoleclient->lpvtbl->CallBack)
            (lpitem->lpoleclient, options, (LPOLEOBJECT)lpitem);

        return TRUE;
    }

    return FALSE;
}



/******************** Data reading/writing functions *********************/
/* GetNative(fClip) - Write the item native format to a memory block.
 *
 * This function will just write the objects which intersect
 * with the selection rectangle into a memory block.  If we
 * are running as an embedded instance, return ALL items, even
 * those which are not in the selection area.  Then we will
 * never lose objects that we move out of the selection area
 * when editing an embedded object.
 *
 * Args: fClip - TRUE means native data is for copying to clipboard
 *
 * Returns: A handle containing the native format, or NULL.
 */
HANDLE
GetNative(
    BOOL fClip
    )
{
    BOOL fSuccess = FALSE;
    DWORD cBytes = 0L;
    HANDLE hdata = NULL;
    LPSTR lpdata = NULL;
    DWORD cEmbWrite;
    LPOLEOBJECT lpobjapp = NULL;
    LPOLEOBJECT lpobjcon = NULL;
    LPPICT lpcPict;
    LPPICT lpaPict;
    WORD w;

    // Compute the size of the appearance
    lpaPict = glpobj[APPEARANCE];
    lpcPict = glpobj[CONTENT];

    switch (gpty[APPEARANCE])
    {
        case ICON:
            cBytes += IconWriteToNative(glpobj[APPEARANCE], NULL);
            break;

        case PICTURE:
            if (fClip)
            {
                if (Error(OleRegisterClientDoc(
                    gszAppClassName, szClip, 0L, &lhClipDoc)))
                    goto Error;

                if (Error(OleClone(
                    lpaPict->lpObject, glpclient, lhClipDoc,
                    szAppearance, &lpobjapp)))
                    goto Error;

                cBytes += PicWriteToNative(lpaPict, lpobjapp, NULL);
            }
            else
            {
                cBytes += PicWriteToNative(lpaPict, lpaPict->lpObject, NULL);
            }

            break;

        default:
            break;
    }

    // Compute the content size
    switch (gpty[CONTENT])
    {
        case CMDLINK:
            cBytes += CmlWriteToNative(glpobj[CONTENT], NULL);
            break;

        case PEMBED:    /* EmbWrite returns -1L if the user cancels */
            cEmbWrite = EmbWriteToNative(glpobj[CONTENT], NULL);

            if (cEmbWrite == (DWORD) - 1L)
                return FALSE;

            cBytes += cEmbWrite;
            break;

        case PICTURE:
            if (fClip)
            {
                if (!lhClipDoc && (Error(OleRegisterClientDoc(
                    gszAppClassName, szClip, 0L, &lhClipDoc))))
                    goto Error;

                if (Error(OleClone(lpcPict->lpObject, glpclient,
                    lhClipDoc, szContent, &lpobjcon)))
                    goto Error;

                cBytes += PicWriteToNative(lpcPict, lpobjcon, NULL);
            }
            else
            {
                cBytes += PicWriteToNative(lpcPict, lpcPict->lpObject, NULL);
            }

            break;

        default:
            break;
    }

    if (cBytes == 0L) // then no data
        goto Error;

    cBytes += (DWORD)(2 * sizeof(WORD));

    // Allocate a memory block for the data
    if (!(hdata = GlobalAlloc(GMEM_ZEROINIT, cBytes)) ||
        !(lpdata = (LPSTR)GlobalLock(hdata)))
        goto Error;

    // Write out the appearance
    w = (WORD)gpty[APPEARANCE];
    MemWrite(&lpdata, (LPSTR)&w, sizeof(WORD));
    switch (gpty[APPEARANCE])
    {
        case ICON:
            IconWriteToNative(glpobj[APPEARANCE], &lpdata);
            break;

        case PICTURE:
            if (fClip)
                PicWriteToNative(lpaPict, lpobjapp, &lpdata);
            else
                PicWriteToNative(lpaPict, lpaPict->lpObject, &lpdata);

            break;

        default:
            break;
    }

    // Write out the content
    w = (WORD)gpty[CONTENT];
    MemWrite(&lpdata, (LPSTR)&w, sizeof(WORD));

    switch (gpty[CONTENT])
    {
        case CMDLINK:
            CmlWriteToNative(glpobj[CONTENT], &lpdata);
            break;

        case PEMBED:
            EmbWriteToNative(glpobj[CONTENT], &lpdata);
            break;

        case PICTURE:
            if (fClip)
                PicWriteToNative(lpcPict, lpobjcon, &lpdata);
            else
                PicWriteToNative(lpcPict, lpcPict->lpObject, &lpdata);

            break;

        default:
            break;
    }

    fSuccess = TRUE;

Error:
    if (lpobjcon)
        OleRelease (lpobjcon);

    if (lpobjapp)
        OleRelease (lpobjapp);

    if (lpdata)
        GlobalUnlock(hdata);

    if (!fSuccess && hdata)
    {
        GlobalFree(hdata);
        hdata = NULL;
    }

    return hdata;
}



/* PutNative() - Read the item native data from a selector.
 *
 * Reads as many objects as it can, in upwards order (better error recovery).
 * Note:  It may be worthwhile to scale the object(s) to the window here.
 *
 * Returns: TRUE iff successful.
 */
BOOL
PutNative(
    HANDLE hdata
    )
{
    BOOL fSuccess = FALSE;
    LPSTR lpdata;
    WORD w;

    if (!(lpdata = (LPSTR)GlobalLock(hdata)))
        goto Error;

    // Delete any previous panes
    DeletePane(APPEARANCE, TRUE);
    DeletePane(CONTENT, TRUE);

    // Read in the appearance
    MemRead(&lpdata, (LPSTR)&w, sizeof(WORD));
    gpty[APPEARANCE] = w;
    switch (gpty[APPEARANCE])
    {
        case ICON:
            if (!(glpobj[APPEARANCE] = IconReadFromNative(&lpdata)))
                gpty[APPEARANCE] = NOTHING;

            break;

        case PICTURE:
            if (glpobj[APPEARANCE] =
                PicReadFromNative(&lpdata, gszCaption[APPEARANCE]))
            {
                SendMessage(ghwndPane[APPEARANCE], WM_FIXSCROLL, 0, 0L);
                break;
            }

        default:
            gpty[APPEARANCE] = NOTHING;
            break;
    }

    // Read the content
    MemRead(&lpdata, (LPSTR)&w, sizeof(WORD));
    gpty[CONTENT] = w;
    switch (gpty[CONTENT])
    {
        case CMDLINK:
            if (!(glpobj[CONTENT] = CmlReadFromNative(&lpdata)))
                gpty[CONTENT] = NOTHING;

            break;

        case PEMBED:
            if (!(glpobj[CONTENT] = (LPVOID)EmbReadFromNative(&lpdata)))
                gpty[CONTENT] = NOTHING;

            break;

        case PICTURE:
            if (glpobj[CONTENT] =
                (LPVOID)PicReadFromNative(&lpdata, gszCaption[CONTENT]))
            {
                SendMessage(ghwndPane[CONTENT], WM_FIXSCROLL, 0, 0L);
                EnableWindow(ghwndPict, TRUE);
                break;
            }

        default:
            gpty[CONTENT] = NOTHING;
            break;
    }

    fSuccess = TRUE;
    InvalidateRect(ghwndFrame, NULL, TRUE);

Error:
    if (lpdata)
        GlobalUnlock(hdata);

    return fSuccess;
}



/* GetLink() - Retrieves ObjectLink/OwnerLink information.
 *
 * This function returns a string describing the selected area.
 */
HANDLE
GetLink(
    VOID
    )
{
    CHAR pchlink[CBLINKMAX];
    INT cblink;
    HANDLE hlink;
    LPSTR lplink;

    // Link data - <App name>\0<Doc name>\0<Item name>\0\0
    StringCchCopy((LPSTR)pchlink, ARRAYSIZE(pchlink), gszAppClassName);   // ok const
    cblink = lstrlen((LPSTR)pchlink) + 1;

    // Copy the file name
    StringCchCopy((LPSTR)(pchlink + cblink), ARRAYSIZE(pchlink) - cblink, szDummy);    // szDummy size = 20
    cblink += lstrlen((LPSTR)(pchlink + cblink)) + 1;

    // Copy the item name
    StringCchCopy((LPSTR)(pchlink + cblink), ARRAYSIZE(pchlink) - cblink, szDummy);
    cblink += lstrlen((LPSTR)(pchlink + cblink)) + 1;
    pchlink[cblink++] = 0;       /* throw in another NULL at the end */

    // Allocate a memory block for the data
    if (!(hlink = GlobalAlloc(GMEM_ZEROINIT, cblink)) ||
        !(lplink = (LPSTR)GlobalLock(hlink)))
        goto Error;

    // Copy the data, then return the memory block
    MemWrite(&lplink, (LPSTR)pchlink, cblink);
    GlobalUnlock(hlink);
    return hlink;

Error:
    if (hlink)
        GlobalFree(hlink);

    return NULL;
}



/* GetMF() - Retrieve a metafile of the selected area.
 *
 * Note:    Originally, tried to Blt directly from the Window DC.  This
 *          doesn't work very well because when the window is obscured,
 *          the obscured portion shows up when the link is updated.
 */
HANDLE
GetMF(
    VOID
    )
{
    BOOL fError = TRUE;
    HANDLE hdata = NULL;
    HDC hdcMF = NULL;
    HDC hdcWnd = NULL;
    HFONT hfont;
    HANDLE hmfpict;
    LPMETAFILEPICT lpmfpict;
    LPIC lpic;
    LPPICT lppict;
    RECT rcTemp;
    RECT rcText;
    INT cxImage;
    INT cyImage;

    hmfpict = GlobalAlloc(GMEM_ZEROINIT, sizeof(METAFILEPICT));
    if (!hmfpict)
        goto Error;

    lpmfpict = (LPMETAFILEPICT)GlobalLock(hmfpict);

    // If the picture has a metafile, use it!
    if (gpty[APPEARANCE] == PICTURE)
    {
        LPMETAFILEPICT  lpmfpictOrg = NULL;

        if (Error(OleGetData(
            ((LPPICT)glpobj[APPEARANCE])->lpObject, CF_METAFILEPICT, &hdata))
            || !hdata
            || !(lpmfpictOrg = (LPMETAFILEPICT)GlobalLock(hdata)))
            goto NoPicture;

        // Copy the metafile
        lpmfpict->hMF = CopyMetaFile(lpmfpictOrg->hMF, NULL);
        GlobalUnlock(hdata);

        // If we failed, just draw it
        if (!lpmfpict->hMF)
            goto NoPicture;

        // Finish filling in the metafile header
        lpmfpict->mm   = lpmfpictOrg->mm;
        lpmfpict->xExt = lpmfpictOrg->xExt;
        lpmfpict->yExt = lpmfpictOrg->yExt;

        GlobalUnlock(hmfpict);
        return hmfpict;
    }

NoPicture:
    // Get the window DC, and make a DC compatible to it.
    if (!(hdcWnd = GetDC(NULL)))
        goto Error;

    switch (gpty[APPEARANCE])
    {
        case ICON:
            lpic = (LPIC)glpobj[APPEARANCE];

            // Set the icon text rectangle, and the icon font
            SetRect(&rcText, 0, 0, gcxArrange, gcyArrange);
            hfont = SelectObject(hdcWnd, ghfontTitle);

            // Figure out how large the text region will be
            // since this is going in a metafile we will not wrap
            // the icon text

            DrawText(hdcWnd, lpic->szIconText, -1, &rcText,
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

            if (hfont)
                SelectObject(hdcWnd, hfont);

            // Compute the image size
            rcText.right++;
            cxImage = (rcText.right > gcxIcon) ? rcText.right : gcxIcon;
            cyImage = gcyIcon + rcText.bottom + 1;
            break;

        case PICTURE:
            lppict  = (LPPICT)glpobj[APPEARANCE];
            cxImage = lppict->rc.right - lppict->rc.left + 1;
            cyImage = lppict->rc.bottom - lppict->rc.top + 1;
            break;

        default:
            cxImage = GetSystemMetrics(SM_CXICON);
            cyImage = GetSystemMetrics(SM_CYICON);
            break;
    }

    cxImage += cxImage / 4; // grow the image a bit

    cyImage += cyImage / 8;

    // Create the metafile
    if (!(hdcMF = CreateMetaFile(NULL)))
        goto Error;

    // Initialize the metafile
    SetWindowOrgEx(hdcMF, 0, 0, NULL);
    SetWindowExtEx(hdcMF, cxImage - 1, cyImage - 1, NULL);

    //
    // Fill in the background
    //
    // We displace back to (0, 0) because that's where the BITMAP resides.
    //
    SetRect(&rcTemp, 0, 0, cxImage, cyImage);
    switch (gpty[APPEARANCE])
    {
        case ICON:
            IconDraw(glpobj[APPEARANCE], hdcMF, &rcTemp, FALSE, cxImage, cyImage);
            break;

        case PICTURE:
            PicDraw(glpobj[APPEARANCE], hdcMF, &rcTemp, 0, 0, TRUE, FALSE);
            break;

        default:
            DrawIcon(hdcMF, 0, 0, LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION)));
            break;
    }

    // Map to device independent coordinates
    rcTemp.right =
        MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, giXppli);
    rcTemp.bottom =
        MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, giYppli);

    // Finish filling in the metafile header
    lpmfpict->mm = MM_ANISOTROPIC;
    lpmfpict->xExt = rcTemp.right;
    lpmfpict->yExt = rcTemp.bottom;
    lpmfpict->hMF = CloseMetaFile(hdcMF);

    fError = FALSE;

Error:
    if (hdcWnd)
        ReleaseDC(NULL, hdcWnd);

    // If we had an error, return NULL
    if (fError && hmfpict)
    {
        GlobalUnlock(hmfpict);
        GlobalFree(hmfpict);
        hmfpict = NULL;
    }

    return hmfpict;
}



/* InitEmbedded() - Perform operations specific to editing embedded objects.
 *
 * This routine changes the menu items as appropriate.
 */
VOID
InitEmbedded(
    BOOL fCreate
    )
{
    HMENU hmenu;

    if (hmenu = GetMenu(ghwndFrame))
        EnableMenuItem(hmenu, IDM_UPDATE, fCreate ? MF_GRAYED : MF_ENABLED);

    gfEmbedded = TRUE;
}



/***************** Item circular queue/utility functions *****************/
/* AddItem() - Add an item to the global item list.
 */
LPSAMPITEM
AddItem(
    LPSAMPITEM lpitem
    )
{
    INT i;
    HANDLE hitem;

    i = FindItem((LPSAMPITEM)lpitem);
    if (i < cItems)
    {
        vlpitem[i]->ref++;

        // Free the duplicate item
        GlobalUnlock(hitem = lpitem->hitem);
        GlobalFree(hitem);
    }
    else
    {
        if (i < CITEMSMAX)
        {
            vlpitem[cItems] = (LPSAMPITEM)lpitem;
            vlpitem[cItems++]->ref = 1;
        }
        else
        {
            return NULL;
        }
    }

    return vlpitem[i];
}



/* DeleteItem() - Delete an item from the global item list.
 *
 * Returns: TRUE iff successful.
 */
BOOL
DeleteItem(
    LPSAMPITEM lpitem
    )
{
    BOOL fFound;
    HANDLE hitem;
    INT i;

    i = FindItem(lpitem);

    if ((fFound = (i < cItems && vlpitem[i]->ref))
        && !(--vlpitem[i]->ref))
    {
        // Free the item
        GlobalUnlock(hitem = vlpitem[i]->hitem);
        GlobalFree(hitem);

        // Shift everything else down
        cItems--;
        for ( ; i < cItems; i++)
            vlpitem[i] = vlpitem[i + 1];
    }

    return fFound;
}



/* FindItem() - Locate an item in the global item list.
 */
static INT
FindItem(
    LPSAMPITEM lpitem
    )
{
    BOOL fFound = FALSE;
    INT i;

    for (i = 0; i < cItems && !fFound;)
    {
        if (lpitem->aName == vlpitem[i]->aName)
        {
            fFound = TRUE;
        }
        else
        {
            i++;
        }
    }

    return i;
}



/* EndEmbedding() - Return to normal editing.
 *
 * This routine changes the menu items as appropriate.
 */
VOID
EndEmbedding(
    VOID
    )
{
    HMENU hmenu;

    // Fix the "Untitled" string
    LoadString(ghInst, IDS_UNTITLED, szUntitled, CBMESSAGEMAX);

    if (hmenu = GetMenu(ghwndFrame))
        EnableMenuItem(hmenu, IDM_UPDATE, MF_GRAYED);

    gfEmbedded = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\packager.c ===
/* packager.c - OLE object wrapping application
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"
#include <htmlhelp.h>

#define MenuFlag(b)    ((b) ? MF_ENABLED : MF_GRAYED)

/* 4-Oct-93 #2695 v-katsuy */
                         // win31#2174: 12/26/92 : fixing frame window initial position
/* The width of the Packager Frame window is nearly equal to 640.
   This value must be changed, when the design will be changed.
*/
#define JPFRAMEWIDTH 640

// Pointer to function RegisterPenApp()
VOID (CALLBACK *RegPen)(WORD, BOOL) = NULL;


static BOOL gfDirty = FALSE;                // TRUE if file needs to be written
static CHAR szEmbedding[] = "-Embedding";   // Not NLS specific
static CHAR szEmbedding2[] = "/Embedding";  // Not NLS specific
static CHAR szFrameClass[] = "AppClass";    // Not NLS specific
static CHAR szObjectMenu[CBSHORTSTRING];    // "&Object" menu string
static CHAR szEdit[CBSHORTSTRING];          // "Edit" string
static CHAR szHelpFile[] = "PACKAGER.CHM";  // packager.chm

static BOOL InitApplication(VOID);
static BOOL InitInstance(VOID);
static VOID EndInstance(VOID);
static VOID SaveAsNeeded(VOID);
static BOOL WriteToFile(VOID);
static BOOL ReadFromFile(LPSTR lpstrFile);
static OLESTATUS ProcessCmdLine(LPSTR lpCmdLine, INT nCmdShow);
static VOID WaitForAllObjects(VOID);
static VOID UpdateMenu(HMENU hmenu);
static VOID UpdateObjectMenuItem(HMENU hMenu);
static VOID ExecuteVerb(INT iVerb);
INT_PTR CALLBACK fnFailedUpdate(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
static VOID SendOleClosed(VOID);
static VOID CreateUntitled(VOID);
static VOID MakePenAware(VOID);
static VOID MakePenUnaware(VOID);
static VOID MakeMenuString(CHAR *szCtrl, CHAR *szMenuStr, CHAR *szVerb,
    CHAR *szClass, CHAR *szObject);


BOOL gbDBCS = FALSE;                 // TRUE if we're running in DBCS mode


/* WinMain() - Main Windows routine
 */
INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    INT nCmdShow
    )
{
    MSG msg;
    LCID lcid;

//DebugBreak(); 
    // Store the application instance number
    ghInst = hInstance;

    // Check DBCSness
    lcid = GetThreadLocale();

    gbDBCS = ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
               (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
               (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE)
              );


    // Initialize application global information (window classes)
    if (!hPrevInstance)
    {
        if (!InitApplication())
            return FALSE;
    }

    // Initialize instance-specific information
    if (!InitInstance() || !InitClient())
        goto errRtn;

    if (!(gfServer = InitServer()))
        goto errRtn;

    MakePenAware();

    if (ProcessCmdLine(lpCmdLine, nCmdShow) != OLE_OK)
    {
        DeleteServer(glpsrvr);
        goto errRtn;
    }

    // if blocking happened in SrvrOpen(), then wait for object to be created
    if (gfBlocked)
        WaitForObject(((LPPICT)(glpobj[CONTENT]))->lpObject);

    // Main message loop
    while (TRUE)
    {
        if (gfBlocked && glpsrvr)
        {
            BOOL bMore = TRUE;
            LHSERVER lhsrvr = glpsrvr->lhsrvr;

            gfBlocked = FALSE;
            while (bMore)
            {
                if (OleUnblockServer (lhsrvr, &bMore) != OLE_OK)
                    break;

                if (gfBlocked)
                    break;
            }
        }

        if (!GetMessage(&msg, NULL, 0, 0))
            break;

        if (!TranslateAccelerator(ghwndFrame, ghAccTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        //
        // to support activation of file based object though Ole mechanism
        // we create a linked object out of file and then activate it. But
        // we don't get any notification when server closes the document.
        // Using the following mechanism we find it out and then grab the
        // contents from file
        //
        if (gfEmbObjectOpen)
        {
            LPEMBED lpembed = (LPEMBED)(glpobj[CONTENT]);

            if (lpembed != NULL && OleQueryOpen(lpembed->lpLinkObj) != OLE_OK)
            {
                gfEmbObjectOpen = FALSE;
                EmbRead(lpembed);
                EmbDeleteLinkObject(lpembed);

                if (gfInvisible)
                    PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
            }
        }
    }

    goto cleanup;

errRtn:
    if (ghwndFrame)
        DestroyWindow(ghwndFrame);

cleanup:

    EndClient();
    MakePenUnaware();
    EndInstance();

    return FALSE;
}



/* InitApplication() - Do application "global" initialization.
 *
 * This function registers the window classes used by the application.
 * Returns:  TRUE iff successful.
 */
static BOOL
InitApplication(
    VOID
    )
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = FrameWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghInst;
    wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    wc.hCursor = LoadCursor(ghInst, MAKEINTRESOURCE(SPLIT));
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName = MAKEINTRESOURCE(ID_APPLICATION);
    wc.lpszClassName = szFrameClass;

    if (!RegisterClass(&wc))
        return FALSE;

    return InitPaneClasses();
}



/* InitInstance() - Handles the instance-specific initialization.
 *
 * This function creates the main application window.
 * Returns:  TRUE iff successful.
 */
static BOOL
InitInstance(
    VOID
    )
{
    HDC hDC;

    ghAccTable = LoadAccelerators(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    ghbrBackground = GetSysColorBrush(COLOR_APPWORKSPACE);
    ghcurWait = LoadCursor(NULL, IDC_WAIT);

    // Load the string resources
    LoadString(ghInst, IDS_APPNAME, szAppName, CBMESSAGEMAX);
    LoadString(ghInst, IDS_UNTITLED, szUntitled, CBMESSAGEMAX);

    // Create the Main Window

    if (gbDBCS)
    {
        /* 4-Oct-93 #2695 v-katsuy */
        // win31#2174: 12/26/92 : fixing frame window initial position
        if (!(ghwndError = ghwndFrame =
            CreateWindow(szFrameClass, szAppName,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
            | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
            CW_USEDEFAULT, CW_USEDEFAULT,
                // Following values are calculated when the window size is changed.
                // Default posiotion of a window is desided here, so dumy values
                // must be set here.
                JPFRAMEWIDTH, JPFRAMEWIDTH  * 7 / 18,
            NULL, NULL, ghInst, NULL)))
            return FALSE;
    }
    else
    {
        if (!(ghwndError = ghwndFrame =
            CreateWindow(szFrameClass, szAppName,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
            | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, ghInst, NULL)))
            return FALSE;
    }


    // Initialize the registration database
    RegInit();

    // Set the correct caption string
    OfnInit();
    glpobj[CONTENT] = glpobj[APPEARANCE] = NULL;
    glpobjUndo[CONTENT] = glpobjUndo[APPEARANCE] = NULL;

    LoadString(ghInst, IDS_EDIT, szEdit, CBSHORTSTRING);
    LoadString(ghInst, IDS_OBJECT_MENU, szObjectMenu, CBSHORTSTRING);
    LoadString(ghInst, IDS_UNDO_MENU, szUndo, CBSHORTSTRING);
    LoadString(ghInst, IDS_GENERIC, szDummy, CBSHORTSTRING);
    LoadString(ghInst, IDS_CONTENT_OBJECT, szContent, CBMESSAGEMAX);
    LoadString(ghInst, IDS_APPEARANCE_OBJECT, szAppearance, CBMESSAGEMAX);

    // Initialize global variables with LOGPIXELSX and LOGPIXELSY
    if (hDC = GetDC (NULL))
    {
        giXppli = GetDeviceCaps(hDC, LOGPIXELSX);
        giYppli = GetDeviceCaps(hDC, LOGPIXELSY);
        ReleaseDC(NULL, hDC);
    }

    return InitPanes();
}



/* EndInstance() - Instance-specific termination code.
 */
static VOID
EndInstance(
    VOID
    )
{
    EndPanes();
}



/* FrameWndProc() - Frame window procedure.
 *
 * This function is the message handler for the application frame window.
 */
LRESULT CALLBACK
FrameWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fSuccess = FALSE;

    if (SplitterFrame(hwnd, msg, wParam, lParam))
        return DefWindowProc(hwnd, msg, wParam, lParam);

    switch (msg)
    {
    case WM_READEMBEDDED:
        if (gpty[CONTENT] == PEMBED)
        {
            EmbRead(glpobj[CONTENT]);

            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }

        break;

    case WM_INITMENU:
        UpdateMenu((HMENU)wParam);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_NEXTWINDOW:
            // Special trickery works because APP = 0 & CONTENT = 1
            Raise(GetTopWindow(hwnd) != ghwndPane[CONTENT]);
            break;

        case IDM_NEW:
            // Save the current file (if needed)
            SaveAsNeeded();

            // delete the current doc, and create untitled document
            CreateUntitled();
            break;

        case IDM_IMPORT:
            if (!OfnGetName(hwnd, IDM_IMPORT))
                break;

            Hourglass(TRUE);
            DeletePane(CONTENT, TRUE);
            if (ReadFromFile(gszFileName))
            {
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                Dirty();

                if (!gpty[APPEARANCE])
                {
                    if (glpobj[APPEARANCE] = IconCreateFromFile(gszFileName))
                    {
                        gpty[APPEARANCE] = ICON;
                        InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                    }
                }
            }

            Hourglass(FALSE);
            break;

        case IDM_EXPORT:
            if (!OfnGetName(hwnd, IDM_EXPORT))
                return 0L;          /* Operation cancelled */

            Hourglass(TRUE);

            if (!WriteToFile())
                ErrorMessage(E_FAILED_TO_SAVE_FILE);

            Hourglass(FALSE);
            break;

        case IDM_UPDATE:
            {
                OLESTATUS retval;

                if (Error(OleSavedClientDoc(glhcdoc)))
                    ErrorMessage(W_FAILED_TO_NOTIFY);

                if ((retval = OleSavedServerDoc (glpdoc->lhdoc)) == OLE_OK)
                {
                    gfDirty = FALSE;
                }
                else if (retval == OLE_ERROR_CANT_UPDATE_CLIENT)
                {
                    //
                    // The client doesn't take updates on Save. Let the
                    // user explicitly update and exit, or continue with
                    // the editing.
                    //
                    if (!MyDialogBox(DTFAILEDUPDATE, ghwndFrame, fnFailedUpdate))
                    {
                        // update the object and exit
                        gfOleClosed = TRUE;
                        DeregisterDoc();
                        DeleteServer(glpsrvr);
                    }
                }
                else
                {
                    Error(retval);
                }

                break;
            }

        case IDM_EXIT:
            SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
            return 0L;
            break;

        case IDM_COMMAND:
            Raise(CONTENT);
            DeletePane(CONTENT, FALSE);

            if (gptyUndo[CONTENT] != CMDLINK)
                glpobj[CONTENT] = CmlCreate("", FALSE);
            else
                glpobj[CONTENT] = CmlClone(glpobjUndo[CONTENT]);

            if (glpobj[CONTENT])
                gpty[CONTENT] = CMDLINK;

            if (glpobj[CONTENT] && ChangeCmdLine(glpobj[CONTENT]))
            {
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                Dirty();
            }
            else
            {
                CmlDelete(glpobj[CONTENT]);
                gpty[CONTENT] = NOTHING;
                glpobj[CONTENT] = NULL;
                SendMessage(ghwndPane[CONTENT], WM_COMMAND, IDM_UNDO, 0L);
            }

            break;

        case IDM_INSERTICON:
            PostMessage (ghwndBar[APPEARANCE], WM_COMMAND, IDM_INSERTICON, 0L);
            break;

        case IDM_DESC:
        case IDM_PICT:
            PostMessage(ghwndBar[CONTENT], WM_COMMAND, wParam, 0L);
            break;

        case IDM_LABEL:
            Raise(APPEARANCE);

            if (gpty[APPEARANCE] != ICON)
                break;

            ChangeLabel(glpobj[APPEARANCE]);
            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
            Dirty();
            break;

        case IDM_COPYPACKAGE:
            if (!CopyObjects())
                ErrorMessage(E_CLIPBOARD_COPY_FAILED);

            break;

        case IDM_PASTE:
            // Check to see if we are pasting a packaged object
            if (IsClipboardFormatAvailable(gcfNative)
                && IsClipboardFormatAvailable(gcfOwnerLink))
            {
                HANDLE hData;
                HANDLE hData2;
                LPSTR lpData;

                OpenClipboard(ghwndFrame);
                hData = GetClipboardData(gcfOwnerLink);

                if (lpData = GlobalLock(hData))
                {
                    // If it's the packager, get the native data
                    if (!lstrcmpi(lpData, gszAppClassName)
                        && (hData2 = GetClipboardData(gcfNative)))
                        fSuccess = PutNative(hData2);

                    // Unlock the clipboard Owner Link data
                    GlobalUnlock(hData);
                }

                CloseClipboard();
            }

            // Did we successfully read the native data?
            if (fSuccess)
                break;

            // ... guess not (maybe not Package!)
            PostMessage(GetTopWindow(hwnd), msg, wParam, lParam);
            break;

        case IDM_OBJECT:
            ExecuteVerb(0);     // Execute the ONLY verb
            break;

        case IDM_INDEX:
            HtmlHelp(ghwndFrame, szHelpFile, HH_DISPLAY_TOPIC, 0L);
            break;

        case IDM_ABOUT:
            ShellAbout(hwnd, szAppName, "",
                LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION)));
            break;

        default:
            if ((LOWORD(wParam) >= IDM_VERBMIN)
                && (LOWORD(wParam) <= IDM_VERBMAX))
            {
                // An object verb has been selected
                // (Hmm.  Did you know that an 'object verb' was a noun?)
                ExecuteVerb(LOWORD(wParam) - IDM_VERBMIN);
            }
            else
            {
                PostMessage(GetTopWindow(hwnd), msg, wParam, lParam);
            }

            break;
        }

        break;

    case WM_CLOSE:
        //
        // Update if necessary by notifying the server that we are closing
        // down, and revoke the server.
        //
        SaveAsNeeded();
        SendOleClosed();
        DeleteServer(glpsrvr);

        return 0L;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0L;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0L;
}



/* SetTitle() - Sets the window caption to the current filename.
 *
 * If gszFileName is NULL, the caption will be set to "(Untitled)".
 * If DocSetHostNames() is called with a client app name, that name
 * will be prepended.
 *
 * For the Embedded case, the "Embedded #n" string is stored in
 * "Untitled", and is always displayed regardless of the file name.
 */
VOID
SetTitle(
    BOOL fRegistering
    )
{
    CHAR szTitle[CBMESSAGEMAX + CBPATHMAX];

    if (!gfEmbedded)
    {
        StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s%s%s - %s", gszClientName,
            (*gszClientName) ? " " : "",
            szAppName, szUntitled);
    }
    else
    {
        CHAR szEmbnameContent[CBSHORTSTRING];

        LoadString(ghInst, IDS_EMBNAME_CONTENT, szEmbnameContent, CBSHORTSTRING);

        if (gbDBCS)
        {
            //#3997: 2/19/93: changed Window title
            StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s - %s %s", szAppName, szUntitled,
                             szEmbnameContent);
        }
        else
        {
            StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s - %s %s", szAppName, szEmbnameContent,
                 szUntitled);
        }

    }

    // Perform the client document registration
    if (glhcdoc)
    {
        if (Error(OleRenameClientDoc(glhcdoc, szUntitled)))
            ErrorMessage(W_FAILED_TO_NOTIFY);

        if (!fRegistering)
            ChangeDocName(&glpdoc, szUntitled);
    }
    else
    {
        if (Error(OleRegisterClientDoc(gszAppClassName, szUntitled, 0L, &glhcdoc)))
        {
            ErrorMessage(W_FAILED_TO_NOTIFY);
            glhcdoc = 0;
        }

        // New file, so re-register it
        if (!fRegistering)
            glpdoc = InitDoc(glpsrvr, 0, szUntitled);
    }

    if (IsWindow(ghwndFrame))
        SetWindowText(ghwndFrame, szTitle);
}



/* InitFile() - Reinitializes the title bar, etc... when editing a New file.
 */
VOID
InitFile(
    VOID
    )
{
    gfDirty = FALSE;

    // Deregister the edited document, and wipe out the objects.
    DeregisterDoc();

    // Reset the title bar, and register the OLE client document
    SetTitle(FALSE);
}



/* SaveAsNeeded() - Saves the file if it has been modified. It's assumed that
 *                  after this routine is called this document is going to be
 *                  closed. If that's not true, then this routine may have to
 *                  be rewritten.
 */
static VOID
SaveAsNeeded(
    VOID
    )
{
    gfOleClosed = FALSE;

    if (gfDirty && gfEmbedded && (glpobj[APPEARANCE] || glpobj[CONTENT]))
    {
        CHAR sz[CBMESSAGEMAX];
        CHAR sz2[CBMESSAGEMAX + CBPATHMAX];

        if (gfInvisible)
        {
            SendDocChangeMsg(glpdoc, OLE_CLOSED);
            return;
        }

        LoadString(ghInst, gfEmbedded ? IDS_MAYBEUPDATE : IDS_MAYBESAVE, sz,
             CBMESSAGEMAX);
        StringCchPrintf(sz2, ARRAYSIZE(sz2), sz, (LPSTR)szUntitled);

        // Ask "Do you wish to save your changes?"
        if (MessageBoxAfterBlock(ghwndFrame, sz2, szAppName,
            MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            gfOleClosed = TRUE;
            return;
        }
        // If not saving changes, revert the document
        else if (OleRevertClientDoc(glhcdoc))
        {
            ErrorMessage(W_FAILED_TO_NOTIFY);
        }
    }
}



/* WriteToFile() - Writes the current document to a file.
 *
 * Returns:  TRUE iff successful.
 */
static BOOL
WriteToFile(
    VOID
    )
{
    BOOL fSuccess = FALSE;
    OFSTRUCT reopenbuf;
    INT fh;

    CHAR szDesc[CBSTRINGMAX];
    CHAR szMessage[CBSTRINGMAX + CBPATHMAX];

    if (OpenFile(gszFileName, &reopenbuf, OF_EXIST) != -1)
    {
        // File exists, query for overwrite!
        LoadString(ghInst, IDS_OVERWRITE, szDesc, CharCountOf(szDesc));
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, gszFileName);
        if (MessageBoxAfterBlock(ghwndFrame, szMessage, szAppName,
            MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            return TRUE;
    }

    // Take care of this earlier?
    if ((fh = _lcreat((LPSTR)gszFileName, 0)) <= 0)
    {
        LoadString(ghInst, IDS_INVALID_FILENAME, szDesc, CharCountOf(szDesc));
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, gszFileName);
        MessageBoxAfterBlock(ghwndFrame, szMessage, szAppName, MB_OK);
        return FALSE;
    }

    Hourglass(TRUE);

    // Go to the top of the file
    _llseek(fh, 0L, 0);

    EmbWriteToFile(glpobj[CONTENT], fh);
    fSuccess = TRUE;

    // Close the file, and return
    _lclose(fh);
    gfDirty = FALSE;
    Hourglass(FALSE);

    return fSuccess;
}



/* ReadFromFile() - Reads OLE objects from a file.
 *
 * Reads as many objects as it can, in upwards order (better error recovery).
 * Returns: TRUE iff successful.
 */
static BOOL
ReadFromFile(
    LPSTR lpstrFile
    )
{
    BOOL fSuccess = FALSE;

    Hourglass(TRUE);

    // Read in each object and get them in the right order
    if (!(glpobj[CONTENT] = EmbCreate(lpstrFile)))
    {
        goto Error;
    }

    gpty[CONTENT] = PEMBED;

    fSuccess = TRUE;

Error:
    gfDirty = FALSE;
    Hourglass(FALSE);

    return fSuccess;
}



/* ErrorMessage() - Pops up a message box containing a string table message.
 *
 * Pre:  Assigns "ghwndError" to be its parent, so focus will return properly.
 */
VOID
ErrorMessage(
    UINT id
    )
{
    CHAR sz[300];

    if (IsWindow(ghwndError))
    {
        LoadString(ghInst, id, sz, 300);
        MessageBoxAfterBlock(ghwndError, sz, szAppName,
            MB_OK | MB_ICONEXCLAMATION);
    }
}



/* ProcessMessage() - Spin in a message dispatch loop.
 */
BOOL
ProcessMessage(
    VOID
    )
{
    BOOL fReturn;
    MSG msg;

    if (fReturn = GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(ghwndFrame, ghAccTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return fReturn;
}



/* Contains() - Determines whether a string matches a pattern.
 * This could be more intelligent, but it is scarcely executed.
 *
 * Returns: Non-NULL iff lpPattern is a substring of lpString.
 */
LPSTR
Contains(
    LPSTR lpString,
    LPSTR lpPattern
    )
{
    LPSTR lpSubstr;
    LPSTR lpPat;

    for (;;)
    {
        // Match the first character
        while (*lpString && *lpString != *lpPattern)
            lpString++;

        // We are at the end of the string, fail...
        if (!(*lpString))
            return NULL;

        // If we have a match, try to match the entire pattern string
        lpPat = lpPattern;
        lpSubstr = lpString;
        while (*lpPat && *lpSubstr && *lpPat == *lpSubstr)
        {
            lpPat++;
            lpSubstr++;
        }

        // We are at the end of the pattern, success!  Wipe out the pattern
        if (!(*lpPat))
            return lpString;

        // We are at the end of the string, failure...
        if (!(*lpSubstr))
            return NULL;

        lpString++;
    }
}



/* ProcessCmdLine() - Processes the command line options.
 */
static OLESTATUS
ProcessCmdLine(
    LPSTR lpCmdLine,
    INT nCmdShow
    )
{
    OLESTATUS retval = OLE_OK;

    // Does the command line contain "/Embedding"?
    if (gfEmbeddedFlag = gfInvisible =
        (Contains(lpCmdLine, szEmbedding) || Contains(lpCmdLine, szEmbedding2)))
    {
        // If we have a file name, register it NOW!
        lpCmdLine += lstrlen(szEmbedding);

        while (*lpCmdLine && *lpCmdLine == ' ')
            lpCmdLine++;

        if (*lpCmdLine)
        {
            retval = (glpsrvr->olesrvr.lpvtbl->Open)
                ((LPOLESERVER)glpsrvr, 0, lpCmdLine,
                (LPOLESERVERDOC *)&glpdoc);

            if (retval != OLE_OK)
                return retval;
        }

        gfDirty = FALSE;
        gnCmdShowSave = nCmdShow;

    }
    else
    {
        ShowWindow(ghwndFrame, nCmdShow);
        SendMessage(ghwndFrame, WM_COMMAND, IDM_NEW, 0L);
    }

    return retval;
}



/* Dirty() - This function is called each time the document is soiled.
 */
VOID
Dirty(
    VOID
    )
{
    gfDirty = TRUE;
    SendDocChangeMsg(glpdoc, OLE_CHANGED);
}



/* WaitForAllObjects() - Wait for asynchronous operations to complete.
 *
 * We don't use ProcessMessage() because we want to terminate as quickly
 * as possible, and we don't want to allow any structured user input.
 */
static VOID
WaitForAllObjects(
    VOID
    )
{
    MSG msgWait;

    if (gcOleWait)
    {
        while (gcOleWait)
        {
            if (GetMessage(&msgWait, NULL, 0, 0))
                DispatchMessage(&msgWait);
        }
    }
}



/* DeregisterDoc() - Deregisters the currently edited document.
 */
VOID
DeregisterDoc(
    VOID
    )
{
    gfDocCleared = TRUE;

    SendOleClosed();

    // Destroy all the objects
    DeletePane(APPEARANCE, TRUE);
    DeletePane(CONTENT, TRUE);

    // Wait for the objects to be deleted
    WaitForAllObjects();

    if (glpdoc)
    {
        LHSERVERDOC lhdoc = glpdoc->lhdoc;

        glpdoc = NULL;
        OleRevokeServerDoc(lhdoc);
    }

    // Release the document
    if (glhcdoc)
    {
        if (Error(OleRevokeClientDoc(glhcdoc)))
            ErrorMessage(W_FAILED_TO_NOTIFY);

        glhcdoc = 0;
    }
}



static VOID
UpdateMenu(
    HMENU hmenu
    )
{
    INT iPane;
    INT mf;

    iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
    EnableMenuItem(hmenu, IDM_EXPORT, MenuFlag(gpty[CONTENT] == PEMBED));
    EnableMenuItem(hmenu, IDM_CLEAR, MenuFlag(gpty[iPane]));
    EnableMenuItem(hmenu, IDM_UNDO, MenuFlag(gptyUndo[iPane]));

    EnableMenuItem(hmenu, IDM_UPDATE, (gfEmbedded ? MF_ENABLED : MF_GRAYED));

    if (((iPane == APPEARANCE) && gpty[iPane]) || (gpty[iPane] == PICTURE))
    {
        EnableMenuItem(hmenu, IDM_CUT, MF_ENABLED);
        EnableMenuItem(hmenu, IDM_COPY, MF_ENABLED);
    }
    else
    {
        EnableMenuItem(hmenu, IDM_CUT, MF_GRAYED);
        EnableMenuItem(hmenu, IDM_COPY, MF_GRAYED);
    }

    if (gpty[iPane] == PICTURE)
    {
        LPPICT lppict = glpobj[iPane];
        DWORD ot;

        mf = MF_GRAYED;
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);

            // Enable Links... only if we have a linked object
            mf = MenuFlag(ot == OT_LINK);
        }

        EnableMenuItem(hmenu, IDM_LINKS, mf);
        EnableMenuItem(hmenu, IDM_LABEL, MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hmenu, IDM_LINKS, MF_GRAYED);
        EnableMenuItem(hmenu, IDM_LABEL, MenuFlag(gpty[APPEARANCE] == ICON));
    }

    UpdateObjectMenuItem(GetSubMenu(hmenu, POS_EDITMENU));
    mf = MenuFlag(OleQueryCreateFromClip(gszProtocol, olerender_draw, 0) ==
        OLE_OK
        || OleQueryCreateFromClip(gszSProtocol, olerender_draw, 0) == OLE_OK);
    EnableMenuItem(hmenu, IDM_PASTE, mf);

    if (iPane == CONTENT)
    {
        if (IsClipboardFormatAvailable(gcfFileName)) {
            EnableMenuItem(hmenu, IDM_PASTELINK, MF_ENABLED);
        }
        else
        {
            mf = MenuFlag(OleQueryLinkFromClip(gszProtocol, olerender_draw, 0)
                == OLE_OK);
            EnableMenuItem(hmenu, IDM_PASTELINK, mf);
        }
    }
    else
    {
        EnableMenuItem(hmenu, IDM_PASTELINK, MF_GRAYED);
    }

    mf = MenuFlag(gpty[CONTENT] && gpty[APPEARANCE]);
    EnableMenuItem(hmenu, IDM_COPYPACKAGE, mf);
}



/* UpdateObjectMenuItem - If there are items in the selection, add the
 *                        menu, with a possible popup depending on the
 *                        number of verbs.
 */
static VOID
UpdateObjectMenuItem(
    HMENU hMenu
    )
{
    INT cVerbs = 0;             /* how many verbs in list */
    HWND hwndItem = NULL;
    INT iPane;
    LONG objtype;
    LPPICT lpPict;
    CHAR szWordOrder2[10];
    CHAR szWordOrder3[10];

    if (!hMenu)
        return;

    DeleteMenu(hMenu, POS_OBJECT, MF_BYPOSITION);

    LoadString(ghInst, IDS_POPUPVERBS, szWordOrder2, sizeof(szWordOrder2));
    LoadString(ghInst, IDS_SINGLEVERB, szWordOrder3, sizeof(szWordOrder3));

    //
    // CASES:
    //  object supports 0 verbs          "<Object Class> Object"
    //  object supports 1 verb == edit   "<Object Class> Object"
    //  object supports 1 verb != edit   "<verb> <Object Class> Object"
    //  object supports more than 1 verb "<Object Class> Object" => verbs
    //

    iPane = ((hwndItem = GetTopWindow(ghwndFrame)) == ghwndPane[CONTENT]);
    lpPict = glpobj[iPane];

    if (lpPict
        && OleQueryType(lpPict->lpObject, &objtype) == OLE_OK
        && hwndItem
        && gpty[iPane] == PICTURE
        && objtype != OT_STATIC)
    {
        HANDLE hData = NULL;
        LPSTR lpstrData;

        if (OleGetData(lpPict->lpObject, (OLECLIPFORMAT) (objtype == OT_LINK ?
            gcfLink : gcfOwnerLink), &hData) == OLE_OK)
        {
            // Both link formats are:  "szClass0szDocument0szItem00"
            if (lpstrData = GlobalLock(hData))
            {
                DWORD dwSize = KEYNAMESIZE;
                CHAR szClass[KEYNAMESIZE], szBuffer[200];
                CHAR szVerb[KEYNAMESIZE];
                HANDLE hPopupNew = NULL;

                // get real language class of object in szClass for menu
                if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrData,
                    szClass, &dwSize))
                    StringCchCopy(szClass, ARRAYSIZE(szClass), lpstrData);    /* if above call failed */
                GlobalUnlock(hData);

                // append class key
                for (cVerbs = 0; ; ++cVerbs)
                {
                    dwSize = KEYNAMESIZE;
                    StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), 
                        "%s\\protocol\\StdFileEditing\\verb\\%d",
                        lpstrData, cVerbs);

                    if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer,
                        szVerb, &dwSize))
                        break;

                    if (hPopupNew == NULL)
                        hPopupNew = CreatePopupMenu();

                    InsertMenu(hPopupNew, (UINT)-1, MF_BYPOSITION,
                        IDM_VERBMIN + cVerbs, szVerb);
                }

                if (cVerbs == 0)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szEdit,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION,
                        IDM_VERBMIN, szBuffer);
                }
                else if (cVerbs == 1)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szVerb,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION,
                        IDM_VERBMIN, szBuffer);
                    DestroyMenu(hPopupNew);
                }
                else
                {
                    // > 1 verbs
                    MakeMenuString(szWordOrder2, szBuffer, NULL,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION |
                        MF_POPUP, (UINT_PTR)hPopupNew, szBuffer);
                }

                EnableMenuItem(hMenu, POS_OBJECT,
                    MF_ENABLED | MF_BYPOSITION);

                return;
            }
        }
    }

    // error if got to here
    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, 0, szObjectMenu);
    EnableMenuItem(hMenu, POS_OBJECT, MF_GRAYED | MF_BYPOSITION);
}



/* ExecuteVerb() - Find the proper verb to execute for each selected item
 */
static VOID
    ExecuteVerb(
    INT iVerb
    )
{
    HWND hwndItem;
    INT iPane;
    RECT rc;

    iPane = ((hwndItem = GetTopWindow(ghwndFrame)) == ghwndPane[CONTENT]);

    GetClientRect(hwndItem, (LPRECT) & rc);

    // Execute the correct verb for this object
    if (Error(OleActivate(((LPPICT)(glpobj[iPane]))->lpObject, iVerb, TRUE,
        TRUE, hwndItem, &rc)))
    {
        if (OleQueryReleaseError(((LPPICT)(glpobj[iPane]))->lpObject) == OLE_ERROR_LAUNCH )
            ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
    }
    else
    {
        LONG ot;

        WaitForObject(((LPPICT)(glpobj[iPane]))->lpObject);
        if (!glpobj[iPane])
            return;

        OleQueryType(((LPPICT)(glpobj[iPane]))->lpObject, &ot);
        if (ot == OT_EMBEDDED)
            Error(OleSetHostNames(((LPPICT)(glpobj[iPane]))->lpObject,
                gszAppClassName,
                (iPane == CONTENT) ? szContent : szAppearance));
    }
}



VOID
Raise(
    INT iPane
    )
{
    if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
        SendMessage(ghwndPane[iPane], WM_LBUTTONDOWN, 0, 0L);
}



INT_PTR CALLBACK
fnFailedUpdate(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (msg)
    {
        case WM_INITDIALOG:
            {
                CHAR szMsg[200];
                CHAR szStr[100];

                LoadString(ghInst, IDS_FAILEDUPDATE, szStr, sizeof(szStr));
                StringCchPrintf((LPSTR)szMsg, ARRAYSIZE(szMsg), szStr, gszClientName, szAppName);
                SetDlgItemText(hDlg, IDD_TEXT, szMsg);

                return TRUE; // default Push button gets the focus
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                case IDD_CONTINUEEDIT:
                    EndDialog(hDlg, TRUE);
                    break;

                case IDD_UPDATEEXIT:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}



static VOID
SendOleClosed(
    VOID
    )
{
    // Do this first, so the data can be updated as needed
    if (glpdoc)
    {
        if (gfOleClosed)
        {
            SendDocChangeMsg(glpdoc, OLE_CLOSED);
            gfOleClosed = FALSE;
        }
    }
}



static VOID
CreateUntitled(
    VOID
    )
{
    if (gfEmbedded)      /* Unembed if embedded */
        EndEmbedding();

    if (gvlptempdoc = InitDoc(glpsrvr, 0, szUntitled))
    {
        InitFile();      /* Reset the file */
        glpdoc = gvlptempdoc;
        SetTitle(TRUE);
        gvlptempdoc = NULL;
        gfDocExists  = TRUE;
        gfDocCleared = FALSE;
    }
    else
    {
        ErrorMessage(E_FAILED_TO_REGISTER_DOCUMENT);
    }
}



static VOID
MakePenAware(
    VOID
    )
{

    HANDLE hPenWin = NULL;

    if ((hPenWin = LongToHandle(GetSystemMetrics(SM_PENWINDOWS))) != NULL)
    {
        // We do this fancy GetProcAddress simply because we don't
        // know if we're running Pen Windows.

        if ((RegPen = (VOID (CALLBACK *)(WORD, BOOL))GetProcAddress(hPenWin, "RegisterPenApp")) != NULL)
            (*RegPen)(1, TRUE);
    }

}



static VOID
MakePenUnaware(
    VOID
    )
{
    if (RegPen != NULL)
        (*RegPen)(1, FALSE);
}



INT_PTR MessageBoxAfterBlock(
    HWND hwndParent,
    LPSTR lpText,
    LPSTR lpCaption,
    UINT fuStyle
    )
{
    if (glpsrvr && !gfBlocked && (OleBlockServer(glpsrvr->lhsrvr) == OLE_OK))
        gfBlocked = TRUE;

    return MessageBox((gfInvisible ? NULL : hwndParent), lpText, lpCaption,
         fuStyle | MB_TOPMOST);
}



INT_PTR DialogBoxAfterBlock(
    LPCSTR lpTemplate,
    HWND hwndParent,
    DLGPROC lpDialogFunc
    )
{
    if (glpsrvr && !gfBlocked && (OleBlockServer(glpsrvr->lhsrvr) == OLE_OK))
        gfBlocked = TRUE;

    return DialogBox(ghInst, lpTemplate, (gfInvisible ? NULL : hwndParent),
        lpDialogFunc);
}



static VOID
MakeMenuString(
    CHAR *szCtrl,
    CHAR *szMenuStr,
    CHAR *szVerb,
    CHAR *szClass,
    CHAR *szObject
    )
{
    register CHAR c;
    CHAR *pStr;

    while (c = *szCtrl++)
    {
        switch (c)
        {
            case 'c': // class
            case 'C': // class
                pStr = szClass;
                break;

            case 'v': // class
            case 'V': // class
                pStr = szVerb;
                break;

            case 'o': // object
            case 'O': // object
                pStr = szObject;
                break;

            default:
                *szMenuStr++ = c;
                *szMenuStr = '\0'; // just in case
                continue;
        }

        if (pStr) // should always be true
        {
            StringCchCopy(szMenuStr, ARRAYSIZE(szMenuStr), pStr);
            szMenuStr += lstrlen(pStr); // point to '\0'

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\picture.c ===
/* picture.c - This file contains OLE object handling routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include "dialogs.h"


static OLECLIENTVTBL clientTbl;
static OLESTREAMVTBL streamTbl;


static VOID PicGetBounds(LPOLEOBJECT lpObject, LPRECT lprc);

/* InitClient() - Initialize the OLE client structures.
 */
BOOL
InitClient(
    VOID
    )
{
    gcfFileName  = (OLECLIPFORMAT)RegisterClipboardFormat("FileName");
    gcfLink      = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    gcfNative    = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    gcfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");

    glpclient = PicCreateClient(&CallBack, (LPOLECLIENTVTBL)&clientTbl);

    if (!(glpStream = (LPAPPSTREAM)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(APPSTREAM))))
        goto Error;

    glpStream->lpstbl = (LPOLESTREAMVTBL)&streamTbl;
    streamTbl.Get = (DWORD (CALLBACK*)(LPOLESTREAM, void FAR*, DWORD))ReadStream;
    streamTbl.Put = (DWORD (CALLBACK*)(LPOLESTREAM, OLE_CONST void FAR*, DWORD))WriteStream;

    return TRUE;

Error:
    if (glpStream)
    {
        GlobalFree(glpStream);
    	glpStream = NULL;
    }

    if (glpclient)
    {
        GlobalFree(glpclient);
        glpclient = NULL;
    }

    return FALSE;
}



/* EndClient() - Clean up for termination.
 */
VOID
EndClient(
    VOID
    )
{
    if (glpStream)
    {
	GlobalFree(glpStream);
        glpStream = NULL;
    }

    if (glpclient)
    {
	GlobalFree(glpclient);
        glpclient = NULL;
    }
}



/* PicCreate() -
 */
LPPICT
PicCreate(
    LPOLEOBJECT lpObject,
    LPRECT lprcObject
    )
{
    HANDLE hpict = NULL;
    LPPICT lppict = NULL;
    RECT rc;

    if (lpObject)
    {
        if (!(hpict = GlobalAlloc(GMEM_MOVEABLE, sizeof(PICT)))
            || !(lppict = (LPPICT)GlobalLock(hpict)))
            goto errRtn;

        //
        // If size of window is specified, use it; otherwise, retrieve
        // the size of the item synchronously.
        //
        if (lprcObject)
            rc = *lprcObject;
        else {
            SetRectEmpty(&rc);
            PicGetBounds(lpObject, &rc);
        }

        // Store the data in the window itself
        lppict->hdata = hpict;
        lppict->lpObject = lpObject;
        lppict->rc = rc;
        lppict->fNotReady = FALSE;
    }

    return lppict;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lppict)
        GlobalUnlock(hpict);

    if (hpict)
        GlobalFree(hpict);

    return NULL;
}



/* PicDelete() - Deletes an object (called when the item window is destroyed).
 */
VOID
PicDelete(
    LPPICT lppict
    )
{
    HANDLE hdata;
    LPOLEOBJECT lpObject;

    if (!lppict)
        return;

    if (lppict && lppict->lpObject)
    {
        lpObject = lppict->lpObject;
        lppict->lpObject = NULL;
        // Wait until the object isn't busy
        WaitForObject(lpObject);

        if (Error(OleDelete(lpObject)))
            ErrorMessage(E_FAILED_TO_DELETE_OBJECT);

        // Wait until the object deletion is complete
        WaitForObject(lpObject);
    }

    GlobalUnlock(hdata = lppict->hdata);
    GlobalFree(hdata);
}



/* PicDraw() - Draws the item associated with hwnd in the DC hDC.
 */
BOOL
PicDraw(
    LPPICT lppict,
    HDC hDC,
    LPRECT lprc,
    INT xHSB,
    INT yVSB,
    BOOL fPicture,
    BOOL fFocus
    )
{
    BOOL fSuccess = FALSE;
    DWORD ot;
    HANDLE hdata;
    HFONT hfont;
    LPOLEOBJECT lpObjectUndo;
    LPSTR lpdata;
    RECT rc;
    RECT rcFocus;
    CHAR szDesc[CBMESSAGEMAX];
    CHAR szFileName[CBPATHMAX];
    CHAR szMessage[CBMESSAGEMAX + CBPATHMAX];
    INT iDelta;
    INT iPane;

    iPane = (lppict == glpobj[CONTENT]);
    lpObjectUndo = (gptyUndo[iPane] == PICTURE)
        ? ((LPPICT)glpobjUndo[iPane])->lpObject : NULL;

    // If drawing the Picture, offset by scroll bars and draw
    if (fPicture)
    {
        if (IsRectEmpty(&(lppict->rc)))
            PicGetBounds(lppict->lpObject, &(lppict->rc));

        rc = lppict->rc;

        // If image is smaller than pane, center horizontally
        if ((iDelta = lprc->right - lppict->rc.right) > 0)
            OffsetRect(&rc, iDelta >> 1, 0);
        else /* else, use the scroll bar value */
            OffsetRect(&rc, -xHSB, 0);

        // If image is smaller than pane, center vertically
        if ((iDelta = lprc->bottom - lppict->rc.bottom) > 0)
            OffsetRect(&rc, 0, iDelta >> 1);
        else /* else, use the scroll bar value */
            OffsetRect(&rc, 0, -yVSB);

        // If we have an object, call OleDraw()
        fSuccess = !Error(OleDraw(lppict->lpObject, hDC, &rc, NULL, NULL));

        if (fFocus)
            DrawFocusRect(hDC, &rc);

        return fSuccess;
    }

    // Otherwise, draw the description string
    OleQueryType(lppict->lpObject, &ot);

    if ((ot == OT_LINK
        && Error(OleGetData(lppict->lpObject, gcfLink, &hdata)))
        || (ot == OT_EMBEDDED
        && Error(OleGetData(lppict->lpObject, gcfOwnerLink, &hdata)))
        || (ot == OT_STATIC
        && (!lpObjectUndo || Error(OleGetData(lpObjectUndo, gcfOwnerLink,
        &hdata)))))
    {
        LoadString(ghInst, IDS_OBJECT, szFileName, CBMESSAGEMAX);
        LoadString(ghInst, IDS_FROZEN, szDesc, CBMESSAGEMAX);
        goto DrawString;
    }

    if (hdata && (lpdata = GlobalLock(hdata)))
    {
        switch (ot)
        {
            case OT_LINK:
                while (*lpdata++)
                    ;
                
                // return value ignored
                if(SUCCEEDED(StringCchCopy(szFileName, ARRAYSIZE(szFileName), lpdata)))
                {
                    Normalize(szFileName);
                    LoadString(ghInst, IDS_LINKTOFILE, szDesc, CBMESSAGEMAX);
                }

                break;

            case OT_EMBEDDED:
                RegGetClassId(szFileName, ARRAYSIZE(szFileName), lpdata);
                LoadString(ghInst, IDS_EMBEDFILE, szDesc, CBMESSAGEMAX);
                break;

            case OT_STATIC:
                RegGetClassId(szFileName, ARRAYSIZE(szFileName), lpdata);
                LoadString(ghInst, IDS_FROZEN, szDesc, CBMESSAGEMAX);
                break;
        }

        GlobalUnlock(hdata);

DrawString:
        if(SUCCEEDED(StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, szFileName)))  // return value ignored
        {

            hfont = SelectObject(hDC, ghfontChild);
            DrawText(hDC, szMessage, -1, lprc,
                DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            if (fFocus)
            {
                rcFocus = *lprc;
                DrawText(hDC, szMessage, -1, &rcFocus,
                    DT_CALCRECT | DT_NOPREFIX | DT_LEFT | DT_TOP | DT_SINGLELINE);
                OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) / 2,
                    (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
                DrawFocusRect(hDC, &rcFocus);
            }

            if (hfont)
                SelectObject(hDC, hfont);

            fSuccess = TRUE;
        }
    }

    return fSuccess;
}



/* PicPaste() - Retrieves an object from the clipboard.
 */
LPPICT
PicPaste(
    BOOL fPaste,
    LPSTR lpstrName
    )
{
    LPOLEOBJECT lpObject;

    if (!OpenClipboard(ghwndFrame))
        return NULL;                    /* Couldn't open the clipboard */

    Hourglass(TRUE);

    // Don't replace the current object unless we're successful
    if (fPaste)
    {
        if (Error(OleCreateFromClip(gszProtocol, glpclient, glhcdoc, lpstrName,
            &lpObject, olerender_draw, 0)))
        {
            if (Error(OleCreateFromClip(gszSProtocol, glpclient, glhcdoc,
                lpstrName, &lpObject, olerender_draw, 0)))
                lpObject = NULL;

        }
    }
    else if (Error(OleCreateLinkFromClip(
        gszProtocol, glpclient, glhcdoc, lpstrName, &lpObject,
        olerender_draw, 0)))
    {
        lpObject = NULL;
    }

    CloseClipboard();
    Hourglass(FALSE);

    if (!lpObject)
        return NULL;

    return PicCreate(lpObject, NULL);
}



/* Error() - check for OLE function error conditions
 *
 * This function increments gcOleWait as appropriate.
 *
 * Pre:      Initialize ghwndError to where the focus should return.
 *
 * Returns:  TRUE  if an immediate error occurred.
 */
BOOL
Error(
    OLESTATUS olestat
    )
{
    DWORD ot;
    INT iPane;

    switch (olestat)
    {
        case OLE_WAIT_FOR_RELEASE:
            gcOleWait++;
            return FALSE;

        case OLE_OK:
            return FALSE;

        case OLE_ERROR_STATIC:              /* Only happens w/ dbl click */
            ErrorMessage(W_STATIC_OBJECT);
            break;

        case OLE_ERROR_ADVISE_PICT:
        case OLE_ERROR_OPEN:                /* Invalid link? */
        case OLE_ERROR_NAME:
            iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
            if ((LPPICT)glpobj[iPane] == NULL)
            {
                ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
                return FALSE;
            }
            else
            {
                OleQueryType(((LPPICT)glpobj[iPane])->lpObject, &ot);
                if (ot == OT_LINK)
                {
                    if (ghwndError == ghwndFrame)
                    {
                        if (DialogBoxAfterBlock (
                            MAKEINTRESOURCE(DTINVALIDLINK), ghwndError,
                            fnInvalidLink) == IDD_CHANGE)
                            PostMessage(ghwndFrame, WM_COMMAND, IDM_LINKS, 0L);
                    }
                    else
                    {
                        // Failed, but already in Link Properties!!
                        ErrorMessage(E_FAILED_TO_UPDATE_LINK);
                    }

                    return FALSE;
                }
            }

            break;

        default:
            break;
    }

    return TRUE;
}



/* CallBack() - Routine that OLE client DLL calls when events occur.
 *
 * This routine is called when the object has been updated and may
 * need to be redisplayed; if asynchronous operations have completed;
 * and if the application allows the user to cancel long operations
 * (like Painting, or other asynchronous operations).
 */
INT CALLBACK
CallBack(
    LPOLECLIENT lpclient,
    OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject
    )
{
    INT iPane;

    switch (flags)
    {
        case OLE_CLOSED:
            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
            else
                SetFocus(ghwndError);

            break;

        case OLE_SAVED:
        case OLE_CHANGED:
            {
                //
                // The OLE libraries make sure that we only receive
                // update messages according to the Auto/Manual flags.
                //
                iPane = (gpty[CONTENT] == PICTURE
                    && ((LPPICT)glpobj[CONTENT])->lpObject == lpObject);

                if (gpty[iPane] == PICTURE)
                {
                    ((LPPICT)glpobj[iPane])->fNotReady = FALSE;
                    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
                    SetRect(&(((LPPICT)glpobj[iPane])->rc), 0, 0, 0, 0);
                    Dirty();
                }

                break;
            }

        case OLE_RELEASE:
            {
                if (gcOleWait)
                    gcOleWait--;
                else
                    ErrorMessage(E_UNEXPECTED_RELEASE);

                switch (Error(OleQueryReleaseError(lpObject)))
                {
                    case FALSE:
                        switch (OleQueryReleaseMethod(lpObject))
                        {
                            case OLE_SETUPDATEOPTIONS:
                                iPane = (gpty[CONTENT] == PICTURE
                                    && ((LPPICT)glpobj[CONTENT])->lpObject ==
                                    lpObject);

                                PostMessage(ghwndPane[iPane], WM_COMMAND,
                                    IDM_LINKDONE, 0L);

                            default:
                                break;
                        }

                        break;

                    case TRUE:
                        switch (OleQueryReleaseMethod(lpObject))
                        {
                            case OLE_DELETE:
                                ErrorMessage(E_FAILED_TO_DELETE_OBJECT);
                                break;

                            case OLE_LOADFROMSTREAM:
                                ErrorMessage(E_FAILED_TO_READ_OBJECT);
                                break;

                            case OLE_LNKPASTE:
                                ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                                break;

                            case OLE_ACTIVATE:
                                ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
                                break;

                            case OLE_UPDATE:
                                ErrorMessage(E_FAILED_TO_UPDATE);
                                break;

                            case OLE_RECONNECT:
                                ErrorMessage(E_FAILED_TO_RECONNECT_OBJECT);
                                break;
                        }

                        break;
                }

                break;
            }

        case OLE_QUERY_RETRY:
            // if lpObject doesn't match any one of these 4 objects, it means
            // that PicDelete() has been called on lpObject, so there is no
            // point in continueing the RETRIES.
            // See PicDelete() code for more info.
            if ((glpobj[CONTENT]
                && lpObject == ((LPPICT)glpobj[CONTENT])->lpObject)
                || (glpobj[APPEARANCE]
                && lpObject == ((LPPICT) glpobj[APPEARANCE])->lpObject)
                || (glpobjUndo[CONTENT]
                && lpObject == ((LPPICT) glpobjUndo[CONTENT])->lpObject)
                || (glpobjUndo[APPEARANCE]
                && lpObject == ((LPPICT) glpobjUndo[APPEARANCE])->lpObject))
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

        case OLE_QUERY_PAINT:
            return TRUE;

        default:
            break;
    }

    return 0;
}



/* WaitForObject() - Waits, dispatching messages, until the object is free.
 *
 * If the object is busy, spin in a dispatch loop.
 */
VOID
WaitForObject(
    LPOLEOBJECT lpObject
    )
{
    while (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        ProcessMessage();
}



/* PicSetUpdateOptions() - Sets the update options of the object.
 *
 * Returns:  TRUE if the command completed synchronously.
 */
BOOL
PicSetUpdateOptions(
    LPPICT lppict,
    UINT idCmd
    )
{
    OLESTATUS olestat = OLE_ERROR_GENERIC;

    olestat = OleSetLinkUpdateOptions(
        lppict->lpObject,
        (idCmd == IDD_AUTO) ? oleupdate_always : oleupdate_oncall);

    if (Error(olestat))
        ErrorMessage(E_FAILED_TO_UPDATE_LINK);

    return (olestat == OLE_OK);
}



/* PicReadFromNative() - Reads an object from the pointer lpstr.
 *
 * SIDE EFFECT:  Advances the pointer past the object.
 */
LPPICT
PicReadFromNative(
    LPSTR *lplpstr,
    LPSTR lpstrName
    )
{
    LPOLEOBJECT lpObject;
    LPSTR lpstrStart;
    RECT rcObject;
    WORD w;

    // Save current position of file pointer
    lpstrStart = *lplpstr;
    SetFile(SOP_MEMORY, 0, lplpstr);

    // Load the new object
    if (Error(OleLoadFromStream((LPOLESTREAM)glpStream, gszProtocol, glpclient,
        glhcdoc, lpstrName, &lpObject)))
    {
        // Reset file pointer, and try again
        *lplpstr = lpstrStart;
        SetFile(SOP_MEMORY, 0, lplpstr);

        // Read it with the "Static" protocol
        if (Error(OleLoadFromStream((LPOLESTREAM)glpStream, gszSProtocol,
            glpclient, glhcdoc, lpstrName, &lpObject)))
            return NULL;
    }

    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.left = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.top = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.right = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.bottom = (INT)w;

    // Create a window at the right place, and display the object
    return PicCreate(lpObject, &rcObject);
}



/* PicWriteToNative() - Writes an object to memory.
 *
 * SIDE EFFECT:  Moves pointer to end of written object
 */
DWORD
PicWriteToNative(
    LPPICT lppict,
    LPOLEOBJECT lpObject,
    LPSTR *lplpstr
    )
{
    DWORD cb = 0L;
    WORD w;

    // Save the object
    SetFile(SOP_MEMORY, 0, lplpstr);

    if (Error(OleSaveToStream(lpObject, (LPOLESTREAM)glpStream)))
        goto Done;

    cb += gcbObject;

    if (lplpstr)
    {
        w = (WORD)lppict->rc.left;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.top;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.right;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.bottom;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
    }

    cb += (DWORD)(4 * sizeof(WORD));

Done:
    return cb;
}



/* Hourglass() - Puts up the hourglass as needed.
 */
VOID
Hourglass(
    BOOL fOn
    )
{
    static HCURSOR hcurSaved = NULL;    // Cursor saved when hourglass is up
    static UINT cWait = 0;              // Number of "Hourglass"es up

    if (fOn)
    {
        if (!(cWait++))
            hcurSaved = SetCursor(ghcurWait);
    }
    else
    {
        if (!(--cWait) && hcurSaved)
        {
            SetCursor(hcurSaved);
            hcurSaved = NULL;
        }
    }
}



VOID
PicActivate(
    LPPICT lppict,
    UINT idCmd
    )
{
    DWORD ot;
    DWORD ot2;
    RECT rc;
    INT iPane;
    BOOL bAlreadyOpen = FALSE;

    iPane = (lppict == glpobj[CONTENT]);
    OleQueryType(lppict->lpObject, &ot);
    if (ot != OT_STATIC)
    {
        // Compute the window dimensions
        GetClientRect(ghwndPane[iPane], &rc);
        bAlreadyOpen = (OleQueryOpen(lppict->lpObject) == OLE_OK);

        // Open the object
        if (Error(OleActivate(lppict->lpObject,
            (idCmd == IDD_PLAY ? OLE_PLAY : OLE_EDIT),
            TRUE, TRUE, ghwndPane[iPane], &rc)))
        {
            ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
            goto errRtn;
        }
        else
        {
            WaitForObject(lppict->lpObject);
            if (!glpobj[iPane])
                goto errRtn;

            OleQueryType(lppict->lpObject, &ot2);
            if (ot2 == OT_EMBEDDED)
                Error(OleSetHostNames(lppict->lpObject, gszAppClassName,
                    (iPane == CONTENT) ? szContent : szAppearance));
        }

        return;
    }
    else
    {
        ErrorMessage(W_STATIC_OBJECT);
    }

errRtn:
    if (gfInvisible && !bAlreadyOpen)
        PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
}



VOID
PicUpdate(
    LPPICT lppict
    )
{
    DWORD ot;

    OleQueryType(lppict->lpObject, &ot);
    if (ot == OT_LINK)
    {
        if (Error(OleUpdate(lppict->lpObject)))
            ErrorMessage(E_FAILED_TO_UPDATE);
    }
}



VOID
PicFreeze(
    LPPICT lppict
    )
{
    DWORD ot;
    LPOLEOBJECT lpObject;
    INT iPane;

    iPane = (lppict == glpobj[CONTENT]);
    OleQueryType(lppict->lpObject, &ot);
    if (ot != OT_STATIC)
    {
        if (Error(OleObjectConvert(lppict->lpObject, gszSProtocol, glpclient,
             glhcdoc, gszCaption[iPane], &lpObject)))
        {
            ErrorMessage(E_FAILED_TO_FREEZE);
            return;
        }

        if (Error(OleDelete(lppict->lpObject)))
            ErrorMessage(E_FAILED_TO_DELETE_OBJECT);

        lppict->lpObject = lpObject;

        // Redraw the list box contents
        PostMessage(ghwndError, WM_REDRAW, 0, 0L);
    }
}



VOID
PicChangeLink(
    LPPICT lppict
    )
{
    HANDLE hData;
    OLESTATUS olestat;

    // Change the link information
    olestat = OleGetData(lppict->lpObject, gcfLink, &hData);
    if (!Error(olestat) && hData)
    {
        hData = OfnGetNewLinkName(ghwndError, hData);
        if (hData && !Error(OleSetData(lppict->lpObject, gcfLink, hData)))
            PostMessage(ghwndError, WM_REDRAW, 0, 0L);
    }
}



/* PicCopy() - Puts an object onto the clipboard.
 *
 * Returns:  TRUE iff successful.
 */
BOOL
PicCopy(
    LPPICT lppict
    )
{
    BOOL fSuccess = FALSE;

    // If we can't open the clipboard, fail
    if (!lppict->lpObject || !OpenClipboard(ghwndFrame))
        return FALSE;

    // Empty the clipboard
    EmptyClipboard();

    // Successful if we managed to copy to the clipboard
    fSuccess = !Error(OleCopyToClipboard(lppict->lpObject));

    CloseClipboard();
    return fSuccess;
}



/* PicGetBounds() -
 */
static VOID
PicGetBounds(
    LPOLEOBJECT lpObject,
    LPRECT lprc
    )
{
    if (IsRectEmpty(lprc))
    {
        switch (OleQueryBounds(lpObject, lprc))
        {
            case OLE_WAIT_FOR_RELEASE:
                Hourglass(TRUE);
                gcOleWait++;
                WaitForObject(lpObject);
                Hourglass(FALSE);

            case OLE_OK:
                // Map from HIMETRIC into screen coordinates
                lprc->right = MulDiv(giXppli,
                    lprc->right - lprc->left, HIMETRIC_PER_INCH);
                lprc->bottom = MulDiv (giYppli,
                    lprc->top - lprc->bottom, HIMETRIC_PER_INCH);
                lprc->left = 0;
                lprc->top = 0;

            default:
                break;
        }
    }
}


/* PicSaveUndo() - Saves a copy of the object for Undo.
 */
VOID
PicSaveUndo(
    LPPICT lppict
    )
{
    INT iPane = (lppict == glpobj[CONTENT]);
    LPOLEOBJECT lpObject;

    // Clone the object
    if (Error(OleClone(lppict->lpObject, glpclient, glhcdoc, gszTemp, &lpObject))
        || !lpObject)
    {
        ErrorMessage(W_FAILED_TO_CLONE_UNDO);
    }
    else
    {
        // Save the undo, delete the prior Undo
        DeletePane(iPane, FALSE);
        OleRename(lpObject, gszCaption[iPane]);
        glpobj[iPane] = PicCreate(lpObject, &(lppict->rc));
        gpty[iPane] = PICTURE;

        if (iPane == CONTENT)
            EnableWindow(ghwndPict, TRUE);
    }
}



/* PicPaste() - Creates object from a file
 */
LPPICT
PicFromFile(
    BOOL fEmbedded,
    LPSTR szFile
    )
{
    HRESULT hr;
    LPOLEOBJECT lpObject;

    Hourglass(TRUE);

    // Don't replace the current object unless we're successful
    if (fEmbedded)
    {
        hr = OleCreateFromFile(gszProtocol, glpclient, NULL, szFile,
                    glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0);
    }
    else
    {
        hr = OleCreateLinkFromFile(gszProtocol, glpclient, NULL, szFile,
                    NULL, glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0);
    }

    Hourglass(FALSE);

    if (FAILED(hr))
        return NULL;

    WaitForObject(lpObject);

    return PicCreate(lpObject, NULL);
}



LPOLECLIENT
PicCreateClient(
    PCALL_BACK fnCallBack,
    LPOLECLIENTVTBL lpclivtbl
    )
{
    LPOLECLIENT pclient;
    if (!(pclient = (LPOLECLIENT)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENT))))
        return NULL;

    pclient->lpvtbl = lpclivtbl;
    pclient->lpvtbl->CallBack = fnCallBack;

    return pclient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\pbrush\pbrush.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#include <windows.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\packager\virtable.c ===
/* virtable.c - This module contains the OLE virtual table/private routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include "dialogs.h"


//#define  OLESVR_SUPPORT     /* enable support for OLE server files */


static CHAR szLink[] = "/Link";             // Appended to end of link packages



/**************************** Server functions *****************************/
/* SrvrOpen() - Wraps a filename that is passed into a command line.
 */
OLESTATUS
SrvrOpen(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{
    LPSAMPDOC lpdoc;
    LPSTR lpstrLink = NULL;
    OLESTATUS retval = OLE_OK;
    LPOLEOBJECT lpObject = NULL;

    DPRINT("pkg: SrvrOpen");

    if (lpstrLink = Contains(lpdocname, szLink))
        *lpstrLink = '\0';

    if (!(lpdoc = (LPSAMPDOC)CreateDocFromFile(
        (LPSAMPSRVR)lpolesrvr, lhdoc, lpdocname)))
        return OLE_ERROR_GENERIC;

    // Generate a command line
    BringWindowToTop(ghwndPane[CONTENT]);

    if (gpty[CONTENT])
        DeletePane(CONTENT, TRUE);

#ifdef OLESVR_SUPPORT
    if (IsOleServerDoc (lpdocname))
    {
        gpty[CONTENT] = PICTURE;

        if (lpstrLink)
        {
            if (Error(OleCreateLinkFromFile(gszProtocol, glpclient, NULL,
                lpdocname, NULL, glhcdoc, gszCaption[CONTENT], &lpObject,
                olerender_draw, 0)))
                retval = OLE_ERROR_OPEN;
        }
        else
        {
            if (Error(OleCreateFromFile(gszProtocol, glpclient, NULL, lpdocname,
                glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0)))
                retval = OLE_ERROR_OPEN;
        }

        if (retval == OLE_OK)
        {
            glpobj[CONTENT] = PicCreate(lpObject, NULL);
            ((LPPICT)glpobj[CONTENT])->fNotReady = TRUE;
            OleBlockServer(((LPSAMPSRVR)lpolesrvr)->lhsrvr);
            gfBlocked = TRUE;
        }
        else
        {
            DeregisterDoc();
            return retval;
        }
    }
    else
    {
#endif
        if (lpstrLink)
        {
            if (glpobj[CONTENT] = CmlCreateFromFilename(lpdocname, TRUE))
                gpty[CONTENT] = CMDLINK;
        }
        else
        {
            if (glpobj[CONTENT] = (LPVOID)EmbCreate(lpdocname))
                gpty[CONTENT] = PEMBED;
        }

        if (glpobj[CONTENT] == NULL)
            retval = OLE_ERROR_OPEN;

#ifdef OLESVR_SUPPORT
    }
#endif

    // If no appearance pane (which should be always), try to make one
    if (!gpty[APPEARANCE])
    {
        if (glpobj[APPEARANCE] = IconCreateFromFile(lpdocname))
        {
            gpty[APPEARANCE] = ICON;
            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
        }
    }

    // Restore the character we so rudely mashed
    if (lpstrLink)
        *lpstrLink = szLink[0];

    // Save the document and change the menus
    InitEmbedded(FALSE);
    *lplpoledoc = (LPOLESERVERDOC)lpdoc;

    return retval;
}



/* SrvrCreate() - Create a new (embedded) object.
 */
OLESTATUS
SrvrCreate(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{

    DPRINT("pkg: SrvrCreate");

    // Initialize the new image
    InitFile();

    if (!(*lplpoledoc = (LPOLESERVERDOC)CreateNewDoc((LPSAMPSRVR)lpolesrvr,
        lhdoc, lpdocname)))
        return OLE_ERROR_GENERIC;

    InitEmbedded(TRUE);

    return OLE_OK;
}



/* SrvrCreateFromTemplate() - Create a new (embedded) object from a file.
 */
OLESTATUS
SrvrCreateFromTemplate(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPSTR lptemplatename,
    LPOLESERVERDOC *lplpoledoc
    )
{
    LPSAMPDOC lpdoc;

    DPRINT("pkg: SrvrCreateFromTemplate");

    if (!(lpdoc = (LPSAMPDOC)CreateDocFromFile((LPSAMPSRVR)lpolesrvr, lhdoc,
        lptemplatename)))
        return OLE_ERROR_GENERIC;

    // Save the document and change the menus
    *lplpoledoc = (LPOLESERVERDOC)lpdoc;
    InitEmbedded(FALSE);

    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpdocname);
    SetTitle(TRUE);
    return OLE_OK;
}



/* SrvrEdit() - Open an (embedded) object for editing.
 */
OLESTATUS
SrvrEdit(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{
    DPRINT("pkg: SrvrEdit");

    if (!(*lplpoledoc = (LPOLESERVERDOC)CreateNewDoc((LPSAMPSRVR)lpolesrvr,
        lhdoc, lpdocname)))
        return OLE_ERROR_MEMORY;

    InitEmbedded(FALSE);

    return OLE_OK;
}



/* SrvrExit() - Called to cause the OLE server to be revoked.
 */
OLESTATUS
SrvrExit(
    LPOLESERVER lpolesrvr
    )
{
    DPRINT("pkg: SrvrExit");
    DeleteServer((LPSAMPSRVR)lpolesrvr);
    return OLE_OK;

}



/* SrvrRelease() - Called so that the server memory can be freed.
 *
 * Note:    This call may occur in isolation without a SrvrExit()
 *          call.  If this occurs, we still revoke the server.
 */
OLESTATUS
SrvrRelease(
    LPOLESERVER lpolesrvr
    )
{
    DPRINT("pkg: SrvrRelease");
    if (gvlptempdoc)
        return OLE_OK;

    if (gfInvisible || (gfEmbeddedFlag && !gfDocExists))
        DeleteServer((LPSAMPSRVR)lpolesrvr);

    if (ghServer)
        DestroyServer();

    return OLE_OK;
}



/* SrvrExecute() - Called to execute DDE commands
 */
OLESTATUS
SrvrExecute(
    LPOLESERVER lpolesrvr,
    HANDLE hCmds
    )
{
    DPRINT("pkg: SrvrExecute");
    return OLE_ERROR_PROTOCOL;
}



/************************** Document functions *************************/
/* DocSave() - OLE callback to save the document.
 */
OLESTATUS
DocSave(
    LPOLESERVERDOC lpoledoc
    )
{
    DPRINT("pkg: DocSave");
    return OLE_OK;
}



/* DocClose() - OLE callback when the document is to be closed.
 *
 * This command has no additional effects; since we are not an MDI application
 * we don't close the child window.  The window is destroyed when the server
 * function "Release" is called.
 */
OLESTATUS
DocClose(
    LPOLESERVERDOC lpoledoc
    )
{
    DPRINT("pkg: DocClose");
    DeregisterDoc();
    return OLE_OK;
}



/* DocRelease() - Deallocate document memory.
 */
OLESTATUS
DocRelease(
    LPOLESERVERDOC lpoledoc
    )
{
    LPSAMPDOC lpdoc = (LPSAMPDOC)lpoledoc;
    HANDLE hdoc;

    DPRINT("pkg: DocRelase");
    if (lpdoc)
    {
        if (!gfDocCleared)
        {
            glpdoc = NULL;
            DeregisterDoc();
        }

        GlobalDeleteAtom(lpdoc->aName);
        LocalUnlock(hdoc = lpdoc->hdoc);
        LocalFree(hdoc);
        gfDocExists = FALSE;
    }

    return OLE_OK;
}



/* DocGetObject() - Create a new object within the current document
 */
OLESTATUS
DocGetObject(
    LPOLESERVERDOC lpoledoc,
    LPSTR lpitemname,
    LPOLEOBJECT *lplpoleobject,
    LPOLECLIENT lpoleclient
    )
{
    LPSAMPITEM lpitem;

    DPRINT("pkg: DocGetObject");

    //
    // Always create a new item in this case, it's much easier than
    // worrying about the sub-rectangle bitmap.
    //
    lpitem = CreateNewItem((LPSAMPDOC)lpoledoc);
    lpitem->lpoleclient = lpoleclient;
    if (*lpitemname)
    {
        lpitem->aName = AddAtom(lpitemname);
    }
    else
    {
        lpitem->aName = 0;
    }

    if (!(*lplpoleobject = (LPOLEOBJECT)AddItem(lpitem)))
        return OLE_ERROR_GENERIC;

    return OLE_OK;
}



/* DocSetHostNames() - Sets the title bar to the correct document name.
 *
 * Note:    The format is "<lpclientName> <app name> - <lpdocName>".
 */
OLESTATUS
DocSetHostNames(
    LPOLESERVERDOC lpoledoc,
    LPSTR lpclientName,
    LPSTR lpdocName
    )
{
    DPRINT("pkg: DocSetHostnames");
    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpdocName);
    StringCchCopy(gszClientName, ARRAYSIZE(gszClientName), lpclientName);

    SetTitle(TRUE);
    return OLE_OK;
}



/* DocSetDocDimensions() - OLE callback to change the document dimensions.
 *
 * Note:    This command is unsupported.  It is the client application's
 *          responsibility to report errors (as needed).
 */
OLESTATUS
DocSetDocDimensions(
    LPOLESERVERDOC lpoledoc,
    LPRECT lprc
    )
{
    DPRINT("pkg: DocSetDocDimensions");
    return OLE_ERROR_GENERIC;
}



/* DocSetColorScheme() - OLE callback to change the document colors.
 *
 * Note:    This command is unsupported.  It is the client application's
 *          responsibility to report errors (as needed).
 */
OLESTATUS
DocSetColorScheme(
    LPOLESERVERDOC lpoledoc,
    LPLOGPALETTE lppal
    )
{
    DPRINT("pkg: DocSetColorScheme");
    return OLE_ERROR_GENERIC;
}



/* DocExecute() - Called to execute DDE commands
 */
OLESTATUS
DocExecute(
    LPOLESERVERDOC lpoledoc,
    HANDLE hCmds
    )
{
    DPRINT("pkg: DocExecute");
    return OLE_ERROR_PROTOCOL;
}



/**************************** Item functions ***************************/
/* ItemDelete() - Free memory associated with the current item.
 */
OLESTATUS
ItemDelete(
    LPOLEOBJECT lpoleobject
    )
{
    DPRINT("pkg: ItemDelete");
    DeleteItem((LPSAMPITEM)lpoleobject);

    return OLE_OK;              /* Add error checking later */
}



/* ItemGetData() - Used by the client to obtain the item data.
 */
OLESTATUS
ItemGetData(
    LPOLEOBJECT lpoleobject,
    OLECLIPFORMAT cfFormat,
    LPHANDLE lphandle
    )
{

    DPRINT("pkg: ItemGetData");
    if ((gpty[CONTENT] == PICTURE) && ((LPPICT)glpobj[CONTENT])->fNotReady)
        return OLE_BUSY;

    if (cfFormat == gcfNative)
    {
        if (*lphandle = GetNative(FALSE))
            return OLE_OK;

    }
    else if (cfFormat == CF_METAFILEPICT)
    {
        if (*lphandle = GetMF())
            return OLE_OK;

    }
    else if (cfFormat == gcfOwnerLink)
    {
        if (*lphandle = GetLink())
            return OLE_OK;
    }

    // Clipboard format not supported
    return OLE_ERROR_GENERIC;
}



/* ItemSetData() - Used by the client to paste data into a server.
 *
 * Read in the embedded object data in Native format.  This will
 * not be called unless we are editing the correct document.
 */
OLESTATUS
ItemSetData(
    LPOLEOBJECT lpoleobject,
    OLECLIPFORMAT cfFormat,
    HANDLE hdata
    )
{
    LPSAMPITEM lpitem = (LPSAMPITEM)lpoleobject;

    DPRINT("pkg: ItemSetData");
    if (cfFormat == gcfNative && !PutNative(hdata))
    {
        SendMessage(ghwndFrame, WM_COMMAND, IDM_NEW, 0L);
        GlobalFree(hdata);

        return OLE_ERROR_GENERIC;
    }

    GlobalFree(hdata);

    return OLE_OK;
}



/* ItemDoVerb() - Play/Edit the object.
 *
 * This routine is called when the user tries to run an object that
 * is wrapped by the packager.
 */
OLESTATUS
ItemDoVerb(
    LPOLEOBJECT lpoleobject,
    UINT wVerb,
    BOOL fShow,
    BOOL fActivate
    )
{

    DPRINT("pkg: ItemDoVerb");
    switch (wVerb)
    {
        case OLE_PLAY:
            if (fShow)
                return (*(lpoleobject->lpvtbl->Show))(lpoleobject, fActivate);
            break;

        case OLE_EDIT:
            if (fShow && fActivate)
            {
                if (gfInvisible)
                {
                    ShowWindow(ghwndFrame, gnCmdShowSave);
                    gfInvisible = FALSE;
                }

                // If iconic, restore the window; then give it the focus.
                if (IsIconic(ghwndFrame))
                    SendMessage(ghwndFrame, WM_SYSCOMMAND, SC_RESTORE, 0L);

                BringWindowToTop(ghwndFrame);
            }

        default:
            break;
    }

    return OLE_OK;
}



/* ItemShow() - Show the item.
 *
 * This routine is called when the user tries to edit an object in a
 * client application, and the server is already active.
 */
OLESTATUS
ItemShow(
    LPOLEOBJECT lpoleobject,
    BOOL fActivate
    )
{
    HWND hwndItem;

    DPRINT("pkg: ItemShow");
    if (fActivate
        && (hwndItem = GetTopWindow(ghwndFrame))
        && (gpty[(hwndItem == ghwndPane[CONTENT])] == NOTHING))
    {
        //
        //  Lets assume that in this case the client has
        //  attempted an InsertObject operation with
        //  the Package class. (5.30.91) v-dougk
        //
        if (gfInvisible)
        {
            ShowWindow(ghwndFrame, SW_SHOW);
            gfInvisible = FALSE;
        }

        BringWindowToTop(ghwndFrame);
    }
    else
    {
        PostMessage(hwndItem, WM_COMMAND, IDD_PLAY, 0L);
    }

    return OLE_OK;
}



/* ItemSetBounds() - Set the item's size.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetBounds(
    LPOLEOBJECT lpoleobject,
    LPRECT lprc
    )
{
    DPRINT("pkg: ItemSetBounds");
    return OLE_ERROR_GENERIC;
}



/* ItemSetTargetDevice() - Changes the target device for item display.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetTargetDevice(
    LPOLEOBJECT lpoleobject,
    HANDLE h
    )
{
    DPRINT("pkg: ItemSetTargetDevice");
    if (h)
        GlobalFree(h);

    return OLE_ERROR_GENERIC;
}



/* ItemEnumFormats() - Enumerate formats which are renderable.
 *
 * This is called by the OLE libraries to get a format for screen display.
 * Currently, only Metafile and Native are supported.
 */
OLECLIPFORMAT
ItemEnumFormats(
    LPOLEOBJECT lpobject,
     OLECLIPFORMAT cfFormat
     )
{
    DPRINT("pkg: ItemEnumFormats");
    if (!cfFormat)
        return CF_METAFILEPICT;

    if (cfFormat == CF_METAFILEPICT)
        return gcfNative;

    return 0;
}



/* ItemQueryProtocol() - Tells whether the given protocol is supported.
 *
 * Returns:  lpoleobject iff the protocol is "StdFileEditing".
 */
LPVOID
ItemQueryProtocol(
    LPOLEOBJECT lpoleobject,
    LPSTR lpprotocol
    )
{
    DPRINT("pkg: ItemQueryProtocol");
    return (!lstrcmpi(lpprotocol, "StdFileEditing") ? lpoleobject : NULL);
}



/* ItemSetColorScheme() - Denotes the palette to be used for item display.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetColorScheme(
    LPOLEOBJECT lpoleobject,
    LPLOGPALETTE lppal
    )
{
    DPRINT("pkg: ItemSetColorScheme");
    return OLE_ERROR_GENERIC;
}



BOOL
IsOleServerDoc(
    LPSTR lpdocname
    )
{
    // 06/11/02 The OLE code path does not execute in XPSP1.  Further, we want to ensure that we are going
    // through the ShellExecute path so that we get the new ShellExecute security warning for
    // the termporary internet directory.  Therefore, we will always return FALSE here, a least for now.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\quickres\registry.c ===
#include "Quickres.h"
#include "tchar.h"

extern HINSTANCE hInstApp;
extern LPQRMONITORINFO pMonitors;
extern INT       iMonitors;
extern WORD      QuickResFlags;
extern WORD      FreqMenuLocation;


#ifdef SAVEFLAGS

//
//****************************************************************************
//
//  CreateQuickResKey(  )
//
//  Create 'Quickres' key in the registry if it doesnt exist
//
//****************************************************************************
//

BOOL CreateQuickResKey( )
{

        HKEY   hKeyOpen;                      // key we try to open
        HKEY   hKeyCreate;                    // key to create: Quickres

        DWORD  RegReturn;                     // for reg APIs
        DWORD  Disposition;

        INT   i;                              // counter

        BOOL   bRet = FALSE;                  // return value



        //
        // Get the key which the QuickRes key will go under
        //

        if(  (RegReturn = RegOpenKeyEx(HKEY_CURRENT_USER,
                                       REGSTR_SOFTWARE,
                                       0,
                                       KEY_CREATE_SUB_KEY,
                                       &hKeyOpen))           == ERROR_SUCCESS )
        {

            //
            // Create my quickres key
            //

            if (RegReturn=RegCreateKeyEx(hKeyOpen,
                                         QUICKRES_KEY,
                                         0,
                                         0,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_SET_VALUE,
                                         NULL,
                                         &hKeyCreate,
                                         &Disposition)       == ERROR_SUCCESS)
            {
                bRet = TRUE;
            }

            RegCloseKey(hKeyOpen);

        }

    return bRet;

}


//
//****************************************************************************
//
//   ReadRegistryValue( LPTSTR, PDWORD, PVOID, PDWORD)
//
//   Read a quickres value from the registry (either modes, flags or BPP)
//
//****************************************************************************
//

BOOL ReadRegistryValue( LPTSTR ValueName, PDWORD KeyType, PVOID Value, PDWORD RegKeySize )
{

    HKEY   hKeyOpen;                              // Reg Key with mode flags
    LONG   RegReturn;                             // ret value for reg APIs
    BOOL   ret=FALSE;                             // return value


    //
    // Try to open the quickres key
    //

    if( (RegReturn=RegOpenKeyEx(HKEY_CURRENT_USER,
                                REGSTR_QUICKRES,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyOpen))           == ERROR_SUCCESS )
    {

        //
        // Try to get the value
        //

        if ( (RegReturn=RegQueryValueEx(hKeyOpen,
                                        ValueName,
                                        NULL,
                                        KeyType,
                                        (LPBYTE)Value,
                                        RegKeySize))      == ERROR_SUCCESS )
        {
            ret = TRUE;
        }

        RegCloseKey(hKeyOpen);

    }

    else
    {
        CreateQuickResKey();
    }

    return ret;
}



//
//****************************************************************************
//
//   SetRegistryValue( UINT, UINT, PVOID, UINT )
//
//   Set requested value (modes, flags, or BPP) in the registry
//
//****************************************************************************
//

VOID SetRegistryValue(LPTSTR ValueName, UINT ValueType, PVOID Value, UINT size)
{

    HKEY   hKeyOpen;                           // Quickres key
    LONG   RegReturn;                          // reg APIs return value


    //
    //  try to open QuickRes key
    //

    if( (RegReturn=RegOpenKeyEx(HKEY_CURRENT_USER,
                                REGSTR_QUICKRES,
                                0,
                                KEY_WRITE,
                                &hKeyOpen))           == ERROR_SUCCESS )

    {

        //
        // Set the value under that key
        //

        RegSetValueEx( hKeyOpen,
                       ValueName,
                       0,
                       ValueType,
                       (LPBYTE)Value,
                       size );

        RegCloseKey(hKeyOpen);

    }

}


#endif  // SAVEFLAGS


//
//****************************************************************************
//
//   SetDevmodeFlags( INT, BOOL )
//
//   Upload value in ModeFlags, and current BPP to registry
//
//****************************************************************************
//

VOID SetDevmodeFlags( INT iDisplay, BOOL ClearAll )
{

#ifdef SAVEFLAGS

    PBYTE  ModeFlags;
    INT    i;
    TCHAR  RegModes[16] = REGDEVMODES;

    //
    //  Alloc  Modes/4 bytes so each mode has 2 bits
    //

    ModeFlags = LocalAlloc ( LPTR, (pMonitors[iDisplay].iModes+3) >> 2 );

    if (ModeFlags)
    {
        if (ClearAll)
        {
            //
            //  Clear out all Mode flags if requested
            //  need to set current mode as the only valid one
            //

            for ( i=0; i < pMonitors[iDisplay].iModes; i++)
            {
                VALIDMODE(&pMonitors[iDisplay].pModes[i]) = MODE_UNTESTED;
            }

        }

        //
        //  Pack valid mode flags into ModeFlags[]
        //

        for ( i=0; i < pMonitors[iDisplay].iModes; i++)
        {
            ModeFlags[i>>2] |= (VALIDMODE(&pMonitors[iDisplay].pModes[i]) << ((i%4)<<1) );
        }


        //
        //  Store modeflags in the registry
        //

        if (iDisplay)
        {
            TCHAR buff[4];

            _itot(iDisplay, buff, 4);
            lstrcat(RegModes, buff);
        }

        SetRegistryValue(RegModes, REG_BINARY,
                         ModeFlags, (pMonitors[iDisplay].iModes+3) >> 2 );


        LocalFree ( ModeFlags );
    }

#endif

}


//
//****************************************************************************
//
//   GetDevmodeFlags( )
//
//   Read value from registry into global variable ModeFlags
//
//****************************************************************************
//

VOID GetDevmodeFlags( INT iDisplay )
{

    INT    i;

#ifdef SAVEFLAGS

    PBYTE  ModeFlags;
    DWORD  KeyType;
    DWORD  SavedBPP;
    DWORD  RegKeySize =  (pMonitors[iDisplay].iModes+3) >> 2 ;
    BOOL   bClear=FALSE;
    TCHAR  RegModes[16] = REGDEVMODES;


    ModeFlags = LocalAlloc ( LPTR, RegKeySize );


    //
    // Try to read value
    //

    if (iDisplay)
    {
        TCHAR buff[4];

        _itot(iDisplay, buff, 4);
        lstrcat(RegModes, buff);
    }

    if ( ReadRegistryValue(RegModes, &KeyType,
                           ModeFlags, &RegKeySize) )
    {

        //
        //  Changing BPP on the fly IS allowed on NT 4.0 - NOT on Win95
        //  NT ONLY : 'Good' modes are still good even if they are different BPP
        //  fShowFreqs is essentially the NT vs Win95 flag.
        //

        if (!fShowFreqs)
        {
            //
            // Make sure user hasnt changed BPP via the desktop applet
            //

            RegKeySize = sizeof( DWORD );


            if (ReadRegistryValue(REGBPP, &KeyType,
                               &SavedBPP, &RegKeySize))
            {

               //
               //  If BPP HAS changed, modeflags is now bogus.
               //  clear the flags.  Tell the user.
               //

               DEVMODE dm;

               GetCurrentDevMode(iDisplay, &dm);

               if ( SavedBPP != BPP(&dm) )
               {

                   bClear=TRUE;
                   MsgBox(IDS_CHANGEDBPP, SavedBPP, MB_OK|MB_ICONEXCLAMATION);

               }
            }

        }
    }
    else
    {

        //
        //  Couldnt read value from registry.
        //  Assume no modes work; clear the flags
        //

        bClear = TRUE;
    }


    if (bClear)
    {
        SetDevmodeFlags( iDisplay, TRUE );
    }

    else
    {
        //
        //  Unpack ModeFlags into a field in each devmode
        //  2 bits per devmode - shift right, and with %11
        //

        for (i=0; i < pMonitors[iDisplay].iModes; i++ )
        {
            VALIDMODE(&pMonitors[iDisplay].pModes[i]) = ((ModeFlags[i>>2]) >> ((i%4)<<1)) & 0x03;
        }

    }

    LocalFree ( ModeFlags );


#else


    //
    //  Not reading from the registry - assign all as untested
    //

    for (i=0; i < pMonitors[iDisplay].iModes; i++ )
    {
        VALIDMODE(&pMonitors[iDisplay].pModes[i]) = MODE_UNTESTED;
    }

#endif

}


//
//****************************************************************************
//
//   SetQuickResFlags( )
//
//   Upload QuickResFlags value to registry
//
//****************************************************************************
//

VOID SetQuickResFlags( )
{

#ifdef SAVEFLAGS

    DWORD BothFlags = (FreqMenuLocation << (8*sizeof(WORD))) | QuickResFlags;

    SetRegistryValue(REGFLAGS, REG_DWORD,
                     &BothFlags, sizeof(DWORD));

#endif

}


//
//****************************************************************************
//
//   GetQuickResFlags( )
//
//   Read value from registry into global QuickResFlags
//
//****************************************************************************
//

VOID GetQuickResFlags( )
{


#ifdef SAVEFLAGS


    DWORD KeyType;
    DWORD RegKeySize=sizeof(DWORD);
    DWORD BothFlags;

    //
    // Try to read value
    //

    if (!ReadRegistryValue(REGFLAGS, &KeyType,
                           &BothFlags, &RegKeySize) )
    {

        //
        // assume a flag value, and create it.
        //

        QuickResFlags = QF_SHOWRESTART | QF_REMMODES;
        FreqMenuLocation= IDD_SUBMENUS;
        SetQuickResFlags();


        #ifdef DONTPANIC

            MsgBox(IDS_DONTPANIC, KEEP_RES_TIMEOUT, MB_OK | MB_ICONEXCLAMATION );

        #endif

    }
    else
    {
        if ( !( FreqMenuLocation = (WORD)(BothFlags >> (8*sizeof(WORD))) ) )
            FreqMenuLocation = IDD_SUBMENUS;

        QuickResFlags = (WORD)(0xFFFF & BothFlags);
    }

    //
    //  Do this always!
    //

    QuickResFlags |= QF_HIDE_4BPP;

#else


#ifdef DONTPANIC

    MsgBox(IDS_DONTPANIC, KEEP_RES_TIMEOUT, MB_OK | MB_ICONEXCLAMATION );

#endif

    QuickResFlags = QF_SHOWRESTART | QF_REMMODES | QF_HIDE_4BPP;


#endif

}


//
//****************************************************************************
//
//   SaveAllSettings( )
//
//   Write QuickResFlags, devmode flags, and BPP to the registry
//
//****************************************************************************
//

VOID SaveAllSettings()
{

    SetQuickResFlags( );

    if (fRememberModes)
    {
        INT iDisplay;

        for (iDisplay = 0; iDisplay < iMonitors; iDisplay++)
        {
            SetDevmodeFlags( iDisplay, FALSE );
        }
    }

    SetRegistryValue(REGBPP, REG_DWORD,
                     &( BPP(&pMonitors[0].pCurrentdm->dm) ), sizeof(DWORD) );

    // FEATURE only pays attention to monitor 0 (is this still necessary?)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\quickres\quickres.c ===
//***************************************************************************
//
//    QuickRes for Windows NT and Windows 9x
//
//    Tray app to change your display resolution quickly.
//
//    written by ToddLa
//
//    03/03/96 - ChrisW : Get to build on NT
//    03/28/96 - MDesai : Finish porting; add submenus with frequencies;
//                        Test for valid devmode.
//    04/23/96 - MDesai : option for 'showing tested modes only'
//    10/01/96 - MDesai : fix all win95-specific bugs
//    11/03/98 - MDesai : 'multimonitor aware'
//    12/02/99 - MDesai : better multimon support
//
//***************************************************************************


#include "QuickRes.h"


PTCHAR szAppName;

HINSTANCE    hInstApp;
HICON        AppIcon;


//
// options, properties, about and exit...
// monitor menu
//

HMENU        MainMenu;
HMENU        MonitorMenu=NULL;

//
// number of monitors/display devices installed
// pointer to monitorinfo struct for each monitor
//

INT              iMonitors;
LPQRMONITORINFO  pMonitors;


//
// Waiting for a Popup - don't process any tray messages
//

BOOL Waiting=FALSE;


//
//  Flags: update registry, show restart modes, sort order
//         also where the freq menu(s) go.
//
WORD QuickResFlags;
WORD FreqMenuLocation;


//
//   Function pointers for NT5
//
FARPROC   lpfnEDSEx=NULL;
FARPROC   lpfnEDD=NULL;


//
//***************************************************************************
//
//  GetResourceString( UINT )
//
//  Load a resource string into a LPTSTR - the memory for the string
//  is dynamically allocated.  The callee must free the memory!
//
//***************************************************************************
//

LPTSTR GetResourceString ( UINT ResourceID )
{


    INT    BuffSize=RESOURCE_STRINGLEN;     // current max size of string
    PTCHAR BigBuf;                          // buffer to find size of resource
    PTCHAR ResBuf;                          // buffer for resource
    INT    len;                             // length of the resource


    while (1)
    {

        //
        //  Allocate hopefully oversized buffer
        //

        if( !(BigBuf= LocalAlloc( LPTR, BuffSize ) ) )
        {
            return NULL;
        }


        //
        //  Try to read string into BigBuf to get its length
        //

        if ( !(len = LoadString(hInstApp, ResourceID, BigBuf, BuffSize)) )
        {
            return NULL;
        }


        //
        //  Buffer is too small - try again.
        //

        if( len >= BuffSize-1 )
        {
            BuffSize <<= 1;
            LocalFree ( BigBuf );
        }

        else
        {

            //
            //  Reallocate properly sized string buffer,
            //  and copy string into it
            //

            len = ( len + 1 ) * sizeof( TCHAR );

            if (ResBuf = LocalAlloc( LPTR, len ))
            {
                lstrcpyn ( ResBuf, BigBuf, len );
            }

            LocalFree ( BigBuf );

            return( ResBuf );

        }

    }

}


//
//***************************************************************************
//
// GetModeName( PDEVMODE, PTCHAR*, PTCHAR* )
//
// Translate devmode into user friendly strings-
// one for resolution and color depth; one for refresh rate
//
//***************************************************************************
//

void GetModeName(PDEVMODE pDevMode, PTCHAR *szMode, PTCHAR *szFreq )
{

    PTCHAR FmtRes=NULL;             // Format strings for
    PTCHAR FmtHz=NULL;              // resolution and Hz


    //
    // Load format string corresponding to devmode
    //

    FmtRes = GetResourceString ( IDS_CRES + BPP(pDevMode) );


    //
    // Use Default Freq string if necessary
    //
    if (fShowFreqs)
    {
        if( HZ(pDevMode) == 0 || HZ(pDevMode) == 1)
        {
            FmtHz = GetResourceString ( IDS_DEFHERTZ );
        }
        else
        {
            FmtHz = GetResourceString ( IDS_HERTZ );
        }
    }

    //
    //  return separate resolution and frequency strings
    //  need to convert "%d"-> "12345", add byte for '\0'
    //

    if (FmtRes)
    {
        if (*szMode = LocalAlloc( LPTR, sizeof(TCHAR)*
                                (lstrlen(FmtRes)+2*INT_FORMAT_TO_5_DIGITS+1 ) ))
        {
            wsprintf(*szMode, FmtRes, XRES(pDevMode), YRES(pDevMode) );
        }

        LocalFree ( FmtRes );
    }


    if (fShowFreqs && FmtHz)
    {

        if (*szFreq = LocalAlloc ( LPTR, sizeof(TCHAR)*
                                   (lstrlen(FmtHz)+INT_FORMAT_TO_5_DIGITS+1) ))
        {
            wsprintf(*szFreq, FmtHz, HZ(pDevMode));
        }

        LocalFree ( FmtHz );
    }

}



//
//***************************************************************************
//
//   GetCurrentDevMode( INT, PDEVMODE )
//
//   Get a pointer to the current devmode into *pDM
//
//***************************************************************************
//

PDEVMODE GetCurrentDevMode(INT iDisplay, PDEVMODE pDM)
{

    UINT uRet=0;

    pDM->dmSize= sizeof(DEVMODE);

    //
    // NT specific; returns current devmode
    //

    if (fShowFreqs)
    {
        uRet = EnumDisplaySettings( pMonitors[iDisplay].DeviceName, (DWORD)ENUM_CURRENT_SETTINGS, pDM);
    }

    if (!uRet)
    {
        //
        //  ENUM_CURRENT_SETTINGS doesnt work on win95
        //  Get current settings via GetDeviceCaps
        //

        HDC  hDC;
        UINT HorzRes;
        UINT VertRes;
        UINT BPP;
        UINT VRefresh;
        UINT Index;

        hDC      =  GetDC( NULL );
        HorzRes  =  GetDeviceCaps( hDC, HORZRES );
        VertRes  =  GetDeviceCaps( hDC, VERTRES );
        BPP      =  GetDeviceCaps( hDC, BITSPIXEL ) * GetDeviceCaps( hDC, PLANES );
        VRefresh =  GetDeviceCaps( hDC, VREFRESH );

        //
        //  Enumerate all settings until one matches our current settings
        //

        for ( Index=0;
              EnumDisplaySettings( pMonitors[iDisplay].DeviceName, Index, pDM);
              Index++ )
        {
            if ( HorzRes ==  XRES(pDM) &&
                 VertRes ==  YRES(pDM) &&
                 BPP     ==  BPP(pDM)
               )
            {
                //
                // if frequency matters, then check for it
                //

                if (!fShowFreqs || (VRefresh == HZ(pDM)) )
                    break;
            }
        }

        ReleaseDC (NULL, hDC);
    }

    return pDM;
}



//
//***************************************************************************
//
//  SetMode( HWND, UINT )
//
//  Set the new devmode and update registry on request using
//  the CDS_UPDATEREGISTRY flag.  If user wants to change and
//  restart, then we need to update the registry and restart.
//
//***************************************************************************
//

BOOL SetMode( HWND hwnd, INT iDisplay, UINT index )
{
    DWORD    CDSret=0;                  // ret value, ChangeDisplaySettings
    DWORD    CDSFlags=0;                // 2nd param of call to CDS
    INT_PTR  DialogBoxRet=0;            // IDYES/NO/ABORT/CANCEL
    LPDEVMODEINFO pSave;                // save ptr in iDisplay to remember orig mode
    LPDEVMODEINFO pdm;                  // new mode to be set
    BOOL     bChange=FALSE;             // changing modes or not
    LPQRMONITORINFO pCurrMon;           // ptr to current monitorinfo strcut


    pCurrMon = &pMonitors[iDisplay];

    //
    //  Save current mode; find ptr to new mode
    //

    pSave = pCurrMon->pCurrentdm;
    pdm   = &(pCurrMon->pModes[index]);

    //
    //  If user wants to update registry
    //

    if( fUpdateReg )
    {
        CDSFlags |= CDS_UPDATEREGISTRY;
    }


    //
    //  Tell CDS what fields may be changing
    //  Also, keep appwndproc from doing anything while we are testing
    //

    pdm->dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY;
    Waiting=TRUE;


    //
    //  Call CDS and update registry on request.  (If it is
    //  a known bad mode give user chance to change his mind.)
    //

    if( (VALIDMODE(pdm) != MODE_INVALID ) ||
           ( MsgBox( IDS_INVALIDMODE, 0, MB_YESNO | MB_ICONQUESTION )==IDYES ) )
    {

        CDSret = ChangeDisplaySettingsEx( pCurrMon->DeviceName, &(pdm->dm), NULL, CDSFlags, 0);

        if (CDSret == DISP_CHANGE_SUCCESSFUL)
        {
            //
            //  Even though it may be temporary, current dm has changed.
            //  Need to reset pCurrentdm to point to new current DM.
            //  Change tooltip to reflect old settings
            //

            pCurrMon->pCurrentdm = pdm;

            TrayMessage(hwnd, NIM_MODIFY, TRAY_ID, AppIcon);

            //
            //  Return value claims that it 'worked.' But, it may not visible
            //  to the user (e.g. the mode is unsupported by the monitor).
            //  If the User has not already approved this new resolution,
            //  then make the user approve the change, or we default back to
            //  the last devmode.
            //

            if ( fGoodMode(pdm) )
            {
                //
                //  VALID or BESTHZ modes - go ahead and change
                //

                bChange = TRUE;
            }

            else
            {
                //
                //  Ask user if it looks okay
                //  Flag the mode based on return value.
                //

                switch( DialogBoxRet = DialogBoxParam( hInstApp,
                                          MAKEINTRESOURCE(KeepNewRes),
                                          NULL,
                                          KeepNewResDlgProc,
                                          iDisplay) )
                {

                                    //
                                    //  There should NOT be a break after
                                    //  IDYES.  Fall thru by design.
                                    //
                    case IDYES:     bChange = TRUE;

                    case IDABORT:   VALIDMODE(pdm) = MODE_VALID;
                                    break;

                    case IDNO:
                    case IDCANCEL:  VALIDMODE(pdm) = MODE_INVALID;
                                    break;

                }   // switch

            }   //  else - MODE_INVALID

        }

        if (CDSret != DISP_CHANGE_SUCCESSFUL)
        {
            //
            // Requires restart.  Ask user if thats okay.
            //

            if (CDSret == DISP_CHANGE_RESTART)
            {

                if ( MsgBox(IDS_RESTART, 0, MB_YESNO | MB_ICONQUESTION) == IDYES )
                {

                    //
                    //  After restart all modes will need to be tested again?
                    //

                    SetDevmodeFlags ( iDisplay, TRUE );


                    //
                    //  Call CDS again to update registry
                    //

                    ChangeDisplaySettingsEx( pCurrMon->DeviceName, &(pdm->dm), NULL,
                                             (CDSFlags | CDS_UPDATEREGISTRY), 0);

                    ExitWindowsEx(EWX_REBOOT, 0);
                }

            }
            else
            {

                 //
                 // Tell user we cannot change to this devmode
                 //

                 MsgBox(IDS_CANTSETMODE, 0, MB_OK | MB_ICONEXCLAMATION);
            }

        }   // end else != DISP_CHANGE_SUCCESSFUL


        if (bChange)
        {
            //
            //  Changing to a valid mode; destroy and rebuild menu
            //  Mark mode we were just in as valid (if it wasnt already)
            //

            VALIDMODE(pSave) |= MODE_VALID;

            //
            //  This is the new "Best Hz" mode.  The old mode is 'only valid'.
            //

            if ((FreqMenuLocation == IDD_ONEMENUMOBILE) ||
                (FreqMenuLocation == IDD_ONEMENUBOTTOM) )
            {
                VALIDMODE(pCurrMon->pCurrentdm) = MODE_BESTHZ;
            }

            DestroyModeMenu( iDisplay, TRUE, FALSE );
        }

        else    // !bChange
        {

            //
            //  Change back to last good devmode; do not have to recheck menuitems
            //

            pCurrMon->pCurrentdm = pSave;


            //
            //  Change back, and reset registry IF we had set it above
            //  Change tooltip to reflect old settings
            //

            if (CDSret != DISP_CHANGE_RESTART)
            {
                ChangeDisplaySettingsEx( pCurrMon->DeviceName, &(pCurrMon->pCurrentdm->dm),
                                         NULL, CDSFlags, 0);
            }

            TrayMessage(hwnd, NIM_MODIFY, TRAY_ID, AppIcon);

        }  // bChange


    }  // endif


    //
    //  Save new settings for this devmode to the registry.
    //  Even if quickres does not exit gracefully, preferences
    //  will be saved.
    //

    if (fRememberModes)
    {
        SaveAllSettings();
    }

    //
    //  Show modemenu again; allow appwndproc to process messages
    //

    if (!bChange)
    {
        SetTimer(hwnd, TRAY_ID, 10, NULL);
    }

    Waiting=FALSE;


    //
    // if Current hasnt changed then we return false
    //

    return (bChange);

}


//
//********************************************************************
//
//  CompareDevmodes ( LPDEVMODEINFO, LPDEVMODEINFO )
//
//  Compares 2 devmodes -
//  Returns 0 if equal, -1 if first > second, +1 if first < second
//
//  msb to lsb: xres, yres, bpp, hertz
//********************************************************************
//

int _cdecl CompareDevmodes( LPDEVMODEINFO pDmi1, LPDEVMODEINFO pDmi2 )
{
    INT compare;
    LPDEVMODE pDm1 = &(pDmi1->dm);
    LPDEVMODE pDm2 = &(pDmi2->dm);


    //
    //  Compare Xs, then Ys, BPP, and Hz.  If !fShowFreqs
    //  then compare only Xs, Ys, and BPP.
    //

    if ( !fSortByBPP || ((compare= BPP(pDm1) - BPP(pDm2)) == 0))
    {
        if( (compare= ( XRES(pDm1) - XRES(pDm2) ) ) == 0 )
        {
            if( (compare= ( YRES(pDm1) - YRES(pDm2) ) ) == 0 )
            {
                if ( fSortByBPP || ((compare= BPP(pDm1) - BPP(pDm2)) == 0))
                {
                   compare = fShowFreqs ? (HZ(pDm1) - HZ(pDm2))  :  0;
                }
            }
        }
    }

    //
    //  Set return value as -1, 0, or 1 only
    //

    if( compare < 0)
    {
        compare= -1;
    }

    else
    {
        if( compare > 0 )
        {
            compare= 1;
        }
    }

    return( compare );

}


//
//********************************************************************
//
//  CheckMenuItemCurrentMode ( INT )
//
//  Traverse all menu items and check the Hz value corresponding
//  to the current mode.  Also, highlight the current resolution/
//  BPP as defaultmenuitem
//
//********************************************************************
//

void CheckMenuItemCurrentMode( INT iDisplay )
{

    int i;                          //  counter
    DEVMODEINFO dmi;                //  temporary storage for current DM
    LPQRMONITORINFO lpqrmi;         //  temporary ptr
    HMENU hMenu;                    //  Frequency submenu for a given Res/BPP
    UINT  MenuItem;                 //  Menu item for exact devmode
    DWORD dwSta;                    //  returns status variable



    lpqrmi = &pMonitors[iDisplay];

    //
    // Need a pointer to the current devmode.  This function will search
    // pModes trying to match the devmode pointed to by pCurrentdm.
    // After the 1st time through, pCurrentdm will be a ptr IN pModes
    //

    if (!lpqrmi->pCurrentdm)
    {
        //
        // Get current devmode
        //

        GetCurrentDevMode(iDisplay, &(dmi.dm));
        lpqrmi->pCurrentdm = &dmi;
    }


    //
    // Uncheck all menu items
    //

    for( i=0; i<lpqrmi->iModes; i++ )
    {

        hMenu = lpqrmi->FreqMenu[FREQMENU( &lpqrmi->pModes[i] )];

        MenuItem= MENUITEM( &lpqrmi->pModes[i] );

        //
        //  Uncheck the Hz in the FreqMenu (if applicable); uncheck item on mode menu
        //

        if (hMenu)
        {
            dwSta= CheckMenuItem(hMenu, MenuItem, MF_BYCOMMAND|MF_UNCHECKED);
            CheckMenuItem(lpqrmi->ModeMenu, FREQMENU( &lpqrmi->pModes[i] ), MF_BYPOSITION  | MF_UNCHECKED );
        }

        CheckMenuItem(lpqrmi->ModeMenu, MenuItem, MF_BYCOMMAND  | MF_UNCHECKED );
    }



    //
    // Check the current one
    //

    for( i=0; i<lpqrmi->iModes; i++ )
    {

        //
        // Go through the array looking for a match of the current devmode
        //

        if( ( CompareDevmodes( lpqrmi->pCurrentdm, &lpqrmi->pModes[i] ) ) == 0 )
        {

            //
            //  Found it!
            //  Get the menu item ID for this devmode and which
            //  frequency submenu it is a part of.
            //

            hMenu = lpqrmi->FreqMenu[FREQMENU( &lpqrmi->pModes[i] )];
            MenuItem= MENUITEM( &lpqrmi->pModes[i] );


            //
            // Save this ptr in the pCurrentdm variable
            // check menu item on mode menu and check mode
            // on frequency submenu (if applicable)
            //

            lpqrmi->pCurrentdm = &lpqrmi->pModes[i];

            if (hMenu)
            {
                dwSta= CheckMenuItem(hMenu, MenuItem, MF_BYCOMMAND|MF_CHECKED);
                CheckMenuItem(lpqrmi->ModeMenu, FREQMENU(&lpqrmi->pModes[i]), MF_BYPOSITION | MF_CHECKED );
            }
            else
            {
                CheckMenuItem(lpqrmi->ModeMenu, MenuItem, MF_BYCOMMAND  | MF_CHECKED );
            }

            break;
        }
    }
}


//
//********************************************************************
//
//   DestroyModeMenu( INT iDisplay, BOOL bRebuild, BOOL bNeedtoSort )
//
//   Free all frequency submenus and the mode menu
//
//********************************************************************
//

void DestroyModeMenu( INT iDisplay, BOOL bRebuild, BOOL bNeedtoSort)
{

    int i;
    LPQRMONITORINFO lpqrmi;         //  temporary ptr



    lpqrmi = &pMonitors[iDisplay];

    //
    //  Free all frequency submenus
    //

    for ( i = 0; i < lpqrmi->iModes; i++ )
    {

        if (IsMenu(lpqrmi->FreqMenu[i]))
        {
            DestroyMenu( lpqrmi->FreqMenu[i] );
            lpqrmi->FreqMenu[i] = NULL;
        }

    }


    //
    //  Free the mode menu (resolutions/BPP)
    //

    if (lpqrmi->ModeMenu)
    {
        DestroyMenu(lpqrmi->ModeMenu);
        lpqrmi->ModeMenu = NULL;

        if (iMonitors==1)
        {
            DestroyMenu(MonitorMenu);
            MonitorMenu = NULL;
        }
    }


    if (bRebuild)
    {
        lpqrmi->ModeMenu = GetModeMenu( iDisplay, bNeedtoSort );

        if (iMonitors==1)
        {
            MonitorMenu = lpqrmi->ModeMenu;
            AppendMainMenu();
        }
        else
        {
            //  If ModifyMenu replaces a menu item that opens a drop-down menu or submenu, the
            //  function destroys the old drop-down menu/submenu & frees the memory used by it.

            ModifyMenu( MonitorMenu, iDisplay, MF_BYPOSITION | MF_POPUP, (UINT_PTR)lpqrmi->ModeMenu,
                        (pMonitors[iDisplay].bPrimary ? pMonitors[iDisplay].PrimaryMonitorName : pMonitors[iDisplay].MonitorName) );
        }
    }
}


//
//********************************************************************
//
//   HandleFreqMenu( )
//
//   Either append submenu to res/bpp, save it for later, or
//   ditch it and put all Hz entries on mode menu.
//   If there is only one Hz for a given Res, we dont need it.
//
//********************************************************************
//
VOID HandleFreqMenu( INT iDisplay, int FreqCount, int ResCounter, int pFirst)
{

    PTCHAR Res=NULL;
    PTCHAR Hz=NULL;
    LPQRMONITORINFO lpqrmi;         //  temporary ptr


    lpqrmi = &pMonitors[iDisplay];
    GetModeName(&lpqrmi->pModes[pFirst].dm, &Res, &Hz);

    //
    //  Dont use submenus if there is only 1 Hz
    //  This is always true when freqmenulocation==IDD_ALLMODEMENU
    //  OR not showing frequency menus
    //  Concatenate Res & Hz into one string (IF fShowFreqs)
    //

    if ( FreqCount == 1 )
    {
        if (fShowFreqs)
        {
            PTCHAR ResHz;

            if (ResHz=LocalAlloc( LPTR, sizeof(TCHAR)*
                              (lstrlen(Res)+lstrlen(Hz)+1) ))
            {
                wsprintf(ResHz,TEXT("%s%s"),Res,Hz);
                AppendMenu(lpqrmi->ModeMenu, MF_STRING,
                           (iDisplay+1)*MENU_RES+pFirst, ResHz);
            }

            LocalFree(ResHz);
        }
        else
        {
            AppendMenu(lpqrmi->ModeMenu, MF_STRING,
                       (iDisplay+1)*MENU_RES+pFirst, Res);
        }
    }

    else
    {
        int i=0;
        int nAppended=0;

        //
        //  Create Popup and append all Hz strings
        //  Append FreqCount items, possibly skipping over some modes
        //

        lpqrmi->FreqMenu[ResCounter] = CreatePopupMenu();

        for (i=0; nAppended < FreqCount; i++)
        {

            PTCHAR LoopRes=NULL;
            PTCHAR LoopHz=NULL;

            //
            //  Skip untested modes if requested.  FreqCount does NOT
            //  include skipped modes, so we count up with nAppended, not i.
            //

            if ( !fShowTestedModes || fGoodMode(&lpqrmi->pModes[pFirst+i]) )
            {

                GetModeName(&lpqrmi->pModes[pFirst+i].dm,&LoopRes,&LoopHz);
                AppendMenu(lpqrmi->FreqMenu[ResCounter],MF_STRING,
                           (iDisplay+1)*MENU_RES+pFirst+i,LoopHz);
                nAppended++;

                LocalFree(LoopRes);
                LocalFree(LoopHz);
                LoopRes=NULL;
                LoopHz=NULL;
            }
        }


        //
        //  Hang menu off side of each bpp/res
        //

        if (FreqMenuLocation == IDD_SUBMENUS)
        {
            AppendMenu(lpqrmi->ModeMenu,MF_POPUP,
                       (UINT_PTR)lpqrmi->FreqMenu[ResCounter],Res);
        }

        else
        {
            //
            //  Only show submenu for the current mode
            //  Use BESTHZ mode or the VALID mode with the
            //  lowest frequency.
            //

            if ( (FreqMenuLocation == IDD_ONEMENUMOBILE) ||
                 (FreqMenuLocation == IDD_ONEMENUBOTTOM) )
            {

                int BestHz=0;
                int index;

                //
                //  Start with highest freq (pFirst+i-1)
                //  and work down to pFirst looking for BestHz.
                //  if we find BESTHZ use that one, else
                //  use last VALIDMODE we get before loop ends
                //

                for (index=pFirst+i-1 ; index >= pFirst; index--)
                {
                    if ( VALIDMODE(&lpqrmi->pModes[index]) == MODE_BESTHZ )
                    {
                        BestHz = index;
                        break;
                    }
                    else
                    {
                        if (VALIDMODE(&lpqrmi->pModes[index])!=MODE_INVALID)
                        {
                            BestHz = index;
                        }
                    }
                }

                //
                //  No valid/besthz modes.  Use smallest Hz for that Res
                //

                if (!BestHz)
                {
                    BestHz = pFirst;
                }

                AppendMenu(lpqrmi->ModeMenu,MF_STRING,
                           (iDisplay+1)*MENU_RES+BestHz,Res);
            }
        }
    }

    LocalFree(Res);
    LocalFree(Hz);

}


//
//********************************************************************
//
//   GetModeMenu( INT, BOOL )
//
//   Build the mode menu with each resolution/BPP having a
//   pointer to its own frequency submenu
//
//********************************************************************
//

HMENU GetModeMenu ( INT iDisplay, BOOL bNeedtoSort )
{

    int  n;                        // counter
    BOOL bMajorChange=FALSE;       // change in the major sort order field
    BOOL bMinorChange=FALSE;       // change in the minor sort order field
    int  FreqCount=0;             // number of freqs on the current submenu
    int  ResCounter=0;            // Res/Color defines the freqmenu #
    INT   FirstMode=-1;            // index in pmodes; 1st mode for given res/bpp
    LPQRMONITORINFO lpqrmi;        //  temporary ptr



    lpqrmi = &pMonitors[iDisplay];


    if (!lpqrmi->ModeMenu)
    {
        lpqrmi->ModeMenu = CreatePopupMenu();


        if (bNeedtoSort)
        {
            qsort( (void*)  lpqrmi->pModes,
                   (size_t) lpqrmi->iModes,
                   (size_t) sizeof(DEVMODEINFO),
                   ( int (_cdecl*)(const void*,const void*) ) CompareDevmodes );

            lpqrmi->pCurrentdm = NULL;
        }


        //
        // For each devmode, add res/color to menu.
        // Make a submenu of frequencies for each res/color
        //

        for (n=0; n < lpqrmi->iModes; n++)
        {
            LPDEVMODEINFO  pDM = &lpqrmi->pModes[n];

            //
            // Tested successfully or might require restart
            //

            if ( ( (CDSTEST(pDM) == DISP_CHANGE_SUCCESSFUL) ||
                   (fShowModesThatNeedRestart && (CDSTEST(pDM) == DISP_CHANGE_RESTART)) ) &&

                 ( !fShowTestedModes || fGoodMode(pDM) )     )
            {


                //
                //  Check for change in the major/minor sort item
                //  *only after we 'initialize' firstmode below
                //

                if (FirstMode == -1)
                {

                //
                //  First time thru, initialize FirstMode,counter
                //

                    FirstMode = n;
                    FreqCount=0;

                }

                else
                {
                    if( BPP(&lpqrmi->pModes[FirstMode].dm) != BPP(&pDM->dm) )
                    {
                        bMajorChange = fSortByBPP;
                        bMinorChange = !fSortByBPP;
                    }

                    if( ( XRES(&lpqrmi->pModes[FirstMode].dm) != XRES(&pDM->dm) ) ||
                        ( YRES(&lpqrmi->pModes[FirstMode].dm) != YRES(&pDM->dm) ) )
                    {
                        bMajorChange |= !fSortByBPP;
                        bMinorChange |= fSortByBPP;
                    }


                    //
                    //  The BPP and/or the Resolution changed.
                    //

                    if ( bMajorChange || bMinorChange )
                    {

                        //
                        //  Appends a Res/BPP and a submenu if applicable
                        //

                        HandleFreqMenu(iDisplay,FreqCount,ResCounter,FirstMode);
                        ResCounter++;

                        //
                        //  Need a separator when major sort item changes
                        //

                        if ( bMajorChange )
                        {
                            AppendMenu(lpqrmi->ModeMenu,MF_SEPARATOR,0,NULL);
                            ResCounter++;
                        }


                        //
                        // n is first mode for the new res/bpp
                        // reset counter, flags
                        //

                        FirstMode  = n;
                        FreqCount= 0;
                        bMajorChange = FALSE;
                        bMinorChange = FALSE;
                    }
                }


                //
                //  Fill in fields for this mode; inc freqcount
                //


                MENUITEM( pDM ) = (iDisplay+1)*MENU_RES+n;
                FREQMENU( pDM ) = ResCounter;
                FreqCount++;


                //
                //  ALLMODEMENU - Force menu append every time
                //

                if (FreqMenuLocation == IDD_ALLMODEMENU)
                {
                   bMinorChange = TRUE;
                }


            }

        }  // end for


        //
        //  NO VALID MODES!!!  Certainly the current mode should be valid.  Make
        //  this mode VALID. Setup FreqCount, FirstMode for the last HandleFreqMenu
        //

        if (FirstMode == -1)
        {
            DEVMODEINFO DisplayModeInfo;

            DisplayModeInfo.dm.dmSize= sizeof(DEVMODE);
            GetCurrentDevMode(iDisplay, &DisplayModeInfo.dm);

            for (n=0;
                 CompareDevmodes(&DisplayModeInfo,&lpqrmi->pModes[n]) != 0;
                 n++ )
            {
            }

            VALIDMODE(&lpqrmi->pModes[n]) = MODE_BESTHZ;
            FirstMode = n;
            FreqCount = 1;

        }


        //
        //  Handle the FreqMenu for the last Res/BPP.
        //

        HandleFreqMenu(iDisplay,FreqCount,ResCounter,FirstMode);


        //
        //  Update menu checks; mode status
        //

        CheckMenuItemCurrentMode( iDisplay );


        //
        //  Put Hz menu next to current mode, or at the bottom
        //

        if (FreqMenuLocation == IDD_ONEMENUMOBILE)
        {
            MENUITEMINFO mii;

            ZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU;
            mii.hSubMenu = lpqrmi->FreqMenu[FREQMENU(lpqrmi->pCurrentdm)];
            SetMenuItemInfo(lpqrmi->ModeMenu, FREQMENU(lpqrmi->pCurrentdm), MF_BYPOSITION, &mii);
        }

        else
        {

            if (FreqMenuLocation == IDD_ONEMENUBOTTOM)
            {
                PTCHAR szRefRate;
                UINT flags=MF_POPUP;

                szRefRate = GetResourceString(IDS_REFRESHRATE);

                if ( !lpqrmi->FreqMenu[FREQMENU(lpqrmi->pCurrentdm)] )
                {
                    flags = MF_GRAYED;
                }

                AppendMenu(lpqrmi->ModeMenu,MF_SEPARATOR,0,NULL);
                AppendMenu(lpqrmi->ModeMenu, flags,
                           (UINT_PTR)lpqrmi->FreqMenu[FREQMENU(lpqrmi->pCurrentdm)],
                           szRefRate);

                LocalFree(szRefRate);
            }
        }
    }

    return (lpqrmi->ModeMenu);
}


//
//********************************************************************
//
//   AppendMainMenu( VOID )
//
//   Append main menu (from .rc file) to monitor menu
//
//********************************************************************
//

VOID AppendMainMenu()
{

#ifdef MAINWITHMODE

    int  n;                        // counter

    //
    //  Add main menu to bottom of mode menu.  These menu
    //  items come from MainMenu as defined in .rc file
    //

    AppendMenu(MonitorMenu,MF_SEPARATOR,0,NULL);

    for (n=0; n < GetMenuItemCount(MainMenu); n++)
    {

        MENUITEMINFO mii;

        //
        //  Set up mii struct to retrieve the length of
        //  each menu item string via GetMenuItemInfo().
        //

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;

        mii.cch = GetMenuString(MainMenu, n, NULL, 0, MF_BYPOSITION) +1;

        //
        //  Allocate enough memory and read in the string.
        //

        if (mii.dwTypeData = LocalAlloc( LPTR, mii.cch*sizeof(TCHAR) ))
        {

            //
            //  Read in the string, get it's ID and append to the menu
            //

            if (GetMenuString(MainMenu, n, mii.dwTypeData, mii.cch,MF_BYPOSITION))
            {
                mii.wID=GetMenuItemID(MainMenu, n);

                AppendMenu(MonitorMenu, MF_STRING, mii.wID, mii.dwTypeData);
            }

            LocalFree(mii.dwTypeData);
        }
    }

    SetMenuDefaultItem(MonitorMenu,MENU_PROPERTIES,MF_BYCOMMAND);

#endif

}


//
//********************************************************************
//
//   GetMonitorMenu( BOOL )
//
//   Build all mode menus with each resolution/BPP having a
//   pointer to its own frequency submenu
//
//********************************************************************
//

HMENU GetMonitorMenu ( BOOL bNeedtoSort )
{


    if (!MonitorMenu)
    {
        //
        //  Use Modemenu of iDisplay==0 as the monitor menu
        //

        if (iMonitors == 1)
        {
            MonitorMenu = GetModeMenu(0, bNeedtoSort);
        }
        else
        {
            INT    iDisplay;

            MonitorMenu = CreatePopupMenu();

            for (iDisplay=0; iDisplay < iMonitors; iDisplay++)
            {
                //
                //  append each monitor name to the main monitor menu
                //

                AppendMenu( MonitorMenu, MF_POPUP,
                            (UINT_PTR)GetModeMenu(iDisplay, bNeedtoSort),
                            (pMonitors[iDisplay].bPrimary ? pMonitors[iDisplay].PrimaryMonitorName : pMonitors[iDisplay].MonitorName) );
            }

        }

        AppendMainMenu();

    }

    return MonitorMenu;
}



//
//********************************************************************
//
//   SetMonitorDeviceInfo( BOOL bFirstTime )
//
//   Set monitor info fields : primary?  attached?
//   and the correct monitor name, based on bPrimary
//
//********************************************************************
//
BOOL SetMonitorDeviceInfo( BOOL bFirstTime )
{
    BOOL    bFoundPrimary=FALSE;
    BOOL    bChange=FALSE;
    PTCHAR  szMonitorRes;
    int     iDisplay;
    int     n;
    DISPLAY_DEVICE DispDev;



    if ( (iMonitors > 1) && (lpfnEDD) )
    {

        szMonitorRes = GetResourceString(IDS_MONITOR);

        DispDev.cb = sizeof(DispDev);

        iDisplay=0;

        for ( n=0; (lpfnEDD)(NULL, n, &DispDev, 0); n++ )
        {

            if ( !(DispDev.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) )
            {

                DWORD dwSize;
                TCHAR index[8];

                //
                //  For each display, get the monitor name, primary monitor name, & Device name
                //  Alloc enough memory for MonitorName string to have up to 3 digits for the monitor index.
                //

                if (DispDev.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                {
                    bChange |= (pMonitors[iDisplay].bPrimary != TRUE);
                    pMonitors[iDisplay].bPrimary = TRUE;
                    bFoundPrimary=TRUE;
                }
                else
                {
                    bChange |= (pMonitors[iDisplay].bPrimary != FALSE);
                    pMonitors[iDisplay].bPrimary = FALSE;
                }

                //
                //  Allocation sizes, device name, and primarymonitorname all never change
                //

                if (bFirstTime)
                {
                    pMonitors[iDisplay].DeviceName  = GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(DispDev.DeviceName)+1));
                    pMonitors[iDisplay].MonitorName = GlobalAlloc( GPTR, sizeof(TCHAR)*dwSize );
                    pMonitors[iDisplay].PrimaryMonitorName = GlobalAlloc( GPTR, sizeof(TCHAR)*dwSize );
                }

                // Memory allocation failed we can't continue
                if (!pMonitors[iDisplay].DeviceName || 
                    !pMonitors[iDisplay].MonitorName || 
                    !pMonitors[iDisplay].PrimaryMonitorName)
                    return FALSE;

                if (bFirstTime)
                {
                    lstrcpy(pMonitors[iDisplay].DeviceName, DispDev.DeviceName);

                    dwSize = lstrlen(DispDev.DeviceString) + lstrlen(szMonitorRes);
                    dwSize += lstrlen(TEXT("Primary"));

                    wsprintf( pMonitors[iDisplay].PrimaryMonitorName, szMonitorRes,
                                  TEXT("Primary "), TEXT(""), DispDev.DeviceString );

                    bChange = TRUE;
                }


                //  this ensures we always have primary, 2,3,4, etc. (never a monitor 0 or 1)
                //

                _itot( (iDisplay + (bFoundPrimary ? 1 : 2)),index,8);
                lstrcat(index,TEXT(" "));

                wsprintf( pMonitors[iDisplay].MonitorName, szMonitorRes,
                          TEXT(""), index, DispDev.DeviceString);


                bChange |= (pMonitors[iDisplay].bAttached != (BOOL)(DispDev.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP));
                pMonitors[iDisplay].bAttached = (DispDev.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP);

                iDisplay++;
            }

            DispDev.cb = sizeof(DispDev);   // always reset before next call to be safe
        }

        LocalFree(szMonitorRes);

        if (!bFirstTime)
        {
            for (n=0; n< iMonitors; n++)
            {
                ModifyMenu( MonitorMenu, n, MF_BYPOSITION | MF_POPUP, (UINT_PTR)pMonitors[n].ModeMenu,
                           (pMonitors[n].bPrimary ? pMonitors[n].PrimaryMonitorName : pMonitors[n].MonitorName));
            }
        }
    }

    return bChange;
}



//
//********************************************************************
//
//   BuildMonitorArray( )
//
//   Allocate & fill in a monitorinfo struct for each display device
//
//********************************************************************
//

BOOL BuildMonitorArray( )
{

    int            iDisplay;
    DISPLAY_DEVICE DispDev;



    //
    // Find the number of monitors/displaydevices
    // alloc a monitorinfo struct per monitor
    //

    iMonitors = 1;
    //    getSysMet != EnumDispDevices!!!  (netmtg, etc.)
    //    iMonitors = max(GetSystemMetrics(SM_CMONITORS),1);


    //
    //  EDSEx is win98 & NT5 only -- the ones with multimonitor, the check for EDD is just to
    //  check that we have the api we're going to call.  win95 osr2.5/NT4 are single-mon only
    //

    if (lpfnEDSEx && lpfnEDD)
    {
        DispDev.cb = sizeof(DispDev);

        iMonitors=0;
        for (iDisplay=0; (lpfnEDD)(NULL, iDisplay, &DispDev, 0); iDisplay++)
        {
            if ( !(DispDev.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) )
            {
                iMonitors++;
            }
        }
    }

    pMonitors = GlobalAlloc(GPTR, iMonitors*sizeof(QRMONITORINFO));


    if (pMonitors)
    {
        //
        //  On a multimon system, get the display device info --
        //     monitor and device names + primary?  and attached?
        //

        if ( (iMonitors > 1) && (lpfnEDD) )
        {
            SetMonitorDeviceInfo( TRUE );
        }
        else
        {
            pMonitors[0].DeviceName  = NULL;
            pMonitors[0].MonitorName = NULL;
            pMonitors[0].PrimaryMonitorName = NULL;
        }
    }
    else
    {
        iMonitors = 0;
    }

    return pMonitors != NULL;
}



//
//********************************************************************
//
//   BuildDevmodeLists( )
//
//   Enumerate all devmodes for each display device into an array.
//   Sort them, remove duplicates, and filter out 4bpp modes
//   Create a popup menu for each display device (put all modes
//   on the main menu if it is a single monitor machine)
//
//********************************************************************
//

BOOL BuildDevmodeLists( )
{

    DEVMODE   DisplayMode;      // temporary devmode storage
    BOOL      bShrink=FALSE;    // set if iModes ever decreases
    int       nModes,
              n,
              iDisplay;         // counters

    LPDEVMODEINFO    lpdm;
    LPQRMONITORINFO  lpqrmi;



    DisplayMode.dmSize= sizeof(DEVMODE);

    //
    //   Fill in each display's/monitor's mode list
    //

    for (iDisplay=0; iDisplay < iMonitors; iDisplay++)
    {
        DWORD dwFlags = 0;

        lpqrmi = &pMonitors[iDisplay];

        lpqrmi->ModeMenu = NULL;
        lpqrmi->FreqMenu = NULL;
        lpqrmi->iModes = 0;
        lpqrmi->pModes = NULL;
        lpqrmi->pCurrentdm = NULL;


        //
        // Find the number of modes known by driver for each monitor
        //

        if (lpfnEDSEx)
        {
            for( nModes=0; (lpfnEDSEx)(pMonitors[iDisplay].DeviceName, nModes, &DisplayMode, dwFlags); nModes++)
                ;
        }
        else
        {
            for( nModes=0; EnumDisplaySettings(pMonitors[iDisplay].DeviceName, nModes, &DisplayMode); nModes++)
                ;
        }

        //
        // Get space for all modes
        //

        lpqrmi->pModes = (LPDEVMODEINFO) GlobalAlloc( GPTR, nModes*sizeof(DEVMODEINFO) );
        lpdm = lpqrmi->pModes;

        if( !lpdm )
        {
            DestroyModeMenu( iDisplay, FALSE, FALSE );
            return FALSE;
        }


        //
        //  Get all display modes into the pModes array
        //

        for( n=0; n<nModes; n++ )
        {
            lpdm[n].dm.dmSize= sizeof(DEVMODE);

            //
            // Get next mode into next spot in pModes
            //

            if (lpfnEDSEx)
            {
                (lpfnEDSEx)(pMonitors[iDisplay].DeviceName, n, &lpdm[n].dm, dwFlags );
            }
            else
            {
                EnumDisplaySettings(pMonitors[iDisplay].DeviceName, n, &lpdm[n].dm );
            }


            //
            //  If any Hz is NOT 0 or 1 (default), then turn on Freq flag.
            //  This will be true on NT.  Win95 will always return 0 or 1.
            //

            if ( HZ(&lpdm[n].dm)  &&  (HZ(&lpdm[n].dm) != 1) )
                QuickResFlags |= QF_SHOWFREQS;
        }


        //
        // sort them according to QF_SORTBYBPP :
        //  (1) BPP X Y HZ  or   (2) X Y BPP HZ
        //

        qsort( (void*)  lpdm,
               (size_t) nModes,
               (size_t) sizeof(DEVMODEINFO),
               ( int (_cdecl*)(const void*,const void*) ) CompareDevmodes );


        //
        //   Filter out any duplicate devmodes return by the driver
        //   and any modes with x resolution < 640 pixels.  We dont
        //   want to show ModeX modes (320x200, 320x240, etc.)
        //

        if (nModes > 1 )
        {

            for (n=0; n+1 < nModes; )
            {

                if (XRES(&lpdm[n].dm) < 640)
                {
                    nModes--;
                    bShrink = TRUE;
                    MoveMemory( &lpdm[n],
                                &lpdm[n+1],
                                (nModes-n)*sizeof(DEVMODEINFO) );
                }
                else
                {
                    //
                    //  If consecutive devmodes are identical, then copy the next
                    //  one over the dup and decrement iModes (# of devmodes).
                    //

                    while ( CompareDevmodes(&lpdm[n],&lpdm[n+1]) == 0 )
                    {
                        //
                        //  Don't go past the last devmode
                        //

                        if (n+2 < nModes--)
                        {
                            bShrink = TRUE;
                            MoveMemory( &lpdm[n],
                                        &lpdm[n+1],
                                        (nModes-n)*sizeof(DEVMODEINFO) );
                        }
                        else
                        {
                            break;
                        }
                    }

                    n++;
                }
            }
        }


        //
        // Check CDS return value for all modes and eliminate all 4bpp
        // modes that have a corresponding 8bpp mode at the same res
        //

        for (n=0; n < nModes; n++)
        {

            CDSTEST(&lpdm[n]) = (WORD)ChangeDisplaySettingsEx( lpqrmi->DeviceName, &lpdm[n].dm,
                                                                    NULL, CDS_TEST, 0);

            //
            //  Filter out all 4BPP modes that have an 8BPP mode at the same resolution
            //

            if (BPP(&lpdm[n].dm)==8)
            {
                INT i;

                for (i=0; i < n; )
                {

                    if ( (BPP (&lpdm[i].dm) == 4)    &&
                         (XRES(&lpdm[n].dm) == XRES(&lpdm[i].dm)) &&
                         (YRES(&lpdm[n].dm) == YRES(&lpdm[i].dm))    )
                    {
                        nModes--;
                        bShrink = TRUE;
                        MoveMemory( &lpdm[i],
                                    &lpdm[i+1],
                                    (nModes-i)*sizeof(DEVMODEINFO) );
                        n--;
                    }
                    else
                    {
                        i++;
                    }
                }
            }
        }

        //
        //  nModes might have decreased; might as well free up some memory.
        //  Note that iModes could NOT have increased, so the ReAlloc will be okay.
        //

        if (bShrink)
        {
            lpqrmi->pModes = (LPDEVMODEINFO) GlobalReAlloc(lpqrmi->pModes,
                                                           nModes*sizeof(DEVMODEINFO),
                                                           GMEM_MOVEABLE );
        }

        lpqrmi->iModes = nModes;

        //
        //  At most, we need 1 freqmenu per mode (actually it's always < #modes.)
        //  Note : separators take up 1 (unused) hmenu in the array, so it would
        //  that we need hmenus > #modes, when "all modes on main menu".  But,
        //  in that case, we dont use the freq submenus at all. :)
        //

        lpqrmi->FreqMenu = (HMENU*) GlobalAlloc(GPTR,nModes*sizeof(HMENU));
        for (n=0; n < nModes; n++)
        {
            lpqrmi->FreqMenu[n] = NULL;
        }


        //
        //  Get modeflags from registry or zero out modeflags[]
        //

        GetDevmodeFlags(iDisplay);


        //
        //  Call GetModeMenu to put all strings/popups in place
        //  Current mode will be the best until user changes it.
        //

        GetModeMenu( iDisplay, FALSE );

        VALIDMODE(lpqrmi->pCurrentdm) = MODE_BESTHZ;

    }

    return TRUE;
}


//
//********************************************************************
//
//   DestroyDevmodeLists( )
//
//   free all the memory allocated for modes and menus for each device
//
//********************************************************************
//

BOOL DestroyDevmodeLists()
{

    int              iDisplay;
    LPQRMONITORINFO  lpqrmi;



    for (iDisplay=0; iDisplay < iMonitors; iDisplay++)
    {

        lpqrmi = &pMonitors[iDisplay];

        //
        //  DestroyModeMenu has freed all the individual menus in this array for us
        //

        if (lpqrmi->FreqMenu)
        {
            GlobalFree(lpqrmi->FreqMenu);
            lpqrmi->FreqMenu = NULL;
        }

        if (lpqrmi->pModes)
        {
            GlobalFree(lpqrmi->pModes);
            lpqrmi->pModes = NULL;
        }

        lpqrmi->iModes = 0;
        lpqrmi->pCurrentdm = NULL;

    }

    return TRUE;
}



//
//********************************************************************
//
//   DoProperties( )
//
//   Calls the control panel applet to show 'Display Properties'
//   specifically the display settings
//
//********************************************************************
//

void DoProperties( )
{
    STARTUPINFO          si;
    PROCESS_INFORMATION  pi;
    TCHAR lpszProperties[64] = DISPLAYPROPERTIES;

    GetStartupInfo( &si );


    //
    // Start it up.
    //

    if (CreateProcess(NULL, lpszProperties, NULL, NULL, FALSE,
                      0,    NULL,           NULL, &si,  &pi))
    {


        //
        //  Dont care what wait return value is, but we want
        //  to 'disable' tray icon for a minute or until the
        //  user kills desk.cpl
        //

        WaitForSingleObject( pi.hProcess, 60*1000 );


        CloseHandle ( pi.hThread );
        CloseHandle ( pi.hProcess );
    }
}


//
//********************************************************************
//
//   AppWndProc(HWND, UINT, WPARAM, LPARAM)
//
//   Main window proc to process messages
//
//********************************************************************
//

LRESULT CALLBACK AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    POINT pt;                  // Get cursor pos for the menu placement
    INT   i;

    switch (msg)
    {

        case WM_CREATE:

            //
            //   Add icon to tray next to time
            //

            TrayMessage(hwnd, NIM_ADD, TRAY_ID, AppIcon);

            break;


        case WM_DESTROY:

            //
            //   Remove icon from tray.
            //

            TrayMessage(hwnd, NIM_DELETE, TRAY_ID, NULL );

            PostQuitMessage(0);

            break;


        case WM_DISPLAYCHANGE:

            //
            //  New settings.  Reset pCurrentdm as index in pModes
            //  No need to destroy/rebuild the mode menu, but bPrimary,
            //  bAttached may have changed.
            //
            //  The Waiting flag makes this a no-op, when its a qres-initiated change
            //

            if (!Waiting)
            {
                for (i=0; i<iMonitors; i++)
                {
                    pMonitors[i].pCurrentdm = NULL;
                    CheckMenuItemCurrentMode(i);
                }

                SetMonitorDeviceInfo( FALSE );
            }

            break;


#if 0
hard to understand when and why we get this message.  better leave it alone
        case WM_DEVICECHANGE:

            if (wParam == DBT_CONFIGCHANGED ||
                wParam == DBT_MONITORCHANGE)
            {
                for (i=0; i<iMonitors; i++)
                {
                    DestroyModeMenu( i, FALSE, FALSE );
                    SetDevmodeFlags( i, TRUE );
                }

                if (MonitorMenu)
                {
                    DestroyMenu(MonitorMenu);
                    MonitorMenu = NULL;
                }
                DestroyDevmodeLists();
                BuildDevmodeLists();
                MonitorMenu = GetMonitorMenu( TRUE );
            }
            break;
#endif


        case WM_COMMAND:
        {

            switch (LOWORD(wParam))
            {

                case MENU_CLOSE:

                    PostMessage(hwnd, WM_CLOSE, 0, 0);

                    break;

                case MENU_PROPERTIES:

                    //
                    // Start control panel applet
                    //

                    DoProperties();

                    break;


                case MENU_ABOUT:

                    //
                    // Show a generic about box
                    //

                    MsgBox(IDS_ABOUT, 0, MB_OK );

                    break;


                case MENU_OPTIONS:

                    //
                    // After showing options dlg box, show mode menu again
                    //

                    if (fShowFreqs)
                        DialogBox(hInstApp, MAKEINTRESOURCE(NTOptions), NULL, NTOptionsDlgProc);
                    else
                        DialogBox(hInstApp, MAKEINTRESOURCE(W95Options),NULL, W95OptionsDlgProc);

                    SetTimer(hwnd, TRAY_ID, 10, NULL);

                    break;


                default:
                {

                    //
                    // Change devmode to pModes[OffsetPdev]
                    //

                    INT OffsetPdev;
                    INT iDisplay;

                    //
                    // The menu item is an offset from MENU_RES
                    // of the selected item.
                    //

                    iDisplay   = LOWORD(wParam) / MENU_RES - 1;
                    OffsetPdev = LOWORD(wParam) % MENU_RES;

                    //
                    // Check that the offset is within range
                    //

                    if( OffsetPdev >= 0 && OffsetPdev < pMonitors[iDisplay].iModes )
                    {

                        //
                        // if different from current devmode then change it
                        //

                        if ( CompareDevmodes( &pMonitors[iDisplay].pModes[OffsetPdev],
                                               pMonitors[iDisplay].pCurrentdm) )
                        {
                            SetMode(hwnd, iDisplay, OffsetPdev);
                        }

                    }

                }

                break;

            }

            break;

        }


        case WM_TIMER:

            //
            // Left click was not a double-click
            //

            KillTimer(hwnd, TRAY_ID);
            GetCursorPos(&pt);
            SetForegroundWindow(hwnd);

            //
            // Create and/or Get resolutions menu
            //

            TrackPopupMenu(GetMonitorMenu( FALSE ), TPM_LEFTBUTTON,
                           pt.x, pt.y, 0, hwnd, NULL);

            break;


        case TRAY_MSG:
        {

            //
            // No messages processed while waiting on
            // a dlg/msg box to return
            //

            if (!Waiting)
            {

                switch (lParam)
                {
                    case WM_RBUTTONUP:

                        //
                        // Properties, about, Exit
                        //

                        SetForegroundWindow(hwnd);
                        GetCursorPos(&pt);

                        TrackPopupMenu(MainMenu, TPM_RIGHTBUTTON,
                                       pt.x, pt.y, 0, hwnd, NULL);

                        break;


                    case WM_LBUTTONDOWN:

                        //
                        // Resolutions menu
                        //

                        SetTimer(hwnd, TRAY_ID, GetDoubleClickTime()+10, NULL);

                        break;



                    case WM_LBUTTONDBLCLK:

                        //
                        // start control panel applet
                        //

                        KillTimer(hwnd, TRAY_ID);
                        DoProperties();

                        break;
                }

            }

        }

        break;

    }

    return DefWindowProc(hwnd,msg,wParam,lParam);

}


//
//********************************************************************
//
//  MsgBox(int, UINT, UINT)
//
//  Generic messagebox function that can print a value into
//  a format string
//
//********************************************************************
//

int MsgBox(int id, UINT value, UINT flags)
{

    PTCHAR msgboxtext=NULL;           // message box body text
    INT  ret = 0;
    MSGBOXPARAMS mb;


    //
    //  Ignore tray clicks while msgbox is up, and
    //  Show at least an OK button.
    //

    Waiting = TRUE;
    if (flags == 0)
    {
        flags = MB_OK | MB_USERICON;
    }


    //
    //  Can print a value into a format string, if value!=0.
    //

    if (value)
    {
        PTCHAR msgboxfmt;                // body test format

        if (msgboxfmt = GetResourceString ( id ))
        {
            if (msgboxtext = LocalAlloc ( LPTR, sizeof(TCHAR)*
                             (lstrlen(msgboxfmt)+INT_FORMAT_TO_5_DIGITS+1)))
            {
                wsprintf(msgboxtext,msgboxfmt,value);
            }

            LocalFree( msgboxfmt );
        }
    }

    else
    {
       msgboxtext = GetResourceString ( id );
    }


    if (msgboxtext)
    {

        mb.cbSize               = sizeof(mb);
        mb.hwndOwner            = NULL;
        mb.hInstance            = hInstApp;
        mb.lpszText             = msgboxtext;
        mb.lpszCaption          = szAppName;
        mb.dwStyle              = flags;
        mb.lpszIcon             = szAppName;
        mb.dwContextHelpId      = 0;
        mb.lpfnMsgBoxCallback   = NULL;
        mb.dwLanguageId         = MAKELANGID (LANG_NEUTRAL, SUBLANG_NEUTRAL);;


        //
        //  Special API for the about box. otherwise, use Messageboxindirect
        //

        if (id == IDS_ABOUT)
        {
            ret = ShellAbout(mb.hwndOwner, mb.lpszCaption, mb.lpszText, AppIcon);
        }

        else
        {

            if (flags & MB_USERICON)
            {
                //
                //  only use MessageBoxIndirect if we have to.
                //  has problems on win9x.
                //

                ret = MessageBoxIndirect(&mb);
            }

            else
            {
                //
                //  MessageBoxEx works great on both NT and Win95
                //

                ret = MessageBoxEx ( mb.hwndOwner, mb.lpszText, mb.lpszCaption,
                                     mb.dwStyle,   (WORD)mb.dwLanguageId );
            }
        }

        //
        //  Free string memory; start processing tray msgs again
        //

        LocalFree( msgboxtext );
    }

    Waiting = FALSE;

    return ret;

}


//
//********************************************************************
//
//  WinMain
//
//********************************************************************
//

int NEAR PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw)
{
    WNDCLASS  cls;
    MSG       msg;
    HWND      hwnd;
    INT       iDisplay;
    HINSTANCE hInstUser;

    hInstApp = hInst;
    szAppName = GetResourceString( IDS_TITLE );


    //
    //   App is already running.  Do not start a 2nd instance
    //

    if ( FindWindow( szAppName, szAppName ) )
    {
        return 0;
    }

    if (hInstUser=GetModuleHandle(TEXT("user32.dll")))
    {
        lpfnEDD =   GetProcAddress( hInstUser, ENUMDISPLAYDEVICES    );
        lpfnEDSEx = GetProcAddress( hInstUser, ENUMDISPLAYSETTINGSEX );
    }


    AppIcon = LoadIcon(hInst,szAppName);


    //
    //  Register a class for the main application window
    //

    cls.lpszClassName  = szAppName;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = hInstApp;
    cls.hIcon          = AppIcon;
    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
    cls.lpszMenuName   = szAppName;
    cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    cls.lpfnWndProc    = AppWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if (!RegisterClass(&cls))
        return FALSE;

    hwnd = CreateWindow(szAppName,
                        szAppName,
                        WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
                        NULL, NULL,
                        hInstApp, NULL);


    //
    //  Properties, about, exit - properties is the default
    //

    MainMenu = GetSubMenu(GetMenu(hwnd), 0);
    SetMenuDefaultItem(MainMenu,MENU_PROPERTIES,MF_BYCOMMAND);


    //
    //  Get flags from registry and build the modemenu
    //  from scratch.
    //

    GetQuickResFlags( );

    if (!BuildMonitorArray())
    {
        return FALSE;
    }

    if (!BuildDevmodeLists())
    {
        return FALSE;
    }


    //
    // Update tray tooltip to be current resolution
    //

    TrayMessage( hwnd, NIM_MODIFY, TRAY_ID, AppIcon );


    //
    // Polling messages from event queue
    //

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    //
    //  write flags to registry
    //

    SaveAllSettings();


    //
    //  Free up dynamically allocated globals.
    //

    LocalFree ( szAppName );

    for (iDisplay=0; iDisplay<iMonitors; iDisplay++)
    {
        if (pMonitors[iDisplay].DeviceName)
            GlobalFree(pMonitors[iDisplay].DeviceName);

        if (pMonitors[iDisplay].MonitorName)
            GlobalFree(pMonitors[iDisplay].MonitorName);

        if (pMonitors[iDisplay].PrimaryMonitorName)
            GlobalFree(pMonitors[iDisplay].PrimaryMonitorName);

        GlobalFree(pMonitors[iDisplay].pModes);

        GlobalFree(pMonitors[iDisplay].FreqMenu);
    }

    GlobalFree(pMonitors);


    return (int)msg.wParam;
}


//
//********************************************************************
//
//   TrayMessage (HWND, DWORD, UINT, HICON )
//
//   Add/remove icon to/from tray next to the time
//
//********************************************************************
//

BOOL TrayMessage(HWND hwnd, DWORD msg, UINT id, HICON hIcon )
{

    NOTIFYICONDATA tnd;
    PTCHAR Res=NULL;
    PTCHAR Hz=NULL;
    UINT   uDisplay=0;
    UINT   uNewlen=0;

    tnd.cbSize           = sizeof(NOTIFYICONDATA);
    tnd.hWnd             = hwnd;
    tnd.uID              = id;
    tnd.szTip[0]         = '\0';
    tnd.uFlags           = NIF_MESSAGE|NIF_ICON|NIF_TIP;
    tnd.uCallbackMessage = TRAY_MSG;
    tnd.hIcon            = hIcon;


    //
    //  Changing tooltip text to match current resolution
    //  (Make sure pCurrentdm is valid / not NULL.)
    //

    if (msg == NIM_MODIFY)
    {

        do
        {

            if (pMonitors[uDisplay].pCurrentdm)
            {
                GetModeName(&(pMonitors[uDisplay].pCurrentdm->dm), &Res, &Hz);

                //
                //  calculate how long the string will be (need to be sure it's < 64)
                //  old tip + new Res + Hz (if applicable) + ", " (if its not the 1st mon)
                //

                uNewlen = lstrlen(tnd.szTip);

                if (Res)
                {
                    uNewlen += lstrlen(Res);
                }

                if (uDisplay > 0)
                {
                   uNewlen += 2;
                }

                if (fShowFreqs && Hz)
                {
                   uNewlen += lstrlen(Hz);
                }


                if (uNewlen < 64)
                {
                    //
                    //  this displays information will fit in the tooltip
                    //  add ", " if not 1st mon, then the Res, then Hz (if applicable)
                    //

                    if ( uDisplay > 0 )
                    {
                        lstrcat(tnd.szTip,TEXT(", "));
                    }

                    if (Res)
                    {
                        lstrcat(tnd.szTip,Res);
                    }

                    if (fShowFreqs && Hz)
                    {
                        lstrcat(tnd.szTip,Hz);
                    }
                }

                if (Res)
                {
                    LocalFree(Res);
                }

                if (Hz)
                {
                    LocalFree(Hz);
                }

                ++uDisplay;
            }

      }  while (uDisplay < (UINT)iMonitors);

    }

    //
    //  Adding the tray icon - Current devmode
    //  is not known so use AppName as tip
    //

    else
    {
        wsprintf(tnd.szTip, szAppName);
    }

    return Shell_NotifyIcon( msg, &tnd );
}



//
//*****************************************************************************
//
//  KeepNewResDlgProc(HWND, UINT, WPARAM, LPARAM )
//
//  User must enter Yes to keep new res, or we default back to the old res.
//
//*****************************************************************************
//

INT_PTR FAR PASCAL KeepNewResDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    //
    //  Save strings as static pointers, and free them only in YES/NO/ABORT/CANCEL,
    //  because they will otherwise disappear from a Win95 dialog box immediately
    //  after they are free'd.
    //

    static int     NOTimeOut;                  // countdown to 0
    static PTCHAR  NewResString=NULL;          // user friendly name for devmode
    static PTCHAR  NewHzString=NULL;           // and frequency
    static PTCHAR  szAt=NULL;                  // ", at"
    static PTCHAR  TotalString=NULL;           // "<wid x ht>, at <freq>"


    switch (message)
    {

       case WM_INITDIALOG:     // initialize values and focus

       {

            //
            //  Initialize values and focus
            //

            DEVMODE dm;


            //
            //  Ignore tray messages while waiting for yes/no.
            //  Wait KEEP_RES_TIMEOUT seconds.
            //

            Waiting=TRUE;


            //
            // Get current devmode; lparam is the iDisplay
            //
            GetCurrentDevMode( (INT)lParam, &dm );


            //
            // Get user friendly strings (concatenate Res & Hz, if applicable)
            //

            GetModeName( &dm, &NewResString, &NewHzString);

            if (NewResString)
            {
                if (fShowFreqs && NewHzString)
                {
                    szAt = GetResourceString ( IDS_AT );
                    
                    //
                    // Replace 2nd text item of msgbox
                    //

                    if (TotalString = LocalAlloc ( LPTR, sizeof(TCHAR)*
                                                 ( lstrlen(NewResString)+
                                                   lstrlen(NewHzString)+
                                                   lstrlen(szAt)+
                                                   1 ) ))
                    {
                        lstrcpy(TotalString, NewResString);
                        lstrcat(TotalString, szAt);
                        lstrcat(TotalString, NewHzString);

                        SetDlgItemText(hDlg, IDTEXT2, TotalString);
                    }
                }
                else
                {
                    SetDlgItemText(hDlg, IDTEXT2, NewResString);
                }
            }

            //
            //  Set timeout length and start waiting
            //

            NOTimeOut=KEEP_RES_TIMEOUT;

            SetTimer(hDlg,IDD_COUNTDOWN,1000,NULL);

            return (TRUE);

            break;

        }


        case WM_TIMER:

            {
                PTCHAR NoTextFmt=NULL;           // "NO: %d"
                PTCHAR NoText=NULL;              // e.g. "NO: 15"

                //
                // Still counting down
                //

                if ( NOTimeOut >= 0 )
                {
                    //
                    // Get format string for NO Button.
                    // Write it to NoText String and to dlg box
                    //

                    NoTextFmt = GetResourceString ( IDS_NOTEXT );

                    if (NoTextFmt)
                    {
                        NoText = LocalAlloc ( LPTR, sizeof(TCHAR)*
                                                    ( lstrlen(NoTextFmt)+1 ) );
                        wsprintf(NoText, NoTextFmt, NOTimeOut--);

                        SetDlgItemText(hDlg, IDNO, NoText);

                        LocalFree ( NoTextFmt );
                        LocalFree ( NoText );
                    }

                }

                else
                {
                    //
                    // Give up on the user - return NO
                    //

                    KillTimer(hDlg, IDD_COUNTDOWN);
                    SendMessage(hDlg, WM_COMMAND, IDNO, 0);
                }

                return (TRUE);

            }

            break;


        case WM_COMMAND:

            //
            // Start processing tray messages again
            //

            Waiting=FALSE;

            switch (LOWORD(wParam))

            {

                //
                //  return value based on the button pressed
                //

                case IDYES :
                case IDNO :
                case IDABORT :
                case IDCANCEL :

                    //
                    //  LocalFree handles NULL pointers gracefully (does nothing)
                    //

                    LocalFree ( szAt );
                    LocalFree ( NewResString );
                    LocalFree ( NewHzString );
                    LocalFree ( TotalString );

                    EndDialog(hDlg, LOWORD(wParam));
                    return (TRUE);

                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return (FALSE);     // Didn't process a message


} // KeepNewResDlgProc()



//
//*****************************************************************************
//
//  NTOptionsDlgProc(HWND, UINT, WPARAM, LPARAM )
//
//
//
//*****************************************************************************
//

INT_PTR FAR PASCAL NTOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT i;
    static WORD SaveQRFlags;

    switch (message)
    {

        case WM_INITDIALOG:

            //
            // Stop processing tray messages; check buttons properly
            //

            Waiting = TRUE;
            SaveQRFlags = QuickResFlags;

            CheckRadioButton(hDlg,IDD_SORT_RES,IDD_SORT_BPP,
                                  (fSortByBPP ? IDD_SORT_BPP : IDD_SORT_RES) );
            CheckRadioButton(hDlg,IDD_SUBMENUS,IDD_ALLMODEMENU, FreqMenuLocation );

            CheckDlgButton(hDlg, IDD_UPDATEREG, fUpdateReg );
            CheckDlgButton(hDlg, IDD_REMMODES,  fRememberModes );
            CheckDlgButton(hDlg, IDD_RESTARTREQ,  fShowModesThatNeedRestart );
            CheckDlgButton(hDlg, IDD_SHOWTESTED,  fShowTestedModes );

            return TRUE;
            break;


        case WM_COMMAND:


            switch (LOWORD(wParam))

            {

                //
                //  Update buttons : sorting by BPP or Res?
                //

                case IDD_SORT_RES:
                case IDD_SORT_BPP:
                    CheckRadioButton(hDlg,IDD_SORT_RES,IDD_SORT_BPP,LOWORD(wParam));
                    return TRUE;
                    break;

                //
                //  Update buttons : where to display freq menus?
                //

                case IDD_SUBMENUS:
                case IDD_ONEMENUMOBILE:
                case IDD_ONEMENUBOTTOM:
                case IDD_ALLMODEMENU:
                    CheckRadioButton(hDlg,IDD_SUBMENUS,IDD_ALLMODEMENU,LOWORD(wParam));
                    return TRUE;
                    break;


                //
                //  Clear all registry remembered settings
                //  Make user verify he did this on purpose
                //

                case IDD_CLEARREG:
                    if (MsgBox(IDS_CLEARREG,
                               0,
                               MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
                         ==    IDYES)
                    {

                        //
                        //  Reset flags for all monitors; destroy and rebuild
                        //  each mode menu
                        //

                        for (i=0; i<iMonitors; i++)
                        {
                            SetDevmodeFlags(i, TRUE);
                            VALIDMODE(pMonitors[i].pCurrentdm) = MODE_BESTHZ;
                            DestroyModeMenu( i, TRUE, FALSE);
                        }
                    }

                    return TRUE;
                    break;


                //
                //  XOR QuickResFlags on and off
                //

                case IDD_UPDATEREG:
                    QuickResFlags ^= QF_UPDATEREG;
                    return TRUE;
                    break;

                case IDD_REMMODES:
                    QuickResFlags ^= QF_REMMODES;
                    return TRUE;
                    break;

                case IDD_RESTARTREQ:
                    QuickResFlags ^= QF_SHOWRESTART;
                    return TRUE;
                    break;

                case IDD_SHOWTESTED:
                    QuickResFlags ^= QF_SHOWTESTED;
                    return TRUE;
                    break;


                case IDOK:
                {

                    BOOL bRebuildMenu   = FALSE;
                    BOOL bNeedToSort    = FALSE;


                    //
                    //  See if sort order has changed.
                    //

                    if ( (IsDlgButtonChecked (hDlg, IDD_SORT_RES) &&  fSortByBPP) ||
                         (IsDlgButtonChecked (hDlg, IDD_SORT_BPP) && !fSortByBPP) )
                    {
                        QuickResFlags ^= QF_SORT_BYBPP;
                        bNeedToSort = TRUE;
                    }


                    //
                    //  If "show modes that require restart", or "show tested "modes only",
                    //  then rebuild menu is required
                    //

                    if ( (fShowModesThatNeedRestart != (SaveQRFlags & QF_SHOWRESTART)) ||
                         (fShowTestedModes          != (SaveQRFlags & QF_SHOWTESTED))
                       )
                    {
                        bRebuildMenu = TRUE;
                    }



                    //
                    // see if FreqMenuLocation has changed
                    //

                    if (!IsDlgButtonChecked (hDlg, FreqMenuLocation))
                    {
                        WORD i;

                        //
                        //  Freq menu location has changed; update & ask for rebuild
                        //

                        bRebuildMenu = TRUE;

                        for ( i=IDD_SUBMENUS; i <= IDD_ALLMODEMENU; i++ )
                        {
                            if (IsDlgButtonChecked (hDlg, i))
                            {
                                FreqMenuLocation = i;
                            }
                        }
                    }


                    //
                    //  If rebuilding and or resorting, just destroy & rebuild the menus
                    //

                    if ( bNeedToSort || bRebuildMenu )
                    {
                        for (i=0; i<iMonitors; i++)
                            DestroyModeMenu( i, TRUE, bNeedToSort);
                    }

                    SaveAllSettings();

                    Waiting = FALSE;
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                    break;
                }

                case IDCANCEL :

                    Waiting = FALSE;
                    QuickResFlags = SaveQRFlags;
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return FALSE;     // Didn't process a message


} // NTOptionsDlgProc()



//
//*****************************************************************************
//
//  W95OptionsDlgProc(HWND, UINT, WPARAM, LPARAM )
//
//
//
//*****************************************************************************
//

INT_PTR FAR PASCAL W95OptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    INT i;
    static WORD SaveQRFlags;

    switch (message)
    {

        case WM_INITDIALOG:

            //
            // Stop processing tray messages; check buttons properly
            //

            Waiting = TRUE;
            SaveQRFlags = QuickResFlags;

            CheckRadioButton(hDlg,IDD_SORT_RES,IDD_SORT_BPP,
                                  (fSortByBPP ? IDD_SORT_BPP : IDD_SORT_RES) );

            CheckDlgButton(hDlg, IDD_UPDATEREG, fUpdateReg );
            CheckDlgButton(hDlg, IDD_REMMODES,  fRememberModes );
            CheckDlgButton(hDlg, IDD_RESTARTREQ,  fShowModesThatNeedRestart );
            CheckDlgButton(hDlg, IDD_SHOWTESTED,  fShowTestedModes );

            return TRUE;
            break;


        case WM_COMMAND:


            switch (LOWORD(wParam))

            {

                //
                //  Update buttons : sorting by BPP or Res?
                //

                case IDD_SORT_RES:
                case IDD_SORT_BPP:
                    CheckRadioButton(hDlg,IDD_SORT_RES,IDD_SORT_BPP,LOWORD(wParam));
                    return TRUE;
                    break;

                //
                //  Clear all registry remembered settings
                //  Make user verify he did this on purpose
                //

                case IDD_CLEARREG:
                    if (MsgBox(IDS_CLEARREG,
                               0,
                               MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
                         ==    IDYES)
                    {

                        //
                        //  Reset flags for all monitors; destroy and rebuild
                        //  each mode menu
                        //

                        for (i=0; i<iMonitors; i++)
                        {
                            SetDevmodeFlags(i, TRUE);
                            VALIDMODE(pMonitors[i].pCurrentdm) = MODE_BESTHZ;
                            DestroyModeMenu( i, TRUE, FALSE);
                        }
                    }

                    return TRUE;
                    break;


                //
                //  XOR QuickResFlags on and off
                //

                case IDD_UPDATEREG:
                    QuickResFlags ^= QF_UPDATEREG;
                    return TRUE;
                    break;

                case IDD_REMMODES:
                    QuickResFlags ^= QF_REMMODES;
                    return TRUE;
                    break;

                case IDD_RESTARTREQ:
                    QuickResFlags ^= QF_SHOWRESTART;
                    return TRUE;
                    break;

                case IDD_SHOWTESTED:
                    QuickResFlags ^= QF_SHOWTESTED;
                    return TRUE;
                    break;

                case IDOK:
                {
                    BOOL bNeedToSort = FALSE;

                    //
                    //  Note if the sort order has changed
                    //

                    if ( (IsDlgButtonChecked (hDlg, IDD_SORT_RES) &&  fSortByBPP) ||
                         (IsDlgButtonChecked (hDlg, IDD_SORT_BPP) && !fSortByBPP) )
                    {
                        QuickResFlags ^= QF_SORT_BYBPP;
                        bNeedToSort = TRUE;
                    }


                    //
                    //  If "sort order", "show modes that require restart", or "show tested
                    //  "modes only" changed, then destroy and rebuild old menu (resort if nec.)
                    //

                    if ( bNeedToSort ||
                         (fShowModesThatNeedRestart != (SaveQRFlags & QF_SHOWRESTART)) ||
                         (fShowTestedModes          != (SaveQRFlags & QF_SHOWTESTED))
                       )
                    {
                        for (i=0; i<iMonitors; i++)
                            DestroyModeMenu( i, TRUE, bNeedToSort);
                    }

                    SaveAllSettings();

                    //
                    //  No break after IDOK, by design.
                    //  IDOK AND IDCANCEL : start processing tray clicks,
                    //  and return ok/cancel as return value.
                    //
                }

                case IDCANCEL :

                    Waiting = FALSE;
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return FALSE;     // Didn't process a message


} // W95OptionsDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\pbrush\pbrush.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "pbrush.h"

extern int _cdecl ShellMessageBox(HINSTANCE hAppInst, HWND hWnd, LPCSTR
        lpcText, LPCSTR lpcTitle, UINT fuStyle, ...);
// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    return WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

}


const char szFile[] = "mspaint.exe";

//---------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    ShellExecute(HWND_DESKTOP, NULL, szFile, lpCmdLine, NULL, nCmdShow);
    ExitProcess(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\basex.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak                                                   
//  File           basex.c                                                    
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)            
//  Copyright      (C) 1995-97 Microsoft                                    
//  Date           03-14-97                                                 
//                                                                          
//                                                                          
//  Description                                                             
//                                                                          
//     Contains number routines for internal base computations, these assume   
//  internal base is a power of 2.                                          
//                                                                          
//-----------------------------------------------------------------------------

#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <ratpak.h>


// WARNING: This assumes return of a 64 bit entity is in edx:eax
// This assumption SHOULD always be true on X86
#pragma warning( disable : 4035 )
DWORDLONG __inline Mul32x32( IN DWORD a, IN DWORD b )

{
#ifdef _X86_ 
    __asm {
    mov eax, b
        mul a
        }
#else
    return (DWORDLONG)a * b;
#endif
}
#pragma warning( default : 4035 )

// Yeah well when the F__KING COMPILER gets a clue I'll change this back to 
// an inline (as opposed to the compiler looking at fastcall putting the args
// in registers, oh and then a) not making this inline, and b) pushing the 
// values anyway!

#ifdef _X86_ 
    #define Shr32xbase(x) \
            __asm { mov eax,DWORD PTR [x] } \
            __asm { mov edx,DWORD PTR [x+4] } \
            __asm { shrd eax,edx,BASEXPWR } \
            __asm { shr edx,BASEXPWR } \
            __asm { mov DWORD PTR [x],eax } \
            __asm { mov DWORD PTR [x+4],edx }
#else
    #define Shr32xbase(x) (x >>= BASEXPWR);
#endif



void _mulnumx( PNUMBER *pa, PNUMBER b );

//----------------------------------------------------------------------------
//
//    FUNCTION: mulnumx
//
//    ARGUMENTS: pointer to a number and a second number, the
//               base is always BASEX.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    This is a stub which prevents multiplication by 1, this is a big speed
//    improvement.
//
//----------------------------------------------------------------------------

void __inline mulnumx( PNUMBER *pa, PNUMBER b )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {
        // If b is not one we multiply
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            { 
            // pa and b are both nonone.
            _mulnumx( pa, b );
            }
        else
            {
            // if pa is one and b isn't just copy b. and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {
        // B is +/- 1, But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: _mulnumx
//
//    ARGUMENTS: pointer to a number and a second number, the
//               base is always BASEX.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    Assumes the base is BASEX of both numbers.  This algorithm is the
//    same one you learned in gradeschool, except the base isn't 10 it's
//    BASEX.
//
//----------------------------------------------------------------------------

void _mulnumx( PNUMBER *pa, PNUMBER b )

{
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    MANTTYPE *ptra;         // ptra is a pointer to the mantissa of a.
    MANTTYPE *ptrb;         // ptrb is a pointer to the mantissa of b.
    MANTTYPE *ptrc;         // ptrc is a pointer to the mantissa of c.
    MANTTYPE *ptrcoffset;   // ptrcoffset, is the anchor location of the next
                            // single digit multiply partial result.
    long iadigit=0;         // Index of digit being used in the first number.
    long ibdigit=0;         // Index of digit being used in the second number.
    MANTTYPE      da=0;     // da is the digit from the fist number.
    TWO_MANTTYPE  cy=0;     // cy is the carry resulting from the addition of
                            // a multiplied row into the result.
    TWO_MANTTYPE  mcy=0;    // mcy is the resultant from a single 
                            // multiply, AND the carry of that multiply.
    long  icdigit=0;        // Index of digit being calculated in final result.

    a=*pa;

    ibdigit = a->cdigit + b->cdigit - 1;
    createnum( c,  ibdigit + 1 );
    c->cdigit = ibdigit;
    c->sign = a->sign * b->sign;

    c->exp = a->exp + b->exp;
    ptra = MANT(a);
    ptrcoffset = MANT(c);

    for (  iadigit = a->cdigit; iadigit > 0; iadigit-- )
        {
        da =  *ptra++;
        ptrb = MANT(b);
        
        // Shift ptrc, and ptrcoffset, one for each digit 
        ptrc = ptrcoffset++;

        for ( ibdigit = b->cdigit; ibdigit > 0; ibdigit-- )
            {
            cy = 0;
            mcy = Mul32x32( da, *ptrb );
            if ( mcy )
                {
                icdigit = 0;
                if ( ibdigit == 1 && iadigit == 1 )
                    {
                    c->cdigit++;
                    }
                }
            // If result is nonzero, or while result of carry is nonzero...
            while ( mcy || cy )
                {
                
                // update carry from addition(s) and multiply.
                cy += (TWO_MANTTYPE)ptrc[icdigit]+((DWORD)mcy&((DWORD)~BASEX));
                
                // update result digit from 
                ptrc[icdigit++]=(MANTTYPE)((DWORD)cy&((DWORD)~BASEX));
                
                // update carries from
                Shr32xbase( mcy );
                Shr32xbase( cy );
                }
            *ptrb++;
            *ptrc++;
            }
        }
    
    // prevent different kinds of zeros, by stripping leading duplicate zeroes.
    // digits are in order of increasing significance.
    while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
        {
        c->cdigit--;
        }

    destroynum( *pa );
    *pa=c;
}
//-----------------------------------------------------------------------------
//
//    FUNCTION: numpowlongx
//
//    ARGUMENTS: root as number power as long
//               number.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes numeric representation of root to
//    root ** power. Assumes base BASEX
//    decomposes the exponent into it's sums of powers of 2, so on average
//    it will take n+n/2 multiplies where n is the highest on bit.
//
//-----------------------------------------------------------------------------

void numpowlongx( IN OUT PNUMBER *proot, IN long power )

{
    PNUMBER lret=NULL;

    lret = longtonum( 1, BASEX );

    // Once the power remaining is zero we are done.
    while ( power > 0 )
        {
        // If this bit in the power decomposition is on, multiply the result
        // by the root number.
        if ( power & 1 )
            {
            mulnumx( &lret, *proot );
            }

        // multiply the root number by itself to scale for the next bit (i.e.
        // square it.
        mulnumx( proot, *proot );

        // move the next bit of the power into place.
        power >>= 1;
        }
    destroynum( *proot );
    *proot=lret;
    
}

void _divnumx( PNUMBER *pa, PNUMBER b );

//----------------------------------------------------------------------------
//
//    FUNCTION: divnumx
//
//    ARGUMENTS: pointer to a number a second number.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the internal nRadix representation.
//    This is a stub which prevents division by 1, this is a big speed
//    improvement.
//
//----------------------------------------------------------------------------

void __inline divnumx( PNUMBER *pa, PNUMBER b )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {
        // b is not one.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            {
            // pa and b are both not one.
            _divnumx( pa, b );
            }
        else
            {
            // if pa is one and b is not one, just copy b, and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {
        // b is one so don't divide, but set the sign.
        (*pa)->sign *= b->sign;
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: _divnumx
//
//    ARGUMENTS: pointer to a number a second number.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the internal nRadix representation.
//
//----------------------------------------------------------------------------

void _divnumx( PNUMBER *pa, PNUMBER b )

{
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER lasttmp = NULL; // lasttmp allows a backup when the algorithm
                            // guesses one bit too far.
    PNUMBER tmp = NULL;     // current guess being worked on for divide.
    PNUMBER rem = NULL;     // remainder after applying guess.
    long cdigits;           // count of digits for answer.
    MANTTYPE *ptrc;         // ptrc is a pointer to the mantissa of c.

    long thismax = maxout+ratio; // set a maximum number of internal digits
                                 // to shoot for in the divide.

    a=*pa;
    if ( thismax < a->cdigit )
        {
        // a has more digits than precision specified, bump up digits to shoot 
        // for.
        thismax = a->cdigit;
        }

    if ( thismax < b->cdigit )
        {
        // b has more digits than precision specified, bump up digits to shoot 
        // for.
        thismax = b->cdigit;
        }

    // Create c (the divide answer) and set up exponent and sign.
    createnum( c, thismax + 1 );
    c->exp = (a->cdigit+a->exp) - (b->cdigit+b->exp) + 1;
    c->sign = a->sign * b->sign;

    ptrc = MANT(c) + thismax;
    cdigits = 0;

    DUPNUM( rem, a );
    rem->sign = b->sign;
    rem->exp = b->cdigit + b->exp - rem->cdigit;

    while ( cdigits++ < thismax && !zernum(rem) )
        {
        long digit = 0;
        *ptrc = 0;
        while ( !lessnum( rem, b ) )
            {
            digit = 1;
            DUPNUM( tmp, b );
            destroynum( lasttmp );
            lasttmp=longtonum( 0, BASEX );
            while ( lessnum( tmp, rem ) )
                {
                destroynum( lasttmp );
                DUPNUM(lasttmp,tmp);
                addnum( &tmp, tmp, BASEX );
                digit *= 2;
                }
            if ( lessnum( rem, tmp ) )
                {    
                // too far, back up...
                destroynum( tmp );
                digit /= 2;
                tmp=lasttmp;
                lasttmp=NULL;
                }

            tmp->sign *= -1;
            addnum( &rem, tmp, BASEX ); 
            destroynum( tmp );
            destroynum( lasttmp );
            *ptrc |= digit;
            }
        rem->exp++;
        ptrc--;
        }
    cdigits--;
    if ( MANT(c) != ++ptrc )
        {
        memcpy( MANT(c), ptrc, (int)(cdigits*sizeof(MANTTYPE)) );
        }

    if ( !cdigits )
        {   
        // A zero, make sure no wierd exponents creep in
        c->exp = 0;
        c->cdigit = 1;
        }
    else
        {
        c->cdigit = cdigits;
        c->exp -= cdigits;
        // prevent different kinds of zeros, by stripping leading duplicate 
        // zeroes. digits are in order of increasing significance.
        while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
            {
            c->cdigit--;
            }
        }

    destroynum( rem );

    destroynum( *pa );
    *pa=c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\quickres\quickres.h ===
//
//  QuickRes.h
//

#include <windows.h>

#include <shellapi.h>
#include "QuickRes.rc"
#include "stdlib.h"
#include "tchar.h"

#define ODS OutputDebugString

#define TRAY_MSG                WM_USER+1
#define TRAY_ID                 42


//
//  Global Quickres bit flags
//

#define QF_SHOWRESTART          0x0001     // Show modes that require a restart
#define QF_UPDATEREG            0x0002     // update registry with new devmode
#define QF_REMMODES             0x0004     // Remember good/bad modes in registry
#define QF_SORT_BYBPP           0x0008     // if not set, we sort by Resolution
#define QF_HIDE_4BPP            0x0010     // Hide 4Bpp mode if 8Bpp of same res exists
#define QF_SHOWTESTED           0x0020     // Show tested/passing modes only
#define QF_SHOWFREQS            0x0040     // Show Frequencies (disabled on Win95)


//
//  fGoodModes (below) depends on these values for these flags
//  Changing these constants requires rewriting the fGoodModes macro
//

#define MODE_INVALID             0         // Devmode is not visible
#define MODE_VALID               1         // Devmode looks good
#define MODE_UNTESTED            2         // Haven't tried it yet
#define MODE_BESTHZ              3         // Best Hz for given res/bpp


#define RESOURCE_STRINGLEN       512       // Guess at largest resource string length

#define KEEP_RES_TIMEOUT         15        // how long before reverting to old devmode

#define INT_FORMAT_TO_5_DIGITS   10        // Need 3+ more bytes : "%d" -> "12345"
                                           // Being safe here (add 10 bytes)


//
//  Constant strings in registry & for starting properties
//

#define REGSTR_SOFTWARE    TEXT("Software\\Microsoft")
#define REGSTR_QUICKRES    TEXT("Software\\Microsoft\\QuickRes")
#define QUICKRES_KEY       TEXT("QuickRes")
#define DISPLAYPROPERTIES  TEXT("rundll32 shell32.dll,Control_RunDLL desk.cpl,,3")
#define REGDEVMODES        TEXT("GoodDevmodes")
#define REGBPP             TEXT("BPP")
#define REGFLAGS           TEXT("Flags")

#ifdef UNICODE
#define ENUMDISPLAYDEVICES    "EnumDisplayDevicesW"
#define ENUMDISPLAYSETTINGSEX "EnumDisplaySettingsExW"
#else
#define ENUMDISPLAYDEVICES    "EnumDisplayDevicesA"
#define ENUMDISPLAYSETTINGSEX "EnumDisplaySettingsExA"
#endif



//
//  Each devmode has 4 additional properties.
//

typedef struct _DEVMODEINFO {

    DEVMODE dm;
    UINT    uFreqMenu;
    UINT    uMenuItem;
    UINT    uCDSTest;
    UINT    uValidMode;

}  DEVMODEINFO, *LPDEVMODEINFO;


//
// Per monitor information :
//   devicename, monitorname
//   devmode menu and freq submenus built on the fly
//   iModes : number of devmodes
//   pModes : array of devmodes display can handle
//   pCurrentdm : pointer (in pModes) to current devmode
//   bPrimary : primary or not?
//

typedef struct _QRMONITORINFO
{
    LPTSTR         DeviceName;
    LPTSTR         MonitorName;
    LPTSTR         PrimaryMonitorName;
    HMENU          ModeMenu;
    HMENU          *FreqMenu;
    INT            iModes;
    LPDEVMODEINFO  pModes;
    LPDEVMODEINFO  pCurrentdm;
    BOOL           bPrimary;
    BOOL           bAttached;

}  QRMONITORINFO, *LPQRMONITORINFO;



//
// prototypes
//
// quickres.c
//

HMENU    GetModeMenu ( INT, BOOL );
HMENU    GetMonitorMenu ( BOOL );
BOOL     BuildDevmodeList ( VOID );
BOOL     TrayMessage( HWND, DWORD, UINT, HICON );
int      MsgBox( int, UINT, UINT );
VOID     CheckMenuItemCurrentMode( INT );
PDEVMODE GetCurrentDevMode( INT, PDEVMODE );
LPTSTR   GetResourceString( UINT );
VOID     DestroyModeMenu( INT, BOOL, BOOL );
VOID     AppendMainMenu( VOID );

INT_PTR FAR PASCAL KeepNewResDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL NTOptionsDlgProc(  HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL W95OptionsDlgProc( HWND, UINT, WPARAM, LPARAM );


//
// registry.c
//

VOID SetDevmodeFlags ( INT, BOOL );
VOID GetDevmodeFlags ( INT );
VOID SetQuickResFlags( VOID );
VOID GetQuickResFlags( VOID );
VOID SetRegistryValue( LPTSTR, UINT, PVOID, UINT );
VOID SaveAllSettings ( VOID );


//
//Macros
//

#define fShowModesThatNeedRestart (QuickResFlags & QF_SHOWRESTART)
#define fUpdateReg                (QuickResFlags & QF_UPDATEREG)
#define fRememberModes            (QuickResFlags & QF_REMMODES)
#define fSortByBPP                (QuickResFlags & QF_SORT_BYBPP)
#define fHide4BppModes            (QuickResFlags & QF_HIDE_4BPP)
#define fShowTestedModes          (QuickResFlags & QF_SHOWTESTED)
#define fShowFreqs                (QuickResFlags & QF_SHOWFREQS)

//
// Devmode info
//

#define BPP(x)  ((x)->dmBitsPerPel)
#define XRES(x) ((x)->dmPelsWidth)
#define YRES(x) ((x)->dmPelsHeight)
#define HZ(x)   ((x)->dmDisplayFrequency)

#define FREQMENU(x)   ((x)->uFreqMenu)
#define MENUITEM(x)   ((x)->uMenuItem)
#define CDSTEST(x)    ((x)->uCDSTest)
#define VALIDMODE(x)  ((x)->uValidMode)


//
//  Must leave MODE_VALID=1, MODE_BESTHZ=3.  
//  Other MODE_* constants should be even

#define fGoodMode(x)  ((x)->uValidMode & 0x1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\calcerr.h ===
//
// CalcErr.h
//
// Defines the error codes thrown by ratpak and caught by Calculator
//
//
//  Ratpak errors are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-------+---------------------+-------------------------------+
//  |S|   R   |    Facility         |               Code            |
//  +-+-------+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail
//
//      R - Reserved - not currently used for anything
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the actual error code
//
// This format is based losely on an OLE HRESULT and is compatible with the
// SUCCEEDED and FAILED marcos as well as the HRESULT_CODE macro

// CALC_E_DIVIDEBYZERO
//
// The current operation would require a divide by zero to complete
#define CALC_E_DIVIDEBYZERO     ((DWORD)0x80000000)

// CALC_E_DOMAIN
//
// The given input is not within the domain of this function
#define CALC_E_DOMAIN           ((DWORD)0x80000001)

// CALC_E_INDEFINITE
//
// The result of this function is undefined
#define CALC_E_INDEFINITE        ((DWORD)0x80000002)

// CALC_E_POSINFINITY
//
// The result of this function is Positive Infinity.
#define CALC_E_POSINFINITY      ((DWORD)0x80000003)

// CALC_E_NEGINFINITY
//
// The result of this function is Negative Infinity
#define CALC_E_NEGINFINITY      ((DWORD)0x80000004)

// CALC_E_ABORTED
//
// The user aborted the completion of this function
#define CALC_E_ABORTED          ((DWORD)0x80000005)

// CALC_E_INVALIDRANGE
//
// The given input is within the domain of the function but is beyond
// the range for which calc can successfully compute the answer
#define CALC_E_INVALIDRANGE     ((DWORD)0x80000006)

// CALC_E_OUTOFMEMORY
//
// There is not enough free memory to complete the requested function
#define CALC_E_OUTOFMEMORY      ((DWORD)0x80000007)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\debug.h ===
//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );
//HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
// HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
void MemExitCheckWorker(void);


//#   define  MemAlloc( f, s )    MemAllocWorker( __FILE__, __LINE__, f, s )
//#   define  MemFree( h )        MemFreeWorker( __FILE__, __LINE__, h )
#   define  MEM_EXIT_CHECK()    MemExitCheckWorker()
#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSCPL.CPL: %s\n"), TEXT(t) )
#else
//#   define  MemAlloc( f, s )    LocalAlloc( f, s )
//#   define  MemFree( h )        LocalFree( h )
#   define  MEM_EXIT_CHECK()
#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\debug.c ===
//------------------------------------------------------------*
//  File name:    DEBUG.C
//
//  Description:  Debug helper code for System control panel
//                applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1996
//  All rights reserved
//
//  History
//      10-Nov-1996 JonPa       Created it.
//
//------------------------------------------------------------*
#include <windows.h>
#include "debug.h"

///////////////////////////////////////////////////////////////
//      Constants
///////////////////////////////////////////////////////////////

#ifdef DBG_CODE

#define CCH_LABEL (sizeof(DWORD) * 2)   // 64 BITS == 8 ANSI chars

#define CB_TAG     sizeof(DWORD)
#define DW_TAG      ((DWORD)(0x434C4143))   // 'CALC'

#define DW_TAG2     ((DWORD)(0x444F4F47))   // 'GOOD'

#define CH_FILL     '*'

///////////////////////////////////////////////////////////////
//      Structures and Types
///////////////////////////////////////////////////////////////

//
// NOTE!!!!
//
// The HOBJHDR structure MUST be a multiple of 8 bytes (64bits) in len!
// otherwise this code will *FAULT* on ALPHA machines!
//

typedef struct HHO *PHHO;

struct HHO {
    PHHO    phhoNext;
    PHHO    phhoPrev;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    DWORD   cBytesData;
    DWORD   dwTmp;
    DWORD   dwTag2;
};

typedef struct HHO HOBJHDR;

typedef struct {
    LPVOID  pvPtr;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    CHAR    szFreedBy[CCH_LABEL];
    DWORD   iLineFreed;
} FREELOGREC, *PFREELOGREC;

///////////////////////////////////////////////////////////////
//      Global variables
///////////////////////////////////////////////////////////////

//
// Root of memory chain

HOBJHDR ghhoRoot = { &ghhoRoot, &ghhoRoot, { 'R', 'O', 'O', 'T' }, 0, sizeof(ghhoRoot) };


//
// Buffer used for OutputDebugString formatting (See DbgPrintf and DbgStopX)

TCHAR szDbgOutBuffer[1024];

//
// Buffer used for logging

#define CFLR_MAX    1024
FREELOGREC aflrFreeLog[CFLR_MAX];
PFREELOGREC g_pflrUnused = NULL;

#define NextFreeLogRec( pflr )    ((pflr >= &aflrFreeLog[CFLR_MAX-1]) ? aflrFreeLog : pflr+1)
#define PrevFreeLogRec( pflr )    ((pflr <= aflrFreeLog) ? &aflrFreeLog[CFLR_MAX-1] : pflr-1)

//---------------------------------------------------------------
//
// void DbgPrintf( LPTSTR szFmt, ... )
//
//  Formatted version of OutputDebugString
//
//  Parameters: Same as printf()
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void DbgPrintf( LPTSTR szFmt, ... ) {
    va_list marker;

    va_start( marker, szFmt );

    wvsprintf( szDbgOutBuffer, szFmt, marker );
    OutputDebugString( szDbgOutBuffer );

    va_end( marker );
}


//---------------------------------------------------------------
//
// void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
//
//  Print a string (with location id) and then break
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      szText      Text string to send to debug port
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText ) {
    int cch;

    wsprintf( szDbgOutBuffer, TEXT("RATPAK (%hs %d) : %s\n"), mszFile, iLine, szText );

    OutputDebugString(szDbgOutBuffer);

    DebugBreak();
}

//---------------------------------------------------------------
//
// void MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes)
//
//  Debug replacement for LocalAlloc
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      uFlags      same as LocalAlloc
//      cBytes      same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes) {
    PHHO phhoNew;
    HLOCAL hMem;
    LPSTR psz;
    UINT i, cBytesAlloc;

    cBytesAlloc = cBytes;
    
    //
    // If fixed alloc...
    //
    if ((uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE)) != 0) {
        DBGSTOPX( szFile, iLine, "Attempting to allocate movable memory... Returning NULL");
        return NULL;
    }

    cBytesAlloc = cBytes + sizeof(HOBJHDR);
    
    // DWORD align Tag
    cBytesAlloc = ((cBytesAlloc + 3) & ~3);
    cBytesAlloc += CB_TAG;


    hMem = LocalAlloc( uFlags, cBytesAlloc );
    
    //
    // If a valid pointer, and it is a fixed pointer...
    //
    phhoNew = (PHHO)hMem;

    if (hMem != NULL) {


        phhoNew->phhoNext = ghhoRoot.phhoNext;
        ghhoRoot.phhoNext = phhoNew;
        phhoNew->phhoNext->phhoPrev = phhoNew;
        phhoNew->phhoPrev = &ghhoRoot;

        phhoNew->dwTag2 = DW_TAG2;

        for( psz = szFile; *psz != '\0'; psz++ );

        for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
        if (*psz == ':' || *psz == '/' || *psz == '\\')
            psz++;

        for( i = 0; i < CCH_LABEL; i++ ) {
            phhoNew->szFile[i] = *psz;
            if (*psz) {
                psz++;
            }
        }

        phhoNew->iLine = iLine;

        phhoNew->cBytesData = cBytes;

        phhoNew += 1;   // point phhoNew to 1st byte after structure
        
        // round up to nearest DWORD
        { LPBYTE pb = (LPBYTE)phhoNew + cBytes;

            cBytesAlloc -= CB_TAG;
            cBytes += sizeof(HOBJHDR);

            while( cBytes < cBytesAlloc ) {
                *pb++ = CH_FILL;
                cBytes++;
            }

            *((LPDWORD)pb) = DW_TAG;
        }
    }

    return (HLOCAL)phhoNew;
}

//---------------------------------------------------------------
//
// void MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem )
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
HLOCAL MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem ) {
    PHHO phhoMem;
    UINT uFlags;
    UINT cBytes, cBytesAlloc;
    LPSTR psz;
    INT  i;


    if (g_pflrUnused == NULL) {
        ZeroMemory( aflrFreeLog, sizeof(aflrFreeLog) );
        g_pflrUnused = aflrFreeLog;
    }

    if (hMem == NULL) {
        DBGSTOPX( szFile, iLine, "Freeing NULL handle!");
        return LocalFree(hMem);
    }

    phhoMem = (PHHO)hMem - 1;

    if (phhoMem->dwTag2 != DW_TAG2) {
        PFREELOGREC pflr;
        //
        // Our tag has been stompped on, see if we have already freed this object
        //
        for( pflr = PrevFreeLogRec(g_pflrUnused); pflr != g_pflrUnused; pflr = PrevFreeLogRec(pflr) ) {
            if (pflr->pvPtr == phhoMem) {
                DBGPRINTF((TEXT("RATPAK: Object may have already been freed by %.8hs line %d\n(that obj was allocated by %.8hs line %d)\n"),
                    pflr->szFreedBy, pflr->iLineFreed, pflr->szFile, pflr->iLine));
                break;
            }
        }

        DBGPRINTF((TEXT("RATPAK: Trashed memory object (0x%X%08X) was allocated in %.8hs line %d (%d bytes)\n"), (DWORD)(((DWORDLONG)hMem) >> 32), PtrToUlong(hMem), phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
    }

    cBytes = phhoMem->cBytesData;

#if 0
    if (cBytes < 0) {
        // Not our object?
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
        return LocalFree(hMem);
    }
#endif

    cBytes += sizeof(HOBJHDR);
    
    // DWORD align
    cBytesAlloc = (cBytes + 3) & ~3;

    { LPBYTE pb = (LPBYTE)(phhoMem);
        pb += cBytes;
        while( cBytes < cBytesAlloc ) {
            if (*pb++ != CH_FILL) {
                DBGPRINTF((TEXT("RATPAK: Trashed memory object (0x%08X) was allocated in %.8hs line %d (%d bytes)\n"),
                        hMem, phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
                DBGSTOPX( szFile, iLine, "End of structure overwritten");
            }
            cBytes++;
        }

        if (*((LPDWORD)pb) != DW_TAG) {
            DBGPRINTF((TEXT("RATPAK: Memory object (0x%08X) was not allocated!\n"), hMem));
            DBGSTOPX( szFile, iLine, "Freeing structure that was not allocated!");
            
            // Not our structure
            return LocalFree(hMem);
        }
    }
    
    // Our structure, check header
    if (phhoMem->phhoNext->phhoPrev != phhoMem || phhoMem->phhoPrev->phhoNext != phhoMem ) {
        DBGPRINTF((TEXT("RATPAK: Orphaned memory object (0x%08X) was allocated in %.8hs line %d (%d bytes)\n"),
                hMem, phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Attempting to free orphaned memory object");
    }

    phhoMem->phhoPrev->phhoNext = phhoMem->phhoNext;
    phhoMem->phhoNext->phhoPrev = phhoMem->phhoPrev;
    
    //
    // Log this free, incase we try and free it twice
    //
    
    // Mark as freed
    phhoMem->dwTag2 = 0;
    
    // Remember who alloc'ed obj
    g_pflrUnused->pvPtr = phhoMem;
    CopyMemory( g_pflrUnused->szFile, phhoMem->szFile, sizeof(g_pflrUnused->szFile) );
    g_pflrUnused->iLine = phhoMem->iLine;
    
    // Remember who freed the obj
    for( psz = szFile; *psz != '\0'; psz++ );

    for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
    if (*psz == ':' || *psz == '/' || *psz == '\\')
        psz++;

    for( i = 0; i < CCH_LABEL; i++ ) {
        g_pflrUnused->szFreedBy[i] = *psz;
        if (*psz) {
            psz++;
        }
    }
    g_pflrUnused->iLineFreed = iLine;
    
    // Point roaming ptr to next record and mark as unused
    g_pflrUnused = NextFreeLogRec(g_pflrUnused);
    ZeroMemory( g_pflrUnused, sizeof(*g_pflrUnused) );

    return LocalFree(phhoMem);
}

//---------------------------------------------------------------
//
//  void MemExitCheckWorker() {
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void MemExitCheckWorker( void ) {
    PHHO phho;

    for( phho = ghhoRoot.phhoNext; phho != &ghhoRoot; phho = phho->phhoNext ) {
        DBGPRINTF((TEXT("RATPAK: Exiting with out freeing object (Header=0x%08X) allocated in %.8hs line %d (%d bytes)\n"),
                phho, phho->szFile, phho->iLine, phho->cBytesData));
    }
}

#endif // DBG_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\exp.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           exp.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains exp, and log functions for rationals
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

//-----------------------------------------------------------------------------
//
//  FUNCTION: exprat
//
//  ARGUMENTS: x PRAT representation of number to exponentiate
//
//  RETURN: exp  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j      j+1
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------

void _exprat( PRAT *px )

{
    CREATETAYLOR();

    addnum(&(pret->pp),num_one, BASEX); 
    addnum(&(pret->pq),num_one, BASEX); 
    DUPRAT(thisterm,pret);

    n2=longtonum(0L, BASEX);

    do    {
        NEXTTERM(*px, INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) && !fhalt );

    DESTROYTAYLOR();
}

void exprat( PRAT *px )

{
    PRAT pwr=NULL;
    PRAT pint=NULL;
    long intpwr;

    if ( rat_gt( *px, rat_max_exp ) || rat_lt( *px, rat_min_exp ) )
        {
        // Don't attempt exp of anything large.
        throw( CALC_E_DOMAIN );
        }

    DUPRAT(pwr,rat_exp);
    DUPRAT(pint,*px);

    intrat(&pint);

    intpwr = rattolong(pint);
    ratpowlong( &pwr, intpwr );

    subrat(px,pint);
    
    // It just so happens to be an integral power of e.
    if ( rat_gt( *px, rat_negsmallest ) && rat_lt( *px, rat_smallest ) )
        {
        DUPRAT(*px,pwr);
        }
    else
        {
        _exprat(px);
        mulrat(px,pwr);
        }

    destroyrat( pwr );
    destroyrat( pint );
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: lograt, _lograt
//
//  ARGUMENTS: x PRAT representation of number to logarithim
//
//  RETURN: log  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___
//   \  ]                                             j*(1-X)
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j      j+1
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   Number is scaled between one and e_to_one_half prior to taking the
//   log. This is to keep execution time from exploding.
//
//
//-----------------------------------------------------------------------------

void _lograt( PRAT *px )

{
    CREATETAYLOR();

    createrat(thisterm);
    
    // sub one from x
    (*px)->pq->sign *= -1;
    addnum(&((*px)->pp),(*px)->pq, BASEX);
    (*px)->pq->sign *= -1;

    DUPRAT(pret,*px);
    DUPRAT(thisterm,*px);

    n2=longtonum(1L, BASEX);
    (*px)->pp->sign *= -1;

    do    {
        NEXTTERM(*px, MULNUM(n2) INC(n2) DIVNUM(n2));
        TRIMTOP(*px);
        } while ( !SMALL_ENOUGH_RAT( thisterm ) && !fhalt );

    DESTROYTAYLOR();
}


void lograt( PRAT *px )

{
    BOOL fneglog;
    PRAT pwr=NULL;            // pwr is the large scaling factor.
    PRAT offset=NULL;        // offset is the incremental scaling factor.
    
    
    // Check for someone taking the log of zero or a negative number.
    if ( rat_le( *px, rat_zero ) )
        {
        throw( CALC_E_DOMAIN );
        }
    
    // Get number > 1, for scaling
    fneglog = rat_lt( *px, rat_one );
    if ( fneglog )
        {
        // WARNING: This is equivalent to doing *px = 1 / *px
        PNUMBER pnumtemp=NULL;
        pnumtemp = (*px)->pp;
        (*px)->pp = (*px)->pq;
        (*px)->pq = pnumtemp;
        }
    
    // Scale the number within BASEX factor of 1, for the large scale.
    // log(x*2^(BASEXPWR*k)) = BASEXPWR*k*log(2)+log(x)
    if ( LOGRAT2(*px) > 1 )
        {
        // Take advantage of px's base BASEX to scale quickly down to 
        // a reasonable range.
        long intpwr;
        intpwr=LOGRAT2(*px)-1;
        (*px)->pq->exp += intpwr;
        pwr=longtorat(intpwr*BASEXPWR);
        mulrat(&pwr,ln_two);
        // ln(x+e)-ln(x) looks close to e when x is close to one using some
        // expansions.  This means we can trim past precision digits+1.
        TRIMTOP(*px);
        }
    else
        {
        DUPRAT(pwr,rat_zero);
        }

    DUPRAT(offset,rat_zero);
    // Scale the number between 1 and e_to_one_half, for the small scale.
    while ( rat_gt( *px, e_to_one_half ) && !fhalt )
        {
        divrat( px, e_to_one_half );
        addrat( &offset, rat_one );
        }

    _lograt(px);
    
    // Add the large and small scaling factors, take into account
    // small scaling was done in e_to_one_half chunks.
    divrat(&offset,rat_two);
    addrat(&pwr,offset);
    
    // And add the resulting scaling factor to the answer.
    addrat(px,pwr);

    trimit(px);
    
    // If number started out < 1 rescale answer to negative.
    if ( fneglog )
        {
        (*px)->pp->sign *= -1;
        }

    destroyrat(pwr);
}
    
void log10rat( PRAT *px )

{
    lograt(px);
    divrat(px,ln_ten);
}


//---------------------------------------------------------------------------
//
//  FUNCTION: powrat
//
//  ARGUMENTS: PRAT *px, and PRAT y
//
//  RETURN: none, sets *px to *px to the y.
//
//  EXPLANATION: This uses x^y=e(y*ln(x)), or a more exact calculation where
//  y is an integer.
//  Assumes, all checking has been done on validity of numbers.
//
//
//---------------------------------------------------------------------------

void powrat( PRAT *px, PRAT y )

{
    PRAT podd=NULL;
    PRAT plnx=NULL;
    long sign=1;
    sign=( (*px)->pp->sign * (*px)->pq->sign );
    
    // Take the absolute value
    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;

    if ( zerrat( *px ) )
        {
        // *px is zero.
        if ( rat_lt( y, rat_zero ) )
            {
            throw( CALC_E_DOMAIN );
            }
        else if ( zerrat( y ) )
            {
            // *px and y are both zero, special case a 1 return.
            DUPRAT(*px,rat_one);
            // Ensure sign is positive.
            sign = 1;
            }
        }
    else 
        {
        PRAT pxint=NULL;
        DUPRAT(pxint,*px);
        subrat(&pxint,rat_one);
        if ( rat_gt( pxint, rat_negsmallest ) && 
             rat_lt( pxint, rat_smallest ) && ( sign == 1 ) )
            {
            // *px is one, special case a 1 return.
            DUPRAT(*px,rat_one);
            // Ensure sign is positive.
            sign = 1;
            }
        else
            {

            // Only do the exp if the number isn't zero or one
            DUPRAT(podd,y);
            fracrat(&podd);
            if ( rat_gt( podd, rat_negsmallest ) && rat_lt( podd, rat_smallest ) )
                {
                // If power is an integer let ratpowlong deal with it.
                PRAT iy = NULL;
                long inty;
                DUPRAT(iy,y);
                subrat(&iy,podd);
                inty = rattolong(iy);

                DUPRAT(plnx,*px);
                lograt(&plnx);
                mulrat(&plnx,iy);
                if ( rat_gt( plnx, rat_max_exp ) || rat_lt( plnx, rat_min_exp ) )
                    {
                    // Don't attempt exp of anything large or small.A
                    destroyrat(plnx);
                    destroyrat(iy);
                    throw( CALC_E_DOMAIN );
                    }
                destroyrat(plnx);
                ratpowlong(px,inty);
                if ( ( inty & 1 ) == 0 )
                    {
                    sign=1;
                    }
                destroyrat(iy);
                }
            else
                {
                // power is a fraction
                if ( sign == -1 )
                    {
                    // And assign the sign after computations, if appropriate.
                    if ( rat_gt( y, rat_neg_one ) && rat_lt( y, rat_zero ) )
                        {
                        // Check to see if reciprocal is odd.
                        DUPRAT(podd,rat_one);
                        divrat(&podd,y);
                        // Only interested in the absval for determining oddness.
                        podd->pp->sign = 1;
                        podd->pq->sign = 1;
                        divrat(&podd,rat_two);
                        fracrat(&podd);
                        addrat(&podd,podd);
                        subrat(&podd,rat_one);
                        if ( rat_lt( podd, rat_zero ) )
                            {
                            // Negative nonodd root of negative number.
                            destroyrat(podd);
                            throw( CALC_E_DOMAIN );
                            }
                        }
                    else
                        {
                        // Negative nonodd power of negative number.
                        destroyrat(podd);
                        throw( CALC_E_DOMAIN );
                        }

                     }
                 else
                     {
                     // If the exponent is not odd disregard the sign.
                     sign = 1;
                     }
    
                 lograt( px );
                 mulrat( px, y );
                 exprat( px );
                 }
             destroyrat(podd);
             }
        destroyrat(pxint);
        }
    (*px)->pp->sign *= sign;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\conv.c ===
//---------------------------------------------------------------------------
//  Package Title  ratpak
//  File           conv.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-97 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains conversion, input and output routines for numbers rationals
//  and longs.
//
//
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <tchar.h>      // TCHAR version of sprintf
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

BOOL fparserror=FALSE;
BOOL gbinexact=FALSE;

// digits 0..64 used by bases 2 .. 64
TCHAR digits[65]=TEXT("0123456789")
TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
TEXT("abcdefghijklmnopqrstuvwxyz_@");

// ratio of internal 'digits' to output 'digits'
// Calculated elsewhere as part of initialization and when base is changed
long ratio;    // int(log(2L^BASEXPWR)/log(nRadix))

// Used to strip trailing zeroes, and prevent combinatorial explosions
BOOL stripzeroesnum( PNUMBER pnum, long starting );

// returns int(lognRadix(x)) quickly.
long longlognRadix( long x );


//----------------------------------------------------------------------------
//
//    FUNCTION: fail
//
//    ARGUMENTS: pointer to an error message.
//
//    RETURN: None
//
//    DESCRIPTION: fail dumps the error message then throws an exception
//
//----------------------------------------------------------------------------

void fail( IN long errmsg )

{
#ifdef DEBUG
    fprintf( stderr, "%s\n", TEXT("Out of Memory") );
#endif
    throw( CALC_E_OUTOFMEMORY );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: _destroynum
//
//    ARGUMENTS: pointer to a number
//
//    RETURN: None
//
//    DESCRIPTION: Deletes the number and associated allocation
//
//-----------------------------------------------------------------------------

void _destroynum( IN PNUMBER pnum )

{
    if ( pnum != NULL )
        {
        zfree( pnum );
        }
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: _destroyrat
//
//    ARGUMENTS: pointer to a rational
//
//    RETURN: None
//
//    DESCRIPTION: Deletes the rational and associated
//    allocations.
//
//-----------------------------------------------------------------------------

void _destroyrat( IN PRAT prat )

{
    if ( prat != NULL )
        {
        destroynum( prat->pp );
        destroynum( prat->pq );
        zfree( prat );
        }
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: _createnum
//
//    ARGUMENTS: size of number in 'digits'
//
//    RETURN: pointer to a number
//
//    DESCRIPTION: allocates and zeroes out number type.
//
//-----------------------------------------------------------------------------

PNUMBER _createnum( IN long size )

{
    PNUMBER pnumret=NULL;

    // sizeof( MANTTYPE ) is the size of a 'digit'
    pnumret = (PNUMBER)zmalloc( (int)(size+1) * sizeof( MANTTYPE ) +
        sizeof( NUMBER ) );
    if ( pnumret == NULL )
        {
        fail( CALC_E_OUTOFMEMORY );
        }
    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: _createrat
//
//    ARGUMENTS: none
//
//    RETURN: pointer to a rational
//
//    DESCRIPTION: allocates a rational structure but does not
//    allocate the numbers that make up the rational p over q
//    form.  These number pointers are left pointing to null.
//
//-----------------------------------------------------------------------------


PRAT _createrat( void )

{
    PRAT prat=NULL;

    prat = (PRAT)zmalloc( sizeof( RAT ) );

    if ( prat == NULL )
        {
        fail( CALC_E_OUTOFMEMORY );
        }
    prat->pp = NULL;
    prat->pq = NULL;
    return( prat );
}



//-----------------------------------------------------------------------------
//
//    FUNCTION: numtorat
//
//    ARGUMENTS: pointer to a number, nRadix number is in.
//
//    RETURN: Rational representation of number.
//
//    DESCRIPTION: The rational representation of the number
//    is guaranteed to be in the form p (number with internal
//    base   representation) over q (number with internal base
//    representation)  Where p and q are integers.
//
//-----------------------------------------------------------------------------

PRAT numtorat( IN PNUMBER pin, IN unsigned long nRadix )

{
    PRAT pout=NULL;
    PNUMBER pnRadixn=NULL;
    PNUMBER qnRadixn=NULL;

    DUPNUM( pnRadixn, pin );

    qnRadixn=longtonum( 1, nRadix );

    // Ensure p and q start out as integers.
    if ( pnRadixn->exp < 0 )
        {
        qnRadixn->exp -= pnRadixn->exp;
        pnRadixn->exp = 0;
        }

    createrat(pout);

    // There is probably a better way to do this.
    pout->pp = numtonRadixx( pnRadixn, nRadix, ratio );
    pout->pq = numtonRadixx( qnRadixn, nRadix, ratio );


    destroynum( pnRadixn );
    destroynum( qnRadixn );

    return( pout );
}



//----------------------------------------------------------------------------
//
//    FUNCTION: nRadixxtonum
//
//    ARGUMENTS: pointer to a number, base requested.
//
//    RETURN: number representation in nRadix requested.
//
//    DESCRIPTION: Does a base conversion on a number from
//    internal to requested base. Assumes number being passed
//    in is really in internal base form.
//
//----------------------------------------------------------------------------

PNUMBER nRadixxtonum( IN PNUMBER a, IN unsigned long nRadix )

{
    PNUMBER sum=NULL;
    PNUMBER powofnRadix=NULL;
    unsigned long bitmask;
    unsigned long cdigits;
    MANTTYPE *ptr;

    sum = longtonum( 0, nRadix );
    powofnRadix = longtonum( BASEX, nRadix );

    // A large penalty is paid for conversion of digits no one will see anyway.
    // limit the digits to the minimum of the existing precision or the
    // requested precision.
    cdigits = maxout + 1;
    if ( cdigits > (unsigned long)a->cdigit )
        {
        cdigits = (unsigned long)a->cdigit;
        }

    // scale by the internal base to the internal exponent offset of the LSD
    numpowlong( &powofnRadix, a->exp + (a->cdigit - cdigits), nRadix );

    // Loop over all the relative digits from MSD to LSD
    for ( ptr = &(MANT(a)[a->cdigit-1]); cdigits > 0 && !fhalt;
        ptr--, cdigits-- )
        {
        // Loop over all the bits from MSB to LSB
        for ( bitmask = BASEX/2; bitmask > 0; bitmask /= 2 )
            {
            addnum( &sum, sum, nRadix );
            if ( *ptr & bitmask )
                {
                sum->mant[0] |= 1;
                }
            }
        }

    // Scale answer by power of internal exponent.
    mulnum( &sum, powofnRadix, nRadix );

    destroynum( powofnRadix );
    sum->sign = a->sign;
    return( sum );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numtonRadixx
//
//    ARGUMENTS: pointer to a number, nRadix of that number.
//       previously calculated ratio
//
//    RETURN: number representation in internal nRadix.
//
//    DESCRIPTION: Does a nRadix conversion on a number from
//    specified nRadix to requested nRadix.  Assumes the nRadix
//    specified is the nRadix of the number passed in.
//
//-----------------------------------------------------------------------------

PNUMBER numtonRadixx( IN PNUMBER a, IN unsigned long nRadix, IN long ratio )

{
    PNUMBER pnumret = NULL;        // pnumret is the number in internal form.
    PNUMBER thisdigit = NULL;      // thisdigit holds the current digit of a
                                   // being summed into result.
    PNUMBER powofnRadix = NULL;    // offset of external base exponent.
    MANTTYPE *ptrdigit;            // pointer to digit being worked on.
    long idigit;                   // idigit is the iterate of digits in a.


    pnumret = longtonum( 0, BASEX );

    ptrdigit = MANT(a);

    // Digits are in reverse order, back over them LSD first.
    ptrdigit += a->cdigit-1;


    for ( idigit = 0; idigit < a->cdigit; idigit++ )
        {
        mulnumx( &pnumret, num_nRadix );
        // WARNING:
        // This should just smack in each digit into a 'special' thisdigit.
        // and not do the overhead of recreating the number type each time.
        thisdigit = longtonum( *ptrdigit--, BASEX );
        addnum( &pnumret, thisdigit, BASEX );
        destroynum( thisdigit );
        }
    DUPNUM( powofnRadix, num_nRadix );

    // Calculate the exponent of the external base for scaling.
    numpowlongx( &powofnRadix, a->exp );

    // ... and scale the result.
    mulnumx( &pnumret, powofnRadix );

    destroynum( powofnRadix );

    // And propagate the sign.
    pnumret->sign = a->sign;

    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: inrat
//
//  ARGUMENTS:
//              fMantIsNeg true if mantissa is less than zero
//              pszMant a string representation of a number
//              fExpIsNeg  true if exponent is less than zero
//              pszExp a string representation of a number
//
//  RETURN: prat    representation of string input.
//          Or NULL if no number scanned.
//
//  EXPLANATION: This is for calc.
//
//
//-----------------------------------------------------------------------------

PRAT inrat( IN BOOL fMantIsNeg, IN LPTSTR pszMant, IN BOOL fExpIsNeg,
    IN LPTSTR pszExp )

{
    PNUMBER pnummant=NULL;              // holds mantissa in number form.
    PNUMBER pnumexp=NULL;               // holds exponent in number form.
    PRAT pratexp=NULL;                  // holds exponent in rational form.
    PRAT prat=NULL;                     // holds exponent in rational form.
    long expt;                          // holds exponent

    // Deal with Mantissa
    if ( ( pszMant == NULL ) || ( *pszMant == TEXT('\0') ) )
        {
        // Preset value if no mantissa
        if ( ( pszExp == NULL ) || ( *pszExp == TEXT('\0') ) )
            {
            // Exponent not specified, preset value to zero
            DUPRAT(prat,rat_zero);
            }
        else
            {
            // Exponent specified, preset value to one
            DUPRAT(prat,rat_one);
            }
        }
    else
        {
        // Mantissa specified, convert to number form.
        pnummant = innum( pszMant );
        if ( pnummant == NULL )
            {
            return( NULL );
            }
        prat = numtorat( pnummant, nRadix );
        // convert to rational form, and cleanup.
        destroynum(pnummant);
        }

    if ( ( pszExp == NULL ) || ( *pszExp == TEXT('\0') ) )
        {
        // Exponent not specified, preset value to zero
        expt=0;
        }
    else
        {
        // Exponent specified, convert to number form.
        // Don't use native stuff, as it is restricted in the bases it can
        // handle.
        pnumexp = innum( pszExp );
        if ( pnumexp == NULL )
            {
            return( NULL );
            }

        // Convert exponent number form to native integral form,  and cleanup.
        expt = numtolong( pnumexp, nRadix );
        destroynum( pnumexp );
        }


    // Convert native integral exponent form to rational multiplier form.
    pnumexp=longtonum( nRadix, BASEX );
    numpowlongx(&(pnumexp),abs(expt));
    createrat(pratexp);
    DUPNUM( pratexp->pp, pnumexp );
    pratexp->pq = longtonum( 1, BASEX );
    destroynum(pnumexp);

    if ( fExpIsNeg )
        {
        // multiplier is less than 1, this means divide.
        divrat( &prat, pratexp );
        }
    else
        {
        if ( expt > 0 )
            {
            // multiplier is greater than 1, this means divide.
            mulrat(&prat, pratexp);
            }
        // multiplier can be 1, in which case it'd be a waste of time to
        // multiply.
        }

    if ( fMantIsNeg )
        {
        // A negative number was used, adjust the sign.
        prat->pp->sign *= -1;
        }
    return( prat );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: innum
//
//  ARGUMENTS:
//              TCHAR *buffer
//
//  RETURN: pnumber representation of string input.
//          Or NULL if no number scanned.
//
//  EXPLANATION: This is a state machine,
//
//    State      Description            Example, ^shows just read position.
//                                                which caused the transition
//
//    START      Start state            ^1.0
//    MANTS      Mantissa sign          -^1.0
//    LZ         Leading Zero           0^1.0
//    LZDP       Post LZ dec. pt.       000.^1
//    LD         Leading digit          1^.0
//    DZ         Post LZDP Zero         000.0^1
//    DD         Post Decimal digit     .01^2
//    DDP        Leading Digit dec. pt. 1.^2
//    EXPB       Exponent Begins        1.0e^2
//    EXPS       Exponent sign          1.0e+^5
//    EXPD       Exponent digit         1.0e1^2 or  even 1.0e0^1
//    EXPBZ      Exponent begin post 0  0.000e^+1
//    EXPSZ      Exponent sign post 0   0.000e+^1
//    EXPDZ      Exponent digit post 0  0.000e+1^2
//    ERR        Error case             0.0.^
//
//    Terminal   Description
//
//    DP         '.'
//    ZR         '0'
//    NZ         '1'..'9' 'A'..'Z' 'a'..'z' '@' '_'
//    SG         '+' '-'
//    EX         'e' '^' e is used for nRadix 10, ^ for all other nRadixs.
//
//-----------------------------------------------------------------------------

#define DP 0
#define ZR 1
#define NZ 2
#define SG 3
#define EX 4

#define START    0
#define MANTS    1
#define LZ       2
#define LZDP     3
#define LD       4
#define DZ       5
#define DD       6
#define DDP      7
#define EXPB     8
#define EXPS     9
#define EXPD     10
#define EXPBZ    11
#define EXPSZ    12
#define EXPDZ    13
#define ERR      14

#if defined( DEBUG )
char *statestr[] = {
    "START",
    "MANTS",
    "LZ",
    "LZDP",
    "LD",
    "DZ",
    "DD",
    "DDP",
    "EXPB",
    "EXPS",
    "EXPD",
    "EXPBZ",
    "EXPSZ",
    "EXPDZ",
    "ERR",
};
#endif

// New state is machine[state][terminal]
char machine[ERR+1][EX+1]= {
    //        DP,     ZR,      NZ,      SG,     EX
    // START
        {     LZDP,   LZ,      LD,      MANTS,  ERR },
    // MANTS
        {     LZDP,   LZ,      LD,      ERR,    ERR },
    // LZ
        {     LZDP,   LZ,      LD,      ERR,    EXPBZ },
    // LZDP
        {     ERR,    DZ,      DD,      ERR,    EXPB },
    // LD
        {     DDP,    LD,      LD,      ERR,    EXPB },
    // DZ
        {     ERR,    DZ,      DD,      ERR,    EXPBZ },
    // DD
        {     ERR,    DD,      DD,      ERR,    EXPB },
    // DDP
        {     ERR,    DD,      DD,      ERR,    EXPB },
    // EXPB
        {     ERR,    EXPD,    EXPD,    EXPS,   ERR },
    // EXPS
        {     ERR,    EXPD,    EXPD,    ERR,    ERR },
    // EXPD
        {     ERR,    EXPD,    EXPD,    ERR,    ERR },
    // EXPBZ
        {     ERR,    EXPDZ,   EXPDZ,   EXPSZ,  ERR },
    // EXPSZ
        {     ERR,    EXPDZ,   EXPDZ,   ERR,    ERR },
    // EXPDZ
        {     ERR,    EXPDZ,   EXPDZ,   ERR,    ERR },
    // ERR
        {     ERR,    ERR,     ERR,     ERR,    ERR }
};


PNUMBER innum( IN TCHAR *buffer )

{
    int c;                    // c is character being worked on currently.
    int state;                // state is the state of the input state machine.
    long exps = 1L;           // exps is exponent sign ( +/- 1 )
    long expt = 0L;           // expt is exponent mantissa, should be unsigned
    long length = 0L;         // length is the length of the input string.
    MANTTYPE *pmant;          //
    PNUMBER pnumret=NULL;     //

    length = _tcslen(buffer);
    createnum( pnumret, length );
    pnumret->sign = 1L;
    pnumret->cdigit = 0;
    pnumret->exp = 0;
    pmant = MANT(pnumret)+length-1;
    state = START;
    fparserror=FALSE;        // clear global flag for parse error initially.
    while ( ( c = *buffer ) && c != TEXT('\n') )
        {
        int dp;
        dp = 0;
        // Added code to deal with international decimal point.
        while ( szDec[dp] && ( szDec[dp] == *buffer ) )
            {
            dp++;
            buffer++;
            }
        if ( dp )
            {
            if ( szDec[dp] == TEXT('\0') )
                {
                // OK pretend that was a decimal point for the state machine
                c = TEXT('.');
                buffer--;
                }
            else
                {
                // Backup that was no decimal point
                buffer -= (dp-1);
                c = *buffer++;
                }
            }
        switch ( c )
            {
        case TEXT('-'):
        case TEXT('+'):
            state=machine[state][SG];
            break;
        case TEXT('.'):
            state=machine[state][DP];
            break;
        case TEXT('0'):
            state=machine[state][ZR];
            break;
        case TEXT('^'):
        case TEXT('e'):
            if ( ( c == TEXT('^') ) || ( nRadix == 10 ) )
                {
                state=machine[state][EX];
                break;
                }
        // WARNING tricky dropthrough in the TEXT('e') as a digit case!!!
        default:
            state=machine[state][NZ];
            break;
            }
        switch ( state )
            {
        case MANTS:
            pnumret->sign = ( ( c == TEXT('-') ) ? -1 : 1);
            break;
        case EXPSZ:
        case EXPS:
            exps = ( ( c == TEXT('-') ) ? -1 : 1);
            break;
        case EXPDZ:
        case EXPD:
            {
            TCHAR *ptr;               // offset into digit table.
            if ( ( nRadix <= 36 ) && ( nRadix > 10 ) )
                {
                c = toupper( c );
                }
            ptr = _tcschr( digits, (TCHAR)c );
            if ( ptr != NULL )
                {
                expt *= nRadix;
                expt += (long)(ptr - digits);
                }
            else
                {
                state=ERR;
                }
            }
            break;
        case LD:
            pnumret->exp++;
        case DD:
            {
            TCHAR *ptr;               // offset into digit table.
            if ( ( nRadix <= 36 ) && ( nRadix > 10 ) )
                {
                // Allow upper and lower case letters as equivalent, base
                // is in the range where this is not ambiguous.
                c = toupper( c );
                }
            ptr = _tcschr( digits, (TCHAR)c );
            if ( ptr != NULL && ( (ptr - digits) < nRadix ) )
                {
                *pmant-- = (MANTTYPE)(ptr - digits);
                pnumret->exp--;
                pnumret->cdigit++;
                }
            else
                {
                state=ERR;
                // set global flag for parse error just in case anyone cares.
                fparserror=TRUE;
                }
            }
            break;
        case DZ:
            pnumret->exp--;
            break;
        case LZ:
        case LZDP:
        case DDP:
            break;
            }
        buffer++;
        }
    if ( state == DZ || state == EXPDZ )
        {
        pnumret->cdigit = 1;
        pnumret->exp=0;
        pnumret->sign=1;
        }
    else
        {
        while ( pnumret->cdigit < length )
            {
            pnumret->cdigit++;
            pnumret->exp--;
            }
        pnumret->exp += exps*expt;
        }


    if ( pnumret->cdigit == 0 )
        {
        destroynum( pnumret );
        pnumret = NULL;
        }
    stripzeroesnum( pnumret, maxout );
    return( pnumret );
}



//-----------------------------------------------------------------------------
//
//    FUNCTION: longtorat
//
//    ARGUMENTS: long
//
//    RETURN: Rational representation of long input.
//
//    DESCRIPTION: Converts long input to rational (p over q)
//    form, where q is 1 and p is the long.
//
//-----------------------------------------------------------------------------

PRAT longtorat( IN long inlong )

{
    PRAT pratret=NULL;
    createrat( pratret );
    pratret->pp = longtonum(inlong, BASEX );
    pratret->pq = longtonum(1L, BASEX );
    return( pratret );
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: realtorat
//
//    ARGUMENTS: double real value.
//
//    RETURN: Rational representation of the double
//
//    DESCRIPTION: returns the rational (p over q)
//    representation of the double.
//
//-----------------------------------------------------------------------------

PRAT realtorat( IN double real )

{
#if !defined( CLEVER )
    // get clever later, right now hack something to work
    TCHAR *ptr;
    PNUMBER pnum=NULL;
    PRAT prat=NULL;
    if ( ( ptr = (TCHAR*)zmalloc( 60 * sizeof(TCHAR) ) ) != NULL )
        {
        _stprintf( ptr, TEXT("%20.20le"), real );
        pnum=innum( ptr );
        prat = numtorat( pnum, nRadix );
        destroynum( pnum );
        zfree( ptr );
        return( prat );
        }
    else
        {
        return( NULL );
        }
#else
    int i;
    union {
        double real;
        BYTE split[8];
    } unpack;
    long expt;
    long ratio;
    MANTTYPE *pmant;
    PNUMBER pnumret = NULL;
    PRAT pratret = NULL;

    createrat( pratret );

    if ( real == 0.0 )
        {
        pnumret=longtonum( 0L, 2L );
        }
    else
        {
        unpack.real=real;

        expt=unpack.split[7]*0x100+(unpack.split[6]>>4)-1023;
        createnum( pnumret, 52 );
        pmant = MANT(pnumret);
        for ( i = 63; i > 10; i-- )
            {
            *pmant++ = (MANTTYPE)((unpack.split[i/8]&(1<<(i%8)))!=0);
            }
        pnumret->exp=expt-52;
        pnumret->cdigit=52;
        }

    ratio = 1;
    while ( ratio > BASEX )
        {
        ratio *= 2;
        }

    pratret->pp = numtonRadixx( pnumret, 2, ratio );
    destroynum( pnumret );

    pratret->pq=longtonum( 1L, BASEX );

    if ( pratret->pp->exp < 0 )
        {
        pratret->pq->exp -= pratret->pp->exp;
        pratret->pp->exp = 0;
        }

    return( pratret );
#endif
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: longtonum
//
//    ARGUMENTS: long input and nRadix requested.
//
//    RETURN: number
//
//    DESCRIPTION: Returns a number representation in the
//    base   requested of the long value passed in.
//
//-----------------------------------------------------------------------------

PNUMBER longtonum( IN long inlong, IN unsigned long nRadix )

{
    MANTTYPE *pmant;
    PNUMBER pnumret=NULL;

    createnum( pnumret, MAX_LONG_SIZE );
    pmant = MANT(pnumret);
    pnumret->cdigit = 0;
    pnumret->exp = 0;
    if ( inlong < 0 )
        {
        pnumret->sign = -1;
        inlong *= -1;
        }
    else
        {
        pnumret->sign = 1;
        }

    do    {
        *pmant++ = (MANTTYPE)(inlong % nRadix);
        inlong /= nRadix;
        pnumret->cdigit++;
        } while ( inlong );

    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: rattolong
//
//    ARGUMENTS: rational number in internal base.
//
//    RETURN: long
//
//    DESCRIPTION: returns the long representation of the
//    number input.  Assumes that the number is in the internal
//    base.
//
//-----------------------------------------------------------------------------

long rattolong( IN PRAT prat )

{
    long lret;
    PRAT pint = NULL;

    if ( rat_gt( prat, rat_dword ) || rat_lt( prat, rat_min_long ) )
        {
        // Don't attempt rattolong of anything too big or small
        throw( CALC_E_DOMAIN );
        }

    DUPRAT(pint,prat);

    intrat( &pint );
    divnumx( &(pint->pp), pint->pq );
    DUPNUM( pint->pq, num_one );

    lret = numtolong( pint->pp, BASEX );

    destroyrat(pint);

    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numtolong
//
//    ARGUMENTS: number input and base   of that number.
//
//    RETURN: long
//
//    DESCRIPTION: returns the long representation of the
//    number input.  Assumes that the number is really in the
//    base   claimed.
//
//-----------------------------------------------------------------------------

long numtolong( IN PNUMBER pnum, IN unsigned long nRadix )

{
    long lret;
    long expt;
    long length;
    MANTTYPE *pmant;

    lret = 0;
    pmant = MANT( pnum );
    pmant += pnum->cdigit - 1;

    expt = pnum->exp;
    length = pnum->cdigit;
    while ( length > 0  && length + expt > 0 )
        {
        lret *= nRadix;
        lret += *(pmant--);
        length--;
        }
    while ( expt-- > 0 )
        {
        lret *= (long)nRadix;
        }
    lret *= pnum->sign;
    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: BOOL stripzeroesnum
//
//    ARGUMENTS:            a number representation
//
//    RETURN: TRUE if stripping done, modifies number in place.
//
//    DESCRIPTION: Strips off trailing zeroes.
//
//-----------------------------------------------------------------------------

BOOL stripzeroesnum( IN OUT PNUMBER pnum, long starting )

{
    MANTTYPE *pmant;
    long cdigits;
    BOOL fstrip = FALSE;

    // point pmant to the LeastCalculatedDigit
    pmant=MANT(pnum);
    cdigits=pnum->cdigit;
    // point pmant to the LSD
    if ( cdigits > starting )
        {
        pmant += cdigits - starting;
        cdigits = starting;
        }

    // Check we haven't gone too far, and we are still looking at zeroes.
    while ( ( cdigits > 0 ) && !(*pmant) )
        {
        // move to next significant digit and keep track of digits we can
    // ignore later.
        pmant++;
        cdigits--;
        fstrip = TRUE;
        }

    // If there are zeroes to remove.
    if ( fstrip )
        {
        // Remove them.
        memcpy( MANT(pnum), pmant, (int)(cdigits*sizeof(MANTTYPE)) );
        // And adjust exponent and digit count accordingly.
        pnum->exp += ( pnum->cdigit - cdigits );
        pnum->cdigit = cdigits;
        }
    return( fstrip );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: putnum
//
//    ARGUMENTS: number representation
//          fmt, one of FMT_FLOAT FMT_SCIENTIFIC or
//          FMT_ENGINEERING
//
//    RETURN: String representation of number.
//
//    DESCRIPTION: Converts a number to it's string
//    representation.  Returns a string that should be
//    zfree'd after use.
//
//-----------------------------------------------------------------------------

TCHAR *putnum( IN PNUMBER *ppnum, IN int fmt )

{
    TCHAR *psz;
    TCHAR *pret;
    long expt;        // Actual number of digits to the left of decimal
    long eout;        // Displayed exponent.
    long cexp;        // the size of the exponent needed.
    long elen;
    long length;
    MANTTYPE *pmant;
    int fsciform=0;    // If true scientific form is called for.
    PNUMBER pnum;
    PNUMBER round=NULL;
    long oldfmt = fmt;


    pnum=*ppnum;
    stripzeroesnum( pnum, maxout+2 );
    length = pnum->cdigit;
    expt = pnum->exp+length;
    if ( ( expt > maxout ) && ( fmt == FMT_FLOAT ) )
        {
        // Force scientific mode to prevent user from assuming 33rd digit is
        // exact.
        fmt = FMT_SCIENTIFIC;
        }


    // Make length small enough to fit in pret.
    if ( length > maxout )
        {
        length = maxout;
        }

    eout=expt-1;
    cexp = longlognRadix( expt );

    // 2 for signs, 1 for 'e'(or leading zero), 1 for dp, 1 for null and
    // 10 for maximum exponent size.
    pret = (TCHAR*)zmalloc( (maxout + 16) * sizeof(TCHAR) );
    psz = pret;

    if (!psz)
        {
        fail( CALC_E_OUTOFMEMORY );
        }

    // If there is a chance a round has to occour, round.
    if (
        // if number is zero no rounding.
        !zernum( pnum ) &&
        // if number of digits is less than the maximum output no rounding.
        pnum->cdigit >= maxout
        )
        {
        // Otherwise round.
        round=longtonum( nRadix, nRadix );
        divnum(&round, num_two, nRadix );

        // Make round number exponent one below the LSD for the number.
        round->exp = pnum->exp + pnum->cdigit - round->cdigit - maxout;
        round->sign = pnum->sign;
        }

    if ( fmt == FMT_FLOAT )
        {
        // cexp will now contain the size required by exponential.
        // Figure out if the exponent will fill more space than the nonexponent field.
        if ( ( length - expt > maxout + 2 ) || ( expt > maxout + 3 ) )
            {
            // Case where too many zeroes are to the right or left of the
            // decimal pt. And we are forced to switch to scientific form.
            fmt = FMT_SCIENTIFIC;
            }
        else
            {
            // Minimum loss of precision occours with listing leading zeros
            // if we need to make room for zeroes sacrifice some digits.
            if ( length + abs(expt) < maxout )
                {
                if ( round )
                    {
                    round->exp -= expt;
                    }
                }
            }
        }
    if ( round != NULL )
    	{
        BOOL fstrip=FALSE;
        long offset;
    	addnum( ppnum, round, nRadix );
    	pnum=*ppnum;
        offset=(pnum->cdigit+pnum->exp) - (round->cdigit+round->exp);
        fstrip = stripzeroesnum( pnum, offset );
        destroynum( round );
        if ( fstrip )
            {
            // WARNING: nesting/recursion, too much has been changed, need to
            // refigure format.
            return( putnum( &pnum, oldfmt ) );
            }
    	}
    else
    	{
        stripzeroesnum( pnum, maxout );
    	}

    // Set up all the post rounding stuff.
    pmant = MANT(pnum)+pnum->cdigit-1;

    if (
        // Case where too many digits are to the left of the decimal or
        // FMT_SCIENTIFIC or FMT_ENGINEERING was specified.
        ( fmt == FMT_SCIENTIFIC ) ||
        ( fmt == FMT_ENGINEERING ) )

        {
        fsciform=1;
        if ( eout != 0 )
            {

            if ( fmt == FMT_ENGINEERING )
                {
                expt = (eout % 3);
                eout -= expt;
                expt++;

                // Fix the case where 0.02e-3 should really be 2.e-6 etc.
                if ( expt < 0 )
                    {
                    expt += 3;
                    eout -= 3;
                    }

                }
            else
                {
                expt = 1;
                }
            }
        }
    else
        {
        fsciform=0;
        eout=0;
        }

    // Make sure negative zeroes aren't allowed.
    if ( ( pnum->sign == -1 ) && ( length > 0 ) )
        {
        *psz++ = TEXT('-');
        }

    if ( ( expt <= 0 ) && ( fsciform == 0 ) )
        {
        *psz++ = TEXT('0');
        *psz++ = szDec[0];
        // Used up a digit unaccounted for.
        }
    while ( expt < 0 )
        {
        *psz++ = TEXT('0');
        expt++;
        }

    while ( length > 0 )
        {
        expt--;
        *psz++ = digits[ *pmant-- ];
        length--;
        // Be more regular in using a decimal point.
        if ( expt == 0 )
            {
            *psz++ = szDec[0];
            }
        }

    while ( expt > 0 )
        {
        *psz++ = TEXT('0');
        expt--;
        // Be more regular in using a decimal point.
        if ( expt == 0 )
            {
            *psz++ = szDec[0];
            }
        }


    if ( fsciform )
        {
        if ( nRadix == 10 )
            {
            *psz++ = TEXT('e');
            }
        else
            {
            *psz++ = TEXT('^');
            }
        *psz++ = ( eout < 0 ? TEXT('-') : TEXT('+') );
        eout = abs( eout );
        elen=0;
        do
            {
            // should this be eout % nRadix?  or is that insane?
            *psz++ = digits[ eout % nRadix ];
            elen++;
            eout /= nRadix;
            } while ( eout > 0 );
        *psz = TEXT('\0');
        _tcsrev( &(psz[-elen]) );
        }
    *psz = TEXT('\0');
    return( pret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: putrat
//
//  ARGUMENTS:
//              PRAT *representation of a number.
//              long representation of base  to  dump to screen.
//              fmt, one of FMT_FLOAT FMT_SCIENTIFIC or FMT_ENGINEERING
//
//  RETURN: string
//
//  DESCRIPTION: returns a string representation of rational number passed
//  in, at least to the maxout digits.  String returned should be zfree'd
//  after use.
//
//  NOTE: It may be that doing a GCD() could shorten the rational form
//       And it may eventually be worthwhile to keep the result.  That is
//       why a pointer to the rational is passed in.
//
//-----------------------------------------------------------------------------

TCHAR *putrat( IN OUT PRAT *pa, IN unsigned long nRadix, IN int fmt )

{
    TCHAR *psz;
    PNUMBER p=NULL;
    PNUMBER q=NULL;
    long scaleby=0;


    // Convert p and q of rational form from internal base to requested base.

    // Scale by largest power of BASEX possible.

    scaleby=min((*pa)->pp->exp,(*pa)->pq->exp);
    if ( scaleby < 0 )
        {
        scaleby = 0;
        }
    (*pa)->pp->exp -= scaleby;
    (*pa)->pq->exp -= scaleby;

    p = nRadixxtonum( (*pa)->pp, nRadix );

    q = nRadixxtonum( (*pa)->pq, nRadix );

    // finally take the time hit to actually divide.
    divnum( &p, q, nRadix );

    psz = putnum( &p, fmt );
    destroynum( p );
    destroynum( q );
    return( psz );
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: gcd
//
//  ARGUMENTS:
//              PNUMBER representation of a number.
//              PNUMBER representation of a number.
//
//  RETURN: Greatest common divisor in internal BASEX PNUMBER form.
//
//  DESCRIPTION: gcd uses remainders to find the greatest common divisor.
//
//  ASSUMPTIONS: gcd assumes inputs are integers.
//
//  NOTE: Before GregSte and TimC proved the TRIM macro actually kept the
//        size down cheaper than GCD, this routine was used extensively.
//        now it is not used but might be later.
//
//-----------------------------------------------------------------------------

PNUMBER gcd( IN PNUMBER a, IN PNUMBER b )

{
    PNUMBER r=NULL;
    PNUMBER tmpa=NULL;
    PNUMBER tmpb=NULL;

    if ( lessnum( a, b ) )
        {
        DUPNUM(tmpa,b);
        if ( zernum(a) )
            {
            return(tmpa);
            }
        DUPNUM(tmpb,a);
        }
    else
        {
        DUPNUM(tmpa,a);
        if ( zernum(b) )
            {
            return(tmpa);
            }
        DUPNUM(tmpb,b);
        }

    remnum( &tmpa, tmpb, nRadix );
    while ( !zernum( tmpa ) )
        {
        // swap tmpa and tmpb
        r = tmpa;
        tmpa = tmpb;
        tmpb = r;
        remnum( &tmpa, tmpb, nRadix );
        }
    destroynum( tmpa );
    return( tmpb );

}

//-----------------------------------------------------------------------------
//
//  FUNCTION: longfactnum
//
//  ARGUMENTS:
//              long integer to factorialize.
//              long integer representing base   of answer.
//
//  RETURN: Factorial of input in nRadix PNUMBER form.
//
//  NOTE:  Not currently used.
//
//-----------------------------------------------------------------------------

PNUMBER longfactnum( IN long inlong, IN unsigned long nRadix )

{
    PNUMBER lret=NULL;
    PNUMBER tmp=NULL;
    PNUMBER tmp1=NULL;

    lret = longtonum( 1, nRadix );

    while ( inlong > 0 )
        {
        tmp = longtonum( inlong--, nRadix );
        mulnum( &lret, tmp, nRadix );
        destroynum( tmp );
        }
    return( lret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: longprodnum
//
//  ARGUMENTS:
//              long integer to factorialize.
//              long integer representing base of answer.
//
//  RETURN: Factorial of input in base PNUMBER form.
//
//-----------------------------------------------------------------------------

PNUMBER longprodnum( IN long start, IN long stop, IN unsigned long nRadix )

{
    PNUMBER lret=NULL;
    PNUMBER tmp=NULL;

    lret = longtonum( 1, nRadix );

    while ( start <= stop )
        {
        if ( start )
            {
            tmp = longtonum( start, nRadix );
            mulnum( &lret, tmp, nRadix );
            destroynum( tmp );
            }
        start++;
        }
    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numpowlong
//
//    ARGUMENTS: root as number power as long and nRadix of
//               number.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes numeric representation of root to
//    root ** power. Assumes nRadix is the nRadix of root.
//
//-----------------------------------------------------------------------------

void numpowlong( IN OUT PNUMBER *proot, IN long power,
                IN unsigned long nRadix )

{
    PNUMBER lret=NULL;

    lret = longtonum( 1, nRadix );

    while ( power > 0 )
        {
        if ( power & 1 )
            {
            mulnum( &lret, *proot, nRadix );
            }
        mulnum( proot, *proot, nRadix );
        TRIMNUM(*proot);
        power >>= 1;
        }
    destroynum( *proot );
    *proot=lret;

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: ratpowlong
//
//    ARGUMENTS: root as rational, power as long.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes rational representation of root to
//    root ** power.
//
//-----------------------------------------------------------------------------

void ratpowlong( IN OUT PRAT *proot, IN long power )

{
    if ( power < 0 )
        {
        // Take the positive power and invert answer.
        PNUMBER pnumtemp = NULL;
        ratpowlong( proot, -power );
        pnumtemp = (*proot)->pp;
        (*proot)->pp  = (*proot)->pq;
        (*proot)->pq = pnumtemp;
        }
    else
        {
        PRAT lret=NULL;

        lret = longtorat( 1 );

        while ( power > 0 )
            {
            if ( power & 1 )
                {
                mulnumx( &(lret->pp), (*proot)->pp );
                mulnumx( &(lret->pq), (*proot)->pq );
                }
            mulrat( proot, *proot );
            trimit(&lret);
            trimit(proot);
            power >>= 1;
            }
        destroyrat( *proot );
        *proot=lret;
        }
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: longlog10
//
//    ARGUMENTS: number as long.
//
//    RETURN: returns int(log10(abs(number)+1)), useful in formatting output
//
//-----------------------------------------------------------------------------

long longlognRadix( long x )

{
    long ret = 0;
    x--;
    if ( x < 0 )
        {
        x = -x;
        }
    while ( x )
        {
        ret++;
        x /= nRadix;
        }
    return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\fact.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           fact.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains fact(orial) and supporting _gamma functions.
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

#define ABSRAT(x) (((x)->pp->sign=1),((x)->pq->sign=1))
#define NEGATE(x) ((x)->pp->sign *= -1)

//-----------------------------------------------------------------------------
//
//  FUNCTION: factrat, _gamma, gamma
//
//  ARGUMENTS:  x PRAT representation of number to take the sine of
//
//  RETURN: factorial of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//      n
//     ___    2j
//   n \  ]  A       1          A
//  A   \   -----[ ---- - ---------------]
//      /   (2j)!  n+2j   (n+2j+1)(2j+1)
//     /__]
//     j=0
//
//                        / oo
//                        |    n-1 -x     __
//  This was derived from |   x   e  dx = |
//                        |               | (n) { = (n-1)! for +integers}
//                        / 0
//
//  GregSte showed the above series to be within precision if A was chosen
//  big enough.
//                          A    n  precision
//  Based on the relation ne  = A 10            A was chosen as
//
//             precision
//  A = ln(Base         /n)+1
//  A += n*ln(A)  This is close enough for precision > base and n < 1.5
//
//
//-----------------------------------------------------------------------------


void _gamma( PRAT *pn )

{
    PRAT factorial=NULL;
    PNUMBER count=NULL;
    PRAT tmp=NULL;
    PRAT one_pt_five=NULL;
    PRAT a=NULL;
    PRAT a2=NULL;
    PRAT term=NULL;
    PRAT sum=NULL;
    PRAT err=NULL;
    PRAT mpy=NULL;
    PRAT ratprec = NULL;
    PRAT ratRadix = NULL;
    long oldprec;
    
    // Set up constants and initial conditions
    oldprec = maxout;
    ratprec = longtorat( oldprec );
    
    // Find the best 'A' for convergence to the required precision.
    a=longtorat( nRadix );
    lograt(&a);
    mulrat(&a,ratprec);

    // Really is -ln(n)+1, but -ln(n) will be < 1 
    // if we scale n between 0.5 and 1.5
    addrat(&a,rat_two);
    DUPRAT(tmp,a);
    lograt(&tmp);
    mulrat(&tmp,*pn);
    addrat(&a,tmp);
    addrat(&a,rat_one);
    
    // Calculate the necessary bump in precision and up the precision.
    // The following code is equivalent to 
    // maxout += ln(exp(a)*pow(a,n+1.5))-ln(nRadix));
    DUPRAT(tmp,*pn);
    one_pt_five=longtorat( 3L );
    divrat( &one_pt_five, rat_two );
    addrat( &tmp, one_pt_five );
    DUPRAT(term,a);
    powrat( &term, tmp );
    DUPRAT( tmp, a );
    exprat( &tmp );
    mulrat( &term, tmp );
    lograt( &term );
    ratRadix = longtorat( nRadix );
    DUPRAT(tmp,ratRadix);
    lograt( &tmp );
    subrat( &term, tmp );
    maxout += rattolong( term );
    
    // Set up initial terms for series, refer to series in above comment block.
    DUPRAT(factorial,rat_one); // Start factorial out with one
    count = longtonum( 0L, BASEX );

    DUPRAT(mpy,a);
    powrat(&mpy,*pn);
    // a2=a^2
    DUPRAT(a2,a);
    mulrat(&a2,a);
    
    // sum=(1/n)-(a/(n+1))
    DUPRAT(sum,rat_one);
    divrat(&sum,*pn);
    DUPRAT(tmp,*pn);
    addrat(&tmp,rat_one);
    DUPRAT(term,a);
    divrat(&term,tmp);
    subrat(&sum,term);

    DUPRAT(err,ratRadix);
    NEGATE(ratprec);
    powrat(&err,ratprec);
    divrat(&err,ratRadix);

    // Just get something not tiny in term
    DUPRAT(term, rat_two );    

    // Loop until precision is reached, or asked to halt.
    while ( !zerrat( term ) && rat_gt( term, err) && !fhalt )
        {
        addrat(pn,rat_two);
        
        // WARNING: mixing numbers and  rationals here.  
        // for speed and efficiency.
        INC(count);
        mulnumx(&(factorial->pp),count);
        INC(count)
        mulnumx(&(factorial->pp),count);

        divrat(&factorial,a2);

        DUPRAT(tmp,*pn);
        addrat( &tmp, rat_one );
        destroyrat(term);
        createrat(term);
        DUPNUM(term->pp,count);
        DUPNUM(term->pq,num_one);
        addrat( &term, rat_one );
        mulrat( &term, tmp );
        DUPRAT(tmp,a);
        divrat( &tmp, term );

        DUPRAT(term,rat_one);
        divrat( &term, *pn);
        subrat( &term, tmp);
        
        divrat (&term, factorial);
        addrat( &sum, term);
        ABSRAT(term);
        }
    
    // Multiply by factor.
    mulrat( &sum, mpy );
    
    // And cleanup
    maxout = oldprec;
    destroyrat(ratprec);
    destroyrat(err);
    destroyrat(term);
    destroyrat(a);
    destroyrat(a2);
    destroyrat(tmp);
    destroyrat(one_pt_five);

    destroynum(count);

    destroyrat(factorial);
    destroyrat(*pn);
    DUPRAT(*pn,sum);
    destroyrat(sum);
}

void factrat( PRAT *px )

{
    PRAT fact = NULL;
    PRAT frac = NULL;
    PRAT neg_rat_one = NULL;
    DUPRAT(fact,rat_one);

    DUPRAT(neg_rat_one,rat_one);
    neg_rat_one->pp->sign *= -1;

    DUPRAT( frac, *px );
    fracrat( &frac );

    // Check for negative integers and throw an error.
    if ( ( zerrat(frac) || ( LOGRATRADIX(frac) <= -maxout ) ) && 
		( (*px)->pp->sign * (*px)->pq->sign == -1 ) )
		{
        throw CALC_E_DOMAIN;
		}
    while ( rat_gt(  *px, rat_zero ) && !fhalt && 
        ( LOGRATRADIX(*px) > -maxout ) )
        {
        mulrat( &fact, *px );
        subrat( px, rat_one );
        }
    
    // Added to make numbers 'close enough' to integers use integer factorial.
    if ( LOGRATRADIX(*px) <= -maxout )
        {
        DUPRAT((*px),rat_zero);
        intrat(&fact);
        }

    while ( rat_lt(  *px, neg_rat_one ) && !fhalt )
        {
        addrat( px, rat_one );
        divrat( &fact, *px );
        }

    if ( rat_neq( *px, rat_zero ) )
        {
        addrat( px, rat_one );
        _gamma( px );
        mulrat( px, fact );
        }
    else
        {
        DUPRAT(*px,fact);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\itransh.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           itransh.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-97 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//    Contains inverse hyperbolic sin, cos, and tan functions.
//
//  Special Information
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


//-----------------------------------------------------------------------------
//
//  FUNCTION: asinhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//    hyperbolic sine of
//  RETURN: asinh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                           -(2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   For abs(x) < .85, and
//
//   asinh(x) = log(x+sqrt(x^2+1))
//
//   For abs(x) >= .85
//
//-----------------------------------------------------------------------------

void asinhrat( PRAT *px )

{
    PRAT neg_pt_eight_five = NULL;

    DUPRAT(neg_pt_eight_five,pt_eight_five);
    neg_pt_eight_five->pp->sign *= -1;
    if ( rat_gt( *px, pt_eight_five) || rat_lt( *px, neg_pt_eight_five) )
        {
        PRAT ptmp = NULL;
        DUPRAT(ptmp,(*px)); 
        mulrat(&ptmp,*px);
        addrat(&ptmp,rat_one);
        rootrat(&ptmp,rat_two);
        addrat(px,ptmp);
        lograt(px);
        destroyrat(ptmp);
        }
    else
        {
        CREATETAYLOR();
        xx->pp->sign *= -1;

        DUPRAT(pret,(*px)); 
        DUPRAT(thisterm,(*px));

        DUPNUM(n2,num_one);

        do
            {
            NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
                INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
            }
        while ( !SMALL_ENOUGH_RAT( thisterm ) );

        DESTROYTAYLOR();
        }
    destroyrat(neg_pt_eight_five);
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: acoshrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//    hyperbolic cose of
//  RETURN: acosh of x in PRAT form.
//
//  EXPLANATION: This uses 
//
//   acosh(x)=ln(x+sqrt(x^2-1))
//
//   For x >= 1
//
//-----------------------------------------------------------------------------

void acoshrat( PRAT *px )

{
    if ( rat_lt( *px, rat_one ) )
        {
        throw CALC_E_DOMAIN;
        }
    else
        {
        PRAT ptmp = NULL;
        DUPRAT(ptmp,(*px)); 
        mulrat(&ptmp,*px);
        subrat(&ptmp,rat_one);
        rootrat(&ptmp,rat_two);
        addrat(px,ptmp);
        lograt(px);
        destroyrat(ptmp);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: atanhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//              hyperbolic tangent of
//
//  RETURN: atanh of x in PRAT form.
//
//  EXPLANATION: This uses
//
//             1     x+1
//  atanh(x) = -*ln(----)
//             2     x-1
//
//-----------------------------------------------------------------------------

void atanhrat( PRAT *px )

{
    PRAT ptmp = NULL;
    DUPRAT(ptmp,(*px)); 
    subrat(&ptmp,rat_one);
    addrat(px,rat_one);
    divrat(px,ptmp);
    (*px)->pp->sign *= -1;
    lograt(px);
    divrat(px,rat_two);
    destroyrat(ptmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\logic.c ===
//---------------------------------------------------------------------------
//  Package Title  ratpak
//  File           num.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-99 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains routines for and, or, xor, not and other support
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <ratpak.h>

void lshrat( PRAT *pa, PRAT b )

{
    PRAT pwr=NULL;
    long intb;

    intrat(pa);
    if ( !zernum( (*pa)->pp ) )
        {
        // If input is zero we're done.
        if ( rat_gt( b, rat_max_exp ) )
            {
            // Don't attempt lsh of anything big
            throw( CALC_E_DOMAIN );
            }
        intb = rattolong(b);
        DUPRAT(pwr,rat_two);
        ratpowlong(&pwr,intb);
        mulrat(pa,pwr);
        destroyrat(pwr);
        }
}

void rshrat( PRAT *pa, PRAT b )

{
    PRAT pwr=NULL;
    long intb;

    intrat(pa);
    if ( !zernum( (*pa)->pp ) )
        { 
        // If input is zero we're done.
        if ( rat_lt( b, rat_min_exp ) )
            {
            // Don't attempt rsh of anything big and negative.
            throw( CALC_E_DOMAIN );
            }
        intb = rattolong(b);
        DUPRAT(pwr,rat_two);
        ratpowlong(&pwr,intb);
        divrat(pa,pwr);
        destroyrat(pwr);
       }
}

void boolrat( PRAT *pa, PRAT b, int func );
void boolnum( PNUMBER *pa, PNUMBER b, int func );


enum {
    FUNC_AND,
    FUNC_OR,
    FUNC_XOR
} BOOL_FUNCS;

void andrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_AND );
}

void orrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_OR );
}

void xorrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_XOR );
}

//---------------------------------------------------------------------------
//
//    FUNCTION: boolrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa op= b;
//
//---------------------------------------------------------------------------

void boolrat( PRAT *pa, PRAT b, int func )

{
    PRAT tmp=NULL;
    intrat( pa );
    DUPRAT(tmp,b);
    intrat( &tmp );

    boolnum( &((*pa)->pp), tmp->pp, func );
    destroyrat(tmp);
}

//---------------------------------------------------------------------------
//
//    FUNCTION: boolnum
//
//    ARGUMENTS: pointer to a number a second number
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa &= b.
//    nRadix doesn't matter for logicals.
//    WARNING: Assumes numbers are unsigned.
//
//---------------------------------------------------------------------------

void boolnum( PNUMBER *pa, PNUMBER b, int func )

{
    PNUMBER c=NULL;
    PNUMBER a=NULL;
    MANTTYPE *pcha;
    MANTTYPE *pchb;
    MANTTYPE *pchc;
    long cdigits;
    long mexp;
    MANTTYPE da;
    MANTTYPE db;

    a=*pa;
    cdigits = max( a->cdigit+a->exp, b->cdigit+b->exp ) -
            min( a->exp, b->exp );
    createnum( c, cdigits );
    c->exp = min( a->exp, b->exp );
    mexp = c->exp;
    c->cdigit = cdigits;
    pcha = MANT(a);
    pchb = MANT(b);
    pchc = MANT(c);
    for ( ;cdigits > 0; cdigits--, mexp++ )
        {
        da = ( ( ( mexp >= a->exp ) && ( cdigits + a->exp - c->exp > 
                    (c->cdigit - a->cdigit) ) ) ? 
                    *pcha++ : 0 );
        db = ( ( ( mexp >= b->exp ) && ( cdigits + b->exp - c->exp > 
                    (c->cdigit - b->cdigit) ) ) ? 
                    *pchb++ : 0 );
        switch ( func )
            {
        case FUNC_AND:
            *pchc++ = da & db;
            break;
        case FUNC_OR:
            *pchc++ = da | db;
            break;
        case FUNC_XOR:
            *pchc++ = da ^ db;
            break;
            }
        }
    c->sign = a->sign;
    while ( c->cdigit > 1 && *(--pchc) == 0 )
        {
        c->cdigit--;
        }
    destroynum( *pa );
    *pa=c;
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: modrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of frac(*pa);
//
//-----------------------------------------------------------------------------

void modrat( PRAT *pa, PRAT b )

{
    PRAT tmp = NULL;

    if ( zerrat( b ) )
		{
		throw CALC_E_INDEFINITE;
		}
    DUPRAT(tmp,b);

    mulnumx( &((*pa)->pp), tmp->pq );
    mulnumx( &(tmp->pp), (*pa)->pq );
    remnum( &((*pa)->pp), tmp->pp, BASEX );
    mulnumx( &((*pa)->pq), tmp->pq );
    
    //Get *pa back in the integer over integer form.
    RENORMALIZE(*pa);

    destroyrat( tmp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\itrans.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           itrans.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains inverse sin, cos, tan functions for rationals
//
//  Special Information
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

void ascalerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    switch ( angletype )
        {
    case ANGLE_RAD:
        break;
    case ANGLE_DEG:
        divrat( pa, two_pi );
        mulrat( pa, rat_360 );
        break;
    case ANGLE_GRAD:
        divrat( pa, two_pi );
        mulrat( pa, rat_400 );
        break;
        }
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: asinrat, _asinrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//    sine of
//  RETURN: asin  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                            (2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   If abs(x) > 0.85 then an alternate form is used
//      pi/2-sgn(x)*asin(sqrt(1-x^2)
//
//
//-----------------------------------------------------------------------------

void _asinrat( PRAT *px )

{
    CREATETAYLOR();
    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);
    DUPNUM(n2,num_one);

    do
        {
        NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
            INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        }
    while ( !SMALL_ENOUGH_RAT( thisterm ) );
    DESTROYTAYLOR();
}

void asinanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    asinrat( pa );
    ascalerat( pa, angletype );
}

void asinrat( PRAT *px )

{
    long sgn;
    PRAT pret=NULL;
    PRAT phack=NULL;

    sgn = (*px)->pp->sign* (*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    // Nasty hack to avoid the really bad part of the asin curve near +/-1.
    DUPRAT(phack,*px);
    subrat(&phack,rat_one);
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(phack,rat_smallest) && rat_ge(phack,rat_negsmallest) )
        {
        destroyrat(phack);
        DUPRAT( *px, pi_over_two );
        }
    else
        {
        destroyrat(phack);
        if ( rat_gt( *px, pt_eight_five ) )
            {
            if ( rat_gt( *px, rat_one ) )
                {
                subrat( px, rat_one );
                if ( rat_gt( *px, rat_smallest ) )
                    {
                	throw( CALC_E_DOMAIN );
                    }
                else
                    {
                	DUPRAT(*px,rat_one);
                    }
                }
            DUPRAT(pret,*px);
            mulrat( px, pret );
            (*px)->pp->sign *= -1;
            addrat( px, rat_one );
            rootrat( px, rat_two );
            _asinrat( px );
            (*px)->pp->sign *= -1;
            addrat( px, pi_over_two );
            destroyrat(pret);
            }
        else
            {
            _asinrat( px );
            }
        }
    (*px)->pp->sign = sgn;
    (*px)->pq->sign = 1;
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: acosrat, _acosrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//    cosine of
//  RETURN: acos  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                            (2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//   In this case pi/2-asin(x) is used.  At least for now _acosrat isn't
//      called.
//
//-----------------------------------------------------------------------------

void acosanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    acosrat( pa );
    ascalerat( pa, angletype );
}

void _acosrat( PRAT *px )

{
    CREATETAYLOR();

    createrat(thisterm); 
    thisterm->pp=longtonum( 1L, BASEX );
    thisterm->pq=longtonum( 1L, BASEX ); 

    DUPNUM(n2,num_one);

    do
        {
        NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
            INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        }
    while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void acosrat( PRAT *px )

{
    long sgn;

    sgn = (*px)->pp->sign*(*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    if ( rat_equ( *px, rat_one ) )
        {
        if ( sgn == -1 )
            {
            DUPRAT(*px,pi);
            }
        else
            {
            DUPRAT( *px, rat_zero );
            }
        }
    else
        {
        (*px)->pp->sign = sgn;
        asinrat( px );
        (*px)->pp->sign *= -1;
        addrat(px,pi_over_two);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: atanrat, _atanrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//              hyperbolic tangent of
//
//  RETURN: atanh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2
//   \  ]                                            (2j)*X (-1^j)
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   If abs(x) > 0.85 then an alternate form is used
//      asin(x/sqrt(q+x^2))
//
//   And if abs(x) > 2.0 then this form is used.
//
//   pi/2 - atan(1/x)
//
//-----------------------------------------------------------------------------

void atananglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    atanrat( pa );
    ascalerat( pa, angletype );
}

void _atanrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);

    DUPNUM(n2,num_one);

    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,MULNUM(n2) INC(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void atan2rat( PRAT *py, PRAT x )

{
    if ( rat_gt( x, rat_zero ) )
        {
        if ( !zerrat( (*py) ) )
            {
            divrat( py, x);
            atanrat( py );
            }
        }
    else if ( rat_lt( x, rat_zero ) )
        {
        if ( rat_gt( (*py), rat_zero ) )
            {
            divrat( py, x);
            atanrat( py );
            addrat( py, pi );
            }
        else if ( rat_lt( (*py), rat_zero ) )
            {
            divrat( py, x);
            atanrat( py );
            subrat( py, pi );
            }
        else // (*py) == 0
            {
            DUPRAT( *py, pi );
            }
        }
    else // x == 0
        {
        if ( !zerrat( (*py) ) )
            {
            int sign;
            sign=(*py)->pp->sign*(*py)->pq->sign;
            DUPRAT( *py, pi_over_two );
            (*py)->pp->sign = sign;
            }
        else // (*py) == 0
            {
            DUPRAT( *py, rat_zero );
            }
        }
}

void atanrat( PRAT *px )

{
    long sgn;
    PRAT tmpx=NULL;

    sgn = (*px)->pp->sign * (*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    if ( rat_gt( (*px), pt_eight_five ) )
        {
        if ( rat_gt( (*px), rat_two ) )
            {
            (*px)->pp->sign = sgn;
            (*px)->pq->sign = 1;
            DUPRAT(tmpx,rat_one);
            divrat(&tmpx,(*px));
            _atanrat(&tmpx);
            tmpx->pp->sign = sgn;
            tmpx->pq->sign = 1;
            DUPRAT(*px,pi_over_two);
            subrat(px,tmpx);
            destroyrat( tmpx );
            }
        else 
            {
            (*px)->pp->sign = sgn;
            DUPRAT(tmpx,*px);
            mulrat( &tmpx, *px );
            addrat( &tmpx, rat_one );
            rootrat( &tmpx, rat_two );
            divrat( px, tmpx );
            destroyrat( tmpx );
            asinrat( px );
            (*px)->pp->sign = sgn;
            (*px)->pq->sign = 1;
            }
        }
    else
        {
        (*px)->pp->sign = sgn;
        (*px)->pq->sign = 1;
        _atanrat( px );
        }
    if ( rat_gt( *px, pi_over_two ) )
        {
        subrat( px, pi );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\num.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak                                                   
//  File           num.c                                                    
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)            
//  Copyright      (C) 1995-97 Microsoft                                    
//  Date           01-16-95                                                 
//                                                                          
//                                                                          
//  Description                                                             
//                                                                          
//     Contains number routines for add, mul, div, rem and other support       
//  and longs.                                                              
//                                                                          
//  Special Information                                                     
//                                                                          
//                                                                          
//-----------------------------------------------------------------------------

#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <ratpak.h>

//----------------------------------------------------------------------------
//
//    FUNCTION: addnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa += b.
//    Assumes nRadix is the base of both numbers.
//
//    ALGORITHM: Adds each digit from least significant to most
//    significant.
//
//
//----------------------------------------------------------------------------

void _addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 0 )
        {    // If b is zero we are done.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 0 )
            { // pa and b are both nonzero.
            _addnum( pa, b, nRadix );
            }
        else
            { // if pa is zero and b isn't just copy b.
            DUPNUM(*pa,b);
            }
        }
}

void _addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER c=NULL;     // c will contain the result.
    PNUMBER a=NULL;     // a is the dereferenced number pointer from *pa
    MANTTYPE *pcha;     // pcha is a pointer to the mantissa of a.
    MANTTYPE *pchb;     // pchb is a pointer to the mantissa of b.
    MANTTYPE *pchc;     // pchc is a pointer to the mantissa of c.
    long cdigits;       // cdigits is the max count of the digits results
                        // used as a counter.
    long mexp;          // mexp is the exponent of the result.
    MANTTYPE  da;       // da is a single 'digit' after possible padding.
    MANTTYPE  db;       // db is a single 'digit' after possible padding.
    MANTTYPE  cy=0;     // cy is the value of a carry after adding two 'digits'
    long  fcompla = 0;  // fcompla is a flag to signal a is negative.
    long  fcomplb = 0;  // fcomplb is a flag to signal b is negative.

    a=*pa;
    
    
    // Calculate the overlap of the numbers after alignment, this includes
    // necessary padding 0's
    cdigits = max( a->cdigit+a->exp, b->cdigit+b->exp ) -
            min( a->exp, b->exp );

    createnum( c, cdigits + 1 );
    c->exp = min( a->exp, b->exp );
    mexp = c->exp;
    c->cdigit = cdigits;
    pcha = MANT(a);
    pchb = MANT(b);
    pchc = MANT(c);
    
    // Figure out the sign of the numbers
    if ( a->sign != b->sign )
        {
        cy = 1;
        fcompla = ( a->sign == -1 );
        fcomplb = ( b->sign == -1 );
        }
    
    // Loop over all the digits, real and 0 padded. Here we know a and b are
    // aligned 
    for ( ;cdigits > 0; cdigits--, mexp++ )
        {
        
        // Get digit from a, taking padding into account.
        da = ( ( ( mexp >= a->exp ) && ( cdigits + a->exp - c->exp > 
                    (c->cdigit - a->cdigit) ) ) ? 
                    *pcha++ : 0 );
        // Get digit from b, taking padding into account.
        db = ( ( ( mexp >= b->exp ) && ( cdigits + b->exp - c->exp > 
                    (c->cdigit - b->cdigit) ) ) ? 
                    *pchb++ : 0 );
        
        // Handle complementing for a and b digit. Might be a better way, but
        // haven't found it yet.
        if ( fcompla )
            {
            da = (MANTTYPE)(nRadix) - 1 - da;
            }
        if ( fcomplb )
            {
            db = (MANTTYPE)(nRadix) - 1 - db;
            }
        
        // Update carry as necessary
        cy = da + db + cy;
        *pchc++ = (MANTTYPE)(cy % (MANTTYPE)nRadix);
        cy /= (MANTTYPE)nRadix;
        }
    
    // Handle carry from last sum as extra digit
    if ( cy && !(fcompla || fcomplb) )
        {
        *pchc++ = cy;
        c->cdigit++;
        }
    
    // Compute sign of result
    if ( !(fcompla || fcomplb) )
        {
        c->sign = a->sign;
        }
    else
        {
        if ( cy )
            {
            c->sign = 1;
            }
        else
            {
            // In this particular case an overflow or underflow has occoured 
            // and all the digits need to be complemented, at one time an 
            // attempt to handle this above was made, it turned out to be much 
            // slower on average.
            c->sign = -1;
            cy = 1;
            for ( ( cdigits = c->cdigit ), (pchc = MANT(c) ); 
                cdigits > 0; 
                cdigits-- )
                {
                cy = (MANTTYPE)nRadix - (MANTTYPE)1 - *pchc + cy;
                *pchc++ = (MANTTYPE)( cy % (MANTTYPE)nRadix );
                cy /= (MANTTYPE)nRadix;
                }
            }
        }
    
    // Remove leading zeroes, remember digits are in order of
    // increasing significance. i.e. 100 would be 0,0,1
    while ( c->cdigit > 1 && *(--pchc) == 0 )
        {
        c->cdigit--;
        }
    destroynum( *pa );
    *pa=c;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: mulnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    Assumes nRadix is the nRadix of both numbers.  This algorithm is the
//    same one you learned in gradeschool.
//
//----------------------------------------------------------------------------

void _mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {    // If b is one we don't multiply exactly.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            { // pa and b are both nonone.
            _mulnum( pa, b, nRadix );
            }
        else
            { // if pa is one and b isn't just copy b, and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {    // But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

void _mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    MANTTYPE *pcha;         // pcha is a pointer to the mantissa of a.
    MANTTYPE *pchb;         // pchb is a pointer to the mantissa of b.
    MANTTYPE *pchc;         // pchc is a pointer to the mantissa of c.
    MANTTYPE *pchcoffset;   // pchcoffset, is the anchor location of the next
                            // single digit multiply partial result.
    long iadigit = 0;       // Index of digit being used in the first number.
    long ibdigit = 0;       // Index of digit being used in the second number.
    MANTTYPE  da = 0;       // da is the digit from the fist number.
    TWO_MANTTYPE  cy = 0;   // cy is the carry resulting from the addition of
                            // a multiplied row into the result.
    TWO_MANTTYPE  mcy = 0;  // mcy is the resultant from a single 
                            // multiply, AND the carry of that multiply.
    long  icdigit = 0;      // Index of digit being calculated in final result.

    a=*pa;
    ibdigit = a->cdigit + b->cdigit - 1;
    createnum( c,  ibdigit + 1 );
    c->cdigit = ibdigit;
    c->sign = a->sign * b->sign;

    c->exp = a->exp + b->exp;
    pcha = MANT(a);
    pchcoffset = MANT(c);

    for (  iadigit = a->cdigit; iadigit > 0; iadigit-- )
        {
        da =  *pcha++;
        pchb = MANT(b);
        
        // Shift pchc, and pchcoffset, one for each digit 
        pchc = pchcoffset++;

        for ( ibdigit = b->cdigit; ibdigit > 0; ibdigit-- )
            {
            cy = 0;
            mcy = (TWO_MANTTYPE)da * *pchb;
            if ( mcy )
                {
                icdigit = 0;
                if ( ibdigit == 1 && iadigit == 1 )
                    {
                    c->cdigit++;
                    }
                }
            // If result is nonzero, or while result of carry is nonzero...
            while ( mcy || cy )
                {
                
                // update carry from addition(s) and multiply.
                cy += (TWO_MANTTYPE)pchc[icdigit]+(mcy%(TWO_MANTTYPE)nRadix);
                
                // update result digit from 
                pchc[icdigit++]=(MANTTYPE)(cy%(TWO_MANTTYPE)nRadix);
                
                // update carries from
                mcy /= (TWO_MANTTYPE)nRadix;
                cy /= (TWO_MANTTYPE)nRadix;
                }
            *pchb++;
            *pchc++;
            }
        }
    
    // prevent different kinds of zeros, by stripping leading duplicate zeroes.
    // digits are in order of increasing significance.
    while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
        {
        c->cdigit--;
        }

    destroynum( *pa );
    *pa=c;
}


//----------------------------------------------------------------------------
//
//    FUNCTION: remnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa %= b.
//            Repeatedly subtracts off powers of 2 of b until *pa < b.
//
//
//----------------------------------------------------------------------------

void remnum( PNUMBER *pa, PNUMBER b, long nRadix )

{
    PNUMBER tmp = NULL;     // tmp is the working remainder.
    PNUMBER lasttmp = NULL; // lasttmp is the last remainder which worked.
    
    // Once *pa is less than b, *pa is the remainder.
    while ( !lessnum( *pa, b ) && !fhalt )
        {
        DUPNUM( tmp, b );
        if ( lessnum( tmp, *pa ) )
            {
            // Start off close to the right answer for subtraction.
            tmp->exp = (*pa)->cdigit+(*pa)->exp - tmp->cdigit;
            if ( MSD(*pa) <= MSD(tmp) )
                {
                // Don't take the chance that the numbers are equal.
                tmp->exp--;
                }
            }

        destroynum( lasttmp );
        lasttmp=longtonum( 0, nRadix );

        while ( lessnum( tmp, *pa ) ) 
            {
            DUPNUM( lasttmp, tmp );
            addnum( &tmp, tmp, nRadix );
            }

        if ( lessnum( *pa, tmp ) )
            {    
            // too far, back up...
            destroynum( tmp );
            tmp=lasttmp;
            lasttmp=NULL;
            }
        
        // Subtract the working remainder from the remainder holder.
        tmp->sign = -1*(*pa)->sign;
        addnum( pa, tmp, nRadix ); 

        destroynum( tmp );
        destroynum( lasttmp );

        } 
}


//---------------------------------------------------------------------------
//
//    FUNCTION: divnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//---------------------------------------------------------------------------

void _divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {    
    	// b is not one
        _divnum( pa, b, nRadix );
        }
    else
        {    // But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

void _divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER a = NULL;
    PNUMBER c = NULL;
    PNUMBER tmp = NULL;
    PNUMBER rem = NULL;
    PLINKEDLIST pll = NULL;
    PLINKEDLIST pllrover = NULL;
    long digit;
    long cdigits;
    BOOL bret;
    MANTTYPE *ptrc;
    long thismax = maxout+2;

    a=*pa;
    if ( thismax < a->cdigit )
        {
        thismax = a->cdigit;
        }

    if ( thismax < b->cdigit )
        {
        thismax = b->cdigit;
        }

    createnum( c, thismax + 1 );
    c->exp = (a->cdigit+a->exp) - (b->cdigit+b->exp) + 1;
    c->sign = a->sign * b->sign;

    ptrc = MANT(c) + thismax;
    cdigits = 0;
    DUPNUM( rem, a );
    DUPNUM( tmp, b );
    tmp->sign = a->sign;
    rem->exp = b->cdigit + b->exp - rem->cdigit;
    
    // Build a table of multiplications of the divisor, this is quicker for 
    // more than nRadix 'digits'
    pll = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
    pll->pnum = longtonum( 0L, nRadix );
    pll->llprev = NULL;
    for ( cdigits = 1; cdigits < (long)nRadix; cdigits++ )
        {
        pllrover = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
        pllrover->pnum=NULL;
        DUPNUM( pllrover->pnum, pll->pnum );
        addnum( &(pllrover->pnum), tmp, nRadix );
        pllrover->llprev = pll;
        pll = pllrover;
        }
    destroynum( tmp );
    cdigits = 0;
    while ( cdigits++ < thismax && !zernum(rem) )
        {
        pllrover = pll;
        digit = nRadix - 1;
        do    {
            bret = lessnum( rem, pllrover->pnum );
            } while ( bret && --digit && ( pllrover = pllrover->llprev ) );
        if ( digit )
            {
            pllrover->pnum->sign *= -1;
            addnum( &rem, pllrover->pnum, nRadix );
            pllrover->pnum->sign *= -1;
            }
        rem->exp++;
        *ptrc-- = (MANTTYPE)digit;
        }
    cdigits--;
    if ( MANT(c) != ++ptrc )
        {
        memcpy( MANT(c), ptrc, (int)(cdigits*sizeof(MANTTYPE)) );
        }
    
    // Cleanup table structure
    pllrover = pll;
    do    {
        pll = pllrover->llprev;
        destroynum( pllrover->pnum );
        zfree( pllrover );
        } while ( pllrover = pll );

    if ( !cdigits )
        {
        c->cdigit = 1;
        c->exp = 0;
        }
    else
        {
        c->cdigit = cdigits;
        c->exp -= cdigits;
        while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
            {
            c->cdigit--;
            }
        }
    destroynum( rem );

    destroynum( *pa );
    *pa=c;
}


//---------------------------------------------------------------------------
//
//    FUNCTION: equnum
//
//    ARGUMENTS: two numbers.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( a == b )
//    Only assumes that a and b are the same nRadix.
//
//---------------------------------------------------------------------------

BOOL equnum( PNUMBER a, PNUMBER b )

{
    long diff;
    MANTTYPE *pa;
    MANTTYPE *pb;
    long cdigits;
    long ccdigits;
    MANTTYPE  da;
    MANTTYPE  db;

    diff = ( a->cdigit + a->exp ) - ( b->cdigit + b->exp );
    if ( diff < 0 )
        {
        // If the exponents are different, these are different numbers.
        return( FALSE );
        }
    else
        {
        if ( diff > 0 )
            {
            // If the exponents are different, these are different numbers.
            return( FALSE );
            }
        else
            {
            // OK the exponents match.
            pa = MANT(a);
            pb = MANT(b);
            pa += a->cdigit - 1;
            pb += b->cdigit - 1;
            cdigits = max( a->cdigit, b->cdigit );
            ccdigits = cdigits;
            
            // Loop over all digits until we run out of digits or there is a
            // difference in the digits.
            for ( ;cdigits > 0; cdigits-- )
                {
                da = ( (cdigits > (ccdigits - a->cdigit) ) ? 
                    *pa-- : 0 );
                db = ( (cdigits > (ccdigits - b->cdigit) ) ? 
                    *pb-- : 0 );
                if ( da != db )
                    {
                    return( FALSE );
                    }
                }
            
            // In this case, they are equal.
            return( TRUE );
            }
        }
}

//---------------------------------------------------------------------------
//
//    FUNCTION: lessnum
//
//    ARGUMENTS: two numbers.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( abs(a) < abs(b) )
//    Only assumes that a and b are the same nRadix, WARNING THIS IS AN.
//    UNSIGNED COMPARE!
//
//---------------------------------------------------------------------------

BOOL lessnum( PNUMBER a, PNUMBER b )

{
    long diff;
    MANTTYPE *pa;
    MANTTYPE *pb;
    long cdigits;
    long ccdigits;
    MANTTYPE  da;
    MANTTYPE  db;


    diff = ( a->cdigit + a->exp ) - ( b->cdigit + b->exp );
    if ( diff < 0 )
        {
        // The exponent of a is less than b
        return( TRUE );
        }
    else
        {
        if ( diff > 0 )
            {
            return( FALSE );
            }
        else
            {
            pa = MANT(a);
            pb = MANT(b);
            pa += a->cdigit - 1;
            pb += b->cdigit - 1;
            cdigits = max( a->cdigit, b->cdigit );
            ccdigits = cdigits;
            for ( ;cdigits > 0; cdigits-- )
                {
                da = ( (cdigits > (ccdigits - a->cdigit) ) ? 
                    *pa-- : 0 );
                db = ( (cdigits > (ccdigits - b->cdigit) ) ? 
                    *pb-- : 0 );
                diff = da-db;
                if ( diff )
                    {
                    return( diff < 0 );
                    }
                }
            // In this case, they are equal.
            return( FALSE );
            }
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: zernum
//
//    ARGUMENTS: number
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( !a )
//
//----------------------------------------------------------------------------

BOOL zernum( PNUMBER a )

{
    long length;
    MANTTYPE *pcha;
    length = a->cdigit;
    pcha = MANT( a );
    
    // loop over all the digits until you find a nonzero or until you run 
    // out of digits
    while ( length-- > 0 )
        {
        if ( *pcha++ )
            {
            // One of the digits isn't zero, therefore the number isn't zero
            return( FALSE );
            }
        }
    // All of the digits are zero, therefore the number is zero
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\rat.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           rat.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//  Contains mul, div, add, and other support functions for rationals.
//
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


//-----------------------------------------------------------------------------
//
//    FUNCTION: gcdrat
//
//    ARGUMENTS: pointer to a rational.
//
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Divides p and q in rational by the G.C.D.
//    of both.  It was hoped this would speed up some
//    calculations, and until the above trimming was done it
//    did, but after trimming gcdratting, only slows things
//    down.
//
//-----------------------------------------------------------------------------

void gcdrat( PRAT *pa )

{
    PNUMBER pgcd=NULL;
    PRAT a=NULL;

    a=*pa;
    pgcd = gcd( a->pp, a->pq );

    if ( !zernum( pgcd ) )
        {
        divnumx( &(a->pp), pgcd );
        divnumx( &(a->pq), pgcd );
        }

    destroynum( pgcd );
    *pa=a;
    
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: fracrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of frac(*pa);
//
//-----------------------------------------------------------------------------

void fracrat( PRAT *pa )

{
    long trim;
    remnum( &((*pa)->pp), (*pa)->pq, BASEX );
    
    //Get *pa back in the integer over integer form.
    RENORMALIZE(*pa);
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: mulrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa *= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//-----------------------------------------------------------------------------

void mulrat( PRAT *pa, PRAT b )
    
    {
    // Only do the multiply if it isn't zero.
    if ( !zernum( (*pa)->pp ) )
        {
        mulnumx( &((*pa)->pp), b->pp );
        mulnumx( &((*pa)->pq), b->pq );
        trimit(pa);
        }
    else
        {
        // If it is zero, blast a one in the denominator.
        DUPNUM( ((*pa)->pq), num_one );
        }

#ifdef MULGCD
    gcdrat( pa );
#endif

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: divrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa /= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//-----------------------------------------------------------------------------


void divrat( PRAT *pa, PRAT b )

{

    if ( !zernum( (*pa)->pp ) )
        {
        // Only do the divide if the top isn't zero.
        mulnumx( &((*pa)->pp), b->pq );
        mulnumx( &((*pa)->pq), b->pp );

        if ( zernum( (*pa)->pq ) )
            {
            // raise an exception if the bottom is 0.
            throw( CALC_E_DIVIDEBYZERO );
            }
        trimit(pa);
        }
    else
        {
        // Top is zero.
        if ( zerrat( b ) )
            {
            // If bottom is zero
            // 0 / 0 is indefinite, raise an exception.
            throw( CALC_E_INDEFINITE );
            }
        else
            {
            // 0/x make a unique 0.
            DUPNUM( ((*pa)->pq), num_one );
            }
        }

#ifdef DIVGCD
    gcdrat( pa );
#endif 

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: subrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa += b.
//    Assumes base is internal througought.
//
//-----------------------------------------------------------------------------

void subrat( PRAT *pa, PRAT b )

{
    b->pp->sign *= -1;
    addrat( pa, b );
    b->pp->sign *= -1;
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: addrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa += b.
//    Assumes base is internal througought.
//
//-----------------------------------------------------------------------------

void addrat( PRAT *pa, PRAT b )

{
    PNUMBER bot=NULL;

    if ( equnum( (*pa)->pq, b->pq ) )
        {
        // Very special case, q's match., 
        // make sure signs are involved in the calculation
        // we have to do this since the optimization here is only 
        // working with the top half of the rationals.
        (*pa)->pp->sign *= (*pa)->pq->sign; 
        (*pa)->pq->sign = 1;
        b->pp->sign *= b->pq->sign; 
        b->pq->sign = 1;
        addnum( &((*pa)->pp), b->pp, BASEX );
        }
    else
        {
        // Usual case q's aren't the same.
        DUPNUM( bot, (*pa)->pq );
        mulnumx( &bot, b->pq );
        mulnumx( &((*pa)->pp), b->pq );
        mulnumx( &((*pa)->pq), b->pp );
        addnum( &((*pa)->pp), (*pa)->pq, BASEX );
        destroynum( (*pa)->pq );
        (*pa)->pq = bot;
        trimit(pa);
        
        // Get rid of negative zeroes here.
        (*pa)->pp->sign *= (*pa)->pq->sign; 
        (*pa)->pq->sign = 1;
        }

#ifdef ADDGCD
    gcdrat( pa );
#endif 

}



//-----------------------------------------------------------------------------
//
//  FUNCTION: rootrat
//
//  PARAMETERS: y prat representation of number to take the root of
//              n prat representation of the root to take.
//
//  RETURN: bth root of a in rat form.
//
//  EXPLANATION: This is now a stub function to powrat().
//
//-----------------------------------------------------------------------------

void rootrat( PRAT *py, PRAT n )

{
    PRAT oneovern=NULL;

    DUPRAT(oneovern,rat_one);
    divrat(&oneovern,n);

    powrat( py, oneovern );

    destroyrat(oneovern);
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: zerrat
//
//    ARGUMENTS: Rational number.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Returns true if input is zero.
//    False otherwise.
//
//-----------------------------------------------------------------------------

BOOL zerrat( PRAT a )

{
    return( zernum(a->pp) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\ratpak.h ===
#pragma warning( disable : 4200 )
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           ratpak.h
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-99 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Infinite precision math package header file, if you use ratpak.lib you
//  need to include this header.
//
//-----------------------------------------------------------------------------

#include "CalcErr.h"

#define BASEXPWR 31L    // Internal log2(BASEX)
#define BASEX 0x80000000 // Internal nRadix used in calculations, hope to raise
                        // this to 2^32 after solving scaling problems with
                        // overflow detection esp. in mul

typedef unsigned long MANTTYPE;
typedef unsigned __int64 TWO_MANTTYPE;

enum eNUMOBJ_FMT {
    FMT_FLOAT,        // returns floating point, or exponential if number is too big
    FMT_SCIENTIFIC,    // always returns scientific notation
    FMT_ENGINEERING    // always returns engineering notation such that exponent is a multiple of 3

};

enum eANGLE_TYPE {
    ANGLE_DEG,    // Calculate trig using 360 degrees per revolution
    ANGLE_RAD,    // Calculate trig using 2 pi  radians per revolution
    ANGLE_GRAD    // Calculate trig using 400 gradients per revolution

};

typedef enum eNUMOBJ_FMT NUMOBJ_FMT;
typedef enum eANGLE_TYPE ANGLE_TYPE;

typedef int BOOL;

//-----------------------------------------------------------------------------
//
//  NUMBER type is a representation of a generic sized generic nRadix number
//
//-----------------------------------------------------------------------------

typedef struct _number
    {
    long sign;        // The sign of the mantissa, +1, or -1
    long cdigit;    // The number of digits, or what passes for digits in the
                    // nRadix being used.
    long exp;       // The offset of digits from the nRadix point
                    // (decimal point in nRadix 10)
    MANTTYPE mant[0];
                    // This is actually allocated as a continuation of the
                    // NUMBER structure.
    } NUMBER, *PNUMBER, **PPNUMBER;


//-----------------------------------------------------------------------------
//
//  RAT type is a representation nRadix  on 2 NUMBER types.
//  pp/pq, where pp and pq are pointers to integral NUMBER types.
//
//-----------------------------------------------------------------------------

typedef struct _rat
    {
    PNUMBER pp;
    PNUMBER pq;
    } RAT, *PRAT;

//-----------------------------------------------------------------------------
//
//  LINKEDLIST is an aid for division, it contains foreward and reverse links
//  to a list of NUMBERS.
//
//-----------------------------------------------------------------------------

typedef struct _linkedlist
    {
    PNUMBER pnum;
    struct _linkedlist *llnext;
    struct _linkedlist *llprev;
    } LINKEDLIST, *PLINKEDLIST;




#if !defined( TRUE )
#define TRUE 1
#endif

#if !defined( FALSE )
#define FALSE 0
#endif

#define MAX_LONG_SIZE 33    // Base 2 requires 32 'digits'

//-----------------------------------------------------------------------------
//
// List of useful constants for evaluation, note this list needs to be
// initialized.
//
//-----------------------------------------------------------------------------

extern PNUMBER num_one;
extern PNUMBER num_two;
extern PNUMBER num_five;
extern PNUMBER num_six;
extern PNUMBER num_nRadix;
extern PNUMBER num_ten;

extern PRAT ln_ten;
extern PRAT ln_two;
extern PRAT rat_zero;
extern PRAT rat_neg_one;
extern PRAT rat_one;
extern PRAT rat_two;
extern PRAT rat_six;
extern PRAT rat_half;
extern PRAT rat_ten;
extern PRAT pt_eight_five;
extern PRAT pi;
extern PRAT pi_over_two;
extern PRAT two_pi;
extern PRAT one_pt_five_pi;
extern PRAT e_to_one_half;
extern PRAT rat_exp;
extern PRAT rad_to_deg;
extern PRAT rad_to_grad;
extern PRAT rat_qword;
extern PRAT rat_dword;
extern PRAT rat_word;
extern PRAT rat_byte;
extern PRAT rat_360;
extern PRAT rat_400;
extern PRAT rat_180;
extern PRAT rat_200;
extern PRAT rat_nRadix;
extern PRAT rat_smallest;
extern PRAT rat_negsmallest;
extern PRAT rat_max_exp;
extern PRAT rat_min_exp;
extern PRAT rat_min_long;


// MANT returns a long pointer to the mantissa of number 'a'
#define MANT(a) ((a)->mant)

// DUPNUM Duplicates a number taking care of allocation and internals
#define DUPNUM(a,b) destroynum(a);createnum( a, b->cdigit ); \
    memcpy( a, b, (int)( sizeof( NUMBER ) + ( b->cdigit )*(sizeof(MANTTYPE)) ) );

// DUPRAT Duplicates a rational taking care of allocation and internals
#define DUPRAT(a,b) destroyrat(a);createrat(a);DUPNUM((a)->pp,(b)->pp);DUPNUM((a)->pq,(b)->pq);

// LOG*RADIX calculates the integral portion of the log of a number in
// the base currently being used, only accurate to within ratio

#define LOGNUMRADIX(pnum) (((pnum)->cdigit+(pnum)->exp)*ratio)
#define LOGRATRADIX(prat) (LOGNUMRADIX((prat)->pp)-LOGNUMRADIX((prat)->pq))

// LOG*2 calculates the integral portion of the log of a number in
// the internal base being used, only accurate to within ratio

#define LOGNUM2(pnum) ((pnum)->cdigit+(pnum)->exp)
#define LOGRAT2(prat) (LOGNUM2((prat)->pp)-LOGNUM2((prat)->pq))

#if defined( DEBUG )
//-----------------------------------------------------------------------------
//
//   Debug versions of rational number creation and destruction routines.
//   used for debugging allocation errors.
//
//-----------------------------------------------------------------------------

#define createrat(y) y=_createrat();fprintf( stderr, "createrat %lx %s file= %s, line= %d\n", y, # y, __FILE__, __LINE__ )
#define destroyrat(x) fprintf( stderr, "destroyrat %lx file= %s, line= %d\n", x, __FILE__, __LINE__ ),_destroyrat(x),x=NULL
#define createnum(y,x) y=_createnum(x);fprintf( stderr, "createnum %lx %s file= %s, line= %d\n", y, # y, __FILE__, __LINE__ );
#define destroynum(x) fprintf( stderr, "destroynum %lx file= %s, line= %d\n", x, __FILE__, __LINE__ ),_destroynum(x),x=NULL
#else
#define createrat(y) y=_createrat()
#define destroyrat(x) _destroyrat(x),x=NULL
#define createnum(y,x) y=_createnum(x)
#define destroynum(x) _destroynum(x),x=NULL
#endif

//-----------------------------------------------------------------------------
//
//   Defines for checking when to stop taylor series expansions due to
//   precision satisfaction.
//
//-----------------------------------------------------------------------------

// RENORMALIZE, gets the exponents non-negative.
#define RENORMALIZE(x) if ( (x)->pp->exp < 0 ) { \
	(x)->pq->exp -= (x)->pp->exp; \
	(x)->pp->exp = 0; \
	} \
	if ( (x)->pq->exp < 0 ) { \
	(x)->pp->exp -= (x)->pq->exp; \
	(x)->pq->exp = 0; \
	}

// TRIMNUM ASSUMES the number is in nRadix form NOT INTERNAL BASEX!!!
#define TRIMNUM(x) if ( !ftrueinfinite ) { \
		long trim = (x)->cdigit - maxout-ratio;\
            if ( trim > 1 ) \
                { \
memmove( MANT(x), &(MANT(x)[trim]), sizeof(MANTTYPE)*((x)->cdigit-trim) ); \
                (x)->cdigit -= trim; \
                (x)->exp += trim; \
                } \
            }
// TRIMTOP ASSUMES the number is in INTERNAL BASEX!!!
#define TRIMTOP(x) if ( !ftrueinfinite ) { \
		long trim = (x)->pp->cdigit - (maxout/ratio) - 2;\
            if ( trim > 1 ) \
                { \
memmove( MANT((x)->pp), &(MANT((x)->pp)[trim]), sizeof(MANTTYPE)*((x)->pp->cdigit-trim) ); \
                (x)->pp->cdigit -= trim; \
                (x)->pp->exp += trim; \
                } \
            trim = min((x)->pp->exp,(x)->pq->exp);\
            (x)->pp->exp -= trim;\
            (x)->pq->exp -= trim;\
            }

#define CLOSE_ENOUGH_RAT(a,b) ( ( ( ( ( a->pp->cdigit + a->pp->exp ) - \
( a->pq->cdigit + a->pq->exp ) ) - ( ( b->pp->cdigit + b->pp->exp ) - \
( b->pq->cdigit + b->pq->exp ) ) ) * ratio > maxout ) || fhalt )

#define SMALL_ENOUGH_RAT(a) (zernum(a->pp) || ( ( ( a->pq->cdigit + a->pq->exp ) - ( a->pp->cdigit + a->pp->exp ) - 1 ) * ratio > maxout ) || fhalt )

//-----------------------------------------------------------------------------
//
//   Defines for setting up taylor series expansions for infinite precision
//   functions.
//
//-----------------------------------------------------------------------------

#define CREATETAYLOR() PRAT xx=NULL;\
    PNUMBER n2=NULL; \
    PRAT pret=NULL; \
    PRAT thisterm=NULL; \
    DUPRAT(xx,*px); \
    mulrat(&xx,*px); \
    createrat(pret); \
    pret->pp=longtonum( 0L, BASEX ); \
    pret->pq=longtonum( 0L, BASEX );

#define DESTROYTAYLOR() destroynum( n2 ); \
    destroyrat( xx );\
    destroyrat( thisterm );\
    destroyrat( *px );\
    trimit(&pret);\
    *px=pret;

// SUM(a,b) is the rational equivalent of a += b
#define SUM(a,b) addnum( &a, b, BASEX);

// INC(a) is the rational equivalent of a++
// Check to see if we can avoid doing this the hard way.
#define INC(a) if ( a->mant[0] < BASEX - 1 ) \
    { \
    a->mant[0]++; \
    } \
    else \
    { \
    addnum( &a, num_one, BASEX); \
    }

#define MSD(x) ((x)->mant[(x)->cdigit-1])
// MULNUM(b) is the rational equivalent of thisterm *= b where thisterm is
// a rational and b is a number, NOTE this is a mixed type operation for
// efficiency reasons.
#define MULNUM(b) mulnumx( &(thisterm->pp), b);

// DIVNUM(b) is the rational equivalent of thisterm /= b where thisterm is
// a rational and b is a number, NOTE this is a mixed type operation for
// efficiency reasons.
#define DIVNUM(b) mulnumx( &(thisterm->pq), b);

// NEXTTERM(p,d) is the rational equivalent of
// thisterm *= p
// d    <d is usually an expansion of operations to get thisterm updated.>
// pret += thisterm
#define NEXTTERM(p,d) mulrat(&thisterm,p);d addrat( &pret, thisterm )

// ONEOVER(x) is the rational equivalent of x=1/x
#define ONEOVER(x) {PNUMBER __tmpnum;__tmpnum=x->pp;x->pp=x->pq;x->pq=__tmpnum;}

#ifndef DOS
#   if defined(ALTERNATE_ALLOCATION)
//-----------------------------------------------------------------------------
//
//   WARNING if you change the allocation package you need to rebuild
//   ratpak.lib
//
//-----------------------------------------------------------------------------

extern void *zmalloc( IN unsigned long sze );
extern void zfree( IN double *pd );
#   define zstrdup( x ) strcpy( zmalloc( strlen(x)+1 ), x )

#   else

#       ifdef USE_HEAPALLOC
//
// NT Heap macros.  Calling process must create a heap with HeapCreate()
//
#           define zmalloc(a)   HeapAlloc( hheap, 0, a )
#           define zfree(a)     HeapFree( hheap, 0, a )
#       elif DBG
//
// Debug heap workers
//
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
#           define zmalloc(a)   MemAllocWorker( __FILE__, __LINE__, LPTR, a )
#           define zfree(a)     MemFreeWorker( __FILE__, __LINE__, a )

#       else
//
// Windows heap macros
//
#           define zmalloc(a)   LocalAlloc( LPTR, a )
#           define zfree(a)     LocalFree( a )

#       endif
#       define zstrdup( x ) strcpy( zmalloc( strlen(x)+1 ), x )

#   endif
#endif

//-----------------------------------------------------------------------------
//
//   External variables used in the math package.
//
//-----------------------------------------------------------------------------

extern BOOL fhalt;	// contains the command to halt execution if true.
extern BOOL fparserror;	// set to true if last innum ended in error, else false.
extern NUMOBJ_FMT fmt;	// contains the format to use
extern TCHAR szDec[5];     // extern decimal point representation
extern long nRadix;     // extern nRadix used for input and output routines
extern unsigned char ftrueinfinite; // set to true to allow infinite precision
                             // don't use unless you know what you are doing
                      // used to help decide when to stop calculating.
extern long maxout;   // Maximum digits nRadix <nRadix> to use for precision.
                      // used to help decide when to stop calculating.

extern long ratio;    // Internally calculated ratio of internal nRadix
                      // v.s. nRadix used for input output number routines

extern LPTSTR oom;     // Out of memory error message

typedef void ERRFUNC( LPTSTR szErr );
typedef ERRFUNC *LPERRFUNC;
extern LPERRFUNC glpErrFunc;    // This function will get called if an error
                        // occurs inside of ratpak.



#ifndef DOS
extern HANDLE hheap;  // hheap is a pointer used in allocation, ratpak.lib
                      // users responsibility to make sure this is set up
                      // for use with Heap{Alloc,Free} routines.
#endif


//-----------------------------------------------------------------------------
//
//   External functions defined in the math package.
//
//-----------------------------------------------------------------------------

// Call whenever radix changes and at start of program. (Obsolete)
extern void changeRadix( IN long nRadix );
// Call whenever precision changes and at start of program. (Obsolete)
extern void changePrecision( IN long nPrecision );

// Call whenever either nRadix or nPrecision changes, is smarter about
// recalculating constants.
// (Prefered replacement for the ChangeRadix and ChangePrecision calls.)
extern void ChangeConstants( IN long nRadix, IN long nPrecision );

extern BOOL equnum( IN PNUMBER a, IN PNUMBER b );     // returns true of a == b
extern BOOL lessnum( IN PNUMBER a, IN PNUMBER b );    // returns true of a < b
extern BOOL zernum( IN PNUMBER a );                // returns true of a == 0
extern BOOL zerrat( IN PRAT a );                   // returns true if a == 0/q
extern TCHAR *putnum( IN OUT PNUMBER *ppnum, IN int fmt );

// returns a text representation of a (*pa)
extern TCHAR *putrat( IN OUT PRAT *pa, IN unsigned long nRadix, IN int fmt );

extern long longpow( IN unsigned long nRadix, IN long power );
extern long numtolong( IN PNUMBER pnum, IN unsigned long nRadix );
extern long rattolong( IN PRAT prat );
extern PNUMBER _createnum( IN long size );         // returns an empty number structure with size digits
extern PNUMBER nRadixxtonum( IN PNUMBER a, IN unsigned long nRadix );
extern PNUMBER binomial( IN long lroot, IN PNUMBER digitnum, IN PNUMBER c, IN PLINKEDLIST pll, IN unsigned long nRadix );
extern PNUMBER gcd( IN PNUMBER a, IN PNUMBER b );
extern PNUMBER innum( IN LPTSTR buffer );           // takes a text representation of a number and returns a number.

// takes a text representation of a number as a mantissa with sign and an exponent with sign.
extern PRAT inrat( IN BOOL fMantIsNeg, IN LPTSTR pszMant, IN BOOL fExpIsNeg, IN LPTSTR pszExp );

extern PNUMBER longfactnum( IN long inlong, IN unsigned long nRadix );
extern PNUMBER longprodnum( IN long start, IN long stop, IN unsigned long nRadix );
extern PNUMBER longtonum( IN long inlong, IN unsigned long nRadix );
extern PNUMBER numtonRadixx( IN PNUMBER a, IN unsigned long nRadix, IN long ratio );

// creates a empty/undefined rational representation (p/q)
extern PRAT _createrat( void );

// returns a new rat structure with the acos of x->p/x->q taking into account
// angle type
extern void acosanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the acosh of x->p/x->q
extern void acoshrat( IN OUT PRAT *px );

// returns a new rat structure with the acos of x->p/x->q
extern void acosrat( IN OUT PRAT *px );

// returns a new rat structure with the asin of x->p/x->q taking into account
// angle type
extern void asinanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void asinhrat( IN OUT PRAT *px );
// returns a new rat structure with the asinh of x->p/x->q

// returns a new rat structure with the asin of x->p/x->q
extern void asinrat( IN OUT PRAT *px );

// returns a new rat structure with the atan of x->p/x->q taking into account
// angle type
extern void atananglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the atanh of x->p/x->q
extern void atanhrat( IN OUT PRAT *px );

// returns a new rat structure with the atan of x->p/x->q
extern void atanrat( IN OUT PRAT *px );

// returns a new rat structure with the atan2 of x->p/x->q, y->p/y->q
extern void atan2rat( IN OUT PRAT *py, IN PRAT y );

// returns a new rat structure with the cosh of x->p/x->q
extern void coshrat( IN OUT PRAT *px );

// returns a new rat structure with the cos of x->p/x->q
extern void cosrat( IN OUT PRAT *px );

// returns a new rat structure with the cos of x->p/x->q taking into account
// angle type
extern void cosanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the exp of x->p/x->q this should not be called explicitly.
extern void _exprat( IN OUT PRAT *px );

// returns a new rat structure with the exp of x->p/x->q
extern void exprat( IN OUT PRAT *px );

// returns a new rat structure with the log base 10 of x->p/x->q
extern void log10rat( IN OUT PRAT *px );

// returns a new rat structure with the natural log of x->p/x->q
extern void lograt( IN OUT PRAT *px );

extern PRAT longtorat( IN long inlong );
extern PRAT numtorat( IN PNUMBER pin, IN unsigned long nRadix );
extern PRAT realtorat( IN double real );

extern void sinhrat( IN OUT PRAT *px );
extern void sinrat( IN OUT PRAT *px );

// returns a new rat structure with the sin of x->p/x->q taking into account
// angle type
extern void sinanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void tanhrat( IN OUT PRAT *px );
extern void tanrat( IN OUT PRAT *px );

// returns a new rat structure with the tan of x->p/x->q taking into account
// angle type
extern void tananglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void _destroynum( IN PNUMBER pnum );
extern void _destroyrat( IN PRAT prat );
extern void addnum( IN OUT PNUMBER *pa, IN PNUMBER b, unsigned long nRadix );
extern void addrat( IN OUT PRAT *pa, IN PRAT b );
extern void andrat( IN OUT PRAT *pa, IN PRAT b );
extern void const_init( void );
extern void divnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void divnumx( IN OUT PNUMBER *pa, IN PNUMBER b );
extern void divrat( IN OUT PRAT *pa, IN PRAT b );
extern void fracrat( IN OUT PRAT *pa );
extern void factrat( IN OUT PRAT *pa );
extern void modrat( IN OUT PRAT *pa, IN PRAT b );
extern void gcdrat( IN OUT PRAT *pa );
extern void intrat( IN OUT PRAT *px);
extern void mulnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void mulnumx( IN OUT PNUMBER *pa, IN PNUMBER b );
extern void mulrat( IN OUT PRAT *pa, IN PRAT b );
extern void numpowlong( IN OUT PNUMBER *proot, IN long power, IN unsigned long nRadix );
extern void numpowlongx( IN OUT PNUMBER *proot, IN long power );
extern void orrat( IN OUT PRAT *pa, IN PRAT b );
extern void powrat( IN OUT PRAT *pa, IN PRAT b );
extern void ratpowlong( IN OUT PRAT *proot, IN long power );
extern void remnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN long nRadix );
extern void rootnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void rootrat( IN OUT PRAT *pa, IN PRAT b );
extern void scale2pi( IN OUT PRAT *px );
extern void scale( IN OUT PRAT *px, IN PRAT scalefact );
extern void subrat( IN OUT PRAT *pa, IN PRAT b );
extern void xorrat( IN OUT PRAT *pa, IN PRAT b );
extern void lshrat( IN OUT PRAT *pa, IN PRAT b );
extern void rshrat( IN OUT PRAT *pa, IN PRAT b );
extern BOOL rat_equ( IN PRAT a, IN PRAT b );
extern BOOL rat_neq( IN PRAT a, IN PRAT b );
extern BOOL rat_gt( IN PRAT a, IN PRAT b );
extern BOOL rat_ge( IN PRAT a, IN PRAT b );
extern BOOL rat_lt( IN PRAT a, IN PRAT b );
extern BOOL rat_le( IN PRAT a, IN PRAT b );
extern void inbetween( IN PRAT *px, IN PRAT range );
extern DWORDLONG __inline Mul32x32( IN DWORD a, IN DWORD b );
//extern DWORDLONG __inline __fastcall Shr32xbase( IN DWORDLONG a );
extern void factnum( IN OUT PLINKEDLIST *ppllfact, PNUMBER pnum );
extern void trimit( IN OUT PRAT *px );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\trans.c ===
//----------------------------------------------------------------------------
//  File           trans.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains sin, cos and tan for rationals
//
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


void scalerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    switch ( angletype )
        {
    case ANGLE_RAD:
        scale2pi( pa );
        break;
    case ANGLE_DEG:
        scale( pa, rat_360 );
        break;
    case ANGLE_GRAD:
        scale( pa, rat_400 );
        break;
        }
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: sinrat, _sinrat
//
//  ARGUMENTS:  x PRAT representation of number to take the sine of
//
//  RETURN: sin of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j+1   j
//   \  ]  X     -1
//    \   ---------
//    /    (2j+1)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                              -X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------


void _sinrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);

    DUPNUM(n2,num_one);
    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
    
    // Since *px might be epsilon above 1 or below -1, due to TRIMIT we need 
    // this trick here.
    inbetween(px,rat_one);
    
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(*px,rat_smallest) && rat_ge(*px,rat_negsmallest) )
        {
        DUPRAT(*px,rat_zero);
        }
}

void sinrat( PRAT *px )
{
    scale2pi(px); 
    _sinrat(px); 
}

void sinanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
        {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            subrat(pa,rat_360);
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            subrat(pa,rat_400);
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _sinrat( pa );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: cosrat, _cosrat
//
//  ARGUMENTS:  x PRAT representation of number to take the cosine of
//
//  RETURN: cosin of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j   j
//   \  ]  X   -1
//    \   ---------
//    /    (2j)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                              -X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------


void _cosrat( PRAT *px )

{
    CREATETAYLOR();

    pret->pp=longtonum( 1L, nRadix );
    pret->pq=longtonum( 1L, nRadix );

    DUPRAT(thisterm,pret)

    n2=longtonum(0L, nRadix);
    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
    // Since *px might be epsilon above 1 or below -1, due to TRIMIT we need 
    // this trick here.
    inbetween(px,rat_one);
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(*px,rat_smallest) && rat_ge(*px,rat_negsmallest) )
        {
        DUPRAT(*px,rat_zero);
        }
}

void cosrat( PRAT *px )
{
    scale2pi(px); 
    _cosrat(px); 
}

void cosanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
        {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            PRAT ptmp=NULL;
            DUPRAT(ptmp,rat_360);
            subrat(&ptmp,*pa);
            destroyrat(*pa);
            *pa=ptmp;
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            PRAT ptmp=NULL;
            DUPRAT(ptmp,rat_400);
            subrat(&ptmp,*pa);
            destroyrat(*pa);
            *pa=ptmp;
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _cosrat( pa );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: tanrat, _tanrat
//
//  ARGUMENTS:  x PRAT representation of number to take the tangent of
//
//  RETURN: tan     of x in PRAT form.
//
//  EXPLANATION: This uses sinrat and cosrat
//
//-----------------------------------------------------------------------------


void _tanrat( PRAT *px )

{
    PRAT ptmp=NULL;

    DUPRAT(ptmp,*px);
    _sinrat(px);
    _cosrat(&ptmp);
    if ( zerrat( ptmp ) )
        {
    	destroyrat(ptmp);
        throw( CALC_E_DOMAIN );
        }
    divrat(px,ptmp);

    destroyrat(ptmp);

}

void tanrat( PRAT *px )
{
    scale2pi(px); 
    _tanrat(px); 
}

void tananglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
        {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            subrat(pa,rat_180);
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            subrat(pa,rat_200);
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _tanrat( pa );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\support.c ===
//----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           support.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           10-21-96
//
//
//  Description
//
//     Contains support functions for rationals and numbers.
//
//  Special Information
//
//
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>



BOOL fhalt;

LINKEDLIST gllfact;

void _readconstants( void );

#if defined( GEN_CONST )
void _dumprawrat( TCHAR *varname, PRAT rat );
void _dumprawnum( PNUMBER num );

static cbitsofprecision = 0;
#define READRAWRAT(v)
#define READRAWNUM(v)
#define DUMPRAWRAT(v) _dumprawrat(#v,v)
#define DUMPRAWNUM(v) fprintf( stderr, \
"// Autogenerated by _dumprawrat in support.c\n" ); \
    fprintf( stderr, "NUMBER init_" #v "= {\n" ); \
    _dumprawnum(v); \
    fprintf( stderr, "};\n" )


#else

#define DUMPRAWRAT(v)
#define DUMPRAWNUM(v)
#define READRAWRAT(v) createrat(v); DUPNUM(v->pp,(&(init_p_##v))); \
DUPNUM(v->pq,(&(init_q_##v)));
#define READRAWNUM(v) DUPNUM(v,(&(init_##v)))

#define RATIO_FOR_DECIMAL 9
#define DECIMAL 10
#define CALC_DECIMAL_DIGITS_DEFAULT 32

static cbitsofprecision = RATIO_FOR_DECIMAL * DECIMAL * 
                            CALC_DECIMAL_DIGITS_DEFAULT;

#include <ratconst.h>

#endif

unsigned char ftrueinfinite = FALSE;    // Set to true if you don't want 
                                        // chopping internally
long maxout;                            // precision used internally

PNUMBER num_one=NULL;
PNUMBER num_two=NULL;
PNUMBER num_five=NULL;
PNUMBER num_six=NULL;
PNUMBER num_ten=NULL;
PNUMBER num_nRadix=NULL;


PRAT ln_ten=NULL;
PRAT ln_two=NULL;
PRAT rat_zero=NULL;
PRAT rat_one=NULL;
PRAT rat_neg_one=NULL;
PRAT rat_two=NULL;
PRAT rat_six=NULL;
PRAT rat_half=NULL;
PRAT rat_ten=NULL;
PRAT pt_eight_five=NULL;
PRAT pi=NULL;
PRAT pi_over_two=NULL;
PRAT two_pi=NULL;
PRAT one_pt_five_pi=NULL;
PRAT e_to_one_half=NULL;
PRAT rat_exp=NULL;
PRAT rad_to_deg=NULL;
PRAT rad_to_grad=NULL;
PRAT rat_qword=NULL;
PRAT rat_dword=NULL;
PRAT rat_word=NULL;
PRAT rat_byte=NULL;
PRAT rat_360=NULL;
PRAT rat_400=NULL;
PRAT rat_180=NULL;
PRAT rat_200=NULL;
PRAT rat_nRadix=NULL;
PRAT rat_smallest=NULL;
PRAT rat_negsmallest=NULL;
PRAT rat_max_exp=NULL;
PRAT rat_min_exp=NULL;
PRAT rat_min_long=NULL;


//----------------------------------------------------------------------------
//
//  FUNCTION: ChangeRadix
//
//  ARGUMENTS:  base changing to, and precision to use.
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void changeRadix( long nRadix )

{
    ChangeConstants( nRadix, maxout );
}


//----------------------------------------------------------------------------
//
//  FUNCTION: changePrecision
//
//  ARGUMENTS:  Precision to use
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void changePrecision( long nPrecision )

{
    ChangeConstants( nRadix, nPrecision );
}

//----------------------------------------------------------------------------
//
//  FUNCTION: ChangeConstants
//
//  ARGUMENTS:  base changing to, and precision to use.
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void ChangeConstants( long nRadix, long nPrecision )

{
    long digit;
    DWORD dwLim;

    maxout = nPrecision;          
    fhalt = FALSE;
    
    
    // ratio is set to the number of digits in the current nRadix, you can get 
    // in the internal BASEX nRadix, this is important for length calculations 
    // in translating from nRadix to BASEX and back.                           

    dwLim = (DWORD)BASEX / (DWORD)nRadix;

    for ( digit = 1, ratio = 0; (DWORD)digit < dwLim; digit *= nRadix )
        {
        ratio++;
        }
    ratio += !ratio;

    destroynum(num_nRadix);
    num_nRadix=longtonum( nRadix, BASEX );
   
    destroyrat(rat_nRadix);
    rat_nRadix=longtorat( nRadix );
    
    // Check to see what we have to recalculate and what we don't
    if ( cbitsofprecision < ( ratio * nRadix * nPrecision ) )
        {
        ftrueinfinite=FALSE;
        num_one=longtonum( 1L, BASEX );
        DUMPRAWNUM(num_one);
        num_two=longtonum( 2L, BASEX );
        DUMPRAWNUM(num_two);
        num_five=longtonum( 5L, BASEX );
        DUMPRAWNUM(num_five);
        num_six=longtonum( 6L, BASEX );
        DUMPRAWNUM(num_six);
        num_ten=longtonum( 10L, BASEX );
        DUMPRAWNUM(num_ten);

        DUPRAT(rat_smallest,rat_nRadix);
        ratpowlong(&rat_smallest,-nPrecision);
        DUPRAT(rat_negsmallest,rat_smallest);
        rat_negsmallest->pp->sign = -1;
        DUMPRAWRAT(rat_smallest);
        DUMPRAWRAT(rat_negsmallest);
        createrat( rat_half );

        createrat( pt_eight_five );

        pt_eight_five->pp=longtonum( 85L, BASEX );
        pt_eight_five->pq=longtonum( 100L, BASEX );
        DUMPRAWRAT(pt_eight_five);

        rat_six = longtorat( 6L );
        DUMPRAWRAT(rat_six);

        rat_two=longtorat( 2L );
        DUMPRAWRAT(rat_two);

        rat_zero=longtorat( 0L );
        DUMPRAWRAT(rat_zero);

        rat_one=longtorat( 1L );
        DUMPRAWRAT(rat_one);

        rat_neg_one=longtorat( -1L );
        DUMPRAWRAT(rat_neg_one);

        DUPNUM(rat_half->pp,num_one);
        DUPNUM(rat_half->pq,num_two);
        DUMPRAWRAT(rat_half);

        rat_ten=longtorat( 10L );
        DUMPRAWRAT(rat_ten);
        
        // Apparently when dividing 180 by pi, another (internal) digit of 
        // precision is needed.
        maxout += ratio;
        DUPRAT(pi,rat_half);
        asinrat( &pi );
        mulrat( &pi, rat_six );
        DUMPRAWRAT(pi);
    
        DUPRAT(two_pi,pi);
        DUPRAT(pi_over_two,pi);
        DUPRAT(one_pt_five_pi,pi);
        addrat(&two_pi,pi);
        DUMPRAWRAT(two_pi);
    
        divrat(&pi_over_two,rat_two);
        DUMPRAWRAT(pi_over_two);
    
        addrat(&one_pt_five_pi,pi_over_two);
        DUMPRAWRAT(one_pt_five_pi);
    
        DUPRAT(e_to_one_half,rat_half);
        _exprat(&e_to_one_half);
        DUMPRAWRAT(e_to_one_half);

        DUPRAT(rat_exp,rat_one);
        _exprat(&rat_exp);
        DUMPRAWRAT(rat_exp);
        
        // WARNING: remember lograt uses exponent constants calculated above...

        DUPRAT(ln_ten,rat_ten);
        lograt( &ln_ten );
        DUMPRAWRAT(ln_ten);

        DUPRAT(ln_two,rat_two);
        lograt(&ln_two);
        DUMPRAWRAT(ln_two);
    
    
        destroyrat(rad_to_deg);
        rad_to_deg=longtorat(180L);
        divrat(&rad_to_deg,pi);
        DUMPRAWRAT(rad_to_deg);
    
        destroyrat(rad_to_grad);
        rad_to_grad=longtorat(200L);
        divrat(&rad_to_grad,pi);
        DUMPRAWRAT(rad_to_grad);
        maxout -= ratio;

        DUPRAT(rat_qword,rat_two);
        numpowlong( &(rat_qword->pp), 64, BASEX );
        subrat( &rat_qword, rat_one );
        DUMPRAWRAT(rat_qword);

        DUPRAT(rat_dword,rat_two);
        numpowlong( &(rat_dword->pp), 32, BASEX );
        subrat( &rat_dword, rat_one );
        DUMPRAWRAT(rat_dword);
        DUPRAT(rat_min_long,rat_dword);
        rat_min_long->pp->sign *= -1;
        DUMPRAWRAT(rat_min_long);

        rat_word = longtorat( 0xffff );
        DUMPRAWRAT(rat_word);
        rat_byte = longtorat( 0xff );
        DUMPRAWRAT(rat_byte);

        rat_400 = longtorat( 400 );
        DUMPRAWRAT(rat_400);

        rat_360 = longtorat( 360 );
        DUMPRAWRAT(rat_360);

        rat_200 = longtorat( 200 );
        DUMPRAWRAT(rat_200);

        rat_180 = longtorat( 180 );
        DUMPRAWRAT(rat_180);

        rat_max_exp = longtorat( 100000 );
        DUPRAT(rat_min_exp,rat_max_exp);
        rat_min_exp->pp->sign *= -1;
        DUMPRAWRAT(rat_max_exp);
        DUMPRAWRAT(rat_min_exp);

        cbitsofprecision = ratio * nRadix * nPrecision;
        }
    else
        {
        _readconstants();

        DUPRAT(rat_smallest,rat_nRadix);
        ratpowlong(&rat_smallest,-nPrecision);
        DUPRAT(rat_negsmallest,rat_smallest);
        rat_negsmallest->pp->sign = -1;
        }

}

//----------------------------------------------------------------------------
//
//  FUNCTION: intrat
//
//  ARGUMENTS:  pointer to x PRAT representation of number
//
//  RETURN: no return value x PRAT is smashed with integral number
//
//
//----------------------------------------------------------------------------

void intrat( PRAT *px)

{
    PRAT pret=NULL;
    PNUMBER pnum=NULL;
    TCHAR *psz;
    // Only do the intrat operation if number is nonzero.
    // and only if the bottom part is not one.
    if ( !zernum( (*px)->pp ) && !equnum( (*px)->pq, num_one ) )
        {
        psz=putrat( px, nRadix, FMT_FLOAT );
        pnum = innum( psz );
        zfree( psz );

        destroyrat( *px );
        *px = numtorat( pnum, nRadix );
        destroynum( pnum );

        DUPRAT(pret,*px);
        modrat( &pret, rat_one );
        
        subrat( px, pret );
        destroyrat( pret );
        }
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_equ
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if equal FALSE otherwise.
//
//
//---------------------------------------------------------------------------

BOOL rat_equ( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    rattmp->pp->sign *= -1;
    addrat( &rattmp, b );
    bret = zernum( rattmp->pp );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_ge
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is greater than or equal to b
//
//
//---------------------------------------------------------------------------

BOOL rat_ge( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( zernum( rattmp->pp ) || 
        rattmp->pp->sign * rattmp->pq->sign == 1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_gt
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is greater than b
//
//
//---------------------------------------------------------------------------

BOOL rat_gt( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( !zernum( rattmp->pp ) && 
        rattmp->pp->sign * rattmp->pq->sign == 1 );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_le
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is less than or equal to b
//
//
//---------------------------------------------------------------------------

BOOL rat_le( PRAT a, PRAT b )

{

    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( zernum( rattmp->pp ) || 
        rattmp->pp->sign * rattmp->pq->sign == -1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_lt
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is less than b
//
//
//---------------------------------------------------------------------------

BOOL rat_lt( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( !zernum( rattmp->pp ) && 
        rattmp->pp->sign * rattmp->pq->sign == -1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_neq
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is not equal to b
//
//
//---------------------------------------------------------------------------


BOOL rat_neq( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    rattmp->pp->sign *= -1;
    addrat( &rattmp, b );
    bret = !( zernum( rattmp->pp ) );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  function: scale
//
//  ARGUMENTS:  pointer to x PRAT representation of number, and scaling factor
//
//  RETURN: no return, value x PRAT is smashed with a scaled number in the
//          range of the scalefact.
//
//---------------------------------------------------------------------------

void scale( PRAT *px, PRAT scalefact )

{
    long logscale;
    PRAT pret=NULL;
    DUPRAT(pret,*px);
    
    // Logscale is a quick way to tell how much extra precision is needed for 
    // scaleing by scalefact.
    logscale = ratio * ( (pret->pp->cdigit+pret->pp->exp) - 
            (pret->pq->cdigit+pret->pq->exp) );
    if ( logscale > 0 )
        {
        maxout += logscale;
        }
    else
        {
        logscale = 0;
        }

    divrat( &pret, scalefact);
    intrat(&pret);
    mulrat( &pret, scalefact);
    pret->pp->sign *= -1;
    addrat( px, pret);

    maxout -= logscale;
    destroyrat( pret );
}

//---------------------------------------------------------------------------
//
//  function: scale2pi
//
//  ARGUMENTS:  pointer to x PRAT representation of number
//
//  RETURN: no return, value x PRAT is smashed with a scaled number in the
//          range of 0..2pi
//
//---------------------------------------------------------------------------

void scale2pi( PRAT *px )

{
    long logscale;
    PRAT pret=NULL;
    PRAT my_two_pi=NULL;
    DUPRAT(pret,*px);
    
    // Logscale is a quick way to tell how much extra precision is needed for 
    // scaleing by 2 pi.
    logscale = ratio * ( (pret->pp->cdigit+pret->pp->exp) - 
            (pret->pq->cdigit+pret->pq->exp) );
    if ( logscale > 0 )
        {
        maxout += logscale;
        DUPRAT(my_two_pi,rat_half);
        asinrat( &my_two_pi );
        mulrat( &my_two_pi, rat_six );
        mulrat( &my_two_pi, rat_two );
        }
    else
        {
        DUPRAT(my_two_pi,two_pi);
        logscale = 0;
        }

    divrat( &pret, my_two_pi);
    intrat(&pret);
    mulrat( &pret, my_two_pi);
    pret->pp->sign *= -1;
    addrat( px, pret);

    maxout -= logscale;
    destroyrat( my_two_pi );
    destroyrat( pret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: inbetween
//
//  ARGUMENTS:  PRAT *px, and PRAT range.
//
//  RETURN: none, changes *px to -/+range, if px is outside -range..+range
//
//---------------------------------------------------------------------------

void inbetween( PRAT *px, PRAT range )

{
    if ( rat_gt(*px,range) )
        {
        DUPRAT(*px,range);
        }
    else
        {
        range->pp->sign *= -1;
        if ( rat_lt(*px,range) )
            {
            DUPRAT(*px,range);
            }
        range->pp->sign *= -1;
        }
}

#if defined( GEN_CONST )

//---------------------------------------------------------------------------
//
//  FUNCTION: _dumprawrat
//
//  ARGUMENTS:  char *name of variable, PRAT x
//
//  RETURN: none, prints the results of a dump of the internal structures
//          of a PRAT, suitable for READRAWRAT to stderr.
//
//---------------------------------------------------------------------------

void _dumprawrat( TCHAR *varname, PRAT rat )

{
    fprintf( stderr, "// Autogenerated by _dumprawrat in support.c\n" );
    fprintf( stderr, "NUMBER init_p_%s = {\n", varname );
    _dumprawnum( rat->pp );
    fprintf( stderr, "};\n" );
    fprintf( stderr, "NUMBER init_q_%s = {\n", varname );
    _dumprawnum( rat->pq );
    fprintf( stderr, "};\n" );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: _dumprawnum
//
//  ARGUMENTS:  PNUMBER num
//
//  RETURN: none, prints the results of a dump of the internal structures
//          of a PNUMBER, suitable for READRAWNUM to stderr.
//
//---------------------------------------------------------------------------

void _dumprawnum( PNUMBER num )

{
    int i;

    fprintf( stderr, "\t%d,\n", num->sign );
    fprintf( stderr, "\t%d,\n", num->cdigit );
    fprintf( stderr, "\t%d,\n", num->exp );
    fprintf( stderr, "\t{ " );

    for ( i = 0; i < num->cdigit; i++ )
        {
        fprintf( stderr, " %d,", num->mant[i] );
        }
    fprintf( stderr, "}\n" );
}
#endif
void _readconstants( void )

{
    READRAWNUM(num_one);
    READRAWNUM(num_two);
    READRAWNUM(num_five);
    READRAWNUM(num_six);
    READRAWNUM(num_ten);
    READRAWRAT(pt_eight_five);
    READRAWRAT(rat_six);
    READRAWRAT(rat_two);
    READRAWRAT(rat_zero);
    READRAWRAT(rat_one);
    READRAWRAT(rat_neg_one);
    READRAWRAT(rat_half);
    READRAWRAT(rat_ten);
    READRAWRAT(pi);
    READRAWRAT(two_pi);
    READRAWRAT(pi_over_two);
    READRAWRAT(one_pt_five_pi);
    READRAWRAT(e_to_one_half);
    READRAWRAT(rat_exp);
    READRAWRAT(ln_ten);
    READRAWRAT(ln_two);
    READRAWRAT(rad_to_deg);
    READRAWRAT(rad_to_grad);
    READRAWRAT(rat_qword);
    READRAWRAT(rat_dword);
    READRAWRAT(rat_word);
    READRAWRAT(rat_byte);
    READRAWRAT(rat_360);
    READRAWRAT(rat_400);
    READRAWRAT(rat_180);
    READRAWRAT(rat_200);
    READRAWRAT(rat_smallest);
    READRAWRAT(rat_negsmallest);
    READRAWRAT(rat_max_exp);
    READRAWRAT(rat_min_exp);
    READRAWRAT(rat_min_long);
    DUPNUM(gllfact.pnum,num_one);
    gllfact.llprev = NULL;
    gllfact.llnext = NULL;
}

void factnum( IN OUT PLINKEDLIST *ppllfact, PNUMBER pnum )

{
    PNUMBER thisnum=NULL;
    PLINKEDLIST pllfact = *ppllfact;

    if ( pllfact->llnext == NULL ) 
        {
        // This factorial hasn't happened yet, lets compute it.
        DUPNUM(thisnum,pllfact->pnum);
        mulnumx(&thisnum,pnum);
        pllfact->llnext = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
        if (pllfact->llnext)
            {
            pllfact->llnext->pnum = thisnum;
            pllfact->llnext->llprev = pllfact;
            pllfact->llnext->llnext = NULL;
            }
        }
    *ppllfact = pllfact->llnext;
}


//---------------------------------------------------------------------------
//
//  FUNCTION: trimit
//
//  ARGUMENTS:  PRAT *px
//
//
//  DESCRIPTION: Chops off digits from rational numbers to avoid time 
//  explosions in calculations of functions using series.  
//  Gregory Stepanets proved it was enough to only keep the first n digits 
//  of the largest of p or q in the rational p over q form, and of course 
//  scale the smaller by the same number of digits.  This will give you 
//  n-1 digits of accuracy.  This dramatically speeds up calculations 
//  involving hundreds of digits or more.
//  The last part of this trim dealing with exponents never affects accuracy
//
//  RETURN: none, modifies the pointed to PRAT 
//
//---------------------------------------------------------------------------

void trimit( PRAT *px ) 

{
    if ( !ftrueinfinite )
        { 
        long trim;
        PNUMBER pp=(*px)->pp;
        PNUMBER pq=(*px)->pq;
        trim = ratio * (min((pp->cdigit+pp->exp),(pq->cdigit+pq->exp))-1) - maxout;
        if ( trim > ratio )
            {
            trim /= ratio;

            if ( trim <= pp->exp )
                {
                pp->exp -= trim;
                }
            else
                {
                memmove( MANT(pp), &(MANT(pp)[trim-pp->exp]), sizeof(MANTTYPE)*(pp->cdigit-trim+pp->exp) );
                pp->cdigit -= trim-pp->exp;
                pp->exp = 0;
                }

            if ( trim <= pq->exp )
                {
                pq->exp -= trim;
                }
            else
                {
                memmove( MANT(pq), &(MANT(pq)[trim-pq->exp]), sizeof(MANTTYPE)*(pq->cdigit-trim+pq->exp) );
                pq->cdigit -= trim-pq->exp;
                pq->exp = 0;
                }
            }
        trim = min(pp->exp,pq->exp);
        pp->exp -= trim;
        pq->exp -= trim;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\transh.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           transh.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains hyperbolic sin, cos, and tan for rationals.
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

//-----------------------------------------------------------------------------
//
//  FUNCTION: sinhrat, _sinhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the sine hyperbolic
//    of
//  RETURN: sinh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j+1
//   \  ]  X
//    \   ---------
//    /    (2j+1)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   if x is bigger than 1.0 (e^x-e^-x)/2 is used.
//
//-----------------------------------------------------------------------------


void _sinhrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,pret);

    DUPNUM(n2,num_one);

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void sinhrat( PRAT *px )

{
    PRAT pret=NULL;
    PRAT tmpx=NULL;

    if ( rat_ge( *px, rat_one ) )
        {
        DUPRAT(tmpx,*px);
        exprat(px);
        tmpx->pp->sign *= -1;
        exprat(&tmpx);
        subrat( px, tmpx );
        divrat( px, rat_two );
        destroyrat( tmpx );
        }
    else
        {
        _sinhrat( px );
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: coshrat
//
//  ARGUMENTS:  x PRAT representation of number to take the cosine
//              hyperbolic of
//
//  RETURN: cosh  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j
//   \  ]  X
//    \   ---------
//    /    (2j)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//   if x is bigger than 1.0 (e^x+e^-x)/2 is used.
//
//-----------------------------------------------------------------------------


void _coshrat( PRAT *px )

{
    CREATETAYLOR();

    pret->pp=longtonum( 1L, nRadix );
    pret->pq=longtonum( 1L, nRadix );

    DUPRAT(thisterm,pret)

    n2=longtonum(0L, nRadix);

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void coshrat( PRAT *px )

{
    PRAT tmpx=NULL;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    if ( rat_ge( *px, rat_one ) )
        {
        DUPRAT(tmpx,*px);
        exprat(px);
        tmpx->pp->sign *= -1;
        exprat(&tmpx);
        addrat( px, tmpx );
        divrat( px, rat_two );
        destroyrat( tmpx );
        }
    else
        {
        _coshrat( px );
        }
    // Since *px might be epsilon below 1 due to TRIMIT 
    // we need this trick here.
    if ( rat_lt(*px,rat_one) )
        {
        DUPRAT(*px,rat_one);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: tanhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the tangent
//              hyperbolic of
//
//  RETURN: tanh    of x in PRAT form.
//
//  EXPLANATION: This uses sinhrat and coshrat
//
//-----------------------------------------------------------------------------

void tanhrat( PRAT *px )

{
    PRAT ptmp=NULL;

    DUPRAT(ptmp,*px);
    sinhrat(px);
    coshrat(&ptmp);
    mulnumx(&((*px)->pp),ptmp->pq);
    mulnumx(&((*px)->pq),ptmp->pp);

    destroyrat(ptmp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ratpak\ratconst.h ===
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_one= {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_two= {
	1,
	1,
	0,
	{  2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_five= {
	1,
	1,
	0,
	{  5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_six= {
	1,
	1,
	0,
	{  6,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_ten= {
	1,
	1,
	0,
	{  10,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_smallest = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_smallest = {
	1,
	4,
	0,
	{  0, 190439170, 901055854, 10097,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_negsmallest = {
	-1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_negsmallest = {
	1,
	4,
	0,
	{  0, 190439170, 901055854, 10097,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pt_eight_five = {
	1,
	1,
	0,
	{  85,}
};
NUMBER init_q_pt_eight_five = {
	1,
	1,
	0,
	{  100,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_six = {
	1,
	1,
	0,
	{  6,}
};
NUMBER init_q_rat_six = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_two = {
	1,
	1,
	0,
	{  2,}
};
NUMBER init_q_rat_two = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_zero = {
	1,
	1,
	0,
	{  0,}
};
NUMBER init_q_rat_zero = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_one = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_one = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_neg_one = {
	-1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_neg_one = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_half = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_half = {
	1,
	1,
	0,
	{  2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_ten = {
	1,
	1,
	0,
	{  10,}
};
NUMBER init_q_rat_ten = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pi = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
NUMBER init_q_pi = {
	1,
	6,
	0,
	{  1288380402, 1120116153, 1860424692, 1944118326, 1583591604, 2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_two_pi = {
	1,
	6,
	0,
	{  251055792, 567796700, 1773504224, 1198217877, 428852897, 17,}
};
NUMBER init_q_two_pi = {
	1,
	6,
	0,
	{  1288380402, 1120116153, 1860424692, 1944118326, 1583591604, 2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pi_over_two = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
NUMBER init_q_pi_over_two = {
	1,
	6,
	0,
	{  429277156, 92748659, 1573365737, 1740753005, 1019699561, 5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_one_pt_five_pi = {
	1,
	6,
	0,
	{  1241201312, 270061909, 1051574664, 1924965045, 1340320627, 70,}
};
NUMBER init_q_one_pt_five_pi = {
	1,
	6,
	0,
	{  1579671539, 1837970263, 1067644340, 523549916, 2119366659, 14,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_e_to_one_half = {
	1,
	6,
	0,
	{  256945612, 216219427, 223516738, 477442596, 581063757, 23,}
};
NUMBER init_q_e_to_one_half = {
	1,
	6,
	0,
	{  1536828363, 698484484, 1127331835, 224219346, 245499408, 14,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_exp = {
	1,
	6,
	0,
	{  943665199, 1606559160, 1094967530, 1759391384, 1671799163, 1123581,}
};
NUMBER init_q_rat_exp = {
	1,
	6,
	0,
	{  879242208, 2022880100, 617392930, 1374929092, 1367479163, 413342,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_ln_ten = {
	1,
	6,
	0,
	{  2086268922, 165794492, 1416063951, 1851428830, 1893239400, 65366841,}
};
NUMBER init_q_ln_ten = {
	1,
	6,
	0,
	{  26790652, 564532679, 783998273, 216030448, 1564709968, 28388458,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_ln_two = {
	1,
	6,
	0,
	{  1789230241, 1057927868, 715399197, 908801241, 1411265331, 3,}
};
NUMBER init_q_ln_two = {
	1,
	6,
	0,
	{  1559869847, 1930657510, 1228561531, 219003871, 593099283, 5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rad_to_deg = {
	1,
	6,
	0,
	{  2127722024, 1904928383, 2016479213, 2048947859, 1578647346, 492,}
};
NUMBER init_q_rad_to_deg = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rad_to_grad = {
	1,
	6,
	0,
	{  2125526288, 684931327, 570267400, 129125085, 1038224725, 547,}
};
NUMBER init_q_rad_to_grad = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_qword = {
	1,
	3,
	0,
	{  2147483647, 2147483647, 3,}
};
NUMBER init_q_rat_qword = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_dword = {
	1,
	2,
	0,
	{  2147483647, 1,}
};
NUMBER init_q_rat_dword = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_min_long = {
	-1,
	2,
	0,
	{  2147483647, 1,}
};
NUMBER init_q_rat_min_long = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_word = {
	1,
	1,
	0,
	{  65535,}
};
NUMBER init_q_rat_word = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_byte = {
	1,
	1,
	0,
	{  255,}
};
NUMBER init_q_rat_byte = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_400 = {
	1,
	1,
	0,
	{  400,}
};
NUMBER init_q_rat_400 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_360 = {
	1,
	1,
	0,
	{  360,}
};
NUMBER init_q_rat_360 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_200 = {
	1,
	1,
	0,
	{  200,}
};
NUMBER init_q_rat_200 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_180 = {
	1,
	1,
	0,
	{  180,}
};
NUMBER init_q_rat_180 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_max_exp = {
	1,
	1,
	0,
	{  100000,}
};
NUMBER init_q_rat_max_exp = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_min_exp = {
	-1,
	1,
	0,
	{  100000,}
};
NUMBER init_q_rat_min_exp = {
	1,
	1,
	0,
	{  1,}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\spechars\cmdlg.h ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    cmdlg.h

Abstract:

    This module contains the dialog definitions for the Charmap utility.

Revision History:

--*/



//
//  Constant Declarations.
//

#define ID_HELP                             100
#define ID_CLOSE                            101
#define ID_COPY                             102
#define ID_SELECT                           103
#define ID_STRING                           104
#define ID_FONT                             105
#define ID_TOPLEFT                          107
#define ID_CHARGRID                         108
#define ID_SUBSET                           109
#define IDBM_TT                             110
#define IDIC_CHARMAP                        111
#define IDS_HELP                            112
#define IDS_RTF                             113
#define IDS_KEYSTROKE                       114
#define IDS_SPACE                           115
#define IDS_CTRL                            116
#define IDS_CTRLALT                         117
#define IDS_SHIFTCTRLALT                    118
#define IDS_ALT                             119
#define IDS_UNICODELABEL                    120

#define IDS_WINDOWS                         1
#define IDS_LATIN1                          2
#define IDS_LATINEXA                        3
#define IDS_LATINEXB                        4
#define IDS_IPAEX                           5
#define IDS_SPACINGMODIFIERS                6
#define IDS_COMBININGDIACRITICS             7
#define IDS_BASICGREEK                      8
#define IDS_GREEKSYMBOLS                    9
#define IDS_CYRILLIC                        10
#define IDS_ARMENIAN                        11
#define IDS_HEBREW                          12
#define IDS_BASICHEBREW                     12
#define IDS_HEBREWEX                        13
#define IDS_BASICARABIC                     14
#define IDS_ARABICEX                        15
#define IDS_DEVANAGARI                      16
#define IDS_BENGALI                         17
#define IDS_GURMUKHI                        18
#define IDS_GUJARATI                        19
#define IDS_ORIYA                           20
#define IDS_TAMIL                           21
#define IDS_TELUGU                          22
#define IDS_KANNADA                         23
#define IDS_MALAYALAM                       24
#define IDS_THAI                            25
#define IDS_LAO                             26
#define IDS_BASICGEORGIAN                   27
#define IDS_GEORGIANEX                      28
#define IDS_HANGULJAMO                      29
#define IDS_LATINEXADDITIONAL               30
#define IDS_GREEKEX                         31
#define IDS_GENERALPUNCTUATION              32
#define IDS_SUPERANDSUBSCRIPTS              33
#define IDS_CURRENCYSYMBOLS                 34
#define IDS_COMBININGDIACRITICSFORSYMBOLS   35
#define IDS_LETTERLIKESYMBOLS               36
#define IDS_NUMBERFORMS                     37
#define IDS_ARROWS                          38
#define IDS_MATHEMATICALOPS                 39
#define IDS_MISCTECHNICAL                   40
#define IDS_CONTROLPICTURES                 41
#define IDS_OPTICALCHAR                     42
#define IDS_ENCLOSEDALPHANUM                43
#define IDS_BOXDRAWING                      44
#define IDS_BLOCKELEMENTS                   45
#define IDS_GEOMETRICSHAPES                 46
#define IDS_MISCDINGBATS                    47
#define IDS_DINGBATS                        48
#define IDS_CJKSYMBOLSANDPUNC               49
#define IDS_HIRAGANA                        50
#define IDS_KATAKANA                        51
#define IDS_BOPOMOFO                        52
#define IDS_HANGULCOMPATIBILITYJAMO         53
#define IDS_CJKMISC                         54
#define IDS_ENCLOSEDCJKLETTERSANDMONTHS     55
#define IDS_CJKCOMPATIBILITY                56
#define IDS_HANGUL                          57
#define IDS_HANGULSUPPA                     58
#define IDS_HANGULSUPPB                     59
#define IDS_CJKUNIFIEDIDEOGRAPHS            60
#define IDS_PRIVATEUSEAREA                  61
#define IDS_CJKCOMPATIBILITYIDEOGRAPHS      62
#define IDS_ALPAHPRESENTATIONFORMS          63
#define IDS_ARABICPRESENTATIONFORMSA        64
#define IDS_CJKCOMPFORMS                    66
#define IDS_SMALLFORMVARIANTS               67
#define IDS_ARABICPRESENTATIONFORMSB        68
#define IDS_HALFANDFULLWIDTHFORMS           69
#define IDS_SPECIALS                        70


#define ID_SUBSETLB                         201
#define ID_NEXTSUBSET                       203
#define ID_PREVSUBSET                       205

#define ID_UNICODESUBSET                    202
#define ID_MAPSCROLL                        204

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\spechars\charmap.h ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    charmap.h

Abstract:

    This module contains the header information for the Charmap utility.

Revision History:

--*/



//
//  Include Files.
//
#include "cmdlg.h"




//
//  Constant Declarations.
//

#define BTOC(bytes)     ((bytes) / sizeof(TCHAR))
#define CTOB(cch)       ((cch) * sizeof(TCHAR))

#define cchFullMap      (256)

#define CCH_KEYNAME     50             // number of chars in keyname

#define LF_SUBSETSIZE   128




//
//  Typedef Declarations.
//

#ifdef UNICODE
typedef unsigned short UTCHAR;
#else
typedef unsigned char UTCHAR;
#endif
#define UCHAR unsigned char

typedef struct tagSYCM
{
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[256];
} SYCM, *PSYCM;


typedef struct tagITEMDATA
{
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
} ITEMDATA;


typedef struct tagUSUBSET
{
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
} USUBSET;




//
//  Function Declarations.
//

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
INT_PTR APIENTRY CharMapDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT ChFromSymLParam(PSYCM, LONG);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcCharMap(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR);
VOID RestoreSymMag(PSYCM);
INT  APIENTRY FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, DWORD, LPARAM);
HANDLE GetEditText(HWND);
VOID CopyString(HWND);
VOID SendRTFToClip(HWND, LPTSTR);
INT PointsToHeight(INT);
VOID UpdateKeystrokeText(HDC hdc, BOOL fANSI, UTCHAR chNew, BOOL fRedraw);
VOID PaintStatusLine(HDC, BOOL, BOOL);
BOOL UpdateHelpText(LPMSG, HWND);
INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);
VOID SaveCurrentFont(HWND);
INT SelectInitialFont(HWND);
VOID ExitMagnify(HWND, PSYCM);
INT SelectInitialSubset(HWND);
VOID SaveCurrentSubset(HWND);
BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID UpdateSymbolSelection(HWND, INT, INT);
VOID UpdateSymbolRange(HWND hwnd, INT FirstChar, INT LastChar);
VOID SubSetChanged(HWND hwnd, INT iSubSet, INT ichFirst, INT ichLast);
VOID ProcessScrollMsg(HWND hwnd, int nCode, int nPos);
INT ScrollMapPage(HWND hwndDlg, BOOL fUp, BOOL fRePaint);
BOOL ScrollMap(HWND hwndDlg, INT cchScroll, BOOL fRePaint);
void SetEditCtlFont(HWND hwndDlg, int idCtl, HFONT hfont);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\spechars\charmap.c ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    charmap.c

Abstract:

    This module contains the main routines for the Charmap utility, an
    interface for selecting special characters.

Revision History:

--*/



//
//  Include Files.
//

#define WIN31
#include "windows.h"
#include <port1632.h>
#include "charmap.h"
#include "stdlib.h"
#include "tchar.h"
#ifdef UNICODE
  #include "wchar.h"
#else
  #include "stdio.h"
#endif
#include "commctrl.h"
#include <htmlhelp.h>



//
//  Macros.
//

#define FMagData(psycm)      ((psycm)->xpMagCurr != 0)
#define abs(x)               (((x) >= 0) ? (x) : (-(x)))




//
//  Constant Declarations.
//

#define STATUSPOINTSIZE      8              // point size of status bar font
#define FE_STATUSPOINTSIZE   10             // FE point size of status bar font
#define DX_BITMAP            20             // width of TT bitmap
#define DY_BITMAP            12             // height of TT bitmap
#define BACKGROUND           0x000000FF     // bright blue
#define BACKGROUNDSEL        0x00FF00FF     // bright purple
#define BUTTONFACE           0x00C0C0C0     // bright grey
#define BUTTONSHADOW         0x00808080     // dark grey
#define TOOLBARPOINTSIZE     21             // height of toolbar in points



// Font types
#define PS_OPENTYPE_FONT    0x0001
#define TT_OPENTYPE_FONT    0x0002
#define TRUETYPE_FONT       0x0004
#define TYPE1_FONT          0x0008

//
//  Debug Print Code.
//

#if 0
  TCHAR szDOUT[3] = TEXT("A\n");
  TCHAR szDbgBuf[256];
  #define DOUTL(p)     OutputDebugString(TEXT(p))
  #define DOUTCHN(ch)  if(0){}else {szDOUT[0] = ch; OutputDebugString(szDOUT);}
  #define DPRINT(p)    if(0){}else {wsprintf p; OutputDebugString(szDbgBuf);}
#else
  #define DOUTL(p)
  #define DOUTCHN(ch)
  #define DPRINT(p)
#endif




//
//  Global Variables.
//

HANDLE hInst;

INT cchSymRow = 32;               // number of characters across the character grid
INT cchSymCol = 8;                // number of rows in the character grid
UTCHAR chSymFirst   = 32;
UTCHAR chSymLast    = 255;
UTCHAR chRangeFirst = 32;
UTCHAR chRangeLast  = 255;
SYCM sycm;                        // tons of data need to do char grid painting
WORD wCFRichText = 0;             // private clipboard format, rich text format
HFONT hFontClipboard = NULL;      // tells us which font is in the clipboard
HANDLE hstrClipboard = NULL;      // contains the string which is in the clipboard
BOOL fDelClipboardFont = FALSE;   // the clipboard font needs to be deleted
INT iControl = ID_CHARGRID;       // index indicating which control has focus
HBITMAP hbmFont = NULL;           // TT bitmap drawn before font facenames in combo
LONG lEditSel = 0;                // contains the selection range of the EC
HBRUSH hStaticBrush;              // used for static controls during WM_CTLCOLOR

//
//  Currently there is no defined interface for querying what character
//  ranges a Unicode font supports.  For now, this table only has the subsets
//  that contain characters supported by the Lucida Sans Unicode font
//  uncommented.  When we get an API that allows querying the font driver for
//  ranges of Unicode characters supported (and whether or not a font is a
//  Unicode font!) then all entries can be uncommented.
//
USUBSET aSubsetData[] =
{
    { 0x0020, 0x00ff, IDS_WINDOWS },
    { 0x0020, 0x00ff, IDS_LATIN1 },
    { 0x0100, 0x017f, IDS_LATINEXA },
    { 0x0180, 0x024f, IDS_LATINEXB },
    { 0x0250, 0x02af, IDS_IPAEX },
    { 0x02b0, 0x02ff, IDS_SPACINGMODIFIERS },
    { 0x0300, 0x036f, IDS_COMBININGDIACRITICS },
    { 0x0370, 0x03cf, IDS_BASICGREEK },
    { 0x03d0, 0x03ff, IDS_GREEKSYMBOLS },
    { 0x0400, 0x04ff, IDS_CYRILLIC },
    { 0x0530, 0x058f, IDS_ARMENIAN },
    { 0x0590, 0x05ff, IDS_HEBREW },
    { 0x0600, 0x0652, IDS_BASICARABIC },
    { 0x0653, 0x06ff, IDS_ARABICEX },
    { 0x0900, 0x097f, IDS_DEVANAGARI },
    { 0x0980, 0x09ff, IDS_BENGALI },
    { 0x0a00, 0x0a7f, IDS_GURMUKHI },
    { 0x0a80, 0x0aff, IDS_GUJARATI },
    { 0x0b00, 0x0b7f, IDS_ORIYA },
    { 0x0b80, 0x0bff, IDS_TAMIL },
    { 0x0c00, 0x0c7f, IDS_TELUGU },
    { 0x0c80, 0x0cff, IDS_KANNADA },
    { 0x0d00, 0x0d7f, IDS_MALAYALAM },
    { 0x0e00, 0x0e7f, IDS_THAI },
    { 0x0e80, 0x0eff, IDS_LAO },
    { 0x10d0, 0x10ff, IDS_BASICGEORGIAN },
    { 0x10a0, 0x10cf, IDS_GEORGIANEX },
    { 0x1100, 0x11ff, IDS_HANGULJAMO },
    { 0x1e00, 0x1eff, IDS_LATINEXADDITIONAL },
    { 0x1f00, 0x1fff, IDS_GREEKEX },
    { 0x2000, 0x206f, IDS_GENERALPUNCTUATION },
    { 0x2070, 0x209f, IDS_SUPERANDSUBSCRIPTS },
    { 0x20a0, 0x20cf, IDS_CURRENCYSYMBOLS },
    { 0x20d0, 0x20ff, IDS_COMBININGDIACRITICSFORSYMBOLS },
    { 0x2100, 0x214f, IDS_LETTERLIKESYMBOLS },
    { 0x2150, 0x218f, IDS_NUMBERFORMS },
    { 0x2190, 0x21ff, IDS_ARROWS },
    { 0x2200, 0x22ff, IDS_MATHEMATICALOPS },
    { 0x2300, 0x23ff, IDS_MISCTECHNICAL },
    { 0x2400, 0x243f, IDS_CONTROLPICTURES },
    { 0x2440, 0x245f, IDS_OPTICALCHAR },
    { 0x2460, 0x24ff, IDS_ENCLOSEDALPHANUM },
    { 0x2500, 0x257f, IDS_BOXDRAWING },
    { 0x2580, 0x259f, IDS_BLOCKELEMENTS },
    { 0x25a0, 0x25ff, IDS_GEOMETRICSHAPES },
    { 0x2600, 0x26ff, IDS_MISCDINGBATS },
    { 0x2700, 0x27bf, IDS_DINGBATS },
    { 0x3000, 0x303f, IDS_CJKSYMBOLSANDPUNC },
    { 0x3040, 0x309f, IDS_HIRAGANA },
    { 0x30a0, 0x30ff, IDS_KATAKANA },
    { 0x3100, 0x312f, IDS_BOPOMOFO },
    { 0x3130, 0x318f, IDS_HANGULCOMPATIBILITYJAMO },
    { 0x3190, 0x319f, IDS_CJKMISC },
    { 0x3200, 0x32ff, IDS_ENCLOSEDCJKLETTERSANDMONTHS },
    { 0x3300, 0x33ff, IDS_CJKCOMPATIBILITY },
    { 0x4e00, 0x9fff, IDS_CJKUNIFIEDIDEOGRAPHS },
    { 0xac00, 0xd7a3, IDS_HANGUL },
    { 0xe000, 0xf8ff, IDS_PRIVATEUSEAREA },
    { 0xf900, 0xfaff, IDS_CJKCOMPATIBILITYIDEOGRAPHS },
    { 0xfb00, 0xfb4f, IDS_ALPAHPRESENTATIONFORMS },
    { 0xfb50, 0xfdff, IDS_ARABICPRESENTATIONFORMSA },
    { 0xfe30, 0xfe4f, IDS_CJKCOMPFORMS },
    { 0xfe50, 0xfe6f, IDS_SMALLFORMVARIANTS },
    { 0xfe70, 0xfefe, IDS_ARABICPRESENTATIONFORMSB },
    { 0xff00, 0xffef, IDS_HALFANDFULLWIDTHFORMS },
    { 0xfff0, 0xfffd, IDS_SPECIALS }
};
INT cSubsets = sizeof(aSubsetData) / sizeof(USUBSET);
INT iCurSubset = 0;     // index of current Unicode subset - default to Latin-1

//
//  Useful window handles.
//
HWND hwndDialog;
HWND hwndCharGrid;

//
//  Data used to draw the status bar.
//
RECT rcStatusLine;                // bounding rect for status bar
RECT rcToolbar[2];                // bounding rects for toolbars
INT dyStatus;                     // height of status bar
INT dyToolbar[2];                 // height of tool bars
INT dxHelpField;                  // width of help window
INT dxKeystrokeField;             // width of keystroke window
TCHAR szKeystrokeText[MAX_PATH];  // buffer for keystroke text
TCHAR szKeystrokeLabel[30];       // buffer for keystroke label
TCHAR szSpace[15];                // strings for keystroke description
TCHAR szCtrl[15];
TCHAR szCtrlAlt[25];
TCHAR szShiftCtrlAlt[25];
TCHAR szAlt[15];
TCHAR szUnicodeLabel[23];         // buffer for Unicode label
INT iKeystrokeTextStart;          // place to start appending text to above
INT iUnicodeLabelStart;           // place to start appending text to above
HFONT hfontStatus;                // font used for text of status bar





////////////////////////////////////////////////////////////////////////////
//
//  WinMain
//
//  Calls initialization function, processes message loop, cleanup.
//
////////////////////////////////////////////////////////////////////////////

INT WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
    {
        return (FALSE);
    }

    //
    //  Perform initialization for this instance.
    //
    if (!InitInstance(hInstance, nCmdShow))
    {
        return (FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        //  Filter for possible tabs now to implement context sensitive help.
        //
        if (msg.message == WM_KEYDOWN)
        {
            if (!UpdateHelpText(&msg, NULL))
            {
                continue;
            }
        }

        //
        //  Main message loop.
        //
        if (!IsDialogMessage(hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    //
    //  Free up some stuff.
    //
    if (hfontStatus)
    {
        DeleteObject(hfontStatus);
    }
    if (hbmFont)
    {
        DeleteObject(hbmFont);
    }

    return (msg.wParam);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitApplication
//
//  Initializes window data and registers window class.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitApplication(
    HANDLE hInstance)
{
    WNDCLASS wc;

    //
    //  Register a window class that we will use to draw the character
    //  grid into.
    //
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_CHARMAP));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitInstance
//
//  Does some initialization and creates main window which is a dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitInstance(
    HANDLE hInstance,
    INT nCmdShow)
{
    INT i;
    CHARSETINFO csi;
    DWORD dw = GetACP();
    LANGID PrimaryLangId = (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())));
    BOOL bFE = ((PrimaryLangId == LANG_JAPANESE) ||
                (PrimaryLangId == LANG_KOREAN)   ||
                (PrimaryLangId == LANG_CHINESE));

    //
    //  Save the instance handle in a global variable.
    //
    hInst = hInstance;

    //
    //  This font will be used to paint the status line.
    //
    if (!TranslateCharsetInfo((DWORD*)dw, &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }
    hfontStatus = CreateFont( -PointsToHeight(bFE
                                                ? FE_STATUSPOINTSIZE
                                                : STATUSPOINTSIZE),
                              0, 0, 0, 400, 0, 0, 0,
                              csi.ciCharset,
                              OUT_DEFAULT_PRECIS,
                              CLIP_DEFAULT_PRECIS,
                              DEFAULT_QUALITY,
                              VARIABLE_PITCH,
                              TEXT("MS Shell Dlg") );

    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);
    dyToolbar[0] = PointsToHeight(TOOLBARPOINTSIZE);
    dyToolbar[1] = PointsToHeight(TOOLBARPOINTSIZE);

    //
    //  Load the Unicode subset names before initializing the main window.
    //
    for (i = 0; i < cSubsets; i++)
    {
        if (!LoadString( hInst,
                         aSubsetData[i].StringResId,
                         (LPTSTR)aSubsetData[i].Name,
                         LF_SUBSETSIZE))
        {
            return (FALSE);
        }
    }

    //
    //  Create a main window for this application instance.
    //
    if (!(hwndDialog = CreateDialog( hInstance,
                                     TEXT("CharMap"),
                                     NULL,
                                     CharMapDlgProc )))
    {
        return (FALSE);
    }

    //
    //  Initialize some strings used for the Keystroke status bar field.
    //  For international purposes, this string could be length 0.
    //
    LoadString( hInst,
                IDS_KEYSTROKE,
                (LPTSTR)szKeystrokeLabel,
                BTOC(sizeof(szKeystrokeLabel)) );
    if (!LoadString( hInst,
                     IDS_UNICODELABEL,
                     (LPTSTR)szUnicodeLabel,
                     BTOC(sizeof(szUnicodeLabel)) ))
    {
        if (!LoadString( hInst,
                         IDS_SPACE,
                         (LPTSTR)szSpace,
                         BTOC(sizeof(szSpace)) ))
        {
            return (FALSE);
        }
    }
    if (!LoadString( hInst,
                     IDS_CTRL,
                     (LPTSTR)szCtrl,
                     BTOC(sizeof(szCtrl)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_CTRLALT,
                     (LPTSTR)szCtrlAlt,
                     BTOC(sizeof(szCtrlAlt)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_SHIFTCTRLALT,
                     (LPTSTR)szShiftCtrlAlt,
                     BTOC(sizeof(szShiftCtrlAlt)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_ALT,
                     (LPTSTR)szAlt,
                     BTOC(sizeof(szAlt)) ))
    {
        return (FALSE);
    }

    //
    //  Store the index to where we start adding status line text changes.
    //
    iKeystrokeTextStart = lstrlen(szKeystrokeLabel);
    iUnicodeLabelStart = lstrlen(szUnicodeLabel);

    //
    //  Initialize keystroke text, make the window visible,
    //  update its client area, and return "success".
    //
    UpdateKeystrokeText(NULL, sycm.fAnsiFont, sycm.chCurr, FALSE);
    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertANSIFontToUnicode
//
////////////////////////////////////////////////////////////////////////////

WCHAR ConvertANSIFontToUnicode(
    HWND hwnd,
    HFONT hFont,
    CHAR ch)
{
    WORD cp = CP_ACP;
    WCHAR wch;
    HDC hdc;

    hdc = GetDC(hwnd);
    if (hdc != NULL)
    {
        HFONT hfOld;
        TEXTMETRIC tm;
        CHARSETINFO csi;
        DWORD cs;

        hfOld = SelectObject(hdc, hFont);

        if (GetTextMetrics(hdc, &tm))
        {
            cs = MAKELONG(tm.tmCharSet, 0);

            if (TranslateCharsetInfo((DWORD *)cs, &csi, TCI_SRCCHARSET))
            {
                cp = csi.ciACP;
            }
            else
            {
                DPRINT(( szDbgBuf,
                         TEXT("CvtAtoW: TranslateCharsetInfo(cset=%d) returned 0! (GetLastErr=%d), using CP_ACP\n"),
                         cs,
                         GetLastError() ));
            }
        }
        SelectObject(hdc, hfOld);
        ReleaseDC(hwnd, hdc);
    }

    if (MultiByteToWideChar(cp, 0, &ch, 1, &wch, 1) != 1)
    {
        if (MultiByteToWideChar(CP_ACP, 0, &ch, 1, &wch, 1) != 1)
        {
            wch = (WCHAR)(BYTE)ch;
        }
    }

    DPRINT(( szDbgBuf,
             TEXT("CvtAtoW: 0x%02x '%c' (CP:%d) -> U'%04X'\n"),
             (DWORD)(BYTE)ch,
             ch,
             cp,
             (DWORD)wch ));

    return (wch);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumChildProc
//
//  Gets called during init for each child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    LONG st;
    TCHAR szClass[MAX_PATH];

    //
    //  Get control class.
    //
    GetClassName(hwnd, szClass, MAX_PATH);
    if (lstrcmpi(szClass, TEXT("button")) == 0 )
    {
        //
        //  If it is a button, set the ex style to NOTIFYPARENT.
        //
        st = GetWindowLong(hwnd, GWL_EXSTYLE);
        st = st & ~WS_EX_NOPARENTNOTIFY;
        SetWindowLong(hwnd, GWL_EXSTYLE, st);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CharMapDlgProc
//
//  Processes messages for the main window.  This window is a dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY CharMapDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_CTLCOLORSTATIC ) :
        {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return ((INT_PTR)hStaticBrush);
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            RECT rectParent, rectTopRightControl, rect;
            POINT pt;
            INT iSubset;
            HWND hwndCMSB;

            //
            //  Set buttons to send WM_PARENTNOTIFY.
            //
            EnumChildWindows(hWnd, EnumChildProc, (LPARAM)NULL );

            //
            //  Create the character grid with dimensions which just fit
            //  inside the space allowed in the dialog.  When it processes
            //  the WM_CREATE message it will be sized and centered more
            //  accurately.
            //
            GetClientRect(hWnd, &rectParent);
            GetWindowRect(GetDlgItem(hWnd, ID_CLOSE), &rectTopRightControl);
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.right));

            if (!(hwndCharGrid =
                  CreateWindow( TEXT("CharGridWClass"),
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                                1,
                                rectParent.top + dyToolbar[0] + dyToolbar[1],
                                rectParent.right - 1,
                                rectParent.bottom - rectParent.top -
                                  dyStatus - dyToolbar[0] - dyToolbar[1] - 1,
                                hWnd,
                                (HMENU)ID_CHARGRID,
                                hInst,
                                NULL )))
            {
                DestroyWindow(hWnd);
                break;
            }

            GetWindowRect(hwndCharGrid, &rect);
            pt.x = rect.right;
            pt.y = rect.top;

            ScreenToClient(hWnd, &pt);

            hwndCMSB = CreateWindowEx( 0L,
                                       TEXT("SCROLLBAR"),
                                       NULL,
                                       WS_CHILD | SBS_VERT | WS_VISIBLE |
                                         WS_TABSTOP,
                                       pt.x + 1,
                                       pt.y + 1,
                                       sycm.dxpBox,
                                       sycm.dypCM,
                                       hWnd,
                                       (HMENU)ID_MAPSCROLL,
                                       hInst,
                                       NULL );

            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            //
            //  Initialize the status line data.
            //
            dxHelpField = 21 * rectParent.right / 32;
            dxKeystrokeField = 9 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            //
            //  Initialize the toolbars.
            //
            rcToolbar[0] = rectParent;
            rcToolbar[0].bottom = rcToolbar[0].top + dyToolbar[0];

            rcToolbar[1] = rcToolbar[0];
            rcToolbar[1].top = rcToolbar[0].bottom + GetSystemMetrics(SM_CYBORDER);
            rcToolbar[1].bottom = rcToolbar[1].top + dyToolbar[1];

            //
            //  Disable Copy button.
            //
            EnableWindow(GetDlgItem(hWnd, ID_COPY), FALSE);

            //
            //  Fill "Subset" list box.
            //
            for (iSubset = 0; iSubset < cSubsets; iSubset++)
            {
                SendDlgItemMessage( hWnd,
                                    ID_UNICODESUBSET,
                                    CB_ADDSTRING,
                                    0,
                                    (DWORD)aSubsetData[iSubset].Name );
            }
            iCurSubset = SelectInitialSubset(hWnd);

            //
            //  Fall through to WM_FONTCHANGE...
            //
        }
        case ( WM_FONTCHANGE ) :
        {
            HDC hdc = GetDC(hWnd);

            //
            //  Get the fonts from the system and put them in the font
            //  selection combo box.
            //
            if (message == WM_FONTCHANGE)
            {
                SaveCurrentFont(hWnd);
                SendDlgItemMessage(hWnd, ID_FONT, CB_RESETCONTENT, 0, 0L);
            }

            EnumFontFamilies(hdc, NULL, (FONTENUMPROC)FontLoadProc, (LPARAM)hWnd);

            ReleaseDC(hWnd, hdc);

            //
            //  Setup character dimensions and select this font.
            //
            RecalcCharMap( hWnd,
                           &sycm,
                           SelectInitialFont(hWnd),
                           (message == WM_FONTCHANGE) );
            SetEditCtlFont(hWnd, ID_STRING, sycm.hFont);

            if (message == WM_INITDIALOG)
            {
                SetFocus(hwndCharGrid);

                //
                //  Fall through to WM_SYSCOLORCHANGE...
                //
            }
            else
            {
                break;
            }
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            if (hbmFont)
            {
                DeleteObject(hbmFont);
            }
            hbmFont = LoadBitmaps(IDBM_TT);
            DeleteObject(hStaticBrush);
            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;
        }
        case ( WM_PARENTNOTIFY ) :
        {
            POINTS points;
            DWORD dwMsgPos;
            POINT point;

            DPRINT(( szDbgBuf,
                     TEXT("WM_PARENTNOTIFY: lParam:0x%08lX, wParam:0x%08lX\n"),
                     (DWORD)lParam,
                     (DWORD)wParam ));

            //
            //  We process this message to implement the context sensitive
            //  help.  Downclicks to controls are found here, the help
            //  message is updated in the status bar.
            //
            //  The parameters with this message are unreliable!
            //
            if (LOWORD(wParam) == WM_LBUTTONDOWN)
            {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
                UpdateHelpText(NULL, WindowFromPoint(point));
            }

            break;
        }
        case ( WM_VSCROLL ) :
        {
            ProcessScrollMsg(hWnd, LOWORD(wParam), HIWORD(wParam));
            break;
        }
        case ( WM_PAINT ) :
        {
            HBRUSH hBrush;
            RECT rcTemp, rectNextButton;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            //
            //  This code implements painting of the status bar.
            //
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            //
            //  Make the whole thing grey.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)))
            {
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp.left = rcToolbar[0].left;
                rcTemp.top = rcToolbar[0].top;
                rcTemp.right = rcToolbar[1].right;
                rcTemp.bottom = rcToolbar[1].bottom;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            GetWindowRect(GetDlgItem(hWnd, ID_TOPLEFT), &rectNextButton);
            ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.right));
            //
            //  Solid black line across bottom of toolbar.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)))
            {
#ifdef USE_MIRRORING
                DWORD dwLayout;
                GetProcessDefaultLayout(&dwLayout);
                if(dwLayout & LAYOUT_RTL)
                { 
                    //
                    // Interchange the right and left values.
                    //
                    int tmp = rectNextButton.left;
                    rectNextButton.left = rectNextButton.right;
                    rectNextButton.right = tmp;
                }
#endif
                rcTemp = rcToolbar[0];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp = rcToolbar[1];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Vertical line.
                //
                rcTemp.top = rcToolbar[0].top;
                rcTemp.bottom = rcToolbar[1].bottom;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                rcTemp.right = rectNextButton.left - 2;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)))
            {
                //
                //  Status line top.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line top.
                //
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line left side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line left side.
                //
                rcTemp.left = rcStatusLine.right - 9 * dyBorder - dxKeystrokeField;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)))
            {
                //
                //  Status line bottom.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line bottom.
                //
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line right side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder + dxHelpField;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line right side.
                //
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            //
            //  Solid black line across top.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)))
            {
                rcTemp = rcStatusLine;
                rcTemp.bottom = rcTemp.top;
                rcTemp.top -= dyBorder;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);

            return (TRUE);
        }
        case ( WM_MEASUREITEM ) :
        {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = max(tm.tmHeight, DY_BITMAP);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
            {
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);
            }
            break;
        }
        case ( WM_ASKCBFORMATNAME ) :
        {
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, wParam);
            return (TRUE);
        }
        case ( WM_PAINTCLIPBOARD ) :
        {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard)
            {
                //
                //  Setup.
                //
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                //
                //  Paint.
                //
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText, lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                //
                //  Cleanup.
                //
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }
            return (TRUE);
        }
        case ( WM_CLOSE ) :
        {
            DestroyWindow(hWnd);
            return (TRUE);
        }
        case ( WM_COMMAND ) :
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDCANCEL ) :
                case ( ID_CLOSE ) :
                {
                    DestroyWindow(hWnd);
                    return (TRUE);
                    break;
                }
                case ( ID_SELECT ) :
                {
                    WCHAR wch = sycm.chCurr;

                    if (sycm.fAnsiFont)
                    {
                        wch = ConvertANSIFontToUnicode( hWnd,
                                                        sycm.hFont,
                                                        (char)wch );
                    }

                    SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR, (WPARAM)wch, 0L);
                    break;
                }
                case ( ID_COPY ) :
                {
                    CopyString(hWnd);
                    return (TRUE);
                    break;
                }
                case ( ID_FONT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        RecalcCharMap( hWnd,
                                       &sycm,
                                       (INT)SendDlgItemMessage( hWnd,
                                                                ID_FONT,
                                                                CB_GETCURSEL,
                                                                0,
                                                                0L ),
                                       TRUE );
                        SetEditCtlFont(hWnd, ID_STRING, sycm.hFont);
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                    break;
                }
                case ( ID_UNICODESUBSET ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        INT iSubset;
                        INT cEntries;

                        iSubset = (INT)SendDlgItemMessage( hWnd,
                                                           ID_UNICODESUBSET,
                                                           CB_GETCURSEL,
                                                           0,
                                                           0 );
                        SubSetChanged( hWnd,
                                       iSubset,
                                       aSubsetData[iSubset].BeginRange,
                                       aSubsetData[iSubset].EndRange );

                        cEntries = (INT)SendDlgItemMessage( hWnd,
                                                            ID_UNICODESUBSET,
                                                            CB_GETCOUNT,
                                                            0,
                                                            0 ) - 1;

                        EnableWindow( GetDlgItem(hWnd, ID_PREVSUBSET),
                                      iSubset > 0 );

                        EnableWindow( GetDlgItem(hWnd, ID_NEXTSUBSET),
                                      iSubset < cEntries );
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    return (0L);
                    break;
                }
                case ( ID_NEXTSUBSET ) :
                {
                    INT iCurSelection, iNumEntries;

                    iCurSelection = (INT)SendDlgItemMessage( hWnd,
                                                             ID_UNICODESUBSET,
                                                             CB_GETCURSEL,
                                                             0,
                                                             0 );
                    if (iCurSelection == CB_ERR)
                    {
                         return (0L);
                    }
                    iNumEntries = (INT)SendDlgItemMessage( hWnd,
                                                           ID_UNICODESUBSET,
                                                           CB_GETCOUNT,
                                                           0,
                                                           0 );
                    if (iNumEntries == CB_ERR)
                    {
                         return (0L);
                    }
                    if (iCurSelection++ < (iNumEntries - 1))
                    {
                        if (iCurSelection == 1)
                        {
                            //
                            //  Enable Previous button.
                            //
                            EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), TRUE);
                        }

                        SendDlgItemMessage( hWnd,
                                            ID_UNICODESUBSET,
                                            CB_SETCURSEL,
                                            iCurSelection,
                                            0 );
                        SubSetChanged( hWnd,
                                       iCurSelection,
                                       aSubsetData[iCurSelection].BeginRange,
                                       aSubsetData[iCurSelection].EndRange );
                        if (iCurSelection == (iNumEntries - 1))
                        {
                            HWND hwndButton;

                            EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), FALSE);
                            //
                            //  Only reset the button style and focus if
                            //  the "Next" button currently has it.
                            //
                            if (iControl == ID_NEXTSUBSET)
                            {
                                SendDlgItemMessage( hwndDialog,
                                                    ID_PREVSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_DEFPUSHBUTTON,
                                                    1 );
                                SendDlgItemMessage( hwndDialog,
                                                    ID_NEXTSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_PUSHBUTTON,
                                                    1 );
                                hwndButton = GetDlgItem(hWnd, ID_PREVSUBSET);
                                SetFocus(hwndButton);
                                UpdateHelpText(NULL, hwndButton);
                            }
                        }
                    }
                    return (0L);
                    break;
                }
                case ( ID_PREVSUBSET ) :
                {
                    INT iCurSelection;

                    iCurSelection = (INT)SendDlgItemMessage( hWnd,
                                                             ID_UNICODESUBSET,
                                                             CB_GETCURSEL,
                                                             0,
                                                             0 );
                    if (iCurSelection == CB_ERR)
                    {
                         return (0L);
                    }
                    if (iCurSelection > 0)
                    {
                        iCurSelection--;

                        if (iCurSelection == (cSubsets - 2))
                        {
                            //
                            //  Enable Next button.
                            //
                            EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), TRUE);
                        }

                        SendDlgItemMessage( hWnd,
                                            ID_UNICODESUBSET,
                                            CB_SETCURSEL,
                                            iCurSelection,
                                            0 );
                        SubSetChanged( hWnd,
                                       iCurSelection,
                                       aSubsetData[iCurSelection].BeginRange,
                                       aSubsetData[iCurSelection].EndRange );
                        if (iCurSelection == 0)
                        {
                            HWND hwndButton;

                            EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), FALSE);
                            //
                            //  Only reset the button style and focus if
                            //  the "Previous" button currently has it.
                            //
                            if (iControl == ID_PREVSUBSET)
                            {
                                SendDlgItemMessage( hwndDialog,
                                                    ID_NEXTSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_DEFPUSHBUTTON,
                                                    1 );
                                SendDlgItemMessage( hwndDialog,
                                                    ID_PREVSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_PUSHBUTTON,
                                                    1 );
                                hwndButton = GetDlgItem(hWnd, ID_NEXTSUBSET);
                                SetFocus(hwndButton);
                                UpdateHelpText(NULL, hwndButton);
                            }
                        }
                    }
                    return (0L);
                    break;
                }
                case ( ID_STRING ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }

                    break;
                }
                case ( ID_HELP ) :
                {
                    DoHelp(hWnd, TRUE);
                    break;
                }
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            SaveCurrentFont(hWnd);
            SaveCurrentSubset(hWnd);
            DoHelp(hWnd, FALSE);
            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;
        }
        case ( WM_ACTIVATEAPP ) :
        {
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    ID_STRING,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
            break;
        }
    }

    return (0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CharGridWndProc
//
//  Processes messages for the character grid window.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_CREATE ) :
        {
            RECT rect;
            HDC hdcScrn;
            POINT point1, point2;

            //
            //  Setup global.
            //
            hwndCharGrid = hWnd;

            GetClientRect(hWnd, &rect);

            //
            //  Calculate metrics for the character grid and the
            //  magnify window.
            //
            sycm.dxpBox = (rect.right - 1)  / (cchSymRow + 2);
            sycm.dypBox = (rect.bottom - 2) / (cchSymCol + 1);
            sycm.dxpCM  = sycm.dxpBox * cchSymRow + 1;
            sycm.dypCM  = sycm.dypBox * cchSymCol + 1;  // space inside for border

            if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE))
            {
                sycm.dxpMag = sycm.dxpBox * 3 + 5;
            }
            else
            {
                sycm.dxpMag = sycm.dxpBox * 2 + 4;    // twice the size + 2 bit border
            }
            sycm.dypMag = sycm.dypBox * 2 + 4;

            sycm.chCurr   = chSymFirst;
            sycm.hFontMag = NULL;
            sycm.hFont    = NULL;
            sycm.hdcMag   = NULL;
            sycm.hbmMag   = NULL;
            sycm.ypDest   = 0;

            sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;

            //
            //  Size the window precisely so the grid fits and is centered.
            //
            MoveWindow( hWnd,
                        (rect.right - sycm.dxpCM + 1) / 2,
                        (rect.bottom - sycm.dypCM + 1) / 2 +
                          ((LPCREATESTRUCT)lParam)->y - 2,
                        sycm.dxpCM + 2,
                        sycm.dypCM + 2,
                        FALSE );

            //
            //  Figure out what the offsets are between the dialog
            //  and the character grid window.
            //
            point1.x = point1.y = point2.x = point2.y = 0;
            ClientToScreen(hWnd, &point1);
            ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
#ifdef USE_MIRRORING
            sycm.xpCM = (abs(point1.x - point2.x)) - (sycm.dxpMag - sycm.dxpBox) / 2;
#else
            sycm.xpCM = (point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
#endif
            sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;

            //
            //  Create dc and bitmap for the magnify window.
            //
            if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
            {
                if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                {
                    SetTextColor( sycm.hdcMag,
                                  GetSysColor(COLOR_WINDOWTEXT) );
                    SetBkColor( sycm.hdcMag,
                                GetSysColor(COLOR_WINDOW) );
                    SetBkMode(sycm.hdcMag, OPAQUE);
                    if ((sycm.hbmMag =
                         CreateCompatibleBitmap( hdcScrn,
                                                 sycm.dxpMag,
                                                 sycm.dypMag * 2 )) == NULL)
                    {
                        DeleteObject(sycm.hdcMag);
                    }
                    else
                    {
                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                    }
                }
                ReleaseDC(hWnd, hdcScrn);
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            if (fDelClipboardFont)
            {
                DeleteObject(hFontClipboard);
            }
            if (sycm.hFont != NULL)
            {
                DeleteObject(sycm.hFont);
            }
            if (sycm.hFontMag != NULL)
            {
                DeleteObject(sycm.hFontMag);
            }
            if (sycm.hdcMag != NULL)
            {
                DeleteDC(sycm.hdcMag);
            }
            if (sycm.hbmMag != NULL)
            {
                DeleteObject(sycm.hbmMag);
            }
            break;
        }
        case ( WM_SETFOCUS ) :
        case ( WM_KILLFOCUS ) :
        {
            RestoreSymMag(&sycm);
            DrawSymChOutlineHwnd( &sycm,
                                  hWnd,
                                  sycm.chCurr,
                                  TRUE,
                                  message == WM_SETFOCUS );
            break;
        }
        case ( WM_LBUTTONDOWN ) :
        {
            RECT rect;

            DOUTL("WM_LBUTTONDOWN: In\n");

            //
            //  Don't draw anything if there's an update region pending.
            //
            if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
            {
                DOUTL("WM_LBUTTONDOWN: No upd rect\n");
                break;
            }

            SetFocus(hWnd);
            SetCapture(hWnd);

            sycm.fMouseDn = TRUE;

            if (!FMagData(&sycm))
            {
                DOUTL("WM_LBUTTONDOWN: Drawing sym outline\n");
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
            }

            //
            //  Fall through to WM_MOUSEMOVE...
            //
        }
        case ( WM_MOUSEMOVE ) :
        {
            DOUTL("WM_MOUSEMOVE: In\n");
            if (sycm.fMouseDn)
            {
                POINT pt;
                UINT chMouseSymbol;

                DOUTL("WM_MOUSEMOVE: mouse is down\n");

                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);
                ClientToScreen(hWnd, (LPPOINT)&pt);
                if (WindowFromPoint(pt) == hWnd)
                {
                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    //
                    //  Convert back to a 'points'-like thing.
                    //
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);
                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);
                    if (chMouseSymbol > (UINT)chSymLast)
                    {
                        //
                        //  We're outside of current character range (but
                        //  still within the grid).  Restore cursor and
                        //  leave magnified character.
                        //
                        if (sycm.fCursorOff)
                        {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    }
                    else
                    {
                        //
                        //  We're in the grid and within the range of currently
                        //  displayed characters, display magnified character.
                        //
                        DOUTL("WM_MOUSEMOVE: in grid and subrange\n");

                        if (!sycm.fCursorOff)
                        {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        DOUTL("WM_MOUSEMOVE: movsymsel ");
                        DOUTCHN( (UTCHAR)chMouseSymbol );
                        MoveSymbolSel(&sycm, (UTCHAR)chMouseSymbol);
                    }
                }
                else
                {
                    //
                    //  Left grid, leave magnified character and restore
                    //  cursor.
                    //
                    if (sycm.fCursorOff)
                    {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }
                }
            }
            DOUTL("WM_MOUSEMOVE: Leaving\n");
            break;
        }
        case ( WM_CANCELMODE ) :
        case ( WM_LBUTTONUP ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            break;
        }
        case ( WM_LBUTTONDBLCLK ) :
        {
            WCHAR wch = sycm.chCurr;

            //
            //  Send this character to the entry field.
            //
            if (sycm.fAnsiFont)
            {
                wch = ConvertANSIFontToUnicode(hWnd, sycm.hFont, (char)wch);
            }

            SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, (WPARAM)wch, 0L);
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            //
            //  Necessary to obtain arrow and tab messages.
            //
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            UTCHAR chNew = sycm.chCurr;
            INT cchMoved;

            if (sycm.fMouseDn)
            {
                break;
            }

            switch (wParam)
            {
                case ( VK_LEFT ) :
                {
                    if (--chNew < chSymFirst)
                    {
                        return (0L);
                    }
                    break;
                }
                case ( VK_UP ) :
                {
                    if ((chNew -= cchSymRow) < chSymFirst)
                    {
                        if (!ScrollMap(GetParent(hWnd), -cchSymRow, TRUE))
                        {
                            return (0L);
                        }
                        RestoreSymMag(&sycm);
                    }
                    break;
                }
                case ( VK_RIGHT ) :
                {
                    if (++chNew > chSymLast)
                    {
                        return (0L);
                    }
                    break;
                }
                case ( VK_DOWN ) :
                {
                    if ((chNew += cchSymRow) > chSymLast)
                    {
                        if (!ScrollMap(GetParent(hWnd), cchSymRow, TRUE))
                        {
                            return (0L);
                        }
                        RestoreSymMag(&sycm);
                    }
                    break;
                }
                case ( VK_NEXT ) :
                {
                    if ((cchMoved =
                         ScrollMapPage(GetParent(hWnd), FALSE, TRUE)) == 0)
                    {
                        return (0L);
                    }
                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(&sycm);
                    chNew += cchMoved;
                    break;
                }
                case ( VK_PRIOR ) :
                {
                    if ((cchMoved =
                        ScrollMapPage( GetParent(hWnd), TRUE, TRUE )) == 0)
                    {
                        return (0L);
                    }

                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(&sycm);
                    chNew += cchMoved;
                    break;
                }
                default :
                {
                   return (0L);
                }
            }

            if (!FMagData(&sycm))
            {
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
            }
            MoveSymbolSel(&sycm, (UTCHAR)chNew);
            break;
        }
        case ( WM_CHAR ) :
        {
            WCHAR wch = (WCHAR)wParam;
            char ch;

            if (sycm.fMouseDn)
            {
                break;
            }
            if (sycm.fAnsiFont)
            {
                if (WideCharToMultiByte( CP_ACP,
                                         0,
                                         &wch,
                                         1,
                                         &ch,
                                         1,
                                         NULL,
                                         NULL ) != 1)
                {
                    break;
                }
                wch = (WCHAR)(BYTE)ch;
            }

            if ((wch >= chSymFirst) && (wch <= chSymLast))
            {
                if (!FMagData(&sycm))
                {
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                }
                MoveSymbolSel(&sycm, (UTCHAR)wch);
                SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, wParam, 0L);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            HDC hdc;
            PAINTSTRUCT ps;

            DOUTL("WM_PAINT: In\n");

            hdc = BeginPaint(hWnd, &ps);
            DOUTL("WM_PAINT: drawing map\n");
            DrawSymbolMap(&sycm, hdc);
            EndPaint(hWnd, &ps);

            DOUTL("WM_PAINT: Leaving\n");
            return (TRUE);
        }
        default :
        {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
    }

    return (0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  ProcessScrollMsg
//
////////////////////////////////////////////////////////////////////////////

VOID ProcessScrollMsg(
    HWND hwndDlg,
    int nCode,
    int nPos)
{
    UTCHAR chNew = sycm.chCurr;
    HWND hwndGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    int cchScroll;

    switch( nCode )
    {
        case ( SB_LINEUP ) :
        {
            cchScroll = -cchSymRow;
            break;
        }
        case ( SB_LINEDOWN ) :
        {
            cchScroll = cchSymRow;
            break;
        }
        case ( SB_PAGEUP ) :
        {
            cchScroll = (int)TRUE;
            break;
        }
        case ( SB_PAGEDOWN ) :
        {
            cchScroll = (int)FALSE;
            break;
        }
        case ( SB_THUMBTRACK ) :
        case ( SB_THUMBPOSITION ) :
        {
            cchScroll = (nPos * cchSymRow + chRangeFirst) - chSymFirst;
            break;
        }
        default :
        {
            return;
        }
    }

    if (nCode == SB_PAGEUP || nCode == SB_PAGEDOWN)
    {
        if (!ScrollMapPage(hwndDlg, (BOOL)cchScroll, FALSE))
        {
            return;
        }

        //
        //  ScrollMapPage will do the right thing to sycm.chCurr.
        //
        chNew = sycm.chCurr;
    }
    else
    {
        if (cchScroll == 0 || !ScrollMap(hwndDlg, cchScroll, FALSE))
        {
            return;
        }

        //
        //  Keep the current symbol inside the window.
        //
        while (chNew > chSymLast)
        {
            chNew -= cchSymRow;
        }

        while (chNew < chSymFirst)
        {
            chNew += cchSymRow;
        }
    }

#if 0
    if (!FMagData(&sycm))
    {
        DrawSymChOutlineHwnd(&sycm, hwndGrid, sycm.chCurr, FALSE, FALSE);
    }
    MoveSymbolSel(&sycm, (UTCHAR)chNew);
#else
    sycm.chCurr = chNew;
    InvalidateRect(hwndGrid, NULL, TRUE);
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMapPage
//
//  Scrolls the map up or down by a page.  See ScrollMap().
//
////////////////////////////////////////////////////////////////////////////

INT ScrollMapPage(
    HWND hwndDlg,
    BOOL fUp,
    BOOL fRePaint)
{
    INT cchScroll = cchFullMap;

    if (fUp)
    {
        cchScroll = -cchScroll;
    }

    if ((chSymFirst + cchScroll) < chRangeFirst)
    {
        cchScroll = (chRangeFirst - chSymFirst);
    }
    else if ((chSymLast + cchScroll) > chRangeLast)
    {
        cchScroll = (chRangeLast - chSymLast);
    }

    return (ScrollMap(hwndDlg, cchScroll, fRePaint) ? cchScroll : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMap
//
//  Scrolls the map up or down if there are too many chars to fit in the
//  chargrid.
//
////////////////////////////////////////////////////////////////////////////

BOOL ScrollMap(
    HWND hwndDlg,
    INT cchScroll,
    BOOL fRePaint)
{
    HWND hwndSB, hwndCharGrid;
    INT chFirst = chSymFirst + cchScroll;
    INT chLast = chSymLast + cchScroll;
    HDC hdc;

    if ((chFirst < chRangeFirst) || (chLast > chRangeLast))
    {
        return (FALSE);
    }

    hwndCharGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    hwndSB = GetDlgItem(hwndDlg, ID_MAPSCROLL);
    SetScrollPos(hwndSB, SB_CTL, (chFirst - chRangeFirst) / cchSymRow, TRUE);

    UpdateSymbolRange(hwndDlg, chFirst, chLast);

    if ((hwndDlg != NULL) && ((hdc = GetDC(hwndDlg)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (sycm.fAnsiFont)
        {
            GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
        }
        else
        {
            GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2 - 1;
        }
        ReleaseDC(hwndDlg, hdc);
    }

    if (fRePaint)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChFromSymLParam
//
//  Determines the character to select from the mouse position (lParam).
//
////////////////////////////////////////////////////////////////////////////

INT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
    return (min( cchSymRow - 1,
                 max(0, ((INT)LOWORD(lParam) - 1) / psycm->dxpBox) ) +
            min( cchSymCol - 1,
                 max(0, ((INT)HIWORD(lParam) - 1) / psycm->dypBox) ) *
            cchSymRow + chSymFirst);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutlineHwnd
//
//  Gets a DC for hwnd, calls DrawSymChOutline.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutlineHwnd(
    PSYCM psycm,
    HWND hwnd,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HDC hdc = GetDC(hwnd);

    DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
    ReleaseDC(hwnd, hdc);
}


////////////////////////////////////////////////////////////////////////////
//
//  RecalcCharMap
//
//  Recalculates fixed character map data (font info, sizes, etc.).
//
////////////////////////////////////////////////////////////////////////////

VOID RecalcCharMap(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
    HDC hdc;
    TEXTMETRIC tm;
    UINT ch;
    LPINT lpdxp;
    HFONT hFont;
    LOGFONT LogFont;
    ITEMDATA ItemData;
    LONG iCurSel;

    //
    //  Get rid of the old font handles.
    //
    if (hFontClipboard && (hFontClipboard == psycm->hFont))
    {
        fDelClipboardFont = TRUE;
    }
    if (psycm->hFont && (hFontClipboard != psycm->hFont))
    {
        DeleteObject(psycm->hFont);
    }
    if (psycm->hFontMag)
    {
        DeleteObject(psycm->hFontMag);
    }

    hdc = GetDC(hwndCharGrid);

    //
    //  Set up the LogFont structure.
    //  Make sure it fits in the grid.
    //
    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        LogFont.lfHeight = 16;
    }
    else
    {
        LogFont.lfHeight = psycm->dypBox - 3;    // Allow for whitespace.
    }
    //
    //  Set these to zero.
    //
    LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                      LogFont.lfWeight = 0;
    LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
                       LogFont.lfOutPrecision = LogFont.lfClipPrecision =
                       LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;

    //
    //  Let the facename and size define the font.
    //
    //  LogFont.lfCharSet = DEFAULT_CHARSET;

    //  Work around the GDI bug that assumes the font's default charset
    //  is always the system default locale.
    //
    *(DWORD *)&ItemData = SendDlgItemMessage( hwndDlg,
                                              ID_FONT,
                                              CB_GETITEMDATA,
                                              iCombo,
                                              0L );
    LogFont.lfCharSet = ItemData.CharSet;

    //
    //  Get the facename from the combo box.
    //
    SendDlgItemMessage( hwndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        iCombo,
                        (LONG)(LPTSTR)LogFont.lfFaceName );

    //
    //  Enable Block listbox and set defaults appropriately.
    //
    EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), TRUE);
    iCurSel = SendDlgItemMessage( hwndDlg,
                                  ID_UNICODESUBSET,
                                  CB_GETCURSEL,
                                  0,
                                  0L );
    UpdateSymbolSelection( hwndDlg,
                           aSubsetData[iCurSel].BeginRange,
                           aSubsetData[iCurSel].EndRange );
    //
    //  Enable Previous button if not on first subset.
    //
    if (iCurSel > 0)
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
    }
    //
    //  Enable Next button if not on last subset.
    //
    if (iCurSel < (cSubsets - 1))
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
    }

    //
    //  The first sub sel is the ANSI code page.
    //
    psycm->fAnsiFont = (iCurSel == 0);

    //
    //  Create the font.
    //
    psycm->hFont = CreateFontIndirect(&LogFont);
    hFont = SelectObject(hdc, psycm->hFont);

    //
    //  Create the magnify font.
    //
    LogFont.lfHeight = psycm->dypMag - 5;        // Allow for whitespace.
    psycm->hFontMag = CreateFontIndirect(&LogFont);

    //
    //  Calculate new values and place in window data structure.
    //
    GetTextMetrics(hdc, &tm);
    psycm->xpCh = 2;
    psycm->ypCh = (4 + psycm->dypBox - tm.tmHeight) / 2;

    lpdxp = (LPINT)psycm->rgdxp;

    if (psycm->fAnsiFont)
    {
        GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
    }
    else
    {
        GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
    }

    SelectObject(hdc, hFont);

    for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
    {
        *lpdxp = (psycm->dxpBox - *lpdxp) / 2 - 1;
    }
    ReleaseDC(hwndCharGrid, hdc);

    psycm->xpMagCurr = 0;              // No magnification data

    if (fRedraw)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolMap
//
//  Draws all of the pieces of the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC hdc)
{
    BOOL fFocus;

    DrawSymbolGrid(psycm, hdc);
    DrawSymbolChars(psycm, hdc);
    //
    //  We need to force the focus rect to paint if we have the focus
    //  since the old focus rect has been drawn over already.
    //
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }
    DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolGrid
//
//  Draws the symbol character map grid.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)
{
    INT cli;                // count of lines
    INT xp, yp;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    HPEN hpenOld;

    hpenOld = SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));

    //
    //  Draw horizontal lines.
    //
    xp = psycm->dxpCM + 1;
    yp = 1;
    cli = cchSymCol+1;
    while (cli--)
    {
        MoveToEx(hdc, 1, yp, NULL);
        LineTo(hdc, xp, yp);
        yp += dypBox;
    }

    //
    //  Draw vertical lines.
    //
    yp = psycm->dypCM;
    xp = 1;
    cli = cchSymRow+1;
    while (cli--)
    {
        MoveToEx(hdc, xp, 1, NULL);
        LineTo(hdc, xp, yp);
        xp += dxpBox;
    }

    DeleteObject(SelectObject(hdc, hpenOld));
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolChars
//
//  Draws the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC hdc)
{
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    INT cch;
    INT x, y;
    INT yp;
    TCHAR ch;
    HFONT hFontOld;
    RECT rect;
    LPRECT lprect = (LPRECT)&rect;
    LPINT lpdxp;

    //
    //  Setup the font and colors.
    //
    hFontOld = (HFONT)SelectObject(hdc, psycm->hFont);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    //
    //  Draw characters.
    //
    cch = 1;
    ch = chSymFirst;

    lpdxp = (LPINT)psycm->rgdxp;

    rect.top = 2;
    yp = psycm->ypCh;
    rect.bottom = rect.top + dypBox - 1;

    for (y = 0; y++ < cchSymCol;)
    {
        rect.left  = psycm->xpCh;
        rect.right = rect.left + dxpBox - 1;
        for (x = 0; (x++ < cchSymRow) && (ch <= chSymLast);)
        {
            if (psycm->fAnsiFont)
            {
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &(CHAR)ch,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &ch,
                             1,
                             NULL );
            }
            ch++;
            rect.left  += dxpBox;
            rect.right += dxpBox;
        }
        yp += dypBox;
        rect.top += dypBox;
        rect.bottom += dypBox;
    }

    SelectObject(hdc, hFontOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutline
//
//  Draws an outline around the symbol in the character map.  If fVisible,
//  then it draws the outline, otherwise it erases it.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutline(
    PSYCM psycm,
    HDC hdc,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HBRUSH hbrOld;
    RECT rc;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;

    hbrOld = SelectObject( hdc,
                           CreateSolidBrush(GetSysColor( fVisible
                                                           ? COLOR_WINDOWFRAME
                                                           : COLOR_WINDOW )) );
    ch -= chSymFirst;

    rc.left   = (ch % cchSymRow) * dxpBox + 2;
    rc.right  = rc.left + dxpBox - 1;
    rc.top    = (ch / cchSymRow) * dypBox + 2;
    rc.bottom = rc.top  + dypBox - 1;

    //
    //  Draw selection rectangle.
    //
    PatBlt(hdc, rc.left,      rc.top - 2,    dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left,      rc.bottom + 1, dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left - 2,  rc.top,        1,          dypBox - 1, PATCOPY);
    PatBlt(hdc, rc.right + 1, rc.top,        1,          dypBox - 1, PATCOPY);

    DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

    //
    //  Deal with the focus rectangle.
    //
    if (fFocus != psycm->fFocusState)
    {
        DrawFocusRect(hdc, &rc);
        psycm->fFocusState = fFocus;
    }

    SelectObject(hdc, hbrOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  MoveSymbolSel
//
//  Changes the current symbol selection.  Handles drawing of magnified
//  characters.
//
////////////////////////////////////////////////////////////////////////////

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew)
{
    HDC hdc;
    HDC hdcMag = psycm->hdcMag;
    RECT rc;
    HFONT hFontOld;
    HFONT hFontMag;                    // old font in memory dc
    HPEN hpenOld;
    UTCHAR chNorm = chNew - chSymFirst + 32;
    INT dxpMag = psycm->dxpMag;        // for quick reference
    INT dypMag = psycm->dypMag;
    INT ypMemSrc  = psycm->ypDest;
    INT ypMemDest = ypMemSrc ^ dypMag;
    INT xpCurr  = psycm->xpMagCurr;
    INT ypCurr  = psycm->ypMagCurr;
    INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
    INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
    INT dxpCh;  // width of extra character space (used to center char in box)
    INT dypCh;
    SIZE sz;

    DOUTL("MoveSymbolSel: In\n");

    if (((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)))
    {
        DOUTL("MoveSymbolSel: ch == cur && fMag... exiting\n");
        return;
    }

    //
    //  Don't draw a magnified character if the char grid has an update
    //  region or is not visible.
    //
    if (!IsWindowVisible(hwndCharGrid) ||
        GetUpdateRect(hwndCharGrid, &rc, FALSE))
    {
        DOUTL("MoveSymbolSel: not vis or upd rect... exiting\n");
        return;
    }

    hdc = GetDC(hwndDialog);

    //
    //  Setup the magnified font character.
    //
    hFontMag = SelectObject(hdcMag, psycm->hFontMag);

    if (psycm->fAnsiFont)
    {
        char chANSINew = (char)chNew;
        GetTextExtentPointA(hdcMag, &chANSINew, 1, &sz);
    }
    else
    {
        GetTextExtentPointW(hdcMag, &chNew, 1, &sz);
    }

    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 2;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 2;
    }
    else
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
    }
    hpenOld = SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));
    hFontOld = SelectObject(hdc, psycm->hFontMag);

    //
    //  Copy screen data to offscreen bitmap.
    //
    BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

    //
    //  Setup DC.
    //
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    if (FMagData(psycm))
    {
        INT xpT  = xpNew - xpCurr;     // point of overlap in offscreen data
        INT ypT  = ypNew - ypCurr;
        INT dxpT = dxpMag - abs(xpT);  // size of overlap
        INT dypT = dypMag - abs(ypT);

        DOUTL("MoveSymbolSel: FMagData\n");

        if ((dxpT > 0) && (dypT > 0))
        {
            INT xpTmax,  ypTmax;   // max(0, xpT);
            INT xpTmin,  ypTmin;   // min(0, xpT);
            INT xpTnmin, ypTnmin;  // min(0, -xpT);

            DOUTL("MoveSymbolSel: dxpT > 0 && dypT > 0\n");

            if (xpT < 0)
            {
                xpTnmin = - (xpTmin = xpT);
                xpTmax  = 0;
            }
            else
            {
                xpTmax  = xpT;
                xpTnmin = xpTmin = 0;
            }
            if (ypT < 0)
            {
                ypTnmin = - (ypTmin = ypT);
                ypTmax  = 0;
            }
            else
            {
                ypTmax  = ypT;
                ypTnmin = ypTmin = 0;
            }

            rc.left  = xpTmax;
            rc.right = xpTmin + dxpMag;
            rc.top   = ypTmax + ypMemSrc;
            rc.bottom= ypTmin + dypMag + ypMemSrc;

            //
            //  Copy overlapping offscreen data.
            //
            BitBlt( hdcMag,
                    xpTnmin,
                    ypTnmin + ypMemDest,
                    dxpT,
                    dypT,
                    hdcMag,
                    xpTmax,
                    ypTmax  + ypMemSrc,
                    SRCCOPY );

            //
            //  Print part of char over old screen data.
            //
            if (psycm->fAnsiFont)
            {
                ExtTextOutA( hdcMag,
                             xpT + dxpCh,
                             ypT + dypCh + ypMemSrc,
                             ETO_OPAQUE | ETO_CLIPPED,
                             (LPRECT)&rc,
                             &(CHAR)chNew,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdcMag,
                             xpT + dxpCh,
                             ypT + dypCh + ypMemSrc,
                             ETO_OPAQUE | ETO_CLIPPED,
                             (LPRECT)&rc,
                             &chNew,
                             1,
                             NULL );
            }
        }

        //
        //  Restore old screen data.
        //
        BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);
    }

    rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
    rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;

    //
    //  The rectangle.
    //
    MoveToEx(hdc, rc.left, rc.top, NULL);
    LineTo(hdc, rc.left, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.top);
    LineTo(hdc, rc.left, rc.top);

    //
    //  The shadow.
    //
    MoveToEx(hdc, rc.right, rc.top + 1, NULL);
    LineTo(hdc, rc.right, rc.bottom);
    LineTo(hdc, rc.left, rc.bottom);
    MoveToEx(hdc, rc.right + 1, rc.top + 2, NULL);
    LineTo(hdc, rc.right + 1, rc.bottom + 1);
    LineTo(hdc, rc.left + 1, rc.bottom + 1);

    rc.left++;
    rc.top++;
    rc.right--;
    rc.bottom--;

    //
    //  Draw magnified character on screen.
    //
    if (psycm->fAnsiFont)
    {
        ExtTextOutA( hdc,
                     xpNew + dxpCh,
                     ypNew + dypCh,
                     ETO_OPAQUE | ETO_CLIPPED,
                     (LPRECT)&rc,
                     &(CHAR)chNew,
                     1,
                     NULL );
    }
    else
    {
        ExtTextOutW( hdc,
                     xpNew + dxpCh,
                     ypNew + dypCh,
                     ETO_OPAQUE | ETO_CLIPPED,
                     (LPRECT)&rc,
                     &chNew,
                     1,
                     NULL );
    }

    psycm->ypDest = ypMemDest;

    DeleteObject(SelectObject(hdc, hpenOld));
    SelectObject(hdc, hFontOld);
    SelectObject(hdcMag, hFontMag);

    UpdateKeystrokeText(hdc, psycm->fAnsiFont, chNew, TRUE);

    ReleaseDC(hwndDialog, hdc);

    psycm->chCurr = chNew;
    DOUTL("MoveSymbolSel: Leaving\n");
}


////////////////////////////////////////////////////////////////////////////
//
//  RestoreSymMag
//
//  Restores the screen data under the magnifier.
//
////////////////////////////////////////////////////////////////////////////

VOID RestoreSymMag(
    PSYCM psycm)
{
    if (FMagData(psycm))
    {
        HDC hdc = GetDC(hwndDialog);

        BitBlt( hdc,
                psycm->xpMagCurr,
                psycm->ypMagCurr,
                psycm->dxpMag,
                psycm->dypMag,
                psycm->hdcMag,
                0,
                psycm->ypDest,
                SRCCOPY );

        ReleaseDC(hwndDialog, hdc);

        psycm->xpMagCurr = 0;     // flag - no data offscreen (see FMagData)
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FontLoadProc
//
//  Used by EnumFonts to load our combo box with all the fonts installed
//  in the system.
//
////////////////////////////////////////////////////////////////////////////

INT APIENTRY FontLoadProc(
    LPLOGFONT lpLogFont,
    NEWTEXTMETRICEX* lpTextMetric,
    DWORD nFontType,
    LPARAM lpData)
{
    INT iPos;
    TCHAR szFace[LF_FACESIZE];

    //
    //  Check for duplicates.
    //
    iPos = (INT)SendDlgItemMessage( (HWND)lpData,
                                    ID_FONT,
                                    CB_FINDSTRING,
                                    (WPARAM)-1,
                                    (DWORD)&lpLogFont->lfFaceName );
    if (iPos == CB_ERR)
    {
NotInListYet:
        //
        //  Doesn't exist, insert the facename into the combo box.
        //
        iPos = (INT)SendDlgItemMessage( (HWND)lpData,
                                        ID_FONT,
                                        CB_ADDSTRING,
                                        0,
                                        (DWORD)&lpLogFont->lfFaceName );
    }
    else
    {
        //
        //  Make sure it is not just a substring (want a full match).
        //
        SendDlgItemMessage( (HWND)lpData,
                            ID_FONT,
                            CB_GETLBTEXT,
                            iPos,
                            (LONG)(LPTSTR)szFace );
        if (lstrcmpi(szFace, lpLogFont->lfFaceName))
        {
            goto NotInListYet;
        }

        //
        //  Already exists, blow out now if this is not a true type font.
        //
        if (!(nFontType & TRUETYPE_FONTTYPE))
        {
            return (1);
        }
    }

    //
    //  Store the pertinant font information in the combo item data.
    //
    if ((iPos != CB_ERR) && (iPos != CB_ERRSPACE))
    {
        ITEMDATA ItemData;
        DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
        SHORT   sFontType = 0;

        if (ntmFlags & NTM_PS_OPENTYPE)
        {
            sFontType = PS_OPENTYPE_FONT;
        }
        else if (ntmFlags & NTM_TYPE1)
        {
            sFontType = TYPE1_FONT;
        }
        else if (nFontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
                sFontType = TT_OPENTYPE_FONT;
            else
                sFontType = TRUETYPE_FONT;
        }

        ItemData.FontType = sFontType;
        ItemData.CharSet = lpLogFont->lfCharSet;
        ItemData.PitchAndFamily = lpLogFont->lfPitchAndFamily;

        SendDlgItemMessage( (HWND)lpData,
                            ID_FONT,
                            CB_SETITEMDATA,
                            iPos,
                            *(DWORD *)&ItemData );
    }

    //
    //  Continue enumeration.
    //
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetEditText
//
//  Returns HANDLE containing the text in the edit control.
//
//  NOTE: Caller is responsible for freeing this handle!
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    DWORD dwSel;

    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);

    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    lpstrText = (LPTSTR)GlobalLock(hmem);

    cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);

    dwSel = SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);

    if (LOWORD(dwSel) != HIWORD(dwSel))
    {
        //
        //  If there is a selection, then only get the selected text.
        //
        *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
        lstrcpy(lpstrText, lpstrText + LOWORD(dwSel));
    }

    GlobalUnlock(hmem);

    if (cchText == 0)
    {
        hmem = GlobalFree(hmem);
    }

    return (hmem);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyString
//
//  Implements the copy function.
//
////////////////////////////////////////////////////////////////////////////

VOID CopyString(
    HWND hwndDlg)
{
    HANDLE hmem;
    LPTSTR lpstrText;

    if (hmem = GetEditText(hwndDlg))
    {
        lpstrText = (LPTSTR)GlobalLock(hmem);

        //
        //  Copying string to clipboard.
        //
        if (OpenClipboard(hwndDlg))
        {
            EmptyClipboard();
            SendRTFToClip(hwndDlg, lpstrText);
#ifdef UNICODE
            SetClipboardData(CF_UNICODETEXT, hmem);
#else
            SetClipboardData(CF_TEXT, hmem);
#endif
            CloseClipboard();
        }
        else
        {
            //
            //  If we couldn't open the clipboard, then we need to free memory.
            //
            GlobalUnlock(hmem);
            GlobalFree(hmem);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SendRTFToClip
//
//  Puts the string in the clipboard using Rich Text Format.  This assumes
//  that the clipboard has already been opened.
//
////////////////////////////////////////////////////////////////////////////

VOID SendRTFToClip(
    HWND hwndDlg,
    LPTSTR lpstrText)
{
    INT iCurrFont;
    ITEMDATA ItemData;
    TCHAR szFaceName[LF_FACESIZE];
    HANDLE hmemRTF, hmemClip;
    LPTSTR lpstrClipString;
    TCHAR achHeaderTmpl[] = TEXT("{\\rtf1\\ansi\\ansicpg%d {\\fonttbl{\\f0\\");
    TCHAR achHeader[sizeof(achHeaderTmpl) / sizeof(TCHAR) + 20];
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");
    INT cchUC;
#ifndef UNICODE_RTF
    LPWSTR pszRTFW;
#endif


    #define MAXLENGTHFONTFAMILY 8
    #define ALITTLEEXTRA 10    // covers extra characters + length of font size

    iCurrFont = (INT)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);

    //
    //  Get the item data - contains fonttype, charset, and pitchandfamily.
    //
    *(DWORD *)&ItemData = SendDlgItemMessage( hwndDlg,
                                              ID_FONT,
                                              CB_GETITEMDATA,
                                              iCurrFont,
                                              0L );

    //
    //  Get the facename from the combo box.
    //
    SendDlgItemMessage( hwndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        iCurrFont,
                        (LPARAM)(LPTSTR)szFaceName );

    wsprintf(achHeader, achHeaderTmpl, (INT)(SHORT)GetACP());

    //
    //  16 times in case they're all > 7 bits (each chr -> \uc1\uddddddd\'xx)
    //  and room for the second byte of DBCS.
    //
    hmemRTF = GlobalAlloc( 0,
                           CTOB(lstrlen((LPTSTR)achHeader) +
                                  MAXLENGTHFONTFAMILY +
                                  lstrlen(szFaceName) +
                                  lstrlen((LPTSTR)achMiddle) +
                                  2 * 16 * lstrlen(lpstrText) +
                                  ALITTLEEXTRA) );
    if (hmemRTF == NULL)
    {
        return;
    }

    //
    //  Allocate memory for local storage of clipboard string for owner draw.
    //
    if (hmemClip  = GlobalAlloc(0, CTOB(lstrlen(lpstrText) + 1)))
    {
        //
        //  Get rid of old ones.
        //
        if (hstrClipboard)
        {
            GlobalFree(hstrClipboard);
        }
        if (fDelClipboardFont)
        {
            fDelClipboardFont = FALSE;
            DeleteObject(hFontClipboard);
        }

        //
        //  Save this stuff away for owner drawing in a clipboard viewer.
        //
        hFontClipboard = sycm.hFont;
        hstrClipboard = hmemClip;
        lstrcpy(GlobalLock(hstrClipboard), lpstrText);
        GlobalUnlock(hstrClipboard);
    }
    else
    {
        GlobalFree(hmemRTF);
        return;
    }

    lpstrClipString = GlobalLock(hmemRTF);
#ifndef UNICODE_RTF
    pszRTFW = lpstrClipString;
#endif

    lstrcpy(lpstrClipString, achHeader);

    if (ItemData.CharSet == SYMBOL_CHARSET)
    {
        lstrcat(lpstrClipString, (LPTSTR)TEXT("ftech "));
    }
    else
    {
        //
        //  Top four bits specify family.
        //
        switch (ItemData.PitchAndFamily & 0xf0)
        {
            case ( FF_DECORATIVE ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fdecor "));
                break;
            }
            case ( FF_MODERN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fmodern "));
                break;
            }
            case ( FF_ROMAN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("froman "));
                break;
            }
            case ( FF_SCRIPT ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fscript "));
                break;
            }
            case ( FF_SWISS ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fswiss "));
                break;
            }
            default :
            {
                break;
            }
        }
    }

    lstrcat(lpstrClipString, szFaceName);

    lstrcat(lpstrClipString, (LPTSTR)achMiddle);

    //
    //  We need to do the text character by character, making sure
    //  that we output a special sequence \'hh for characters bigger
    //  than 7 bits long!
    //
    lpstrClipString = (LPTSTR)(lpstrClipString + lstrlen(lpstrClipString));

    cchUC = 0;

    while (*lpstrText)
    {
        if ((UTCHAR)*lpstrText < 128)
        {
            if (*lpstrText == TEXT('\\') ||
                *lpstrText == TEXT('{')  ||
                *lpstrText == TEXT('}'))
            {
                //
                //  Need to preface these symbols with a '\' since they are
                //  special control characters for RTF.
                //
                *lpstrClipString++ = TEXT('\\');
            }

            *lpstrClipString++ = *lpstrText++;
        }
        else
        {
            unsigned char achTmp[2];
            unsigned char *pTmp = achTmp;
            int cch;

            cch = WideCharToMultiByte( CP_ACP,
                                       0,
                                       lpstrText,
                                       1,
                                       pTmp,
                                       2,
                                       NULL,
                                       NULL );

            //
            // Put in a \uc# to tell Unicode reader how many bytes to skip
            // and the \uN code to indicate the real unicode value.
            //
            if (cch != cchUC )
            {
                cchUC = cch;
                lpstrClipString += wsprintf( lpstrClipString,
                                             TEXT("\\uc%d"),
                                             (INT)(SHORT)cchUC );
            }

            lpstrClipString += wsprintf( lpstrClipString,
                                         TEXT("\\u%d"),
                                         (INT)(SHORT)*lpstrText );

            //
            //  Now put the \'xx string in to indicate the actual character.
            //
            lpstrText++;
            while (cch--)
            {
                *lpstrClipString++ = TEXT('\\');
                *lpstrClipString++ = TEXT('\'');
                wsprintf(achMiddle, TEXT("%x"), (INT)*pTmp++);
                *lpstrClipString++ = achMiddle[0];
                *lpstrClipString++ = achMiddle[1];
            }
        }
    }
    *lpstrClipString++ = TEXT('}');
    *lpstrClipString++ = TEXT('\0');

    if (!wCFRichText)
    {
         TCHAR szRTF[80];

         LoadString(hInst, IDS_RTF, szRTF, BTOC(sizeof(szRTF)) - 1);
         wCFRichText = RegisterClipboardFormat(szRTF);
    }

#ifndef UNICODE_RTF
    {
        //
        //  RTF is only defined for ANSI, not for Unicode, therefore
        //  we need to convert the buffer before we put it on the
        //  clipboard.  Eventually, we should add autoconversion code
        //  to USER to handle this for us.
        //
        int cch;
        HANDLE hmemRTFA;
        LPSTR pszRTFA;

        cch = WideCharToMultiByte( CP_ACP,
                                   0,
                                   pszRTFW,
                                   lpstrClipString - pszRTFW,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL );

        if (cch != 0 &&
            (hmemRTFA = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,cch)) != NULL)
        {
            pszRTFA = GlobalLock(hmemRTFA);

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 pszRTFW,
                                 lpstrClipString - pszRTFW,
                                 pszRTFA,
                                 cch,
                                 NULL,
                                 NULL );

            GlobalUnlock(hmemRTFA);
            GlobalUnlock(hmemRTF);
            GlobalFree(hmemRTF);

            hmemRTF = hmemRTFA;
        }
    }
#endif

    //
    //  Put RTF and OwnerDisplay formats in the clipboard.
    //
    SetClipboardData(wCFRichText, hmemRTF);
    SetClipboardData(CF_OWNERDISPLAY, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  PointsToHeight
//
//  Calculates the height in pixels of the specified point size for the
//  current display.
//
////////////////////////////////////////////////////////////////////////////

INT PointsToHeight(
    INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return (iHeight);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateKeystrokeText
//
//  Calculates and updates the text string displayed in the Keystroke
//  field of the status bar.  It repaints the status field if fRedraw is
//  TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateKeystrokeText(
    HDC hdc,
    BOOL fANSI,
    UTCHAR chNew,
    BOOL fRedraw)
{
    TCHAR szUnshifted[CCH_KEYNAME];
    INT vkRes;
    LONG lParam;

    if (!fANSI)
    {
        lstrcpy(szKeystrokeText, szUnicodeLabel);
        wsprintf( (LPTSTR)(szKeystrokeText + iUnicodeLabelStart),
                  TEXT("%04x"),
                  chNew );
    }
    else
    {
        lstrcpy(szKeystrokeText, szKeystrokeLabel);
        vkRes = VkKeyScan(chNew);
        //
        //  Map the virtual key code into an unshifted character value.
        //
        lParam = MapVirtualKey(LOBYTE(vkRes), 0) << 16;
        GetKeyNameText(lParam, szUnshifted, CCH_KEYNAME - 1);

        switch (HIBYTE(vkRes))
        {
            case ( 0 ) : // unshifted char
            case ( 1 ) : // character is shifted, just display the shifted char
            {
                if (chNew != TEXT(' '))
                {
                    szKeystrokeText[iKeystrokeTextStart] = chNew;
                    szKeystrokeText[iKeystrokeTextStart + 1] = TEXT('\0');
                }
                else
                {
                    lstrcat(szKeystrokeText, szUnshifted);
                }
                break;
            }
            case ( 2 ) : // character is control character
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrl);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            case ( 6 ) : // character is CONTROL+ALT
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            case ( 7 ) : // character is SHIFT+CONTROL+ALT
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szShiftCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            default : // Character created via Alt + Numpad
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szAlt);
                wsprintf( (LPTSTR)(szKeystrokeText + lstrlen(szKeystrokeText)),
                          TEXT("%d"),
                          chNew );
                break;
            }
        }
    }

    if (fRedraw)
    {
        PaintStatusLine(hdc, FALSE, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateHelpText
//
//  Calculates if the Help string needs to be updated, and does so if
//  necessary.
//
//  If hwndCtrl is not NULL, then it specifies the window handle of the
//  control gaining focus, and lpmsg is ignored.
//
//  If hwndCtrl is NULL, then lpmsg must point to a valid message structure.
//  If it is a tab character, then we calculate what the next control is
//  that will receive the focus.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateHelpText(
    LPMSG lpmsg,
    HWND hwndCtrl)
{
    HDC hdc;
    BOOL fPaintStatus = FALSE;
    BOOL fRet = TRUE;

    DPRINT((szDbgBuf, TEXT("UpdHlpTxt: lpmsg:0x%08lX, hwnd:0x%08lX\n"), (DWORD)lpmsg, (DWORD)hwndCtrl));

    if (hwndCtrl != NULL)
    {
        fPaintStatus = TRUE;
        iControl = GetDlgCtrlID(hwndCtrl);
    }
    else if (lpmsg->message == WM_KEYDOWN)
    {
        if (lpmsg->wParam == VK_TAB)
        {
            fPaintStatus = TRUE;
            hwndCtrl = GetNextDlgTabItem( hwndDialog,
                                          GetDlgItem(hwndDialog, iControl),
                                          (BOOL)(GetKeyState(VK_SHIFT) & 0x8000) );
            iControl = GetDlgCtrlID(hwndCtrl);
            if (iControl == ID_STRING)
            {
                //
                //  Do this ourselves, otherwise default action will select
                //  the whole edit control.
                //
                SetFocus(hwndCtrl);
                fRet = FALSE;
            }
            if (iControl == ID_CHARGRID)
            {
                //
                //  Set the default button back to "Select".  The default
                //  might have changed to the "Next" or "Previous" button.
                //
                SendMessage(hwndDialog, DM_SETDEFID, ID_SELECT, 0);
            }
        }
        else if (lpmsg->wParam == VK_F1)
        {
            PostMessage(hwndDialog, WM_COMMAND, ID_HELP, 0L);
        }
    }

    if (fPaintStatus)
    {
        hdc = GetDC(hwndDialog);
        PaintStatusLine(hdc, TRUE, FALSE);
        ReleaseDC(hwndDialog, hdc);
    }

    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  SubSetChanged
//
//  Sets the ANSI bit if appropriate and then calls UpdateSymbolSelection
//  and then repaints the window.
//
//  Repaints Keystroke field if HWND != NULL.
//  Sets sycm->fAnsiFont if 'Windows Chars' is the subset.
//  Redraws the char grid.
//
////////////////////////////////////////////////////////////////////////////

VOID SubSetChanged(
    HWND hwnd,
    INT iSubSet,
    INT ichFirst,
    INT ichLast)
{
    HDC hdc;
    BOOL fANSI = (iSubSet == 0);

    if (fANSI != sycm.fAnsiFont)
    {
        sycm.fAnsiFont = fANSI;
    }

    UpdateSymbolSelection(hwnd, ichFirst, ichLast);

    if ((hwnd != NULL) && ((hdc = GetDC(hwnd)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (iSubSet == 0)
        {
            GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
        }
        else
        {
            GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2 - 1;
        }
        ReleaseDC(hwnd, hdc);
    }

    InvalidateRect(hwndCharGrid, NULL, TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolSelection
//
//  Updates the values of the following global values:
//      chRangeFirst
//      chRangeLast
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolSelection(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = FirstChar;
    chRangeLast = LastChar;

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;

        if (i < 0)
        {
            i = 1;
        }
        else
        {
            i = i / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);

    UpdateSymbolRange(hwnd, chFirst, chLast);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolRange
//
//  Updates the values of the following global values:
//      chSymFirst
//      chSymLast
//      sycm.chCurr
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolRange(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;

    chSymFirst = FirstChar;
    chSymLast = LastChar;

    sycm.chCurr = chSymOffset + chSymFirst;
    if (sycm.chCurr > chSymLast)
    {
        sycm.chCurr = chSymFirst;
    }
    if (hwnd != NULL)
    {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.fAnsiFont, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        UpdateKeystrokeText(NULL, sycm.fAnsiFont, sycm.chCurr, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintStatusLine
//
//  Paints the Help and Keystroke fields in the status bar.
//
//  Repaints Help field if fHelp == TRUE.
//  Repaints Keystroke field if fKeystroke == TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;
    TCHAR szHelpText[100];

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
    {
        hfontOld = SelectObject(hdc, hfontStatus);
    }

    //
    //  Set the text and background colors.
    //
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fHelp)
    {
        //
        //  Now the help text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rect.left + dxHelpField - 2 * dyBorder;

        LoadString(hInst, iControl, szHelpText, BTOC(sizeof(szHelpText)) - 1);

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szHelpText,
                    lstrlen(szHelpText),
                    NULL );
    }

    if (fKeystroke)
    {
        //
        //  Now the keystroke text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.right = rcStatusLine.right - 9 * dyBorder;
        rect.left = rect.right - dxKeystrokeField + 2 * dyBorder;

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szKeystrokeText,
                    lstrlen(szKeystrokeText),
                    NULL );
    }

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
//  Paints the font facenames and TT bitmap in the font combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE];
    HBITMAP hOld;
    INT dy;
    SHORT   sFontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE | ETO_CLIPPED,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        if (hbmFont)
        {
            hOld = SelectObject(hdcMem, hbmFont);
            sFontType = ((ITEMDATA FAR *)&(lpdis->itemData))->FontType;

            if (sFontType)
            {

                int xSrc;
                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if (sFontType & TRUETYPE_FONT)
                    xSrc = 0;
                else if (sFontType & TT_OPENTYPE_FONT)
                    xSrc = 2;
                else if(sFontType & PS_OPENTYPE_FONT)
                    xSrc = 3;
                else if (sFontType & TYPE1_FONT)
                    xSrc = 4;

                BitBlt( hDC,
                        lpdis->rcItem.left,
                        lpdis->rcItem.top + dy,
                        DX_BITMAP,
                        DY_BITMAP,
                        hdcMem,
                        xSrc * DX_BITMAP,
                        lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                        SRCCOPY );
            }
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  Loads DIB bitmaps and "fixes up" their color tables so that we get the
//  desired result for the device we are on.
//
//  This routine requires:
//    - the DIB is a 16 color DIB authored with the standard windows colors
//    - bright blue (00 00 FF) is converted to the background color
//    - light grey  (C0 C0 C0) is replaced with the button face color
//    - dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

HBITMAP LoadBitmaps(
    INT id)
{
    HDC hdc;
    HANDLE h, hRes;
    DWORD *p;
    LPBYTE lpBits;
    LPBITMAPINFOHEADER lpBitmapInfo;
    INT numcolors;
    DWORD rgbSelected, rgbUnselected;
    HBITMAP hbm;

    rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
    //
    //  Flip the colors.
    //
    rgbSelected = RGB( GetBValue(rgbSelected),
                       GetGValue(rgbSelected),
                       GetRValue(rgbSelected) );
    rgbUnselected = GetSysColor(COLOR_WINDOW);
    //
    //  Flip the colors.
    //
    rgbUnselected = RGB( GetBValue(rgbUnselected),
                         GetGValue(rgbUnselected),
                         GetRValue(rgbUnselected) );

    h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(hInst, h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //
    numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
        p++;
    }
    UnlockResource(hRes);

    //
    //  Now create the DIB.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    //
    //  First skip over the header structure.
    //
    lpBits = (LPBYTE)(lpBitmapInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapInfo,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapInfo,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    GlobalUnlock(hRes);
    FreeResource(hRes);

    return (hbm);
}


////////////////////////////////////////////////////////////////////////////
//
//  DoHelp
//
//  Invokes help if fInvokeHelp is true, or dismisses help if fInvokeHelp
//  is FALSE.
//
////////////////////////////////////////////////////////////////////////////

VOID DoHelp(
    HWND hWnd,
    BOOL fInvokeHelp)
{
    TCHAR szHelp[80];

    if (LoadString(hInst, IDS_HELP, szHelp, BTOC(sizeof(szHelp)) - 1))
    {
        if (fInvokeHelp)
        {
			// APPCOMPAT: an error in HtmlHelp prevents the unicode version from working
			// This is a HACK to get around the problem.  Remove this hack when the problem is fixed.
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HH_DISPLAY_TOPIC, 0L);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveFont
//
//  Saves the current font facename in win.ini, so that it can be selected
//  the next time charmap comes up.
//
////////////////////////////////////////////////////////////////////////////

VOID SaveCurrentFont(
    HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");

    SendDlgItemMessage( hWndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        (WORD)SendDlgItemMessage( hWndDlg,
                                                  ID_FONT,
                                                  CB_GETCURSEL,
                                                  0,
                                                  0L ),
                        (LONG)(LPTSTR)szFaceName );

    WriteProfileString(TEXT("MSCharMap"), TEXT("Font"), (LPTSTR)szFaceName);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectInitialFont
//
//  Selects the initial font by getting a saved facename from win.ini and
//  selecting it in the combo box.
//
//  Returns index to font selected.
//
////////////////////////////////////////////////////////////////////////////

INT SelectInitialFont(
    HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString( TEXT("MSCharMap"),
                           TEXT("Font"),
                           NULL,
                           (LPTSTR)szFaceName,
                           BTOC(sizeof(szFaceName)) ) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage( hWndDlg,
                                            ID_FONT,
                                            CB_SELECTSTRING,
                                            (WPARAM)-1,
                                            (LONG)(LPTSTR)szFaceName )) == CB_ERR))
    {
        //
        //  If there was no profile or the selection failed then try selecting
        //  the symbol font, if that fails then select the first one.
        //
        if ((iIndex = (INT)SendDlgItemMessage( hWndDlg,
                                               ID_FONT,
                                               CB_SELECTSTRING,
                                               (WPARAM)-1,
                                               (LONG)(LPTSTR)TEXT("Symbol") )) == CB_ERR)
        {
            SendDlgItemMessage(hWndDlg, ID_FONT, CB_SETCURSEL, iIndex = 0, 0L);
        }
    }

    return (iIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveCurrentSubset
//
//  Saves the current subset name in win.ini, so that it can be selected
//  the next time charmap comes up.
//
////////////////////////////////////////////////////////////////////////////

VOID SaveCurrentSubset(
    HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");

    SendDlgItemMessage( hWndDlg,
                        ID_UNICODESUBSET,
                        CB_GETLBTEXT,
                        (WORD)SendDlgItemMessage( hWndDlg,
                                                  ID_UNICODESUBSET,
                                                  CB_GETCURSEL,
                                                  0,
                                                  0L ),
                        (LONG)(LPTSTR)szSubsetName );

    WriteProfileString(TEXT("MSCharMap"), TEXT("Block"), (LPTSTR)szSubsetName);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectInitialSubset
//
//  Selects the initial Unicode subset by getting a saved block name from
//  win.ini.
//
//  Returns index to subset selected.
//
////////////////////////////////////////////////////////////////////////////

INT SelectInitialSubset(
    HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString( TEXT("MSCharMap"),
                           TEXT("Block"),
                           NULL,
                           (LPTSTR)szSubsetName,
                           BTOC(sizeof(szSubsetName)) ) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage(
                            hWndDlg,
                            ID_UNICODESUBSET,
                            CB_SELECTSTRING,
                            (WPARAM)-1,
                            (LONG)(LPTSTR)szSubsetName )) == CB_ERR))
    {
        //
        //  If there was no profile or the selection failed then try selecting
        //  the Basic Latin block, if that fails then select the first one.
        //
        if ((iIndex = (INT)SendDlgItemMessage(
                               hWndDlg,
                               ID_UNICODESUBSET,
                               CB_SELECTSTRING,
                               (WPARAM)-1,
                               (LONG)(LPTSTR)TEXT("Basic Latin") )) == CB_ERR)
        {
            SendDlgItemMessage( hWndDlg,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iIndex = 0,
                                0L );
        }
    }

    chSymFirst = aSubsetData[iIndex].BeginRange;
    chSymLast = aSubsetData[iIndex].EndRange;
    sycm.chCurr = chSymFirst;

    return (iIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  ExitMagnify
//
//  Releases mouse capture, exits magnify mode, and restores the cursor.
//
////////////////////////////////////////////////////////////////////////////

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    //
    //  Release capture, remove magnified character, restore cursor.
    //
    ReleaseCapture();
    RestoreSymMag(psycm);
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, TRUE);
    if (psycm->fCursorOff)
    {
        ShowCursor(TRUE);
    }
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetEditCtlFont
//
//  Creates a font for the Edit control that visually matches the handle
//  given, but is guaranteed not to be bigger than the size of the edit
//  control.
//
////////////////////////////////////////////////////////////////////////////

void SetEditCtlFont(
    HWND hwndDlg,
    int idCtl,
    HFONT hfont)
{
    static HFONT hfNew = NULL;
    LOGFONT lfNew;
    HWND hwndCtl = GetDlgItem(hwndDlg, idCtl);
    RECT rc;

    if (hfNew != NULL)
    {
        DeleteObject(hfNew);
    }

    GetWindowRect(hwndCtl, &rc);

    if (GetObject(hfont, sizeof(lfNew), &lfNew) != 0)
    {
        lfNew.lfHeight = rc.bottom - rc.top - 8;
        lfNew.lfWidth = lfNew.lfEscapement = lfNew.lfOrientation =
          lfNew.lfWeight = 0;

        hfNew = CreateFontIndirect(&lfNew);
    }
    else
    {
        hfNew = hfont;
    }

    SendMessage(hwndCtl, WM_SETFONT, (WPARAM)hfNew, (LPARAM)TRUE);

    if (hfNew == hfont)
    {
        hfNew = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\sublocal\sublocal.c ===
#include <windows.h>
#include <stdio.h>
#include <io.h>


/*
    Usage:

    sublocal -winini <section> <key> <value>

    IE,
        sublocal -winini fonts "MS Sans Serif (8,10,12,18,24 (VGA res)" sserifeg.fon

    sublocal -userdef


    Return codes:

        0 - success
        1 - invalid command line args
        2 - failure (-winini case)
        3 - failure (-userdef case)
*/



typedef enum {
    ResultSuccess,
    ResultInvalidArgs,
    ResultWinIniFailure,
    ResultUserDefFailure,
    ResultTurkishKeyboardFailure
} RESULTCODE;



BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


RESULTCODE
DoNewUserDef(
    VOID
    )
{
    TCHAR UserDefName[MAX_PATH];
    TCHAR TempName[MAX_PATH];
    BOOL Renamed;
    ULONG u;

    //
    // Form the full pathname of the userdef hive
    // and a temporary filename.
    //
    GetSystemDirectory(UserDefName,MAX_PATH);
    lstrcat(UserDefName,TEXT("\\CONFIG"));
    GetTempFileName(UserDefName,TEXT("HIVE"),0,TempName);
    lstrcat(UserDefName,TEXT("\\USERDEF"));

    //
    // Rename the existing userdef to the temp file name.
    // If this fails, assume there is no existing userdef hive (!!!)
    // and continue.
    //
    // Note that GetTempFileName creates the temp file and leaves it
    // there so we have to use MoveFileEx to replace it.
    //
    Renamed = MoveFileEx(UserDefName,TempName,MOVEFILE_REPLACE_EXISTING);

    //
    // Save the current user to userdef.
    //
    EnablePrivilege(SE_BACKUP_NAME);
    u = RegSaveKey(HKEY_CURRENT_USER,UserDefName,NULL);
    if(u != NO_ERROR) {
        //
        // Save failed. Clean up and return.
        //
        DeleteFile(UserDefName);
        if(Renamed) {
            MoveFile(TempName,UserDefName);
        }
        return(ResultUserDefFailure);
    }

    //
    // Save worked.  Get rid of the original userdef.
    //
    SetFileAttributes(TempName,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(TempName);

    return(ResultSuccess);
}


static TCHAR    szKey[] = TEXT("System\\CurrentControlSet\\Control\\Keyboard Layout\\DosKeybIDs");

RESULTCODE
PatchTurkishDosKeybIDs(
    VOID
    )
{
    DWORD   dwSize, dwType;
    int     rc;
    HANDLE  hkey;
    TCHAR   szX0000041F[40];
    TCHAR   szX0001041F[40];

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0L, KEY_WRITE, (PHKEY)&hkey)) {

        // dwSize = sizeof(szX0000041F);
        // rc = RegQueryValueEx (hkey, TEXT("0000041F"), NULL, &dwType,
        //                     (LPBYTE)szX0000041F, &dwSize);
	    rc = RegSetValueEx (hkey, TEXT("0000041F"), 0L, REG_SZ,
		       (LPBYTE)TEXT("179"), (lstrlen(TEXT("179")) + 1)*sizeof(TCHAR));
        if (rc != 0) {
	        RegCloseKey (hkey);
	        printf("Error = %d\n", GetLastError());
            return ResultTurkishKeyboardFailure;
        }

        // dwSize = sizeof(szX0001041F);
        // rc = RegQueryValueEx (hkey, TEXT("0001041F"), NULL, &dwType,
        //                      (LPBYTE)szX0001041F, &dwSize);
	    rc = RegSetValueEx (hkey, TEXT("0001041F"), 0L, REG_SZ,
		       (LPBYTE)TEXT("440"), (lstrlen(TEXT("440")) + 1)*sizeof(TCHAR));

        RegCloseKey (hkey);

        if (rc != 0) {
	        printf("Error = %d\n", GetLastError());
            return ResultTurkishKeyboardFailure;
        }

	    // printf("0000041F=%s, 0001041F=%s\n", szX0000041F, szX0001041F);

    }

    else {
	    printf("Error = %d\n", GetLastError());
	    return ResultTurkishKeyboardFailure;
    }

    return rc;
}

int
tmain(
    IN int   argc,
    IN PTSTR argv[]
    )
{
    RESULTCODE result;

    //
    // Check arguments.
    //
    if((argc < 2)
    || ((argv[1][0] != TEXT('-')) && (argv[1][0] != TEXT('/')))) {

        return(ResultInvalidArgs);
    }

    //
    // See whether we are supposed to set a win.ini value.
    //
    if(!lstrcmpi(argv[1]+1,TEXT("winini"))) {

        result = (argc == 5)
               ? (WriteProfileString(argv[2],argv[3],argv[4]) ? ResultSuccess
                                                              : ResultWinIniFailure)
               : ResultInvalidArgs;

    //
    // See whether we are supposed to create a new userdef hive.
    //
    }
    else if(!lstrcmpi(argv[1]+1,TEXT("userdef"))) {

	result = DoNewUserDef();

    }
    else if(!lstrcmpi(argv[1]+1,TEXT("PatchTurkishKeyb"))) {

	result = PatchTurkishDosKeybIDs();

    }
    else {

	//
	// Unknown operation.
	//
	result = ResultInvalidArgs;
    }

    return(result);
}



int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    return(tmain(argc,argv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\addprot.h ===
/*were  not defined but called from initcode.c */

BOOL PrintFileInit();
int PrintFileShutDown ();
VOID sizeFkeys(LONG clientSize);
VOID initChildSize(RECT *pRect);
VOID setDefaultAttrib(BOOL bLoad);
VOID initDlgPos(HWND hDlg);
VOID initComDevSelect(HWND hDlg, WORD wListID, BOOL bInit);
BYTE getComDevSelect(HWND hDlg, WORD wListID, BYTE *newDevRef);
BOOL getFileType(BYTE *fileName, BYTE *fileExt);
VOID taskInit();
VOID keyMapInit();
BOOL termInitSetup(HANDLE hPrevInstance);
VOID forceExtension(BYTE *fileName, BYTE *fileExt, BOOL bReplace);
BOOL termFile(BYTE *filePath,BYTE *fileName,BYTE *fileExt,BYTE *title,WORD flags);
VOID sizeTerm(LONG termSize);
VOID keyMapCancel();

/*****************/

/* were not defined but called from winmain.c */

VOID xSndBFile();
VOID xRcvBFile();

/**************/

/* were not defined but called from winmain.c*/

void myDrawIcon(HDC hDC, BOOL bErase);
VOID PrintFileComm(BOOL bPrint);
BOOL termCloseAll(VOID);
int flashIcon(BOOL bInitFlash, BOOL bEndProc);
WORD childZoomStatus(WORD wTest, WORD wSet);
VOID initMenuPopup(WORD menuIndex);
BOOL keyMapTranslate(WORD *wParam, LONG *lParam, TERM_STRING *mapStr);
BOOL fKeyStrBuffer(BYTE *str,WORD  len);
BOOL keyMapSysKey(HWND hWnd, WORD *wParam, LONG lParam);
VOID longToPoint(long sel, POINT *pt);

VOID keyMapKeyProc(HWND hWnd, WORD wParam, LONG lParam);
BOOL termCloseFile(VOID);
VOID hpageScroll(int which);



VOID PrintFileString(LPSTR lpchr,LONG  count, BOOL bCRtoLF);
BOOL PrintFileOn(HANDLE theInstance,HWND theWnd,
LPSTR thePrintName,LPSTR thePrintType,LPSTR thePrintDriver,
LPSTR thePrintPort,BOOL showDialog);
BOOL PrintFileOff();
int PrintFileLineFeed (BOOL nextLine);
int PrintFilePageFeed ();


BOOL termSaveFile(BOOL bGetName);


int testMsg(BYTE *str, int arg0,int  arg1,int  arg2, int arg3,int  arg4,int  arg5,int  arg6, int arg7,
                 int arg8, int arg9, int arga, int argb, int argc, int argd, int arge, int argf);


VOID xferStopBreak(BOOL bStop);

VOID xferPauseResume(BOOL bPause, BOOL bResume);

int selectFKey(WORD wIDFKey);

BOOL sendKeyInput(BYTE theByte);

VOID sndAbort  ();

int countChildWindows(BOOL bUnzoom);

VOID stripBlanks (LPBYTE ptr, DWORD *len);

VOID doFileNew();

VOID doFileOpen();
VOID doFileClose();
VOID doFileSave();
VOID doFileSaveAs();

VOID stripControl(TERM_STRING *str);
int TF_ErrProc(WORD, WORD, WORD);


BOOL XM_RcvFile(WORD);
BOOL FAR KER_Receive(BOOL bRemoteServer);
VOID listFontSizes(BYTE *faceName, BYTE *sizeList, int maxSize);

int updateIcon();
BOOL XM_SndFile(WORD);
BOOL FAR KER_Send();
VOID setAppTitle();


VOID icsResetTable(WORD icsType);
VOID rcvFileErr();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\asm2c_32.c ===
/************************************************************************
 *                                                                      *
 *  Copyright (c) 1991                                                  *
 *  by Future Soft Engineering, Inc.,  Houston, Texas                   *
 *                                                                      *
 *  The information in this software  is  subject  to  change  without  *
 *  notice  and  should not be construed as a commitment by Future Soft *
 *  Engineering Incorporated.                                           *
 *                                                                      *
 ************************************************************************
 * 
 * ABSTRACT:   About dialog box processing
 *
 * AUTHOR:     BJW
 *
 * CREATION DATE: 91/10/05
 *
 * REVISION HISTORY: $Log:	asm2c_32.c $
 * Revision 1.1  92/04/06  16:10:25  rjs
 * Initial revision
 * 
 *
 */

#include "winrev.h"
#include <windows.h>
#include "port1632.h"
#include <dos.h>
#include <stdlib.h>
#include "dcrc.h"
#include "dynacomm.h"                  // dwb KtoA   STRING + ?
#include "fileopen.h"                   // dwb KtoA

LONG fileLength(INT hFile)
{
   LONG lPointerNow;
   LONG lFileLength;

   lPointerNow = _llseek(hFile, 0L, 1);
   lFileLength = _llseek(hFile, 0L, 2);

   _llseek(hFile, lPointerNow, 0);

   return(lFileLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\asm2c_32.h ===
//
// Prototypes for: asm2c_32.c
//


LONG fileLength(INT hFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\datestuf.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#include "winrev.h"
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"

#include  <io.h>     /* added for get_osfhandle crt -sdj*/

static INT dayTable[2][13] = 
{
   {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
   {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};


/*-------------- >>> Routines Specific to Windows Start Here <<< ------------*/

/*---------------------------------------------------------------------------*/
/* getDateTime() - Set a long int to number of elapsed seconds since  [scf]  */
/*                 January 1, 1904.  (Mimic the MAC funtion)                 */
/*---------------------------------------------------------------------------*/

VOID getDateTime (LONG *elapsedSecs)
{
   DOSTIME present;

   readDateTime (&present);
   date2secs (&present, elapsedSecs);
}


/*---------------------------------------------------------------------------*/
/* date2secs() - Convert a date found in DOSTIME struct to elapsed seconds   */
/*               since January 1, 1904.  (Mimic the MAC)             [scf]   */
/*---------------------------------------------------------------------------*/

VOID date2secs (DOSTIME *date, LONG *elapsedSecs)
{
#ifdef ORGCODE
   INT  year;
   INT  month;
   INT  leapYear;
#else
   WORD  year;
   WORD  month;
   WORD  leapYear;
#endif



   *elapsedSecs = 0l;
   for (year = 1904; year < date->yy; year++)
   {
      leapYear = year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
      for (month = 1; month <= 12; month++)
         *elapsedSecs += (LONG) dayTable[leapYear][month] * SECS_IN_A_DAY;
   }
   leapYear = date->yy % 4 == 0 && date->yy % 100 != 0 || date->yy % 400 == 0;
   for (month = 1; month < date->mm; month++)
      *elapsedSecs += (LONG) dayTable[leapYear][month] * SECS_IN_A_DAY;
   *elapsedSecs += (LONG) (date->dd-1) *SECS_IN_A_DAY;
   *elapsedSecs += (LONG) date->hour *60*60;
   *elapsedSecs += (LONG) date->minute * 60;
   *elapsedSecs += (LONG) date->second;
}



/*---------------------------------------------------------------------------*/
/* secs2date() - Sets DOSTIME struct (except dayOfWeek) according to the     */
/*               number of elapsed  seconds since January 1, 1904.     [scf] */
/*---------------------------------------------------------------------------*/

VOID secs2date (LONG secs, DOSTIME *date)
{
   register  INT  year;
             INT  month;
             INT  day;
             INT  hour;
             INT  minute;
             INT  leapYear;
             INT  daysPerYear[2];

           DWORD  usecs;

   daysPerYear[0] = DAYS_IN_A_YEAR;
   daysPerYear[1] = DAYS_IN_A_YEAR + (leapYear = 1);

   usecs = (DWORD) secs;
   year = 1904;
   while (usecs >= (DWORD) daysPerYear[leapYear] * SECS_IN_A_DAY)
   {
      usecs -= (DWORD) daysPerYear[leapYear] * SECS_IN_A_DAY;
      year++;
      leapYear = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) ? 1 : 0;
   }
   secs = (LONG) usecs;
   for (month = 1; secs >= (LONG) dayTable[leapYear][month] *SECS_IN_A_DAY; 
         month++)
      secs -= (LONG) dayTable[leapYear][month] *SECS_IN_A_DAY;
   for (day = 1; secs >= SECS_IN_A_DAY; day++)
      secs -= SECS_IN_A_DAY;
   for (hour = 0; secs >= 60*60; hour++)
      secs -= 60 * 60;
   for (minute = 0; secs >= 60; minute++)
      secs -= 60;

   date->yy        = (WORD)year;
   date->mm        = (WORD)month;
   date->dd        = (WORD)day;
   date->dayOfWeek = DONTCARE;
   date->hour      = (WORD)hour;
   date->minute    = (WORD)minute;
   date->second    = (INT) secs;
}


VOID readDateTime(DOSTIME *pDosTime)
{

SYSTEMTIME NtSystemTime;

/************

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

***************/

/********************

typedef
   struct {
             WORD  hour;
             WORD  minute;
             WORD  second;
             WORD  dayOfWeek;
             WORD  mm;
             WORD  dd;
             WORD  yy;
          }  DOSTIME;

*************************/

DEBOUT("readDateTime:%s\n","Calling GetSystemTime()");

// GetSystemTime(&NtSystemTime);
// -sdj this time will not make sense, have to use
// -sdj GetLocalTime instead, this is due to Zone,Bias,UTC and all
// -sdj the other complicated things I have to learn sometime!


GetLocalTime(&NtSystemTime);

pDosTime->hour =        NtSystemTime.wHour;
pDosTime->minute =      NtSystemTime.wMinute;
pDosTime->second =      NtSystemTime.wSecond;
pDosTime->dayOfWeek =   NtSystemTime.wDayOfWeek;
pDosTime->mm =          NtSystemTime.wMonth;
pDosTime->dd =          NtSystemTime.wDay;
pDosTime->yy =          NtSystemTime.wYear;

}


VOID getFileDate(DOSTIME *pDosTime, int fh)
{
//BOOL	    bRc;
//HANDLE     hFile;
//FILETIME   CrTime,AccTime,WrTime;
SYSTEMTIME SysTime;

DEBOUT("getFileDate: UNDEF!! %s\n","converting the crt fh to os fh using get_osfhandle");

/* hFile = get_osfhandle(fh); */

DEBOUT("getFileDate: UNDEF!! got os fh as %lx\n", hFile);

/* DEBOUT("getFileDate: %s\n","calling GetFileTime , for LastWrTime"); */

/* bRc = GetFileTime(hFile,&CrTime,&AccTime,&WrTime); */

/* DEBOUT("getFileDate: GetFileTime Rc= %lx\n conv to SystemTime",bRc); */

/* bRc = FileTimeToSystemTime(&WrTime,&SysTime); */

/* DEBOUT("getFileDate: FileTimeToSystemTime Rc= %lx\n store in DosTime",bRc); */

DEBOUT("getFileDate: HACK %s\n","calling sys time instead of filetime for now");
GetSystemTime(&SysTime);

pDosTime->hour =        SysTime.wHour;
pDosTime->minute =      SysTime.wMinute;
pDosTime->second =      SysTime.wSecond;
pDosTime->dayOfWeek =   SysTime.wDayOfWeek;
pDosTime->mm =          SysTime.wMonth;
pDosTime->dd =          SysTime.wDay;
pDosTime->yy =          SysTime.wYear;

}


#ifdef OLDCODE
VOID lmovmem(LPSTR lpsrc,LPSTR lpdst, WORD wCount)
{
   LPBYTE TmpSrc,TmpDst;
   WORD i;

   TmpSrc = (LPBYTE)lpsrc;
   TmpDst = (LPBYTE)lpdst;


   for (i=0; i< wCount; i++)
   {
      *TmpDst = *TmpSrc;
      TmpDst++;TmpSrc++;
   }
}

VOID lsetmem(LPSTR str,BYTE ch,WORD wCount)
{
   WORD i;
   LPSTR tmp;

   tmp = str;

   for (i=0; i < wCount; i++)
   {
      *tmp = ch;
      tmp++;
   }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcdata.h ===
procPtr pProcTable[] = 
{
   /* 0 */    pNullState,          /* 00h */
   /* 1 */    pCursorState,        /* 01h */
   /* 2 */    pCursHome,           /* 02h */
   /* 3 */    pClrScr,             /* 03h */
   /* 4 */    pClrEol,             /* 04h */
   /* 5 */    pClrEop,             /* 05h */
   /* 6 */    pLinIns,             /* 06h */
   /* 7 */    pLinDel,             /* 07h */
   /* 8 */    pCursToggle,         /* 08h */
   /* 9 */    pCursUp,             /* 09h */
   /* 10 */   pCursDn,             /* 0ah */
   /* 11 */   pCursRt,             /* 0bh */
   /* 12 */   pCursLt,             /* 0ch */
   /* 13 */   pCursOff,            /* 0dh */
   /* 14 */   pCursOn,             /* 0eh */
   /* 15 */   pNullState,          /* 0fh */
   /* 16 */   pReverseOff,         /* 10h */
   /* 17 */   pReverseOn,          /* 11h */
   /* 18 */   pCmpSrvResponse,     /* 12h */
   /* 19 */   pSndCursor,          /* 13h */
   /* 20 */   pInquire,            /* 14h */
   /* 21 */   pNextLine,           /* 15h */
   /* 22 */   pRevIndex,           /* 16h */
   /* 23 */   pDecScs,             /* 17h */
   /* 24 */   pSetMode,            /* 18h */
   /* 25 */   pSetTab,             /* 19h */
   /* 26 */   pClearTab,           /* 1ah */
   /* 27 */   pTab,                /* 1bh */
   /* 28 */   aSetScrRgn,          /* 1ch */
   /* 29 */   pCharDel,            /* 1dh */
   /* 30 */   pInsChar,            /* 1eh */
   /* 31 */   pClearAllTabs,       /* 1fh */
   /* 32 */   pEscSkip,            /* 20h */
   /* 33 */   pVPosState,          /* 21h */
   /* 34 */   pHPosState,          /* 22h */
   /* 35 */   pLAttrState,         /* 23h */
   /* 36 */   pClrBop,             /* 24h */
   /* 37 */   pClrBol,             /* 25h */
   /* 38 */   pClrLine,            /* 26h */
   /* 39 */   pNullState,          /* 27h */
   /* 40 */   pSaveCursorPos,      /* 28h */
   /* 41 */   pRestoreCursorPos,   /* 29h */
   /* 42 */   pAnsiState,          /* 2ah */
   /* 43 */   pGrState,            /* 2bh */
   /* 44 */   pVT100H,             /* 2ch */
   /* 45 */   pVT100D,             /* 2dh */
   /* 46 */   pVT100M,             /* 2eh */
   /* 47 */   pVT100c,             /* 2fh */
   /* 48 */   pDCSTerminate,       /* 30h */
   /* 49 */   pProtOn,             /* 31h */
   /* 50 */   pProtOff,            /* 32h */
   /* 51 */   pClrAll,             /* 33h */
   /* 52 */   pPrintOn,            /* 34h */
   /* 53 */   pPrintOff,           /* 35h */
   /* 54 */   pVT100P,             /* 36h */
   /* 55 */   pVideoAttribState,   /* 37h */
   /* 56 */   pCursorOnOffState,   /* 38h */
   /* 57 */   pAnswerBack,         /* 39h */
   /* 58 */   pEchoOff,            /* 3Ah */
   /* 59 */   pEchoOn,             /* 3Bh */
   /* 60 */   pCR,                 /* 3Ch */
   /* 61 */   pLF,                 /* 3Dh */
   /* 62 */   pBackSpace,          /* 3Eh */
   /* 63 */   pBeep,               /* 3Fh */
   /* 64 */   pBegProtect,         /* 40h */          /* mbbx 1.03: TV925... */
   /* 65 */   pEndProtect,         /* 41h */
   /* 66 */   pBegGraphics,        /* 42h */
   /* 67 */   pEndGraphics,        /* 43h */
   /* 68 */   pSetStatusLine,      /* 44h */
   /* 69 */   pNullState,          /* 45h */          /* mbbx 1.10: VT220 8BIT */
   /* 70 */   pSetCtrlBits,        /* 46h */          /* mbbx 1.10: VT220 8BIT */
   /* 71 */   pTransPrint,         /* 47h */          /* mbbx 2.01.32 */
};


procPtr aProcTable[] = 
{
   /* 0 */    pNullState,     /* 00h */
   /* 1 */    aCursor,        /* 01h */
   /* 2 */    pNullState,     /* 02h */
   /* 3 */    pNullState,     /* 03h */
   /* 4 */    aClrEol,        /* 04h */
   /* 5 */    aClrEop,        /* 05h */
   /* 6 */    aInsLin,        /* 06h */
   /* 7 */    aDelLin,        /* 07h */
   /* 8 */    pNullState,     /* 08h */
   /* 9 */    aCursUp,        /* 09h */
   /* 10 */   aCursDn,        /* 0ah */
   /* 11 */   aCursRt,        /* 0bh */
   /* 12 */   aCursLt,        /* 0ch */
   /* 13 */   pNullState,     /* 0dh */
   /* 14 */   pNullState,     /* 0eh */
   /* 15 */   aVideo,         /* 0fh */
   /* 16 */   pNullState,     /* 10h */
   /* 17 */   pNullState,     /* 11h */
   /* 18 */   pNullState,     /* 12h */
   /* 19 */   aReport,        /* 13h */
   /* 20 */   pInquire,       /* 14h */
   /* 21 */   pNullState,     /* 15h */
   /* 22 */   pNullState,     /* 16h */
   /* 23 */   pNullState,     /* 17h */
   /* 24 */   aSetMode,       /* 18h */
   /* 25 */   pNullState,     /* 19h */
   /* 26 */   aClearTabs,     /* 1ah */
   /* 27 */   pNullState,     /* 1bh */
   /* 28 */   aSetScrRgn,     /* 1ch */
   /* 29 */   aDelChar,       /* 1dh */
   /* 30 */   pNullState,     /* 1eh */
   /* 31 */   pNullState,     /* 1fh */
   /* 32 */   pEscSkip,       /* 20h */
   /* 33 */   pNullState,     /* 21h */
   /* 34 */   pNullState,     /* 22h */
   /* 35 */   pNullState,     /* 23h */
   /* 36 */   pNullState,     /* 24h */
   /* 37 */   pNullState,     /* 25h */
   /* 38 */   pNullState,     /* 26h */
   /* 39 */   pNullState,     /* 27h */
   /* 40 */   pNullState,     /* 28h */
   /* 41 */   pNullState,     /* 29h */
   /* 42 */   pNullState,     /* 2ah */
   /* 43 */   pNullState,     /* 2bh */
   /* 44 */   pVT100H,        /* 2ch */
   /* 45 */   pVT100D,        /* 2dh */
   /* 46 */   pVT100M,        /* 2eh */
   /* 47 */   pVT100c,        /* 2fh */
   /* 48 */   pDCSTerminate,       /* 30h */     /* mbbx: are these ANSI ??? */
   /* 49 */   pProtOn,             /* 31h */
   /* 50 */   pProtOff,            /* 32h */
   /* 51 */   pClrAll,             /* 33h */
   /* 52 */   pPrintOn,            /* 34h */
   /* 53 */   pPrintOff,           /* 35h */
   /* 54 */   pVT100P,             /* 36h */
   /* 55 */   pVideoAttribState,   /* 37h */
   /* 56 */   pCursorOnOffState,   /* 38h */
   /* 57 */   pNullState,          /* 39h */
   /* 58 */   pNullState,          /* 3Ah */
   /* 59 */   pNullState,          /* 3Bh */
   /* 60 */   pNullState,          /* 3Ch */
   /* 61 */   pNullState,          /* 3Dh */
   /* 62 */   pNullState,          /* 3Eh */
   /* 63 */   pNullState,          /* 3Fh */
   /* 64 */   pNullState,          /* 40h */          /* mbbx 1.03: TV925... */
   /* 65 */   pNullState,          /* 41h */
   /* 66 */   pNullState,          /* 42h */
   /* 67 */   pNullState,          /* 43h */
   /* 68 */   pNullState,          /* 44h */
   /* 69 */   aSetCompLevel,       /* 45h */          /* mbbx 1.10: VT220 8BIT */
   /* 70 */   pNullState,          /* 46h */          /* mbbx 1.10: VT220 8BIT */
   /* 71 */   pTransPrint,         /* 47h */          /* mbbx 2.01.32 */
};


procPtr ansiParseTable[] =
{
      ansiArgument,          /*  '0'  */
      ansiArgument,          /*  '1'  */
      ansiArgument,          /*  '2'  */
      ansiArgument,          /*  '3'  */
      ansiArgument,          /*  '4'  */
      ansiArgument,          /*  '5'  */
      ansiArgument,          /*  '6'  */
      ansiArgument,          /*  '7'  */
      ansiArgument,          /*  '8'  */
      ansiArgument,          /*  '9'  */
      pNullState,            /*  ':'  */
      ansiDelimiter,         /*  ';'  */
      pNullState,            /*  '<'  */
      pNullState,            /*  '='  */
      ansiHeathPrivate,      /*  '>'  */
      ansiDecPrivate,        /*  '?'  */
};


BYTE ansiXlateTable[256] =                   /* mbbx 1.06A: ics new xlate... */
{
   0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,    /* ANSI -> ASCII */
   0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
   0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
   0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
   0xA0, 0xAD, 0x9B, 0x9C, 0xA4, 0x9D, 0xA6, 0xA7,
   0xA8, 0xA9, 0xA6, 0xAE, 0xAC, 0xAD, 0xAE, 0xAF,
   0xF8, 0xF1, 0xFD, 0xB3, 0xB4, 0xE6, 0xB6, 0xFA,
   0xB8, 0xB9, 0xA7, 0xAF, 0xAC, 0xAB, 0xBE, 0xA8,
   0xC0, 0xC1, 0xC2, 0xC3, 0x8E, 0x8F, 0x92, 0x80,
   0xC8, 0x90, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
   0xD0, 0xA5, 0xD2, 0xD3, 0xD4, 0xD5, 0x99, 0xD7,
   0xED, 0xD9, 0xDA, 0xDB, 0x9A, 0xDD, 0xDE, 0xE1,
   0x85, 0xA0, 0x83, 0xE3, 0x84, 0x86, 0x91, 0x87,
   0x8A, 0x82, 0x88, 0x89, 0x8D, 0xA1, 0x8C, 0x8B,
   0xEB, 0xA4, 0x95, 0xA2, 0x93, 0xF5, 0x94, 0xF7,
   0xF8, 0x97, 0xA3, 0x96, 0x81, 0xFD, 0xFE, 0x98,

   0xC7, 0xFC, 0xE9, 0xE2, 0xE4, 0xE0, 0xE5, 0xE7,    /* ASCII -> ANSI */
   0xEA, 0xEB, 0xE8, 0xEF, 0xEE, 0xEC, 0xC4, 0xC5,
   0xC9, 0xE6, 0xC6, 0xF4, 0xF6, 0xF2, 0xFB, 0xF9,
   0xFF, 0xD6, 0xDC, 0xA2, 0xA3, 0xA5, 0x7F, 0x7F,
   0xE1, 0xED, 0xF3, 0xFA, 0xF1, 0xD1, 0xAA, 0xBA,
   0xBF, 0xA9, 0xAA, 0xBD, 0xBC, 0xA1, 0xAB, 0xBB,
   0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
   0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
   0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
   0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
   0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
   0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
   0xE0, 0xDF, 0xE2, 0xE3, 0xE4, 0xE5, 0xB5, 0xE7,
   0xE8, 0xE9, 0xEA, 0xF0, 0xEC, 0xD8, 0xEE, 0xEF,
   0xF0, 0xB1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
   0xB0, 0xF9, 0xB7, 0xFB, 0xFC, 0xB2, 0xFE, 0xFF,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcrc.h ===
/* ------- itrc.h defines dialog item lists and resource names --------- */

#define ICO_STOP           1
#define ICO_NOTE           2
#define ICO_CAUTION        3
#define ICO_QUESTION       4
#define ICO_DYNACOMM       255


/* String table constants */

#define STR_APPNAME        0x0001
#define STR_DEVELOPER      0x0002
#define STR_TERMINAL       0x0003
#define STR_SCRIPT         0x0004
#define STR_MEMO           0x0005
#define STR_ERRCAPTION     0x0006
#define STR_FATALERROR     0x0007
#define STR_TASKERROR      0x0008
#define STR_CREATEFILE     0x0009
#define STR_APPNAME_PRIVATE 0x000A /* jtf terminal */
#define STR_EXTRAINFO      0x000B

#define STR_VERSION        0x0021
#define STR_ICONLIBFILE    0x0022
#define STR_AUTOEXEC       0x0023
#define STR_AUTOLOAD       0x0024
#define STR_HELPFILE       0x0025
#define STR_BUILDFILE      0x0026
#define STR_TEMPFILE       0x0027
#define STR_COM            0x0028
#define STR_PATH           0x0029            /* mbbx 1.04: REZ... */
#define STR_COMMAND        0x002A
#define STR_MORE           0x002B

#define STR_PHONE          0x0041
#define STR_DIALPREFIX     0x0042
#define STR_DIALSUFFIX     0x0043
#define STR_HANGPREFIX     0x0044
#define STR_HANGSUFFIX     0x0045
#define STR_ANSWER         0x0046
#define STR_ORIGINATE      0x0047
#define STR_XFERLINESTR    0x0048
#define STR_ANSWERBACK     0x0049

#define STR_HIDETERMINAL   0x0061
#define STR_SHOWTERMINAL   0x0062
#define STR_HIDEFKEYS      0x0063
#define STR_SHOWFKEYS      0x0064
#define STR_STOP           0x0065            /* mbbx 2.00: xfer ctrls... */
#define STR_BREAK          0x0066
#define STR_PAUSE          0x0067
#define STR_RESUME         0x0068

#define STR_SAVE           0x0081
#define STR_SAVEAS         0x0082
#define STR_DELETE         0x0083
#define STR_PRINT          0x0084
#define STR_MERGE          0x0085
#define STR_SENDTEXTFILE   0x0086
#define STR_VIEWTEXTFILE   0x0087
#define STR_COMPILE        0x0088
#define STR_EXECUTE        0x0089
#define STR_EDIT           0x008A            /* mbbx 1.04: REZ... */
#define STR_LOAD           0x008B
#define STR_CREATE         0x008C

#define STR_RETRIES        0x00A1
#define STR_BYTECOUNT      0x00A2
#define STR_SENDING        0x00A3
#define STR_RECEIVING      0x00A4
#define STR_VIEWING        0x00A5
#define STR_FILENAME       0x00A6            /* mbbx 1.04: REZ... */
#define STR_DIRECTORY      0x00A7
#define STR_TO             0x00A8
#define STR_TOPIC          0x00A9
#define STR_LEVEL          0x00AA  /* jtf 3.Final */

#define STR_STOPTASK       0x0101
#define STR_STOPXFER       0x0102
#define STR_SAVECHANGES    0x0103
#define STR_OTHERCOM       0x0104
#define STR_OVERWRITEFILE  0x0105
#define STR_DELETING       0x0106            /* mbbx 1.04: REZ... */
#define STR_AREYOUSURE     0x0107
#define STR_XOFFSTATE      0x0108
#define STR_COMPILEOK	   0x0109
#define STR_TELNETFAIL	   0x010A // sdj: added this msg if telnet open fails
#define STR_SETCOMFAIL	   0x010B // sdj: added this msg if setcomstate fails

#define STR_NOCOMMPORTS    0x0181
#define STR_COMMNOTREADY   0x0182
#define STR_HANGUP         0x0183
#define STR_RETRYCOUNT     0x0184
#define STR_ABORTSND       0x0185
#define STR_ABORTRCV       0x0186
#define STR_LOADEMUL       0x0187            /* mbbx 1.04: REZ... */
#define STR_OUTOFMEMORY    0x0188
#define STR_COULDNOTEXEC   0x0189

#define STR_MINTIME        0x018A            /* jtf 3.20 */
#define STR_NOMEMORY	      0x018B
#define STR_PORTDISCONNECT 0x018C     // -sdj for telnet-quit processing

#define STREWRERR          0x01E1
#define STRFNOTFOUND       0x01E2
#define STRFINVALIDNAME    0x01E3
#define STRFERROPEN        0x01E4
#define STRFERRREAD        0x01E5
#define STRFERRFILELENGTH  0x01E6
#define STRFERRCLOSE       0x01E7
#define STRERRHANGUP       0x01E8
#define STRERRNOFILE       0x01E9
#define STRERRNOTIMERS     0x01EA   /* rjs bugs 006 */
#define STR_PRINTERROR     0x01EB   /* rjs bugs 013 */
#define STRDRIVEDIR	      0X01EC	

#define STR_INI_WINDOWS          0x0221
#define STR_INI_DEVICE           0x0222
#define STR_INI_EXTENSIONS       0x0223
#define STR_INI_COLORS           0x0224
#define STR_INI_WINDOW           0x0225
#define STR_INI_BKGDCOLOR        0x0226
#define STR_INI_WINDOWTEXT       0x0227
#define STR_INI_TEXTCOLOR        0x0228
#define STR_INI_INTL             0x0229
#define STR_INI_ICOUNTRY         0x022A
#define STR_INI_IDATE            0x022B
#define STR_INI_ITIME            0x022C
#define STR_INI_S1159            0x022D
#define STR_INI_S2359            0x022E
#define STR_INI_SDATE            0x022F
#define STR_INI_STIME            0x0230
#define STR_INI_PORTS            0x0231
#define STR_INI_DEVICES          0x0232
#define STR_INI_ON               0x0233
#define STR_INI_DEVICEMODE       0x0234
#define STR_INI_POSITION         0x0235
#define STR_INI_MAXIMIZED        0x0236
#define STR_INI_PORT             0x0237
#define STR_INI_SWAP             0x0238
#define STR_INI_SYSTEM           0x0239      /* mbbx 2.01.157 */
#define STR_INI_SETTINGS         0x023A
#define STR_INI_SCRIPT           0x023B
#define STR_INI_TASK             0x023C
#define STR_INI_MEMO             0x023D
#define STR_INI_DATA             0x023E
#define STR_INI_BUFFER           0x023F
#define STR_INI_FONT             0x0240
#define STR_INI_FONTFACE         0x0241
#define STR_INI_POINTER          0x0242 /* jtf gold 070 */
#define STR_INI_CONNECTORS       0x0243      /* slc nova 012 bjw gold 027 */
#define STR_INI_EMULOTHER        0x0244      /* slc nova 048 */
#define STR_INI_LISTBOXFONT      0x0245      /* slc nova 049 */
#define STR_INI_DCFKEYFONT	 0x0246      /* slc swat */
#define	STR_INI_XPOSITION	 0x0247	     /* sdj: added these so that terminal   */
#define	STR_INI_YPOSITION	 0x0248	     /* sdj: can remember the prev pos/size */
#define	STR_INI_WIDTH		 0x0249	     /* sdj: set by the user and use them in*/
#define	STR_INI_HEIGHT		 0x0250      /* sdj: CreateWindow arguments	    */


#define STR_FI                   0x0261
#define STR_RF                   0x0262
#define STR_DF                   0x0263
#define STR_RI                   0x0264
#define STR_RE                   0x0265
#define STR_SI                   0x0266
#define STR_SE                   0x0267


#define STR_KER_BADPACKET     0x02D1         /* mbbx 1.04: REZ... */
#define STR_KER_BADPACKNUM    0x02D2
#define STR_KER_RETRYABORT    0x02D3
#define STR_KER_SNDABORT      0x02D4
#define STR_KER_RCVABORT      0x02D5
#define STR_KER_CREATEFILE    0x02D6
#define STR_KER_XFERABORT     0x02D7
#define STR_KER_BADPACKTYPE   0x02D8
#define STR_KER_BADHOSTCMD    0x02DA
#define STR_KER_NEWPATH       0x02DC
#define STR_KER_BADPATH       0x02DD
#define STR_KER_BADDIRSPEC    0x02DE
#define STR_KER_DISKSPACE     0x02DF
#define STR_KER_GETDISKSPACE  0x02E0
#define STR_KER_DELETED       0x02E1
#define STR_KER_DELETEFILE    0x02E2
#define STR_KER_RENAMED       0x02E3
#define STR_KER_RENAMEFILE    0x02E4
#define STR_KER_COPIED        0x02E5
#define STR_KER_COPYFILE      0x02E6
#define STR_KER_HELP          0x02E7
#define STR_KER_BADCOMMAND    0x02E8
#define STR_KER_FILECOUNT     0x02E9
#define STR_KER_WHO           0x02ED         /* rkhx 2.00 */


/*- Added 02/13/91 Doug Wickstrom- for win 3.1 common dialog support -----*/
#define STR_FILTERTRM		0X02EE
#define STR_FILTERTXT		0X02EF
#define STR_FILTERALL		0X02F0


/* 0x0300 - reserved for FILEOPEN.RC */
/* 0x0400 - reserved for EDITFILE.RC */

#define STR_ERC_LIST       0x0800
#define STR_ERT_LIST       0x0C00

#define STR_NERR_LIST      0x0D00            /* mbbx 2.00: network... */
#define STR_MYNERR_LIST    0x0F00

#define STR_DIRS_LIST      0x1000
#define STR_CMDS_LIST      0x1100

#define STR_DLGS_LIST      0x2000
#define STR_EDITS_LIST     0x2100
#define STR_FILES_LIST     0x2200
#define STR_KEYS_LIST      0x2300            /* mbbx 1.04 */
#define STR_KBDS_LIST      0x2400
#define STR_MENUS_LIST     0x2500
#define STR_NETS_LIST      0x2580            /* mbbx 2.00: network */
#define STR_PRTS_LIST      0x2600
#define STR_RECS_LIST      0x2700
#define STR_SLCTS_LIST     0x2800
#define STR_SETS_LIST      0x2900
#define STR_STNGS_LIST     0x2A00
#define STR_TBLS_LIST      0x2B00
#define STR_VIDS_LIST      0x2C00            /* mbbx 1.03 */
#define STR_WAITS_LIST     0x2D00
#define STR_WHENS_LIST     0x2E00
#define STR_WNDS_LIST      0x2F00

#define STR_BINS_LIST      0x3000
#define STR_CNCTS_LIST     0x3100            /* mbbx 2.00: network */
#define STR_ICSS_LIST      0x3200
#define STR_DOCS_LIST      0x3300
#define STR_MDMS_LIST      0x3400
#define STR_PTRS_LIST      0x3500
#define STR_TERMS_LIST     0x3600
#define STR_TEXTS_LIST     0x3700
#define STR_OPTS_LIST      0x3800

#define STR_STRS_LIST      0x4000
#define STR_INTS_LIST      0x4100
#define STR_BOOLS_LIST     0x4200
#define STR_MISCS_LIST     0x4300
#define STR_EVALS_LIST     0x4400            /* mbbx 1.04: REZ... */

#define STR_ICS_NAME       0x5000            /* mbbx 1.04: ics */
#define STR_ICS_DATA       0x5020            /* mbbx 1.04: ics */
#define STR_COM_CONNECT    0x5080            /* mbbx 2.00 ... */
#define STR_MDM_HAYES      0x5100            /* mbbx 1.10: CUA... */
#define STR_MDM_TELEBIT    0x5120
#define STR_MDM_MNP        0x5140
#define STR_MDM_NONE       0x5160

/*----------------------------- Menu Commands -----------------------*/

#define POPUPMENUCOUNT     6                 /* mbbx 2.00: CUA 8 -> 9 */

#define FILEMENU           0
#define FMNEW              0x0101
#define FMOPEN             0x0102
#define FMCLOSE            0x0103
#define FMSAVE             0x0111
#define FMSAVEAS           0x0112
#define FMDELETE           0x0113
#define FMPRINT            0x0121
#define FMPRINTSETUP       0x0122
#define FMPRINTER          0x0131
#define FMTIMER            0x0132
#define FMMONITOR          0x0133
#define FMEXIT             0x01FF            /* mbbx 1.10: CUA */

#define EDITMENU           1
#define EMUNDO             0x0201
#define EMSELECTALL        0x0211
#define EMCUT              0x0221
#define EMCOPY             0x0222
#define EMPASTE            0x0223
#define EMCLEAR            0x0224
#define EMCOPYTABLE	      0x0225
#define EMCOPYBITMAP       0x0226
#define EMCOPYSPECIAL      0x022F            /* mbbx 2.00: CUA */
#define EMSETMARGIN        0x0231
#define EMSETTABWIDTH      0x0232            /* mbbx 2.00: CUA */
#define EMREFORMAT         0x0233
#define EMALIGN            0x0234
#define EMCENTER           0x0235
#define EMMERGE            0x0236
#define EMCOPYTHENPASTE    0x0241
#define EMSAVESELECT       0x0242
#define EMPRINTSELECT      0x0243
#define EMSAVESCREEN       0x0251

#define SETTINGSMENU       2
#define SMPHONE            0x0401
#define SMEMULATE          0x0402
#define SMTERMINAL         0x0403
#define SMFUNCTIONKEYS     0x0404
#define SMTEXTXFERS        0x0405
#define SMBINXFERS         0x0406
#define SMCOMMUNICATIONS   0x0407
#define SMMODEM            0x0408
#define WMFKEYS            0x0812

#define PHONEMENU          3
#define PMDIAL             0x0501
#define PMHANGUP           0x0502
#define PMWAITFORCALL      0x0503
#define PMREMOTEKERMIT     0x0511

#define TRANSFERMENU       4
#define TMSENDTEXTFILE     0x0601
#define TMRCVTEXTFILE      0x0602
#define TMVIEWTEXTFILE     0x0603
#define TMSENDBINFILE      0x0611
#define TMRCVBINFILE       0x0612
#define TMPAUSE            0x0621
#define TMRESUME           0x0622
#define TMSTOP             0x0623

#define HELPMENU           5
#define HMINDEX            0xFFFF
#define HMKEYBOARD         0x001E
#define HMMOUSE            0x001F
#define HMCOMMANDS         0x0020
#define HMPROCEDURES       0x0021
#define HMHELP             0xFFFC
#define HMABOUT            0x09FF
#define HMSEARCH           0x0105


/*---------------------------- Dialog Boxes -------------------------*/

/* standard item numbers */
#define ITMOK       1
#define ITMCANCEL   2

#define IDDBABOUT    99

#define IDDBSIGNON          87

/* Dialog box for printing abort */
#define IDABORTDLG          88

/* Dialog Box for Serial Port Initialization */
#define IDDBPORTINIT        89


/* Dialing Dialog box */

#define IDDBDIALING         94

#define IDDIALING                11
#define IDDIALTIME               12
#define IDDIALRETRY              13


/*---------------------------------------------------------------------------*/

#define IDDBMYCONTROLS      98

#define IDFK1               10
#define IDFK2               11
#define IDFK3               12
#define IDFK4               13
#define IDFK5               14
#define IDFK6               15
#define IDFK7               16
#define IDFK8               17
#define IDTIMER              9
#define IDMORE              24

#define IDFK9               18
#define IDFK10              19


/*---------------------------------------------------------------------------*/

#define IDDBXFERCTRLS       24               /* mbbx 1.04 ... */

#define IDGRAYBACK           0

#define IDSTOP          0x4000               /* mbbx 2.00 ... */
#define IDPAUSE         0x2000
#define IDFORK          0x1000
#define IDSCALE         0x0800
/* #define IDREMAIN        0x0400 */
#define IDSENDING       0x0200
#define IDBERRORS       0x0100


/* ----------------------- File : Type Selection  ------------------------- */

#define IDDBFILETYPE     20
#define ITMSETTINGS      3
#define ITMSCRIPT        4
#define ITMMEMO          5


/* File:PrinterSetup --------------------------------------------------------*/

#define IDDBPRTSETUP             25          /* mbbx/jtfprt... */

#define IDPRINTNAME              11
#define IDPRTSETUP               21


/* File:PrinterSetup --------------------------------------------------------*/

#define IDDBCOPYSPECIAL          26          /* mbbx 2.00 ... */

#define ITMPRINTER               11
#define ITMFILE                  12
#define ITMCLIPBOARD             13

#define ITMTEXT                  21
#define ITMTABLE                 22
#define ITMBITMAP                23


/* Edit:SetMargin, Edit:SetTabWidth, & Search:GotoLine ----------------------*/

#define IDDBSETMARGIN            21
#define IDDBSETTABWIDTH          22
#define IDDBGOTOLINE             23

#define IDNUMITEM                11
#define IDBOOLITEM               12


/* Settings:Phone Number ----------------------------------------------------*/

#define IDDBPHON                 1

#define ITMPHONENUMBER           11
#define ITMRETRY                 12
#define ITMRETRYTIME             13
#define ITMSIGNAL                14


/* Settings:Terminal Emulation ----------------------------------------------*/

#define IDDBEMUL                 2
// sdj 02jun92 it is ADDS 12 TTY 11, can change the order to get rid
// of the unknown control id problem, only tty,vt52,vt100 are in RC
// but lets not do this now, before checking the impact on dcutil1.c
// FindResource code where 1000 1002 1003 are the .bin resources
// maybe the order is important!
#define ITMTTY			 11
#define ITMADDS 		 12
#define ITMVT52                  13
#define ITMVT100                 14
#define ITMVT220                 15
#define ITMIBM3101               16
#define ITMTVI925                17
#define ITMVIDTEX                18
#define ITMDELTA                 19

#define ITMTERMFIRST		 ITMTTY
#define ITMTERMLAST		 ITMVIDTEX
// sdj 02jun02 possible fix for unknown control id problem
//#define ITMTERMLAST		  ITMVT100

#define ITMCTRLGRP               20
#define ITM7BITCTRLS             21
#define ITM8BITCTRLS             22


/* Settings:Terminal Preferences --------------------------------------------*/

#define IDDBTERM                 3

#define ITMLINEWRAP              11
#define ITMLOCALECHO             12
#define ITMSOUND                 13

#define ITMINCRLF                21
#define ITMOUTCRLF               22

#define ITM80COL                 31
#define ITM132COL                32

#define ITMBLKCURSOR             41
#define ITMUNDCURSOR             42
#define ITMBLINKCURSOR           48

#define ITMFONTFACE              51
#define ITMFONTSIZE              52

#define ITMTRANSLATE             91
#define ITMBUFFERLINES           92
#define ITMSCROLLBARS            93
#define ITMIBMXANSI              94          /* rjs swat */
#define ITMWINCTRL               95


/* Settings:Function Keys ---------------------------------------------------*/

#define IDDBFKEY                 4

#define ITMFKEYTITLE             10
#define ITMFKEYTEXT              20

#define ITMLEVEL1                31
#define ITMLEVEL2                32
#define ITMLEVEL3                33
#define ITMLEVEL4                34

#define ITMSHOWFKEYS             91
#define ITMAUTOARRANGE           92


/* Settings:Text Transfers --------------------------------------------------*/

#define IDDBTXTX                 5

#define ITMSTD                   11          /* ITMSTD, ITMCHR, ITMLIN */
#define ITMCHR                   12
#define ITMLIN                   13

#define ITMSTDGRP                16
#define ITMSTDXON                17
#define ITMSTDHARD               18
#define ITMSTDNONE               19

#define ITMCHRGRP                20          /* ITMCHRDELAY, ITMCHRWAIT */
#define ITMCHRDELAY              21
#define ITMCHRWAIT               22
#define ITMCHRTIME               23
#define ITMCHRUNITS              24

#define ITMLINGRP                30          /* ITMLINDELAY, ITMLINWAIT */
#define ITMLINDELAY              31
#define ITMLINWAIT               32
#define ITMLINTIME               33
#define ITMLINUNITS              34
#define ITMLINSTR                35

#define ITMWORDWRAP              41
#define ITMWRAPCOL               42


/* Settings:Binary Transfers ------------------------------------------------*/

#define IDDBBINX                 6

#define ITMDYNACOMM              11          /* mbbx 2.00: remove XTalk... */
#define ITMKERMIT                12
#define ITMXMODEM                13
#define ITMYMODEM                14
#define ITMYTERM                 15

#if OLD_CODE                                 /* mbbx 2.00: remove XTalk... */
#define ITMDYNACOMM              11
#define ITMCROSSTALK             12
#define ITMKERMIT                13
#define ITMXMODEM                14
#define ITMYMODEM                15
#define ITMYTERM                 16
#endif


/* Settings:Communications --------------------------------------------------*/

#define IDDBCOMM                 7

#define ITMSETUP                 3           /* rjs bug2 */

#define ITMBD110                 11
#define ITMBD300                 12
#define ITMBD600                 13          /* mbbx 2.00: support 600 baud */
#define ITMBD120                 14
#define ITMBD240                 15
#define ITMBD480                 16
#define ITMBD960                 17
#define ITMBD144		 18
#define ITMBD192		 19
#define ITMBD384		 20
#define ITMBD576		 21
#define ITMBD1152		 22


#define ITMDATA4		 23
#define ITMDATA5		 24
#define ITMDATA6		 25
#define ITMDATA7		 26
#define ITMDATA8		 27

#define ITMSTOP1                 31
#define ITMSTOP5                 32
#define ITMSTOP2                 33

#define ITMNOPARITY              41
#define ITMODDPARITY             42
#define ITMEVENPARITY            43
#define ITMMARKPARITY            44
#define ITMSPACEPARITY           45

#define ITMXONFLOW               51
#define ITMHARDFLOW              52
#define ITMNOFLOW                53
#define ITMETXFLOW               54          /* rjs bug2 */
#define ITMXONSTOPTRANS          55          /* rjs bug2 */
#define ITMXONSTOPRECEP          56          /* rjs bug2 */

#define ITMCONNECTOR             61

#define ITMPARITY                91
#define ITMCARRIER               92


#define ITMNOCOM                 0
                                             /* mbbx 2.00: network... */
#define ITMWINCOM                1
#define ITMCOM1                  (ITMWINCOM+0)
#define ITMCOM2                  (ITMWINCOM+1)
#define ITMCOM3                  (ITMWINCOM+2)
#define ITMCOM4                  (ITMWINCOM+3)
#define ITMCOMLAST               ITMCOM2
                                             /* mbbx 2.00: network... */
#define ITMNETCOM                2
#define ITMCOMBIOS               (ITMNETCOM+0)
#define ITMNETBIOS               (ITMNETCOM+1)
#define ITMUBNETCI               (ITMNETCOM+2)
#define ITMDEVICE                (ITMNETCOM+3)
#define ITMDECLAT                (ITMNETCOM+4)  /* rjs bug2 */
#define ITMDLLCONNECT            (ITMNETCOM+5)  /* rjs bug2 */


#define IDDBCOMBIOS              31
#define IDDBNETBIOS              32
#define IDDBUBNETCI              33
#define IDDBDEVICE               34

#define ITMPORT1                 11
#define ITMPORT2                 12
#define ITMPORT3                 13
#define ITMPORT4                 14

#define ITMEXT_STANDARD          20          /* ((ITMNETCOM*10)+0) */
#define ITMCOMBIOS_EICONX25      21          /* ((ITMCOMBIOS*10)+1) */
#define ITMCOMBIOS_ETHERTERM     22          /* ((ITMCOMBIOS*10)+2) */
#define ITMNETBIOS_UB            31          /* ((ITMNETBIOS*10)+1) */
#define ITMNETBIOS_ATT           32          /* ((ITMNETBIOS*10)+2) */
#define ITMDEVICE_EICON          51          /* ((ITMDEVICE*10)+1) */

#define ITMNETBIOS_SERVER        35
#define ITMNETBIOS_LNAME         36
#define ITMNETBIOS_RNAME         37
#define ITMNETBIOS_RCVTO         38
#define ITMNETBIOS_SNDTO         39
#define ITMDEVICE_NAME           59


/* Settings:Modem Commands --------------------------------------------------*/

#define IDDBMODEM                8

#define ITMDIAL                  10
#define ITMHANGUP                12
#define ITMBINTX                 14
#define ITMBINRX                 16
#define ITMFASTQRY               18
#define ITMANSWER                20
#define ITMORIGIN                21

/* #define ITMDEFAULTS             31          mbbx 2.00 */

/* #define ITMFASTLINK             41          mbbx 2.00 */
#define ITMHAYES                 41
#define ITMMULTITECH             42
#define ITMTRAILBLAZER           43
#define ITMNOMODEM               44

#define ITMMODEMFIRST            ITMHAYES
/* #define ITMMODEMFIRST         ITMFASTLINK    mbbx 2.00 */
#define ITMMODEMLAST             ITMNOMODEM


/* Phone:Remote Kermit ------------------------------------------------------*/

#define IDDBKERREMOTE            9

#define ITMKERHLP                11
#define ITMKERTYPE               12
#define ITMKERDEL                13
#define ITMKERCOPY               14
#define ITMKERREN                15
#define ITMKERMESS               16          /* rkhx 2.00 */
#define ITMKERCHDIR              17
#define ITMKERDIR                18
#define ITMKERFREE               19
#define ITMKERFINISH             20
#define ITMKERLGOUT              21
#define ITMKERWHO                22          /* rkhx 2.00 */

#define ITMKERFIRST              ITMKERHLP
#define ITMKERLAST               ITMKERLGOUT

#define ITMKERDECR1              31
#define ITMKERFNAME1             32
#define ITMKERDECR2              33
#define ITMKERFNAME2             34
#define ITMKEREXECUTE            35
#define ITMKERCANCEL             36


/*- Script:Compile ----------------------------------------------------------*/

#define IDDBCOMPILE              69

#define ITMPHASE1                11
#define ITMPHASE2                12
#define ITMPROGRESS              13
#define ITMPHASE3                14

#define ITMRESULT1               21
#define ITMRESULT2               22


/*---------------------------------------------------------------------------*/

#define DC_RES_CCTL              "CCTL"      /* mbbx 1.04: REZ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcutil0.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include <port1632.h>
#include <dcrc.h>
#include <dynacomm.h>


#if OLDCODE

WORD lread(handle, buffer, count)            /* mbbx 2.01.13 ... */
INT      handle;
LPSTR    buffer;
WORD     count;
{
   return(_LREAD(handle, buffer, count));
}


WORD lwrite(handle, buffer, count)           /* mbbx 2.01.13 ... */
INT      handle;
LPSTR    buffer;
WORD     count;
{
   return(_LWRITE(handle, buffer, count));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\chrpaint.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "video.h"


/*---------------------------------------------------------------------------*/
/* eraseColorRect() - use current attribute to erase area              [jtf] */
/*---------------------------------------------------------------------------*/

VOID eraseColorRect(HDC hDC, LPRECT rect, BYTE cAttr)
{
   HBRUSH   hTmpBrush;

   hTmpBrush = CreateSolidBrush(RGB(vidAttr[cAttr & AMASK].bkgd[VID_RED], 
                                    vidAttr[cAttr & AMASK].bkgd[VID_GREEN], 
                                    vidAttr[cAttr & AMASK].bkgd[VID_BLUE]));
   FillRect(hDC, (LPRECT) rect, (HBRUSH) hTmpBrush);
   DeleteObject((HBRUSH) hTmpBrush);
}


/*---------------------------------------------------------------------------*/
/* reDrawTermScreen() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

VOID reDrawTermScreen(INT nStart, INT nCount, INT nOffset)
{
   while(nStart < nCount)
      reDrawTermLine((nStart++) + nOffset, 0, maxChars);
}


/*---------------------------------------------------------------------------*/
/* reDrawTermLine() - Reslap some lines back up on the terminal.  [scf]      */
/*---------------------------------------------------------------------------*/

VOID reDrawTermLine(INT lin, INT col, INT len)
{
   LPBYTE   lpText;

   if(lin < 0)
   {
      getPort();
      hideTermCursor();

      if((lpText = GlobalLock(hTE.hText)) != NULL)
      {
         drawTermLine(lpText + ((savTopLine + lin) * (maxChars + 2)) + col,
                      len, lin, col + len, LNORMAL, 0);
         GlobalUnlock(hTE.hText);
      }
      showTermCursor();
      releasePort();
   }
   else if(lin <= (maxScreenLine+1))         /* mbbx 2.00.06: jtf disp2 */
   {
      attrib[lin][LFLAGS] = (LCLEAR | LDIRTY);
      updateLine(lin);
   }
}


/*---------------------------------------------------------------------------*/
/* updateLine() -                                                            */
/*---------------------------------------------------------------------------*/

VOID updateLine(INT line)
{
   BOOL     bStatusLine;                     /* mbbx 2.00.06: jtf disp2 */
   LPBYTE   txt;
   BYTE     *attr;
   INT	    col1, col2, len, txtLen; // sdj: unref variable was- bottom;
   BYTE     cAttr;
   BOOL     anyway;

                                             /* mbbx 2.00.06: dont overwrite xferCtrls... */
   if((bStatusLine = (line == maxScreenLine+1)) && (xferFlag > XFRNONE))
      return;

   getPort();
   hideTermCursor();

   if(!bStatusLine)
   {
      clipRect(&hTE.viewRect); /* jtf 3.Final */
      txt = (LPBYTE)GlobalLock(hTE.hText) + (savTopLine + line) * (maxChars + 2);
   }
   else
   {
      clipRect(&statusRect);                 /* rjs bugs 019 */
      txt = (LPBYTE) line25;
   }

   attr     = attrib[line];
   anyway   = (attr[LFLAGS] == (LCLEAR | LDIRTY));

   for(col1 = 0; col1 < maxChars; col1 = col2)
   {
      cAttr = attr[col1];
      for (col2 = col1+1; col2 < maxChars; col2++)
      {
         attr[col2-1] &= ~ADIRTY;
         if (cAttr != attr[col2])
            break;
      }
      len    = col2 - col1;
      txtLen = len;
      if((cAttr & ADIRTY) || anyway)
         drawTermLine(txt, txtLen, line, col1 + txtLen, attr[LATTRIB], cAttr);

      txt   += len;
   }
   attr[col2-1] &= ~ADIRTY;
   attr[LFLAGS]  =  0;

   if(!bStatusLine)
      GlobalUnlock(hTE.hText);

   showTermCursor();
   releasePort();
}


/*---------------------------------------------------------------------------*/
/* drawTermLine() -                                                          */
/*---------------------------------------------------------------------------*/

VOID drawTermLine(LPBYTE txtPtr, INT len, INT lin, INT col, BYTE lAttr, BYTE cAttr)
{
   BOOL     bStatusLine;
   HDC      savePort;
   HBITMAP  hBitMap;
   RECT     srcRect, dstRect, tmpRect;
   INT      ndx;
   BYTE     grSave[132], grChar[132];        
   HPEN     newPen, oldPen;
   INT	    grLeft, grWidth2, grHeight2;
   BOOL     bhBitMapValid;

   bhBitMapValid = FALSE;  //sdj: there is a chance that hbitmap maynot
			   //sdj: be valid and still deleteobject(hbitmap)
			   //sdj: is called, and this may delete some random
			   //sdj: object, who knows, so lets delete it only
			   //sdj: if you create one

   if(!(bStatusLine = (lin == maxScreenLine+1)))
   {
      if(((lin += (savTopLine - curTopLine)) < 0) || (lin > visScreenLine))
         return;
   }

   if(lAttr != LNORMAL)
   {
      thePort = CreateCompatibleDC(savePort = thePort);
      hBitMap = CreateCompatibleBitmap(thePort, chrWidth * maxChars, chrHeight);
      bhBitMapValid = TRUE;
      SelectObject(thePort, hBitMap);
      SelectObject(thePort, hTE.hFont);

      /* srcRect : rect to draw chars in (memory DC) */
      srcRect.left   = 0;
      srcRect.right  = len * chrWidth;
      srcRect.top    = 0;
      srcRect.bottom = chrHeight;

      /* dstRect : rect to copy bits to (stretchBlt) */
      dstRect.right = col*chrWidth*2 - curLeftCol*chrWidth;
      dstRect.left  = dstRect.right - len*chrWidth*2;
      dstRect.top   = lin * chrHeight;

      if(lAttr == LHIGHBOTTOM)
         dstRect.top -= chrHeight;

      if((dstRect.bottom = dstRect.top + chrHeight) >= statusRect.top)
         dstRect.bottom = statusRect.top-1;  /* mbbx 2.00.06: wont this look FUNKY ??? */
      if(lAttr != LWIDE)
         dstRect.bottom += chrHeight;

      tmpRect = dstRect;
      eraseColorRect((HDC) thePort, (LPRECT) &tmpRect, (BYTE) cAttr);
   }
   else
   {
      srcRect.right = (col - curLeftCol) * chrWidth;
      srcRect.left = srcRect.right - (len * chrWidth);

                                             /* mbbx 2.00.06: jtf disp2... */
      srcRect.top = !bStatusLine ? (lin * chrHeight) : statusRect.top + (STATUSRECTBORDER / 2);
      srcRect.bottom = srcRect.top + chrHeight;
   }

   if(cAttr & AGRAPHICS)
   {
      lmovmem(txtPtr, (LPSTR) grSave, len);  /* mbbx 2.00.06: save actual buffer data */

      for(ndx = 0; ndx < len; ndx += 1)
      {
         if((txtPtr[ndx] >= 0x40) && (txtPtr[ndx] <= 0x7F))
         {
            grChar[ndx] = vidGraphChars[txtPtr[ndx] - 0x40].display;
            txtPtr[ndx] = vidGraphChars[txtPtr[ndx] - 0x40].buffer;
         }
         else
            grChar[ndx] = 0;
      }
   }

   ndx = 0;
   if(!(vidAttr[cAttr & AMASK].flags & VID_UNDERLINE) && !bStatusLine)  /* mbbx 2.00.06: jtf disp2... */
   {
      while((txtPtr[ndx] == ' ') && (ndx < len))
         ndx += 1;
   }

   if(ndx > 0)
   {
      CopyRect((LPRECT) &tmpRect, (LPRECT) &srcRect);
      tmpRect.right = tmpRect.left + (ndx * chrWidth);
      if(tmpRect.bottom >= statusRect.top)   /* mbbx 2.00.06: jtf disp2 - dont overwrite statusRect... */
         tmpRect.bottom = statusRect.top-1;
      eraseColorRect((HDC) thePort, (LPRECT) &tmpRect, (BYTE) cAttr);
   }

   if((len - ndx) > 0)
   {
      setAttrib(cAttr);
      ExtTextOut(thePort, srcRect.left + (ndx * chrWidth), srcRect.top, ETO_CLIPPED, (LPRECT) &srcRect, 
                 (LPSTR) &txtPtr[ndx], len-ndx, (LPINT) vidCharWidths);
   }

   if(cAttr & AGRAPHICS)
   {
      newPen = CreatePen(0, 1, RGB(vidAttr[cAttr & AMASK].text[VID_RED], 
                         vidAttr[cAttr & AMASK].text[VID_GREEN], 
                         vidAttr[cAttr & AMASK].text[VID_BLUE]));
      oldPen = SelectObject(thePort, (HPEN) newPen);

      grLeft = srcRect.left;
      grWidth2 = chrWidth / 2;
      grHeight2 = chrHeight / 2;

      for(ndx = 0; ndx < len; ndx += 1)
      {
         if(grChar[ndx] & VID_DRAW_LEFT)
         {
            MMoveTo(thePort, grLeft, srcRect.top + grHeight2);
            LineTo(thePort, grLeft + grWidth2, srcRect.top + grHeight2);
         }

         if(grChar[ndx] & VID_DRAW_RIGHT)
         {
            MMoveTo(thePort, grLeft + grWidth2, srcRect.top + grHeight2);
            LineTo(thePort, grLeft + chrWidth, srcRect.top + grHeight2);
         }

         if(grChar[ndx] & VID_DRAW_TOP)
         {
            MMoveTo(thePort, grLeft + grWidth2, srcRect.top);
            LineTo(thePort, grLeft + grWidth2, srcRect.top + grHeight2);
         }

         if(grChar[ndx] & VID_DRAW_BOTTOM)
         {
            MMoveTo(thePort, grLeft + grWidth2, srcRect.top + grHeight2);
            LineTo(thePort, grLeft + grWidth2, srcRect.top + chrHeight);
         }

         if(grChar[ndx] & VID_DRAW_SCAN1)
         {
            MMoveTo(thePort, grLeft, srcRect.top);
            LineTo(thePort, grLeft + chrWidth, srcRect.top);
         }

         if(grChar[ndx] & VID_DRAW_SCAN3)
         {
            MMoveTo(thePort, grLeft, srcRect.top + (chrHeight / 4));
            LineTo(thePort, grLeft + chrWidth, srcRect.top + (chrHeight/4));
         }

         if(grChar[ndx] & VID_DRAW_SCAN7)
         {
            MMoveTo(thePort, grLeft, srcRect.top + (3 * (chrHeight / 4)));
            LineTo(thePort, grLeft + chrWidth, srcRect.top + (3 * (chrHeight/4)));
         }

         if(grChar[ndx] & VID_DRAW_SCAN9)
         {
            MMoveTo(thePort, grLeft, srcRect.top + (chrHeight-1));
            LineTo(thePort, grLeft + chrWidth, srcRect.top + (chrHeight-1));
         }

         grLeft += chrWidth;
      }

      SelectObject(thePort, (HPEN) oldPen);
      DeleteObject((HPEN) newPen);

      lmovmem((LPSTR) grSave, txtPtr, len);  /* mbbx 2.00.06: restore actual buffer data */
   }

   if(vidAttr[cAttr & AMASK].flags & VID_REVERSE)
      InvertRect(thePort, (LPRECT) &srcRect);

   if(lAttr != LNORMAL)
   {
                                             /* mbbx 2.00: font selection... */
      StretchBlt(savePort, dstRect.left, dstRect.top, 
                 dstRect.right - dstRect.left, dstRect.bottom - dstRect.top, 
                 thePort, srcRect.left, srcRect.top, 
                 srcRect.right - srcRect.left, chrHeight, SRCCOPY);

      DeleteDC(thePort);
      if (bhBitMapValid)	  //sdj: check if valid, only then call delete
	  DeleteObject(hBitMap);
      thePort = savePort;
   }

   if(vidAttr[cAttr & AMASK].flags & (VID_BOLD | VID_ITALIC | VID_UNDERLINE | VID_STRIKEOUT))
      SelectObject(thePort, hTE.hFont);
}


/*--------------------------------------------------------------------------*/
/* setAttrib() -                                                      [jtf] */
/*--------------------------------------------------------------------------*/

VOID setAttrib(BYTE cAttr)
{
   INT      ndx;
   LOGFONT  logFont;
   HFONT    hFont;

   cAttr &= AMASK;

   SetTextColor(thePort, RGB(vidAttr[cAttr].text[VID_RED], 
                vidAttr[cAttr].text[VID_GREEN], vidAttr[cAttr].text[VID_BLUE]));

   SetBkColor(thePort, RGB(vidAttr[cAttr].bkgd[VID_RED], 
              vidAttr[cAttr].bkgd[VID_GREEN], vidAttr[cAttr].bkgd[VID_BLUE]));

   if(vidAttr[cAttr].flags & (VID_BOLD | VID_ITALIC | VID_UNDERLINE | VID_STRIKEOUT))
   {
      for(ndx = 0; ndx < VID_MAXFONTCACHE; ndx += 1)
      {
         if(vidFontCache[ndx].hFont == NULL)
            break;

         if(vidFontCache[ndx].flags == (vidAttr[cAttr].flags & VID_MASK))
         {
            SelectObject(thePort, vidFontCache[ndx].hFont);
            return;
         }
      }

      GetObject(hTE.hFont, sizeof(LOGFONT), (LPSTR) &logFont);

      if(vidAttr[cAttr].flags & VID_BOLD)
         logFont.lfWeight = 700;

      logFont.lfUnderline = (vidAttr[cAttr].flags & VID_UNDERLINE) ? TRUE : FALSE;
      logFont.lfStrikeOut = (vidAttr[cAttr].flags & VID_STRIKEOUT) ? TRUE : FALSE;
      logFont.lfItalic = (vidAttr[cAttr].flags & VID_ITALIC) ? TRUE : FALSE;

      hFont = CreateFontIndirect((LPLOGFONT) &logFont);
      if(ndx == VID_MAXFONTCACHE)
      {
         DeleteObject(vidFontCache[0].hFont);
         for(ndx = 0; ndx < VID_MAXFONTCACHE-1; ndx += 1)
         {
            vidFontCache[ndx].hFont = vidFontCache[ndx+1].hFont;
            vidFontCache[ndx].flags = vidFontCache[ndx+1].flags;
         }
      }

      vidFontCache[ndx].hFont = hFont;
      vidFontCache[ndx].flags = (vidAttr[cAttr].flags & VID_MASK);
      SelectObject(thePort, hFont);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\connect.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1990, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMB	            TRUE
#define  NOMINMAX	         TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31
#define  USECOMM

#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "network.h"
#include "video.h"  
#include "connect.h"


/**************************************************************************/
/*                                                                        */
/* initConnectors                                                         */
/*                                                                        */
/**************************************************************************/

BOOL initConnectors(BOOL bInit)
{
   LPCONNECTORS   lpConnectors;              /* slc nova 031 */

   if(bInit)                                 /* we are initializing stuff */
   {
      ghConnectors = GlobalAlloc(GHND | GMEM_ZEROINIT, (DWORD) sizeof(CONNECTORS));
      if(ghConnectors == NULL)
         return(FALSE);

                                             /* slc nova 031 */
      ghCCB = GlobalAlloc(GHND | GMEM_ZEROINIT, (DWORD)sizeof(CONNECTOR_CONTROL_BLOCK));

      /* the lpConnectors struct not really used by DynaComm at this time */
      /* let's go ahead and allocate room for one CCB */
      lpConnectors = (LPCONNECTORS) GlobalLock(ghConnectors);
      lpConnectors->hCCBArray = ghCCB;

      if(lpConnectors->hCCBArray == NULL)
      {
         GlobalUnlock(ghConnectors);
         GlobalFree(ghConnectors);
         return(FALSE);
      }

      lpConnectors->lpCCB[0] = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(lpConnectors->hCCBArray);

      GlobalUnlock(ghConnectors);
   }
   else
   {  /* we are unloading this stuff */
      GlobalFree(ghCCB);                     /* slc nova 031 */
      GlobalFree(ghConnectors);              /* slc nova 031 */
   }

   return(TRUE);
}


/**************************************************************************/
/*                                                                        */
/* addConnectorList                                                       */
/*                                                                        */
/**************************************************************************/

VOID addConnectorList(HWND hDlg, WORD wId)   /* slc nova 031 */
{
   HANDLE   theHandle;
   OFSTRUCT ofDummy;

   if (MOpenFile((LPSTR)"LANMAN.DLL", (LPOFSTRUCT)&ofDummy, OF_EXIST) != -1)
      SendDlgItemMessage(hDlg, wId, LB_INSERTSTRING, -1, (LPARAM)"LANMAN");
}


/**************************************************************************/
/*                                                                        */
/* DLL_ConnectConnector                                      seh nova 005 */
/*                                                                        */
/**************************************************************************/

WORD DLL_ConnectConnector(HANDLE hCCB, BOOL bShow) /* slc nova 031 seh nova 005 */
{
   FARPROC                   lpfnGetType;
   LPCONNECTOR_CONTROL_BLOCK lpCCB;
   WORD                      wResult = 0;

   if(hCCB == NULL)                          /* slc nova 028 */
      return(0);

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnGetType = GetProcAddress(lpCCB->hConnectorInst,
                            MAKEINTRESOURCE(ORD_CONNECTCONNECTOR))) != NULL)
   {
      wResult = ((WORD)(*lpfnGetType)(dlgGetFocus(), lpCCB, (BOOL)bShow));
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_DisconnectConnector                                  seh nova 005  */
/*                                                                        */
/**************************************************************************/

WORD DLL_DisconnectConnector(HANDLE hCCB)
{
   FARPROC                   lpfnGetType;
   LPCONNECTOR_CONTROL_BLOCK lpCCB;
   WORD                      wResult = 0;

   if(hCCB == NULL)
      return(0);

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnGetType = GetProcAddress(lpCCB->hConnectorInst,
                           MAKEINTRESOURCE(ORD_DISCONNECTCONNECTOR))) != NULL)
   {
/*      wResult = ((WORD)(*lpfnGetType)(dlgGetFocus(), lpCCB)); */
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_modemSendBreak                                                     */
/*                                                                        */
/**************************************************************************/

WORD DLL_modemSendBreak(HANDLE hCCB, INT nTimes)
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   FARPROC                    lpfnCommandConnector;
   WORD                       wResult = 0;

   if(hCCB == NULL)
      return(0);

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnCommandConnector = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_COMMANDCONNECTOR))) != NULL)
   {
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_ReadConnector                                                      */
/*                                                                        */
/**************************************************************************/

WORD DLL_ReadConnector(HANDLE hCCB)          /* slc nova 031 */
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   FARPROC                    lpfnRead;
   WORD                       wResult = 0;

   if(hCCB == NULL)                          /* slc nova 028 */
      return(0);

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnRead = GetProcAddress(lpCCB->hConnectorInst,
                                 MAKEINTRESOURCE(ORD_READCONNECTOR))) != NULL)
   {
      wResult = (WORD)(*lpfnRead)(lpCCB);
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_ConnectBytes                                                       */
/*                                                                        */
/**************************************************************************/

WORD DLL_ConnectBytes(HANDLE hCCB)           /* slc nova 031 */
{
   if(hCCB == NULL)
   {
      serCount = 0;
      return(FALSE);
   }

   return(DLL_ReadConnector(hCCB));
}


/**************************************************************************/
/*                                                                        */
/* DLL_WriteConnector                                                     */
/*                                                                        */
/**************************************************************************/

WORD DLL_WriteConnector(HANDLE hCCB)         /* slc nova 031 */
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   WORD                       wResult = FALSE;
   FARPROC                    lpfnWrite;

   if(hCCB == NULL)                          /* slc nova 028 */
   {
      serCount = 0;
      return(wResult);
   }

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnWrite = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_WRITECONNECTOR))) != NULL)
   {
      wResult = (WORD)(*lpfnWrite)(lpCCB);
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_ExitConnector                                                      */
/*                                                                        */
/**************************************************************************/

WORD DLL_ExitConnector(HANDLE hCCB, recTrmParams *pTrmParams)
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   FARPROC                    lpfnGetType;

   if(hCCB == NULL)                          /* slc nova 028 */
      return(0);

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnGetType = GetProcAddress(lpCCB->hConnectorInst,
                                 MAKEINTRESOURCE(ORD_EXITCONNECTOR))) != NULL)
   {
   }

   if(lpCCB->hConnectorInst != 0)            /* slc nova 031 */
      FreeLibrary(lpCCB->hConnectorInst);
   lpCCB->hConnectorInst = 0;

   GlobalUnlock(hCCB);

   return(0);
}


/**************************************************************************/
/*                                                                        */
/* DLL_ResetConnector                                                     */
/*                                                                        */
/**************************************************************************/

WORD DLL_ResetConnector(HANDLE hCCB, BOOL bShow)   /* slc nova 031 */
{
   LPCONNECTOR_CONTROL_BLOCK lpCCB;
   FARPROC                   lpfnGetType;
   WORD                      wResult = 0;

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnGetType = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_RESETCONNECTOR))) != NULL)
   {
      wResult = (WORD)(*lpfnGetType)(dlgGetFocus(), lpCCB, (BOOL)bShow);
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_SetupConnector                                                     */
/*                                                                        */
/**************************************************************************/

WORD DLL_SetupConnector(HANDLE hCCB, BOOL bShow)   /* slc nova 031 */
{
   LPCONNECTOR_CONTROL_BLOCK lpCCB;
   FARPROC                   lpfnProcAddr;
   WORD                      wResult = 0;

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if((lpfnProcAddr = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_SETUPCONNECTOR))) != NULL)
   {
      ccbFromTrmParams(lpCCB, &trmParams);
      wResult = (WORD)(*lpfnProcAddr)(dlgGetFocus(), lpCCB, (BOOL)bShow);
      ccbToTrmParams(&trmParams, lpCCB);
   }

   GlobalUnlock(hCCB);
   return(wResult);
}


/**************************************************************************/
/*                                                                        */
/* loadConnector                                                          */
/*                                                                        */
/**************************************************************************/

HANDLE loadConnector(HWND hTopWnd, HANDLE hCCB, LPSTR lpszConnector, BOOL bShow)
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   FARPROC                    lpfnGetType;
   CHAR                       szWork[PATHLEN];
   HANDLE                     hResult = NULL;

   if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB)) == NULL)
      return(0);

   if(lpCCB->hConnectorInst != 0)
      FreeLibrary(lpCCB->hConnectorInst);
   lpCCB->hConnectorInst = 0;

   if(*lpszConnector)
   {
      if(!lstrcmp(lpszConnector, (LPSTR)"LANMAN"))
      {
         lstrcpy((LPSTR)szWork, lpszConnector);
         strcat(szWork, ".DLL");
      }
      lpCCB->hConnectorInst = LoadLibrary((LPSTR)szWork);   /* slc nova 028 */
   }

/* in win30 <32 rc is an error, but in win32 rc is NULL in case of an error -sdj*/

#ifdef ORGCODE
   if(lpCCB->hConnectorInst < 32)
      lpCCB->hConnectorInst = 0;
#else
   if(lpCCB->hConnectorInst == NULL)
      lpCCB->hConnectorInst = (HANDLE)0;
#endif

   if(lpCCB->hConnectorInst != 0)
   {  /* check to see if we have a DC_CONNECTOR type dll */
      if((lpfnGetType = GetProcAddress(lpCCB->hConnectorInst,
                                    MAKEINTRESOURCE(ORD_GETDLLTYPE))) == NULL)
      {
         FreeLibrary(lpCCB->hConnectorInst);
         lpCCB->hConnectorInst = 0;
      }
      else
      {
         if((WORD)(*lpfnGetType)((HWND)hTopWnd, (BOOL)bShow) != DC_CONNECTOR)
         {
            FreeLibrary(lpCCB->hConnectorInst);
            lpCCB->hConnectorInst = 0;
         }
      }
   }
   hResult = lpCCB->hConnectorInst;
   GlobalUnlock(hCCB);

   if(hResult)                               /* slc nova 031 */
      DLL_ResetConnector(hCCB, FALSE);

   return(hResult);
}


/**************************************************************************/
/*                                                                        */
/* DLL_HasSetupBox                                          seh nova 006  */
/*                                                                        */
/**************************************************************************/

BOOL DLL_HasSetupBox(HANDLE hCCB)
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;
   FARPROC                    lpProc;
   BOOL		                  bHasSetup;

   if(hCCB == NULL)                          /* slc nova 028 */
      return(0);
                                   
   lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB);  /* slc nova 031 */

   if((lpProc = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_GETEXTENDEDINFO))) == NULL)
   {
      bHasSetup = FALSE;
   }
   else
   {
      bHasSetup = (WORD)(*lpProc)((WORD)GI_IDENTIFY, (WORD)GI_SETUPBOX, (LPSTR)NULL);
   }

   return(bHasSetup);
}


/**************************************************************************/
/*                                                                        */
/* getConnectorCaps                                                       */
/*                                                                        */
/**************************************************************************/

WORD getConnectorCaps(LPCONNECTOR_CONTROL_BLOCK lpCCB)   /* slc nova 031 */
{
   FARPROC  lpProc;
   WORD     wReturn;

   if((lpProc = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_GETCONNECTCAPS))) != NULL)
   {
      wReturn = (WORD)(*lpProc)((WORD)SET_PARAMETERS);
   }

   return(wReturn);
}


/**************************************************************************/
/*                                                                        */
/* getConnectorSettings                                                   */
/*                                                                        */
/**************************************************************************/

WORD getConnectorSettings(LPCONNECTOR_CONTROL_BLOCK lpCCB, BOOL bShow) /* slc nova 031 */
{
   FARPROC  lpProc;
   WORD     wReturn;
   WORD     wPassVal = SP_GETDEFAULT;

   if(bShow)
      wPassVal |= SP_SHOW;

   if((lpProc = GetProcAddress(lpCCB->hConnectorInst,
                                 MAKEINTRESOURCE(ORD_SETPARAMETERS))) != NULL)
   {
      wReturn = (WORD)(*lpProc)((WORD)wPassVal, (LPCONNECTOR_CONTROL_BLOCK)lpCCB);
   }

   return(wReturn);
}


/**************************************************************************/
/*                                                                        */
/* setConnectorSettings                                                   */
/*                                                                        */
/**************************************************************************/

WORD setConnectorSettings(HWND hDlg, HANDLE hCCB, BOOL bDefaults) /* slc nova 031 */
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;         /* slc nova 031 */
   LPCONNECTORS               lpConnectors;  /* slc nova 031 */
   FARPROC                    lpProc;
   WORD                       wSettings;
   WORD                       wWorkSettings, wWork;

   if(hCCB == NULL)                          /* slc nova 028 */
      return(0);
                                   
   lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB);  /* slc nova 031 */
   if(lpCCB->hConnectorInst == 0)            /* slc nova 046 */
   {
      GlobalUnlock(hCCB);
      return(0);
   }

   if((lpProc = GetProcAddress(lpCCB->hConnectorInst,
                              MAKEINTRESOURCE(ORD_GETEXTENDEDINFO))) != NULL)
   {
      wSettings = (WORD)(*lpProc)((WORD)GI_IDENTIFY, (WORD)GI_SETUPBOX, (LPSTR)NULL);
   }

   if(wSettings)
   {
      EnableWindow(GetDlgItem(hDlg, ITMSETUP), TRUE);    /* seh nova 005 */
      ShowWindow(GetDlgItem(hDlg, ITMSETUP), SW_SHOW);   /* seh nova 005 */
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, ITMSETUP),  FALSE);  /* seh nova 005 */
      ShowWindow(GetDlgItem(hDlg, ITMSETUP), SW_HIDE);   /* seh nova 005 */
   }

   wSettings = getConnectorCaps(lpCCB);      /* slc nova 031 */
   getConnectorSettings(lpCCB, FALSE);       /* slc nova 031 */
   if(bDefaults)                             /* slc nova 031 */
   {
      ccbFromTrmParams(lpCCB, &trmParams);
      ccbToTrmParams(&trmParams, lpCCB);
   }
   
   /* enable baud rates */
   for(wWork = ITMBD110; wWork <= ITMBD192; wWork++)
      EnableWindow(GetDlgItem(hDlg, wWork), FALSE);

   if((wSettings & SP_BAUD) == SP_BAUD)
   {
      wWorkSettings = lpCCB->wBaudFlags;

      if((wWorkSettings & BAUD_110) == BAUD_110)
         EnableWindow(GetDlgItem(hDlg, ITMBD110), TRUE);

      if((wWorkSettings & BAUD_300) == BAUD_300)
         EnableWindow(GetDlgItem(hDlg, ITMBD300), TRUE);

      if((wWorkSettings & BAUD_600) == BAUD_600)
         EnableWindow(GetDlgItem(hDlg, ITMBD600), TRUE);

      if((wWorkSettings & BAUD_120) == BAUD_120)
         EnableWindow(GetDlgItem(hDlg, ITMBD120), TRUE);

      if((wWorkSettings & BAUD_240) == BAUD_240)
         EnableWindow(GetDlgItem(hDlg, ITMBD240), TRUE);

      if((wWorkSettings & BAUD_480) == BAUD_480)
         EnableWindow(GetDlgItem(hDlg, ITMBD480), TRUE);

      if((wWorkSettings & BAUD_960) == BAUD_960)
         EnableWindow(GetDlgItem(hDlg, ITMBD960), TRUE);

      if((wWorkSettings & BAUD_192) == BAUD_192)
         EnableWindow(GetDlgItem(hDlg, ITMBD192), TRUE);

      CheckRadioButton(hDlg, ITMBD110, ITMBD192, putCCB_BAUDITM(lpCCB->wBaudSet));
   }

   /*  enable data bits */
   for(wWork = ITMDATA5; wWork <= ITMDATA8; wWork++)
      EnableWindow(GetDlgItem(hDlg, wWork), FALSE);

   if((wSettings & SP_DATABITS) == SP_DATABITS)
   {
      wWorkSettings = lpCCB->wDataBitFlags;

      if((wWorkSettings & DATABITS_5) == DATABITS_5)
         EnableWindow(GetDlgItem(hDlg, ITMDATA5), TRUE);

      if((wWorkSettings & DATABITS_6) == DATABITS_6)
         EnableWindow(GetDlgItem(hDlg, ITMDATA6), TRUE);

      if((wWorkSettings & DATABITS_7) == DATABITS_7)
         EnableWindow(GetDlgItem(hDlg, ITMDATA7), TRUE);

      if((wWorkSettings & DATABITS_8) == DATABITS_8)
         EnableWindow(GetDlgItem(hDlg, ITMDATA8), TRUE);

      CheckRadioButton(hDlg, ITMDATA5, ITMDATA8, putCCB_DATABITS(lpCCB->wDataBitSet));
   }

   /* enable stop bits */
   for(wWork = ITMSTOP1; wWork <= ITMSTOP2; wWork++)
      EnableWindow(GetDlgItem(hDlg, wWork), FALSE);

   if((wSettings & SP_STOPBITS) == SP_STOPBITS)
   {
      wWorkSettings = lpCCB->wStopBitFlags;

      if((wWorkSettings & STOPBITS_10) == STOPBITS_10)
         EnableWindow(GetDlgItem(hDlg, ITMSTOP1), TRUE);

      if((wWorkSettings & STOPBITS_15) == STOPBITS_15)
         EnableWindow(GetDlgItem(hDlg, ITMSTOP5), TRUE);

      if((wWorkSettings & STOPBITS_20) == STOPBITS_20)
         EnableWindow(GetDlgItem(hDlg,ITMSTOP2), TRUE);

      CheckRadioButton(hDlg, ITMSTOP1, ITMSTOP2, putCCB_STOPBITS(lpCCB->wStopBitSet));
   }

   /* enable parity options */
   for(wWork = ITMNOPARITY; wWork <= ITMSPACEPARITY; wWork++)
      EnableWindow(GetDlgItem(hDlg, wWork), FALSE);

   if((wSettings & SP_PARITY) == SP_PARITY)
   {
      wWorkSettings = lpCCB->wParityFlags;

      if((wWorkSettings & PARITY_NONE) == PARITY_NONE)
         EnableWindow(GetDlgItem(hDlg, ITMNOPARITY), TRUE);

      if((wWorkSettings & PARITY_ODD) == PARITY_ODD)
         EnableWindow(GetDlgItem(hDlg, ITMODDPARITY), TRUE);

      if((wWorkSettings & PARITY_EVEN) == PARITY_EVEN)
         EnableWindow(GetDlgItem(hDlg, ITMEVENPARITY), TRUE);

      if((wWorkSettings & PARITY_MARK) == PARITY_MARK)
         EnableWindow(GetDlgItem(hDlg, ITMMARKPARITY), TRUE);

      if((wWorkSettings & PARITY_SPACE) == PARITY_SPACE)
         EnableWindow(GetDlgItem(hDlg, ITMSPACEPARITY), TRUE);

      CheckRadioButton(hDlg, ITMNOPARITY, ITMSPACEPARITY, putCCB_PARITY(lpCCB->wParitySet));
   }

   /* enable handshake options */
   for(wWork = ITMXONFLOW; wWork <= ITMNOFLOW; wWork++)
      EnableWindow(GetDlgItem(hDlg, wWork), FALSE);

   if((wSettings & SP_HANDSHAKING) == SP_HANDSHAKING)
   {
      wWorkSettings = lpCCB->wHandshakeFlags;

      if((wWorkSettings & HANDSHAKE_XONXOFF) == HANDSHAKE_XONXOFF)
         EnableWindow(GetDlgItem(hDlg, ITMXONFLOW), TRUE);

      if((wWorkSettings & HANDSHAKE_HARDWARE) == HANDSHAKE_HARDWARE)
         EnableWindow(GetDlgItem(hDlg, ITMHARDFLOW), TRUE);

      if((wWorkSettings & HANDSHAKE_NONE) == HANDSHAKE_NONE)
         EnableWindow(GetDlgItem(hDlg, ITMNOFLOW), TRUE);

      CheckRadioButton(hDlg, ITMXONFLOW, ITMNOFLOW, putCCB_FLOWCTRL(lpCCB->wHandshakeSet));
   }

   /* enable carrier detect button */
   //if((wSettings & SP_RLSD) == SP_RLSD)		  needs to be changed to SP_CARRIER_DETECT
   //{
   //	EnableWindow(GetDlgItem(hDlg, ITMCARRIER), TRUE);
   //}
   //else
   //{
      EnableWindow(GetDlgItem(hDlg, ITMCARRIER), FALSE);
   //}

   /* enable parity check button */
   if((wSettings & SP_PARITY_CHECK) == SP_PARITY_CHECK)
   {
      EnableWindow(GetDlgItem(hDlg, ITMPARITY), TRUE);
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, ITMPARITY), FALSE);
   }

   GlobalUnlock(hCCB);                       /* slc nova 031 */
   return(wSettings);
}

/**************************************************************************/

INT GetDynaCommProfileString(LPSTR lpsz1, LPSTR lpsz2, LPSTR lpsz3,
                             LPSTR lpsz4, INT nSize, LPSTR lpsz5)
{
   return GetPrivateProfileString(lpsz1, lpsz2, lpsz3, lpsz4, nSize, lpsz5);
}


/**************************************************************************/
/* getConnectType                                          seh nova 005   */
/**************************************************************************/

WORD getConnectType(HANDLE hConnector, HANDLE hCCB)
{
   LPCONNECTOR_CONTROL_BLOCK lpCCB;
   WORD                      wResult;

   lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(hCCB);
   wResult = (WORD)lpCCB->wType;
   GlobalUnlock(hCCB);

   return(wResult);
}


/**************************************************************************/
/* ccbFromTrmParams                                         slc nova 028  */
/**************************************************************************/

/**************************************************************************/
/* getCCB_BAUD                                             seh nova 005   */
/**************************************************************************/

WORD getCCB_BAUD(WORD wSpeed)
{
   WORD wReturn;

   switch(wSpeed)                            /* from DC to CCB */
   {
   case 75:
      wReturn = BAUD_075;
      break;
   case 110:
      wReturn = BAUD_110;
      break;
   case 300:
      wReturn = BAUD_300;
      break;
   case 600:
      wReturn = BAUD_600;
      break;
   case 1200:
      wReturn = BAUD_120;
      break;
   case 2400:
      wReturn = BAUD_240;
      break;
   case 4800:
      wReturn = BAUD_480;
      break;
   case 9600:
      wReturn = BAUD_960;
      break;
   case 19200:
      wReturn = BAUD_192;
      break;
   default:
      wReturn = (WORD)BAUD_USER;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* getCCB_DATABITS                                         slc nova 028   */
/**************************************************************************/

WORD getCCB_DATABITS(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case ITMDATA5:
      wReturn = DATABITS_5;
      break;
   case ITMDATA6:
      wReturn = DATABITS_6;
      break;
   case ITMDATA7:
      wReturn = DATABITS_7;
      break;
   case ITMDATA8:
      wReturn = DATABITS_8;
      break;
   default:
      wReturn = DATABITS_8;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* getCCB_PARITY                                           slc nova 028   */
/**************************************************************************/

WORD getCCB_PARITY(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case ITMNOPARITY:
      wReturn = PARITY_NONE;
      break;
   case ITMODDPARITY:
      wReturn = PARITY_ODD;
      break;
   case ITMEVENPARITY:
      wReturn = PARITY_EVEN;
      break;
   case ITMMARKPARITY:
      wReturn = PARITY_MARK;
      break;
   case ITMSPACEPARITY:
      wReturn = PARITY_SPACE;
      break;
   default:
      wReturn = PARITY_NONE;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* getCCB_STOPBITS                                         slc nova 028   */
/**************************************************************************/

WORD getCCB_STOPBITS(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case ITMSTOP1:
      wReturn = STOPBITS_10;
      break;
   case ITMSTOP5:
      wReturn = STOPBITS_15;
      break;
   case ITMSTOP2:
      wReturn = STOPBITS_20;
      break;
   default:
      wReturn = STOPBITS_10;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* getCCB_FLOWCTRL                                         slc nova 028   */
/**************************************************************************/

WORD getCCB_FLOWCTRL(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case ITMXONFLOW:
      wReturn = HANDSHAKE_XONXOFF;
      break;
   case ITMHARDFLOW:
      wReturn = HANDSHAKE_HARDWARE;
      break;
   case ITMNOFLOW:
      wReturn = HANDSHAKE_NONE;
      break;
   case ITMETXFLOW:
      wReturn = HANDSHAKE_ETXFLOW;
      break;
   default:
      wReturn = HANDSHAKE_XONXOFF;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* getCCB_MISCSET                                          slc nova 028   */
/**************************************************************************/

WORD getCCB_MISCSET(WORD wInput1, WORD wInput2)
{
   WORD wReturn = 0;

   if(wInput1)
      wReturn = MISC_CARRIER_DETECT;

   if(wInput2)
      wReturn |= MISC_PARITY_CHECK;

   return(wReturn);
}

/**************************************************************************/

VOID ccbFromTrmParams(LPCONNECTOR_CONTROL_BLOCK lpCCB, recTrmParams *pTrmParams)
{

// -sdj, dec'91 If the trmparams structure  is packed with 1 byte alignment
// -sdj, MIPS compiler breaks while compiling this funciton, I think the line
// -sdj, is: lpCCB->byPadChar = (pTrmParams->commFlags & DCS_CF_NETNAMEPADDING) ? 0x20 : 0x00;
// -sdj, the Fix for this cc bug wont make it into the pdk2, so lets bypass
// -sdj, this function code for the time being
// #ifdef BUGBYPASS
// #else

   lstrcpy(lpCCB->szDLLName, (LPSTR)pTrmParams->szConnectorName); /* slc nova 106 */

   lpCCB->wSpeed         = pTrmParams->speed;             /* seh nova 005 */
   lpCCB->wBaudSet       = getCCB_BAUD(lpCCB->wSpeed);   /* seh nova 005 */
   lpCCB->wDataBitSet    = getCCB_DATABITS(pTrmParams->dataBits);
   lpCCB->wParitySet     = getCCB_PARITY(pTrmParams->parity);
   lpCCB->wStopBitSet    = getCCB_STOPBITS(pTrmParams->stopBits);
   lpCCB->wHandshakeSet  = getCCB_FLOWCTRL(pTrmParams->flowControl);
   lpCCB->wMiscSet       = getCCB_MISCSET(pTrmParams->fCarrier,
                                          pTrmParams->fParity);

   lstrcpy(lpCCB->szPhoneNumber, (LPSTR)pTrmParams->phone); /* slc nova 106 */
   lstrcpy(lpCCB->szClient, (LPSTR)pTrmParams->localName);  /* slc nova 106 */
   lstrcpy(lpCCB->szServer, (LPSTR)pTrmParams->remoteName); /* slc nova 106 */
   lpCCB->byPadChar = (pTrmParams->commFlags & DCS_CF_NETNAMEPADDING) ? 0x20 : 0x00;

   lmovmem((LPSTR)pTrmParams->connectorConfigData, lpCCB->configBuffer, 32); /* slc nova 106 */

// #endif

}

/**************************************************************************/
/* ccbToTrmParams                                           slc nova 028  */
/**************************************************************************/

/**************************************************************************/
/* putCCB_BAUDITM                                          seh nova 005   */
/**************************************************************************/

WORD putCCB_BAUDITM(WORD wID)    /* called by setConnectorSettings() */
{
   WORD wReturn;

   switch(wID)
   {
   case BAUD_075:
      wReturn = ITMBD110;        /* dc does not support yet */
      break;
   case BAUD_110:
      wReturn = ITMBD110;
      break;
   case BAUD_300:
      wReturn = ITMBD300;
      break;
   case BAUD_600:
      wReturn = ITMBD600;
      break;
   case BAUD_120:
      wReturn = ITMBD120;
      break;
   case BAUD_240:
      wReturn = ITMBD240;
      break;
   case BAUD_480:
      wReturn = ITMBD480;
      break;
   case BAUD_960:
      wReturn = ITMBD960;
      break;
   case BAUD_192:
      wReturn = ITMBD192;
      break;
   default:
      wReturn = ITMBD120;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_BAUD                                             seh nova 005   */
/**************************************************************************/

WORD putCCB_BAUD(WORD wID)
{
   WORD wReturn;

   switch(wID)
   {
   case BAUD_075:
      wReturn = 75;
      break;
   case BAUD_110:
      wReturn = 110;
      break;
   case BAUD_300:
      wReturn = 300;
      break;
   case BAUD_600:
      wReturn = 600;
      break;
   case BAUD_120:
      wReturn = 1200;
      break;
   case BAUD_240:
      wReturn = 2400;
      break;
   case BAUD_480:
      wReturn = 4800;
      break;
   case BAUD_960:
      wReturn = 9600;
      break;
   case BAUD_192:
      wReturn = 19200;
      break;
   default:
      wReturn = 1200;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_DATABITS                                         slc nova 028   */
/**************************************************************************/

WORD putCCB_DATABITS(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case DATABITS_5:
      wReturn = ITMDATA5;
      break;
   case DATABITS_6:
      wReturn = ITMDATA6;
      break;
   case DATABITS_7:
      wReturn = ITMDATA7;
      break;
   case DATABITS_8:
      wReturn = ITMDATA8;
      break;
   default:
      wReturn = ITMDATA8;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_PARITY                                           slc nova 028   */
/**************************************************************************/

WORD putCCB_PARITY(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case PARITY_NONE:
      wReturn = ITMNOPARITY;
      break;
   case PARITY_ODD:
      wReturn = ITMODDPARITY;
      break;
   case PARITY_EVEN:
      wReturn = ITMEVENPARITY;
      break;
   case PARITY_MARK:
      wReturn = ITMMARKPARITY;
      break;
   case PARITY_SPACE:
      wReturn = ITMSPACEPARITY;
      break;
   default:
      wReturn = ITMNOPARITY;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_STOPBITS                                         slc nova 028   */
/**************************************************************************/

WORD putCCB_STOPBITS(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case STOPBITS_10:
      wReturn = ITMSTOP1;
      break;
   case STOPBITS_15:
      wReturn = ITMSTOP5;
      break;
   case STOPBITS_20:
      wReturn = ITMSTOP2;
      break;
   default:
      wReturn = ITMSTOP1;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_FLOWCTRL                                         slc nova 028   */
/**************************************************************************/

WORD putCCB_FLOWCTRL(WORD wInput)
{
   WORD wReturn;

   switch(wInput)
   {
   case HANDSHAKE_XONXOFF:
      wReturn = ITMXONFLOW;
      break;
   case HANDSHAKE_HARDWARE:
      wReturn = ITMHARDFLOW;
      break;
   case HANDSHAKE_NONE:
      wReturn = ITMNOFLOW;
      break;
   case HANDSHAKE_ETXFLOW:
      wReturn = ITMETXFLOW;
      break;
   default:
      wReturn = ITMXONFLOW;
      break;
   }

   return(wReturn);
}

/**************************************************************************/
/* putCCB_MISCSET                                          slc nova 028   */
/**************************************************************************/

WORD putCCB_MISCSET(WORD wInput1, WORD wInput2)
{
   WORD wReturn = 0;

   if(wInput1)
      wReturn = MISC_CARRIER_DETECT;

   if(wInput2)
      wReturn |= MISC_PARITY_CHECK;

   return(wReturn);
}

/**************************************************************************/

VOID ccbToTrmParams(recTrmParams *pTrmParams, LPCONNECTOR_CONTROL_BLOCK lpCCB)
{
// -sdj, dec'91 If the trmparams structure  is packed with 1 byte alignment
// -sdj, MIPS compiler breaks while compiling this funciton,
// -sdj, the Fix for this cc bug wont make it into the pdk2, so lets bypass
// -sdj, this function code for the time being
// #ifdef BUGBYPASS
// #else

   lstrcpy((LPSTR)pTrmParams->szConnectorName, lpCCB->szDLLName); /* slc nova 106 */

   pTrmParams->speed       = putCCB_BAUD(lpCCB->wBaudSet);
   pTrmParams->dataBits    = (BYTE)putCCB_DATABITS(lpCCB->wDataBitSet);
   pTrmParams->parity      = (BYTE)putCCB_PARITY(lpCCB->wParitySet);
   pTrmParams->stopBits    = (BYTE)putCCB_STOPBITS(lpCCB->wStopBitSet);
   pTrmParams->flowControl = (BYTE)putCCB_FLOWCTRL(lpCCB->wHandshakeSet);
   pTrmParams->fCarrier    = (lpCCB->wMiscSet & MISC_CARRIER_DETECT) ? 1 : 0;
   pTrmParams->fParity     = (lpCCB->wMiscSet & MISC_PARITY_CHECK) ? 1 : 0;

   lstrcpy((LPSTR)pTrmParams->phone, lpCCB->szPhoneNumber); /* slc nova 106 */
   lstrcpy((LPSTR)pTrmParams->localName, lpCCB->szClient);  /* slc nova 106 */
   lstrcpy((LPSTR)pTrmParams->remoteName, lpCCB->szServer); /* slc nova 106 */
   if(lpCCB->byPadChar == 0x20)
   {
      pTrmParams->commFlags |= DCS_CF_NETNAMEPADDING;
      NETNAMEPADDING = ' ';
   }
   else
   {
      pTrmParams->commFlags &= ~DCS_CF_NETNAMEPADDING;
      NETNAMEPADDING = '\0';
   }

   lmovmem(lpCCB->configBuffer, (LPSTR)pTrmParams->connectorConfigData, 32); /* slc nova 106 */

// #endif
}

/* the end */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\connect.h ===
/* connect.h */

/*************************************************************************
 *  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  JUST COPY AND PASTE THE DEFINES THAT YOU NEED
 *************************************************************************
#define NOORDINALS       TRUE
#define NOPROTOTYPES     TRUE
#define NODLLPROTOTYPES  TRUE
#define NODCPROTOTYPES   TRUE
#define NOCONSTANTS      TRUE
#define NOCONNECTORS     TRUE
#define NOGLOBALS        TRUE
#define NO  TRUE

 *************************************************************************
 */

#ifndef MINCONSTR             /* seh nova 005 */
#define MINCONSTR       64    /* seh nova 005 */
#endif
#ifndef MINRESSTR
#define MINRESSTR       32    /* seh nova 005 this must match dynacomm.h */
#endif

#ifndef NOORDINALS
/* define ordinal values for all exported functions */
#define     ORD_GETDLLTYPE          959
#define     ORD_GETCONNECTCAPS      962
#define     ORD_SETPARAMETERS       800
#define     ORD_GETEXTENDEDINFO     801
#define     ORD_RESETCONNECTOR      802
#define     ORD_EXITCONNECTOR       803
#define     ORD_CONNECTCONNECTOR    804
#define     ORD_READCONNECTOR       805
#define     ORD_WRITECONNECTOR      806
#define     ORD_COMMANDCONNECTOR    807
#define     ORD_DISCONNECTCONNECTOR 808
#define     ORD_SETUPCONNECTOR      809

#endif /* NOORDINALS */



#ifndef NOCONSTANTS
/* constants defined here (listed by function that uses them */

/* GetDLLType */
#define GDT_SHOW_EGO       TRUE
#define GDT_QUIET          FALSE
#define DC_CONNECTOR       4257


/* GetConnectCaps, SetParameters */
#define SET_PARAMETERS     0x0001

#define SP_GETCAPS         0x0001
#define SP_QUIET           0x0000
#define SP_SHOW            0x0002
#define SP_GETDEFAULT      0x0004
#define SP_SETDEFAULT      0x0008

#ifdef ORGCODE
#define SP_PARITY          0x0001
#define SP_BAUD            0x0002
#define SP_DATABITS        0x0004
#define SP_STOPBITS        0x0008
#define SP_HANDSHAKING     0x0010
#define SP_PARITY_CHECK    0x0020
#define SP_CARRIER_DETECT  0x0040
#endif

/* available baud rates */
#define GP_AVAIL_BAUD      0x0002
/* values can be.... */
#ifdef ORGCODE
#define BAUD_075           0x0001
#define BAUD_110           0x0002
#define BAUD_300           0x0004
#define BAUD_600           0x0008

#define BAUD_120           0x0010
#define BAUD_240           0x0020
#define BAUD_480           0x0040
#define BAUD_960           0x0080
#define BAUD_192           0x0100
#else
#define BAUD_120           BAUD_1200
#define BAUD_240           BAUD_2400
#define BAUD_480           BAUD_4800
#define BAUD_960           BAUD_9600
#define BAUD_192           BAUD_19200

#endif

#ifdef ORGCODE
#define BAUD_USER          0x0200
#endif

#define BAUD_ALL (BAUD_075+BAUD_110+BAUD_300+BAUD_600+BAUD_120+BAUD_240+BAUD_480+BAUD_960+BAUD_192+BAUD_USER)
#define BAUD_OFFSET        0x1000      /* tge used for resources */

/* available data bits */
#define GP_AVAIL_DATABITS  0x0004
/* values can be.... */
#ifdef ORGCODE
#define DATABITS_5         0x0001
#define DATABITS_6         0x0002
#define DATABITS_7         0x0004
#define DATABITS_8         0x0008
#endif

#define DATABITS_ALL       (DATABITS_5+DATABITS_6+DATABITS_7+DATABITS_8)
#define DATABITS_OFFSET    0x2000      /* tge used for resources */

/* available stops bits */
#define GP_AVAIL_STOPBITS  0x0008
/* values can be.... */
#ifdef ORGCODE
#define STOPBITS_10        0x0001
#define STOPBITS_15        0x0002
#define STOPBITS_20        0x0004
#endif

#define STOPBITS_ALL       (STOPBITS_10+STOPBITS_15+STOPBITS_20)
#define STOPBITS_OFFSET    0x3000      /* tge used for resources */

/* available parity options */
#define GP_AVAIL_PARITY    0x0010
/* values can be ... */
#ifdef ORGCODE
#define PARITY_NONE        0x0001
#define PARITY_ODD         0x0002
#define PARITY_EVEN        0x0004
#define PARITY_MARK        0x0008
#define PARITY_SPACE       0x0010
#endif

#define PARITY_ALL         (PARITY_NONE+PARITY_ODD+PARITY_EVEN+PARITY_MARK+PARITY_SPACE)
#define PARITY_OFFSET      0x4000      /* tge used for resources */

/* available handshaking */
#define GP_AVAIL_HANDSHAKE 0x0020
/* values can  be...*/
#define HANDSHAKE_XONXOFF  0x0001
#define HANDSHAKE_HARDWARE 0x0002
#define HANDSHAKE_NONE     0x0004
#define HANDSHAKE_ETXFLOW  0x0008

#define HANDSHAKE_ALL      (HANDSHAKE_XONXOFF+HANDSHAKE_HARDWARE+HANDSHAKE_NONE+HANDSHAKE_ETXFLOW)
#define HANDSHAKE_OFFSET   0x5000      /* tge used for resources */

/* misc. options */
#define GP_AVAIL_MISC      0x0040
/* values can be... */
#define MISC_CARRIER_DETECT   0x0001
#define MISC_PARITY_CHECK     0x0002

#define MISC_ALL           (MISC_CARRIER_DETECT+MISC_PARITY_CHECK)
#define MISC_NONE          0x0000
#define MISC_OFFSET        0x6000      /* tge used for resources */


/* GetExtendedInfo */
#define GI_STRSIZE         80
/* if GetExtendedInfo does not have extended info for what we want,
   it gives us this message */
#define GIN_NOINFO                 0xffff
/* else, the following stuff is used */

/* we send GetExtendedInfo this in parameter one and error code in param 2 */
#define GI_ERROR                   0x0000
/* and GetExtended info returns this ... */
#define GIN_ERRWARNING             0x0000
#define GIN_ERRDLLCRASH            0x0001
#define GIN_ERRAPPCRASH            0x0002
#define GIN_ERRSYSCRASH            0x0003
#define GIN_ERRFATAL               0x0004

/* we send GetExtendedInfo this is param 1 */
#define GI_IDENTIFY                0x0001
/* and one of these in param 2 */
#define GI_DLLFILENAME             0x0000    /* put dll file name is param 3 */
#define GI_DLLNAME                 0x0001    /* put dll name is param 3 (used in listbox) */
#define GI_CLIENTNAME              0x0002    /* put client name is param 3 */
#define GI_SERVERNAME              0x0003    /* put server name is param 3 */
#define GI_DLLVERSION              0x0004    /* put version # in param 3 */
#define GI_DLLINIFILENAME          0x0005    /* put ini filename in  param 3 */
#define GI_SETUPBOX                0x0006    /* return TRUE if setup button should be enabled */
/* and GetExtended info returns this ... */
#define GI_OK                      TRUE

/* connector read and write errors */
#define CONNECT_READ_ERROR        0xffff
#define CONNECT_WRITE_ERROR       (CONNECT_READ_ERROR)

/* connector ini list error */
#define CONNECT_NO_CONNECTORS     (-2)


/* CommandConnector */
#define DLL_CMD_BREAK                0x0001

/* ConnectConnector */
#define STAT_CONNECTED                 1        /* slc nova xxx */
#define STAT_NOT_CONNECTED             2        /* slc nova xxx */
#define STAT_WAIT_CONNECT              3        /* bjw nova 002 */
#define STAT_ERROR                     4        /* bjw nova 002 */

/* control block constants */
#define TYPE_MODEM                     0x0001
#define TYPE_NETWORK                   0x0002
#define TYPE_PHYSICAL                  0x0003

#endif /* NOCONSTANTS */


#ifndef NOCONNECTORS
/* User Union (not to be mistaken with the AFL-CIO */

#define  CCB_UNION_SIZE    512               /* seh/slc nova */

typedef union
{
   BYTE     Byte[CCB_UNION_SIZE];
   WORD     Word[CCB_UNION_SIZE / sizeof(WORD)];
   LONG     Long[CCB_UNION_SIZE / sizeof(LONG)];
   PSTR     Pstr[CCB_UNION_SIZE / sizeof(PSTR)];
   LPSTR    Lpstr[CCB_UNION_SIZE / sizeof(LPSTR)];
   HANDLE   Handle[CCB_UNION_SIZE / sizeof(HANDLE)];
}  USER_UNION;

/* Connector Control Block */
typedef struct
{
   WORD     wVersion;            /* version number (always equals 100) */
   HANDLE   hConnectorInst;      /* instance handle of connector DLL   */
   WORD     wType;               /* Type of connection (network, physical, ect...) */
   WORD     wStatus;             /* Status (connected, not connected, ect... */
   WPARAM wParamFlags;         /* flags returned by GetConnectCaps(SET_PARAMETERS) */
   WORD     wBaudFlags;          /* flags returned by GetConnectCaps(GP_AVAIL_BAUD) */
   WORD     wDataBitFlags;       /* flags returned by GetConnectCaps(GP_AVAIL_DATABITS) */
   WORD     wStopBitFlags;       /* flags returned by GetConnectCaps(GP_AVAIL_STOPBITS) */
   WORD     wParityFlags;        /* flags returned by GetConnectCaps(GP_AVAIL_PARITY) */
   WORD     wHandshakeFlags;     /* flags returned by GetConnectCaps(GP_AVAIL_HANDSHAKE) */
   WORD     wMiscFlags;          /* flags returned by GetConnectCaps(GP_AVAIL_MISC) */

   WORD     wSpeed;              /* currently set baud rate (actual value) */ /* seh nova 005 */
   WORD     wBaudSet;            /* currently set baud rate (control id) */
   WORD     wDataBitSet;         /* currently set data bits (control id) */
   WORD     wStopBitSet;         /* currently set stop bits (control id) */
   WORD     wParitySet;          /* currently set parity (control id) */
   WORD     wHandshakeSet;       /* currently set handshaking (control id) */
   WORD     wMiscSet;            /* currently set misc (bit flags) */

   BYTE     szPhoneNumber[MINRESSTR];  /* Phone Number to Dial */
   BYTE     szDLLFileName[MINRESSTR];  /* DOS filename for DLL */
   BYTE     szDLLName[MINRESSTR];      /* Name used in connectors listbox */

   BYTE     szClient[16];        /* client name (for network DLL use) */
   BYTE     szServer[64];        /* server name (for network DLL use) */
   WORD     wNetBiosLNum;        /* slc nova NetBIOS Local Session Number  */
   WORD     wNetBiosRNum;        /* slc nova NetBIOS Remote Session Number */
   WORD     byPadChar;           /* char used for blank padding         */

   WORD     wReadBufferSize;     /* size of read transfer buffer        */
   WORD     wReadBufferRead;     /* actual bytes read                   */ /* bjw nova 002 */
   LPSTR    lpReadBuffer;        /* address of read transfer buffer     */
   HANDLE   hReadBuffer;         /* handle to read transfer buffer      */
   WORD     wWriteBufferSize;    /* size of write transfer buffer       */
   WORD     wWriteBufferUsed;    /* size of write transfer buffer used  */ /* seh nova 005 */
   LPSTR    lpWriteBuffer;       /* address of write transfer buffer    */
   HANDLE   hWriteBuffer;        /* handle to write transfer buffer     */
   LPSTR    lpNCB;               /* address of NetBIOS Control Block    */
   HANDLE   hNCB;                /* handle to NetBIOS Control Block     */
   LPSTR    lpNCBWrite;          /* address of NetBIOS Control Block    */
   HANDLE   hNCBWrite;           /* handle to NetBIOS Control Block     */
   LPSTR    lpNCBRead;           /* address of NetBIOS Control Block    */
   HANDLE   hNCBRead;            /* handle to NetBIOS Control Block     */
   WORD     wTimeRemain;         /* NetBIOS Listen Timeout              */
   BYTE     configBuffer[32];    /* Saved in DCS file (for DLL use)     */

   USER_UNION  User;             /* DLL's are free to use this space
                                    in anyway that they would like to */
}  CONNECTOR_CONTROL_BLOCK, *PCONNECTOR_CONTROL_BLOCK, FAR *LPCONNECTOR_CONTROL_BLOCK;

/* connector array structure */
typedef  struct
{
   WORD   wNumOfChannels;              /* number of opened channels */
   WORD   wTopChannel;                 /* if a session window is the top window, */
                                       /* then this is it's index into CCB array */
   HANDLE hCCBArray;
   LPCONNECTOR_CONTROL_BLOCK  lpCCB[1]; /* array of CCB's (dynamically allocated) */
}  CONNECTORS, *PCONNECTORS, FAR *LPCONNECTORS;

#endif  /* NOCONNECTORS */


#ifndef NOGLOBALS

HANDLE         ghConnectors;        /* global handle to connector data struct */
HANDLE         ghCCB;               /* global handle CONNECTOR_CONTROL_BLOCK */
LPCONNECTORS   xglpConnectors;       /* not used anymore - long pointer to connector data structure */
HANDLE         ghWorkConnector;     /* handle for temporary connector work (settings) */
BYTE           gszWork[MINCONSTR];  /* slc nova xxx */

#endif  /* NOGLOBALS */


#ifndef NOPROTOTYPES
/* exported functions  prototypes */

#ifndef NODLLPROTOTYPES
/* Connect DLL's */
WORD  APIENTRY GetDLLType(HWND, BOOL);
WORD  APIENTRY GetConnectCaps(WORD);
WORD  APIENTRY SetParameters(WORD, LPCONNECTOR_CONTROL_BLOCK);
WORD  APIENTRY GetExtendedInfo(WORD, WORD, LPSTR);
WORD  APIENTRY ResetConnector(HWND, LPCONNECTOR_CONTROL_BLOCK, BOOL);
WORD  APIENTRY ExitConnector(HWND, LPCONNECTOR_CONTROL_BLOCK, BOOL);
WORD  APIENTRY ConnectConnector(HWND, LPCONNECTOR_CONTROL_BLOCK, BOOL);
WORD  APIENTRY ReadConnector(LPCONNECTOR_CONTROL_BLOCK);
WORD  APIENTRY WriteConnector(LPCONNECTOR_CONTROL_BLOCK);
WORD  APIENTRY CommandConnector(HWND, LPCONNECTOR_CONTROL_BLOCK, WORD, LONG);
WORD  APIENTRY DisconnectConnector(HANDLE, LPCONNECTOR_CONTROL_BLOCK);

#endif /* NODLLPROTOTYPES */

#ifndef NODCPROTOTYPES
/* DynaComm */
BOOL     initConnectors(BOOL);
VOID     addConnectorList(HWND, WORD);   /* slc nova 031 */
HANDLE   loadConnector(HWND, HANDLE, LPSTR, BOOL); /* slc nova 031 */
WORD     getConnectorCaps(LPCONNECTOR_CONTROL_BLOCK); /* slc nova 031 */
WORD     setConnectorSettings(HWND, HANDLE, BOOL);
WORD     getConnectorSettings(LPCONNECTOR_CONTROL_BLOCK, BOOL);   /* slc nova 031 */
WORD     DLL_ResetConnector(HANDLE, BOOL);   /* slc nova 031 */
WORD     DLL_SetupConnector(HANDLE, BOOL);   /* slc nova 031 */
WORD     DLL_ExitConnector(HANDLE, recTrmParams *);
WORD     DLL_ConnectConnector(HANDLE, BOOL);    /* slc nova 031 */
WORD     DLL_ReadConnector(HANDLE);          /* slc nova 031 */
WORD     DLL_WriteConnector(HANDLE);         /* slc nova 031 */
WORD     DLL_CommandConnector(HANDLE, LPCONNECTOR_CONTROL_BLOCK, WORD, LONG);
WORD     DLL_DisconnectConnector(HANDLE hCCB);  /* slc nova 031 seh nova 005 */
WORD     DLL_modemSendBreak(HANDLE, INT);
WORD     DLL_ConnectBytes(HANDLE);           /* slc nova 031 */
WORD     getConnectType(HANDLE hConnector, HANDLE hCCB);  /* seh nova 005 */
VOID     ccbFromTrmParams(LPCONNECTOR_CONTROL_BLOCK, recTrmParams *);
VOID     ccbToTrmParams(recTrmParams *, LPCONNECTOR_CONTROL_BLOCK);
BOOL     DLL_HasSetupBox(HANDLE hConnector); /* seh nova 006 */

WORD     putCCB_BAUDITM(WORD);               /* slc nova xxx */
WORD     putCCB_BAUD(WORD);
WORD     putCCB_DATABITS(WORD);
WORD     putCCB_PARITY(WORD);
WORD     putCCB_STOPBITS(WORD);
WORD     putCCB_FLOWCTRL(WORD);
WORD     putCCB_MISCSET(WORD, WORD);

#endif /* NODCPROTOTYPES */
#endif /* NOPROTOTYPES */

/* taken from dcrc.h bjw nova 002 */
#ifdef NEED_DCRC
/* bjw gold 027  - the evil warning! */
/*****************************************************************************
 * B I G - T I M E ,   W A R N I N G !,  W A R N I N G !,  W A R N I N G !
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * If any of the folling ID's change (and you better have a good reason!)
 * make sure and change the corresponding ID's in any DLL that uses them and
 * recompile DynaComm and ALL connector DLL's.
 * If you really have to change one of these items, DynaComm will no longer
 * be compatible with earlier settings files or connector DLL's.
 * I WARNED YOU!
 *
 ******************************************************************************/

#define ITMSETUP                 3           /* seh nova 005 */

#define IDDBCOMM                 7

#define ITMBD110                 11
#define ITMBD300                 12
#define ITMBD600                 13          /* mbbx 2.00: support 600 baud */
#define ITMBD120                 14
#define ITMBD240                 15
#define ITMBD480                 16
#define ITMBD960                 17
#define ITMBD192                 18

#define ITMDATA4                 21          /* not used */
#define ITMDATA5                 22
#define ITMDATA6                 23
#define ITMDATA7                 24
#define ITMDATA8                 25

#define ITMSTOP1                 31
#define ITMSTOP5                 32
#define ITMSTOP2                 33

#define ITMNOPARITY              41
#define ITMODDPARITY             42
#define ITMEVENPARITY            43
#define ITMMARKPARITY            44
#define ITMSPACEPARITY           45

#define ITMXONFLOW               51
#define ITMHARDFLOW              52
#define ITMNOFLOW                53
#define ITMETXFLOW               54          /* jtfx 2.01.75 ... */

#define ITMCONNECTOR             61

#define ITMPARITY                91
#define ITMCARRIER               92

#endif /* NEED_DCRC */

/* WINCIM typedef's */

typedef CONNECTOR_CONTROL_BLOCK 	CCB;
typedef CCB FAR *			LPCCB;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcutil3.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "video.h"


/*---------------------------------------------------------------------------*/
/* offCursor() - Turn off terminal emulation cursor.                  [scf]  */
/*---------------------------------------------------------------------------*/

VOID offCursor ()
{
   if (activTerm)
   {
      cursorOn--;
      if (cursorOn == 0)
      {
         if (cursBlinkOn)
            toggleCursor(&cursorRect);
      }
      else
         if(cursorOn < 0)
            cursorOn = 0;
   }
}


/*---------------------------------------------------------------------------*/
/* onCursor() - Turn on the terminal emulation cursor.                [scf]  */
/*---------------------------------------------------------------------------*/

VOID onCursor ()
{
   if (activTerm)
   {
      cursorOn++;
      if (cursorOn == 1)
      {
         cursorTick = 1;
         rectCursor (&cursorRect);
         cursBlinkOn = FALSE;
         toggleCursor (&cursorRect);
      }
      else
         if (cursorOn > 1)
            cursorOn = 1;
   }
}


/*---------------------------------------------------------------------------*/
/* rectCursor() - Set the terminal cursor rectangle.                  [scf]  */
/*---------------------------------------------------------------------------*/

VOID rectCursor(RECT *theRect)
{
   if(activCursor > 0)
   {
      if(statusLine)
         theRect->top = statusRect.top + (STATUSRECTBORDER / 2);
      else
         theRect->top = (savTopLine - curTopLine + curLin) * chrHeight;

      theRect->bottom = theRect->top + chrHeight;
      if(trmParams.termCursor != ITMBLKCURSOR)
         theRect->top += ((3 * chrHeight) / 4);
      else
         theRect->top++; /* jtf terminal changed to make cursor smaller */

      if(statusLine || (attrib[curLin][LATTRIB] == LNORMAL))
      {
         theRect->left  = (curCol - curLeftCol) * chrWidth;
         theRect->right = theRect->left + chrWidth;
      }
      else
      {
         theRect->left  = curCol * chrWidth * 2 - curLeftCol * chrWidth;
         theRect->right = theRect->left + chrWidth * 2;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* toggleCursor() - Toggle the terminal emulation cursor visible or not      */
/*---------------------------------------------------------------------------*/

VOID toggleCursor(RECT *theRect)
{
   RECT  clientRect;

   if(activCursor > 0)
   {
      getPort();

      cursBlinkOn = !cursBlinkOn;
                                             /* mbbx 1.04: for lack of a better method... */
      if(theRect->top == statusRect.top + (STATUSRECTBORDER / 2))
         clipRect(&statusRect);
      else
         clipRect(&hTE.viewRect);
      InvertRect(thePort, theRect);

      releasePort();
   }
}


/*---------------------------------------------------------------------------*/
/* hideTermCursor                                                            */
/*---------------------------------------------------------------------------*/

VOID hideTermCursor ()
{
   if (activCursor == 1)
      offCursor ();
   activCursor--;
}

/*---------------------------------------------------------------------------*/
/* showTermCursor                                                            */
/*---------------------------------------------------------------------------*/

VOID showTermCursor ()
{
   activCursor++;
   if (activCursor == 1)
      onCursor ();
}


/*---------------------------------------------------------------------------*/
/* stripBlanks() - Purge unecessary CHFILL's for text file.            [scf] */
/*---------------------------------------------------------------------------*/

VOID stripBlanks (LPBYTE ptr, DWORD *len)
{
   register INT src;
   register INT dst;
   INT deltaLen;

   ptr[*len]     = 0;                     /* Terminate for 'C'            */
   for (src = (INT) *len; src > 0; src = dst - 1)
   {
      while ( (src > 0) && (ptr[src] != CR) ) /* jtf 3.11 fixed segmentation error */
         src--;
      dst = src - 1;
      while ((dst > 0) && (ptr[dst] == CHFILL) ) /* jtf 3.11 fixed segmentation error */
         dst--;
      dst++;
      deltaLen = src - dst;
      lmovmem (&ptr[src], &ptr[dst], (DWORD) (*len - src));
      *len -= (DWORD) deltaLen;
   }
   ptr[*len] = 0;
}


/*---------------------------------------------------------------------------*/
/* loadTermFont() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID loadTermFont(LOGFONT *logFont)
{
   HFONT       hOldFont;
   TEXTMETRIC  fontMetrics;
   INT         ndx;

   hOldFont = hTE.hFont;

   if((hTE.hFont = CreateFontIndirect(logFont)) != hOldFont)
   {
      getPort();
      SelectObject(thePort, hTE.hFont);
      GetTextMetrics(thePort, &fontMetrics);
      releasePort();

      stdChrHeight = chrHeight = fontMetrics.tmHeight;
      stdChrWidth  = chrWidth  = fontMetrics.tmMaxCharWidth; 

      for(ndx = 0; ndx < 256; ndx += 1)
         vidCharWidths[ndx] = chrWidth;

      if(hOldFont != NULL)
      {
         DeleteObject(hOldFont);
         clearFontCache();
         resetEmul();
         if(!IsIconic(hItWnd))   /* rjs bugs 015 */
            sizeTerm(0L);
      }
   }
}



/*---------------------------------------------------------------------------*/
/* nextFontSize() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

INT  APIENTRY  nextFontSize(const LOGFONT *lpLogFont, const TEXTMETRIC *lpTextMetrics, 
                            DWORD FontType, LPARAM lpParam)
{
   LPSTR lpData = (LPSTR)lpParam;
   INT   ndx, ndx2;

   if(*lpData != 0)
   {
      if (FontType & RASTER_FONTTYPE) 
      {
         for(ndx = 1; ndx <= 5; ndx += 1)
         {
            if((ndx2 = lpLogFont->lfHeight * ndx) > *lpData)
               break;
            lpData[ndx2] = (char)lpLogFont->lfHeight;

            if(lpLogFont->lfQuality == PROOF_QUALITY)    /* no scaling... */
               break;
         }
      }
      else                                   /* vector font... */
         lsetmem(lpData+1, lpLogFont->lfHeight, *lpData);
   }
   else if(lpLogFont->lfHeight == lpData[1])
   {
      lmovmem(lpLogFont, lpData, sizeof(LOGFONT));

      return(FALSE);
   }

   return(TRUE);                             /* continue... */
}


/*---------------------------------------------------------------------------*/
/* listFontSizes() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID listFontSizes(BYTE *faceName, BYTE *sizeList, INT maxSize)
{
   memset(sizeList+1, 0, *sizeList = (BYTE)maxSize);

   getPort();
   EnumFonts(thePort, faceName, nextFontSize, (LPARAM) sizeList);
   releasePort();
}


/*---------------------------------------------------------------------------*/
/* buildTermFont() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID buildTermFont()                         /* mbbx 2.00: font selection... */
{
   BYTE     sizeList[64];
   LOGFONT  logFont;

   if((hTE.hFont != NULL) && (trmParams.fontSize > 0))
   {
      strcpy(sizeList, trmParams.fontFace);
      AnsiUpper((LPSTR)sizeList);
      if(!strcmp(sizeList, "SYSTEM"))
         LoadString(hInst, STR_INI_FONTFACE, trmParams.fontFace, LF_FACESIZE);

      listFontSizes(trmParams.fontFace, sizeList, 64-1);

      if((logFont.lfHeight = (sizeList[trmParams.fontSize] * 256)) != 0)
      {
         getPort();
         EnumFonts(thePort, trmParams.fontFace, nextFontSize, (LPARAM) &logFont);
         releasePort();
      }
   }
   else
      logFont.lfHeight = 0;

   if(LOBYTE(logFont.lfHeight) == 0)
   {
      logFont.lfEscapement     = 0;
      logFont.lfOrientation    = 0;
      logFont.lfWeight         = 0; /* rjs bugs 017 -> 0 to 200 */
      logFont.lfItalic         = FALSE;
      logFont.lfUnderline      = FALSE;
      logFont.lfStrikeOut      = FALSE;
      logFont.lfCharSet        = ANSI_CHARSET;
      logFont.lfOutPrecision   = OUT_DEFAULT_PRECIS;
      logFont.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
      logFont.lfQuality        = DEFAULT_QUALITY;
      logFont.lfPitchAndFamily = FF_DONTCARE;
      strcpy(logFont.lfFaceName, trmParams.fontFace);
   }

   logFont.lfHeight = trmParams.fontSize;
   logFont.lfWidth = 0;

   loadTermFont(&logFont);
}


/*---------------------------------------------------------------------------*/
/* clearFontCache() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID clearFontCache()                        /* mbbx 1.10 ... */
{
   INT   ndx;

   for(ndx = 0; ndx < VID_MAXFONTCACHE; ndx += 1)
   {
      if(vidFontCache[ndx].hFont != NULL)
      {
         DeleteObject(vidFontCache[ndx].hFont);
         vidFontCache[ndx].hFont = NULL;
         vidFontCache[ndx].flags = 0;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* calcDefaultAttrib() -                                               [jtf] */
/*---------------------------------------------------------------------------*/

VOID calcDefaultAttrib()                     /* mbbx 1.03 ... */
{
   INT   ndx;

   for(ndx = 3; ndx < 32; ndx += 1)          /* skip NORMAL, BOLD, REVERSE */
   {
      if((ndx == ABLINK) || (ndx == AUNDERLINE) || (ndx == APROTECT))
         continue;

      if(vidAttr[ndx].flags & VID_CALCTEXT)
      {
         vidAttr[ndx].text[VID_RED]   = 0;
         vidAttr[ndx].text[VID_GREEN] = 0;
         vidAttr[ndx].text[VID_BLUE]  = 0;
      }

      if(vidAttr[ndx].flags & VID_CALCBKGD)
      {
         vidAttr[ndx].bkgd[VID_RED]   = 0;
         vidAttr[ndx].bkgd[VID_GREEN] = 0;
         vidAttr[ndx].bkgd[VID_BLUE]  = 0;
      }

      if(vidAttr[ndx].flags & VID_CALCATTR)
         vidAttr[ndx].flags &= (VID_CALCTEXT | VID_CALCBKGD | VID_CALCATTR);

      if(ndx & ABOLD)
      {
         if(vidAttr[ndx].flags & VID_CALCTEXT)
         {
            vidAttr[ndx].text[VID_RED]   = min(vidAttr[ndx].text[VID_RED]   + vidAttr[ABOLD].text[VID_RED], 255);
            vidAttr[ndx].text[VID_GREEN] = min(vidAttr[ndx].text[VID_GREEN] + vidAttr[ABOLD].text[VID_GREEN], 255);
            vidAttr[ndx].text[VID_BLUE]  = min(vidAttr[ndx].text[VID_BLUE]  + vidAttr[ABOLD].text[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCBKGD)
         {
            vidAttr[ndx].bkgd[VID_RED]   = min(vidAttr[ndx].bkgd[VID_RED]   + vidAttr[ABOLD].bkgd[VID_RED], 255);
            vidAttr[ndx].bkgd[VID_GREEN] = min(vidAttr[ndx].bkgd[VID_GREEN] + vidAttr[ABOLD].bkgd[VID_GREEN], 255);
            vidAttr[ndx].bkgd[VID_BLUE]  = min(vidAttr[ndx].bkgd[VID_BLUE]  + vidAttr[ABOLD].bkgd[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCATTR)
            vidAttr[ndx].flags |= (vidAttr[ABOLD].flags & VID_MASK);
      }

      if(ndx & AREVERSE)
      {
         if(vidAttr[ndx].flags & VID_CALCTEXT)
         {
            vidAttr[ndx].text[VID_RED]   = min(vidAttr[ndx].text[VID_RED]   + vidAttr[AREVERSE].text[VID_RED], 255);
            vidAttr[ndx].text[VID_GREEN] = min(vidAttr[ndx].text[VID_GREEN] + vidAttr[AREVERSE].text[VID_GREEN], 255);
            vidAttr[ndx].text[VID_BLUE]  = min(vidAttr[ndx].text[VID_BLUE]  + vidAttr[AREVERSE].text[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCBKGD)
         {
            vidAttr[ndx].bkgd[VID_RED]   = min(vidAttr[ndx].bkgd[VID_RED]   + vidAttr[AREVERSE].bkgd[VID_RED], 255);
            vidAttr[ndx].bkgd[VID_GREEN] = min(vidAttr[ndx].bkgd[VID_GREEN] + vidAttr[AREVERSE].bkgd[VID_GREEN], 255);
            vidAttr[ndx].bkgd[VID_BLUE]  = min(vidAttr[ndx].bkgd[VID_BLUE]  + vidAttr[AREVERSE].bkgd[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCATTR)
            vidAttr[ndx].flags |= (vidAttr[AREVERSE].flags & VID_MASK);
      }

      if(ndx & ABLINK)
      {
         if(vidAttr[ndx].flags & VID_CALCTEXT)
         {
            vidAttr[ndx].text[VID_RED]   = min(vidAttr[ndx].text[VID_RED]   + vidAttr[ABLINK].text[VID_RED], 255);
            vidAttr[ndx].text[VID_GREEN] = min(vidAttr[ndx].text[VID_GREEN] + vidAttr[ABLINK].text[VID_GREEN], 255);
            vidAttr[ndx].text[VID_BLUE]  = min(vidAttr[ndx].text[VID_BLUE]  + vidAttr[ABLINK].text[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCBKGD)
         {
            vidAttr[ndx].bkgd[VID_RED]   = min(vidAttr[ndx].bkgd[VID_RED]   + vidAttr[ABLINK].bkgd[VID_RED], 255);
            vidAttr[ndx].bkgd[VID_GREEN] = min(vidAttr[ndx].bkgd[VID_GREEN] + vidAttr[ABLINK].bkgd[VID_GREEN], 255);
            vidAttr[ndx].bkgd[VID_BLUE]  = min(vidAttr[ndx].bkgd[VID_BLUE]  + vidAttr[ABLINK].bkgd[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCATTR)
            vidAttr[ndx].flags |= (vidAttr[ABLINK].flags & VID_MASK);
      }

      if(ndx & AUNDERLINE)
      {
         if(vidAttr[ndx].flags & VID_CALCTEXT)
         {
            vidAttr[ndx].text[VID_RED]   = min(vidAttr[ndx].text[VID_RED]   + vidAttr[AUNDERLINE].text[VID_RED], 255);
            vidAttr[ndx].text[VID_GREEN] = min(vidAttr[ndx].text[VID_GREEN] + vidAttr[AUNDERLINE].text[VID_GREEN], 255);
            vidAttr[ndx].text[VID_BLUE]  = min(vidAttr[ndx].text[VID_BLUE]  + vidAttr[AUNDERLINE].text[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCBKGD)
         {
            vidAttr[ndx].bkgd[VID_RED]   = min(vidAttr[ndx].bkgd[VID_RED]   + vidAttr[AUNDERLINE].bkgd[VID_RED], 255);
            vidAttr[ndx].bkgd[VID_GREEN] = min(vidAttr[ndx].bkgd[VID_GREEN] + vidAttr[AUNDERLINE].bkgd[VID_GREEN], 255);
            vidAttr[ndx].bkgd[VID_BLUE]  = min(vidAttr[ndx].bkgd[VID_BLUE]  + vidAttr[AUNDERLINE].bkgd[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCATTR)
            vidAttr[ndx].flags |= (vidAttr[AUNDERLINE].flags & VID_MASK);
      }

      if(ndx & APROTECT)
      {
         if(vidAttr[ndx].flags & VID_CALCTEXT)
         {
            vidAttr[ndx].text[VID_RED]   = min(vidAttr[ndx].text[VID_RED]   + vidAttr[APROTECT].text[VID_RED], 255);
            vidAttr[ndx].text[VID_GREEN] = min(vidAttr[ndx].text[VID_GREEN] + vidAttr[APROTECT].text[VID_GREEN], 255);
            vidAttr[ndx].text[VID_BLUE]  = min(vidAttr[ndx].text[VID_BLUE]  + vidAttr[APROTECT].text[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCBKGD)
         {
            vidAttr[ndx].bkgd[VID_RED]   = min(vidAttr[ndx].bkgd[VID_RED]   + vidAttr[APROTECT].bkgd[VID_RED], 255);
            vidAttr[ndx].bkgd[VID_GREEN] = min(vidAttr[ndx].bkgd[VID_GREEN] + vidAttr[APROTECT].bkgd[VID_GREEN], 255);
            vidAttr[ndx].bkgd[VID_BLUE]  = min(vidAttr[ndx].bkgd[VID_BLUE]  + vidAttr[APROTECT].bkgd[VID_BLUE], 255);
         }

         if(vidAttr[ndx].flags & VID_CALCATTR)
            vidAttr[ndx].flags |= (vidAttr[APROTECT].flags & VID_MASK);
      }
   }
}


/*---------------------------------------------------------------------------*/
/* setDefaultAttrib() -                                                [jtf] */
/*---------------------------------------------------------------------------*/

VOID setDefaultAttrib(BOOL bLoad)
{
   BYTE  szSection[MINRESSTR], szKeyWord[MINRESSTR], szDefault[MINRESSTR];
   BYTE  work[16];
#ifdef ORGCODE
   INT   text[3], bkgd[3];
#else
   DWORD text[3], bkgd[3];         // -sdj 10/8/91 bug#3279
#endif
   INT   ndx;

   clearFontCache();


   LoadString(hInst, STR_INI_COLORS, szSection, MINRESSTR);
   LoadString(hInst, STR_INI_WINDOWTEXT, szKeyWord, MINRESSTR);
   LoadString(hInst, STR_INI_TEXTCOLOR, szDefault, MINRESSTR);
   GetProfileString(szSection, szKeyWord, szDefault, work, 16-1);

   sscanf(work, "%d %d %d", text+0, text+1, text+2);

   LoadString(hInst, STR_INI_WINDOW, szKeyWord, MINRESSTR);
   LoadString(hInst, STR_INI_BKGDCOLOR, szDefault, MINRESSTR);
   GetProfileString(szSection, szKeyWord, szDefault, work, 16-1);

   sscanf(work, "%d %d %d", bkgd+0, bkgd+1, bkgd+2);

   for(ndx = 0; ndx < 32; ndx += 1)

   {
// -sdj 10/8/91 bug#3279 remove the hardcoded color stuff, new crt libs are in

      vidAttr[ndx].text[VID_RED]   = (BYTE)text[VID_RED];
      vidAttr[ndx].text[VID_GREEN] = (BYTE)text[VID_GREEN];
      vidAttr[ndx].text[VID_BLUE]  = (BYTE)text[VID_BLUE];

      vidAttr[ndx].bkgd[VID_RED]   = (BYTE)bkgd[VID_RED];
      vidAttr[ndx].bkgd[VID_GREEN] = (BYTE)bkgd[VID_GREEN];
      vidAttr[ndx].bkgd[VID_BLUE]  = (BYTE)bkgd[VID_BLUE];
      vidAttr[ndx].flags = VID_CALCATTR | VID_CALCBKGD | VID_CALCTEXT;
   }

   vidAttr[ANORMAL].flags    = 0;
   vidAttr[ABOLD].flags      = VID_BOLD;
   vidAttr[AREVERSE].flags   = VID_REVERSE;
   vidAttr[ABLINK].flags     = VID_BOLD;
   vidAttr[AUNDERLINE].flags = VID_UNDERLINE;
   vidAttr[APROTECT].flags   = VID_REVERSE;

   calcDefaultAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dofile.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "fileopen.h"
#include "task.h"
#include <direct.h> /* adding this for getcwd prototype - sdj */


/*---------------------------------------------------------------------------*/
/* File Document Data Routines                                         [mbb] */
/*---------------------------------------------------------------------------*/

VOID getFileDocData(FILEDOCTYPE fileDocType, BYTE *filePath, BYTE *fileName,
                    BYTE *fileExt, BYTE *title)
{
   if(filePath != NULL)
      strcpy(filePath, fileDocData[fileDocType].filePath);
   if(fileName != NULL)
      strcpy(fileName, fileDocData[fileDocType].fileName);
   if(fileExt != NULL)
      strcpy(fileExt, fileDocData[fileDocType].fileExt);
   if(title != NULL)
      strcpy(title, fileDocData[fileDocType].title);
}


VOID setFileDocData(FILEDOCTYPE fileDocType, BYTE *filePath, BYTE *fileName,
                    BYTE *fileExt, BYTE *title)
{
   if(filePath != NULL)
      strcpy(fileDocData[fileDocType].filePath, filePath);
   if(fileName != NULL)
      strcpy(fileDocData[fileDocType].fileName, fileName);
   if(fileExt != NULL)
      strcpy(fileDocData[fileDocType].fileExt, fileExt);
   if(title != NULL)
   {
      if(strlen(title) >= FO_MAXPATHLENGTH)
         title[FO_MAXPATHLENGTH-1] = 0;
      strcpy(fileDocData[fileDocType].title, title);
   }
}


VOID getDataPath(FILEDOCTYPE fileDocType, BYTE *filePath, BYTE *fileName)
{
   BYTE  savePath[FO_MAXPATHLENGTH];

   if(setPath(fileDocData[fileDocType].filePath, FALSE, savePath))
   {
      setFilePath(fileName);
#ifdef ORGCODE
      _getcwd(filePath);
#else
      _getcwd(filePath,PATHLEN);
#endif

      setPath(savePath, FALSE, NULL);
   }
}


/*---------------------------------------------------------------------------*/
/* dbFileType() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL  APIENTRY dbFileType(HWND hDlg, UINT message, WPARAM wParam, LONG lParam)
//HWND  hDlg;
//UINT  message;
//WPARAM wParam;
//LONG  lParam;
{
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      switch(saveFileType)
      {
      case FILE_NDX_SETTINGS:
         wParam = ITMSETTINGS;
         break;
      }
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         switch(whichGrpButton(hDlg, ITMSETTINGS, ITMMEMO))
         {
         case ITMSETTINGS:
            wParam = FILE_NDX_SETTINGS;
            break;
         }
         break;

      case IDCANCEL:
         wParam = FALSE;
         break;

      default:
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   EndDialog(hDlg, wParam);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* doFileNew() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/


VOID doFileNew()
{
   INT      fileType;
   BYTE     szTitle[MINRESSTR];

   fileType = FILE_NDX_SETTINGS;

   if(childZoomStatus(0x0001, 0))
      childZoomStatus(0, 0x8000);

   LoadString(hInst, STR_TERMINAL, szTitle, MINRESSTR);
   termFile(fileDocData[fileType].filePath, NULL_STR, fileDocData[fileType].fileExt, 
            (*fileDocData[fileType].title == 0) ? szTitle : fileDocData[fileType].title, 
            (*fileDocData[fileType].title == 0) ? TF_DEFTITLE : 0);
}


/*---------------------------------------------------------------------------*/
/* doFileOpen() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY FO_FileOpenType(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   INT   fileType;

   switch(message)
   {
   case WM_INITDIALOG:
      switch(pFOData->nType = saveFileType)
      {
      case FILE_NDX_SETTINGS:
         wParam = FO_IDSETTINGS;
         break;
      }
      break;

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case FO_IDSETTINGS:
         fileType = FILE_NDX_SETTINGS;
         break;
      default:
         return(TRUE);
      }
      if(pFOData->nType == fileType)
         return(TRUE);
      pFOData->nType = fileType;
      break;

   case WM_NULL:
      if(wParam)
         saveFileType = pFOData->nType;
      return(FALSE);
   }

   return(FALSE);
}


VOID doFileOpen()
{
   BYTE     filePath[FO_MAXPATHLENGTH];
   BYTE     fileName[FO_MAXFILELENGTH];
   BYTE     fileExt[FO_MAXEXTLENGTH];
   BYTE     szTitle[MINRESSTR];

   *filePath = 0;
   *fileName = 0;
   *fileExt  = 0;

   strcpy(fileName, "*.TRM");
   strcpy(fileExt, "TRM");

   if(termData.filePath[strlen(termData.filePath) - 1] != '\\')
      strcat(termData.filePath, "\\");

   if(FileOpen(termData.filePath, fileName, NULL, fileExt, NULL, FO_DBFILETYPE, 
               FO_FileOpenType, FO_FILEEXIST | FO_FORCEEXTENT))
   {
      strcpy(fileDocData[saveFileType].filePath, filePath);
      strcpy(fileDocData[saveFileType].fileName, fileName);

      if(childZoomStatus(0x0001, 0))
         childZoomStatus(0, 0x8000);

      LoadString(hInst, STR_TERMINAL, szTitle, MINRESSTR);
      termFile(termData.filePath, fileName, fileDocData[FILE_NDX_SETTINGS].fileExt,
               (*fileDocData[FILE_NDX_SETTINGS].title == 0) ? szTitle : fileDocData[FILE_NDX_SETTINGS].title, 
               (*fileDocData[FILE_NDX_SETTINGS].title == 0) ? TF_DEFTITLE : 0);
   }
}


/*---------------------------------------------------------------------------*/
/* doFileClose() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID doFileClose()
{
      termCloseFile();
}


/*---------------------------------------------------------------------------*/
/* doFileSave() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

VOID doFileSave()
{
      termSaveFile(FALSE);
}


/*---------------------------------------------------------------------------*/
/* doFileSaveAs() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID doFileSaveAs()
{
      termSaveFile(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcutil2.c ===
/*===========================================================================*/
/*          Copyright (c) 1985 - 1986, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"


WORD fDisableMoreCtrl;


/*---------------------------------------------------------------------------*/
/* dbmyControls() - Function keys dialog box message processor.        [mbb] */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbmyControls(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   BOOL  result = FALSE;
   RECT  clipRect;
   WORD  wTemp;

   switch(message)
   {
   case WM_ACTIVATE:
      result = GET_WM_ACTIVATE_STATE(wParam, lParam);
      break;

   case WM_ERASEBKGND:                       /* mbbx 2.00: dlg & ctrl bkgd... */
      GetClipBox((HDC) wParam, &clipRect);
      FillRect((HDC) wParam, &clipRect, (HBRUSH) GetStockObject(GRAY_BRUSH));
      return(TRUE);

   case WM_CTLCOLOR:
      return((INT_PTR) GetStockObject(HOLLOW_BRUSH));

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDSTOP:                           /* mbbx 2.00: xfer ctrls... */
         if(result = updateFKeyButton(wParam, lParam, FKB_UPDATE_BKGD))
            xferStopBreak(!xferBreak);
         break;

      case IDPAUSE:                          /* mbbx 2.00: xfer ctrls... */
         if(result = updateFKeyButton(wParam,lParam, FKB_UPDATE_BKGD))
            xferPauseResume(!xferPaused, xferPaused);
         break;

      case IDFK1:
      case IDFK2:
      case IDFK3:
      case IDFK4:
      case IDFK5:
      case IDFK6:
      case IDFK7:
      case IDFK8:
#ifdef ORGCODE

         if(result = updateFKeyButton(lParam, FKB_UPDATE_BKGD |
                                      ((*trmParams.fKeyText[curLevel-1][wParam-IDFK1] != 0) ? 0 : FKB_DISABLE_CTRL)))
#else

         wTemp = GET_WM_COMMAND_ID(wParam,lParam);
         if(result = updateFKeyButton(wParam, lParam, 
                                      FKB_UPDATE_BKGD |
                                      ((*trmParams.fKeyText[curLevel-1][wTemp-IDFK1] != 0) ? 0 : FKB_DISABLE_CTRL)))
#endif
         {
            selectFKey((UINT)wParam);
         }
         break;

      case IDMORE:
      case IDFK9:
#ifdef ORGCODE
         if(result = updateFKeyButton(lParam, FKB_UPDATE_BKGD | fDisableMoreCtrl))  /* mbbx 2.00: fkeys */
#else
         if(result = updateFKeyButton(wParam, lParam, FKB_UPDATE_BKGD | fDisableMoreCtrl))  /* mbbx 2.00: fkeys */
#endif
            setFKeyLevel(-1, FALSE);         /* mbbx 2.00: bReset */
         break;

      case IDTIMER:
      case IDFK10:
#ifdef ORGCODE
         if(result = updateFKeyButton(lParam, FKB_UPDATE_BKGD | FKB_UPDATE_TIMER))  /* mbbx 2.00: fkeys */
#else
         if(result = updateFKeyButton(wParam, lParam, FKB_UPDATE_BKGD | FKB_UPDATE_TIMER))  /* mbbx 2.00: fkeys */
#endif
            timerToggle(FALSE);              /* mbbx 1.03 */
         break;
      }

      if(result && (hDlg == hdbXferCtrls))
         BringWindowToTop(hTermWnd);
      break;
   }

   if(result)
      selectTopWindow();

   return(result);
}


/*---------------------------------------------------------------------------*/
/* updateFKeyButton() -                                               [mbb] */
/*---------------------------------------------------------------------------*/

BOOL fKeyStrBuffer(BYTE *str, WORD len)
{
   if(fKeyNdx > *fKeyStr)
   {
      if(len == 1)
         return(sendKeyInput(*str));

      memcpy(fKeyStr+1, str, *fKeyStr = (BYTE)len);
      fKeyNdx = 1;
      return(TRUE);
   }

   if(fKeyNdx > 1)
   {
      memcpy(fKeyStr+1, fKeyStr+fKeyNdx, (*fKeyStr+1)-fKeyNdx);
      *fKeyStr -= (fKeyNdx-1);
      fKeyNdx = 1;
   }

   if(*fKeyStr+len >= STR255-1)
      return(FALSE);

   memcpy(fKeyStr+(*fKeyStr+1), str, len);
   *fKeyStr += len;
   return(TRUE);
}


void  selectFKey(UINT wIDFKey)
//WORD  wIDFKey;
{
   fKeyStrBuffer(trmParams.fKeyText[curLevel-1][wIDFKey-IDFK1], 
                 strlen(trmParams.fKeyText[curLevel-1][wIDFKey-IDFK1]));
}


/*---------------------------------------------------------------------------*/
/* setFKeyTitles() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID setFKeyTitles()
{
   INT   ndx;
   BYTE  str[STR255];
   CHAR  szBuffer[16];
   DEBOUT("setKKeyTitles: curLevel = %d\n",curLevel);
   DEBOUT("setKKeyTitles:%s\n","SetWindowText BUG? check this out, HACK return");

   for(ndx = 0; ndx < DCS_NUMFKEYS; ndx += 1)
   {
      DEBOUT("setFKeyTitles: fKH[ndx]=%lx\n",fKeyHandles[ndx]);
      DEBOUT("setFKeyTitles: fKT[curlevel-1][ndx]=%s\n",(LPSTR) trmParams.fKeyTitle[curLevel-1][ndx]);
      SetWindowText(fKeyHandles[ndx], (LPSTR) trmParams.fKeyTitle[curLevel-1][ndx]);
   }

      if(*trmParams.fKeyNext == 0)
   {
      LoadString(hInst, STR_LEVEL, szBuffer, 15);
      sprintf(str, szBuffer, curLevel);
   }
   else
      strcpy(str, trmParams.fKeyNext);

   SetWindowText(GetDlgItem(hdbmyControls, IDMORE), (LPSTR) str);
}

/*---------------------------------------------------------------------------*/
/* testFkeyLevel() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/
BOOL NEAR testFKeyLevel(INT level)
//INT   level;
{
   INT   ndx;

   for(ndx = 0; ndx < DCS_NUMFKEYS; ndx += 1)
      if((*trmParams.fKeyTitle[level][ndx] != 0) || (*trmParams.fKeyText[level][ndx] != 0))
         return(TRUE);

   return(FALSE);
}



/*---------------------------------------------------------------------------*/
/* nextFkeyLevel() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/
INT NEAR nextFKeyLevel(INT level)
{
   INT   ndx;

   for(ndx = 0; ndx < DCS_FKEYLEVELS; ndx += 1)
   {
      if(level >= DCS_FKEYLEVELS)
         level = 0;
      if(testFKeyLevel(level++))
         return(level);
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* setFKeyLevel() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID setFKeyLevel(INT newLevel, BOOL bReset)
{
   if(newLevel == -1)
      newLevel = nextFKeyLevel(curLevel);

   if((newLevel < 1) || (newLevel > DCS_FKEYLEVELS))
      newLevel = bReset ? 1 : curLevel;

   if(bReset || (newLevel != curLevel))
   {
      fDisableMoreCtrl = ((newLevel = nextFKeyLevel(curLevel = newLevel)) && 
                         (newLevel != curLevel)) ? 0 : FKB_DISABLE_CTRL;
      setFKeyTitles();
   }
}


/*---------------------------------------------------------------------------*/
/* timerAction() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID timerAction(BOOL bTimer, BOOL bReset)
{
   DWORD tickCount;
   
   if(bTimer != timerActiv)
   {
      CheckMenuItem(hMenu, FMTIMER, timerActiv = bTimer ? MF_CHECKED : MF_UNCHECKED);
      PostMessage(hdbmyControls, WM_COMMAND, GET_WM_COMMAND_MPS(IDTIMER, GetDlgItem(hdbmyControls, IDTIMER), BN_PAINT));
   }

   if(bReset)
      readDateTime(startTimer);
}

/*---------------------------------------------------------------------------*/
/* timerToggle() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID timerToggle(BOOL bReset)
{
   timerAction(!timerActiv, bReset);
}

/*---------------------------------------------------------------------------*/
/* sizeFkeys() - Resize fkeys dialog                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID sizeFkeys(LONG clientSize)
{
   RECT  fKeysRect, fCtrlRect;
   GetWindowRect(hdbmyControls, (LPRECT) &fKeysRect);
/* -------------------------------------------------------------- 
if ((HIWORD(clientSize) - fKeysRect.bottom) < 0)   jtf 3.15 
         clientSize = (LOWORD(clientSize),fKeysRect.bottom);
 -------------------------------------------------------------- */

   fKeysRect.top += (HIWORD(clientSize) - fKeysRect.bottom);

   MoveWindow(hdbmyControls, 0, fKeysRect.top, 
              LOWORD(clientSize), HIWORD(clientSize) - fKeysRect.top, TRUE);

   GetWindowRect(fKeyHandles[1], (LPRECT) &fKeysRect);
   GetWindowRect(fKeyHandles[2], (LPRECT) &fCtrlRect);
   fKeysRect.left = fCtrlRect.left - fKeysRect.right;
   fKeysRect.top -= fCtrlRect.bottom;

   fCtrlRect.left = 0;
   fCtrlRect.bottom -= fCtrlRect.top;
   fCtrlRect.right = (LOWORD(clientSize) / ((DCS_NUMFKEYS/2)+1));
   for(fCtrlRect.top = 0; fCtrlRect.top < DCS_NUMFKEYS; fCtrlRect.top += 2)
   {
      MoveWindow(fKeyHandles[fCtrlRect.top], fCtrlRect.left, 0, 
                 fCtrlRect.right, fCtrlRect.bottom, TRUE);
      MoveWindow(fKeyHandles[fCtrlRect.top+1], fCtrlRect.left, fCtrlRect.bottom + fKeysRect.top, 
                 fCtrlRect.right, fCtrlRect.bottom, TRUE);
      fCtrlRect.left += (fCtrlRect.right + fKeysRect.left);
   }

   fCtrlRect.right = LOWORD(clientSize) - fCtrlRect.left;
   MoveWindow(GetDlgItem(hdbmyControls, IDMORE), fCtrlRect.left, 0, 
              fCtrlRect.right, fCtrlRect.bottom, TRUE);
   MoveWindow(GetDlgItem(hdbmyControls, IDTIMER), fCtrlRect.left, fCtrlRect.bottom + fKeysRect.top, 
              fCtrlRect.right, fCtrlRect.bottom, TRUE);
}

/*---------------------------------------------------------------------------*/
/* initChildSize() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID initChildSize(RECT *pRect)
{
   if(IsIconic(hItWnd))
   {
      SetRectEmpty((LPRECT) pRect);
      pRect->right  = GetSystemMetrics(SM_CXSCREEN);
      pRect->bottom = GetSystemMetrics(SM_CYSCREEN) - GetSystemMetrics(SM_CYCAPTION) - 
                      GetSystemMetrics(SM_CYMENU);
   }
   else
   {
      GetClientRect(hItWnd, (LPRECT) pRect);
      if(IsWindowVisible(hdbmyControls))     /* mbbx 1.04: fkeys... */
         pRect->bottom -= fKeysHeight;
   }
}


/*---------------------------------------------------------------------------*/
/* childZoomSize() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

BOOL bZoomFlag = FALSE;                      /* prevents recursive calls */


/*---------------------------------------------------------------------------*/
/* childWindowZoom() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

#define ZC_NOTZOOMED                0x0000
#define ZC_ZOOMED                   0x0001
#define ZC_ZOOMNEXT                 0x4000
#define ZC_NORESTORE                0x8000

WORD fZoomChild = ZC_NOTZOOMED;

WORD childZoomStatus(WORD wTest, WORD wSet)
{
   WORD childZoomStatus = (fZoomChild & wTest);

   fZoomChild |= wSet;

   return(childZoomStatus);
}


VOID setAppTitle()
{
   BYTE  work[STR255];

   strcpy(work, szMessage);

      strcpy(work+strlen(work), " - ");
      GetWindowText(hTermWnd, (LPSTR) work+strlen(work), 80);

   SetWindowText(hItWnd, (LPSTR) work);
}



/*---------------------------------------------------------------------------*/
/* sizeTerm() - Resize terminal window                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID sizeTerm(LONG termSize)
{
   RECT     termRect, ctrlRect;
   
   GetClientRect(hItWnd, (LPRECT) &termRect);
   if(IsWindowVisible(hdbmyControls))
         termRect.bottom -= fKeysHeight;

   MoveWindow(hTermWnd, 0, 0, termRect.right,termRect.bottom,TRUE); 

   GetClientRect(hTermWnd, (LPRECT) &termRect);

   CopyRect((LPRECT) &statusRect, (LPRECT) &termRect);
   statusRect.top = termRect.bottom - (chrHeight + STATUSRECTBORDER);

   CopyRect((LPRECT) &ctrlRect, (LPRECT) &statusRect);
   if((ctrlRect.bottom - ctrlRect.top) < ctrlsHeight)
      ctrlRect.top = termRect.bottom - ctrlsHeight;
   MoveWindow(hdbXferCtrls, 0, ctrlRect.top, ctrlRect.right - ctrlRect.left, 
              ctrlRect.bottom - ctrlRect.top, FALSE);
   updateIndicators();

   if(chrHeight != 0)
      visScreenLine = (ctrlRect.top / chrHeight) - 1;
   CopyRect((LPRECT) &hTE.viewRect, (LPRECT) &termRect);
   hTE.viewRect.bottom = (visScreenLine + 1) * chrHeight;

   curTopLine = min(curTopLine, savTopLine + maxScreenLine - visScreenLine);

   if (curTopLine < 0) 
      curTopLine = 0;

   if((nScrollRange.x = maxChars - (termRect.right / chrWidth)) < 0)
      nScrollRange.x = 0;
   if(nScrollPos.x > nScrollRange.x)
      nScrollPos.x = nScrollRange.x;

   updateTermScrollBars(TRUE);
   InvalidateRect(hTermWnd, NULL, FALSE); /* rjs swat - was TRUE */
   UpdateWindow(hTermWnd);

}


/*---------------------------------------------------------------------------*/
/* countChildWindows() -                                               [mbb] */
/*---------------------------------------------------------------------------*/

INT countChildWindows(BOOL bUnzoom)
{
   INT   nWndCount = 0;
   HWND  hNextWnd;

   hNextWnd = hdbmyControls;                 /* mbb?: reasonable assumption? */
   while((hNextWnd = GetNextWindow(hNextWnd, GW_HWNDPREV)) != NULL)
      if(IsWindowVisible(hNextWnd))
         nWndCount++;

   if(bUnzoom && IsZoomed(hNextWnd = GetTopWindow(hItWnd)))   /* AFTER count!!! */
      ShowWindow(hNextWnd, SW_RESTORE);

   return(nWndCount);
}

/*---------------------------------------------------------------------------*/
/* showTerminal() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID showTerminal(BOOL bShow, BOOL bReset)
{
   if((bShow != (!(termData.flags & TF_HIDE) ? TRUE : FALSE)) || bReset)
   {
      if(bShow)
      {
         termData.flags &= ~TF_HIDE;

         if(activTerm)
         {
            SetWindowPos(hTermWnd, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW);
            SetFocus(hTermWnd);
         }
      }
      else
      {
         termData.flags |= TF_HIDE;

         if(activTerm)
         {
            if(childZoomStatus(ZC_ZOOMED, 0) && (countChildWindows(FALSE) == 1))
            {
               childZoomStatus(0, ZC_ZOOMNEXT);
               ShowWindow(hTermWnd, SW_RESTORE);
            }
            /* typecasted the 2nd param to HWND -sdj*/
            SetWindowPos(hTermWnd,(HWND) 1, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_HIDEWINDOW);
            selectTopWindow();                  /* mbbx 1.03 ... */
         }
      }
   }
}


/*---------------------------------------------------------------------------*/
/* showHidedbmyControls() -                                                  */
/*---------------------------------------------------------------------------*/

VOID showHidedbmyControls(BOOL bShow, BOOL bArrange)
{
   BYTE  strShowHide[TMPNSTR+1];

   if(bShow != fKeysShown)
   {
      if(fKeysShown = bShow)
      {
         ShowWindow(hdbmyControls, SW_SHOW);
         LoadString(hInst, STR_HIDEFKEYS, (LPSTR) strShowHide, TMPNSTR);
         ChangeMenu(hMenu, WMFKEYS, (LPSTR) strShowHide, WMFKEYS, MF_CHANGE);
      }
      else
      {
         ShowWindow(hdbmyControls, SW_HIDE);
         LoadString(hInst, STR_SHOWFKEYS, (LPSTR) strShowHide, TMPNSTR);
         ChangeMenu(hMenu, WMFKEYS, (LPSTR) strShowHide, WMFKEYS, MF_CHANGE);
      }
      if(!IsIconic(hItWnd))   /* rjs bugs 015 */
         sizeTerm(0L); /* jtf 3.21 */


      // make sure hTermWnd gets cleaned so there's no
      // garbage left on hTermWnd.
      InvalidateRect (hTermWnd, NULL, TRUE);
      UpdateWindow (hTermWnd);
   }
}



/*---------------------------------------------------------------------------*/
/* makeActiveNext() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID makeActiveNext(BOOL bPrevWnd)
{
   HWND  hNextWnd, hTopWnd;

   if((hNextWnd = GetNextWindow(hdbmyControls, GW_HWNDPREV)) != (hTopWnd = GetTopWindow(hItWnd)))
   {
      if(childZoomStatus(ZC_ZOOMED, 0))
      {
         childZoomStatus(0, ZC_NORESTORE);
         ShowWindow(hTopWnd, SW_RESTORE);
      }

      if(bPrevWnd)
         BringWindowToTop(hNextWnd);
      else
      {
         SetWindowPos(hTopWnd, hNextWnd, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
         hNextWnd = GetTopWindow(hItWnd);
      }

      SetFocus(hNextWnd);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dlgs.h ===
/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-                                */
/*---------------------------------------------------------------------------*/

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041d
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 * 27 March 1991        clarkc
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dcutil1.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "video.h"


/*---------------------------------------------------------------------------*/
/* clipRect () - Sets a rect to the current clip rect                        */
/*              Note: assumes getPort () has been called                     */
/*---------------------------------------------------------------------------*/

VOID clipRect(RECT *clpRect)
{
   HRGN  hClipRgn;

   hClipRgn = CreateRectRgnIndirect ((LPRECT) clpRect);
   SelectClipRgn(thePort, hClipRgn);
   DeleteObject (hClipRgn);
}


/*---------------------------------------------------------------------------*/
/* pos() -                                                             [mbb] */
/*---------------------------------------------------------------------------*/

INT pos(STRING *word, STRING *str)
{
   INT   ndx, count;

   if((count = *str - *word + 1) > 0)
   {
      for(ndx = 1; ndx <= count; ndx += 1)
         if(memcmp(str+ndx, word+1, *word) == 0)
            return(ndx);
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* delay() - Spin wheels & be nice to other windows applications             */
/*---------------------------------------------------------------------------*/

/* NOTE: 1000/60 msec/ticks => 50/3; max delay w/o overflow = 3932 ticks */

VOID delay(UINT units, DWORD  *endingCount)
{
   DWORD  tmStart;
   DWORD  dtmWait = (units * 50) / 3;
   
   tmStart = GetTickCount();
   
   while(GetTickCount() - tmStart < dtmWait)
   {
      PeekMessage(&msg, hItWnd, 0, 0, PM_NOREMOVE);
      updateTimer();
   }

   if(endingCount != NULL)
      *endingCount = tmStart + dtmWait;
}

/*---------------------------------------------------------------------------*/
/* concat() - Concatanate two Pascal-type strings.                      [scf]*/
/*---------------------------------------------------------------------------*/

BYTE *concat (STRING *out, STRING *s1, STRING *s2)
{
   STRING scratch[STR255];

   if ((WORD) (*s1 + *s2) < STR255)
   {                               
      if (out == s2)
      {
         memcpy (scratch, s2, (WORD) *s2 + 1);
         memcpy (&out[1], &s1[1], (WORD) *s1);
         memcpy (&out[*s1 + 1], &scratch[1], (WORD) *scratch);
         *out = *s1 + *scratch;
      }
      else
      {
         memcpy (&out[1], &s1[1], (WORD) *s1);
         memcpy (&out[*s1 + 1], &s2[1], (WORD) *s2);
         *out = *s1 + *s2;
      }
   }
   nullTerminate (out);
   return out;
}


/*---------------------------------------------------------------------------*/
/* stripControl() -                                                    [scf] */
/*---------------------------------------------------------------------------*/

VOID stripControl(STRING *str)
{
   WORD     ndxDst, ndxSrc;
   STRING   newStr[STR255];

   ndxSrc = 1;
   *newStr = 0;
   for (ndxDst = 1; ndxDst <= *str; ndxDst++)
      if (ndxSrc <= *str)
      {
         newStr[0] = (BYTE) ndxDst;
         if((str[ndxSrc] == '^') && (str[ndxSrc+1] != '$'))    /* mbbx 1.04... */
            if (str[ndxSrc+1] == '^' || ndxSrc == *str)
            {
               newStr[ndxDst] = '^';
               ndxSrc += 2;
            }
            else
            {
               newStr[ndxDst] = str[ndxSrc+1] & 0x1f;
               ndxSrc += 2;
            }
         else
         {
            newStr[ndxDst] = str[ndxSrc];
            ndxSrc++;
         }
      }
   strEquals(str, newStr); 
}


/*---------------------------------------------------------------------------*/
/* clearBuffer() - Initialize terminal I/O capture buffer.             [scf] */
/*---------------------------------------------------------------------------*/

VOID clearBuffer()
{
   RECT  clientRect;

   gIdleTimer    = GetCurrentTime();   /* rjs bug2 001 */

   timPointer    = GetCurrentTime();

   escAnsi       = FALSE;
   escCol        = -1;
   escCursor     = FALSE;
   escGraphics   = FALSE;
   grChrMode     = FALSE;
   escLin        = -1;
   escSeq        = FALSE;
   escExtend     = EXNONE;
   escSkip       = 0;
   escVideo      = 0;
   vidGraphics   = GRNONE;
   vidInverse    = FALSE;
   termDirty     = FALSE;
   curLin        = 0;
   curCol        = 0;
   curTopLine    = savTopLine = 0;
   savLeftCol    = 0;
   cursorValid   = FALSE;
   rectCursor(&cursorRect);

   clearTermBuffer(0, maxLines, maxChars + 2);  /* mbbx 2.00.03: lines > 399 ... */
   termSetSelect(0L, 0L);

   chrHeight = stdChrHeight;
   chrWidth  = stdChrWidth;

   GetClientRect (hTermWnd, (LPRECT) &clientRect);
   visScreenLine = hTE.viewRect.bottom / chrHeight - 1;

   nScrollRange.x = maxChars - (clientRect.right / chrWidth);
   nScrollPos.y   = 0;
   nScrollPos.x   = 0;
   updateTermScrollBars(FALSE);

   activSelect = FALSE;
   noSelect = TRUE;     /* rjs bugs 020 */
   clearModes();

   InvalidateRect(hTermWnd, NULL, TRUE);     /* mbbx 2.00.03 ... */
   UpdateWindow(hTermWnd);
}


/*---------------------------------------------------------------------------*/
/* clearModes() - An terminal emulation initialization worker routine. [scf] */
/*---------------------------------------------------------------------------*/

VOID clearModes()
{
   INT ndx;
   INT lin;
   INT col;

   cursorKeyMode = FALSE;
   keyPadAppMode = FALSE;
   originMode    = FALSE;
   chInsMode     = FALSE;
   scrRgnBeg     = 0;
   shiftCharSet  = 0;
   charSet[0]    = 'B';
   charSet[1]    = 'B';
   scrRgnEnd     = maxScreenLine;
   statusLine    = FALSE;
   curAttrib     = 0;
   protectMode   = FALSE;

   for (ndx = 1; ndx <= 131; ndx++)
     if (ndx % 8 == 0)
        tabs[ndx] = 1;
     else
        tabs[ndx] = 0;
   for (lin = 0; lin <= 23; lin++)
      for (col = 0; col <= 132; col++)
         attrib[lin][col] = 0;
   for (ndx = 0; ndx <= maxChars -1; ndx++)
      line25[ndx] = ' ';
}


/*---------------------------------------------------------------------------*/
/* setCommDefaults() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID setCommDefaults()                       /* mbbx 2.01.20 (2.01.17) ... */
{
   BYTE  str[MINRESSTR], portData[32];
   INT   nPort, nSpeed, nData, nStop;

   trmParams.comDevRef = ITMNOCOM;
   trmParams.speed     = 1200;
   trmParams.dataBits  = ITMDATA8;
   trmParams.stopBits  = ITMSTOP1;
   trmParams.parity    = ITMNOPARITY;

   LoadString(hInst, STR_INI_PORT, (LPSTR) str, MINRESSTR);
   GetProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) NULL_STR, (LPSTR) portData, sizeof(portData));

   switch(sscanf(portData, "COM%d:%d,%c,%d,%d", &nPort, &nSpeed, str, &nData, &nStop))
   {
   case 5:
      if(nStop == 2)
         trmParams.stopBits = ITMSTOP2;
                                       /* then fall thru... */
   case 4:
      if((nData >= 4) && (nData < 8))
         trmParams.dataBits = ITMDATA8 - (8 - nData);
                                       /* then fall thru... */
   case 3:
      switch(str[0])
      {
      case 'o':
         trmParams.parity = ITMODDPARITY;
         break;
      case 'e':
         trmParams.parity = ITMEVENPARITY;
         break;
      case 'm':
         trmParams.parity = ITMMARKPARITY;
         break;
      case 's':
         trmParams.parity = ITMSPACEPARITY;
         break;
      }
                                       /* then fall thru... */
   case 2:
      if((nSpeed < 150) || (nSpeed == 192))
         nSpeed *= 100;
      trmParams.speed = (WORD)nSpeed;
                                       /* then fall thru... */
   case 1:
      if(nPort >= 1)
      {
         trmParams.newDevRef = ITMWINCOM;
         trmParams.comPortRef = ITMCOM1 + (nPort - 1);
         trmParams.fResetDevice = TRUE;
      }
      break;
   }

   DEBOUT("setCommDefaults:   trmParams.comDevRef = %x\n",trmParams.comDevRef);
   DEBOUT("setCommDefaults:   trmParams.speed     = %d\n",trmParams.speed);
   DEBOUT("setCommDefaults:   trmParams.dataBits  = %d\n",trmParams.dataBits);
   DEBOUT("setCommDefaults:   trmParams.stopBits  = %d\n" ,trmParams.stopBits);

   DEBOUT("setCommDefaults:   trmParams.parity    = %d\n",trmParams.parity);
   DEBOUT("setCommDefaults:   trmParams.newDevRef = %d\n",trmParams.newDevRef);

   DEBOUT("setCommDefaults:   trmParams.comPortRef = %d\n",trmParams.comPortRef);
   DEBOUT("setCommDefaults:   trmParams.fResetDevice = %d\n",trmParams.fResetDevice);

}


/*---------------------------------------------------------------------------*/
/* setDefaultFonts() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID setDefaultFonts()                       /* rkhx 2.00 ... */
{
   BYTE szFont[MINRESSTR], szDefFontFace[LF_FACESIZE], szFontFace[LF_FACESIZE];
   INT  ndx;
   WORD fontHeight = 8;                      /* mbbx 2.00: was 0 */

   LoadString(hInst, STR_INI_FONT, (LPSTR) szFont, MINRESSTR);
   LoadString(hInst, STR_INI_FONTFACE, (LPSTR) szDefFontFace, LF_FACESIZE);
   GetProfileString((LPSTR) szAppName_private, (LPSTR) szFont, (LPSTR) szDefFontFace, 
                    (LPSTR) szFontFace, LF_FACESIZE);

   for(ndx = 0; szFontFace[ndx] != 0; ndx += 1)
   {
      if(szFontFace[ndx] == ',')
      {
         sscanf(szFontFace+(ndx+1), "%d", &fontHeight);
         szFontFace[ndx] = 0;
         break;
      }
   }

   strcpy(trmParams.fontFace, szFontFace);   /* mbbx 2.00: font selection... */
   trmParams.fontSize = fontHeight;
   buildTermFont();
}


/*---------------------------------------------------------------------------*/
/* getDefCountry() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

/* MS-DOS 3.0 COUNTRY command: */

#define CC_USA                   1
#define CC_UK                    44
#define CC_DENMARK               45
#define CC_NORWAY                47
#define CC_FINLAND               358
#define CC_FRANCE                33
                                             /* NOTE: CANADA not defined */
#define CC_GERMANY               49
#define CC_ITALY                 39
#define CC_SPAIN                 34
#define CC_SWEDEN                46
#define CC_SWITZERLAND           41

WORD getDefCountry()                         /* mbbx 1.04: ics... */
{
   ICS_TYPE    icsType;
   BYTE        szIntl[MINRESSTR];
   BYTE        szCountry[MINRESSTR];

   LoadString(hInst, STR_INI_INTL, (LPSTR) szIntl, MINRESSTR);
   LoadString(hInst, STR_INI_ICOUNTRY, (LPSTR) szCountry, MINRESSTR);
   switch(GetProfileInt((LPSTR) szIntl, (LPSTR) szCountry, 0))
   {
   case CC_UK:
      icsType = ICS_BRITISH;
      break;
   case CC_DENMARK:
   case CC_NORWAY:
      icsType = ICS_DANISH;
      break;
   case CC_FINLAND:
      icsType = ICS_FINISH;
      break;
   case CC_FRANCE:
      icsType = ICS_FRENCH;
      break;
   case CC_GERMANY:
      icsType = ICS_GERMAN;
      break;
   case CC_ITALY:
      icsType = ICS_ITALIAN;
      break;
   case CC_SPAIN:
      icsType = ICS_SPANISH;
      break;
   case CC_SWEDEN:
      icsType = ICS_SWEDISH;
      break;
   case CC_SWITZERLAND:
      icsType = ICS_SWISS;
      break;
   default:
      icsType = ICS_NONE;
      break;
   }

   return((WORD) icsType);
}


/*---------------------------------------------------------------------------*/
/* icsResetTable() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

#define ICS_RESBYTES             12

VOID icsResetTable(WORD icsType)
{
   BYTE  ndx;
   BYTE  work1[ICS_RESBYTES+1], work2[ICS_RESBYTES+1];

   trmParams.language = (BYTE) ICS_NONE;
   for(ndx = 0; ndx < 256; ndx += 1)
      icsXlateTable[ndx] = ndx;

   if((icsType > ICS_NONE) && (icsType < ICS_MAXTYPE))
   {
      if((LoadString(hInst, STR_ICS_DATA, (LPSTR) work1, ICS_RESBYTES+1) == ICS_RESBYTES) && 
         (LoadString(hInst, STR_ICS_DATA + icsType, (LPSTR) work2, ICS_RESBYTES+1) == ICS_RESBYTES))
      {
         for(ndx = 0; ndx < ICS_RESBYTES; ndx += 1)
         {
            icsXlateTable[work1[ndx]] = work2[ndx];
            icsXlateTable[work2[ndx]] = work1[ndx];
         }

         trmParams.language = icsType;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* setDefaults() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

#define DEFBUFFERLINES           100

VOID setDefaults()
{
   BYTE  str[80];
   INT   ndx;

   memset(&trmParams, 0, sizeof(recTrmParams));    /* mbbx 1.00: default to NULL */

   trmParams.fileID = DCS_FILE_ID;           /* mbbx 2.00 ... */
   LoadString(hInst, STR_VERSION, (LPSTR) trmParams.version, DCS_VERSIONSZ);

   trmParams.controlZ = CNTRLZ;
   trmParams.fileSize = sizeof(recTrmParams);

   setCommDefaults();                        /* mbbx 2.01.17 ... */
   trmParams.fParity     = FALSE;            /* mbbx 1.10: CUA */
   trmParams.flowControl = ITMXONFLOW;
   trmParams.fCarrier    = FALSE;            /* mbbx 1.10: CUA */


/* Terminal: */
   trmParams.emulate     = ITMVT100;         /* mbbx 1.04: was ITMTTY; */
   trmParams.fCtrlBits   = FALSE;            /* mbbx 1.10: VT220 8BIT = TRUE */
   LoadString(hInst, STR_ANSWERBACK, (LPSTR) trmParams.answerBack, DCS_ANSWERBACKSZ);
   trmParams.lineWrap    = TRUE;             /* mbbx 1.10: CUA... */
   trmParams.localEcho   = FALSE;
   trmParams.sound       = TRUE;             /* mbbx 1.04: synch */
   trmParams.inpCRLF     = FALSE;
   trmParams.outCRLF     = FALSE;
   trmParams.columns     = ITM80COL;
   trmParams.termCursor  = ITMBLKCURSOR;
   trmParams.cursorBlink = TRUE;
   LoadString(hInst, STR_INI_BUFFER, (LPSTR) str, MINRESSTR);
   trmParams.bufferLines = (WORD)GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, DEFBUFFERLINES);
   maxChars = 0; /* mbbx 2.00.04 */

   DEBOUT("Calling: %s\n","resetTermBuffer()");
   resetTermBuffer();
   DEBOUT("Outof: %s\n","resetTermBuffer()");

   DEBOUT("Calling: %s\n","setDefaultFonts()");
   setDefaultFonts();
   DEBOUT("Outof: %s\n","setDefaultFonts()");

   DEBOUT("Calling: %s\n","icsResetTable()");
   icsResetTable(getDefCountry());           /* mbbx 1.04: ics */
   DEBOUT("Outof: %s\n","icsResetTable()");

   trmParams.fHideTermVSB = FALSE;
   trmParams.fHideTermHSB = FALSE;

/*   trmParams.useWinCtrl   = TRUE;	      rjs msoft */

// -sdj 08 may 92: I am not sure why cntl-c is not xmited
// and used instead for copy-paste. When terminal is used
// as a debug machine, or to connect to mainframe, it is important
// most of the times that the control-c should go out to the other end
// user can turn this other way if he needs to..
// changing default from TRUE to FALSE

     trmParams.useWinCtrl   = FALSE;

/* Binary Transfers: */
   trmParams.xBinType    = ITMXMODEM;
   trmParams.rcvBlSz     = 2000;
   trmParams.sendBlSz    = 2000;
   trmParams.retryCt     = 20;

/* Text Transfers: */
   trmParams.xTxtType    = ITMSTD;
   trmParams.xChrType    = ITMCHRDELAY;
   trmParams.xChrDelay   = 1;
   trmParams.xLinType    = ITMLINDELAY;
   trmParams.xLinDelay   = 1;
   LoadString(hInst, STR_XFERLINESTR, (LPSTR) trmParams.xLinStr, DCS_XLINSTRSZ);
   trmParams.xWordWrap   = FALSE;
   trmParams.xWrapCol    = 79;               /* mbbx 1.04: revert from 65 */

/* Phone: */
   trmParams.dlyRetry     = 30;              /* mbbx 1.10: CUA */
   trmParams.cntRetry     = 0;
   trmParams.flgRetry     = FALSE;
   trmParams.flgSignal    = FALSE;

/* Modem: */
   trmParams.xMdmType = ITMHAYES;
   LoadString(hInst, STR_DIALPREFIX, (LPSTR) trmParams.dialPrefix, DCS_MODEMCMDSZ);
   LoadString(hInst, STR_DIALSUFFIX, (LPSTR) trmParams.dialSuffix, DCS_MODEMCMDSZ);
   LoadString(hInst, STR_HANGPREFIX, (LPSTR) trmParams.hangPrefix, DCS_MODEMCMDSZ);
   LoadString(hInst, STR_HANGSUFFIX, (LPSTR) trmParams.hangSuffix, DCS_MODEMCMDSZ);
   LoadString(hInst, STR_ANSWER, (LPSTR) trmParams.answer, DCS_MODEMCMDSZ);
   LoadString(hInst, STR_ORIGINATE, (LPSTR) trmParams.originate, DCS_MODEMCMDSZ);

/* Environment: */
   if(fKeysShown)                            /* mbbx 2.00: show fkeys... */
      trmParams.environmentFlags |= DCS_EVF_FKEYSSHOW;
   else
      trmParams.environmentFlags &= ~DCS_EVF_FKEYSSHOW;
   trmParams.environmentFlags |= DCS_EVF_FKEYSARRANGE;

/* Parent: */

   for(ndx = 1; ndx <= 131; ndx++)
      if(ndx % 8 == 0)
         tabs[ndx] = 1;
      else
         tabs[ndx] = 0;

   answerMode    = FALSE;
   keyPadAppMode = FALSE;
   cursorKeyMode = FALSE;
}


/*---------------------------------------------------------------------------*/
/* resetEmul() - Load the Emulation table from resource.               [scf] */
/*---------------------------------------------------------------------------*/

VOID resetEmul()                             /* mbbx per slc */
{
#ifdef ORGCODE
   HANDLE      hResInfo, hFile;
   TEXTMETRIC  fontMetrics;
   INT         ndx, ndx2;

   if((hResInfo = FindResource(hInst, getResId(1000 + (trmParams.emulate - ITMTERMFIRST)), (LPSTR) DC_RES_CCTL)) != NULL) /* mbbx 1.04: REZ */
   {
      if((hFile = AccessResource(hInst, hResInfo)) != -1)
      {
         if(_read(hFile, emulInfo, 128) == 128)
		   {
            if(_read(hFile, GlobalLock(hemulKeyInfo), SIZEOFEMULKEYINFO) == SIZEOFEMULKEYINFO)
            {
               GlobalUnlock(hemulKeyInfo);

               if(_read(hFile, vidGraphChars, 128) != 128)   /* mbbx 1.10 ... */
                  trmParams.emulate = -1;

               if((trmParams.emulate == ITMVT100) || (trmParams.emulate == ITMVT220))
                  ansi = TRUE;
               else
                  ansi = FALSE;
            }
            else   /* read for emulKeyInfo failed so unlock it */
            {
               GlobalUnlock (hemulKeyInfo);
               trmParams.emulate = -1;
            }
         }
         else
            trmParams.emulate = -1;

         _close(hFile);
      }
      else
         trmParams.emulate = -1;
   }
   else
      trmParams.emulate = -1;

#else
   HANDLE      hFoundRes,hResInfo;
   LPSTR       lpResData,lpEmulKey;
   TEXTMETRIC  fontMetrics;
   INT         ndx, ndx2;

   if((hFoundRes = FindResource(hInst, getResId(1000 + (trmParams.emulate - ITMTERMFIRST)), (LPSTR) DC_RES_CCTL)) != NULL) /* mbbx 1.04: REZ */
   {
      DEBOUT("resetEmul: findresource returns %lx\n",hFoundRes);
      /*accessresource no longer in win32, so gotta LoadResource, then lock it, */
      /*so I get a pointer to the resource data itself.(JAP)*/
      if( (hResInfo = LoadResource(hInst,hFoundRes)) != NULL)
      {
         DEBOUT("resetEmul: LoadResource returns %lx\n",hResInfo);
         if((lpResData = LockResource(hResInfo)) )
         {
            DEBOUT("resetEmul: LockResource returns %lx\n",lpResData);
            memcpy(emulInfo, lpResData, 128);
            if ( (lpEmulKey = GlobalLock(hemulKeyInfo)) != NULL )
            {
               memcpy(lpEmulKey,lpResData+128,SIZEOFEMULKEYINFO);
               memcpy(vidGraphChars, lpResData + 128 + SIZEOFEMULKEYINFO, 128);
               if((trmParams.emulate == ITMVT100) || (trmParams.emulate == ITMVT220))
               {
                  DEBOUT("resetEmul:%s\n","emulate = VT100|VT52, ansi=true");
         	      ansi = TRUE;
		         }
               else
		         {
                  DEBOUT("resetEmul:%s\n","emulate not VT100|VT52, ansi=false");
         	      ansi = FALSE;
		         }
               GlobalUnlock(hemulKeyInfo);
               UnlockResource(hResInfo);
            }
            else  /* Globallock failed, so put -1 in .emulate */
            {
               DEBOUT("resetEmul: %s\n","GlobalLock FAILED");
               trmParams.emulate = -1;
               UnlockResource(hResInfo);
            }
         }
         else     /* LockResource failed, so put -1 in .emulate */
         {
            DEBOUT("resetEmul: %s\n","LockResource FAILED");
            trmParams.emulate = -1;
         }
      }
      else        /* LoadResource failed, so put -1 in .emulate */
      {
         DEBOUT("resetEmul: %s\n","LoadResource FAILED");
         trmParams.emulate = -1;
      }
   }
   else
   /* FindResource failed, so put -1 in .emulate  */
   {
      DEBOUT("resetEmul: %s\n","FindResource FAILED");
      trmParams.emulate = -1;
   }

#endif

   /*********** now check if .emulate is -1 and do the defaults ***********/
   if(trmParams.emulate == (BYTE) -1)
   {
      LoadString(hInst, STR_LOADEMUL, (LPSTR) taskState.string, 80);    /* mbbx 1.04: REZ... */
      testMsg(taskState.string,NULL,NULL);
      trmParams.emulate = ITMTTY;
      escHandler = pNullState;
   }
   else
   {
      escHandler = pEscSequence;
   
      getPort();
      GetTextMetrics(thePort, (TEXTMETRIC FAR *) &fontMetrics);
      releasePort();
      if(fontMetrics.tmCharSet == ANSI_CHARSET)
      {
         for(ndx = 0; ndx < 64; ndx += 1)
         {
            switch(vidGraphChars[ndx].buffer)
            {
            case 0x9C:
               vidGraphChars[ndx].buffer = 0xA3;
               break;
            case 0xF1:
               vidGraphChars[ndx].buffer = 0xB1;
               break;
            case 0xF8:
               vidGraphChars[ndx].buffer = 0xB0;
               break;
            case 0xFA:
               vidGraphChars[ndx].buffer = 0xB7;
               break;
            default:
               if(vidGraphChars[ndx].buffer > 0x80)
                  vidGraphChars[ndx].buffer = 0x20;
               break;
            }
         }
      }
   }

   clearModes();

   for(ndx2 = 0; ndx2 <= 127; ndx2 += 1)
   {
      ndx = emulInfo[ndx2];
      if(ndx > 128)
         ndx = ESCSKIPNDX;
      pEscTable[ndx2] = pProcTable[ndx];
      if(ansi)
         aEscTable[ndx2] = aProcTable[ndx];
   }

   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* initTermBuffer() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

/* mbbx 2.00.03: buffer lines > 399 ... */

/* NOTE: the following routines contain code which assumes the term buffer   */
/*       will be limited to 64K...  This seems like a reasonable limit       */
/*       since too large a buffer would slow down the emulation!             */

/* #define MINBUFFERLINES           25
#define MAXBUFFERSIZE            0xFFFF                          jtf 3.12 */
#define MINBUFFERLINES           (maxScreenLine+2)
#define MAXBUFFERSIZE            0x7FFF                         /* jtf 3.12 */
#define TERMBUFFERFUDGE          1

BOOL clearTermBuffer(UINT prevLines, UINT bufLines, UINT lineWidth)
{
   LPSTR    lpBufData;
   UINT     wPrevSize;

   if((lpBufData = GlobalLock(hTE.hText)) == NULL)
      return(FALSE);

   wPrevSize = prevLines * lineWidth;
   lsetmem(lpBufData += wPrevSize, 0x20, (bufLines * lineWidth) - wPrevSize);

   while(prevLines < bufLines)
   {
      lpBufData += lineWidth;
      // NOTE:  Will AV on RISC if lineWidth is odd
      *(((WORD FAR *) lpBufData)-1) = 0x0A0D;
      prevLines += 1;
   }
   *lpBufData = 0;                           /* NULL terminated, of course */

#ifndef BUGBYPASS
   DEBOUT("initTermBuffer: %s\n","GlobalUnlock BUG??? CHECK THIS OUT");
   return (TRUE);
#else
   GlobalUnlock(hTE.hText);
   return (TRUE);
#endif
}


BOOL initTermBuffer(WORD bufLines, WORD lineWidth, BOOL bReset)
{
   LONG     lBufSize;
   LPSTR    lpBufData;
   HANDLE   hNewBuf;

   if(bReset && (hTE.hText != NULL))
      hTE.hText = GlobalFree(hTE.hText);

   if(bufLines < MINBUFFERLINES)
      bufLines = MINBUFFERLINES;
   if((lBufSize = ((LONG) bufLines * lineWidth) + TERMBUFFERFUDGE) > MAXBUFFERSIZE)
   {
      bufLines = (MAXBUFFERSIZE - TERMBUFFERFUDGE) / lineWidth;
      lBufSize = (bufLines * lineWidth) + TERMBUFFERFUDGE;
   }

   if(hTE.hText == NULL)
   {
      GlobalCompact(lBufSize);

      if((hTE.hText = GlobalAlloc(GMEM_MOVEABLE, (DWORD) (MINBUFFERLINES * lineWidth) + 
                                  TERMBUFFERFUDGE)) == NULL)
      {
         testResMsg(STR_OUTOFMEMORY);
         SendMessage(hItWnd, WM_CLOSE, 0, 0L);
         return(FALSE);
      }

      maxLines = 0;
   }
   else if(bufLines < savTopLine + (maxScreenLine + 2))
   {
      lpBufData = GlobalLock(hTE.hText);
      lmovmem(lpBufData + ((savTopLine + (maxScreenLine + 2) - bufLines) * lineWidth), lpBufData, lBufSize);
      GlobalUnlock(hTE.hText);

      if(curTopLine > (savTopLine = bufLines - (maxScreenLine + 2)))
         curTopLine = savTopLine;
      if(!IsIconic(hItWnd))      /* rjs bugs 015 */
         sizeTerm(0L);                          /* reset scrollbars */
   }

   while(bufLines > MINBUFFERLINES)
   {
      if((hNewBuf = GlobalReAlloc(hTE.hText, lBufSize, GMEM_MOVEABLE)) != NULL)
      {
         hTE.hText = hNewBuf;
         break;
      }

      bufLines -= 1;
      lBufSize -= lineWidth;
   }

   if(bufLines > maxLines)
      clearTermBuffer(maxLines, bufLines, lineWidth);

   maxLines = bufLines;

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* resetTermBuffer() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID resetTermBuffer()
{
   WORD  lineWidth;
   BOOL  bNewWidth;

   lineWidth = (trmParams.columns == ITM80COL) ? 80 : 132;
   if((bNewWidth = (lineWidth != maxChars)) || (trmParams.bufferLines != maxLines))
   {
      maxChars = lineWidth;
      initTermBuffer(trmParams.bufferLines, lineWidth + 2, bNewWidth);

      if(bNewWidth)
         clearBuffer();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\dynacomm.h ===
#include "fsemacro.h"         // rjs - macros for dynacomm
#include <io.h>       /* for open,read,write,close file crt -sdj*/
#include <string.h>   /* for strncpy -sdj */
#include <stdio.h>    /* for sprintf sscanf -sdj */
#include <fcntl.h>  /*added cause CRT's need defines*/
#include <sys\types.h>
#include <sys\stat.h>
#include "asm2c_32.h"

/*****************************************************************************/
/* Compilation Switches                                                      */
/*****************************************************************************/

#ifdef DEBUG
#define DEBOUT(a,b)         DbgPrint("WIN32DEBUG: " a, (b));
#else
#define DEBOUT(a,b)
#endif

#define DEBUG_FLAG   FALSE
#define DEBUG_FLAG1  (DEBUG_FLAG & 0x0002)

#define NULL_PORT    TRUE                                             /* enables DynaComm to function */
                                                                                                                        /* without a valid COMM PORT    */

/*****************************************************************************/
/* Type Definitions                                                          */
/*****************************************************************************/

typedef BYTE            STRING;              /* denotes PASCAL-type string */
typedef BYTE *          Ptr;
typedef BYTE HUGE_T *   HPSTR;

typedef VOID            (NEAR *procPtr)();
typedef HWND            ControlHandle;


/*****************************************************************************/

typedef enum {KBD_LOCK, KBD_UNLOCK, KBD_ECHO, KBD_BUFFER, KBD_WAIT} KBD_STATE;

typedef enum {ICS_NONE, ICS_BRITISH, ICS_DANISH, ICS_FINISH,
              ICS_FRENCH, ICS_CANADIAN, ICS_GERMAN, ICS_ITALIAN,
              ICS_SPANISH, ICS_SWEDISH, ICS_SWISS, ICS_MAXTYPE} ICS_TYPE;

typedef enum {XFRNORMAL, XFRCHAR, XFRLINE} TTXTTYPE;

typedef enum {XFRCHRDELAY, XFRCHRWAIT} TCHRTYPE;

typedef enum {XFRLINDELAY, XFRLINWAIT} TLINTYPE;

typedef enum {BNEITHER, BPAUSE, BWHEN, BBOTH} BREAKCOND;

typedef enum {EXNONE, EXVPOS, EXHPOS, EXSCS, EXSETMODE, EXRESETMODE} ESCEXTEND;

typedef enum {TBLBEGINLINE, TBLNONSPACE, TBLONESPACE, TBLSPACES} TBLPOS;

typedef enum {XFRNONE, XFRSND, XFRRCV, XFRTYP, XFRBSND, XFRBRCV} XFERFLAG;

typedef enum {GRNONE, GRSEMI, GRHIGH, GRMEDM} VIDGRAPHICS;

typedef enum {XFRDYNACOMM, XFRXMODEM, XFRYMODEM, XFRKERMIT, XFRYTERM} tBinType;

typedef enum {XFRBOTH, XFRDATA, XFRRESOURCE} tBinFork;


/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/

#define PATHLEN                     80
#define FILENAMELEN		    32 // -sdj 12 is really bad if you have ntfs names 12

#define ESCSKIPNDX                  32       /* used: resetEmul (itutil1.c)  */

#define MAXTIMERNUM                 3        /* mbbx 2.00: multiple timers */


/*****************************************************************************/
/*                        STANDARD CHARACTER CONSTANTS                       */

#define CR                  13               /* Carriage return              */
#define LF                  10               /* Line Feed                    */
#define SP                  32               /* Space                        */
#define TAB                 9                /* Tab                          */
#define FF                  12               /* Form Feed                    */
#define BS                  8                /* BackSpace                    */
#define ESC                 27               /* Escape                       */
#define BELL                7                /* Bell                         */
#define CHFILL              32               /* buffer fill char.            */
#define XOFF                19               /* XOFF                         */
#define XON                 17               /* XON                          */
#define CNTRLZ              26               /* end of file ^Z               */
#define CNTRLC               3               /* ^C same song second CHETX    */

#define CHSOH                1
#define CHSTX                2
#define CHETX                3
#define CHEOT                4
#define CHACK                6
#define CHNAK               21
#define CHCAN               24
#define CHTIMEOUT           -1

#define CHQUOTE            '"'               /* mbbx 1.04: REZ... */
#define CHSQUOTE            '\''


/*                              SYSTEM CONSTANTS                             */

#define KILOBYTES                  * 1024
#define KILOBYTESL                 * 1024L
#define MEGABYTES                  * 1024 KILOBYTES
#define MEGABYTESL                 * 1024 KILOBYTESL
#define MAXUNSIGNEDINT             64 KILOBYTES - 1
#define MAXUNSIGNEDINTL            64 KILOBYTESL - 1
#define MAXINT                     32 KILOBYTES - 1
#define MININT                     -1 * MAXINT
#define MAXINTL                    32 KILOBYTESL -1
#define MAXLONGINT                 2048 MEGABYTESL
#define MINLONGINT                 -1 * MAXLONGINT
#define MAXUNSIGNEDCHAR            255
#define TERM_MAXCHAR               127 /* changed from MAXCHAR to avoid conflict*/
                                       /* MAXCHAR was not used in any files anyway-sdj*/
#define MILLISECONDS               * 1
#define SECONDS                    * 1000 MILLISECONDS

#define versSettings         4

#define STR255               256             /* Faking Pascal str255 type    */
#define DONTCARE             0xff            /* General purpose don't care   */
#define MAXROWCOL            MAXLONGINT      /* Max. value for type ROWCOL   */
#define STANDARDKEY          0x00
#define KEYPADKEY            0x01
#define TERMINALFKEY         0x02
#define SCROLLKEY            0x04
#define SYSTEMFKEY           0xF0
#define SHORTBREAK           0xFE            /* Defined for serial short brk */
#define LONGBREAK            0xFF            /* Defined for serial long brk  */
#define DAYS_IN_A_YEAR       31+28+31+30+31+30+31+31+30+31+30+31
#define SECS_IN_A_DAY        24l*60l*60l
#define MAXSCREENLINE        23
#define MINPOINTSIZE          6
#define MAXPOINTSIZE          15             /* Maximum point size for the   */
                                             /* terminal screen font         */
#define STATUSLINE           24
#define UPDATETICKS           3
#define YIELDCHARS           48  /* *** optimize this */

/*                         ARRAY DECLARATOR CONSTANTS                        */

#define LOCALMODEMBUFSZ       513            /* mbbx: previously 1024 */
#define NINQUEUE              1024           /* mbbx 1.04: was 3072 */
#define NOUTQUEUE             256            /* mbbx 1.04: was 512 */
#define KEYSEQLEN             5
#define SIZEOFEMULKEYINFO     50*KEYSEQLEN   /* mbbx 2.00: was 52,44 */

/* #define FKEYLEN               64  jtf 3.12         Max. sizeof funct. key text  */
#define DCS_FKEYLEVELS         4             /* Number of level keys         */
#define DCS_NUMFKEYS           8             /* Number of function keys      */
#define DCS_FKEYTITLESZ       20             /* Length of fkey title rkhx 2.00 */
#define DCS_FKEYTEXTSZ        44             /* Length of fkey text rkhx 2.00 */
#define DCS_NUMSYSVARS        10             /* rkhx 2.00 */

#define MDMRESLEN             20
#define TMPNSTR               255             /* Gen. purpose temp. string len*/
#define MINRESSTR             32
#define STATUSRECTBORDER      4


#define SPACE              32                /* Space (yterm)                */
#define SERINBUFFSIZE      LOCALMODEMBUFSZ   /* mbbx: yterm */
#define YTERMTIMEOUT       600


/* VIRTUAL KEY STATE */

#define VKS_SHIFT                   0x0100   /* mbbx 1.04: keymap ... */
#define VKS_CTRL                    0x0200
#define VKS_ALT                     0x0400


#define FKB_UPDATE_BKGD             0x0001   /* mbbx 2.00: fkey button options... */
#define FKB_UPDATE_TIMER            0x0002
#define FKB_DISABLE_CTRL            0x8000


/* CHARACTER ATTRIBUTES */

#define ANORMAL         0x00                 /* mbbx 1.03 ... */
#define ABOLD           0x01
#define AREVERSE        0x02
#define ABLINK          0x04
#define AUNDERLINE      0x08
#define APROTECT        0x10
#define AGRAPHICS       0x20
#define ADIRTY          0x40
#define ACLEAR          0x80
#define AMASK           (ABOLD | AREVERSE | ABLINK | AUNDERLINE | APROTECT)
#define ANOTGRAPHICS    ~AGRAPHICS


/* LINE ATTRIBUTES */

#define LNORMAL      0
#define LHIGHTOP     1
#define LHIGHBOTTOM  2
#define LWIDE        3
#define LATTRIB      132
#define LFLAGS       133
#define LDIRTY       0x01
#define LCLEAR       0x02
#define ATTRROWLEN   134


/* FILE ERROR CONSTANTS */

#define NOERR                 FALSE          /* No file error flag value     */
#define EOFERR                262
#define FERR_FILENOTFOUND     2
#define FERR_PATHNOTFOUND     3
#define FERR_TOOMANYOPENFILES 4
#define FERR_ACCESSDENIED     5
#define FERR_INVALIDACCESS    12
#define FERR_INVALIDFILENAME  257
#define FERR_OPEN             258
#define FERR_READ             259
#define FERR_FILELENGTH       260
#define FERR_CLOSE            261


/* rkhx 2.00 ... */

#if OLD_CODE                                 /* mbbx 2.00: using bit fields... */
/* commFlags */
#define DCS_CF_RESETDEVICE       0x8000      /* select new comm device */
#endif

/* termFlags */
#define DCS_TF_SCROLLBARS        0x0001      /* show terminal scroll bars */

/* modemFlags */
#define DCS_MF_USEDEFAULT        0x0001      /* use default modem settings */

/* communication flags */   /* rjs bug2 */
#define DCS_CF_NETNAMEPADDING    0x0001      /* if set, then use blank padding in NetBios names, else null */

/* environmentFlags */
#define DCS_EVF_FKEYSSHOW        0x0001      /* show fkeys */
#define DCS_EVF_FKEYSARRANGE     0x0002      /* auto arrange when shown */

/* parentFlags */
#define DCS_PF_                  0x0001      /* */

#define DCS_FILE_ID              0x20534344  /* mbbx 2.00 ... */
/* #define DCS_HEADERSZ          4 */
#define DCS_VERSIONSZ         6
#define DCS_DESCRIPTIONSZ    53
#define DCS_PASSWORDSZ       16

#define DCS_ANSWERBACKSZ     44
#define DCS_FONTFACESZ       32

#define DCS_XLINSTRSZ        24

#define DCS_MODEMCMDSZ       32

#define DCS_FKEYNEXTSZ       20
#define DCS_SYSVARSZ         44

#define DCS_DCINITAGSZ       16

#if OLD_CODE

/*                     FILE DIALOG BOX ATTRIBUTE CONSTANTS                   */
#define GETFILE              0x0001
#define PUTFILE              0x0002
#define VIEWTXTFILE          0x0004
#define SENDTXTFILE          0x0008
#define MACFILETYPE          0x0010
#define APPENDTXTFILE        0x0020
#define SENDFILE             0x0040
#define FORCEXTENSION        0x0080
#define RECEIVEFILE          0x0100
#define EXECUTEFILE          0x0200
#define PRINTFILE            0x0400
#define REMOTEFILE           0x0800

#endif


/* strings constants: */

#define DC_WNDCLASS                 "DC_Term"      /* mbbx 1.04: REZ... */

#define HEX_STR                     "0123456789ABCDEF"   /* mbbx 2.00 */

#define NULL_STR                    "\0"     /* mbbx 1.00: 00 00 */
#define VOID_STR                    "\1\0"   /* mbbx 1.00: 01 00 00 */
#define PRMPT_STR                   "\1?"
#define LABEL_STR                   "\1*"
#define SPACE_STR                   "\1 "
#define SEMI_STR                    "\1;"

#define TIME_STR                    "\800:00:00"
#define OK_STR                      "\2OK"
#define VIDEO_STR                   "\5VIDEO"
#define CRLF_STR                    "\2\015\012"
#define DBG_FNL_STR                 "["
#define DBG_FNR_STR                 "]\r\n"
#define MSDOS_STR                   "MSDOS"
#define VT100_STR                   "VT-100"

#define PAR2_STR                    "PAR2"
#define TEXT_STR                    "TEXT"
#define PARM_STR                    "PARM"
#define CCL_STR                     "CCL "
#define YT_WSA_STR                  "\3WSA"
#define YT_W43_STR                  "\3W43"
#define YT_RSA_STR                  "\3RSA"
#define YT_R43_STR                  "\3R43"
#define YT_CRC_STR                  "\02##"
#define YT_RESP_STR                 "012345"


/*****************************************************************************/
/* Data File Definitions                                                     */
/*****************************************************************************/

typedef enum {FILE_NDX_DATA, FILE_NDX_SETTINGS, FILE_NDX_TASK,
              FILE_NDX_SCRIPT, FILE_NDX_MEMO, MAX_FILE_NDX} FILEDOCTYPE;


#define DATA_FILE_TYPE        "\\*.*"
#define SETTINGS_FILE_TYPE    "\\*.TRM"
#define TASK_FILE_TYPE        "\\*.TXT"
#define SCRIPT_FILE_TYPE      "\\*.TXT"
#define MEMO_FILE_TYPE        "\\*.TXT"
#define ANY_FILE_TYPE         "\\*.*"
#define NO_FILE_TYPE          "\\*."         /* mbbx 2.00 */

#define INI_FILE_TYPE         "\\*.INI"
#define EXE_FILE_TYPE         "\\*.EXE"
#define DRIVER_FILE_TYPE      "\\*.DRV"      /* mbbx 2.00 ... */
/* #define TERMINAL_FILE_TYPE    "\\*.TRM"   mbbx 2.00: no forced extents */


#define FILEDOCDATA                 struct tagFileDocData

struct tagFileDocData
{
   BYTE     filePath[PATHLEN];
   BYTE     fileName[16];
   BYTE     fileExt[16];
   BYTE     title[PATHLEN];
} fileDocData[MAX_FILE_NDX];

/*
struct tagFileDocData
{
   BYTE     filePath[FO_MAXPATHLENGTH];
   BYTE     fileName[FO_MAXFILELENGTH];
   BYTE     fileExt[FO_MAXEXTLENGTH];
   BYTE     title[FO_MAXPATHLENGTH];
} fileDocData[MAX_FILE_NDX];
*/

/* #define ATTRDIRLIST           0x4010 */


INT   saveFileType;                          /* mbbx 2.00: save prev file type... */


/*****************************************************************************/
/* Structure Definitions                                                     */
/*****************************************************************************/


/* rkhx 2.00 */
/* obsolete
typedef
   struct {
      BYTE  title[TITLELEN];
      BYTE  xtra[XTRALEN];
   } TITLEREC;
*/


// -sdj this is the portable way to pack the structures 1 byte aligned.
// win3.0 sources are compiled with -Zp option so that the structures are
// byte aligned. This pragma would work for MIPS and X86 MS compilers

#ifdef ORGCODE
#else
#pragma pack(1)
#endif

typedef
   struct {
/* House keeping:    86 +   42 =  128 bytes */
   LONG fileID;                              /* mbbx 2.00 ... */
/* BYTE header[DCS_HEADERSZ];                header ('DCS ') */
   BYTE version[DCS_VERSIONSZ];           /* version (2.00: ) */
   BYTE description[DCS_DESCRIPTIONSZ];   /* description */
   BYTE controlZ;                         /* fake eof for typing text */
   WORD fileSize;                         /* file size */
   WORD crc;                              /* crc check */
   WORD groupSave;                        /* global save params flag DCS_GS_... */
   BYTE password[DCS_PASSWORDSZ];         /* password */
   BYTE headerXtraRoom[42];               /* extra room for header section */

/* Communications:   (7 + 5) + (7 + 5) + (98 + 6) =  128 bytes */
   WORD fParity: 1;                       /* mbbx 2.00: bit fields... */
   WORD fCarrier: 1;
   WORD commFlags: 13;                    /* communication settings DCS_CF_... */
   WORD fResetDevice: 1;

   BYTE newDevRef;                        /* new comm device */
   BYTE comDevRef;                        /* comm device */
   BYTE comExtRef;                        /* comm extension */
   BYTE comPortRef;                       /* comm port */
   BYTE comModeRef;
   BYTE commXtraRoom1[5];                 /* extra room for comm section */

   WORD speed;                            /* mbbx 2.00: allow ANY baud rate */
   BYTE dataBits;
   BYTE parity;
   BYTE stopBits;
   BYTE flowControl;
   BYTE priority;                         /* com priority (as per spooler) */
   BYTE commXtraRoom2[5];                 /* extra room for comm section */

   BYTE localName[16];                    /* used for deviceName */
   BYTE remoteName[64];
   BYTE deviceName[14];                   /* used for deviceName */
   WORD netRcvTimeOut;
   WORD netSndTimeOut;
   BYTE commXtraRoom3[6];                 /* extra room for comm section */

/* Terminal:         94 +   34 =  128 bytes */
   WORD termFlags: 12;
   WORD fInpLFCR: 1;
   WORD fBSKey: 1;
   WORD fHideTermHSB: 1;
   WORD fHideTermVSB: 1;
   BYTE emulate;                          /* terminal emulation */
   BYTE fCtrlBits;                        /* mbbx 1.10: VT220 8BIT */
   BYTE answerBack[DCS_ANSWERBACKSZ];     /* answer back string */
   BYTE lineWrap;
   BYTE localEcho;
   BYTE sound;
   BYTE inpCRLF;
   BYTE outCRLF;
   BYTE columns;
   BYTE termCursor;
   BYTE cursorBlink;
   BYTE fontFace[DCS_FONTFACESZ];         /* font face */
   WORD fontSize;                         /* font point size */
   WORD language;                         /* mbbx 1.04 */
   WORD bufferLines;                      /* terminal scroll buffer size */
/**** nov25,91 win31 added 2 bytes here! -sdj ********************/
/**** to compensate the xtra room was reduced by 2 bytes 34->32 -sdj *********/
   BYTE setIBMXANSI;
   BYTE useWinCtrl;

   BYTE termXtraRoom[32];                 /* extra room for terminal section */






/* Binary Transfers:  9 +  119 =  128 bytes */
   WORD binXferFlags;                     /* binary transfer state DCS_BXF_... */
   BYTE xBinType;
   WORD rcvBlSz;
   WORD sendBlSz;
   BYTE retryCt;
   BYTE psChar;                           /* mbbx 1.04: xferPSChar */
   BYTE binXferXtraRoom[119];             /* extra room for bin xfer section */

/* Text Transfers:   33 +   95 =  128 bytes */
   WORD txtXferFlags;                     /* text transfer state DCS_TXF_... */
   BYTE xTxtType;
   BYTE xChrType;
   BYTE xChrDelay;
   BYTE xLinType;
   BYTE xLinDelay;
   BYTE xLinStr[DCS_XLINSTRSZ];
   BYTE xWordWrap;
   BYTE xWrapCol;
   BYTE txtXferXtraRoom[95];              /* extra room for txt xfer section */

/* Phone:            38 +   90 =  128 bytes */
   WORD phoneFlags;                       /* phone state DCS_PHF_... */
   BYTE phone[DCS_MODEMCMDSZ];
   BYTE dlyRetry;
   BYTE cntRetry;
   BYTE flgRetry;
   BYTE flgSignal;
   BYTE phoneXtraRoom[90];                /* extra room for phone section */

/* Modem:           387 +  253 =  640 bytes */
   WORD modemFlags;                       /* modem state DCS_MF_... */
   BYTE xMdmType;
   BYTE dialPrefix[DCS_MODEMCMDSZ];
   BYTE dialSuffix[DCS_MODEMCMDSZ];
   BYTE hangPrefix[DCS_MODEMCMDSZ];
   BYTE hangSuffix[DCS_MODEMCMDSZ];
   BYTE binTXPrefix[DCS_MODEMCMDSZ];
   BYTE binTXSuffix[DCS_MODEMCMDSZ];
   BYTE binRXPrefix[DCS_MODEMCMDSZ];
   BYTE binRXSuffix[DCS_MODEMCMDSZ];
   BYTE answer[DCS_MODEMCMDSZ];
   BYTE originate[DCS_MODEMCMDSZ];
   BYTE fastInq[DCS_MODEMCMDSZ];             /* mbbx 2.00: not used */
   BYTE fastRsp[DCS_MODEMCMDSZ];             /* mbbx 2.00: not used */
   BYTE modemXtraRoom[221];                  /* extra room for modem section */
   BYTE phone2[DCS_MODEMCMDSZ];             /* mbbx 2.00: not used */

/* Environment:    2510 +   50 = 2560 bytes */
   WORD environmentFlags;                 /* environment state DCS_EVF_... */
   BYTE fKeyNext[DCS_FKEYNEXTSZ];
   BYTE fKeyTitle[DCS_FKEYLEVELS][DCS_NUMFKEYS][DCS_FKEYTITLESZ]; /*  4 *  8 * 20 =  640 */
   BYTE fKeyText[DCS_FKEYLEVELS][DCS_NUMFKEYS][DCS_FKEYTEXTSZ];   /*  4 *  8 * 44 = 1408 */
   BYTE systemVariables[DCS_NUMSYSVARS][DCS_SYSVARSZ];            /*      10 * 44 =  440 */
   BYTE environmentXtraRoom[50];          /* extra room for environment section */

/* Parent:           42 +   86 =  128 bytes */
   WORD parentFlags;                      /* arrange/stack flags DCS_PF_... */
   SHORT dummy1;
   SHORT dummy2;
   SHORT dummy3;
   SHORT dummy4;
   BYTE keyMapTag[DCS_DCINITAGSZ];        /* key remapping tag (.ini file) */
   BYTE videoAttrTag[DCS_DCINITAGSZ];     /* video tag (.ini file) */
   BYTE szConnectorName[DCS_DCINITAGSZ];  /* slc nova 031 bjw nova 001 Connector DLL file name */
   BYTE connectorConfigData[32];          /* slc nova 028 */
   BYTE parentXtraRoom[86 - DCS_DCINITAGSZ - 32 ];               /* extra room for parent section */
   } recTrmParams;

typedef recTrmParams FAR *LPSETTINGS;

#ifdef ORGCODE
#else
#pragma pack()
#endif

typedef
   struct {
             LONG row;
             LONG col;
          }  ROWCOL;


typedef
   struct {
             GLOBALHANDLE  hText;
             RECT          viewRect;
             LONG          selStart;
             LONG          selEnd;
             BOOL          active;
             FARPROC       clikLoop;
             HFONT         hFont;
          } tEHandle;


#define TF_CHANGED                  0x8000
#define TF_NOCLOSE                  0x4000
#define TF_DIM                      0x2000
#define TF_HIDE                     0x1000
#define TF_DEFTITLE                 0x0010

typedef
   struct
   {
      BYTE      filePath[PATHLEN+1];
      BYTE      fileName[FILENAMELEN+1];
      BYTE      fileExt[FILENAMELEN+1];
      BYTE      title[PATHLEN+1];
      WORD      flags;
   } curDataRec;


typedef
   struct {
             BOOL good;
             BYTE vRefNum[PATHLEN+1];
             BYTE fName[PATHLEN+1];
          }  FSReply;

typedef
   struct {
             WORD  hour;
             WORD  minute;
             WORD  second;
             WORD  dayOfWeek;                 /* 0 = Sunday ... 6 = Saturday  */
             WORD  mm;                        /* Month (1 - 12)               */
             WORD  dd;                        /* Day   (1 - 31)               */
             WORD  yy;                        /* Year  (1980 - 2099)          */
          }  DOSTIME;


typedef
   struct {
            BYTE  fdType[4];
            BYTE  fdCreator[4];
            INT   fdFlags;
            DWORD ioFlLgLen;
            DWORD ioFlRLgLen;
            LONG  ioFlCrDat;
            LONG  ioFlMdDat;
          } PARAMBLOCKREC;


typedef
   struct {
            BYTE  reserved[21];
            BYTE  attribute;
            WORD  time;
            WORD  date;
            LONG  size;
            BYTE  filename[14];
          } DTA;

typedef DTA FAR *LPDTA;


/*****************************************************************************/
/* Variable Definitions                                                      */
/*****************************************************************************/

/* WORD  winVersion; */

INT  itemHit;

BOOL doneFlag;                               /* End of DynaComm - Flag       */
BOOL cancelAbort;                            /* Abort spooling process ?     */
DWORD dwWriteFileTimeout;                    /* used for wait after writefile*/
BYTE  MaxComPortNumberInMenu;		     /* N in max ComN, just now 4    */
BYTE  bPortDisconnected;		     /* this flag is used to indicate that
						the specified port is no longer accesible
						user should select some other port. Typically
						this will happen when user presses cntl-c or
						quit at the telnet prompt, and after this the
						right thing to do is to close this port and
						prompt user to select other port */

int   WindowXPosition;			     // x cord for createwindow
int   WindowYPosition;			     // y cord for createwindow
int   WindowWidth;			     // width  for createwindow
int   WindowHeight;			     // height for createwindow
CHAR  szCurrentPortName[TMPNSTR+1];	     // this variable will contain the name
					     // of port which terminal attempted an open on


BOOL  bPortIsGood;                           /* to indicate that the port is good*/

typedef struct _ComNumAndName {
    BYTE Index;
    CHAR PortName[TMPNSTR+1];
    } COMMNUMANDNAME, *PCOMMNUMANDNAME;

COMMNUMANDNAME arComNumAndName[20];

BOOL activTerm;                              /* Active terminal flag         */

POINT nScrollRange;
POINT nScrollPos;                                                        /* port macro added MPOINT*/

BOOL noSelect;                               /* rjs bugs 020 */
BOOL activSelect;
BOOL answerMode;                             /* Answer mode flag             */
BOOL mdmValid;
BOOL cursorValid;
BOOL debugFlg;                               /* Monitor mode (dis)enabled ?  */
BOOL prtFlag;
BOOL transPrintFlag;                         /* rjs bug2 */
BOOL prtPause;
BOOL escSeq;                                 /* Incoming are part of escSeq  */
BOOL ansi;
BOOL escAnsi;
BOOL escGraphics;
BOOL escCursor;
BOOL escVideo;
BOOL statusLine;                             /* Status line enabled ?        */
BOOL chInsMode;
BOOL vidInverse;
BOOL cursorKeyMode;
BOOL keyPadAppMode;
BOOL originMode;
BOOL grChrMode;
BOOL cursorOn;
BOOL dialing;
BOOL cursBlinkOn;
BOOL scrapSeq;
BOOL outBufSeq;
BOOL copiedTable;
BOOL useScrap;
BOOL mdmOnLine;
BOOL timerActiv;
BOOL useMacFileName;
BOOL vScrollShowing;
BOOL later;
BOOL bufferFull;
BOOL fKeysShown;
BOOL protectMode;                            /* mbbx: emulation */

BYTE  szAppClass[20];                        /* rjs bug2 */
BYTE  szAppName_private[20];                 /* Windows registered name      */
BYTE  szAppName[20];                         /* Windows name      */
BYTE  szMessage[80];                         /* Tiled window caption         */

BYTE  serBytes[LOCALMODEMBUFSZ];             /* Our IT local modem buffer    */
BYTE  attrib[25][134];                       /* Screen attribute map         */
BYTE  curAttrib;                             /* Current character attribute  */
BYTE  ch;                                    /* Modem character              */
BYTE  theChar;                               /* Modem character - all 7 bits */
BYTE  the8Char;                              /* Modem character - all 8 bits */
BYTE  tabs[132];
BYTE  fileVolume[80];
BYTE  macFileName[PATHLEN+1];
BYTE  charSet[2];
BYTE  chAscii;
BYTE  emulInfo[128];
BYTE  icsXlateTable[256];                    /* mbbx 1.04: ics */
BYTE  ansiXlateTable[256];                   /* mbbx 1.06A: ics new xlate */
WORD  keyMapState;                           /* mbbx 1.04: keymap */

STRING mdmResult[MDMRESLEN];                 /* Non-displayed modem chars.   */
STRING line25[132];                          /* Status line 25 characters    */
STRING strAnsi[STR255];
STRING outBuf[134];
STRING fKeyStr[STR255];
STRING keyPadString[5];

/*---------------------------------------------------------------------------*/

XFERFLAG    xferFlag;
BOOL        xferStopped;
INT         xferErrors;
LONG        xferLength;
HANDLE      xferBufferHandle;    /* rjs bugs 016 */
WORD        xferBufferCount;     /* rjs bugs 016 */

INT         xferRefNo;
STRING      xferVRefNum[PATHLEN];
STRING      xferFname[PATHLEN];
STRING      rdCH[256];
int         ioCnt;    /* flagged by port macro*/

WORD  xferMenuAdds;

INT   xferSndLF;                             /* mbbx: (-1,0,1)=>(NOLF,CR,CRLF) */
WORD  xferViewPause;                         /* mbbx: auto line count */
WORD  xferViewLine;

INT   xferBlkNumber;
INT   xferPct;
INT   xferLinDelay;
INT   xferChrDelay;

BOOL xferPaused;
BOOL xferBreak;                              /* mbbx 2.00: xfer ctrls */
BOOL xferSaveCtlChr;
BOOL xferTableSave;
BOOL xferWaitEcho;
BOOL xferAppend;
BOOL xferFast;

BYTE  xferCharEcho;
BYTE  xferPSChar;                            /* mbbx 1.02: packet switching */

STRING xferLinStr[DCS_XLINSTRSZ];            /* rkhx 2.00 */
STRING strRXBytes[32];
STRING strRXErrors[32];
STRING strRXFname[32];
STRING strRXFork[4];

TTXTTYPE      xferTxtType;
TCHRTYPE      xferChrType;
TLINTYPE      xferLinType;
tBinType      xferBinType;
tBinFork      xferBinFork;

LONG  xferEndTimer;
LONG  xferOrig;
LONG  xferBlkSize;
LONG  xferRLgLen;
LONG  xferLgLen;
LONG  xferBytes;
LPBYTE xferBuffer;
CHAR  NoMemStr[41];

/*---------------------------------------------------------------------------*/

INT            serNdx;                                /* Index into local modem buff. */
INT            serCount;                              /* Index comm. buffer           */
INT            curCol;
INT            curLin;
INT            maxChars;
INT            maxLines;
INT            escChar;
INT            escSkip;
BOOL           termDirty;                             /* mbbx: used to be termLine */
INT            savTopLine;
INT            curTopLine;
INT            savLeftCol;
INT            chrWidth,  stdChrWidth;
INT            chrHeight, stdChrHeight;
INT            scrRgnBeg;
INT            scrRgnEnd;
INT            escCol;
INT            escLin;
INT            curLeftCol;
INT            maxScreenLine;                         /* Windows only                 */
INT            visScreenLine;                         /* Windows only                 */
INT            curLevel;
INT            vidBG;
INT            textIndex;
INT            outBufCol;
INT            fKeyNdx;
INT            keyPadIndex;
HANDLE         sPort;                                 /* Serial port id win32         */
INT            portLocks;                             /* number of unreleased getPorts*/
BOOL           sPortErr;

INT            lineFeeds;
INT            seqTableNdx;
INT            progress;
INT            decScs;
INT            shiftCharSet;
INT            activCursor;
INT            scrollBegin;
INT            scrollEnd;
INT            nScroll;
INT            fKeysHeight;                           /* (mbbx) */
INT            ctrlsHeight;                           /* mbbx 1.04 */

ESCEXTEND      escExtend;
TBLPOS         tblPos;
VIDGRAPHICS    vidGraphics;
KBD_STATE      kbdLock;

DWORD          gIdleTimer;                            /* rjs bug2 001 */

LONG           lastChTick;
LONG           timPointer;
LONG           cursorTick;
LONG           dialStart;

LONG           textLength;

/*                            \\\ Long Pointers ///                          */

LPBYTE         textPtr;

HWND           hItWnd;                        /* Application Window Handle    */
HWND           hTermWnd;                      /* Window handle to terminal    */
HWND           hdbmyControls;                 /* Window handle to fkey dlg.   */
HWND           hdbXferCtrls;                  /* mbbx 1.04: term ctrls */
HWND           hEdit;
HWND           fKeyHdl;

HWND           hwndThread;                      // rjs thread
DWORD          dwTimerRes;                      // rjs thread
HWND           commThread;                      // rjs thread
BOOL           CommThreadExit;                  // sdj thread
BOOL           gotCommEvent;                    // rjs thread
HANDLE         overlapEvent;                    // rjs thread
BOOL           gbThreadDoneFlag;                // rjs thread
HANDLE         hMutex;                          // rjs thread
BOOL           gbXferActive;                    // rjs thread
BOOL           bgOutStandingWrite;   /* slc swat */

ControlHandle  xferCtlStop;
ControlHandle  xferCtlPause;
ControlHandle  xferCtlScale;
ControlHandle  fKeyHandles[DCS_NUMFKEYS+1];

HDC            hPrintDC;
HDC            thePort;
HBRUSH         theBrush;
HBRUSH         blackBrush;

HMENU          hMenu;
WORD           sysAppMenu[16];                 /* mbbx 2.00.03: control app menu */
HMENU          hEditMenu;                      /* Edit popup for Terminal WND  */
HMENU          hLastEdit;

HANDLE         hInst;
HANDLE         hIconLib;                       /* mbbx 1.10: DCICONS.LIB */
HANDLE         hemulKeyInfo;
HANDLE         tEScrapHandle;

HANDLE        hDevNames;
HANDLE        hDevMode;

HBITMAP        hCloseBox;                      /* mbbx: mdi */

HANDLE         hDCCLib;                         /* mbbx 2.00: compile */
HWND           hDCCDlg;                         /* mbbx 2.00: compile */

MSG            msg;                            /* Application queue messages   */
RECT           cursorRect;                     /* Rectangle of the current curs*/
RECT           timerRect;
RECT           statusRect;                      /* CCL commands show up in here */
POINT         lastPoint;                       /* last hTermWnd client point   */
DOSTIME        startTimer[MAXTIMERNUM];         /* mbbx 2.00: multiple timers */
DOSTIME        lastTime;
recTrmParams   trmParams;                      /* Contains global 'settings'   */
tEHandle       hTE;                            /* Main text edit window struct */
curDataRec     termData;                        /* Current data associated w/   */
                                             /* terminal window              */
PARAMBLOCKREC  xferParams;

struct icontype
{
   HICON  hIcon;
   INT    last;
   BOOL   flash;
   INT    dy;
   INT    dx;
}  icon;

struct                                       /* mbbx 2.00: intl date/time... */
{
   INT   iDate;                              /* 0=MDY, 1=DMY, 2=YMD */
   BYTE  sDate[2];                           /* date separator */
   INT   iTime;                              /* 0=12HR, 1=24HR */
   BYTE  sTime[2];                           /* time separator */
   BYTE  s1159[4];                           /* AM trailing string */
   BYTE  s2359[4];                           /* PM trailing string */
}  intlData;


/*                       \\\ Functions & Procedures ///                      */

/* FARPROC lpdbPortInit;                     mbbx: now local */

/*                                           mbbx 1.04: obsolete...
FARPROC lpitWndProc;
FARPROC lptrmWndProc;
FARPROC lpSizeBoxProc;
FARPROC lpdbStdFN;
FARPROC lpdbGetPutFN;
FARPROC lpdbTypTFile;
FARPROC lpdbRcvTFile;
FARPROC lpdbSendFile;
FARPROC lpdbPrompt;
FARPROC lpdbSelSavApp;
FARPROC lpdbPhon;
FARPROC lpdbEmul;
FARPROC lpdbTerm;
FARPROC lpdbFkey;
FARPROC lpdbTxtX;
FARPROC lpdbBinX;
FARPROC lpdbComm;
FARPROC lpdbModem;
FARPROC lpEditProc;
*/

procPtr termState;
procPtr escHandler;
procPtr pEscTable[128];
procPtr aEscTable[128];
procPtr pProcTable[72];                      /* mbbx 2.00 ... */
procPtr aProcTable[72];
procPtr ansiParseTable[16];


/* KERMIT STUFF */

#define DEL         127                /* Delete (rubout) */
/* crt also defines EOF so dont define this twice -sdj*/
#ifndef EOF
#define EOF         -1
#endif

#define DEFESC      '^'     /* Default escape character for CONNECT */
#define DEFIM       TRUE    /* Default image mode */

#define DEFFNC      FALSE

#define KERFILE     1       /* bufemp goes to a file */
#define KERBUFF     2       /* bufemp goes to KER_buff */
#define KERSCREEN   4       /* bufemp goes to the screen */

#define tochar(ch)  ((ch) + ' ')
#define unchar(ch)  ((ch) - ' ')
#define ctl(ch)     ((ch) ^ 64 )
#define unpar(ch)   ((ch) & 127)

INT
   KER_size,          /* Size of present data */
   KER_rpsiz,         /* Maximum receive packet size */
   KER_spsiz,         /* Maximum send packet size */
   KER_pad,           /* How much padding to send */
   KER_timint,        /* Timeout for foreign host on sends */
   KER_n,             /* Packet number */
   KER_numtry,        /* Times this packet retried */
   KER_oldtry,        /* Times previous packet retried */
   ttyfd,             /* File descriptor of tty for I/O, 0 if remote */
   KER_remote,        /* -1 means we're a remote kermit */
   KER_image,         /* -1 means 8-bit mode */
   KER_parflg,        /* TRUE means use parity specified */
   KER_turn,          /* TRUE means look for turnaround char (XON) */
   KER_lecho,         /* TRUE for locally echo chars in connect mode */
   KER_8flag,         /* TRUE means 8th bit quoting is done */
   KER_initState,     /* jtf 3.20 Used for retries durring send/receive */
   KER_parMask,       /* tge Used for auto parity selection */
   KER_mask,          /* tge Used for auto parity checsum masking */
   KER_pktdeb,        /* TRUE means log all packet to a file */
   KER_filnamcnv,     /* -1 means do file name case conversions */
   KER_filecount,     /* Number of files left to send */
   KER_timeout;       /* TRUE means a timeout has occurred. */

BYTE
   KER_state,         /* Present state of the automaton */
   KER_cchksum,       /* Our (computed) checksum */
   KER_padchar,       /* Padding character to send */
   KER_eol,           /* End-Of-Line character to send */
   KER_escchr,        /* Connect command escape character */
   KER_quote,         /* Quote character in incoming data */
   KER_select8,       /* 8th bit quote character to send either 'Y' or '&'*/
   KER_firstfile,
   KER_getflag,
   **KER_filelist,    /* List of files to be sent */
   *KER_filnam,       /* Current file name */
   recpkt[94],        /* Receive packet buffer */
   packet[94],        /* Packet buffer */
   KER_buff[94],      /* buffer for translations */
   outstr[80],        /*output string for debugging and translations */
   KERRCVFLAG;        /* direct recieved buffers to screen, file or buffer*/

LONG
   KER_bytes;          /* number of bytes received */

/*
   19 *  2 byte   =   38 bytes

    9 *  1 byte
    2 *  4 bytes
    3 * 94 bytes
    1 * 80 bytes
    1 *  1 byte   =  380 bytes

    1 *  4 bytes  =    4 bytes

                     422 bytes total + room for filenames */

/*****************************************************************************/
/* Macro Definitions                                                         */
/*****************************************************************************/

#define proc                     void near
#define getResId                 MAKEINTRESOURCE
#define eraseRect(rectangle)     FillRect(getPort(),(LPRECT) &rectangle, theBrush); releasePort()
#define invalRect(rectangle)     InvalidateRect(hTermWnd, (LPRECT) &rectangle)
#define validRect(rectangle)     ValidateRect(hTermWnd, (LPRECT) &rectangle)
#define invertRect(rectanlge)    InvertRect(getPort(), (LPRECT) &rectanlge); releasePort()
#define tickCount()              GetCurrentTime() * 60/1000
#define TEDelete(h)              SendMessage(h, WM_CLEAR, 0, 0L)
#define sysBeep()                MessageBeep(0)
#define nullTerminate(str)       str[*str+1] = 0
#define strEquals(dst,src)       memcpy(dst, src, (WORD) src[0] + 1), nullTerminate(dst)
#define blockMove(src, dst, len) lmovmem(src, dst, (DWORD) len)
#define equalString(str1, str2)  !strcmpi(str1, str2)
#define repeat                   do
#define until(cond)              while(!(cond))
#define stringToNum(str,num)     sscanf(&str[1], "%ld", num)
#define c2p(str1, str2)          lstrcpy((LPBYTE) &str1[1], (LPBYTE) str2), *str1 = lstrlen((LPBYTE) &str1[1])
#define p2c(str1, str2)          lmovmem((LPBYTE) &str2[1], (LPBYTE) str1, (unsigned) *str2), str1[*str2] = NULL
#define SWAPBYTES(i)             (((WORD) i >> 8) | (i << 8))
#define yield(lpmsg, hWnd)       PeekMessage(lpmsg, hWnd, 0, 0, FALSE)


/*****************************************************************************/
/* Forward Procedure Definitions                                             */
/*****************************************************************************/

/*** INITCODE.C ***/
//WORD MMain(HANDLE, HANDLE, LPSTR, INT);  /* causing compiler to puke*/
BOOL initWndClass();                         /* mbbx 1.04: was registerIt(); */
VOID initPort();
VOID initIcon();
BOOL createWindows(INT);
/* VOID hidemyControls();                    mbbx 2.00: obsolete... */
VOID setDefaultFonts();
VOID sizeWindows();
HBITMAP NEAR extractCloseBitmap();
BOOL initWindows(HANDLE, HANDLE, INT);
VOID initDialogs();
INT_PTR APIENTRY dbPortInit(HWND, UINT, WPARAM, LPARAM);
BOOL NEAR setProfileExtent(BYTE *, BYTE *);  /* mbbx 2.00: default paths... */
BOOL NEAR initFileDocData(FILEDOCTYPE fileType, WORD strResID,BYTE  *fileExt,BYTE *szSection);
VOID initProfileData();
BOOL setup();
/* VOID initMemPort();                       mbbx 2.00: */
VOID NEAR initIconLib();
BOOL NEAR initTermFile(BYTE *);
BOOL NEAR initTaskExec(BYTE *);
BOOL NEAR initEditFile(INT, BYTE *);
VOID NEAR readCmdLine(LPSTR);
VOID freeItResources();

/*** WINMAIN.C ***/
VOID FAR mainProcess();
VOID FAR mainEventLoop();
BOOL NEAR checkInputBuffer(MSG *);
void APIENTRY idleProcess(VOID);
VOID FAR updateTimer();
BOOL updateFKeyButton(WPARAM wParam ,LPARAM lParam,WORD  status);   /* JAP fix adding wParam*/
VOID getTimeString(BYTE *, DOSTIME *);       /* mbbx 2.00: intl date/time */
VOID FAR cursorAdjust();
VOID NEAR blinkCursor();
BOOL NEAR taskProcess();

/*** WNDPROC.C ***/                          /* mbbx 1.04 ... */
VOID selectTopWindow();
/* changed WORD -> UINT -sdj */
LRESULT APIENTRY DC_WndProc(HWND, UINT, WPARAM, LPARAM);
VOID termKeyProc(HWND hWnd, UINT message, WPARAM wParam,LPARAM lParam);
/* changed WORD -> UINT -sdj */
LRESULT APIENTRY TF_WndProc(HWND, UINT, WPARAM, LPARAM);

/*** CHRPAINT.C ***/
VOID eraseColorRect(HDC hDC,LPRECT rect,BYTE cAttr);
VOID reDrawTermScreen(INT, INT, INT);        /* mbbx 2.00.06: jtf disp2 */
VOID reDrawTermLine(INT, INT, INT);
VOID updateLine(INT);
VOID drawTermLine(LPBYTE txtPtr,INT len, INT lin, INT col,BYTE  lAttr,BYTE cAttr);
VOID setAttrib(BYTE cAttr);

/*** DOFILE.C ***/
VOID getFileDocData(FILEDOCTYPE, BYTE *, BYTE *, BYTE *, BYTE *);
VOID setFileDocData(FILEDOCTYPE, BYTE *, BYTE *, BYTE *, BYTE *);    /* mbbx 2.00: no forced extents... */
VOID getDataPath(FILEDOCTYPE, BYTE *, BYTE *);
BOOL setDataPath(FILEDOCTYPE, BYTE *, BOOL);
BOOL EditGetDocData(BYTE *, BYTE *, BYTE *);
BOOL EditSetDocData(BYTE *, BYTE *, BYTE *, WORD, BOOL);

/*** MODEMINP.C ***/
VOID cleanRect(INT, INT);
VOID updateLine(INT);
proc scrollBuffer();
proc doScroll();
VOID trackCursor();
VOID termCleanUp();
proc putChar(BYTE ch);
VOID checkSelect();
VOID clrAttrib(INT, INT, INT, INT);
proc clrLines(INT, INT);
proc clrChars(INT, INT, INT);
VOID getUnprot(INT, INT, INT *, INT *);
INT getProtCol();
proc pCursToggle();
proc pCursOn();
proc pCursOff();
proc pCursRC();
proc pSetStatusLine();                       /* mbbx 1.03: TV925 ... */
proc pCursHome();
proc pVideo(BYTE attr);
proc pCursRelative(INT, INT);
proc pCursUp();
proc pCursDn();
proc pCursRt();
proc pCursLt();
proc pVPosAbsolute();
proc pHPosAbsolute();
proc pClrScr();
proc pClrBol();
proc pClrBop();
proc pClrEol();
proc pClrEop();
proc pClrLine();
proc scrollAttrib(INT, INT, INT, BOOL);
proc pLF();
proc pInsLin(INT, INT);
proc pDelLin(INT, INT, INT);
proc pDelChar(INT);
VOID begGraphics();
VOID endGraphics();
proc pGrSemi();
proc pGrDoIt(INT, HBRUSH);
proc pGrFill();
proc pGrChar();
proc pSetGrMode();
proc pSetMode();
proc pDecScs();
proc getParms();
proc pInquire();
proc pTab();
proc pClearAllTabs();
proc pSetTab();
proc pClearTab();
proc pCmpSrvResponse();
proc pSndCursor();
proc pIndex();
proc pRevIndex();
proc pSetLineAttrib();
proc pInsChar();
proc pSaveCursorPos();
proc pRestoreCursorPos();
proc pEscSkip();
proc pNullState();
proc pCursorState();
proc pVPosState();
proc pHPosState();
proc pLAttrState();
proc pAnsi();
proc pAnsiState();
proc pGrState();
proc pSkipState();
proc pReverseOff();
proc pReverseOn();
proc pProtOff();
proc pProtOn();
proc pBegProtect();                          /* mbbx 1.03: TV925 */
proc pEndProtect();                          /* mbbx 1.03: TV925 */
proc pBegGraphics();                         /* mbbx 1.03: TV925 */
proc pEndGraphics();                         /* mbbx 1.03: TV925 */
proc pLinDel();
proc pCharDel();
proc pLinIns();
proc pNextLine();
proc pClrAll();
proc pPrintOn();
proc pPrintOff();
proc pTransPrint();                          /* rjs bug2 */
VOID NEAR checkTransPrint(BYTE);             /* rjs swat */
proc pVideoAttrib();
proc pVideoAttribState();
proc pCursorOnOff();
proc pCursorOnOffState();
proc pAnswerBack();
proc pEchoOff();
proc pEchoOn();
proc pCR();
proc pBackSpace();
proc pBeep();
proc pEscSequence();
VOID NEAR aSetCompLevel();                   /* mbbx 1.10: VT220 8BIT */
VOID NEAR pSetCtrlBits();                    /* mbbx 2.00: VT220 8BIT */
proc aCursor();
proc aClrEol();
proc aClrEop();
proc aCursUp();
proc aCursDn();
proc aCursRt();
proc aCursLt();
proc aClearTabs();
proc aVideo();
proc aSetMode();
proc aReport();
proc aSetScrRgn();
proc aDelLin();
proc aInsLin();
proc aDelChar();
proc pVT100H();
proc pVT100D();
proc pVT100M();
proc pVT100c();
proc pVT100P();                              /* mbbx: new routine */
proc pDCS();                                 /* mbbx: yterm */
proc pDCSTerminate();
proc ansiArgument();
proc ansiDelimiter();
proc ansiHeathPrivate();
proc ansiDecPrivate();
proc testPause(BYTE);
BOOL NEAR writeRcvChar(BYTE theChar);                /* mbbx 1.10 */
VOID NEAR putRcvChar(BYTE theChar);                  /* mbbx 1.10 */
VOID putDebugChar(BYTE, BOOL);               /* mbbx 2.00: FAR, bRcvChar... */
VOID modemInp(INT, BOOL);                    /* mbbx 1.10 */

/*** PHONE.C ***/
BOOL termSendCmd(BYTE *str, INT nBytes,WORD  wFlags);

/*** RDMODEM.C ***/
BOOL FAR testWhenEnabled();
BOOL FAR testWhenActive();
BOOL NEAR brake();
VOID rdModem(BOOL);

/*** SERIAL.C ***/
VOID resetSerial(recTrmParams *trmParams, BOOL bLoad, BOOL  bInit, BYTE byFlowFlag);   /* slc swat */
BOOL PASCAL NEAR resetSerialError0(recTrmParams *trmParams, WORD count);
BOOL PASCAL NEAR resetSerialError1(recTrmParams *trmParams, WORD count);
DWORD checkCommEvent(LPVOID);

/*** SETTINGS.C ***/
BOOL doSettings(INT, DLGPROC);
/* changed WORD -> UINT -sdj */
INT_PTR  APIENTRY dbPhon(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY dbEmul(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY dbTerm(HWND, UINT, WPARAM, LPARAM);
VOID NEAR setDlgFkeys(HWND, INT);
VOID NEAR getDlgFkeys(HWND, INT);
/* changed WORD -> UINT -sdj */
INT_PTR  APIENTRY dbFkey(HWND, UINT, WPARAM, LPARAM);
VOID NEAR enableChrItems(HWND, BOOL);
VOID NEAR enableLinItems(HWND, BOOL);
/* changed WORD -> UINT -sdj */
INT_PTR  APIENTRY dbTxtX(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY dbBinX(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY dbComm(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY dbComBios(HWND, WORD, WPARAM, LPARAM);    /* mbbx 2.00: network... */
INT_PTR  APIENTRY dbNetBios(HWND, WORD, WPARAM, LPARAM);    /* mbbx 2.00: network... */
INT_PTR  APIENTRY dbUBNetCI(HWND, WORD, WPARAM, LPARAM);    /* mbbx 2.00: network... */
INT_PTR  APIENTRY dbDevice(HWND, WORD, WPARAM, LPARAM);     /* mbbx 2.00: network... */
/* changed WORD -> UINT -sdj */
INT_PTR  APIENTRY dbModem(HWND, UINT, WPARAM, LPARAM);   /* mbbx 1.10: CUA... */
VOID chkGrpButton(HWND, INT, INT, INT);
BYTE whichGrpButton(HWND, INT, INT);
/*                                           mbbx 1.04: obsolete routines...
VOID initDlgPhon ();
VOID dlgCommandPhon ();
VOID initDlgEmul ();
VOID dlgCommandEmul ();
VOID initDlgTerm ();
VOID dlgCommandTerm ();
VOID initDlgFkey ();
VOID dlgCommandFkey ();
VOID setFkeys ();
VOID getFkeys ();
VOID enableButton ();
VOID initDlgTxtX ();
VOID dlgCommandTxtX ();
VOID initDlgBinX ();
VOID dlgCommandBinX ();
VOID initDlgComm ();
VOID dlgCommandComm ();
BOOL  APIENTRY dbModem();
*/
INT_PTR  APIENTRY dbKerRemote(HWND, UINT, WPARAM, LPARAM);
/*
VOID initDlgKerRemote();
VOID dlgCommandKerRemote();
*/

/*** MDMUTIL.C ***/
BOOL mdmConnect();
VOID modemReset();
VOID modemSendBreak(INT);
INT modemBytes();
/* BOOL modemAvail(); */
BYTE getMdmChar(BOOL);                       /* mbbx 1.06A: ics new xlate */
BOOL getRcvChar(BYTE *, BYTE);
BOOL waitRcvChar(BYTE *, WORD, BYTE,BYTE, ...);
BOOL modemRd(BYTE *);                        /* obsolete !!! */
BOOL modemRdy();                             /* obsolete !!! */
BOOL modemWt(BYTE *);                        /* obsolete !!! */
VOID flushRBuff();
BOOL modemWrite(LPSTR, INT);
VOID modemWr(BYTE);
VOID termStr(STRING *, INT, BOOL);

/*** YTERM.C ***/
VOID yTermRcvBlock();
VOID yTermEnd();
VOID yTermCancel();
VOID yTermInit();
VOID blk43Decode();
VOID yTermPutStr();
INT yTermBlkEncode();
VOID ytSendCRC();
VOID yTermResponse();
VOID yTermBegin();
VOID yTermCheckSum();
VOID hostReady();
BYTE hostAck();

/*** DCUTIL1.C ***/
VOID setDefaults();
BOOL clearTermBuffer(UINT prevLines,UINT  bufLines,UINT  lineWidth);      /* mbbx 2.00.03 ... */
BOOL initTermBuffer(WORD bufLines, WORD lineWidth,BOOL bReset);
VOID resetTermBuffer(VOID);

/*** DCUTIL2.C ***/
VOID showTerminal(BOOL, BOOL);               /* mbbx 2.00.08: term init */
VOID showHidedbmyControls(BOOL, BOOL);       /* mbbx 2.00 */

/*** DCUTIL3.C ***/
VOID buildTermFont();
VOID clearFontCache();

// VOID lsetmem(LPSTR, BYTE, WORD);

VOID getFileDate(DOSTIME *, INT);

// VOID lmovmem(LPSTR, LPSTR, WORD);
/*** SCROLL.C ***/
VOID updateTermScrollBars(BOOL);             /* mbbx 2.00.06: jtf display... */
proc scrollTermWindow(INT, INT);
proc scrollTermLine(INT, INT, INT);
VOID scrollBits();
VOID scrollUp(INT, INT, INT);
VOID scrollDown(INT, INT, INT);
VOID pageScroll(INT);
VOID hPageScroll(INT);
VOID trackScroll(INT, INT);

/*** SHOWSTAT.C ***/                         /* mbbx 2.00: xfer ctrls... */
VOID setXferCtrlButton(WORD wCtrlID, WORD wResID);
INT NEAR placeXferCtrl(HWND, INT);
VOID showXferCtrls(WORD fShowCtrls);
HDC NEAR beginXferCtrlUpdate(HWND, RECT *, BOOL);
VOID NEAR setItemText(INT, BYTE *, BOOL);
VOID bSetUp(BYTE *);
VOID showScale();
VOID updateProgress(BOOL);
VOID showBBytes(LONG, BOOL);
VOID showRXFname(BYTE *, INT);
VOID showBErrors(INT);
VOID updateIndicators();




/* mbbx: yterm mods to SNDBFILE.C */
VOID setupFinderInfo();
VOID getFinderInfo();

proc scrollTopPart ();
proc scroll ();

VOID pageFeed ();
VOID paintTerm ();

VOID setFKeyTitles();                        /* mbbx 2.00 ... */
BOOL NEAR testFKeyLevel(INT);
INT NEAR nextFKeyLevel(INT);
VOID setFKeyLevel(INT, BOOL);

VOID doCommand ();
VOID resetEmul ();
VOID openAwindow ();
VOID clearBuffer ();
VOID termAnswer ();
VOID termSpecial ();
VOID clearModes ();
VOID onCursor ();
VOID offCursor ();

VOID putCursor ();

VOID reDrawTermLine ();
VOID toggleCursor ();
VOID doEditMenu ();
VOID scrollText ();
VOID xferFile ();
VOID termSpecial ();
VOID stripLeadingSpaces ();
VOID xferEnd ();
VOID trackScroll ();
VOID scrollBits ();
VOID scrollUp ();
VOID scrollDown ();
VOID pageScroll ();
VOID hPageScroll ();
VOID teScr ();
VOID delay (UINT units, DWORD *endingCount);
VOID setDefaultFonts ();
/* VOID zoomTerm (); */
VOID zoomChild(HWND);
VOID freeItResources ();
VOID updateTimer ();
VOID readDateTime ();
VOID timerAction(BOOL, BOOL);                /* mbbx 1.03: VOID tmrAction(); */
VOID timerToggle(BOOL);                      /* mbbx 1.03: VOID tmrToggle(); */
VOID clipRect ();
//VOID setAttrib ();
VOID getMdmResult ();
VOID saveSelection ();
VOID frameTime ();
VOID loadKeyPadString ();
VOID rectCursor ();
VOID exitSerial ();
VOID errTest ();
VOID newFile ();
VOID clsFile ();
VOID savFile ();
VOID svsFile ();
VOID opnFile ();
VOID getWTitle ();
VOID addExtension();
VOID setWTitle ();
VOID execErr ();
VOID addParen ();
VOID rdErr ();
VOID stripFileExt ();
/* VOID forceExtension();                    mbbx 2.00: defined in FILEOPEN.H */
VOID sndTFile ();
VOID typTFile ();
VOID rcvTFile ();
VOID sndBFile ();
VOID rcvPutFile ();
VOID rcvBFile ();
VOID rcvErr ();
VOID rcvPre ();
VOID showRXFname ();
VOID showScale ();
VOID sndBPre ();
VOID sndBFileErr ();
VOID showBErrors ();
VOID rcvErr ();
VOID rcvBPre ();
VOID showBBytes ();
VOID rxEventLoop ();
VOID rcvAbort ();

VOID getDateTime ();
VOID sec2date ();
VOID date2secs ();
VOID termActivate ();
VOID termDeactivate ();
VOID termSetSelect ();
VOID termClick ();
VOID releasePort ();
VOID dialPhone ();
VOID hangUpPhone ();
VOID waitCall ();
VOID printchar ();
VOID lineFeed ();
VOID endOfPrintJob ();
VOID prAction ();
VOID prSelection ();
VOID xShowLine ();
VOID ansInTalk ();
VOID ansKermit();
VOID selectTermFont ();
VOID  sizeTimerRect ();
VOID  hideTermCursor ();
VOID  showTermCursor ();

BOOL getScrCh ();
BOOL copyTable ();
BOOL myAbort();
BOOL keyPadSequence ();
BOOL getArg ();
BOOL  APIENTRY dbSendFile ();
BOOL  APIENTRY pasClikLoop ();
BOOL  APIENTRY dbSelSavApp ();
INT_PTR APIENTRY dbAbortDlg (HWND  hDlg, UINT  msg, WPARAM wParam, LPARAM lParam);
//BOOL  APIENTRY dbDialing ();
//BOOL  APIENTRY dbmyControls();
BOOL writeFile ();
BOOL myPutFile ();
BOOL getPutFN ();
BOOL newPath ();
BOOL searchFileSpec ();
BOOL checkFilename ();
BOOL isCharLegal ();
BOOL fnErr ();
BOOL fileExist ();
BOOL ldFile ();
BOOL readFile ();
BOOL rdFileErr ();
BOOL  APIENTRY dbStdFN ();
BOOL  APIENTRY dbGetPutFN ();
BOOL  APIENTRY dbTypTFile ();
BOOL  APIENTRY dbRcvTFile ();
BOOL  APIENTRY abortDlgProc (HDC, INT);
BOOL readMacSettings ();
BOOL writeMacSettings ();
BOOL readMacSettings ();
BOOL writeMacSettings ();
//BOOL  APIENTRY dbDialing ();

BOOL rcvPutBFile ();
BOOL getSndTFile ();
BOOL getSndBFile ();
BOOL getSndTFile ();
BOOL startOfPrintJob ();

BYTE *concat ();
// BYTE *getcwd ();
/* this is redefined here, now including the cruntime headers -sdj*/
/* BYTE *strchr (); */
BYTE whichGrpButton ();

INT  valIndex ();
INT  pos ();
INT classifyKey (WORD vrtKey);
INT availSerial ();
INT  testBox ();
INT  sysError ();
INT  wrErr ();

LONG fileSize();

HDC getPort ();

HANDLE macToDOSText ();

/* VOID newHTE ();                           mbbx 2.00.03: old code */
/* VOID crBuffer(int, int);                  mbbx 2.00.03: old code */

/*** DATESTUF.C ***/
VOID date2secs (DOSTIME *, LONG *);






/*were  not defined but called from initcode.c */

BOOL PrintFileInit();
void PrintFileShutDown ();
VOID sizeFkeys(LONG clientSize);
VOID initChildSize(RECT *pRect);
VOID setDefaultAttrib(BOOL bLoad);
VOID initDlgPos(HWND hDlg);
VOID initComDevSelect(HWND hDlg, WORD wListID, BOOL bInit);
BYTE getComDevSelect(HWND hDlg, WORD wListID, BYTE *newDevRef);
BOOL getFileType(BYTE *fileName, BYTE *fileExt);
VOID taskInit();
VOID keyMapInit();
BOOL termInitSetup(HANDLE hPrevInstance);
VOID forceExtension(BYTE *fileName, BYTE *fileExt, BOOL bReplace);
BOOL termFile(BYTE *filePath,BYTE *fileName,BYTE *fileExt,BYTE *title,WORD flags);
VOID sizeTerm(LONG termSize);
VOID keyMapCancel();

/*****************/

/* were not defined but called from winmain.c */

VOID xSndBFile();
VOID xRcvBFile();

/**************/

/* were not defined but called from winmain.c*/

void myDrawIcon(HDC hDC, BOOL bErase);
BOOL termCloseAll(VOID);
void flashIcon(BOOL bInitFlash, BOOL bEndProc);
WORD childZoomStatus(WORD wTest, WORD wSet);
VOID initMenuPopup(WORD menuIndex);
BOOL keyMapTranslate(WPARAM *wParam, LPARAM *lParam, STRING *mapStr);
BOOL fKeyStrBuffer(BYTE *str,WORD  len);
BOOL keyMapSysKey(HWND hWnd, WORD message , WPARAM *wParam, LPARAM lParam); //sdj: AltGr
VOID longToPoint(long sel, POINT *pt);

VOID keyMapKeyProc(HWND hWnd, WORD message, WPARAM wParam, LPARAM lParam); //sdj: AltGr
BOOL termCloseFile(VOID);
VOID hpageScroll(int which);



VOID PrintFileString(LPSTR lpchr,LONG  count, BOOL bCRtoLF);
BOOL PrintFileOn(HANDLE theInstance,HWND theWnd,
LPSTR thePrintName,LPSTR thePrintType,LPSTR thePrintDriver,
LPSTR thePrintPort,BOOL showDialog);
BOOL PrintFileOff();
void PrintFileLineFeed (BOOL nextLine);
void PrintFilePageFeed ();


BOOL termSaveFile(BOOL bGetName);


int testMsg(BYTE *str0, BYTE* str1, BYTE *str2);



VOID xferStopBreak(BOOL bStop);

VOID xferPauseResume(BOOL bPause, BOOL bResume);

void selectFKey(UINT wIDFKey);

BOOL sendKeyInput(BYTE theByte);

VOID sndAbort  ();

int countChildWindows(BOOL bUnzoom);

VOID  stripBlanks (LPBYTE ptr, DWORD *len);

VOID  doFileNew();

VOID  doFileOpen();
VOID  doFileClose();
VOID  doFileSave();
VOID  doFileSaveAs();

VOID  stripControl(STRING *str);
int   TF_ErrProc(WORD errMess, WORD errType,WORD  errCode);


BOOL  XM_RcvFile(WORD rcvStatus);
BOOL  FAR KER_Receive(BOOL bRemoteServer);
VOID  listFontSizes(BYTE *faceName, BYTE *sizeList, int maxSize);

void  updateIcon();
BOOL  XM_SndFile(WORD);
BOOL  FAR KER_Send();
VOID  setAppTitle();


VOID  icsResetTable(WORD icsType);
VOID  rcvFileErr();


/* connector.c needs this fn from wndproc.c */
HWND  dlgGetFocus();

/* initcode.c needs this from connect.c */
BOOL  initConnectors(BOOL bInit);
/* defined in messages.c called from dcutil */
INT   testResMsg(WORD wResID);

/* two famous functions. dont know how this was working in win3.0 -sdj*/
/* these functions have some case problem, called with uppercase B and
   defined with lowercase b in term.c, not changed to Board */

VOID  keyBoardToMouse(INT partCode);

/* this one was called as bSetup and defined as bSetUp() in showstat.c */
VOID  bSetup(BYTE  *str);

void  APIENTRY    nextFlash(HWND hWnd, UINT message, UINT_PTR nIDEvent, DWORD sysTime);
INT_PTR  APIENTRY    dbDialing(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY    dbmyControls(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);

/* rjs - add prototype for the about dialog function */
INT_PTR CALLBACK dbAbout(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\fileopen.h ===
#ifndef NO_MMSYSTEMH
#define NO_MMSYSTEMH
#endif

#include <windows.h> /* added -sdj*/
/*---------------------------------------------------------------------------*/
/* Option Declarations - FileOpen()                                          */
/*---------------------------------------------------------------------------*/

#define FO_GETFILE                  0x0000
#define FO_PUTFILE                  0x0001
#define FO_FILEEXIST                0x0002
#define FO_FORCEEXTENT              0x0004   /* mbbx 2.00: no forced extents */
#define FO_BATCHMODE                0x1000
#define FO_NONDOSFILE               0x2000
#define FO_REMOTEFILE               0x4000
#define FO_GETFILENAME2             0x8000


/*---------------------------------------------------------------------------*/
/* Constant Declarations                                                     */
/*---------------------------------------------------------------------------*/

#define FO_MAXPATHLENGTH            513
#define FO_MAXFILELENGTH            16
#define FO_MAXEXTLENGTH             16


/*---------------------------------------------------------------------------*/
/* Type Declarations                                                         */
/*---------------------------------------------------------------------------*/

#define FILEOPENDATA                struct tagFileOpenData

struct tagFileOpenData
{
   BYTE     file[FO_MAXPATHLENGTH];
   BYTE     file1[FO_MAXFILELENGTH];
   BYTE     file2[FO_MAXPATHLENGTH];         /* must be able to hold PATH */
   BYTE     extent[FO_MAXEXTLENGTH];
   BYTE     title[32];                       /* mbbx 1.10: CUA... */
   WORD     wResID;
   DLGPROC  lpFilter;                        /* mbbx 2.00: new FO hook */
   WORD     wMode;
   INT      nType;                           /* mbbx 1.10: CUA */
};


/*---------------------------------------------------------------------------*/
/* Variable Declarations                                                     */
/*---------------------------------------------------------------------------*/

FILEOPENDATA   *pFOData;


/*---------------------------------------------------------------------------*/
/* Rescource ID Declarations                                                 */
/*---------------------------------------------------------------------------*/

#define FO_STR_ERRCAPTION           0x0300
#define FO_STR_WARNCAPTION          0x0301
#define FO_STR_BADFILENAME          0x0302
#define FO_STR_FILENOTFOUND         0x0303
#define FO_STR_REPLACEFILE          0x0304

#define FO_LBFILE                   0x0000         /* list FILES only */
#define FO_LBDIR                    0xC010         /* list DIRECTORIES only */

#define FO_DBFILEOPEN               601
#define FO_DBFILETYPE               602
#define FO_DBSNDTEXT                603
#define FO_DBSNDFILE                604
#define FO_DBCOMPILE                605      /* mbbx 2.00: auto save DCP */

#define FO_DBFILESAVE               611
#define FO_DBFILEAPPEND             612
#define FO_DBRCVTEXT                613
#define FO_DBRCVFILE                614

#define FO_IDTITLE                  621
#define FO_IDPROMPT                 631
#define FO_IDFILENAME               632
#define FO_IDPROMPT2                633
#define FO_IDFILENAME2              634
#define FO_IDPATH                   635
#define FO_IDFILELIST               641
#define FO_IDDIRLIST                642

#define FO_IDSETTINGS               651
#define FO_IDSCRIPT                 652
#define FO_IDMEMO                   653

#define FO_IDAPPEND                 691
#define FO_IDCTRL                   692
#define FO_IDTABLE                  693
#define FO_IDSNDLF                  694
#define FO_IDSNDNOLF                695


/*---------------------------------------------------------------------------*/
/* Function Prototypes                                                       */
/*---------------------------------------------------------------------------*/

BOOL FileOpen(BYTE *, BYTE *, BYTE *, BYTE *, BYTE *, WORD, DLGPROC, WORD);   /* mbbx 2.00: new FO hook scheme... */
/* BOOL FileOpen(HWND, HANDLE, BYTE *, BYTE *, BYTE *, BYTE *, BYTE *, WORD, WORD); */

INT_PTR APIENTRY dbFileOpen(HWND, UINT, WPARAM, LPARAM);
BOOL NEAR FO_SaveFileName(HWND);             /* mbbx 2.00 */
VOID NEAR FO_SetListItem(HWND, WORD, BOOL);
VOID NEAR FO_NewFilePath(HWND, WORD, BYTE *, BYTE *);
BOOL NEAR FO_AddFileType(BYTE *, BYTE *);
VOID NEAR FO_StripFileType(BYTE *);
BOOL NEAR FO_IsLegalDOSFN(BYTE *);           /* mbbx 2.00: no forced extents... */
BOOL NEAR FO_IsLegalDOSCH(BYTE);
BOOL NEAR FO_IsLegalFN(BYTE *);
INT NEAR FO_ErrProc(WORD, WORD,HWND);
BOOL NEAR FO_SetCtrlFocus(HWND, HWND);

BOOL setPath(BYTE *, BOOL, BYTE *);
BOOL setFilePath(BYTE *);
VOID forceExtension(BYTE *, BYTE *, BOOL);   /* mbbx 2.00: no forced extents... */
BOOL getFileType(BYTE *, BYTE *);


/*---------------------------------------------------------------------------*/

/* mbbx 2.00: new FO hook scheme... */

#ifdef ORGCODE
BOOL  APIENTRY FO_FileOpenType (HWND, WORD, WORD, LONG);   /* mbbx 2.00: CUA */
VOID  APIENTRY FO_SaveSelection(HWND, WORD, WORD, LONG);
VOID  APIENTRY FO_SendTextFile (HWND, WORD, WORD, LONG);
VOID  APIENTRY FO_RcvTextFile  (HWND, WORD, WORD, LONG);
VOID  APIENTRY FO_ScriptCompile(HWND, WORD, WORD, LONG);   /* mbbx 2.00: auto save DCP */
#else
INT_PTR APIENTRY FO_FileOpenType (HWND, UINT, WPARAM, LPARAM);   /* mbbx 2.00: CUA */
INT_PTR APIENTRY FO_SaveSelection(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY FO_SendTextFile (HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY FO_RcvTextFile  (HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY FO_ScriptCompile(HWND, UINT, WPARAM, LPARAM);   /* mbbx 2.00: auto save DCP */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\fileopen.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31 	         TRUE

#include <windows.h>
#include <port1632.h>
#include <dcrc.h>                            /* mbbx 2.00 ... */
#include "commdlg.h"
#include <dynacomm.h>
#include <fileopen.h>
#include "dlgs.h"
#include <direct.h> /* adding this for chdir prototype -sdj*/

/*---------------------------------------------------------------------------*/
/* FileOpen() -                                                        [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR PASCAL PoundToNull(LPSTR str)
{

   while(*str)
   {
      if(*str == '#')
      	*str = 0x00;
      str++;
   }
}

VOID NEAR PASCAL LoadFilterString(HANDLE hInst,WORD ResID,LPSTR szFilter,
	                               INT len,DWORD *FilterIndex)
{

	switch(ResID)
   {
      case FO_DBSNDTEXT:
      case FO_DBRCVTEXT:
	      LoadString(hInst,STR_FILTERALL,
 	      &szFilter[LoadString(hInst,STR_FILTERTXT,szFilter,len)],len);	
         *FilterIndex = 1;
         break;

      case FO_DBSNDFILE:
      case FO_DBRCVFILE:
         LoadString(hInst,STR_FILTERALL,szFilter,len);
	      *FilterIndex = 1;
      break;

      default:
	      LoadString(hInst,STR_FILTERTRM,szFilter,len);
         *FilterIndex = 1;
    }

	 PoundToNull(szFilter);
}


VOID NEAR PASCAL AddDirMod(CHAR *path)
{
	INT len=0;

	while(path[len]){
		if(path[len] == '.')
			return;
		if(++len == (FO_MAXPATHLENGTH-1)){
			*path = 0;
			return;
		}
	}
	path[len] =  '\\';
	path[len+1] = 0;
}




BOOL FileOpen(BYTE *filePath, BYTE *fileName1,BYTE *fileName2, BYTE *fileExt,BYTE * titleText,WORD  wResID,DLGPROC lpFilter, WORD wMode)
{
   BOOL           FileOpen = FALSE;
   // -sdj was unreferenced local var: LPDTA	   saveDTA;
   BYTE           savePath[FO_MAXPATHLENGTH];
   FILEOPENDATA   FOData;
   // -sdj was unreferenced local var: BYTE	   work[80];
   HWND           whichParent;
   CHAR           szFilter[75];		         /* default filter text/spec. for above  */
   CHAR           szFileName[STR255];	      /* Fully qualified name of file         */
   OPENFILENAME   OFN;
   INT            rc;

#ifndef BUGBYPASS
   if (TRUE)
#else
   if(setPath(filePath, FALSE, savePath))
#endif
   {
      setFilePath(fileName1);

      strcpy(FOData.file1, fileName1);
      strcpy(FOData.file2, (fileName2 != NULL) ? fileName2 : NULL_STR);
      strcpy(FOData.extent, fileExt);
      strcpy(FOData.title, (titleText != NULL) ? titleText : NULL_STR);
      FOData.wResID = ((wResID != 0) ? wResID : (!(wMode & FO_PUTFILE) ? FO_DBFILEOPEN : FO_DBFILESAVE));   /* mbbx 1.10: CUA... */
      FOData.lpFilter = lpFilter;
      FOData.wMode = wMode;
      pFOData = &FOData;

      whichParent = GetActiveWindow();
      if ( (whichParent == NULL) || (!IsChild(hItWnd,whichParent)) ) 
         whichParent = hItWnd; /* jtf 3.15 */

      /* OFN structure intialization for common open dialog. 02/19/91*/
      LoadFilterString(hInst,FOData.wResID,szFilter,sizeof(szFilter),&OFN.nFilterIndex);
      szFileName[0] = '\0';

      OFN.lStructSize	    = sizeof(OPENFILENAME);
      OFN.lpstrTitle 	    = NULL;	     /* Address  later to whichever dialog*/
      OFN.lpstrCustomFilter = NULL;
      OFN.nMaxCustFilter    = 0L;
      OFN.lpstrDefExt       = NULL;   /* ?? address later forcing trm. */ 
      OFN.lpstrInitialDir   = NULL;
      OFN.lpstrFile 	       = szFileName;
      OFN.nMaxFile	       = sizeof(szFileName);
      OFN.lpfnHook	       = dbFileOpen;
      OFN.lCustData	       = 0L;
      OFN.lpTemplateName    = MAKEINTRESOURCE(FOData.wResID);
      OFN.hInstance	       = hInst;
      OFN.hwndOwner	       = whichParent;
      OFN.Flags 	          = OFN_HIDEREADONLY|OFN_ENABLETEMPLATE|OFN_ENABLEHOOK;
      OFN.lpstrFileTitle    = NULL;	
      OFN.nMaxFileTitle	    = 0L;	
      OFN.lpstrFilter	    = szFilter;

      if((FOData.wResID == FO_DBFILESAVE) || 
         (FOData.wResID == FO_DBRCVFILE)  || 
         (FOData.wResID == FO_DBRCVTEXT))
      {
        FileOpen = GetSaveFileName(&OFN);
      }
      else
      {
        FileOpen = GetOpenFileName(&OFN);
      }

      if(rc = CommDlgExtendedError())
      {
         testBox(whichParent,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
         FileOpen = FALSE;
      }
	
#ifdef ORGCODE
         _getcwd(filePath);
#else
         _getcwd(filePath,PATHLEN);
#endif

      if(FileOpen)
      {


	 // sdj: the way this code is working right now, terminal
	 // sdj: calls the commdlg fileopen with a dbFileOpen hook
	 // sdj: function which saves FOData.file with just the name
	 // sdj: part of the file, and the called of FileOpen does
	 // sdj: the cat of getcwd with this filename. This is broken
	 // sdj: in case where terminal sets chdir to c:\ and commdlg
	 // sdj: while exiting sets the dir back to where it was so
	 // sdj: instead of c:\boot.ini user views d:\...\boot.ini!
	 // sdj: solution is to set filename1 to FileName part of szfilename
	 // sdj: which is what comdlg gives as a FQN and set filePath to
	 // sdj: the path part of this. it is very unlikely that commdlg
	 // sdj: will return szFileName with no '\\' in it but if strrchr
	 // sdj: fails, stick with the original pathrelated bug!

	 if (strrchr(szFileName,'\\'))
	    {
	    strcpy(fileName1,(strrchr(szFileName,'\\')+1));
	    *(strrchr(szFileName,'\\')) = 0;
	    strcpy(filePath,szFileName);
	    }

	 else{


         switch(FOData.wResID)
	 {
         case FO_DBRCVFILE:
	 case FO_DBRCVTEXT:
	    strcpy(fileName1, FOData.file);
            break;
         case FO_DBFILESAVE:
            strcpy(fileName1, szFileName);
            break;
         default:
	    strcpy(fileName1, FOData.file1);
            break;
	 }/* switch(resID) */
	}// end of if{!strrchr}else{sw:original stuff}

         if(fileName2 != NULL)
            strcpy(fileName2, FOData.file2);

         if(!OFN.nFileExtension)
         {
            if(!strchr(fileName1, '.'))
               strcat(fileName1, ".");
         }
         else if(FOData.wMode & FO_FORCEEXTENT)
         {
            if(strchr(fileExt, '.'))
               strcpy(fileExt, strchr(fileExt, '.') + 1);
            
            if(strchr(fileName1, '.'))
            {
               strcpy(strchr(fileName1, '.') + 1, fileExt);
            }
            else
            {
               strcat(fileName1, ".");
               strcat(fileName1, fileExt);
            }

         }
         else
            strcpy(fileExt, FOData.extent);

         if(wResID == FO_DBFILETYPE)
            FileOpen = FOData.nType;
      }

      setPath(savePath, FALSE, NULL);
   }

   SetFocus(hTermWnd);

   return(FileOpen);
}


/*---------------------------------------------------------------------------*/
/* dbFileOpen() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbFileOpen(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   BOOL  result;
   BYTE  OEMname[STR255];            /* jtf 3.20 */
   BYTE  savePath[STR255]; /* rjs bugs 018 */

   updateTimer();                            /* code specific to DynaComm!!! */

   switch(message)
   {
   case WM_INITDIALOG:
      // use the OFN stuct to set this

      if(*(pFOData->title) != 0)
         SetWindowText(hDlg, pFOData->title); /* jtf terminal */

      SendDlgItemMessage(hDlg, edt1, EM_LIMITTEXT, FO_MAXPATHLENGTH, 0L);
      SendDlgItemMessage(hDlg, edt1, EM_SETSEL, GET_EM_SETSEL_MPS(0, MAKELONG(0,32767)));

      if(pFOData->wResID == FO_DBFILETYPE)   /* mbbx 1.10: CUA... */
         (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);  /* mbbx 2.00: new FO hook scheme... */

      switch(pFOData->wResID)                /* mbbx 2.00: new FO hook scheme... */
      {
      case FO_DBFILETYPE:
         break;

      case FO_DBSNDFILE:
      case FO_DBRCVFILE:
         ShowWindow(GetDlgItem(hDlg, FO_IDPROMPT2), SW_HIDE);
         ShowWindow(GetDlgItem(hDlg, FO_IDFILENAME2), SW_HIDE);
         SendDlgItemMessage(hDlg, FO_IDFILENAME2, EM_LIMITTEXT, FO_MAXPATHLENGTH, 0L);
         break;

      default:
         if(pFOData->lpFilter != NULL)
            (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);
         break;
      }

      if((pFOData->wMode & FO_PUTFILE) && !FO_SaveFileName(hDlg))    /* mbbx 2.00 ... */
      {
         SetDlgItemText(hDlg, edt1, pFOData->file1);
         strcpy(pFOData->title, pFOData->file1);
      }
      if(pFOData->lpFilter != NULL)       /* jtf 3.22 */
          (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);
      return(TRUE);     /* Bug 7115, let dlgmgr set focus.  clarkc */

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
      {
         HWND focus = GetFocus();	

         if(focus == GetDlgItem(hDlg,edt1) || 
            focus == GetDlgItem(hDlg,lst1) ||
		      focus == GetDlgItem(hDlg,IDOK)) 
         {
            if((pFOData->wMode & FO_GETFILENAME2) && (pFOData->wMode & FO_NONDOSFILE))
            {
               if(!GetDlgItemText(hDlg, edt1, pFOData->file2, FO_MAXPATHLENGTH))
                  pFOData->wMode &= ~FO_GETFILENAME2;
               if(!GetDlgItemText(hDlg, FO_IDFILENAME2, pFOData->file, FO_MAXPATHLENGTH))
                  strcpy(pFOData->file, (pFOData->wMode & FO_GETFILENAME2) ? pFOData->file2 : pFOData->file1);
            }
            else
            { 
               if(!GetDlgItemText(hDlg, edt1, pFOData->file, FO_MAXPATHLENGTH))
                  strcpy(pFOData->file, pFOData->file1);
               if(pFOData->wMode & FO_GETFILENAME2)
                  if(!GetDlgItemText(hDlg, FO_IDFILENAME2, pFOData->file2, FO_MAXPATHLENGTH))
                     pFOData->wMode &= ~FO_GETFILENAME2;
            }

            result = TRUE;
            break;	      
         }
         else
            return(FALSE);
      }

      case IDCANCEL:
         *(pFOData->file2) = 0;
         pFOData->wMode &= ~FO_GETFILENAME2;
         result = FALSE;
         break;

      case edt1:
         if(GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
         {
            if(!((pFOData->wMode & FO_BATCHMODE) && (pFOData->wMode & FO_PUTFILE)))    /* mbbx 1.01: ymodem */
               EnableWindow(GetDlgItem(hDlg, IDOK), (BOOL)SendDlgItemMessage(hDlg, edt1, WM_GETTEXTLENGTH, 0, 0L));

            if(pFOData->wMode & FO_GETFILENAME2)
            {
               *(pFOData->file2) = 0;
               pFOData->wMode &= ~FO_GETFILENAME2;
               ShowWindow(GetDlgItem(hDlg, FO_IDPROMPT2), SW_HIDE);
               ShowWindow(GetDlgItem(hDlg, FO_IDFILENAME2), SW_HIDE);
            } 

            if(pFOData->lpFilter != NULL)    /* mbbx 2.00: new FO hook scheme... */
               (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);
         }
         return(FALSE);

      case lst1:
         if(GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
         {
            FO_SetListItem(hDlg, lst1, FALSE);
            if(pFOData->lpFilter != NULL)    /* mbbx 2.00: new FO hook scheme... */
               (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);
            return(FALSE);
         }
         result = TRUE;
         if(GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                  break;
         return(FALSE);
         break;

      default:
         switch(pFOData->wResID)             /* mbbx 2.00: new FO hook scheme... */
         {
         case FO_DBFILETYPE:                 /* mbbx 1.10: CUA... */
			/* BUG BUG, what does this call, wParam/lParam may need fixing!*/
            if(!(*(pFOData->lpFilter)) (hDlg, message, wParam, lParam))
            {
               SetDlgItemText(hDlg, FO_IDFILENAME, pFOData->file1);
            }
            break;

         default:
            if(pFOData->lpFilter != NULL)
               (*(pFOData->lpFilter)) (hDlg, message, wParam, lParam);
            break;
         }

         return(FALSE);
      }
      break;

   default:
      return(FALSE);
   }

   if(result)
   {
      if(!setPath(pFOData->file, TRUE, savePath))
      {
         FO_ErrProc(STRDRIVEDIR, MB_OK | MB_ICONHAND, hDlg);
         return(FO_SetCtrlFocus(hDlg, GetFocus()));
      }

      if(!((pFOData->wMode & FO_BATCHMODE) && (GetKeyState(VK_CONTROL) & 0x8000)))  /* mbbx 1.01: ymodem */
      {
         AnsiUpper(pFOData->file);
         strcpy(pFOData->file1, pFOData->file);

         if(FO_AddFileType(pFOData->file, pFOData->extent))
      	 	return(FALSE);

         if(!FO_IsLegalDOSFN(pFOData->file))    /* mbbx 2.00: no forced extents... */
         {
            if(((pFOData->wMode & FO_NONDOSFILE) && (pFOData->wMode & FO_GETFILENAME2)) || 
               (!(pFOData->wMode & FO_NONDOSFILE) && !(pFOData->wMode & FO_GETFILENAME2)) || 
               !FO_IsLegalFN(pFOData->file))
            {
               FO_ErrProc(FO_STR_BADFILENAME, MB_OK | MB_ICONHAND,hDlg);
               return(FO_SetCtrlFocus(hDlg, GetFocus()));
            }
            else if(!(pFOData->wMode & FO_GETFILENAME2))
            {
               pFOData->wMode |= FO_GETFILENAME2;
               ShowWindow(GetDlgItem(hDlg, FO_IDPROMPT2), SW_SHOW);
               ShowWindow(GetDlgItem(hDlg, FO_IDFILENAME2), SW_SHOW);
               return(FO_SetCtrlFocus(hDlg, GetFocus()));
            }
         }

         if(!getFileType(pFOData->file, pFOData->extent))   /* mbbx 2.00 ... */
         {
            forceExtension(pFOData->file, pFOData->extent+2, FALSE);    /* mbbx 2.00: no forced extents... */
         }


         // JYF -- replace these two lines with the below if() to remove the use of AnsiToOem()
         //
         //AnsiToOem(pFOData->file, (LPSTR) OEMname); /* jtf 3.20 */
         //if((pFOData->wMode & FO_FILEEXIST) && !fileExist(OEMname)) /* jtf 3.20 */

         if ((pFOData->wMode & FO_FILEEXIST) && !fileExist(pFOData->file))
         {
/* rjs bugs 018 */
            if(!(pFOData->wMode & FO_PUTFILE))  /* mbbx 1.10: CUA... */
               DlgDirList(hDlg, pFOData->file, lst1, 0, FO_LBFILE);
            else
               strcpy(pFOData->file, pFOData->title);
            SetDlgItemText(hDlg, ((pFOData->wMode & FO_GETFILENAME2) && (pFOData->wMode & FO_NONDOSFILE)) ? 
                           FO_IDFILENAME2 : FO_IDFILENAME, pFOData->file);
            setFilePath(savePath);
/* end of rjs bugs 018 */
            FO_ErrProc(FO_STR_FILENOTFOUND, MB_OK | MB_ICONHAND,hDlg);
            return(FO_SetCtrlFocus(hDlg, GetFocus()));
         }

         if((pFOData->wMode & FO_REMOTEFILE) && !(pFOData->wMode & FO_GETFILENAME2))
         {
            pFOData->wMode |= FO_GETFILENAME2;
            SetDlgItemText(hDlg, FO_IDFILENAME2, pFOData->file);
            ShowWindow(GetDlgItem(hDlg, FO_IDPROMPT2), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, FO_IDFILENAME2), SW_SHOW);
            return(FO_SetCtrlFocus(hDlg, GetDlgItem(hDlg, FO_IDFILENAME2)));
         } 


         // JYF -- replace these two lines with following if() to remove the use of AnsiToOem()
         //
         //AnsiToOem(pFOData->file, (LPSTR) OEMname); /* jtf 3.20 */
         //if(((pFOData->wMode & (FO_PUTFILE | FO_FILEEXIST)) == FO_PUTFILE) && fileExist(OEMname))  /* jtf 3.20 */

         if (((pFOData->wMode & (FO_PUTFILE | FO_FILEEXIST)) == FO_PUTFILE) && fileExist(pFOData->file))
         {
            if(FO_ErrProc(FO_STR_REPLACEFILE, MB_YESNO | MB_ICONEXCLAMATION,hDlg) == IDNO)
               return(FO_SetCtrlFocus(hDlg, GetFocus()));
         }
      }

      AnsiUpper(pFOData->file);      /* mbbx 2.00: new FO hook scheme... */
      strcpy(pFOData->file1, pFOData->file);
      AnsiUpper(pFOData->file2);
   }

   if(pFOData->lpFilter != NULL)             /* mbbx 2.00: new FO hook scheme... */
      (*(pFOData->lpFilter)) (hDlg, WM_NULL, result, 0L);

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* FO_SaveFileName() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR FO_SaveFileName(HWND  hDlg)
{
   register BYTE  *pch;

   GetDlgItemText(hDlg, ((pFOData->wMode & FO_GETFILENAME2) && (pFOData->wMode & FO_NONDOSFILE)) ? 
                  FO_IDFILENAME2 : edt1, pFOData->file, 32);

   for(pch = pFOData->file; *pch != 0; pch += 1)
      if((*pch == '*') || (*pch == '?') || (*pch == '\\') || (*pch == ':'))
         return(FALSE);

   strcpy(pFOData->title, pFOData->file);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* FO_SetListItem() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR FO_SetListItem(HWND hDlg,WORD  wCtrlID,BOOL bSetSel)
{
   if(bSetSel)
      SendDlgItemMessage(hDlg, wCtrlID, LB_SETCURSEL, 0, 0L);


   if(SendDlgItemMessage(hDlg, wCtrlID, LB_GETCURSEL, 0, 0L) != LB_ERR)
   {
      MDlgDirSelect(hDlg, pFOData->file, FO_MAXFILELENGTH, wCtrlID);

      if(wCtrlID == lst2)
      {
         FO_NewFilePath(hDlg, ((pFOData->wMode & FO_GETFILENAME2) && (pFOData->wMode & FO_NONDOSFILE)) ? 
                        FO_IDFILENAME2 : edt1, pFOData->file, pFOData->extent);
      }

      SetDlgItemText(hDlg, ((pFOData->wMode & FO_GETFILENAME2) && (pFOData->wMode & FO_NONDOSFILE)) ? 
                     FO_IDFILENAME2 : edt1, pFOData->file);
   }
}


/*---------------------------------------------------------------------------*/
/* FO_NewFilePath() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR FO_NewFilePath(HWND hDlg, WORD wCtrlID,BYTE *fileName,BYTE *fileExt)
{
   register BYTE  *pch;
   BOOL           bWild;
   BYTE           tempName[FO_MAXPATHLENGTH];

   GetDlgItemText(hDlg, wCtrlID, tempName, FO_MAXPATHLENGTH);

   pch = tempName+(strlen(tempName)-1);
   bWild = ((*pch == '*') || (*pch == ':'));

   while(pch > tempName)
   {
      pch--;
      if((*pch == '*') || (*pch == '?'))
         bWild = TRUE;
      if((*pch == '\\') || (*pch == ':'))
      {
         pch++;
         break;
      }
   }

   if(bWild)
      strcpy(fileName+strlen(fileName), pch);
   else
      strcpy(fileName+strlen(fileName), fileExt+1);
}


/*---------------------------------------------------------------------------*/
/* FO_AddFileType() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR FO_AddFileType(BYTE  *fileName, BYTE  *fileExt)
{
   register BYTE  *pch;
   INT            j;
   BOOL           bWild;

   if((pch = fileName+strlen(fileName)) == fileName)
      j = 1;
   else if((pch == fileName+2) && (fileName[0] == '.') && (fileName[1] == '.'))
      j = 0;
   else
   {
      bWild = FALSE;                         /* mbbx 2.00: no forced extents... */
      while(--pch >= fileName)
      {
         if((*pch == '*') || (*pch == '?'))
         {
            bWild = TRUE;
            break;
         }
      }

      if(getFileType(fileName, fileExt))
         return(bWild);

      pch = fileName+strlen(fileName);
      j = ((*(pch-1) == '\\') ? 1 : (bWild ? 2 : 0));
   }

   //sdj: if the extention is "\*.*" which it would be if someone is doing
   //sdj: recvfile open with "test" as name, why add \*.* to test?
   //sdj: it  is ok to do this for open/save/saveas where you can force .trm
   //sdj: not not in other cases of opening the file

   if (*fileExt == '\\' && *(fileExt+1) == '*' && *(fileExt+2) == '.')
      {
      return FALSE;
      }

   strcpy(pch, fileExt+j);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* FO_StripFileType() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR FO_StripFileType(BYTE  *fileName)
{
   register BYTE  *pch;

   for(pch = fileName+(strlen(fileName)-1); pch > fileName; pch--)
   {
      if(*pch == '\\')
      {
         *pch = 0;
         break;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* FO_IsLegalDOSFN() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

#define FO_MAXDOSFILELEN	    FO_MAXFILELENGTH //-sdj bug#4587 fix
// -sdj this was 8 to check for dosfilename length. with ntfs filenames
// -sdj being >8 this test used to fail. made maxdosfilelen to fo_maxfilelength
// -sdj which is 16 at present. This will let users use prefix name upto
// -sdj 16 chars, but still force them to have .trm extension, AND by
// -sdj restricting the name to FO_MAXFILELENGTH, ensure that no other
// -sdj global buffer overflows (most of the buffers use this define)
// -sdj eventually, right solution is to set fo_maxfilelength to ntfs max
// -sdj name, but this is an intermediate solution which is safe, and still
// -sdj allow users upto 16 chars of trmfilenames.
// -sdj along with this change the other change needed is to increase
// -sdj the termData element sizes to > 12 which was a pain! this define
// -sdj in dynacomm.h is increased to 32 for the time being.


#define FO_MAXDOSEXTLEN             3

BOOL NEAR FO_IsLegalDOSFN(BYTE  *fileName)
{
   register INT   i;
   INT            j;

   for(i = 0; fileName[i] == ' '; i++);
   if(i > 0)
      strcpy(fileName, fileName+i);

   for(i = 0; fileName[i] != 0; i++)
   {
      if(fileName[i] == '.')
      {
         for(j = 1; fileName[i+j] != 0; j++)
         {
            if((j > FO_MAXDOSEXTLEN) || !FO_IsLegalDOSCH(fileName[i+j]) || (fileName[i+j]=='.') ) /* jtf 3.31 */
               return(FALSE);
         }

         break;
      }

      if((i >= FO_MAXDOSFILELEN) || !FO_IsLegalDOSCH(fileName[i]))
	 return(FALSE);
   }

   return(i != 0);
}


/*---------------------------------------------------------------------------*/
/* FO_IsLegalDOSCH() -                                                       */
/*---------------------------------------------------------------------------*/

#define FO_NONDOSFNCHARS            "\\/[]:|<>+=;,\""

BOOL NEAR FO_IsLegalDOSCH(BYTE ch)
{
   register BYTE  *pch;

   if(ch <= ' ')
      return(FALSE);

   for(pch = FO_NONDOSFNCHARS; *pch != '\0'; pch++)
   {
      if(*pch == ch)
         return(FALSE);
   }

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* FO_IsLegalFN() -                                                    [scf] */
/*---------------------------------------------------------------------------*/

BOOL NEAR FO_IsLegalFN(BYTE  *fileName)
{
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* FO_ErrProc() -                                                            */
/*---------------------------------------------------------------------------*/

INT NEAR FO_ErrProc(WORD errMess, WORD errType, HWND hDlg)
{
   BYTE temp1[STR255];
   BYTE temp2[STR255];
   GetWindowText(hItWnd, temp1, 254);    /* mbbx 2.00: new FO hook scheme... */
   sscanf(temp1, "%s", temp2);
   LoadString(hInst, (errType & MB_ICONHAND) ? FO_STR_ERRCAPTION : FO_STR_WARNCAPTION, temp1, 80);
   strcpy(temp2+strlen(temp2), temp1);
   LoadString(hInst, errMess, temp1, 254);

   MessageBeep(0);
   return(MessageBox(hDlg, temp1, temp2, errType)); /* jtf 3.14 */
}


/*---------------------------------------------------------------------------*/
/* FO_SetCtrlFocus() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR FO_SetCtrlFocus(HWND  hDlg, HWND  hCtrl)
{
   if(hCtrl == NULL)                         /* mbbx 2.00 ... */
      hCtrl = GetDlgItem(hDlg, (pFOData->wMode & FO_GETFILENAME2) ? FO_IDFILENAME2 : edt1);

#ifdef ORGCODE
   switch(GetWindowWord(hCtrl, GWW_ID))
#else
   switch(GetWindowLong(hCtrl, GWL_ID))
#endif
   {
   case edt1:
   case FO_IDFILENAME2:
      SendMessage(hCtrl, EM_SETSEL, GET_EM_SETSEL_MPS(0, 0x7FFF));
      break;

   case lst2:
      break;

   case lst1:
      if(SendMessage(hCtrl, LB_GETCURSEL, 0, 0L) != LB_ERR)
         break;

   case IDOK:
      if(pFOData->wMode & FO_PUTFILE)
      {
         hCtrl = GetDlgItem(hDlg, (pFOData->wMode & FO_GETFILENAME2) ? FO_IDFILENAME2 : edt1);
         SendMessage(hCtrl, EM_SETSEL, GET_EM_SETSEL_MPS(0, 0x7FFF));
      }
      else
      {
         hCtrl = GetDlgItem(hDlg, lst1);
         if(SendMessage(hCtrl, LB_GETCOUNT, 0, 0L) > 0)
            FO_SetListItem(hDlg, lst1, TRUE);
         else
            hCtrl = GetDlgItem(hDlg, lst2);   /* mbbx 1.10: CUA... */
      }
      break;
   }

   SetFocus(hCtrl);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* setPath() -                                                         [mbb] */
/*---------------------------------------------------------------------------*/

BOOL setPath(BYTE  *newPath, BOOL  bFileName, BYTE  *oldPath)
{
   BYTE  work[FO_MAXPATHLENGTH];

DEBOUT("Enter setPath: with newpath=%lx\n",newPath);
DEBOUT("      setPath: with bFileName=%lx\n",bFileName);
DEBOUT("      setPath: with oldPath=%lx\n",oldPath);

   if(oldPath)
#ifdef ORGCODE
{      _getcwd(oldPath); }
#else
      {
      _getcwd(oldPath,PATHLEN);
DEBOUT("setPath: getcwd returned %s\n",oldPath);
      }
#endif

   if(bFileName)
   {
      if(!setFilePath(newPath)){
DEBOUT("setPath: setFilePath(newPath) returned 0, calling sFP(%lx) and ret FALSE\n",oldPath);
      	 setFilePath(oldPath);
         return(FALSE);
      }
   }
   else
   {
      strcpy(work, newPath);
      DEBOUT("setPath: bFil=0,call setfp and chdir with work as %s\n",work);
      if(!setFilePath(work) || ((work[0] != 0) && (_chdir(work) == -1))){
DEBOUT("setPath: setFP(work) ret0||somethingelse, calling sFP(%lx) and ret FALSE\n",oldPath);
	 setFilePath(oldPath);
         return(FALSE);
      }
   }

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* setFilePath() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BOOL setFilePath(BYTE  *fileName)
{
   INT   ndx;
   BYTE  temp[FO_MAXPATHLENGTH];
   //sdj: just added to debug if chdir is working BYTE	tmpgetcwd[PATHLEN];

DEBOUT("Enter setFilePath with filename=%lx\n",fileName);

#ifdef ORGCODE
#else
if (!fileName)
{
   DEBOUT("setFilePath: HACK %s\n","called with 0 as filename");
   DEBOUT("setFilePath: HACK %s\n","setting chdir to c:\\nt");
   _chdir("C:\\NT");
   return TRUE;
}
#endif

   ndx = strlen(fileName);

#ifdef ORGCODE
   if((ndx >= 2) && (fileName[1] == ':'))    /* mbbx 2.00 ... */
   {
      if(fileName[0] > 'Z')
         fileName[0] -= ' ';
      if(!setdrive(fileName[0]))
         return(FALSE);

      strcpy(fileName, fileName+2);
      ndx -= 2;                              /* mbbx 2.00 */
   }

#else
/* in NT there is no concept of currentdrive AND currentWorkDir -sdj
   so dont do any setdrive, and keep the fileName as a fully    -sdj
   qualified path name including the drive letter               -sdj*/
#endif

   while(--ndx >= 0)                         /* mbbx 2.00 ... */
   {
      if(fileName[ndx] == '\\')
         break;
   }

   if(ndx >= 0)
   {
// sdj: 11may93: FileOpen
      strcpy(temp, fileName+ndx+1);

      if(ndx == 0)
	 ndx += 1;

      fileName[ndx] = '\0';

// -sdj fix for readcmdline not opening .trm file 03jun92
//
// if filename was c:\scratch\foo.trm, do chdir(c:\) not chdir(c:)
// if chdir(c:) is done,later getcwd will not give c:\ but something else

   if (fileName[ndx-1] == ':')
      {
      fileName[ndx] = '\\';
      fileName[ndx+1] = '\0';
      }

// end of fix

      if(_chdir(fileName) == -1)
         return(FALSE);

      //getcwd(tmpgetcwd,PATHLEN);

      strcpy(fileName, temp);
   }

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* forceExtension() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID forceExtension(BYTE  *fileName, BYTE  *fileExt, BOOL  bReplace)
{
   register BYTE  *pch;
   WORD           len;

   for(pch = fileName+((len = strlen(fileName))-1); pch > fileName; pch -= 1)
   {
      if((*pch == '.') || (*pch == '\\'))
         break;
   }

   if((pch <= fileName) || (*pch != '.'))
      pch = fileName + len;
   else if(!bReplace)
      return;

   strcpy(pch, fileExt);

   while(*(++pch) != 0)
      if((*pch == '*') || (*pch == '?'))
      {
         *pch = 0;
         break;
      }
}


/*---------------------------------------------------------------------------*/
/* getFileType() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BOOL getFileType(BYTE  *fileName, BYTE  *fileExt)
{
   register BYTE  *pch;

   for(pch = fileName+(strlen(fileName)-1); pch > fileName; pch -= 1)
   {
      if(*pch == '.')
      {
         AnsiUpper(pch);
         forceExtension(fileExt, pch, TRUE);    /* mbbx 2.00: no forced extents */
         return(TRUE);
      }
      else if(*pch == '\\')
         break;
   }

   return(FALSE);
}

#ifdef ORGCODE
#else

BOOL   fileExist(LPSTR lpfilename)
{
   HANDLE hFile;
   CHAR   chCurDir[FO_MAXPATHLENGTH+1];
   DWORD  dwRc;

   dwRc = GetCurrentDirectory(FO_MAXPATHLENGTH,chCurDir);

   DEBOUT("Rc of getcdir = %lx\n",dwRc);
   DEBOUT("Current Dir in which file is being opened=%s\n",chCurDir);
   DEBOUT("Existence being checked for the file=%s\n",lpfilename);

   hFile = CreateFile(lpfilename,
                      GENERIC_READ,            /* no access desired please */
                      FILE_SHARE_READ|FILE_SHARE_WRITE,     /* dont be greedy */
                      NULL,                   /* no security */
                      OPEN_EXISTING,          /* open only if existing */
                      FILE_ATTRIBUTE_NORMAL,  /* who cares what attr it is */
                      NULL);                  /* why do we need template here */

   if( (hFile == (HANDLE)-1) || (hFile == NULL) )
   {
      /* cant open this one, so return false, looks like doesnt exist */
      DEBOUT("fileExist FALSE: %s does not exit\n",lpfilename);
      return FALSE;
   }

   DEBOUT("fileExist TRUE: %s does exit\n",lpfilename);

   CloseHandle(hFile);
   return TRUE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\icon.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE
#include <windows.h>
#include "port1632.h"
#include "dynacomm.h"


#define ID_FLASHEVENT    1
#define FLASH_ELAPSE     450

/*****************************************************************************/
/* nextFlash() -                                                             */
/*****************************************************************************/
void  APIENTRY nextFlash(HWND  hWnd, UINT  message, UINT_PTR nIDEvent, DWORD sysTime)
{
   RECT  rect;
   HDC   hDC;

   rect.left   = 0;
   rect.top    = 0;
   rect.right  = 16*icon.dx;
   rect.bottom = 16*icon.dy;
   InvertRect(hDC = GetDC(hWnd), &rect);
   ReleaseDC(hWnd, hDC);
}

/*****************************************************************************/
/* myDrawIcon() -                                                            */
/*****************************************************************************/

void myDrawIcon(HDC hDC, BOOL bErase)
{
   INT          i, x, y;
   RECT         rect;

   DrawIcon(hDC, 0, 0, icon.hIcon);

   if((progress > 0) && !icon.flash)
   {
      i = progress-1;
      y = i/16;
      x = i%16;

      rect.left   = 0;
      rect.top    = 0;
      rect.right  = 16*icon.dx;
      if(x < 16-1)
         rect.bottom = y*icon.dy;
      else
         rect.bottom = (y+1)*icon.dy;
      InvertRect(hDC, &rect);

      if(x < 16-1)
      {
         rect.left   = 0;
         rect.top    = y*icon.dy;
         rect.right  = (x+1)*icon.dx;
         rect.bottom = (y+1)*icon.dy;
         InvertRect(hDC, &rect);
      }

      icon.last = progress;
   }
}


/*****************************************************************************/
/* updateIcon()                                                              */
/*****************************************************************************/

void updateIcon()
{
   INT          i, x, y;
   HDC          hDC;
   RECT         rect;

   UpdateWindow(hItWnd); /* jtf 3.20 */
   hDC = GetDC(hItWnd);

   i = icon.last;
   y = i / 16;
   x = i % 16;

   while(i < progress)
   {
      rect.left   = x*icon.dx;
      rect.top    = y*icon.dy;
      rect.right  = (x+1)*icon.dx;
      rect.bottom = (y+1)*icon.dy;
      InvertRect(hDC, &rect);

      i++;
      if(x < 16-1)
         x++;
      else
      {
         x = 0;
         if(y < 16-1)
            y++;
         else
            y = 0;
      }
   }

   icon.last = progress;

   ReleaseDC(hItWnd, hDC);
}


/*****************************************************************************/
/* flashIcon() -                                                             */
/*****************************************************************************/

void flashIcon(BOOL  bInitFlash, BOOL  bEndProc)
{
   HDC   hDC;

   if(bEndProc)
   {
      progress = 0;
      icon.last = 0;
   }
   if (IsIconic (hItWnd))
   {
      if(icon.flash = bInitFlash)
         SetTimer(hItWnd, ID_FLASHEVENT, FLASH_ELAPSE, nextFlash);
      else
         KillTimer(hItWnd, ID_FLASHEVENT);
      
      myDrawIcon(hDC = GetDC(hItWnd), TRUE);
      ReleaseDC(hItWnd, hDC);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\initcode.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31

#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "video.h"
#include <stdlib.h>       /* adding for _searchenv and exit crt -sdj*/


VOID NEAR PASCAL DestroyWindows()
{
   if(hdbmyControls)
      DestroyWindow(hdbmyControls);
   if(hdbXferCtrls)
      DestroyWindow(hdbXferCtrls);
   if(hTermWnd)
      DestroyWindow(hTermWnd);
}

/*---------------------------------------------------------------------------*/
/* WinMain() - entry point from Windows                                [mbb] */
/*---------------------------------------------------------------------------*/

int APIENTRY WinMain(HANDLE hInst, HANDLE hPrevInst, LPSTR lpCmdLine, INT nCmdShow)
{
   CHAR errmsg[115],caption[18];
   VOID (APIENTRY *lpfnRegisterPenApp)(WORD, BOOL) = NULL;

   readDateTime(startTimer);      
   trmParams.comDevRef = ITMNOCOM;

   if(!initConnectors(TRUE))      
      return (FALSE);

   /* Added 02/2591 w-dougw  check that all windows are created. */
   if(!initWindows(hInstance, hPrevInstance, cmdShow))
   {
      LoadString(hInstance,STR_ERRCAPTION,caption,sizeof(caption));
      LoadString(hInstance,STR_OUTOFMEMORY,errmsg,79);
      MessageBox(NULL,errmsg,caption,MB_ICONHAND|MB_SYSTEMMODAL);
      return(FALSE);
   }
   initDialogs();
   if(!setup())
   {
      LoadString(hInstance,STR_ERRCAPTION,caption,sizeof(caption));
      LoadString(hInstance,STR_OUTOFMEMORY,errmsg,79);
      MessageBox(NULL,errmsg,caption,MB_ICONHAND|MB_SYSTEMMODAL);
      return(FALSE);  
   }
   DEBOUT("Calling: %s\n","readCmdLine()");
   readCmdLine(lpszCmdLine);
   DEBOUT("Outof: %s\n","readCmdLine()");

   DEBOUT("Calling: %s\n","PrintFileInit()");
   PrintFileInit(); /* jtfterm */
   DEBOUT("Outof: %s\n","PrintFileInit()");

   /* Register as a good little pen-windows app
    */
   /* NOTE**** have to confirm that this is the way to go GetSystemMet RC-sdj*/
   /* added typecasting of (HANDLE) to param 1 */
   if (lpfnRegisterPenApp = GetProcAddress((HANDLE)GetSystemMetrics(SM_PENWINDOWS),
         "RegisterPenApp"))
       (*lpfnRegisterPenApp)(1, TRUE);

   DEBOUT("Calling: %s\n","mainProcess()");
   mainProcess();                            /* now load _WINMAIN segment */
   DEBOUT("Outof: %s\n","mainProcess()");

   /* Make sure to de-register if you register
    */
   if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)(1, FALSE);

   PrintFileShutDown(); /* jtfterm */

   DestroyWindow(hdbXferCtrls);        /* rjs swat */
   DestroyWindow(hdbmyControls);       /* jtf 3.33 */
   DestroyWindow(hItWnd);              /* rjs swat */

   freeItResources();

   exit(msg.wParam);
//   ExitProcess((DWORD)msg.wParam);  should this be used instead of exit()?-sdj
}



/*---------------------------------------------------------------------------*/
/* initWndClass() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL initWndClass()
{
   WNDCLASS    wndClass;

   wndClass.style          = CS_HREDRAW | CS_VREDRAW;
   wndClass.lpfnWndProc    = DC_WndProc;
   wndClass.cbClsExtra     = 0;
   wndClass.cbWndExtra     = 0;
   wndClass.hInstance      = hInst;
   wndClass.hIcon          = (HICON) NULL; 
   wndClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wndClass.hbrBackground  = (HBRUSH)(COLOR_BACKGROUND+1);
   wndClass.lpszMenuName   = (LPSTR) szAppName_private;
   wndClass.lpszClassName  = (LPSTR) szAppName_private;

   if(!RegisterClass((LPWNDCLASS) &wndClass))   /* register DYNACOMM class */
      return(FALSE);

   wndClass.style          = CS_DBLCLKS; /* jtf 3.21 | CS_HREDRAW | CS_VREDRAW; */
   wndClass.lpfnWndProc    = TF_WndProc;
   wndClass.hIcon          = (HICON) NULL;
   wndClass.hCursor        = LoadCursor(NULL, IDC_IBEAM);
   wndClass.hbrBackground  = (HBRUSH) NULL;
   wndClass.lpszMenuName   = (LPSTR) NULL;
   wndClass.lpszClassName  = (LPSTR) DC_WNDCLASS;

   if(!RegisterClass((LPWNDCLASS) &wndClass))   /* register TERMINAL class */
      return(FALSE);

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* initPort () - Initialize hTE text rectangles  and init thePort            */
/* thePort is always 0 or an active DC of hTermWnd                           */
/* portLocks is count of number of un'releasePort'ed getPort calls           */

extern BOOL insertionPoint;

VOID initPort ()
{
   insertionPoint = TRUE;
   thePort   = 0;
   portLocks = 0;
   hTE.active = TRUE;
   hTE.selStart = hTE.selEnd = MAXROWCOL;

   /* Added 02/22/91 for win 3.1 common dialog interface */
   hDevNames = NULL;
   hDevMode  = NULL;
}


/*---------------------------------------------------------------------------*/
/* initIcon()                                                                */
/*---------------------------------------------------------------------------*/

VOID  APIENTRY nextFlash();

VOID initIcon()
{
   CHAR  temp[10];

   icon.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(ICO_DYNACOMM));

   icon.flash = FALSE;

   icon.dx = GetSystemMetrics(SM_CXICON)/16;
   icon.dy = GetSystemMetrics(SM_CYICON)/16;

}



/*---------------------------------------------------------------------------*/
/* createWindows() - Determine tube size and create all Windows.             */
/*---------------------------------------------------------------------------*/

BOOL createWindows(cmdShow)
INT   cmdShow;
{
   INT      ndx;
   HMENU    hSysMenu;
   BYTE     work[80], work1[80], work2[80];

   LoadString(hInst, STR_APPNAME, (LPSTR) work, MINRESSTR);
   strcpy(work+strlen(work), " - ");
   LoadString(hInst, STR_TERMINAL, (LPSTR) work+strlen(work), MINRESSTR);

   if(!(hItWnd = CreateWindow((LPSTR) szAppName_private,
                         (LPSTR) work,
                         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                         CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
                         (HWND) NULL,
                         (HMENU) NULL,
                         (HANDLE) hInst,
                         (LPSTR) NULL)))
	return(FALSE);

   LoadString(hInst, STR_INI_MAXIMIZED, (LPSTR) work, MINRESSTR);
   if(!GetProfileInt((LPSTR) szAppName_private, (LPSTR) work, 0) || 
      (cmdShow == SW_SHOWMINNOACTIVE) || (cmdShow == SW_SHOWMINIMIZED) || (cmdShow == SW_MINIMIZE))
   {
      ShowWindow(hItWnd, cmdShow);
   }
   else
      ShowWindow(hItWnd, SW_SHOWMAXIMIZED);

   if(!(hdbmyControls = CreateDialog(hInst, getResId(IDDBMYCONTROLS), 
   	                               hItWnd, dbmyControls))) 
   {
      return(FALSE);
   }

   for(ndx = 0; ndx < DCS_NUMFKEYS; ndx += 1)   /* mbbx 2.00: moved from hidemyControls... */
      {
      fKeyHandles[ndx] = GetDlgItem(hdbmyControls, IDFK1 + ndx);
      DEBOUT("createWindows: fKeyHandles[]=%lx from GetDlgItem()\n",fKeyHandles[ndx]);
      }
   LoadString(hInst, STR_TERMINAL, (LPSTR) work, MINRESSTR);
   if(!(hTermWnd = CreateWindow((LPSTR) DC_WNDCLASS,
                           (LPSTR) work,
                           /* Removed WS_THICKFRAME jtf 3.21 */
                           WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_CLIPSIBLINGS | CS_BYTEALIGNWINDOW,
                           0, 0, 0, 0,
                           hItWnd,
                           (HMENU) NULL,
                           (HANDLE) hInst,
                           (LPSTR) NULL))) 
	return(FALSE);

/* jtf 3.33   hSysMenu = GetSystemMenu(hTermWnd, FALSE);
   for(ndx = GetMenuItemCount(hSysMenu)-1; ndx >= 0; ndx -= 1)
   {
      if(GetMenuString(hSysMenu, ndx, (LPSTR) work, 80, MF_BYPOSITION))
      {
         sscanf(work, "%s %s", work1, work2);
         sprintf(work, "%s\t  xxxxCtrl+%s", work1, work2+4);
         ChangeMenu(hSysMenu, ndx, (LPSTR) work, GetMenuItemID(hSysMenu, ndx),
                    MF_CHANGE | MF_BYPOSITION | GetMenuState(hSysMenu, ndx, MF_BYPOSITION));
      }
   } */

   if(!(hdbXferCtrls = CreateDialog(hInst, getResId(IDDBXFERCTRLS),
   	hTermWnd, dbmyControls))) 
	return(FALSE);
	/* mbbx 1.04 */
   xferCtlStop = GetDlgItem(hdbXferCtrls, IDSTOP);    /* mbbx 2.00: moved from hidemyControls()... */
   xferCtlPause = GetDlgItem(hdbXferCtrls, IDPAUSE);
   xferCtlScale = GetDlgItem(hdbXferCtrls, IDSCALE);
   showXferCtrls(NULL);
}


/*---------------------------------------------------------------------------*/
/* sizeWindows() -                                                           */
/*---------------------------------------------------------------------------*/

VOID sizeWindows()
{
   RECT  fKeysRect;
   RECT  ctrlsRect;
   RECT  termRect;

   setDefaultFonts();

   GetWindowRect(hdbmyControls, (LPRECT) &fKeysRect);
   GetWindowRect(fKeyHandles[0], (LPRECT) &ctrlsRect);   /* mbbx 2.00: fkeys... */
   MoveWindow(hdbmyControls, 0, fKeysRect.top, fKeysRect.right, 
              fKeysHeight = ((ctrlsRect.bottom - ctrlsRect.top) * 2), FALSE);

   GetClientRect(hItWnd, (LPRECT) &fKeysRect);  /* mbbx 2.00: may not init maximized... */
   sizeFkeys(MAKELONG(fKeysRect.right, fKeysRect.bottom));


   GetWindowRect(hdbXferCtrls, (LPRECT) &ctrlsRect);  /* mbbx 1.04: fkeys... */
   ctrlsHeight = ctrlsRect.bottom - ctrlsRect.top;

   initChildSize(&termRect);
   MoveWindow(hTermWnd, 0, 0, termRect.right, termRect.bottom, FALSE); /* jtf 3.21 */
}
/*---------------------------------------------------------------------------*/
/* initWindows() -                                                           */
/*---------------------------------------------------------------------------*/

BOOL initWindows(hInstance, hPrevInstance, cmdShow)
HANDLE   hInstance;
HANDLE   hPrevInstance;
INT      cmdShow;
{
   hInst = hInstance;

   /* Added 02/26/91 for window existence */
   hItWnd = NULL;
   hdbmyControls = NULL;
   hTermWnd = NULL;
   hdbXferCtrls = NULL;
   hEdit = NULL;
   fKeyHdl = NULL;

   LoadString(hInst, STR_APPNAME_PRIVATE, (LPSTR) szAppName_private, 20);
   LoadString(hInst, STR_APPNAME, (LPSTR) szAppName, 20);
   LoadString(hInst, STR_DEVELOPER, (LPSTR) szMessage, 80);
   LoadString(hInst, STR_NOMEMORY,(LPSTR)NoMemStr,sizeof(NoMemStr)); /* rjs msoft ??? */

   setDefaultAttrib(TRUE);                   /* mbbx 1.04: ...szAppName loaded */

   if(!hPrevInstance)
   {
      if(!initWndClass())                    /* mbbx 1.04 ... */
          return(FALSE);
   }

   initPort();
   initIcon();

   theBrush   = GetStockObject (WHITE_BRUSH);
   blackBrush = GetStockObject (BLACK_BRUSH);

   if(!createWindows(cmdShow))
     return(FALSE);

   sizeWindows();

   maxScreenLine = MAXSCREENLINE;            /* rjs moved from size windows */

   hMenu = GetMenu(hItWnd);

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* initDialogs() - Do all dialogbox initialization. [scf]                    */
/*---------------------------------------------------------------------------*/

VOID initDialogs()                           /* mbbx: remove ALL of these... */
{
}


/*---------------------------------------------------------------------------*/
/* dbPortInit() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL  APIENTRY dbPortInit(hDlg, message, wParam, lParam)   /* mbbx 2.01.10 ... */
HWND     hDlg;
UINT     message;
WPARAM   wParam;
LONG     lParam;
{
#ifdef WIN32
   WORD	temp_wParam;	
#endif

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);
      initComDevSelect(hDlg, ITMCONNECTOR, TRUE);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         break;

      case ITMCONNECTOR:
         if(GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
            break;
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, &trmParams.newDevRef);
   trmParams.fResetDevice = TRUE;
#ifdef WIN32
   /* code in next block passes address of wParam to function*/
   /* so we pass temp variable instead, since we need extract ID from wParam under WIN32*/
   temp_wParam = GET_WM_COMMAND_ID(wParam, lParam);
#endif

#ifdef ORGCODE
   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &wParam);
#else
   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &temp_wParam);
#endif
   resetSerial(&trmParams, TRUE, TRUE, NULL);   /* slc swat */
   if(trmParams.comDevRef != trmParams.newDevRef)
   {
      exitSerial();
      return(TRUE);
   }
   exitSerial();

#ifdef ORGCODE
   EndDialog(hDlg, (INT) getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &wParam));
#else
   EndDialog(hDlg, (INT) getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &temp_wParam));
#endif
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* setProfileExtent() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

/* mbbx: 1.01 - moved from itutil1.c */

BOOL NEAR setProfileExtent(section, extent)  /* mbbx 2.00: NEAR call... */
BYTE  *section;
BYTE  *extent;
{
   BOOL  setProfileExtent = FALSE;
   BYTE  str[80];
   BYTE  temp[80];

   if(!GetProfileString((LPSTR) section, (LPSTR) extent, (LPSTR) NULL_STR, (LPSTR) temp, 80))
   {
      strcpy(temp, extent);
      AnsiLower((LPSTR) temp);
      sprintf(str, "%s.exe ^.%s", szAppName_private, temp);
      AnsiLower((LPSTR) str);
      WriteProfileString((LPSTR) section, (LPSTR) temp, (LPSTR) str);
      setProfileExtent = TRUE;
   }

   return(setProfileExtent);
}


/*---------------------------------------------------------------------------*/
/* initFileDocData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR initFileDocData(fileType, strResID, fileExt, szSection)   /* mbbx 2.00 ... */
FILEDOCTYPE    fileType;
WORD           strResID;
BYTE           *fileExt;
BYTE           *szSection;
{
   BYTE  work1[MINRESSTR], work2[80];

   LoadString(hInst, strResID, (LPSTR) work1, MINRESSTR);
   GetProfileString((LPSTR) szAppName_private, (LPSTR) work1, (LPSTR) NULL_STR, (LPSTR) work2, 80);

   getDataPath(fileType, fileDocData[fileType].filePath, work2);

   strcpy(fileDocData[fileType].fileExt, fileExt);
   if(!getFileType(work2, fileDocData[fileType].fileExt))
      strcpy(work2, fileDocData[fileType].fileExt);

   strcpy(fileDocData[fileType].fileName, fileDocData[fileType].fileExt+1);

   if(work2[strlen(work2)-1] != '*')
      return(setProfileExtent(szSection, fileDocData[fileType].fileExt+3));

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* initProfileData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

#define DEFBUFFERLINES           100         /* mbbx 1.10... */

VOID initProfileData()                       /* mbbx: 1.01 ... */
{
   BYTE     str[MINRESSTR], str2[MINRESSTR], portName[16];
   INT      ndx;
   FARPROC  lpdbPortInit;
   BOOL     notify;

   LoadString(hInst, STR_INI_PORT, (LPSTR) str, MINRESSTR);
   if(!GetProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) NULL_STR, (LPSTR) portName, 5))
   {
      trmParams.comDevRef = ITMNOCOM;        /* jtf 3.33 */
      trmParams.speed     = 1200;            /* jtf 3.33 */
      trmParams.dataBits  = ITMDATA8;        /* jtf 3.33 */
      trmParams.stopBits  = ITMSTOP1;        /* jtf 3.33 */
      trmParams.parity    = ITMNOPARITY;     /* jtf 3.33 */
      if((ndx = doSettings(IDDBPORTINIT, dbPortInit)) != -1)   /* mbbx 2.01.10 ... */
      {
         LoadString(hInst, (ndx > 0) ? STR_COM : STR_COM_CONNECT, (LPSTR) str2, MINRESSTR);
         sprintf(portName, str2, ndx);
         WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) portName);
      }
   }

   LoadString(hInst, STR_INI_SWAP, (LPSTR) str, MINRESSTR);
   if((ndx = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 0)) > 0)
      *taskState.string = sprintf(taskState.string+1, "%d", SetSwapAreaSize(ndx));

   LoadString(hInst, STR_INI_INTL, (LPSTR) str, MINRESSTR);
   LoadString(hInst, STR_INI_IDATE, (LPSTR) str2, MINRESSTR);
   intlData.iDate = GetProfileInt((LPSTR) str, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_SDATE, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "/", (LPSTR) intlData.sDate, 2);
   LoadString(hInst, STR_INI_ITIME, (LPSTR) str2, MINRESSTR);
   intlData.iTime = GetProfileInt((LPSTR) str, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_STIME, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) ":", (LPSTR) intlData.sTime, 2);
   LoadString(hInst, STR_INI_S1159, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "AM", (LPSTR) intlData.s1159, 4);
   LoadString(hInst, STR_INI_S2359, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "PM", (LPSTR) intlData.s2359, 4);

   LoadString(hInst, STR_INI_EXTENSIONS, (LPSTR) str, MINRESSTR);
   notify = initFileDocData(FILE_NDX_SETTINGS, STR_INI_SETTINGS, SETTINGS_FILE_TYPE, str);
   if(initFileDocData(FILE_NDX_TASK, STR_INI_TASK, TASK_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_SCRIPT, STR_INI_SCRIPT, SCRIPT_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_MEMO, STR_INI_MEMO, MEMO_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_DATA, STR_INI_DATA, DATA_FILE_TYPE, str))
      notify = TRUE;
   if(notify)
#ifdef ORGCODE
      SendMessage(0xFFFF, WM_WININICHANGE, 0, (LONG) ((LPSTR) str));
#else
      SendMessage((HWND)0xFFFFFFFF, WM_WININICHANGE, 0, (LONG) ((LPSTR) str));
#endif
}

/*---------------------------------------------------------------------------*/
/* setup() - Reset all varibles, read settings file & emulation.       [scf] */
/*---------------------------------------------------------------------------*/

BOOL setup()                                 /* mbbx 2.00: no cmd line... */
{
   BYTE path[PATHLEN+1];
   BYTE tmp1[TMPNSTR+1];
   INT  ndx;
   SetRect ((LPRECT) &cursorRect, 0, 0, 0, 0);
   vScrollShowing = TRUE;
   serNdx         = 0;
   cursorTick     = -1l;
   cursBlinkOn    = FALSE;
   cursorOn       = TRUE;
   activCursor    = 1;
   prtFlag        = FALSE;
   useScrap       = FALSE;
   copiedTable    = FALSE;
   *fKeyStr       = 0;                       /* mbbx 2.00: fKeySeq... */
   fKeyNdx        = 1;
   scrapSeq       = FALSE;

   xferFlag       = XFRNONE;
   xferPaused     = FALSE;
   xferBreak      = FALSE;                   /* mbbx 2.00: xfer ctrls */
   xferEndTimer   = 0;
   xferWaitEcho   = FALSE;
   xferViewPause  = 0;                       /* mbbx: auto line count */
   xferViewLine   = 0;
   xferPSChar     = 0;                           /* mbbx 1.02: packet switching */
   *strRXErrors   =
   *strRXBytes    =
   *strRXFname    =
   *strRXFork     = 0;
   taskInit();
   keyMapInit();                             /* mbbx 1.04: keymap */

   debugFlg       = FALSE;                   /* how does this get enabled??? */

   mdmOnLine      = FALSE;
   dialing        = FALSE;
   answerMode     = FALSE;
   protectMode    = FALSE;                    /* mbbx: emulation state */
   KER_getflag    = FALSE;
   gotCommEvent   = TRUE;

   if((hemulKeyInfo = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD) SIZEOFEMULKEYINFO)) == NULL)
      return(FALSE);


   initProfileData();                       /* mbbx: 1.01 */

   hTE.hText = NULL;
   setDefaults();

   setFKeyLevel(1, FALSE);           /*   jtfterm */

   termInitSetup(NULL);

   strcpy(szMessage, szAppName);
   return(TRUE);
}

/*---------------------------------------------------------------------------*/
/* readCmdLine() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BOOL fileDocExist(fileType, filePath)        /* mbbx 2.00: no forced extents... */
WORD  fileType;
BYTE  *filePath;
{
   BOOL  fileDocExist;
   BYTE  savePath[PATHLEN], testPath[PATHLEN];
   BYTE     OEMname[STR255];            /* jtf 3.20 */

   strcpy(savePath, filePath);
   getDataPath(fileType, testPath, savePath);
   strcpy(testPath+strlen(testPath), savePath);


   // JYF -- replace below two line with following if () to
   //        remove the use of AnsiToOem()
   //
   //AnsiToOem((LPSTR) testPath, (LPSTR) OEMname); /* jtf 3.20 */
   //if(fileDocExist = fileExist(OEMname)) /* jtf 3.20 */

   if (fileDocExist = fileExist(testPath))
      strcpy(filePath, testPath);


   return(fileDocExist);
}


WORD NEAR getFileDocType(filePath)           /* mbbx 2.00: no forced extents... */
BYTE  *filePath;
{
   BYTE  fileExt[16];
   WORD  fileType;

   *fileExt = 0;
   if(!getFileType(filePath, fileExt))
   {
      forceExtension(filePath, NO_FILE_TYPE+2, FALSE);
      if(fileDocExist(FILE_NDX_DATA, filePath) || fileDocExist(FILE_NDX_SETTINGS, filePath))
         return(FILE_NDX_SETTINGS); /* jtf 3.11 */
   }

   for(fileType = FILE_NDX_SETTINGS; fileType <= FILE_NDX_MEMO; fileType += 1)
   {
      if(*fileExt == 0)
         forceExtension(filePath, fileDocData[fileType].fileExt+2, TRUE);
      else if((fileType < FILE_NDX_MEMO) && (strcmp(fileDocData[fileType].fileExt+2, fileExt) != 0))
         continue;

      if(fileDocExist(FILE_NDX_DATA, filePath) || fileDocExist(fileType, filePath) || (*fileExt != 0))
         return(fileType);
   }

   return(FILE_NDX_DATA);
}


BOOL NEAR initTermFile(filePath)             /* mbbx 2.00 ... */
BYTE  *filePath;
{
   getDataPath(FILE_NDX_SETTINGS, fileDocData[FILE_NDX_SETTINGS].filePath, filePath);

   LoadString(hInst, STR_TERMINAL, (LPSTR) termData.title, MINRESSTR);
                                             /* mbbx 2.00: no forced extents... */
   return(termFile(fileDocData[FILE_NDX_SETTINGS].filePath, filePath, 
                   fileDocData[FILE_NDX_SETTINGS].fileExt, termData.title, TF_DEFTITLE));
}


VOID NEAR readCmdLine(lpszCmdLine)
LPSTR    lpszCmdLine;
{
   INT   ndx, ndx2;
   BYTE  filePath[PATHLEN];
   BYTE  tmpFilePath[PATHLEN];
   INT   nEditWnd = 0;
   BYTE  OEMname[STR255];              /* jtf 3.20 */
   BYTE  work[STR255];                 /* jtf 3.28 */
   BYTE  work1[STR255];                /* jtf 3.28 */
   INT   testFlag;
   
   saveFileType = FILE_NDX_SETTINGS; /* jtf 3.11 */

   AnsiUpper(lpszCmdLine);
   for(ndx = 0; lpszCmdLine[ndx] != 0; )     /* mbbx 2.00 ... */
   {
      while(lpszCmdLine[ndx] == 0x20)
         ndx += 1;
      if(lpszCmdLine[ndx] == 0)
         break;

      for(ndx2 = 0; (filePath[ndx2] = lpszCmdLine[ndx]) != 0; ndx2 += 1)
      {
         ndx += 1;
         if(filePath[ndx2] == 0x20)
         {
            filePath[ndx2] = 0;
            break;
         }
      }
      strcpy(work1,filePath);
      switch(ndx2 = getFileDocType(filePath))   /* mbbx 2.00: term init... */
      {
      case FILE_NDX_SETTINGS:
         if(!activTerm)
            initTermFile(filePath);
         break;
      }
   }

   if ((!activTerm) && (lstrlen((LPSTR)lpszCmdLine)>0) )
         {
         LoadString(hInst, STRERRNOFILE, (LPSTR) work, STR255-1); /* jtf 3.15 */
         strcpy(filePath,work1);
         forceExtension(filePath, SETTINGS_FILE_TYPE+2, FALSE);
         sprintf(work1, work, filePath);
         testFlag = MessageBox(GetActiveWindow(), (LPSTR) work1, (LPSTR) szAppName, MB_OKCANCEL);
         if (testFlag==IDOK)
            {
            if (filePath[1]==':')
               {
               filePath[0]='A';
               }
            else
               {
               strcpy(work,filePath);
               strcpy(filePath,"A:");
               strcpy(filePath+2,work);
               }
               initTermFile(filePath);
            }
         }
   if(!activTerm)                            /* mbbx 2.00: term init... */
   {
      LoadString(hInst, STR_AUTOLOAD, (LPSTR) filePath, PATHLEN); /* jtf 3.17 */


      // JYF -- replace below two lines with the following if() to
      //        remove the use of AnsiToOem()
      //
      //AnsiToOem((LPSTR) filePath, (LPSTR) OEMname); /* jtf 3.20 */
      //if (fileExist(OEMname)) /* jtf 3.20 */

      if (fileExist(filePath))
         initTermFile(filePath);
      else
         {
         _searchenv( filePath, "PATH", tmpFilePath );
         if(strlen(tmpFilePath)>0)
            initTermFile(tmpFilePath);
         }

      if(!activTerm)
      {
         if((nEditWnd -= 1) >= 0)
            termData.flags |= TF_HIDE;
         else
            saveFileType = FILE_NDX_SETTINGS;

         activTerm = TRUE;
         resetSerial(&trmParams, TRUE, TRUE,0);

         if(!(termData.flags & TF_HIDE))
            showTerminal(TRUE, TRUE);
      }
   }
   if(!IsIconic(hItWnd))   /* rjs bugs 015 */
      sizeTerm(0L); /* jtf 3.21 */
}


/*---------------------------------------------------------------------------*/
/* freeItResources()- Free up all windows resource b/4 back to DOS executive.*/
/*                    Internal house keeping.  Note: Close that serial port. */
/*---------------------------------------------------------------------------*/

VOID freeItResources()
{
   INT   ndx;

   exitSerial();
   keyMapCancel();                           /* mbbx 1.04: keymap */

   DeleteObject(hTE.hFont);
   clearFontCache();                         /* mbbx 2.00: redundant code... */

   GlobalFree(hTE.hText);
   GlobalFree(hemulKeyInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\kermit.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "kermit.h"

/*---------------------------------------------------------------------------*/
/* KER_Receive() - state table switcher for receiving files            [rkh] */
/*---------------------------------------------------------------------------*/
BOOL FAR KER_Receive(BOOL  bRemoteServer)
{
   INT  num, len;
   BYTE bySaveState = KER_state;

   KER_Init(KER_RCV);

   if((KERRCVFLAG == KERSCREEN) || answerMode)
   {
      KER_n = 1;
      KER_state = KER_FILE;
      if(bySaveState == KER_TEXT)               /* tge nova kermit ... */
      {
         KER_SndPacket(KER_ACK, KER_n, 0, 0);   /* Return a ACK */
         KER_state = KER_DATA;
      }
   }
   else
   {
      flushRBuff();
   }

   while(TRUE)
   {
      if(xferStopped && (KER_state != KER_ABORT))
      {
         KER_RcvPacket(&len, &num, packet);
         KER_Abort(STR_KER_RCVABORT);
         return(FALSE);
      }
      if((KER_numtry++ > KER_MAXRETRY) && (KER_state != KER_ABORT))
      {
         KER_RcvPacket(&len, &num, packet);
         KER_Abort(STR_KER_RETRYABORT);
         return(FALSE);
      }
      rxEventLoop();

      KER_bSetUp(KER_state);

      switch(KER_state)
      {
         case KER_RCV:                       /* Receive-Init */   
            KER_state = KER_ReceiveInit();
            break;

         case KER_TEXT:                      /* Receive-Text */
         case KER_FILE:                      /* Receive-File */
            KER_state = KER_ReceiveFile();
            break;                           /* Receive-Data */

         case KER_DATA:
            KER_state = KER_ReceiveData();
            break; 

         case KER_CMPLT:                     /* Complete state */
            delay((WORD) 60, NULL);          /* tgex delay 1 sec for last packet */
            return(TRUE);

         case KER_ABORT:                     /* Abort state */
         default:
           delay((WORD) 60, NULL);          /* tgex delay 1 sec for last packet */
           return(FALSE);
      }
   } /* while */
}

/*---------------------------------------------------------------------------*/
/* KER_ReceiveInit() - receive initalization                           [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_ReceiveInit()
{
   INT len, num;                             /* Packet length, number */

   KER_parflg = KER_NOPARITY;                /* tgex : let parity bits through from sender */

   switch(KER_RcvPacket(&len, &num, packet)) /* Get a packet */
   {
      case KER_SEND:                         /* Send-Init */
         if (KERRCVFLAG == KERFILE)          /* set parity off of 'S' packet */
            KER_parflg = KER_AutoPar();
         KER_RcvPacketInit(packet);          /* Get the other side's init data */
         KER_SndPacketInit(packet);          /* Fill up packet with my init info */
         KER_SndPacket(KER_ACK, KER_n, 8, packet); /* ACK with my parameters */
         KER_mask = 0xFF;                    /* set mask so checksum will include 8th bit if parity is used */
                                             /* have to wait until after packet we send back has built
                                                its checksum while ignoring possible parity bits that we
                                                let thru in the first place to be able to check the parity */
         KER_oldtry = KER_numtry;            /* Save old try count */
         KER_numtry = 0;                     /* Start a new counter */
         KER_n = (KER_n+1) % 64;             /* Bump packet number, mod 64 */
         return(KER_FILE);                   /* Enter File-Receive state */

      case KER_ERROR:                        /* Error packet received */
         return(KER_PrintErrPacket(packet)); /* Print it out and */

      case FALSE:                            /* Didn't get packet */
      default: 
         flushRBuff(); 
         showBErrors(++xferErrors);
         KER_SndPacket(KER_NACK, KER_n, 0, 0);  /* Return a NAK */
         return(KER_state);                     /* Keep trying */
   }
}

/*---------------------------------------------------------------------------*/
/* KER_ReceiveFile() - receive file header                             [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_ReceiveFile()
{
   INT      num, len;   
   BYTE     filnam1[50];
   OFSTRUCT dummy;

   switch(KER_RcvPacket(&len, &num, packet)) /* Get a packet */
   {
      case KER_SEND:                         /* Send-Init, maybe our ACK lost */
         if(KER_oldtry++ > KER_MAXRETRY)           /* If too many tries abort */
            return(KER_Abort(STR_KER_RETRYABORT));

         if(num==((KER_n==0) ? 63 : KER_n-1))/* Previous packet, mod 64? */
         {                                   /* Yes, ACK it again with  */
            KER_SndPacketInit(packet);       /* our Send-Init parameters */
            KER_SndPacket(KER_ACK, num, 8, packet);
            showBErrors(++xferErrors);
            KER_numtry = 0;                  /* Reset try counter */
            return(KER_state);               /* Stay in this state */
         }
         else                                /* Not previous packet, abort */
            return(KER_Abort(STR_KER_BADPACKNUM));

      case KER_EOF:                          /* End-Of-File */
         if(KER_oldtry++ > KER_MAXRETRY)          /* If too many tries abort */
            return(KER_Abort(STR_KER_RETRYABORT));

         if(num == ((KER_n==0) ? 63 : KER_n-1)) /* Previous packet, mod 64? */
         {                                      /* Yes, ACK it again. */
            KER_SndPacket(KER_ACK, num, 0, 0);
            KER_numtry = 0;
            showBErrors(++xferErrors);
            return(KER_state);               /* Stay in this state */
         }
         else                                /* Not previous packet, abort */
            return(KER_Abort(STR_KER_BADPACKNUM));

      case KER_TEXT:
      case KER_FILE:                         /* File Header (just what we want) */
         if(num != KER_n)                    /* The packet number must be right */
            return(KER_Abort(STR_KER_BADPACKNUM));

         if(!KER_firstfile)
            return(KER_Abort(STR_KER_CREATEFILE));

         KER_SndPacket(KER_ACK, KER_n, 0, 0);/* Acknowledge the file header */
         KER_oldtry = KER_numtry;            /* Reset try counters */
         KER_numtry = 0;
         KER_n = (KER_n+1) % 64;             /* Bump packet number, mod 64 */
         KER_bytes = 0l;                     /* don't have any bytes from file yet */
         return(KER_DATA);                   /* Switch to Data state */

      case KER_BREAK:                        /* Break transmission (EOT) */
          if(num != KER_n)                   /* Need right packet number here */
             return(KER_Abort(STR_KER_BADPACKNUM));

          KER_SndPacket(KER_ACK, KER_n, 0, 0);  /* Say OK */
          return(KER_CMPLT);                    /* Go to complete state */

      case KER_ERROR:                           /* Error packet received */
         return(KER_PrintErrPacket(packet)); /* Print it out and */

      case FALSE:                               /* Didn't get packet */
      default: 
         flushRBuff(); 
         KER_SndPacket(KER_NACK, KER_n, 0, 0);  /* Return a NAK */
         showBErrors(++xferErrors);
         return(KER_state);                     /* Keep trying */
      }
}

/*---------------------------------------------------------------------------*/
/* KER_ReceiveData() - receive data packets                            [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_ReceiveData()
{
   INT num, len;                             /* Packet number, length */

   switch(KER_RcvPacket(&len, &num, packet)) /* Get packet */
   {
   case KER_DATA:                            /* Got Data packet */
      if(num != KER_n)                       /* Right packet? */
      {                                      /* No */
         if(KER_oldtry++ > KER_MAXRETRY)           /* If too many tries abort */
            return(KER_Abort(STR_KER_RETRYABORT));

         if(num == ((KER_n==0) ? 63 : KER_n-1)) /* Else check packet number */
         {                                      /* Previous packet again? */
            flushRBuff(); 
            KER_SndPacket(KER_ACK, num, 6, packet);   /* Yes, re-ACK it */
            KER_numtry = 0;                           /* Reset try counter */
            showBErrors(++xferErrors);
            return(KER_state);               /* Don't write out data! */
         }
         else                                /* sorry, wrong number */
            return(KER_Abort(STR_KER_BADPACKNUM));
      }
                                                /* Got data with right packet number */
      KER_BufferEmpty(packet, len, KERRCVFLAG); /* Write the data to the file */
      if(KERRCVFLAG != KERSCREEN)
         showBBytes(KER_bytes, FALSE);       /* mbbx 2.00: xfer ctrl */
      KER_SndPacket(KER_ACK, KER_n, 0, 0);   /* Acknowledge the packet */
      KER_oldtry = KER_numtry;               /* Reset the try counters */
      KER_numtry = 0;        
      KER_n = (KER_n+1) % 64;                /* Bump packet number, mod 64 */
      return(KER_DATA);                      /* Remain in data state */

   case KER_FILE:                            /* Got a File Header */
      if(KER_oldtry++ > KER_MAXRETRY)              /* If too many tries abort */
         return(KER_Abort(STR_KER_RETRYABORT));

      if(num == ((KER_n==0) ? 63:KER_n-1))  /* Else check packet number */
      {                                      /* It was the previous one */
         flushRBuff(); 
         KER_SndPacket(KER_ACK, num, 0, 0);  /* ACK it again */
         KER_numtry = 0;                     /* Reset try counter */
         showBErrors(++xferErrors);
         return(KER_state);                  /* Stay in Data state */
      }
      else                                   /* Not previous packet, abort */
         return(KER_Abort(STR_KER_BADPACKNUM));

   case KER_EOF:                             /* End-Of-File */
      if(num != KER_n)                       /* Must have right packet number */
         return(KER_Abort(STR_KER_BADPACKNUM));

      KER_SndPacket(KER_ACK, KER_n, 0, 0);   /* OK, ACK it. */
      KER_firstfile = FALSE;                 /* we have got at least one complete file*/
      _lclose(xferRefNo);                    /* Close the file */
      KER_n = (KER_n+1)%64;                  /* Bump packet number */
      return(KER_FILE);                      /* Go back to Receive File state */

   case KER_ERROR:                           /* Error packet received */
      return(KER_PrintErrPacket(packet));    /* Print it out and */

   case FALSE:                               /* Didn't get packet */
   default: 
      flushRBuff(); 
      KER_SndPacket(KER_NACK, KER_n, 0, 0);  /* Return a NAK */
      showBErrors(++xferErrors);
      return(KER_state);                     /* Keep trying */
   }
}

/*---------------------------------------------------------------------------*/
/* KER_Send() - state table switcher for sending files                 [rkh] */
/*---------------------------------------------------------------------------*/
BOOL FAR KER_Send()
{
   LONG  dummy;

   KER_Init(KER_SEND);

   if(answerMode)
      delay(100, &dummy);                    /* Sleep to give the guy a chance */

   flushRBuff();                             /* Flush pending input */

   while(TRUE)                               /* Do this as long as necessary */
   {
      if(xferStopped && (KER_state != KER_ABORT))
      {
         KER_Abort(STR_KER_SNDABORT);
         return(FALSE);
      }
      if((KER_numtry++ > KER_MAXRETRY) && (KER_state != KER_ABORT))  /* If too many tries, give up */
      {
         KER_Abort(STR_KER_RETRYABORT);
         return(FALSE);
      }
      rxEventLoop();

      KER_bSetUp(KER_state);


      switch(KER_state)
      {
         case KER_SEND:
            KER_state = KER_SendInit();
            break;
         case KER_FILE:
            KER_state = KER_SendFile();
            break;
         case KER_DATA:
            KER_state = KER_SendData();
            break;
         case KER_EOF:
         case KER_BREAK:
            KER_state = KER_SendGeneric(KER_state);
            break;
         case KER_CMPLT:
            delay((WORD) 60, NULL);          /* tgex delay 1 sec for last packet */
            return(TRUE);
         default:
            KER_bSetUp('?');
            /* fall through */
         case KER_ABORT:
            delay((WORD) 60, NULL);          /* tgex delay 1 sec for last packet */
            return(FALSE);
      }
   }
}

/*---------------------------------------------------------------------------*/
/* KER_SendInit() - send parameters to other side                      [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_SendInit()
{
   INT num, len;                             /* Packet number, length */
   LONG dummy;

   KER_SndPacketInit(packet);                /* Fill up init info packet */
   KER_SndPacket(KER_SEND, KER_n, 8, packet);/* Send an S packet */

   switch(KER_RcvPacket(&len, &num, recpkt)) /* What was the reply? */
   {
      case KER_RCV:
         return(KER_state);                  /* remote get */
      case KER_NACK:  
         flushRBuff(); 
         showBErrors(++xferErrors);
         return(KER_state);                  /* NAK, try it again */
      case KER_ACK:                          /* ACK */
         if(KER_n != num)                    /* If wrong ACK, stay in S state */
         {
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state);               /* and try again */
         }
         KER_RcvPacketInit(recpkt);                   /* Get other side's init info */
         KER_eol = (KER_eol == 0) ? '\n' : KER_eol;   /* Check and set defaults */
         KER_quote = (KER_quote == 0) ? '#' : KER_quote; 
         KER_numtry = 0;                     /* Reset try counter */
         KER_n = (KER_n+1) % 64;             /* Bump packet count */
         return(KER_FILE);                   /* OK, switch state to F */
      case KER_ERROR:                        /* Error packet received */
         return(KER_PrintErrPacket(recpkt)); /* Print it out and */
      case FALSE:
      default: 
         flushRBuff(); 
         showBErrors(++xferErrors);
/* debug:rkh 60 ticks ??? */
         delay(60,&dummy);
         return(KER_state);                  /* Receive failure, try again */
   }
}

/*---------------------------------------------------------------------------*/
/* KER_SendFile() -send the file header                                [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_SendFile()
{
   INT num, len;                             /* Packet number, length */
   BYTE filnam1[50],                         /* Converted file name */
   *newfilnam,                               /* Pointer to file name to send */
   *cp;                                      /* BYTE pointer */

   KER_SndPacket(KER_FILE, KER_n, (INT)*xferFname, xferFname+1);   /* Send an F packet */

   switch(KER_RcvPacket(&len, &num, recpkt))    /* What was the reply? */
   {       
      case KER_NACK:                            /* NAK, just stay in this state, */
         num = ((--num < 0) ? 63 : num);        /* unless it's NAK for next packet */
         if(KER_n != num)                       /* which is just like an ACK for */ 
         {                                      /* this packet so fall thru to... */
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         }
         /* fall through if nacking next packet
            ... we did not get last ACK, but they sent it */
      case KER_ACK:                             /* ACK */
         if(KER_n != num)                       /* If wrong ACK, stay in F state */
         {                      
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         }
         KER_numtry = 0;                        /* Reset try counter */
         KER_n = (KER_n+1) % 64;                /* Bump packet count */
         KER_size = KER_BufferFill(packet);     /* Get first data from file */
         return(KER_DATA);                      /* Switch state to D */
      case KER_ERROR:                           /* Error packet received */
         return(KER_PrintErrPacket(recpkt));    /* Print it out and */
      case FALSE:                               /* Receive failure, stay in F state */
      default:                                  /* Something else, just abort */
         flushRBuff(); 
         showBErrors(++xferErrors);
         return(KER_state); 
   }
}

/*---------------------------------------------------------------------------*/
/* KER_SendData() -send the data packets                               [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_SendData()
{
   INT num, len;                             /* Packet number, length */

   KER_SndPacket(KER_DATA, KER_n, KER_size, packet); /* Send a D packet */

   switch(KER_RcvPacket(&len, &num, recpkt)) /* What was the reply? */
   {        
      case KER_NACK:                         /* NAK, just stay in this state, */
         num = ((--num < 0) ? 63 : num);     /* unless it's NAK for next packet */
         if(KER_n != num)                    /* which is just like an ACK for */
         {                                   /* this packet so fall thru to... */
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         } 
         /* fall through if nacking next packet
            ... we did not get last ACK, but they sent it */
      case KER_ACK:                          /* ACK */
         if(KER_n != num)                    /* If wrong ACK, fail */
         {
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         }
         updateProgress(FALSE);
         updateTimer();
         KER_numtry = 0;                     /* Reset try counter */
         KER_n = (KER_n+1) % 64;             /* Bump packet count */
         if((KER_size = KER_BufferFill(packet)) == EOF)     /* Get data from file */
            return(KER_EOF);                 /* If EOF set state to that */
         return(KER_DATA);                   /* Got data, stay in state D */
      case KER_ERROR:                        /* Error packet received */
         return(KER_PrintErrPacket(recpkt)); /* Print it out and */
      case FALSE:                            /* Receive failure, stay in D */
      default:
         flushRBuff(); 
         showBErrors(++xferErrors);
         return(KER_state); 
      }
}

/*---------------------------------------------------------------------------*/
/* KER_SendGeneric() -                                                 [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_SendGeneric(BYTE lKER_state)
{
   INT num, len;

   KER_SndPacket(lKER_state, KER_n, 0, packet);        /* Send a KER_EOF packet */

   switch(KER_RcvPacket(&len, &num, recpkt)) /* What was the reply? */
   {
      case KER_NACK:                         /* NAK, just stay in this state, */
         num = ((--num < 0) ? 63 : num);     /* unless NAK for previous packet, */

         if(KER_n != num)                    /* which is just like an ACK for */
         {                                   /* this packet so fall thru to... */
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         }
         /* fall through if nacking next packet
            ... we did not get last ACK, but they sent it */
      case KER_ACK:                          /* ACK */
         if(KER_n != num)                    /* If wrong ACK, hold out */
         {
            flushRBuff(); 
            showBErrors(++xferErrors);
            return(KER_state); 
         }
         KER_numtry = 0;                     /* Reset try counter */
         KER_n = (KER_n+1) % 64;             /* and bump packet count */

         switch(lKER_state)
         {
            case KER_EOF:
               _lclose (xferRefNo);          /* Close the input file */
               xferRefNo = 0;                /* Set flag indicating no file open */ 
               if(!KER_GetNextFile())        /* No more files go? */
                  return(KER_BREAK);         /* if not, break, EOT, all done */
               return(KER_FILE);             /* More files, switch state to F */
            case KER_BREAK:
               return(KER_CMPLT);            /* Switch state to Complete */
         }
      case KER_ERROR:                        /* Error packet received */
         return(KER_PrintErrPacket(recpkt)); /* Print it out and */
      case FALSE:                            /* Receive failure, stay in Z */
      default:
         flushRBuff(); 
         showBErrors(++xferErrors);
         return(KER_state); 
   }
}

/*---------------------------------------------------------------------------*/
/*
 * KERMIT utilities.
 */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* KER_Init() initializes kermit variables                             [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_Init(BYTE state)
{
   KER_eol = ((trmParams.emulate == ITMDELTA) && trmParams.localEcho) ? XOFF : CR;
                                             /* mbbx 1.10: CUA */
                                             /* EOL for outgoing packets (half duplex) */
                                             /* EOL for outgoing packets */
   KER_escchr = DEFESC;                      /* Default escape character */
   KER_filnamcnv = DEFFNC;                   /* Default filename case conversion */
   KER_firstfile = TRUE;                     /* First file transfer */
   KER_image = DEFIM;                        /* Default image mode (TRUE) */
   KER_lecho = KER_GetLocalEcho();           /* Get local echo info */
   KER_n = 0;                                /* Initialize message number */
   KER_numtry = 0;                           /* Say no tries yet */
   KER_pad = 0;                              /* No padding */
   KER_padchar = KER_PADCHAR;                /* Use null if any padding wanted */
   KER_pktdeb = FALSE;                       /* No packet file debugging */
   KER_quote = '#';                          /* Standard control-quote char */
   KER_state = state;                        /* Receive-Init is the start state */
   KER_timeout = FALSE;                      /* No timeout has occurred yet */
   KER_timint = KER_SNDTIMEOUT;              /* Start with default time outs. */
   KER_turn = KER_GetTurnAroundTime();       /* Get turnaround info */
   KER_8flag   = FALSE;  /* start with 8th bit quote flag off */ 

   KER_parMask = 0;       /* tgex used for auto parity */
   KER_mask = 0xFF;       /* used for checksumming with autoparity, to screen parity */
	KER_initState = 0;     /* tgex */
   KER_select8 = '\0';    /* tgex set to illegal value, set later */

   xferErrors = 0;
   xferStopped = FALSE;

   KER_parflg = KER_GetParity();             /* Get parity info -- before changed */
                                             /* if we are sending, we need it. */ 
}

/*---------------------------------------------------------------------------*/
/* KER_GetParity() - get parity setting                                [rkh] */
/*---------------------------------------------------------------------------*/
INT NEAR KER_GetParity()
{
   switch(trmParams.parity)
   {
      case ITMODDPARITY:
         return(KER_ODDPARITY);
      case ITMEVENPARITY:
         return(KER_EVENPARITY);
      case ITMMARKPARITY:
         return(KER_MARKPARITY);
      case ITMSPACEPARITY:
         return(KER_SPACEPARITY);
      case ITMNOPARITY:
      default:
         return(KER_NOPARITY);
   }
}

/*---------------------------------------------------------------------------*/
/* KER_GetTurnAroundTime() - get turnaround parameter                  [rkh] */
/*---------------------------------------------------------------------------*/
INT NEAR KER_GetTurnAroundTime()
{
   return(FALSE);

   switch(trmParams.flowControl)
   {
      case ITMXONFLOW:
         return (TRUE);
      case ITMNOFLOW:
      case ITMHARDFLOW:
      default:
         return (FALSE);
   }
}

/*---------------------------------------------------------------------------*/
/* KER_GetLocalEcho() - get local echo parameter                       [rkh] */
/*---------------------------------------------------------------------------*/
INT NEAR KER_GetLocalEcho()
{
   return(trmParams.localEcho);              /* mbbx 1.10: CUA... */
}

/*---------------------------------------------------------------------------*/
/* KER_Abort() - Kermit abort transfer routine                         [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_Abort(WORD msgID)
{
   LONG  dummy;

   LoadString(hInst, msgID, (LPSTR)taskState.string, 80);  /* mbbx 1.04: REZ... */
   KER_SndPacket(KER_ERROR, KER_n, strlen(taskState.string), taskState.string);

   if(xferFlag == XFRBSND)
      sndAbort();
   else
      rcvAbort();

   delay(180, &dummy);
   flushRBuff();

   return(KER_ABORT);
}

/*---------------------------------------------------------------------------*/
/* KER_DoParity()- do parity on character ch                           [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_DoParity(BYTE ch)
{
   INT a;

   if (!KER_parflg)                       /* tgex: was masking out bit 8 */
      return (ch);

   ch &= 0177;

   switch(KER_parflg)
   {
      case KER_ODDPARITY:
         ch |= 0x80;
      case KER_EVENPARITY:
         a = (ch & 15) ^ ((ch >> 4) & 15);
         a = (a & 3) ^ ((a >> 2) & 3);
         a = (a & 1) ^ ((a >> 1) & 1);
         return((ch & 0177) | (a << 7));
      case KER_MARKPARITY:             /* tgex ITMMARKPARITY: */
         return(ch | 0x80);
      case KER_SPACEPARITY:            /* tgex ITMSPACEPARITY: */
         return(ch & 0x7F);
      default:
         return(ch);
   }
}

/*---------------------------------------------------------------------------*/
/* KER_SndPacket()- send a kermit packet                               [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_SndPacket(BYTE  type, int   num, int len, BYTE  *data)
{
   INT i;                                    /* Character loop counter */
   BYTE chksum, buffer[200];                 /* Checksum, packet buffer */
   register BYTE *bufp;                      /* Buffer pointer */

   bufp = buffer;                            /* Set up buffer pointer */

   for(i=1; i <= KER_pad; i++)
      modemWr(KER_padchar);                  /* Issue any padding */

   *bufp++ = KER_DoParity(CHSOH);            /* Packet marker, ASCII 1 (SOH) */

   *bufp++ = KER_DoParity(tochar(len+3));    /* Send the character count */
   chksum  = tochar(len+3) & KER_mask;       /* Initialize the checksum */

   *bufp++ = KER_DoParity(tochar(num));      /* Packet number */
   chksum += tochar(num) & KER_mask;         /* Update checksum */

   *bufp++ = KER_DoParity(type);             /* Packet type */
   chksum += type & KER_mask;                /* Update checksum */

   for(i=0; i<len; i++)                      /* Loop for all data characters */
   {
      *bufp++ = KER_DoParity(data[i]);       /* Get a character */
      chksum += data[i] & KER_mask;          /* Update checksum */
   }

   chksum = (((chksum & 0300) >> 6) + chksum) & 077;  /* Compute final checksum */

   *bufp++ = KER_DoParity(tochar(chksum));      /* Put it in the packet */
   *bufp++ = KER_DoParity(KER_eol);             /* Extra-packet line terminator */

   modemWrite((LPSTR)buffer, (INT) (bufp - buffer));    /* mbbx 1.03: isolate comm... */
}

/*---------------------------------------------------------------------------*/
/* KER_RcvPacket()- read a kermit packet                               [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_RcvPacket(INT   *len, INT *num, BYTE  *data)
{
   INT i, tries, done;                       /* Data character number, loop exit */
   BYTE t,                                   /* Current input character */
        type,                                /* Packet type */
        rchksum;                             /* Checksum received from other host */
   BOOL resync;

   tries = 0;

   while(unpar(t = KER_InChar()) != CHSOH)              /* Wait for packet header */
   {
      if(KER_timeout || xferStopped)
      {
         KER_timeout = FALSE;
         return(FALSE);
      }
   }

   done = FALSE;                             /* Got SOH, init loop */

   while(!done)                              /* Loop to get a packet */
   {
      KER_parMask = t & 0x80;         /* Get SOH parity bit */
      KER_cchksum = 0;                       /* reset checksum */
      if((t = unpar(KER_CInChar())) == CHSOH)
         continue;                           /* Resynchronize if SOH */
      *len = unchar(t)-3;             /* Character count */

      if((t = unpar(KER_CInChar())) == CHSOH)
         continue;                           /* Resynchronize if SOH */
      *num = unchar(t);               /* Packet number */

      if(unpar(t = KER_CInChar()) == CHSOH)
         continue;                           /* Resynchronize if SOH */
      type = unpar(t);                       /* Packet type */
      KER_parMask |= (t & 0x80) >> 1;        /* get packet type parity into bit 6 of KER_parMask */

   /* Put len characters from the packet into the data buffer */
       
      resync = FALSE;
      for (i=0; i < *len; i++)
      {
         if((data[i] = KER_mask & (t = KER_CInChar())) == CHSOH) /* Resynch if SOH */
                     /* tgex ^ use KER_mask to get rid of parity bits in data of initial packet sent */
         {
            resync = TRUE;
            break;
         }
         if(KER_timeout || xferStopped)
         {
            KER_timeout = FALSE;
            return(FALSE);
         }
      }
      if(resync)
         continue;

      data[*len] = 0;                        /* Mark the end of the data */

      if((t = unpar(KER_InChar())) == CHSOH)
         continue;                           /* Resynchronize if SOH */
      rchksum = unchar(t);                   /* Convert to numeric */
      done = TRUE;                           /* Got checksum, done */
   }
                                             /* Fold in bits 7,8 to compute */
   KER_cchksum = (((KER_cchksum & 0300) >> 6) + KER_cchksum) & 077; /* final checksum */

   if(KER_timeout || xferStopped)
   {
      KER_timeout = FALSE;
      return(FALSE);
   }

   if(KER_cchksum != rchksum)
   {
      return(FALSE);
   }

   return(type);                             /* All OK, return packet type */
}

/*---------------------------------------------------------------------------*/
/* KER_CInChar() - get parity adjusted char and update checksum        [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_CInChar()
{
    BYTE ch;

    ch = KER_InChar();                       /* Get a character */
    KER_cchksum += ch & KER_mask;            /* Add to the checksum, drop parity bit if first packet */
    return(ch);
}

/*---------------------------------------------------------------------------*/
/* KER_InChar()- get parity adjusted character                         [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_InChar()
{
   BYTE  ch;

   ch = (BYTE)KER_ModemWait();

   return((KER_parflg || KER_parMask) ? ch & 0x7F : ch);
}

/*---------------------------------------------------------------------------*/
/* KER_ModemWait() -                                                   [rkh] */
/*---------------------------------------------------------------------------*/
INT NEAR KER_ModemWait()                            /* mbbx 0.81 */
{
   BYTE  theChar;

   if(!waitRcvChar(&theChar, (KER_timint * 10), 0, 0))
      KER_timeout = TRUE;                             /* rjs */

   return((INT) theChar);
}

/*---------------------------------------------------------------------------*/
/* KER_BufferFill() - fill up a buffer from file that is being sent    [rkh] */
/*---------------------------------------------------------------------------*/
INT NEAR KER_BufferFill(BYTE *buffer)
{
   INT   i = 0;                              /* Loop index */
   INT   bytes = 0;
   INT   t;                                  /* Char read from file */
   BYTE  t7;                                 /* 7-bit version of above */
   BYTE  t8;                                 /* 8-bit flag */

   /* myh swat: if all chars in the buffer have been transfered */
   if (KER_bytetran >= KER_buffsiz) 
   {
      /* read in the next buffer from the file */
      if ((KER_buffsiz = _lread(xferRefNo, KER_buffer, BUFFSIZE)) <= 0)
         return(EOF);
      /* reset the number of bytes transfered for next read in buffer */
      else
         KER_bytetran = 0;
   }   /* myh swat */

   /* myh swat: continue to fill the packet until the full packet size */
   /*           or the end of the read buffer                          */
   while ((i < KER_spsiz - 9) && (KER_bytetran < KER_buffsiz))
   {
      xferBytes--;
      t = KER_buffer[KER_bytetran++];   /* myh swat: check one char at a time */
      t7 = t & 0x7F;                    /* Get low order 7 bits */
      t8 = t & 0x80;

      if(KER_8flag && t8)                    /* do 8th bit quoting, this char */
      {
         buffer[i++] = KER_select8;
         t = t7;
      }

      if((t7 < SP) || (t7 == DEL))
      {
         buffer[i++] = KER_quote;
         t = ctl(t);
      }
      else if(t7 == KER_quote)
         buffer[i++] = KER_quote;
      else if(KER_8flag && (t7 == KER_select8)) 
         buffer[i++] = KER_quote;

      buffer[i++] = (BYTE)t;
   }

   buffer[i] = '\0';
   return(i);
}

/*---------------------------------------------------------------------------*/
/* KER_BufferEmpty() - decode an incoming packet                       [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_BufferEmpty(BYTE  *buffer, int len, BYTE  flag)
{
   INT   i;                                 /* Counter*/
   INT   KER_bufflen = 0;                   /* buffer length */
   BYTE  b8, t7, t;                         /* Character holder */
   BYTE  WriteBuffer[KER_MAXPACKSIZE];      /* myh swat: create a buffer so later can write */
                                            /*     the whole buffer instead of char by char */

   for(i=0; i<len; i++)                     /* Loop thru the data field */
   {
      t = buffer[i];                        /* Get character */
      b8 = 0;                               /* 8th bit flag */

      if(KER_8flag && (t == KER_select8))
      {
         b8 = 128;
         t = buffer[++i];
      }

      if(t == KER_QUOTE)                     /* Control quote? */
      {                                     /* Yes */
         t = buffer[++i];                   /* Get the quoted character */
         t7 = t & 127;
         if((t7 > 62) && (t7 < 96))
            t = ctl(t);
      }
      t |= b8;

      if((t == CR) && !KER_image)               /* Don't pass CR if in image mode */
         continue;
      switch (flag)
      {
      case KERFILE:
         WriteBuffer[KER_bufflen++] = t;   /* myh swat: store char to a buffer */         
         KER_bytes++;
         break;
      case KERSCREEN:
         modemInp(t, TRUE);
         KER_bytes++;
         break;
      case KERBUFF:
         KER_buff[KER_bufflen++] = t;
         break;
      }
   }

   /* myh swat: write the buffer to a file */
   if (flag == KERFILE)
         _lwrite(xferRefNo, WriteBuffer, KER_bufflen);   

   KER_buff[KER_bufflen] = 0;
}

/*---------------------------------------------------------------------------*/
/* KER_GetNextFile() - get next file in a file group                   [rkh] */
/*---------------------------------------------------------------------------*/
BOOL NEAR KER_GetNextFile()
{
   return FALSE;
}

/*---------------------------------------------------------------------------*/
/* KER_PrintErrPacket() - print an error packet                        [rkh] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_PrintErrPacket(BYTE  *msg)
{
   if(!answerMode)
   {
      LoadString(hInst, STR_KER_XFERABORT, (LPSTR)taskState.string, 80);  /* mbbx 1.04: REZ... */
      sprintf(outstr, taskState.string, msg);
      KER_PutScreenStr(outstr);
   }

   xferStopped = TRUE;
   return(KER_ABORT);                     /* abort */
}

/*---------------------------------------------------------------------------*/
/* KER_RcvPacketInit() - get the initalization stuff from other side   [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_RcvPacketInit(BYTE *data)
{
   BYTE tmp;

/* rjs swat 011 -> unpar()'d each of the characters in data[] per Altitude fix */
   KER_spsiz = unchar(unpar(data[0]));              /* Maximum send packet size */
   KER_timint = unchar(unpar(data[1]));             /* When I should time out */

   if(KER_timint == 0) 
      KER_timint = 32000;                    /* 32000 is close enough to infinite */
   else if((KER_timint > KER_MAXTIMEOUT) || (KER_timint < KER_MINTIMEOUT))
      KER_timint = (xferFlag == XFRBSND) ? KER_SNDTIMEOUT : KER_RCVTIMEOUT;

   KER_pad = unchar(unpar(data[2]));                /* Number of pads to send */
   KER_padchar = ctl(unpar(data[3]));               /* Padding character to send */

   if(trmParams.emulate != ITMDELTA)         /* (mbbx) for DELTA, send XOFF */
      KER_eol = unchar(unpar(data[4]));             /* EOL character I must send */

   KER_quote = unpar(data[5]);                      /* Incoming data quote character */
  
/* tge comment: we need to check the packet length before the next section
                to see if they even have the 8bit quote slot present */

   tmp = unpar(data[6]);
   if (KER_initState <= 0)         /* tgex */
   {  /* we are the receiver */
      if(tmp == 'Y')
      {
         if (KER_parflg)
         {
            KER_select8 = '&';
            KER_8flag = TRUE;
         }
         else
            KER_select8 = 'N';               /* KER_8flag stays FALSE */
      }
      else if(tmp == 'N')
        KER_select8 = 'N';                  /* KER_8flag stays FALSE */
      else if(((tmp > ' ') && (tmp < '?')) || 
               ((tmp > '_') && (tmp < DEL)))   /* jtf 3.20 this was > DEL */
      {
         KER_select8 = tmp;
         KER_8flag = TRUE;
      }
   }
   else
   {                                      /* we are the sender */
      if (KER_select8 == '&')
      {
         if ((tmp == '&') || (tmp == 'Y'))
            KER_8flag = TRUE;
      }
      else                                /* KER_select8 == 'Y' */
       if(((tmp > ' ') && (tmp < '?')) || 
            ((tmp > '_') && (tmp < DEL)))   /* jtf 3.20 this was > DEL */
         {
            KER_select8 = tmp;
            KER_8flag = TRUE;
         }
   }


  KER_initState = -1;

}

/*---------------------------------------------------------------------------*/
/* KER_SndPacketInit() - send the initalization stuff to other side     [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_SndPacketInit(BYTE *data)
{
   data[KER_INIT_MAXL] = tochar(KER_MAXPACKSIZE);     /* Biggest packet I can receive */

   data[KER_INIT_TIME] =                              /* When I want to be timed out */
      (xferFlag == XFRBSND) ? tochar(KER_SNDTIMEOUT) : tochar(KER_RCVTIMEOUT);

   data[KER_INIT_NPAD] = tochar(KER_NPAD);            /* How much padding I need */
   data[KER_INIT_PADC] = ctl(KER_PADCHAR);            /* Padding character I want */
   data[KER_INIT_EOL]  = tochar(KER_EOL);             /* End-Of-Line character I want */
   data[KER_INIT_QCTL] = KER_QUOTE;                   /* Control-Quote character I send */

   if (KER_initState >= 0)
   {                                            /* we are the sender */
      KER_select8 = (KER_parflg) ? '&' : 'Y';
   }
   else                                         /* we are the receiver */
   {
      if (KER_select8 == 'Y')                   /* they sent us yes */
      {
         if (KER_parflg)
         {
            KER_select8 = '&';
            KER_8flag = TRUE;
         }
         else
            KER_select8 = 'N';               /* KER_8flag stays FALSE */
      }
      else                                   /* they told us to quote */
         if(((KER_select8 > ' ') && (KER_select8 < '?')) || 
            ((KER_select8 > '_') && (KER_select8 < DEL)))
         {
            KER_select8 = data[6];
            KER_8flag = TRUE;
         }
   }

   data[KER_INIT_QBIN] = KER_select8;                 /* 8th bit quote char */
   data[KER_INIT_CHKT] = KER_BLOCKCHK1;
   data[KER_INIT_CHKT+1] = '\0';

   KER_initState = 1;
}


/*---------------------------------------------------------------------------*/
/* KER_PutScreenStr() - put data onto the screen                       [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_PutScreenStr(BYTE *data) 
{
   INT i;
#ifdef ORGCODE
   for(i=0; i<strlen(data); i++)
#else
   for(i=0; i< lstrlen(data); i++)
#endif
      modemInp(data[i], FALSE);

   modemInp(CR, FALSE);
   modemInp(LF, FALSE);
}

/*---------------------------------------------------------------------------*/
/* KER_bSetUp()                                                        [rkh] */
/*---------------------------------------------------------------------------*/
VOID NEAR KER_bSetUp(BYTE state)
{
   BYTE stateStr[2];

   *stateStr = state;
   stateStr[1] = 0;
}

/*---------------------------------------------------------------------------*/
/* KER_AutoPar()                                                       [tge] */
/*---------------------------------------------------------------------------*/
BYTE NEAR KER_AutoPar()
{
   switch(KER_parMask)
   {
      case 0x80:
         return(KER_EVENPARITY);
      case 0xC0:
         return(KER_MARKPARITY);
      case 0x40:
         return(KER_ODDPARITY);
      case 0x00:
         return(KER_NOPARITY);
      default:
         return(-1);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\kermit.h ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

BOOL  bKermitTaskRemote;                     /* slc nova 110 */
INT   gKermitTaskCMD;                        /* slc nova 110 */
LPSTR glpKermitTaskParm1;                    /* slc nova 110 */
LPSTR glpKermitTaskParm2;                    /* slc nova 110 */

/* basic file transfer packet types */
#define KER_ACK            'Y'
#define KER_NACK           'N'
#define KER_SEND           'S'
#define KER_INIT           'I'
#define KER_FILE           'F'
#define KER_TEXT           'X'
#define KER_ATTRIB         'A'
#define KER_DATA           'D'
#define KER_EOF            'Z'
#define KER_BREAK          'B'
#define KER_ERROR          'E'
#define KER_RCV            'R'
#define KER_COMMAND        'C'
#define KER_KERMIT         'K'
#define KER_TIMEOUT        'T'
#define KER_ERRCHK         'Q'

#define KER_CMPLT          'C'
#define KER_ABORT          'A'

#define KER_GENERIC        'G'

/* generic packet types */
#define KER_LOGIN          'I'
#define KER_CHDIR          'C'
#define KER_LOGOUT         'L'
#define KER_FINISH         'F'
#define KER_DIR            'D'
#define KER_FREE           'U'
#define KER_DEL            'E'
#define KER_TYPE           'T'
#define KER_REN            'R'
#define KER_COPY           'K'
#define KER_WHO            'W'
#define KER_MESSAGE        'M'
#define KER_HELP           'H'
#define KER_STATUS         'Q'
#define KER_PROGRAM        'P'
#define KER_JOURNAL        'J'
#define KER_VAR            'V'

#define KER_NOPARITY       '\0'
#define KER_ODDPARITY      'o'
#define KER_EVENPARITY     'e'
#define KER_MARKPARITY     'm'
#define KER_SPACEPARITY    's'

/* initialization packet subscripts and values */
#define KER_INIT_MAXL      0
#define KER_INIT_TIME      1
#define KER_INIT_NPAD      2
#define KER_INIT_PADC      3
#define KER_INIT_EOL       4
#define KER_INIT_QCTL      5
#define KER_INIT_QBIN      6
#define KER_INIT_CHKT      7
#define KER_INIT_REPT      8

#define KER_MAXPACKSIZE    94                /* Maximum packet size */
#define KER_RCVTIMEOUT     13                /* Seconds for receive time out */
#define KER_SNDTIMEOUT      8                /* Seconds for send time out */
#define KER_MAXTIMEOUT     60                /* Maximum timeout interval */
#define KER_MINTIMEOUT      2                /* Minumum timeout interval */
#define KER_NPAD            0                /* Number of padding characters I will need */
#define KER_PADCHAR         0                /* Padding character I need (NULL) */
#define KER_EOL            0x0D              /* End-Of-Packet character */
#define KER_QUOTE          '#'               /* Control prefix character */
#define KER_8BITPREFIX     '&'               /* Eighth bit prefix character */
#define KER_BLOCKCHK1      '1'               /* Block check type (1 byte) */
#define KER_BLOCKCHK2      '2'               /* Block check type (2 byte) */
#define KER_BLOCKCHK3      '3'               /* Block check type (3 byte) */

/* other kermit session constants */
#define KER_MAXRETRY       5                 /* Times to retry a packet */

/*  myh swat: set the buffer size for the number of bytes read in from file at a time */
#define BUFFSIZE           512

INT KER_bytetran;          /* myh swat: number of bytes transfered from the buffer */
INT KER_buffsiz;           /* myh swat: the buffer size read from the file; usually is */
                           /*     BUFFSIZE, but the last buffer size can be smaller    */
BYTE KER_buffer[BUFFSIZE]; /* myh swat: the buffer storing read in chars from file */
INT KER_debug;
BYTE KER_rem8bit;

typedef
   struct   {
      INT   KER_spsiz;        /* Maximum send packet size */
      INT   KER_timint;       /* Timeout for foreign host on sends */
      INT   KER_pad;          /* How much padding to send */
      BYTE  KER_padchar;      /* Padding character to send */
      BYTE  KER_eol;          /* End-Of-Line character to send */
      BYTE  KER_quote;        /* Quote character in incoming data */
      BYTE  KER_select8;      /* 8th bit quote character to send either 'Y' or '&'*/
            } KERPACKETSTRUCT;
typedef
   struct   {
      INT   KER_size;         /* Size of present data */
      INT   KER_rpsiz;        /* Maximum receive packet size */
      INT   KER_spsiz;        /* Maximum send packet size */
      INT   KER_pad;          /* How much padding to send */
      INT   KER_timint;       /* Timeout for foreign host on sends */
      INT   KER_n;            /* Packet number */
      INT   KER_numtry;       /* Times this packet retried */
      INT   KER_oldtry;       /* Times previous packet retried */
      INT   ttyfd;            /* File descriptor of tty for I/O, 0 if remote */
      INT   KER_remote;       /* -1 means we're a remote kermit */
      INT   KER_image;        /* -1 means 8-bit mode */
      INT   KER_parflg;       /* TRUE means use parity specified */
      INT   KER_turn;         /* TRUE means look for turnaround char (XON) */
      INT   KER_lecho;        /* TRUE for locally echo chars in connect mode */
      INT   KER_8flag;        /* TRUE means 8th bit quoting is done */
      INT   KER_pktdeb;       /* TRUE means log all packet to a file */
      INT   KER_filnamcnv;    /* -1 means do file name case conversions */
      INT   KER_filecount;    /* Number of files left to send */
      INT   KER_timeout;      /* TRUE means a timeout has occurred. */
      BYTE  KER_state;        /* Present state of the automaton */
      BYTE  KER_cchksum;      /* Our (computed) checksum */
      BYTE  KER_padchar;      /* Padding character to send */
      BYTE  KER_eol;          /* End-Of-Line character to send */
      BYTE  KER_escchr;       /* Connect command escape character */
      BYTE  KER_quote;        /* Quote character in incoming data */
      BYTE  KER_select8;      /* 8th bit quote character to send either 'Y' or '&'*/
      BYTE  KER_firstfile;
      BYTE  KER_getflag;
      BYTE  **KER_filelist;         /* List of files to be sent */
      BYTE  *KER_filnam;            /* Current file name */
      BYTE  recpkt[KER_MAXPACKSIZE];     /* Receive packet buffer */
      BYTE  packet[KER_MAXPACKSIZE];     /* Packet buffer */
      BYTE  KER_buff[KER_MAXPACKSIZE];   /* buffer for translations */
      BYTE  outstr[80];             /*output string for debugging and translations */
      BYTE  KERRCVFLAG;             /* direct recieved buffers to screen, file or buffer*/

      LONG  KER_bytes;              /* number of bytes received */
            } KERMITSTRUCT;

BOOL FAR  KER_Receive(BOOL);
BYTE NEAR KER_ReceiveInit();
BYTE NEAR KER_ReceiveFile();
BYTE NEAR KER_ReceiveData();

BOOL FAR  KER_Send();
BYTE NEAR KER_SendInit();
BYTE NEAR KER_SendFile();
BYTE NEAR KER_SendData();
BYTE NEAR KER_SendGeneric(BYTE lKER_state);

VOID NEAR KER_Init(BYTE state);
INT  NEAR KER_GetParity();
INT  NEAR KER_GetTurnAroundTime();
INT  NEAR KER_GetLocalEcho();
BYTE NEAR KER_Abort(WORD msgID);
BYTE NEAR KER_DoParity (BYTE ch);
VOID NEAR KER_SndPacket(BYTE type, INT num, INT len, BYTE *data);
BYTE NEAR KER_RcvPacket(INT*, INT*, BYTE*);
BYTE NEAR KER_CInChar();
BYTE NEAR KER_InChar();
INT  NEAR KER_ModemWait();
INT  NEAR KER_BufferFill(BYTE*);
VOID NEAR KER_BufferEmpty(BYTE buffer[],INT len,BYTE flag);
BOOL NEAR KER_GetNextFile();
BYTE NEAR KER_PrintErrPacket(BYTE*);
VOID NEAR KER_RcvPacketInit(BYTE*);
VOID NEAR KER_SndPacketInit(BYTE*);
VOID FAR  KER_Answer();
VOID FAR  KER_Server(BYTE, INT, INT);
VOID NEAR KER_DoGenericPack(BYTE*, INT, INT);
BOOL NEAR KER_DoDir(BYTE*);
INT_PTR APIENTRY dbKerRemote(HWND, UINT, WPARAM, LPARAM);
BOOL NEAR KER_RemoteParamsOK(HWND, INT);
VOID NEAR KER_DoRemoteShow(HWND, INT);
VOID NEAR KER_Remote(HWND, INT);
BYTE NEAR KER_Tinit();
INT  NEAR KER_Encode(BYTE*, BYTE*, INT);
VOID NEAR KER_Pack(HWND, BYTE, INT, INT);
VOID NEAR KER_HandleTrans();
VOID NEAR KER_PutScreenStr(BYTE*);
VOID NEAR KER_bSetUp(BYTE state);
BYTE NEAR KER_AutoPar();                        /* tge gold 01 */
VOID NEAR KER_ResetFromRemote();                /* tge gold 01 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\keyboard.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"


/*---------------------------------------------------------------------------*/
/* KEYBOARD REMAPPING ROUTINES (and DATA)                              [mbb] */
/*---------------------------------------------------------------------------*/

#define KEYMAP                   struct tagKeyMap
#define LPKEYMAP                 KEYMAP FAR *

struct tagKeyMap
{
   BYTE  scanCode[256];
   INT   virtKey[8][256];
   WORD  dataBytes;
};

HANDLE   hKeyMap;


VOID keyMapInit()                            /* mbbx 1.04: all new... */
{
   hKeyMap = NULL;
   keyMapState = 0;
}


VOID keyMapCancel()
{
   if(hKeyMap != NULL)
      hKeyMap = GlobalFree(hKeyMap);
}

BOOL NEAR keyMapSetState(WPARAM wParam)
{
   keyMapState = 0;

   if(GetKeyState(VK_SHIFT) & 0x8000)
      keyMapState |= VKS_SHIFT;
   if(GetKeyState(VK_CONTROL) & 0x8000)
      keyMapState |= VKS_CTRL;
   if(GetKeyState(VK_MENU) & 0x8000)
      keyMapState |= VKS_ALT;

   keyMapState |= (keyMapState >> 8);

   return(((wParam >= VK_SHIFT) && (wParam <= VK_MENU)) ? TRUE : FALSE);
}


BOOL keyMapTranslate(WPARAM *wParam, LPARAM *lParam, STRING *mapStr)
{
   BOOL        keyMapTranslate = FALSE;
   LPKEYMAP    lpKeyMap;
   WORD        wVirtKey;
   LPINT       lpVirtKey;
   LPSTR       lpKeyData;

   if(hKeyMap == NULL)
   {
      keyMapSetState(*wParam);
      return(FALSE);
   }

   if((lpKeyMap = (LPKEYMAP) GlobalLock(hKeyMap)) == NULL)
   {
      return(FALSE);
   }

   if((wVirtKey = lpKeyMap->scanCode[(*lParam >> 16) & 0x00FF]) != 0)
      *wParam = wVirtKey;

   if(keyMapSetState(*wParam))
      return(FALSE);

   lpVirtKey = &lpKeyMap->virtKey[keyMapState >> 8][*wParam & 0x00FF];

   if(*lpVirtKey != -1)
   {
      if((*lpVirtKey & 0xF000) == 0xF000)
      {
         keyMapState = (*lpVirtKey & 0x0700) | (keyMapState & 0x00FF);
         *wParam = (*lpVirtKey & 0x00FF);
      }
      else
      {
         if(mapStr != NULL)
         {
            if(*lpVirtKey & 0x8000)
            {
               *mapStr = 1;
               mapStr[1] = (BYTE) *lpVirtKey;
            }
            else
            {
               lpKeyData = ((LPSTR) lpKeyMap) + sizeof(KEYMAP) + *lpVirtKey;
               lmovmem(lpKeyData, (LPSTR) mapStr, *lpKeyData+1);
            }
            mapStr[*mapStr+1] = 0;
         }

         keyMapTranslate = TRUE;
      }
   }

   GlobalUnlock(hKeyMap);
   return(keyMapTranslate);
}

//
// Brain Dead mucking with our lParam values or CHARS
// Causes TranslateMessage to fail.  -JohnHall for WLO
//
VOID NEAR keyMapSendMsg(MSG   *msg, WPARAM wParam, BOOL  bKeyDown)
{
   /*
   msg->message = (bKeyDown ? WM_KEYDOWN : WM_KEYUP);

   	
   if(keyMapState & VKS_ALT)
   {
	msg->message += (WM_SYSKEYDOWN - WM_KEYDOWN);
   }

   TranslateMessage(msg);

   DefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam);
   */ 

   
   if (bKeyDown) {
      msg->message &= ~0x0001;
   } else {
      msg->message |= 0x0001;
   }                                                                   
   TranslateMessage(msg);
   //DbgPrint("msg.msg %x msg.wparam %x msg.lparam %lx\n",
   //	     msg->message, msg->wParam, msg->lParam);
   DefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam);
   
}


VOID keyMapKeyProc(HWND  hWnd, WORD message, WPARAM wParam, LPARAM lParam)  // sdj: AltGr
{
   BOOL  bSetState;
   BYTE  keyState[256], newKeyState[256];
   MSG   msg;

   if(bSetState = ((keyMapState & (VKS_SHIFT | VKS_CTRL | VKS_ALT)) != 
                   ((keyMapState << 8) & (VKS_SHIFT | VKS_CTRL | VKS_ALT))))
   {
      GetKeyboardState((LPSTR) keyState);
      memcpy(newKeyState, keyState, 256);

      newKeyState[VK_SHIFT]   = (keyMapState & VKS_SHIFT) ? 0x81 : 0x00;
      newKeyState[VK_CONTROL] = (keyMapState & VKS_CTRL) ? 0x81 : 0x00;
      newKeyState[VK_MENU]    = (keyMapState & VKS_ALT) ? 0x81 : 0x00;

      SetKeyboardState((LPSTR) newKeyState);
   }

   msg.hwnd = hWnd;
   msg.wParam = wParam;
   msg.lParam = lParam;
   msg.message = message;  //sdj AltGr
   keyMapSendMsg(&msg, wParam, (lParam & (1L << 31)) ? FALSE : TRUE);

   if(bSetState)
      SetKeyboardState((LPSTR) keyState);
}


BOOL keyMapSysKey(HWND	hWnd, WORD message, WPARAM	*wParam, LPARAM lParam) //sdj: AltGr
{
   MSG   msg;

   if((*wParam >= VK_SHIFT) && (*wParam <= VK_MENU))
   {
      msg.hwnd = hItWnd;
      msg.wParam = *wParam;
      msg.lParam = lParam;
      msg.message = message;  //sdj: AltGr
      keyMapSendMsg(&msg, *wParam, (lParam & (1L << 31)) ? FALSE : TRUE);
      return(TRUE);
   }

   if(keyMapState & VKS_CTRL)
   {

/* jtf 3.30      if(*wParam == VK_TAB)
      {
         return(TRUE);
      }
      else  */

      if((*wParam >= VK_F1) && (*wParam <= VK_F10))
      {
         if(!(lParam & (1L << 31)))
         {
            if(keyMapState & VKS_ALT)
               selectFKey(IDFK1+((UINT)*wParam-VK_F1));
/* jtf 3.30            else if(hWnd != hItWnd)
            {
               switch(*wParam)
               {
               case VK_F4:
                  *wParam = SC_CLOSE;
                  break;
               case VK_F5:
                  *wParam = SC_RESTORE;
                  break;
               case VK_F6:
                  makeActiveNext(keyMapState & VKS_SHIFT);
                  return(TRUE);
               case VK_F7:
                  *wParam = SC_MOVE;
                  break;
               case VK_F8:
                  *wParam = SC_SIZE;
                  break;
               case VK_F10:
                  *wParam = SC_MAXIMIZE;
                  break;
               }
               SendMessage(hWnd, WM_SYSCOMMAND, *wParam, 0L);
            }
*/
         }

         return(TRUE);
      }
   }
   else
   if(keyMapState & VKS_ALT)
   {
      switch(*wParam)
      {
      case VK_BACK:                          /* ALT BACK -> UNDO */
	 keyMapKeyProc(hWnd, message , *wParam, lParam); //sdj: AltGr
         return(TRUE);

      case VK_F1:
      case VK_F2:
         *wParam += 10;
         keyMapState &= ~VKS_ALT;
         break;

      case VK_F4:
      case VK_F5:
      case VK_F6:
      case VK_F7:
      case VK_F8:
      case VK_F9:
      case VK_F10:
         DefWindowProc(hItWnd, !(lParam & (1L << 31)) ? WM_SYSKEYDOWN : WM_SYSKEYUP, *wParam, lParam);
         return(TRUE);

      default:
	 keyMapKeyProc(hItWnd, message, *wParam, lParam); // sdj: AltGr
         return(TRUE);
      }
   }

   return(FALSE);
}

/*---------------------------------------------------------------------------*/
/* classifyKey() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

#define TKS_IDPGUP               0           /* mbbx 2.00 ... */
#define TKS_IDLEFT               4
#define TKS_IDINSERT             8
#define TKS_IDNUMERIC0           10
#define TKS_IDF1                 26
#define TKS_IDSHIFTF1            38

INT classifyKey(WORD  vrtKey)
{
   INT   classifyKey = TERMINALFKEY;

   switch(vrtKey)
   {
   case VK_CANCEL:
      if(keyMapState & VKS_CTRL)
         classifyKey = ((keyMapState & VKS_SHIFT) ? LONGBREAK : SHORTBREAK);
      else
         classifyKey = STANDARDKEY;
      break;

   case VK_PRIOR:
   case VK_NEXT:
   case VK_END:
   case VK_HOME:
   case VK_LEFT:
   case VK_UP:
   case VK_RIGHT:
   case VK_DOWN:
      /* rjs - add test for trmParams.useWinCtrl */   
      if(!((GetKeyState(0x91) & 0x0001) || trmParams.useWinCtrl))
         seqTableNdx = (vrtKey - VK_PRIOR) + TKS_IDPGUP;
      else
         classifyKey = SCROLLKEY;
      break;

   case VK_SELECT:
      seqTableNdx = (VK_END - VK_PRIOR) + TKS_IDPGUP;
      break;

   case VK_INSERT:
      classifyKey = (!(keyMapState & (VKS_CTRL | VKS_SHIFT)) ? TERMINALFKEY : STANDARDKEY);
      seqTableNdx = TKS_IDINSERT;
      break;

   case VK_DELETE:
      classifyKey = (!(keyMapState & VKS_SHIFT) ? TERMINALFKEY : STANDARDKEY);
      seqTableNdx = (VK_DELETE - VK_INSERT) + TKS_IDINSERT;
      break;

   case VK_NUMPAD0:
   case VK_NUMPAD1:
   case VK_NUMPAD2:
   case VK_NUMPAD3:
   case VK_NUMPAD4:
   case VK_NUMPAD5:
   case VK_NUMPAD6:
   case VK_NUMPAD7:
   case VK_NUMPAD8:
   case VK_NUMPAD9:
   case VK_MULTIPLY:
   case VK_ADD:
   case VK_SEPARATOR:
   case VK_SUBTRACT:
   case VK_DECIMAL:
   case VK_DIVIDE:
      seqTableNdx = (vrtKey - VK_NUMPAD0) + TKS_IDNUMERIC0;
      break;

   case VK_F1:
   case VK_F2:
   case VK_F3:
   case VK_F4:
   case VK_F5:
   case VK_F6:
   case VK_F7:
   case VK_F8:
   case VK_F9:
   case VK_F10:
   case VK_F11:
   case VK_F12:
      /* rjs - add test for trmParams.useWinCtrl */   
      if(!((GetKeyState(0x91) & 0x0001) || trmParams.useWinCtrl))
            {
            if (vrtKey==VK_F1)
               doCommand(hTermWnd, HMINDEX, 0);
            classifyKey = STANDARDKEY;
            break;
            } 
      seqTableNdx = (vrtKey - VK_F1) + (!(keyMapState & VKS_SHIFT) ? TKS_IDF1 : TKS_IDSHIFTF1);
      break;
   case VK_F13:
   case VK_F14:
   case VK_F15:
   case VK_F16:
      seqTableNdx = (vrtKey - VK_F13) + TKS_IDSHIFTF1;
      break;
   default:
      classifyKey = STANDARDKEY;
      break;
   }

   return(classifyKey);
}


/*---------------------------------------------------------------------------*/
/* keyPadSequence() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

BOOL keyPadSequence()
{
   INT      ndx;
   LPBYTE   emulKeyBase;
   BYTE     keyPadByte;

   if(!(emulKeyBase = GlobalLock(hemulKeyInfo)))
      return(FALSE);

   emulKeyBase += (seqTableNdx * KEYSEQLEN);
   *keyPadString = 0;
   for(ndx = 0; *(emulKeyBase + ndx) != 0; ndx++)
      keyPadString[++(*keyPadString)] = *(emulKeyBase + ndx);
   GlobalUnlock(hemulKeyInfo);

   if((trmParams.emulate >= ITMVT52) && (trmParams.emulate <= ITMVT220))
   {
      if(((seqTableNdx >= TKS_IDLEFT) && (seqTableNdx < TKS_IDINSERT)) && cursorKeyMode)
      {
         switch(trmParams.emulate)
         {
         case ITMVT100:
            keyPadString[2] = 0x4F;
            break;
         }
      }
      else if(((seqTableNdx >= TKS_IDNUMERIC0) && (seqTableNdx < TKS_IDF1)) && !keyPadAppMode)
      {
         switch(seqTableNdx)
         {
         case TKS_IDNUMERIC0+10:
            keyPadByte = '-';
            break;
         case TKS_IDNUMERIC0+11:
            keyPadByte = CR;
            break;
         case TKS_IDNUMERIC0+12:
            keyPadByte = ' ';
            break;
         case TKS_IDNUMERIC0+13:
            keyPadByte = ',';
            break;
         case TKS_IDNUMERIC0+14:
            keyPadByte = '.';
            break;
         case TKS_IDNUMERIC0+15:
            keyPadByte = ' ';
            break;
         default:
            keyPadByte = (seqTableNdx - TKS_IDNUMERIC0) + '0';
            break;
         }

         keyPadString[*keyPadString = 1] = keyPadByte;
      }
   }

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* sendKeyInput() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL sendKeyInput(BYTE  theByte)
{

   switch(kbdLock)
   {
   case KBD_ECHO:
      modemInp(theByte, FALSE);              /* mbbx 1.10 */
      break;

   default:
      modemWr(theByte);
      break;
   }

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\fsemacro.h ===
// bjw Win16 <-> Win32 compatibility macros

#include <direct.h>                             // dwb KtoA
#include <stdlib.h>                             // dwb KtoA
#include <io.h>                                 // dwb KtoA
#include <memory.h>                             // dwb KtoA
#include <string.h>                             // dwb KtoA

#ifdef OLDCODE
typedef UINT WPARAM;                            // dwb KtoA

#define MAINENTRY                               APIENTRY
// bjw Win16 <-> Win32 compatibility macros
#define MAINENTRY                               APIENTRY
#define huge                                    FAR
#define WINAPI                                  APIENTRY

#define GET_WM_COMMAND_ID(wParam, lParam)       ((WORD) (wParam))
#define GET_WM_COMMAND_HWND(wParam, lParam)     ((HWND) lParam)
#define GET_WM_COMMAND_CMD(wParam, lParam)      ((WORD) HIWORD(wParam))
#define PACK_WM_COMMAND_WPARAM(w1, w2)          ((UINT) MAKELONG(w1, 2))
#define MAKE_MOUSE_POINT(l)                     (*((POINTS FAR *)&(l)))
#define MDI_CREATE(hwnd, long)                  ((HWND) SendMessage(hwnd, WM_MDICREATE, (UINT) 0, (LONG)long))
#define GET_MDI_ACTIVE(hwnd, w, l)              ((HWND) SendMessage(hwnd, WM_MDIGETACTIVE, (UINT) 0, 0L))
#define MDI_SETMENU(hwnd, a, b)                 ((HMENU) SendMessage(hwnd, WM_MDISETMENU, (UINT) a, (LONG) b))
#define MDI_TILE(hwnd)                          ((LONG) SendMessage(hwnd, WM_MDITILE, (UINT) 0, 0L))
#define GET_WM_CTLCOLOR_HWND(w, l)              ((HWND)  l)
#define DLGDIRSELECT(hwnd, lpsz, ncnt, nid)     ((BOOL)DlgDirSelectEx(hwnd, lpsz, ncnt, nid))
#define DIRSELECTCB(hwnd, lpsz, ncnt, nid)      ((BOOL)DlgDirSelectComboBoxEx(hwnd, lpsz, ncnt, nid))
#define GET_HMODULE(hwnd)                                      ((HMODULE) GetWindowLong(hwnd, GWL_HINSTANCE))
#define GET_HWNDPARENT(hwnd)                    ((HWND) GetWindowLong(hwnd, GWL_HWNDPARENT))
#define GET_ID(hwnd)                            ((UINT) GetWindowLong(hwnd, GWL_ID))
#define GET_WW(hwnd, ndx)                       ((UINT) GetWindowLong(hwnd, ndx))
#define SET_WW(hwnd, ndx, val)                  ((UINT) SetWindowLong(hwnd, ndx, (LONG) val));
#define MOVE_TO(hdc, x, y)                      ((BOOL) MoveToEx(hdc, x, y, NULL))
#define MoveTo(hdc, x, y)                       ((BOOL) MoveToEx(hdc, x, y, NULL))
#define GET_CLASS_HCURSOR(hwnd)                 ((HCURSOR) GetClassLong(hwnd, GCL_HCURSOR))
#define GET_CLASS_HICON(hwnd)                   ((HCURSOR) GetClassLong(hwnd, GCL_HICON))
#define SET_CLASS_HCURSOR(hwnd, h)              ((HCURSOR) SetClassLong(hwnd, GCL_HCURSOR, (LONG) h))
#define SET_CLASS_HICON(hwnd, h)                ((HCURSOR) SetClassLong(hwnd, GCL_HICON, (LONG) h))

#define GET_WM_MENUSELECT_ID(w, l)              ((WORD) w)
#define GET_WM_MENUSELECT_CMD(w, l)             ((WORD) HIWORD(l))
#define GET_WM_MENUSELECT_HMENU(w, l)           ((HMENU) l)
#define GET_WM_ACTIVATE_HWND(w, l)              ((HWND) l)
#define SET_BRUSH_ORG(hdc, x, y)                ((BOOL) SetBrushOrg(hdc, x, y, NULL))

#define GET_WM_HSCROLL_POSITION(w, l)           ((WORD) HIWORD(w))  // dwb KtoA  for 16-bit: #define GET_WM_HSCROLL_POSITION(w, l)           ((WORD) LOWORD(l)) 
#define GET_WM_VSCROLL_POSITION(w, l)           ((WORD) HIWORD(w))  // dwb KtoA  for 16-bit: #define GET_WM_VSCROLL_POSITION(w, l)           ((WORD) LOWORD(l)) 

#define SET_WINDOW_EXT(hdc, x, y)               ((BOOL) SetWindowExtEx(hdc, x, y, NULL))
#define SetWindowExt(hdc, x, y)                 ((BOOL) SetWindowExtEx(hdc, x, y, NULL))
#define SET_WINDOW_ORG(hdc, x, y)               ((BOOL) SetWindowOrgEx(hdc, x, y, NULL))
#define SetWindowOrg(hdc, x, y)                 ((BOOL) SetWindowOrgEx(hdc, x, y, NULL))
#define SET_VIEWPORT_EXT(hdc, x, y)             ((BOOL) SetViewportExtEx(hdc, x, y, NULL))
#define SetViewportExt(hdc, x, y)               ((BOOL) SetViewportExtEx(hdc, x, y, NULL))
#define SET_VIEWPORT_ORG(hdc, x, y)             ((BOOL) SetViewportOrgEx(hdc, x, y, NULL))
#define SetViewportOrg(hdc, x, y)               ((BOOL) SetViewportOrgEx(hdc, x, y, NULL))

LONG FSE_filelength(int hFile);

#define ODS(s)  OutputDebugString(s); OutputDebugString("\n");
#endif // oldcode
// x86 asembly replacements
#define lmovmem(s, d, l)                        memcpy(d, s, l)
#define lsetmem(s, b, l)                        memset(s, b, l)



#ifdef OLDCODE
//--------------------------------------------------------------------------
//-- obsolete functions
//--------------------------------------------------------------------------
#define  CloseSound()
#define  CountVoiceNotes(n)                     ((int) 0)
#define  GetWinFlags()                          ((DWORD) 0)
#define  OpenSound()                            ((int) 0)
#define  SetVoiceAccent(n1,n2,n3,n4,n5)         ((int) 0)
#define  SetVoiceNote(n1, n2, n3, n4)           ((int) 0)
#define  StartSound()                           ((int) 0)
#define  StopSound()                            ((int) 0)
#define  LockData()                             (0)
#define  UnlockData()                           (0)
#define  AccessResource()                       (0)
#define  SetResourceHandler()                   (0)


//--------------------------------------------------------------------------
//-- comm functions that need to be replaced by Windows NT comm functions
//--------------------------------------------------------------------------
#define CloseComm()                             (0)
#define FlushComm()                             (0)
#define GetCommError()                          (0)
#define OpenComm()                              (0)
#define ReadComm()                              (0)
#define SetCommEventMask()                      (0)
#define WriteComm()                             (0)


//--------------------------------------------------------------------------
//-- FSE functions not portable to NT
//--------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\mdmutil.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  USECOMM

#include <stdarg.h>
#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "connect.h"

/*---------------------------------------------------------------------------*/
/* mdmConnect() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

/* NOTE: PATCH until WIN COMM DRV is fixed!!! */

#define DEB_MSR_OFFSET           35          /* mbbx 1.10: carrier... */
#define DEB_MSR_RLSD             0x80

BOOL mdmConnect()                            /* mbbx 2.00: network... */
{
   BOOL     bRc,bCarrier = FALSE;
   // -sdj unreferenced local var: LPBYTE	lpMSR;
   DWORD    dwModemStatus;

   if(trmParams.fCarrier)
   {
      switch(trmParams.comDevRef)
      {
      case ITMWINCOM:
        DEBOUT("mdmConnect: %s\n","Calling getmodemstatus to see rlsd!");
        bRc = GetCommModemStatus(sPort,&dwModemStatus);
        DEBOUT("mdmConnect: rc of getmodemstatus = %lx\n",bRc);
        DEBOUT("mdmConnect: dw of getmodemstatus = %lx\n",dwModemStatus);
        if (!bRc)
        {
            DEBOUT("mdmconnect: %s\n","getmodemstatus failed, setting bCar=TRUE");
            bCarrier = TRUE;
        }
        else
        {
            bCarrier = (dwModemStatus & MS_RLSD_ON) ? TRUE : FALSE;
            DEBOUT("mdmconnect: bCarrier is set as:  %lx\n",bCarrier);
        }
	    break;

      default:
         bCarrier = TRUE;
         break;
      }

      if(mdmOnLine != bCarrier)
      {
         if(!(mdmOnLine = bCarrier))
         {
         }

         return(TRUE);
      }
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* modemReset() - Send XON character to the serial port.               [mbb] */
/*---------------------------------------------------------------------------*/

VOID modemReset()                            /* mbbx 2.00: network... */
{
   switch(trmParams.comDevRef)
   {
   case ITMWINCOM:
      switch(trmParams.flowControl)
      {
      case ITMXONFLOW:
         DEBOUT("modemReset: Esccom(SETXON) on comport=%lx\n",sPort);
         EscapeCommFunction(sPort, SETXON);
         break;
      case ITMHARDFLOW:
         DEBOUT("modemReset: Esccom(SETRTS) on comport=%lx\n",sPort);
         EscapeCommFunction(sPort, SETRTS);
         break;
      }
      break;

   }

   sPortErr = FALSE;
}


/*---------------------------------------------------------------------------*/
/* modemBreak() - Send BREAK signal to the serial port.                [mbb] */
/*---------------------------------------------------------------------------*/

/* NOTE: units for modemSendBreak are approx. 1/9 secs ( = 7 ticks)          */
/*---------------------------------------------------------------------------*/
/* VT100 standards for BREAK signals are as follows:                         */
/*                                                                           */
/*       short break:         0.233 sec   =    2 units                       */
/*        long break:         3.500 sec   =   30 units                       */
/*                                                                           */

VOID modemSendBreak(INT   nCount)
{
   DCB      dcb;                             /* slc nova 051 */

   switch(trmParams.comDevRef)
   {
   case ITMWINCOM:
      if(nCount > 2)                         /* slc nova 051 moved... */
      {
         if(GetCommState(sPort, (DCB FAR *)&dcb) == 0)   /* slc nova 051 */
         {
            dcb.fRtsControl = RTS_CONTROL_DISABLE;
            dcb.fDtrControl = DTR_CONTROL_DISABLE;
            EscapeCommFunction(sPort,CLRRTS);
            EscapeCommFunction(sPort,CLRDTR);

            if(!SetCommState(sPort,(DCB FAR *)&dcb))
                {
                }
         }
      }

DEBOUT("modemSendBrk:EscapeCommFunction(sPort, SETBREAK), DelayStart..for port=%lx\n",sPort);
      EscapeCommFunction(sPort, SETBREAK);
      delay(nCount*7, NULL);
DEBOUT("modemSendBrk:DelayOver...EscapeCommFunction(sPort, CLRBREAK)for port=%lx\n",sPort);
      EscapeCommFunction(sPort, CLRBREAK);

      if(nCount > 2)                         /* slc nova 051 moved... */
      {
         if(GetCommState(sPort, (DCB FAR *)&dcb) == 0)   /* slc nova 051 */
         {
            dcb.fRtsControl  = RTS_CONTROL_ENABLE;
            dcb.fDtrControl  = DTR_CONTROL_ENABLE;
            EscapeCommFunction(sPort,SETRTS);
            EscapeCommFunction(sPort,SETDTR);
  DEBOUT("modemSendBreak: set fRtsDtrdisable to false: for port=%lx\n",sPort);
            if(!SetCommState(sPort,(DCB FAR *)&dcb))
                {
  DEBOUT("FAIL: modemSendBreak: set fRtsDtrdisable to false: for port=%lx\n",sPort);
                }
         }
      }
      break;

   case  ITMDLLCONNECT:                      /* rjs bug2 */
      DLL_modemSendBreak(ghCCB, nCount);
      break;

   }/* switch */

   resetSerial(&trmParams, FALSE, FALSE, 0);
}


/*---------------------------------------------------------------------------*/
/* modemBytes() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR WIN_modemBytes()                   /* mbbx 2.00: network... */
{
   // -sdj unreferenced local var: INT	i;
   LPBYTE      ltmp;
   COMSTAT     serInfo;
   DWORD       dwErrors;
   DWORD       dwBytesRead;
   OVERLAPPED  overlap;
   BOOL        bRc;

   overlap.hEvent       = overlapEvent;
   overlap.Internal     = 0;
   overlap.InternalHigh = 0;
   overlap.Offset       = 0;
   overlap.OffsetHigh   = 0;

   ResetEvent(overlapEvent);

   gotCommEvent = FALSE;

   bRc = ReadFile(sPort, serBytes+1, LOCALMODEMBUFSZ-1,
                 (LPDWORD)&serCount, (LPOVERLAPPED)&overlap);

   if(!bRc && ((dwErrors = GetLastError()) != ERROR_IO_PENDING))
   {
      bRc = ClearCommError(sPort, &dwErrors, &serInfo); /* reset after error */

      if(trmParams.flowControl == ITMHARDFLOW)
      {
         if(serInfo.cbInQue < 100)
         {
            modemReset();
         }
      }

      if(serInfo.fXoffSent || serInfo.fCtsHold || serInfo.fDsrHold)
      {
         if(serInfo.cbInQue < 100)
         {
            modemReset();
         }
      }
   }
   else
   {
      if(!bRc && ((dwErrors = GetLastError()) == ERROR_IO_PENDING))
      {
         bRc = ClearCommError(sPort, &dwErrors, &serInfo);
      }

      if(!GetOverlappedResult(sPort, &overlap, &dwBytesRead, FALSE))
         return;

      if(serCount = dwBytesRead)
      {
         ltmp = serBytes+1;

         if(serCount != LOCALMODEMBUFSZ-1)
         {
            bRc = ClearCommError(sPort, &dwErrors, &serInfo); /* reset after error */

            if(trmParams.flowControl == ITMHARDFLOW)     /* rjs bug2 003 */
            {
               if(serInfo.cbInQue < 100)
               {
                  modemReset();
               }
            }

            if(serInfo.fXoffSent || serInfo.fCtsHold || serInfo.fDsrHold)
            {
               if(serInfo.cbInQue < 100)
               {
                  modemReset();
               }
            }
	 }  /* if readfile cameout halfway through */
	 else
	 {
	    gotCommEvent = TRUE;   /* we read a full buffer, try again..*/
	 }

      }
   } /* readfile succeded lets see the bytes read */
}


INT modemBytes()                            /* mbbx 2.00: network... */
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;	     /* slc nova 031 */
   BYTE  tmp1[TMPNSTR+1];
   BYTE  tmp2[TMPNSTR+1];



   if(serNdx > 0)
      return(serCount - (serNdx-1));

   switch(trmParams.comDevRef)
   {
   case ITMWINCOM:


   //-sdj comments from checkcommevent():
   //-sdj for telnet-quit processing
   //-sdj if this is a telnet connection which was opened before and
   //-sdj the user hits cntl-c/bye/quit etc
   //-sdj the telnet service will stop talking
   //-sdj with us, but terminalapp still keeps
   //-sdj doing io without knowing that the handle
   //-sdj can only be closed now, The way we can
   //-sdj detect this is, to check if getlasterror
   //-sdj is ERROR_NETNAME_DELETED, if this is the
   //-sdj case then we should do exactly same thing
   //-sdj which we do when the user tries to go to
   //-sdj some other comm port, close this one, and
   //-sdj go to the next one.
   //-sdj by setting bPortDisconnected to TRUE,
   //-sdj further modemBytes()[reads] will stop on
   //-sdj this port, and modemBytes will prompt the
   //-sdj user to select some other port, and return.


   if (bPortDisconnected)
      {
      LoadString(hInst, STR_PORTDISCONNECT, (LPSTR) tmp1, TMPNSTR);
      LoadString(hInst, STR_ERRCAPTION, (LPSTR) tmp2, TMPNSTR);
      MessageBox(hItWnd, (LPSTR) tmp1, (LPSTR)tmp2, MB_OK | MB_APPLMODAL);
      serCount = 0;  //so that return dword is 0, no chars to process
      // resetSerial(&trmParams, FALSE,TRUE,0);
      if(!trmParams.fResetDevice)
	 trmParams.newDevRef = trmParams.comDevRef;
      exitSerial();
      doSettings(IDDBCOMM, dbComm);
      break;
      }

       if(gotCommEvent)
      {
         WIN_modemBytes();
      }
      else
         serCount = 0;

      break;

   case ITMDLLCONNECT:                       /* slc nova 012 bjw nova 002 */
      serCount = DLL_ConnectBytes(ghCCB);    /* slc nova 031 */
      if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(ghCCB)) != NULL) /* slc nova 031 */
      {
         if(serCount == CONNECT_READ_ERROR)
            serCount = lpCCB->wReadBufferRead;

         lmovmem((LPSTR)lpCCB->lpReadBuffer, (LPSTR)(serBytes + 1), (WORD)serCount);
         GlobalUnlock(ghCCB);
      }
      break;
   }

   if(serCount > 0)
      serNdx = 1;                            /* indicates chars to process */

   return(serCount);
}


/*---------------------------------------------------------------------------*/
/* getMdmChar() - Get a modem character out of local buffer.           [mbb] */
/*---------------------------------------------------------------------------*/

/* NOTE:  modemBytes() must be called prior to this routine */

BYTE getMdmChar(BOOL  bText)
{
   BYTE nextChar;

   nextChar = serBytes[serNdx++];
   if(serNdx > serCount)
      serNdx = 0;

   if(trmParams.parity != ITMNOPARITY)
      nextChar &= 0x7F;

   if(bText && (trmParams.language > ICS_NONE) && (termState == NULL))  /* mbbx 1.06A: ics new xlate... */
   {
      if(nextChar >= 0x80)                   /* slc swat */
      {
         if(trmParams.setIBMXANSI)
            nextChar = ansiXlateTable[nextChar];   /* IBM extended to ANSI */
      }
      else
      {
         if(trmParams.language > ICS_NONE)
            nextChar = icsXlateTable[nextChar];    /* ISO char to ANSI */
      }
   }

   return(nextChar);
}


/*---------------------------------------------------------------------------*/
/* getRcvChar() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL getRcvChar(BYTE  *theChar, BYTE  charMask)
{
   if(modemBytes())
   {
      *theChar = getMdmChar(FALSE);

      if(charMask != 0)
         *theChar &= charMask;

      return(TRUE);
   }

   *theChar = 0;
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* waitRcvChar() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BOOL waitRcvChar(BYTE  *theChar, WORD  timeOut, BYTE  charMask, BYTE  charFirst, ...)
{
   va_list  ap;
   DWORD    waitTicks; //-sdj was LONG, getcurrenttime,tickcount returns dword
		       //-sdj this was causing a sign/unsign warning noise
   BYTE     charList;

   waitTicks = tickCount() + (timeOut * 6);
   repeat
   {
      va_start(ap,charFirst);
      updateTimer();

      if(doneFlag)
      {
         xferStopped = TRUE;
         va_end(ap);
         return(FALSE);
      }

      if(xferStopped)
         break;

      gotCommEvent = TRUE;

      if(getRcvChar(theChar, charMask))
      {

         if(charFirst == 0)
         {
            va_end(ap);
            return(TRUE);

          }

         for(charList = charFirst; charList != 0; charList = va_arg(ap,BYTE))
         {
            if(charList == *theChar)
            {
               va_end(ap);
               return(TRUE);

            }
         }

         *theChar = 0;
      }

      //if(PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
      //   mainEventLoop();
      //sdj: now that rcv and snd b file are threads the main
      //sdj: thread will deal with UI while the xfer is going on, so
      //sdj: no need of this hack to peek the msges.
      //sdj: but lets put sleep of 10ms so that we dont hog the CPU
      //sdj: and give chance for the buffer to fill and reduce number
      //sdj: of	calls to ReadFile()

      Sleep(10);

   }
   until(tickCount() >= waitTicks);

   va_end(ap);
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* flushRBuf() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

VOID flushRBuff()
{
   if(modemBytes())
      delay(6, NULL);                        /* mbbx: wtf??? */

   while(modemBytes())
      serNdx = 0;                            /* mbbx: dump serBytes data */
}


/*---------------------------------------------------------------------------*/
/* checkUserAbort() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/
BOOL checkUserAbort()
{
   BOOL checkUserAbort = FALSE;

   return(FALSE);

   if(PeekMessage(&msg, hdbXferCtrls, 0, 0, PM_REMOVE))
   {
      if((msg.hwnd != xferCtlStop)     ||
         (msg.message < WM_MOUSEFIRST) ||
         (msg.message > WM_MOUSELAST))
      {
         IsDialogMessage(hdbXferCtrls, &msg);
      }
   }

   while(PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
   {
      if((msg.message == WM_KEYDOWN) && (msg.wParam == VK_CANCEL))
         checkUserAbort = TRUE;
   }

   return(checkUserAbort);
}


/*---------------------------------------------------------------------------*/
/* modemWrite() - Send data to comm port (no special processing here)  [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR WIN_modemWrite(LPSTR lpData, INT nSize)
{
   BOOL        modemWrite = TRUE;
   BOOL        bWriteFile;
   INT         nRemain;
   INT         nBytes;
   INT         nSent;
   COMSTAT     serInfo;
   // -sdj unreferenced local var: BYTE	str[80];
   DWORD       dwErrors;
   OVERLAPPED  overlap;
   BOOL        bRc;

   overlap.hEvent       = overlapEvent;
   overlap.Internal     = 0;
   overlap.InternalHigh = 0;
   overlap.Offset       = 0;
   overlap.OffsetHigh   = 0;

   for(nRemain = nSize; nRemain > 0; nRemain -= nSent)
   {
      nBytes = nRemain;

      bWriteFile = WriteFile(sPort,  (LPVOID)  (lpData+(nSize-nRemain)),
                             nBytes, (LPDWORD) &nSent,
                             (LPOVERLAPPED)&overlap);

      dwErrors = GetLastError();

      if ((!bWriteFile) && (dwErrors != ERROR_IO_PENDING))
      {
         bRc = ClearCommError(sPort, &dwErrors, &serInfo);

         if(serInfo.fXoffSent || serInfo.fCtsHold)
         {
            if(serInfo.fCtsHold)
            {
               sPortErr = TRUE;
               return(FALSE);
            }

            rxEventLoop(); /* jtf 3.20 */

            if ( (xferStopped == TRUE) && (xferFlag != XFRNONE) ) /* jtf 3.33 3.30 */
            {
               modemWrite = TRUE;
               return(modemWrite);  /* jtf 3.30 */
            }

            if(checkUserAbort())             /* mbbx: see if CTRL BREAK hit */
            {
               switch(trmParams.flowControl)    /* mbbx 1.10: CUA... */
               {
               case ITMXONFLOW:
                  modemReset();
                  break;

               case ITMHARDFLOW:             /* drastic ... */
                  trmParams.flowControl = ITMNOFLOW;
                  resetSerial(&trmParams, FALSE, FALSE, 0);
                  break;
               }
               modemWrite = FALSE;
               break;
            }/* if checkUserAbort */
         }/* if serInfo.hold */
      }/* if writeComm */
      else
      {
         if(!bWriteFile)
            if(dwErrors != ERROR_IO_PENDING)
            {
               bRc = ClearCommError(sPort, &dwErrors, &serInfo);
               modemWrite = FALSE;
               nSent = 0;
            }
            else
	    {
	       if(WaitForSingleObject(overlapEvent, dwWriteFileTimeout) == 0)
               {
                  GetOverlappedResult(sPort, &overlap, (LPDWORD)&nSent, TRUE);
               }
               else
               {
                  ResetEvent(overlapEvent);
                  bRc = ClearCommError(sPort, &dwErrors, &serInfo);
                  nSent = 0;
               }
            }

#ifdef SLEEP_FOR_CONTEXT_SWITCH

	 Sleep((DWORD)5);
#endif

//         if(!nSent)
//         {
//            modemWrite = FALSE;
//            break;
//         }
      }
   }/* for */

   if(xferBreak)                             /* mbbx 2.00: xfer ctrls... */
   {
      setXferCtrlButton(IDSTOP, STR_STOP);
      xferBreak = FALSE;
   }

   return(modemWrite);
}/* WIN_modemWrite */


/* ----------------------------------------------------------------------- */


BOOL modemWrite(LPSTR lpData, INT nSize)
{
   LPCONNECTOR_CONTROL_BLOCK  lpCCB;               /* slc nova 031 */
   BOOL                       bResult = FALSE;     /* slc swat */

   if (nSize == 0)    /* mbbx 2.00.04: check outgoing buffer... */
   {
      switch(trmParams.comDevRef)
      {
      case ITMDLLCONNECT:                       /* slc nova 028 */
         if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(ghCCB)) != NULL)
         {
            lpCCB->wWriteBufferUsed = (WORD)nSize;    /* slc nova 031 */
            GlobalUnlock(ghCCB);
            DLL_WriteConnector(ghCCB);
         }
         break;
      case ITMWINCOM:
      default:
         break;
      }
      return(TRUE);
   }


   /* We cannot allow recursive calls to the modemWrite() sub,
      cuz we stack overflow!  Design issue: caller should check
      this return value and re-call with same data!
   */

   if(bgOutStandingWrite)                    /* slc swat */
   {
      sysBeep();
      return(FALSE);
   }
   else
      bgOutStandingWrite = TRUE;


   switch(trmParams.comDevRef)
   {
   case ITMWINCOM:
      bResult = WIN_modemWrite(lpData, nSize);
      break;

   case ITMDLLCONNECT:                       /* slc nova 012 bjw nova 002 */
      if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(ghCCB)) != NULL) /* slc nova 031 */
      {
         if(lpCCB->lpWriteBuffer)               /* seh nova 005 */
         {
            lmovmem((LPSTR)lpData, (LPSTR)lpCCB->lpWriteBuffer, (WORD)nSize);  /* seh nova 005 */
            lpCCB->wWriteBufferUsed = (WORD)nSize;    /* seh nova 005 */

            GlobalUnlock(ghCCB);                /* slc nova 031 */
            bResult = DLL_WriteConnector(ghCCB);
         }
      }
      break;

   }/* switch */

   bgOutStandingWrite = FALSE;               /* slc swat */

   return(bResult);
}


/*---------------------------------------------------------------------------*/
/* modemWr() - Send character to the windows serial port driver.       [mbb] */
/*---------------------------------------------------------------------------*/

VOID modemWr(BYTE  theByte)
{
   BYTE  saveByte = theByte;
   BYTE  ISOByte;

   if((theByte >= 0x80) && (xferFlag < XFRBSND))   /* mbbx 1.10: VT220 8BIT... */
   {
      if(trmParams.language > ICS_NONE)
         ISOByte = icsXlateTable[theByte];
      else
         ISOByte = theByte;

      if(trmParams.setIBMXANSI)
      {
         if(ISOByte >= 0x80)  /* was not ISO */
            theByte = ansiXlateTable[theByte & 0x7F]; /* ANSI to IBM extended */
      }
      else
         theByte = ISOByte;
   }
   else if((theByte == CR) && (trmParams.emulate == ITMDELTA))
      theByte = XOFF;

   if(!modemWrite((LPSTR) &theByte, 1))
      return;

   if(trmParams.localEcho && (xferFlag < XFRTYP))
   {
      modemInp(saveByte, FALSE);
      if((theByte == CR) && (xferFlag == XFRSND))
         modemInp(LF, FALSE);
   }

   if(trmParams.outCRLF && (theByte == CR) && (xferFlag == XFRNONE))    /* mbbx 2.00: heed outCRLF... */
      modemWr(LF);                           /* yikes!  it's recursive!!! */
}


/*---------------------------------------------------------------------------*/
/* termStr() - Send PASCAL character string to the modem.              [mbb] */
/*---------------------------------------------------------------------------*/

VOID termStr(STRING *tStr, INT nDelay, BOOL crFlag)
{
   WORD  ndx;

   for(ndx = 1; ndx <= *tStr; ndx++)
   {
      modemWr(tStr[ndx]);
      if(nDelay > 0)
         delay(nDelay, NULL);
      if(!dialing)
         idleProcess();
   }

   if(crFlag)
      modemWr(CR);
}



DWORD  checkCommEvent(LPVOID lpThreadParameter)
{
   DWORD    eventMask;
   HANDLE   hEvent;
   OVERLAPPED OverLapped;
   DWORD      dwGetLastError;

//   eventMask = EV_RXCHAR | EV_ERR | EV_BREAK | EV_CTS | EV_DSR;
   eventMask = EV_RXCHAR;
   SetCommMask(sPort, eventMask);

   hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
   OverLapped.hEvent = hEvent;

   while(TRUE)
   {
      if(bPortIsGood && (sPort != NULL) && (sPort != (HANDLE)-1) && (!CommThreadExit) )
      {
         if(WaitForSingleObject(hMutex, 50) == 0)
	 {
	    eventMask = EV_RXCHAR;
	   // SetCommMask(sPort, eventMask);

            if(WaitCommEvent(sPort, (LPDWORD)&eventMask, &OverLapped))
            {
               gotCommEvent = TRUE;
	    }
	    else
	    {
		dwGetLastError = GetLastError();
		if (dwGetLastError == ERROR_IO_PENDING)
		     {

                    DWORD Trash;
                    GetOverlappedResult(
                        sPort,
                        &OverLapped,
                        &Trash,
                        TRUE
                        );
		    gotCommEvent = TRUE;

		      }
		else  {

		      //-sdj for telnet-quit processing
		      //-sdj if this is a telnet connection and
		      //-sdj the user hits cntl-c/bye/quit etc
		      //-sdj the telnet service will stop talking
		      //-sdj with us, but terminalapp still keeps
		      //-sdj doing io without knowing that the handle
		      //-sdj can only be close now, The way we can
		      //-sdj detect this is, to check if getlasterror
		      //-sdj is ERROR_NETNAME_DELETED, if this is the
		      //-sdj case then we should do exactly same thing
		      //-sdj which we do when the user tries to go to
		      //-sdj some other comm port, close this one, and
		      //-sdj go to the next one.
		      //-sdj by setting bPortDisconnected to TRUE,
		      //-sdj further modemBytes()[reads] will stop on
		      //-sdj this port, and modemBytes will prompt the
		      //-sdj user to select some other port, and return.

		      CloseHandle(sPort);  // only valid operation in this state
		      sPort = NULL;	   // this will prevent checkcommevent to
					   // attempt unnecessary waits untill sPort
					   // becomes valid, and bPortDisconnected
					   // is set back to FALSE by modembytes/resetserial

		      bPortDisconnected = TRUE;


		      }


            }

	    if(CommThreadExit)	  // was ,doneFlag but doneFlag
				  // does not get set for sometime
				  // even after the comm port closes
				  // so exit the thread when you know
				  // that the port is going to get closed
				  // This flag is init to false and set
				  // to true just before calling exitserial
				  // in termfile.c

            {
               gbThreadDoneFlag = TRUE;
               ReleaseMutex(hMutex);
               ResetEvent(hEvent);
               ExitThread((DWORD)0);
            }

            ReleaseMutex(hMutex);

            eventMask = EV_RXCHAR;
         }  // wait on mutex

#ifdef SLEEP_FOR_CONTEXT_SWITCH

	 Sleep((DWORD)3);
#endif


         ResetEvent(hEvent);
      }  // good sPort
      else
      {
	 if(CommThreadExit)	    // was doneFlag : see above for comments
         {
            gbThreadDoneFlag = TRUE;
            ReleaseMutex(hMutex);
            ResetEvent(hEvent);
            ExitThread((DWORD)0);
	 }

	 Sleep((DWORD)3);   // -sdj either the comm port handle is changing
			  // or it is invalid, so instead of doing
			  // a tight while-true, sleep each time you
			  // come here, so that others get a chance

      }
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\messages.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"


/*---------------------------------------------------------------------------*/
/* testBox() - Display parametered messaged box from any using any type. [mg]*/
/*---------------------------------------------------------------------------*/

INT testBox(HWND  window, INT   choice, INT   captionID, BYTE  *str, 
            INT   arg0, INT arg1, INT arg2, INT arg3, INT arg4, INT arg5, 
            INT arg6, INT arg7, INT arg8, INT arg9, INT arga, INT argb, 
            INT argc, INT argd, INT arge, INT argf)
{
   INT   result;
   BYTE  caption[TMPNSTR+1];
   BYTE  workstr[STR255];

   if(window == NULL)
        window = GetActiveWindow(); /* jtf 3.14 */

   LoadString(hInst, captionID, (LPSTR) caption, TMPNSTR);

   sprintf(workstr, str, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                         arg8, arg9, arga, argb, argc, argd, arge, argf);

   if(choice < 0)
   {
      choice = -choice;
      MessageBeep(0);
   }

   result = MessageBox(window, (LPSTR) workstr, (LPSTR) caption, choice);

   return(result);
}


/*---------------------------------------------------------------------------*/
/* testMsg() - Display parametered messaged box from main window.      [mg]  */
/*---------------------------------------------------------------------------*/

INT testMsg(BYTE *str0, BYTE *str1, BYTE *str2)
{
   return(testBox(NULL, -MB_ICONHAND, STR_ERRCAPTION, str0,
                  str1, str2,    0,    0,    0,    0,    0,    0,
                     0,    0,    0,    0,    0,    0,    0,    0));
}


/*---------------------------------------------------------------------------*/
/* testResMsg() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/
INT testResMsg(WORD wResID)
{
   BYTE  work[80];

   LoadString(hInst, wResID, (LPSTR) work, 80);
   return(testMsg(work, NULL, NULL));
}

/*---------------------------------------------------------------------------*/
/* testMsgAux() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

VOID testMsgAux(BYTE  *str, INT   arg0, INT arg1, INT arg2, INT arg3, INT arg4, 
                INT arg5, INT arg6, INT arg7, INT arg8, INT arg9, INT arga, 
                INT argb, INT argc, INT argd, INT arge, INT argf)
{
   INT   hFile, len, ndx;
   BYTE  work[STR255];

   if((hFile = _open("aux", 2)) != -1)
   {
      len = sprintf(work, str, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                               arg8, arg9, arga, argb, argc, argd, arge, argf);

      _write(hFile, work, len);
      _write(hFile, "\r\n", 2);

      _close(hFile);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\menus.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS                 TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM          TRUE
#define  NODRAWTEXT           TRUE
#define  NOMINMAX                TRUE
#define  NOOPENFILE           TRUE
#define  NOSCROLL                TRUE
#define  NOPROFILER           TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31

#include <stdarg.h>
#include <windows.h>
#include <shellapi.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "printfil.h"
#include <commdlg.h>
#include <cderr.h>

/*---------------------------------------------------------------------------*/
/* enableMenuList() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

VOID enableMenuList(HMENU hAppMenu,BOOL bEnable, ...)
{
   va_list ap;
   INT      ndx;
   UINT     miList;
   HMENU    hSubMenu;

   va_start(ap,bEnable);
   for(miList = va_arg(ap,UINT); miList; miList = va_arg(ap,UINT))
   {
      if(miList & 0x8000)
      {
         miList &= 0x000F;
         if(childZoomStatus(0x0001, 0))
            miList += 1;
         hSubMenu = GetSubMenu(hAppMenu, miList);
         for(ndx = GetMenuItemCount(hSubMenu)-1; ndx >= 0; ndx -= 1)
            EnableMenuItem(hSubMenu, ndx, (bEnable ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);
      }
      else
         EnableMenuItem(hAppMenu, miList, bEnable ? MF_ENABLED : MF_GRAYED);
   }
   va_end(ap);
}



/*---------------------------------------------------------------------------*/
/* initMenuPopup() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID initMenuPopup(WORD  menuIndex)
{
   HMENU    hAppMenu;
   WORD     systemIndex;

   if(childZoomStatus(0x0001, 0))
      menuIndex -= 1;

   hAppMenu = hMenu;
   systemIndex = menuIndex;
      switch(menuIndex)
      {
      case FILEMENU:
         enableMenuList(hAppMenu, countChildWindows(FALSE), FMCLOSE, FMSAVE, FMSAVEAS, NULL);
         enableMenuList(hAppMenu, TRUE, FMPRINT, FMPRINTSETUP, NULL);
         enableMenuList(hAppMenu, (hPrintFile==NULL), FMPRINTSETUP, FMPRINTSETUP, NULL); /* jtf 3.20 check to see if chanel open */
         break;

      case EDITMENU:
         if(GetTopWindow(hItWnd) == hTermWnd)
         {
            enableMenuList(hAppMenu, TRUE, EMSELECTALL, EMCLEAR, NULL);
            enableMenuList(hAppMenu, (hTE.selStart != hTE.selEnd), EMCOPY, EMCOPYTHENPASTE, EMCOPYSPECIAL, NULL);

            enableMenuList(hAppMenu, IsClipboardFormatAvailable(CF_TEXT), EMPASTE, NULL);

            if (scrapSeq || ((xferFlag != XFRNONE) && (xferFlag != XFRRCV)) ) /* jtf 3.17 disable send if in transfer */
               {
               enableMenuList(hAppMenu, FALSE, EMCOPYTHENPASTE, NULL);
               enableMenuList(hAppMenu, FALSE, EMPASTE, NULL);
               enableMenuList(hAppMenu, FALSE, EMSELECTALL, NULL);
               enableMenuList(hAppMenu, FALSE, EMCOPY, NULL);
               }

            enableMenuList(hAppMenu, (curTopLine >= savTopLine), EMSAVESCREEN, NULL);
         }
         else
            enableMenuList(hAppMenu, FALSE, 0x8000 | systemIndex, NULL);
         break;

      case SETTINGSMENU:
         enableMenuList(hAppMenu, activTerm, SMPHONE, SMEMULATE, SMTERMINAL, SMFUNCTIONKEYS, SMMODEM, NULL);
         enableMenuList(hAppMenu, activTerm && (xferFlag == XFRNONE), SMTEXTXFERS, SMBINXFERS, SMCOMMUNICATIONS, NULL);
         break;

      case PHONEMENU:                        /* mbbx 2.00: network... */
         if((trmParams.comDevRef > ITMNOCOM) && (xferFlag == XFRNONE))  /* mbbx 1.10: carrier... */
         {
            enableMenuList(hAppMenu, TRUE, 0x8000 | systemIndex, NULL);
            enableMenuList(hAppMenu, !mdmOnLine, PMDIAL, NULL);
         }
         else
            enableMenuList(hAppMenu, FALSE, 0x8000 | systemIndex, NULL);
         break;

      case TRANSFERMENU:
                                             /* mbbx 1.10: answerMode... */
         enableMenuList(hAppMenu, (trmParams.comDevRef > ITMNOCOM) && (xferFlag == XFRNONE),    /* mbbx 2.00: network... */
                        TMSENDTEXTFILE, TMRCVTEXTFILE, NULL);
         enableMenuList(hAppMenu, (trmParams.comDevRef > ITMNOCOM) && (xferFlag == XFRNONE) && !answerMode,
                        TMSENDBINFILE, TMRCVBINFILE, NULL);
         enableMenuList(hAppMenu, activTerm && (xferFlag == XFRNONE), TMVIEWTEXTFILE, NULL);
         enableMenuList(hAppMenu, (xferFlag > XFRNONE) && (xferFlag < XFRBSND) && !xferPaused, TMPAUSE, NULL);
         enableMenuList(hAppMenu, (xferFlag > XFRNONE) && (xferFlag < XFRBSND) && xferPaused, TMRESUME, NULL);
         enableMenuList(hAppMenu, (xferFlag > XFRNONE), TMSTOP, NULL);

         if (scrapSeq) /* jtf gold 045 */
         enableMenuList(hAppMenu, FALSE, TMSENDTEXTFILE, TMVIEWTEXTFILE, NULL); /* jtf 3.27 */


         break;

      case HELPMENU:                         /* mbbx 2.00: CUA... */
         break;
      }
}


/*---------------------------------------------------------------------------*/
/* doEditMenu() - Edit memu commands happen here !                     [scf] */
/*---------------------------------------------------------------------------*/

VOID doEditMenu(INT  theItem)
{
   DWORD    scrapSize;
   HANDLE   hText;
   HANDLE   tmpScrapHandle;

   // -sdj unreferenced local var HDC	theDC,newDC;
   // -sdj unreferenced local varRECT	  theClient;
   // -sdj unreferenced local varHANDLE   newHdl;

   if(GetTopWindow(hItWnd) == hTermWnd)
   {
      hText = hTE.hText;

      switch(theItem)
      {
      case EMSELECTALL:
         termSetSelect(0l, (LONG) (savTopLine + maxScreenLine + 1) * (maxChars + 2));
         activSelect = TRUE; /* jtf 3.30 */
         noSelect = FALSE;    /* rjs bugs 020 */
         break;

      case EMCOPY:
      case EMPASTE:
      case EMCOPYTABLE:
      case EMCOPYTHENPASTE:
         if((theItem == EMCOPY) || (theItem == EMCOPYTABLE) || (theItem == EMCOPYTHENPASTE))
         {
            copiedTable = FALSE;
            scrapSize = hTE.selEnd - hTE.selStart;
            if (scrapSize == 0)
                  break; /* jtf 3.20 do not copy blank selection */
                                             /* the + 3 for possible <cr>,<lf>, NULL */
            if((tEScrapHandle = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, scrapSize + 3)) != NULL)
            {
               blockMove((LPBYTE) GlobalLock(hText) + hTE.selStart,
                         (LPBYTE) GlobalLock(tEScrapHandle), scrapSize);
               GlobalUnlock(hText);
               GlobalUnlock(tEScrapHandle);

                  stripBlanks(GlobalLock(tEScrapHandle), &scrapSize);
                  GlobalUnlock(tEScrapHandle);

               if((tEScrapHandle = GlobalReAlloc(tEScrapHandle, scrapSize+1, GMEM_MOVEABLE | GMEM_ZEROINIT)) != NULL)
                  if(OpenClipboard(hTermWnd))
                  {
                     EmptyClipboard();
                     SetClipboardData(CF_TEXT, tEScrapHandle);
                     CloseClipboard();
                  }
            }
         }

         if((theItem == EMPASTE) || (theItem == EMCOPYTHENPASTE))
           if (IsClipboardFormatAvailable(CF_TEXT)) /* jtf 3.20 prevent protect violation */
            if(OpenClipboard(hTermWnd))
            {
               if((tmpScrapHandle = GetClipboardData(CF_TEXT)) != NULL)
               {
                  scrapSize = (DWORD) lstrlen(GlobalLock(tmpScrapHandle));
                  GlobalUnlock(tmpScrapHandle);
                  if((tEScrapHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, scrapSize+1)) != NULL)
                  {
                     blockMove(GlobalLock(tmpScrapHandle), GlobalLock(tEScrapHandle), scrapSize);
                     GlobalUnlock(tmpScrapHandle);
                     GlobalUnlock(tEScrapHandle);
                  }
               }
               CloseClipboard();
               useScrap = TRUE;
            }
         break;

      case EMCLEAR:
         cursorAdjust();
         clearBuffer();
         break;

      }
   }

}


/*---------------------------------------------------------------------------*/
/* doCommand() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

VOID doCommand(HWND     hWnd, WPARAM   wParam, LONG     lParam)
{

/* this is called from within WM_COMMAND, so that wParam and lParam change as per*/
/* win32.  This is also called from another place with lParm set to zero */
/* I'll fix the wParam references, and debug to see if any other fixes needed*/

   CHAR     work[STR255];
   CHAR     extrainfo[STR255];	// -sdj another buff to hold EXTRAINFO string of aboutbox;
   BOOL     result;
   // -sdj unreferenced local var LPSTR	lpEOS;
   INT      rc;
   PRINTDLG PRN;

   offCursor();

   switch(GET_WM_COMMAND_ID(wParam, lParam))
   {
   case FMNEW:
      doFileNew();
      break;

   case FMOPEN:
      doFileOpen();
      break;

   case FMCLOSE:
      doFileClose();
      break;

   case FMSAVE:
      doFileSave();
      break;

   case FMSAVEAS:
      doFileSaveAs();
      break;

   case FMPRINTSETUP:
      /* initialize PRINTDLG structure */
      PRN.lStructSize = sizeof(PRINTDLG);
      PRN.hDevMode    = hDevMode;
      PRN.hDevNames   = hDevNames;
      PRN.Flags       = PD_PRINTSETUP;
      PRN.hwndOwner   = hWnd;

      PrintDlg(&PRN);
      rc = CommDlgExtendedError();
      /* Probable cause is low memory. */
      if(rc == CDERR_DIALOGFAILURE  || rc == CDERR_INITIALIZATION ||
           rc == CDERR_LOADSTRFAILURE || rc == CDERR_LOADRESFAILURE ||
           rc == PDERR_LOADDRVFAILURE || rc == PDERR_GETDEVMODEFAIL)
      {
        testBox(hWnd,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
      }
      else
      {
        hDevMode = PRN.hDevMode;
        hDevNames= PRN.hDevNames;
      }
      break;

   case FMPRINTER:
      PrintFileComm(!prtFlag);         /* mbbx 1.03: prAction(!prtFlag); */
      break;

   case FMTIMER:
      timerToggle(TRUE);                     /* mbbx 1.03 */
      break;

   case FMEXIT:                              /* mbbx 1.10: CUA... */
      CommThreadExit = TRUE;  // we are exiting, so let the thread
                              // exit on its own by ExitThread.

      PostMessage(hItWnd, WM_CLOSE, 0, 0L);
      break;

   case EMUNDO:
   case EMSELECTALL:
   case EMCUT:
   case EMCOPY:
   case EMPASTE:
   case EMCLEAR:
   case EMCOPYTHENPASTE:
      doEditMenu(GET_WM_COMMAND_ID(wParam, lParam));
      break;

   case SMPHONE:                             /* mbbx 1.04 ... */
      doSettings(IDDBPHON, dbPhon);
      break;

   case SMEMULATE:
      doSettings(IDDBEMUL, dbEmul);
      break;

   case SMTERMINAL:
      doSettings(IDDBTERM, dbTerm);
      break;

   case SMFUNCTIONKEYS:
      doSettings(IDDBFKEY, dbFkey);
      break;

   case SMTEXTXFERS:
      doSettings(IDDBTXTX, dbTxtX);
      break;

   case SMBINXFERS:
      doSettings(IDDBBINX, dbBinX);
      break;

   case SMCOMMUNICATIONS:
      doSettings(IDDBCOMM, dbComm);
      break;

   case SMMODEM:                             /* mbbx 1.10: CUA... */
      doSettings(IDDBMODEM, dbModem);
      break;

   case PMDIAL:
      dialPhone();
      break;

   case PMHANGUP:
      hangUpPhone();
      break;

   case TMSENDTEXTFILE:
      DEBOUT("doCommand: Got %s menu click\n","SENDTEXTFILE");
      *taskState.string = 0;                 /* mbbx 1.01... */
      sndTFile();
      break;

   case TMRCVTEXTFILE:
      DEBOUT("doCommand: Got %s menu click\n","RCVTEXTFILE");
      *taskState.string = 0;                 /* mbbx 1.01... */
      rcvTFile();
      break;

   case TMVIEWTEXTFILE:
      DEBOUT("doCommand: Got %s menu click\n","VIEWTEXTFILE");
      *taskState.string = 0;                 /* mbbx 1.01... */
      typTFile();
      break;

   case TMSENDBINFILE:
      DEBOUT("doCommand: Got %s menu click\n","SENDBINFILE");
      *taskState.string = 0;                 /* mbbx 1.01... */
      sndBFile();
      break;

   case TMRCVBINFILE:
      DEBOUT("doCommand: Got %s menu click\n","RCVBINFILE");
      *taskState.string = 0;                 /* mbbx 1.01... */
      rcvBFile();
      break;

   case TMPAUSE:                             /* mbbx 2.00: xfer ctrls... */
      xferPauseResume(TRUE, FALSE);
      break;

   case TMRESUME:
      xferPauseResume(FALSE, TRUE);
      break;

   case TMSTOP:
      xferStopBreak(TRUE);
      break;

   case WMFKEYS:
      showHidedbmyControls(!fKeysShown, TRUE);  /* mbbx 2.00: bArrange... */
      break;

   case HMCOMMANDS:
   case HMPROCEDURES:
   case HMKEYBOARD:
      LoadString(hInst, STR_HELPFILE, work, STR255-1);
      result = WinHelp(hTermWnd, work, HELP_CONTEXT, wParam);
      if(!result)
         testBox(hTermWnd,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
      break;

   case HMINDEX:                             /* mbbx 2.00: CUA... */
      LoadString(hInst, STR_HELPFILE, work, STR255-1);
      result = WinHelp(hTermWnd,work,HELP_INDEX,0L);
      if(!result)
         testBox(hTermWnd,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
      break;

   case HMHELP:
      result = WinHelp(hTermWnd,NULL,HELP_HELPONHELP,0L);
           if(!result)
                testBox(hTermWnd,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
      break;

   case HMSEARCH:
      LoadString(hInst, STR_HELPFILE, work, STR255-1);
      if(!WinHelp(hTermWnd, work, HELP_PARTIALKEY, (DWORD_PTR)""))
	  testBox(hTermWnd,-(MB_ICONHAND|MB_SYSTEMMODAL|MB_OK),STR_ERRCAPTION,NoMemStr);
      break;

//   case HMABOUT:
//		 DialogBox(hInst, MAKEINTRESOURCE(IDDBABOUT), hItWnd, dbAbout);
//	break;
// lets try to close one bugreport, by using shellabout again so that
// the about box is consistent with the other shell applets and win31
// -sdj 12/15/92

   case HMABOUT:
      LoadString(hInst, STR_APPNAME, work,	 STR255-1);
      LoadString(hInst, STR_EXTRAINFO, extrainfo, STR255-1);

		ShellAbout(hTermWnd, work, extrainfo,
		       LoadIcon(hInst, MAKEINTRESOURCE(ICO_DYNACOMM)));
            break;




   default:
      DEBOUT("doCommand: %s\n","Got INTO default option");
      switch(GET_WM_COMMAND_ID(wParam, lParam) & 0xF000)
      {
      case 0xF000:
                 /* NOTE under lParam may be zero and screw up under win32, since lParam*/
                 /* is passed in sometimes == zero by another function*/

         DEBOUT("doCommand: %s\n","Got into default option: doing SendMsg");
         SendMessage(GetTopWindow(hItWnd), WM_SYSCOMMAND, wParam, lParam);
         DEBOUT("doCommand: %s\n","Got into default option: done SendMsg");
         break;
      }
      DEBOUT("doCommand: %s\n","Got OUT of default option");
      break;
   }

   DEBOUT("doCommand: %s\n","Doing UpdateWindow(hItWnd)");
   UpdateWindow(hItWnd);
   DEBOUT("doCommand: %s\n","Done  UpdateWindow(hItWnd)");
   onCursor();
}

INT_PTR CALLBACK dbAbout(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   switch (message)
   {
   case WM_INITDIALOG:
      return TRUE;

   case WM_COMMAND:
      if (wParam == IDOK)
         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
      break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\network.h ===
/*****************************************************************************/
/* NETBIOS: definitions for netbios interface                                */
/*****************************************************************************/

/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/

#define DOS_GETVECTOR            0x35

#define INT_NETBIOS              0x5C
#define INT_ATTEXT_NETBIOS       0x5B

#define NAMSZ           16          /* max length of a net names */
#define NAMSZLONG       80          /* max length of extended net names */
#define NAMSZISN        64          /* max length of ISN names */
#define NETBUFFERSIZE   (768-64)    /* now 3/4 K bytes for each NCB */
#if OLDCODE
/* tge gold 005 changed to a variable, used with checkbox in dialog */
#define NETNAMEPADDING  0x20        /* mbbx 2.01.28: was 0x20 */
#endif
#define MAXTASKNCBS     32          /* max number of outstanding NCB's
                                       that DC can keep track of */

#define NAB_MAX_LUS     32          /* NABIOS max LU's per PU */

#define WWID_WHEN_MASK     0xFF00
#define WWID_WAIT_MASK     0x00FF
#define WWID_WHEN_STD      0x0100
#define WWID_WAIT_STD      0x0001
#define WWID_WHEN_NABIOS   0x0200
#define WWID_WAIT_NABIOS   0x0002
#define WWID_WHEN_ATT      0x0300
#define WWID_WAIT_ATT      0x0003

#define NET_TASK_NETINT    0   /* flags for hScriptNCB->res */
#define NET_TASK_NETLANA   1   /* (secret place for script runtime flags) */
#define NET_TASK_NABINT    2
#define NET_TASK_NABLANA   3 
#define NET_TASK_ATTINT    4
#define NET_TASK_ATTLANA   5 

#define NETBIOS_NOTEXISTS -1  /* flags for dcIoStat.netbiosStatus */
#define NETBIOS_NOTCHECKED 0
#define NETBIOS_EXISTS     1

#define NABIOS_NOTEXISTS  -1  /* flags for dcIoStat.nabiosStatus */
#define NABIOS_NOTCHECKED  0
#define NABIOS_EXISTS      1

#define ATTBIOS_NOTEXISTS -1  /* flags for dcIoStat.attbiosStatus */
#define ATTBIOS_NOTCHECKED 0
#define ATTBIOS_EXISTS     1

#define FSE_LOCK     0        /* flags for memJugler() */
#define FSE_UNLOCK   1
#define FSE_FREE     2

#define NERR_LVL_IGNORE 0x01  /* netbios error levels */
#define NERR_LVL_WEIRD  0x02
#define NERR_LVL_ERROR  0x03

#define NET_COM_OK      0x00  /* NET_CommandWait() constants */
#define NET_COM_ABORT   0x01
#define NET_COM_FAIL    0x02
#define NET_COM_BUSY    0x03
#define NET_COM_DUP     0x04

#define COM_ADDN_NCB    0x00  /* NCB constants */
#define COM_CALL_NCB    0x00
#define COM_LISN_NCB    0x00
#define COM_HANG_NCB    0x00
#define COM_STAT_NCB    0x00
#define COM_BRAK_NCB    0x00  /* mbbx 2.00: ATT extension */
#define COM_SEND_NCB    0x01
#define COM_RECV_NCB    0x02
#define COM_CNCL_NCB    0x03
#define COM_DATA_NCB    0x04
#define LAST_COMM_NCB   0x04
#define MAXCOMMNCBS     5     /* NCB's for comm session */

#define NET_ASYNCH      0x80  /* int 5Ch calls */

#define NET_CALL_RESET     0x32     /******* General Commands *******/
#define NET_CALL_ASTATUS   0x33
#define NET_CALL_CANCEL    0x35
#define NET_CALL_UNLINK    0x70

#define NET_CALL_ADDNAME   0x30     /******* Name Support Commands *******/
#define NET_CALL_ADDGNAME  0x36
#define NET_CALL_DELNAME   0x31

#define NET_CALL_CALL         0x10  /******* Session Support Commands *******/
#define NET_CALL_LISTEN       0x11
#define NET_CALL_HANGUP       0x12
#define NET_CALL_SEND         0x14
#define NET_CALL_CHAINSEND    0x17
#define NET_CALL_RECEIVE      0x15
#define NET_CALL_RECEIVEANY   0x16
#define NET_CALL_SSTATUS      0x34

#define NET_CALL_DGSEND       0x20  /******* Datagram Support Commands *******/
#define NET_CALL_BDGSEND      0x22
#define NET_CALL_DGRECEIVE    0x21
#define NET_CALL_BDGRECEIVE   0x23

#define NET_CALL_CALLNIU      0x74  /******* UB Extensions *******/
#define NET_CALL_LISTENNIU    0x7B
#define NET_CALL_UBSNDPACKET  0x77           /* mbbx 2.00.06 ... */
#define NET_CALL_UBRCVPACKET  0x78

#define NET_CALL_CALLISN      0x10  /******* AT&T Extensions *******/
#define NET_CALL_BREAK        0x70  /* ATT via int 5Bh */

#define NET_CALL_ACTPU        0x30  /******* NABIOS Extensions *******/
#define NET_CALL_DACTPU       0x31

#define NET_CALL_ACTLU        0x10
#define NET_CALL_DACTLU       0x12

#define NET_CALL_NABSEND      0x14
#define NET_CALL_NABRECV      0x15

#define NET_CALL_NABASTAT     0x33
#define NET_CALL_NABSSTAT     0x34

#define NET_CALL_INVALID      0x7F  /* invalid command to test for Netbios */

#define NLANANETBIOS    0x00  /* lpNcb.lana constants */
#define NLANAEICONS     0xFF

/* ncb return codes */
#define NET_ERR_GOODRET 0x00  /* good return */
#define NET_ERR_BUFLEN  0x01  /* illegal buffer length */
#define NET_ERR_BFULL   0x02  /* buffers full, no receive issued */
#define NET_ERR_ILLCMD  0x03  /* illegal command */
#define NET_ERR_CMDTMO  0x05  /* command timed out */
#define NET_ERR_INCOMP  0x06  /* message incomplete, issue another command */
#define NET_ERR_BADDR   0x07  /* illegal buffer address */
#define NET_ERR_SNUMOUT 0x08  /* session number out of range */
#define NET_ERR_NORES   0x09  /* no resource available */
#define NET_ERR_SCLOSED 0x0a  /* session closed */
#define NET_ERR_CMDCAN  0x0b  /* command canceled */
#define NET_ERR_DMAFAIL 0x0c  /* PC DMA failed */
#define NET_ERR_DUPNAME 0x0d  /* duplicate name */
#define NET_ERR_NAMTFUL 0x0e  /* name table full */
#define NET_ERR_ACTSES  0x0f  /* no deletions, name has active sessions */
#define NET_ERR_INVALID 0x10  /* name not found or no valid name */
#define NET_ERR_LOCTFUL 0x11  /* local session table full */
#define NET_ERR_REMTFUL 0x12  /* remote session table full */
#define NET_ERR_ILLNN   0x13  /* illegal name number */
#define NET_ERR_NOCALL  0x14  /* no callname */
#define NET_ERR_NOWILD  0x15  /* cannot put * in NCB_NAME */
#define NET_ERR_INUSE   0x16  /* name in use on remote adapter */
#define NET_ERR_NAMERR  0x17  /* called name cannot == name nor name # */
#define NET_ERR_SABORT  0x18  /* session ended abnormally */
#define NET_ERR_NAMCONF 0x19  /* name conflict detected */
#define NET_ERR_REMTDEV 0x1A  /* Incompatible remote device */
#define NET_ERR_IFBUSY  0x21  /* interface busy, IRET before retrying */
#define NET_ERR_TOOMANY 0x22  /* too many commands outstanding, retry later */
#define NET_ERR_BRIDGE  0x23  /* ncb_bridge field not 00 or 01 */
#define NET_ERR_CANOCCR 0x24  /* command completed while cancel occuring */
#define NET_ERR_RESNAME 0x25  /* reserved name specified */
#define NET_ERR_CANCEL  0x26  /* command not valid to cancel */
#define NET_ERR_MULT    0x33  /* multiple requests for same session */
#define NET_ERR_SYSTEM  0x40  /* system error */
#define NET_ERR_ROM     0x41  /* ROM checksum failure */
#define NET_ERR_RAM     0x42  /* RAM test failure */
#define NET_ERR_DLF     0x43  /* digital loopback failure */
#define NET_ERR_ALF     0x44  /* analog loopback failure */
#define NET_ERR_IFAIL   0x45  /* interface failure */
#define NET_ERR_ADMALF  0x46  /* adapter malfunction */
#define NET_ERR_UNDEFERR 0x47 /* Undefined Network Error */
#define NET_ERR_LAST    0x47

/* EICONS specific errors */
#define NET_ERR_MDMMASK 0x90  /* Modem Not Ready Mask */
#define NET_ERR_NODSR   0x91  /* Modem Not Ready (No DSR) */
#define NET_ERR_NOCTS   0x92  /* Modem Not Ready (No CTS) */
#define NET_ERR_NOCLOCK 0x93  /* Modem Not Ready (No Clock) */

#define NET_ERR_LNKMASK 0xA0  /* Link level not ready */
#define NET_ERR_PCKMASK 0xB0  /* Packet level not ready */

#define NET_ERR_PENDING 0xFF  /* asynchronous command is not yet finished */

/* nabios errors */
#define NET_NERR_GOODRET   0x00  /* good return */
#define NET_NERR_BUFLEN    0x01  /* Illegal buffer length. */
#define NET_NERR_INVALPU   0x03  /* PU not active. */
#define NET_NERR_INCOMP    0x06  /* Message incomplete. */
#define NET_NERR_INVALSID  0x08  /* Invalid session number. */
#define NET_NERR_LUNOTACT  0x0a  /* LU not active. */
#define NET_NERR_CMDCAN    0x0b  /* Command cancelled. */
#define NET_NERR_DUPPU     0x0d  /* PU name already exists. */
#define NET_NERR_PUTFUL    0x0e  /* PU name table full. */
#define NET_NERR_LUTFUL    0x11  /* No circuits available. */
#define NET_NERR_UNSUCC    0x12  /* Call unsuccessful. */
#define NET_NERR_NORESP    0x14  /* No response from Server. */
#define NET_NERR_PUINUSE   0x16  /* Station Address already assigned to a PU. */
#define NET_NERR_PUNOTACT  0x17  /* PU name not active. */
#define NET_NERR_STATECHG  0x18  /* QLLC/SDLC state change. */
#define NET_NERR_DATATRAF  0x1A  /* Data traffic reset or in Receive state. */
#define NET_NERR_TOOMANY   0x22  /* Too many commands oustanding. */
#define NET_NERR_LAST      0x22

/* my errors */
#define NET_ERR_CONNECT   0x00      /* Connected to Netbios */
#define NET_ERR_ALRDYCON  0x01      /* Already Connected to Netbios */
#define NET_ERR_NONETBIO  0x02      /* Cannot find Netbios */
#define NET_ERR_CANTCONN  0x03      /* Can't Connect to Netbios */
#define NET_ERR_LINKERR   0x0D      /* Link level not ready */
#define NET_ERR_PACKERR   0x0E      /* Packet level not ready */
#define NET_ERR_ACTSESS   0x10      /* Packet level not ready */


/*****************************************************************************/
/* Type & Structure Definitions                                              */
/*****************************************************************************/

typedef enum
{
   CONV_CLIENT, 
   CONV_SERVER
}
CONVERSATION;


#define FARP struct longptr   /* 8088/86 long pointer */

FARP
{
   INT lp_offset;    /* offset */
   INT lp_seg;       /* segment */
};

typedef struct                /* Net Control Block 512 bytes */
{
   BYTE ncb_com;              /* command */
   BYTE ncb_ret;              /* return code */
   BYTE ncb_lsn;              /* local session # */
   BYTE ncb_num;              /* number of network name */
   FARP ncb_bfr;              /* pntr to message buffer */
   WORD ncb_len;              /* msg length in unsigned chars */
   CHAR ncb_rname[NAMSZ];     /* blank-padded name of * remote end of connection */
   CHAR ncb_lname[NAMSZ];     /* our blank-padded network name */
   BYTE ncb_rto;              /* rcv timeout/retry count */
   BYTE ncb_sto;              /* send timeout/sys timeout */
   FARP ncb_sig;              /* interrupt signal routine */
   BYTE ncb_lana;             /* reserved */
   BYTE ncb_cplt;             /* 0xff => commmand pending */

   FARP ncb_vrCallName;       /* ATT special - address of ISN name */
   BYTE ncb_vrCallNameSz;     /* ATT special - length of ISN name */
   BYTE ncb_res[9];           /* reserved */
/*
   BYTE ncb_res[14];          /* reserved *
*/
   BYTE ncb_buffer[NETBUFFERSIZE];
} NCB;

typedef NCB FAR *LPNCB;
typedef NCB NEAR *PNCB;

typedef struct                /* 18 bytes */
{                             /* Name entries */
   BYTE as_name[NAMSZ];       /* Name */
   BYTE as_number;            /* Name number */
   BYTE as_status;            /* Name status */
} ASTATNAME;

typedef struct                /* 60 + (16 * 18) =  348 bytes */
{
   BYTE as_uid[6];            /* Unit identification number */
   BYTE as_ejs;               /* External jumper status */
   BYTE as_lst;               /* Results of last self-test */
   BYTE as_ver;               /* Software version number */
   BYTE as_rev;               /* Software revision number */
   WORD as_dur;               /* Duration of reporting period */
   WORD as_crc;               /* Number of CRC errors */
   WORD as_align;             /* Number of alignment errors */
   WORD as_coll;              /* Number of collisions */
   WORD as_abort;             /* Number of aborted transmissions */
   LONG as_spkt;              /* Number of successful packets sent */
   LONG as_rpkt;              /* No. of successful packets rec'd */
   WORD as_retry;             /* Number of retransmissions */
   WORD as_exhst;             /* Number of times exhausted */
   BYTE as_res0[8];           /* Reserved */
   WORD as_ncbfree;           /* Free ncbs */
   WORD as_numncb;            /* number of ncbs configured */
   WORD as_maxncb;            /* max configurable ncbs */
   BYTE as_res1[4];           /* Reserved */
   WORD as_sesinuse;          /* sessions in use */
   WORD as_numses;            /* number of sessions configured */
   WORD as_maxses;            /* Max configurable sessions */
   WORD as_maxdat;            /* Max. data packet size */
   WORD as_names;             /* No. of names in local table */
   ASTATNAME as_struct[16];   /* Name entries */
} ASTATSTRUCT;

typedef ASTATSTRUCT FAR *LPASTATSTRUCT;
typedef ASTATSTRUCT NEAR *PASTATSTRUCT;

typedef struct                /* 36 bytes */
{                             /* Name entries */
   BYTE ss_session;           /* local session number */
   BYTE ss_status;            /* session status */
   BYTE ss_lname[NAMSZ];      /* local name */
   BYTE ss_rname[NAMSZ];      /* remote name */
   BYTE ss_recout;            /* outstanding receive commands */
   BYTE ss_sndout;            /* outstanding send & chain send commands */
} SSTATNAME;

typedef struct                /* 4 + (16 * 36) = 580 bytes */
{
   BYTE ss_numses;            /* sessions */
   BYTE ss_numsesname;        /* sessions with this name */
   BYTE ss_recdgout;          /* outstanding rec & rec broad datagram commands */
   BYTE ss_recanyout;         /* outstanding rec any commands */
   SSTATNAME ss_struct[16];   /* Name entries */
} SSTATSTRUCT;

typedef SSTATSTRUCT FAR *LPSSTATSTRUCT;
typedef SSTATSTRUCT NEAR *PSSTATSTRUCT;

typedef struct
{
   INT hNCB;                  /* handles for NCB's */
   LPNCB lpNCB;               /* long pointers for NCB's */
   WORD whenWaitID;           /* ARG_WHEN_LISTEN, ARG_WHEN_RECEIVE or NULL = wait */
} TASKNCBDATA;


/*****************************************************************************/
/* Variable Definitions                                                      */
/*****************************************************************************/

struct                                       /* mbbx 2.00.04: rkhx netbios... */
{
   BYTE  lsn;
   BYTE  num;
   WORD  maxSendBytes;                       /* mbbx 2.00.06: netbios extensions */

   WORD  netbiosStatus;
   WORD  nabiosStatus;
   WORD  attbiosStatus;
} dcIoStat;

INT debugFileHandle;


/* task netbios data */
TASKNCBDATA taskNcbs[MAXTASKNCBS];  /* (1 + 2 + 1) * 32 = 128 bytes */
WORD taskNcbStatus;                 /* general status info for task ncb's */
HANDLE hScriptNcb;                  /* handle for script ncb */
HANDLE hAdapterStatus;              /* handle for script adapter status */
HANDLE hSessionStatus;              /* handle for script session status */

/* comm netbios data */
HANDLE hCommNcbs;
LPNCB lpCommNcbs;

/* tge gold 005 changed from a constant, used with checkbox in dialog */
BYTE NETNAMEPADDING;

/*****************************************************************************/
/* Macro Definitions                                                         */
/*****************************************************************************/

/*****************************************************************************/
/* Forward Procedure Definitions                                             */
/*****************************************************************************/

VOID NET_exitSerial();
VOID NET_SetDefaults();
WORD NET_Connect(BOOL);
VOID NET_resetSerial(recTrmParams *, BOOL);  /* mbbx 2.01.141 */

VOID NET_modemSendBreak(INT);
INT NET_ReadComm(LPSTR, INT);
VOID NET_modemBytes();
INT NET_WriteComm(LPSTR, INT);
BOOL NET_modemWrite(LPSTR, INT);

BYTE NETBIOS_Reset(LPNCB, BOOL, BYTE, BYTE, BYTE, BYTE); /* General Commands */
BYTE NETBIOS_AdapterStatus(LPNCB, BOOL, LPBYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_Cancel(LPNCB, WORD, BYTE, BYTE);
BYTE NETBIOS_Unlink(LPNCB, BYTE, BYTE);

BYTE NETBIOS_AddName(LPNCB, BOOL, LPBYTE, BYTE, BYTE);   /* Name Support Commands */
BYTE NETBIOS_AddGroupName(LPNCB, BOOL, LPBYTE, BYTE, BYTE);
BYTE NETBIOS_DeleteName(LPNCB, BOOL, LPBYTE, BYTE, BYTE);

BYTE NETBIOS_Call(LPNCB, BOOL, LPBYTE, LPBYTE, BYTE, BYTE, BYTE, BYTE); /* Session Support Commands */
BYTE NETBIOS_Listen(LPNCB, BOOL, LPBYTE, LPBYTE, BYTE, BYTE, BYTE, BYTE);
BYTE NETBIOS_Hangup(LPNCB, BOOL, BYTE, BYTE, BYTE);
BYTE NETBIOS_Send(LPNCB, BOOL, BYTE, LPBYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_ChainSend(LPNCB, BOOL, LPBYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_Receive(LPNCB, BOOL, BYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_ReceiveAny(LPNCB, BOOL, BYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_SessionStatus(LPNCB, BOOL, LPBYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_SendDG(LPNCB, BOOL, LPBYTE, LPBYTE, WORD, BYTE, BYTE, BYTE);  /* Datagram Support Commands */
BYTE NETBIOS_SendBDG(LPNCB, BOOL, LPBYTE, WORD, BYTE, BYTE, BYTE);
BYTE NETBIOS_ReceiveDG(LPNCB, BOOL, BYTE, WORD, BYTE, BYTE);
BYTE NETBIOS_ReceiveBDG(LPNCB, BOOL, BYTE, WORD, BYTE, BYTE);

/*** UB Extensions ***/
BYTE NETBIOS_UB_CallNIU(LPNCB, LPBYTE, BYTE, BYTE, BYTE, BYTE);
BYTE NETBIOS_UB_ListenNIU(LPNCB, LPBYTE, BYTE, BYTE, BYTE, BYTE);
BYTE NETBIOS_UB_SendPacket(LPNCB, BYTE, LPBYTE, WORD, BYTE, BYTE);  /* mbbx 2.00.06 */
BYTE NETBIOS_UB_ReceivePacket(LPNCB, BYTE, WORD, BYTE, BYTE);  /* mbbx 2.00.06 */

/*** AT&T Extensions ***/
BYTE NETBIOS_ATT_CallISN(LPNCB, BOOL, LPBYTE, LPBYTE, BYTE, BYTE);
BYTE NETBIOS_ATT_Break(LPNCB, BOOL, BYTE, BYTE, BYTE);

BOOL NET_NetbiosExist(WORD, BOOL);
BYTE NET_CallNetbios(LPNCB, BYTE);
BOOL NET_AllocCommNCBS();
VOID NET_ClearNcb(LPNCB);
VOID NET_DoCommError(LPNCB, BOOL);
WORD NET_Hangup();
WORD NET_CommandWait(WORD);


VOID NET_ExecCmdWait(WORD);   /* tsknet.c prototypes */
VOID NET_ExecCmdWhen(WORD);
VOID NET_WaitEnd(VOID);
BOOL NEAR NET_WhenNetwork(WORD);
INT  NET_AllocTaskNCB();
VOID NET_FreeNCB(WORD);
BOOL NEAR NET_CallNetbiosMulti(WORD, WORD, LPBYTE, LONG, LONG);
LPSTR memJugler(WORD, HANDLE*, DWORD);
VOID freeNetworkData();

VOID NET_TaskProcess(VOID);   /* netproc.c prototypes */
VOID NEAR NET_CommandComplete(WORD, BYTE);
VOID NEAR NET_PushWhenStack(INT, BYTE);
VOID NET_PopWhenStack(WORD);



/*****************************************************************************/
/* COMBIOS: definitions for combios interface                                */
/*****************************************************************************/

/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/

#define INT_COMBIOS              0x14

#define COM_CALL_INIT            0x00
#define COM_CALL_WRITE           0x01
#define COM_CALL_READ            0x02
#define COM_CALL_STATUS          0x03

#define COM_CALL_BREAK           0x04  /* EICONS & ETHERTERM */
#define COM_CALL_WRITESTRING     0x06  /* EICONS */
#define COM_CALL_READSTRING      0x07  /* EICONS */

#define COM_PORT_COM1            0x00
#define COM_PORT_COM2            0x01
#define COM_PORT_COM3            0x02
#define COM_PORT_COM4            0x03

/* com init parameters */
#define COM_BAUD_110             0x00
#define COM_BAUD_300             0x40
#define COM_BAUD_600             0x60        /* mbbx 2.00.04: allow any baud */
#define COM_BAUD_1200            0x80
#define COM_BAUD_2400            0xA0
#define COM_BAUD_4800            0xC0
#define COM_BAUD_9600            0xE0

#define COM_PARITY_NONE          0x00
#define COM_PARITY_ODD           0x08
#define COM_PARITY_EVEN          0x18

#define COM_STOP_1               0x00
#define COM_STOP_2               0x04

#define COM_DATA_7               0x02
#define COM_DATA_8               0x03

/* port status bits */
#define COM_PORTSTAT_CMDTMO      0x8000
#define COM_PORTSTAT_TSREGMT     0x4000
#define COM_PORTSTAT_THREGMT     0x2000
#define COM_PORTSTAT_BREAK       0x1000
#define COM_PORTSTAT_FRAME       0x0800
#define COM_PORTSTAT_PARITY      0x0400
#define COM_PORTSTAT_OVERRUN     0x0200
#define COM_PORTSTAT_READY       0x0100

/* modem status bits */
#define COM_MDMSTAT_RLSD         0x0080
#define COM_MDMSTAT_RI           0x0040
#define COM_MDMSTAT_DSR          0x0020
#define COM_MDMSTAT_CTS          0x0010
#define COM_MDMSTAT_DLTARLSD     0x0008
#define COM_MDMSTAT_TERI         0x0004
#define COM_MDMSTAT_DLTADSR      0x0002
#define COM_MDMSTAT_DLTACTS      0x0001


/*****************************************************************************/
/* Forward Procedure Definitions                                             */
/*****************************************************************************/

/* VOID COM_exitSerial(VOID); */
VOID COM_resetSerial(recTrmParams *, BOOL);  /* mbbx 2.01.141 */

BOOL COM_mdmConnect();
VOID COM_modemReset();
VOID COM_modemSendBreak(INT);
INT NEAR COM_ReadComm(LPSTR, INT);
VOID COM_modemBytes();
INT NEAR COM_WriteComm(LPSTR, INT);
BOOL COM_modemWrite(LPSTR, INT);
WORD NEAR COM_CallBios(BYTE, BYTE, BYTE, LPBYTE, WORD);


/*****************************************************************************/
/* UBNETCI: definitions for Ungermann-Bass Command interpreter interface     */
/*****************************************************************************/
/* tge gold 007: split UB definitions into netubci.h */
#include "netubci.h"

/*****************************************************************************/
/* DEVICE: definitions for DOS device interface                              */
/*****************************************************************************/

/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/
#define INT_DOS            0x21

/* int 21h calls */
#define DOS_CALL_OPEN      0x3D
#define DOS_CALL_CLOSE     0x3E
#define DOS_CALL_READ      0x3F
#define DOS_CALL_WRITE     0x40
#define DOS_CALL_IOCTL     0x44

#define DOS_IOCTL_CMD_GETINFO      0x00
#define DOS_IOCTL_CMD_SETINFO      0x01
#define DOS_IOCTL_CMD_READ         0x02
#define DOS_IOCTL_CMD_WRITE        0x03
#define DOS_IOCTL_CMD_READDRIVE    0x04
#define DOS_IOCTL_CMD_WRITEDRIVE   0x05
#define DOS_IOCTL_CMD_GETINSTAT    0x06
#define DOS_IOCTL_CMD_GETOUTSTAT   0x07
#define DOS_IOCTL_CMD_REMOVABLE    0x08
#define DOS_IOCTL_CMD_DEV_LCL_RMT  0x09
#define DOS_IOCTL_CMD_HNDL_LCL_RMT 0x0A
#define DOS_IOCTL_CMD_SHARECOUNT   0x0B

#define DOS_OPEN_ERR_NOSHAR   0x01
#define DOS_OPEN_ERR_NOFILE   0x02
#define DOS_OPEN_ERR_NOPATH   0x03
#define DOS_OPEN_ERR_NOHNDL   0x04
#define DOS_OPEN_ERR_NOACES   0x05
#define DOS_OPEN_ERR_NOCODE   0x0C

#define DOS_CLOSE_ERR_NOHNDL  0x06

#define DOS_READ_ERR_NOACES   0x05
#define DOS_READ_ERR_NOTOPN   0x06

#define DOS_WRITE_ERR_NOACES  0x05
#define DOS_WRITE_ERR_NOTOPN  0x06

#define DOS_IOCTL_ERR_NOSHAR  0x01
#define DOS_IOCTL_ERR_NOHNDL  0x04
#define DOS_IOCTL_ERR_NOACES  0x05
#define DOS_IOCTL_ERR_NOTOPN  0x06
#define DOS_IOCTL_ERR_BADDAT  0x0D
#define DOS_IOCTL_ERR_BADDRV  0x0F


/*****************************************************************************/
/* Forward Procedure Definitions                                             */
/*****************************************************************************/

VOID DEV_exitSerial();
VOID DEV_resetSerial(recTrmParams *, BOOL);  /* mbbx 2.01.141 */

VOID DEV_modemBytes();
BOOL DEV_modemWrite(LPSTR, INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\printfil.h ===
/* Header file for Print File */

#define PRINTREC         struct PrintType
#define LPPRINTREC       PRINTREC FAR *

LPPRINTREC    lpPrintFile;
HANDLE       hPrintFile;

VOID PrintFileString(LPSTR, LONG, BOOL);
BOOL PrintFileControl(UINT  msg, WPARAM wParam, LPARAM lParam );
BOOL  APIENTRY PrintFileComm(BOOL);

struct PrintType
       {
       BOOL    active;         /* Printer active flag used for pause/resume */
       BOOL    selectPrintActive; /* Selection printing active */
       BOOL    filePrintActive;   /* File printing active */
       SHORT   openCount;      /* Counter to test for balance of open/close */
       INT     fileio;         /* File iochannel */
       HFONT   hFont;            /* current print font */  
       LOGFONT font;             /* Logical font sturcture */
       INT     point;            /* Point size */
       SHORT   nLineHeight;      /* Real line height includes leading */
       INT   pageWidth;
       INT   pageHeight;
       INT   pageLength;         /* Length of page in lines */
       INT   lineLength;         /* Length of line on a page */
       INT   prtLine;            /* Current line being printed */
       INT   charCount;          /* Current position in line */
       INT   pixCount;           /* Current position in pixels */
       INT   pixColCount;        /* Current col position of pixels */
       INT   tab;                /* Tab value */
       BOOL  CRtoLF;             /* True translate CR to LF */
       BYTE  title[STR255];         /* Title of document to print */
       BYTE  lineBuffer[STR255];    /* Current line buffer */
		 BYTE  tmpFile[STR255];    /* Temp file name jtfnew */
       BOOL  cancelAbort;        /* Cancel printing flag */
       HDC   hPrintDC;           /* Handle to printer DC */
       HWND  hAbortDlg;          /* Handle to abort dialog box */
       };


#define CR     13               /* Carriage return              */
#define LF     10               /* Line Feed                    */
#define FF     12               /* Form Feed                    */
#define TAB    9                /* Tab                          */
#define TABMAX 20               /* Max tab size                 */


#define PRINTFILEBOLD         0x0001
#define PRINTFILEUNDERLINE    0x0002
#define PRINTFILEITALIC       0x0004
#define PRINTFILESTRIKEOUT    0x0008
#define PRINTFILEQUALITY      0x0010
#define PRINTFILECRTOLF       0x0020
#define PRINTFILENORMAL       0x0040
#define PRINTFILETAB          0x0080
#define PRINTFILESETFONT      0x0100
#define PRINTFILEFONTFACE     0x0200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\printfil.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMB	            TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31

#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "printfil.h"
#include <commdlg.h>
/*BUG BUG Get this file from 31 folks .... -sdj #include <drivinit.h> */


BOOL PrintFileOn(HANDLE,HWND,LPSTR,LPSTR,LPSTR,LPSTR,BOOL);
BOOL PrintFileOff();

/*---------------------------------------------------------------------------*/

BOOL PrintFileInit()
{
   hPrintFile = NULL;
   return(TRUE);
}


/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbAbortDlg (HWND  hDlg, UINT  msg, WPARAM wParam, LPARAM lParam)
{
   switch(msg)
   {
   case WM_INITDIALOG:
      lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);
      SetDlgItemText(hDlg, 99, lpPrintFile->title);
      SetFocus (hDlg);
      GlobalUnlock(hPrintFile);
      return TRUE;
      break;

   case WM_COMMAND:
      lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);
      lpPrintFile->cancelAbort = TRUE;
      GlobalUnlock(hPrintFile);
      return TRUE;
      break;
   }

   return FALSE;
}


/*---------------------------------------------------------------------------*/

BOOL  APIENTRY abortDlgProc(HDC   hPrintDC, INT   iReserved)
{
   return(TRUE);                             /* jtfnew */
}


/*---------------------------------------------------------------------------*/

BOOL  APIENTRY PrintFileComm(BOOL bPrint)         /* rjs bugs 013 */
{
   /* Added 02/22/91 for common print dialog by w-dougw */
   LPDEVNAMES lpDevNames = NULL;

	if(hDevNames)
		lpDevNames  = (LPDEVNAMES)GlobalLock(hDevNames);

	if(bPrint != prtFlag)
   {
		prtFlag = bPrint;
		CheckMenuItem(hMenu, FMPRINTER, prtFlag ? MF_CHECKED : MF_UNCHECKED);

		if(prtFlag)
      {
			if(lpDevNames)
         {
				if(!(PrintFileOn((HANDLE) hInst, (HWND) hItWnd, 
					(LPSTR)szAppName, 
					(LPSTR)lpDevNames+lpDevNames->wDeviceOffset, 
					(LPSTR)lpDevNames+lpDevNames->wDriverOffset,
					(LPSTR)lpDevNames+lpDevNames->wOutputOffset, FALSE)))
            {
					GlobalUnlock(hDevNames);
					return(FALSE);
				}
			}
         else
         {
				if(!(PrintFileOn((HANDLE) hInst, (HWND) hItWnd, 
					(LPSTR)szAppName, 
					NULL_STR, 
					NULL_STR, 
					NULL_STR, FALSE)))
            {
					GlobalUnlock(hDevNames);	
					return(FALSE);
				}
			}
			PrintFileControl( PRINTFILECRTOLF, TRUE, 0L);
      }
      else
   	   PrintFileOff();
	}
	if(hDevNames)
		GlobalUnlock(hDevNames);
      return TRUE;
}

BOOL PrintFileOn(HANDLE theInstance, HWND  theWnd, LPSTR thePrintName, 
                 LPSTR thePrintType, LPSTR thePrintDriver, LPSTR thePrintPort, 
                 BOOL  showDialog)
{
   CHAR        pPrintInfo[80];
   LPSTR       lpTemp;
   LPSTR       lpPrintType;
   LPSTR       lpPrintDriver;
   LPSTR       lpPrintPort;
   TEXTMETRIC  tmMetric;
   BYTE        spool[255];
   BYTE        szWindows[MINRESSTR];
   BYTE        szDevice[MINRESSTR];
   LPDEVMODE   lpDevMode;

   if(hPrintFile) 
   {
      lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);
      lpPrintFile->openCount++;
      GlobalUnlock(hPrintFile);
      return(TRUE);                          /* Assume print channel open */
   }

   hPrintFile = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD) sizeof(PRINTREC));
   if(hPrintFile == NULL)
      return(FALSE);                         /* not enough memory */

   lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);

   lpPrintFile->active = FALSE;
   lpPrintFile->openCount = 1;

   LoadString(hInst, STR_INI_WINDOWS, szWindows, MINRESSTR);
   LoadString(hInst, STR_INI_DEVICE, szDevice, MINRESSTR);
   if(!GetProfileString(szWindows, (LPSTR) szDevice, (LPSTR) NULL_STR, (LPSTR) pPrintInfo, 80))
   {
      GlobalUnlock(hPrintFile);
      hPrintFile = GlobalFree(hPrintFile);
      return(FALSE);
   }

   lpTemp = lpPrintType = pPrintInfo;
   lpPrintDriver = lpPrintPort = 0;
   while(*lpTemp)
   {
      if(*lpTemp == ',')
      {
         *lpTemp++ = 0;
         while (*lpTemp == ' ')
            lpTemp = AnsiNext(lpTemp);

         if(!lpPrintDriver)
            lpPrintDriver = lpTemp;
         else
         {
            lpPrintPort = lpTemp;
            break;
         }
      }
      else
         lpTemp = AnsiNext(lpTemp);
   }

   lpDevMode =  (LPDEVMODE)GlobalLock(hDevMode);

   /* Overide win.ini with script referenced driver */
   if (lstrlen(thePrintDriver) > 0) lpPrintDriver = thePrintDriver;
   if (lstrlen(thePrintType)   > 0) lpPrintType   = thePrintType;
   if (lstrlen(thePrintPort)   > 0) lpPrintPort   = thePrintPort;

   lpPrintFile->hPrintDC = CreateDC((LPSTR)lpPrintDriver ,(LPSTR)lpPrintType, 
                                    (LPSTR)lpPrintPort, (LPDEVMODE)lpDevMode);
   GlobalUnlock(hDevMode);

   if (!lpPrintFile->hPrintDC)                    /*  could not get DC */
   {
      GlobalUnlock(hPrintFile);
      hPrintFile = GlobalFree(hPrintFile);
      return(FALSE);
   }

   GetTextMetrics(lpPrintFile->hPrintDC,&tmMetric);
   lpPrintFile->nLineHeight = (SHORT)(tmMetric.tmHeight + tmMetric.tmExternalLeading);
   lpPrintFile->font.lfHeight = 0;
   lpPrintFile->font.lfWidth = 0;
   lpPrintFile->font.lfEscapement = 0;
   lpPrintFile->font.lfOrientation = 0;
   lpPrintFile->font.lfWeight = 400;
   lpPrintFile->font.lfItalic = tmMetric.tmItalic;
   lpPrintFile->font.lfUnderline = tmMetric.tmUnderlined;
   lpPrintFile->font.lfStrikeOut = tmMetric.tmStruckOut;
   lpPrintFile->font.lfCharSet = tmMetric.tmCharSet;
   lpPrintFile->font.lfOutPrecision = OUT_DEFAULT_PRECIS;
   lpPrintFile->font.lfClipPrecision = CLIP_DEFAULT_PRECIS;
   lpPrintFile->font.lfQuality = DEFAULT_QUALITY;
   lpPrintFile->font.lfPitchAndFamily = (DEFAULT_PITCH | FF_DONTCARE);
   GetTextFace(lpPrintFile->hPrintDC,LF_FACESIZE,
              lpPrintFile->font.lfFaceName);
   lpPrintFile->tab = 8;                /* Default tab */
   lpPrintFile->prtLine = 0;            /* Current line being printed */
   lpPrintFile->charCount = 0;          /* Current position in line */
   lpPrintFile->pixColCount = 0;        /* Keep col for pix count */
   lpPrintFile->pixCount  = 0;          /* Keep track of x position */
   lpPrintFile->cancelAbort = FALSE;    /* Cancel printing flag */
   lpPrintFile->CRtoLF = FALSE;         /* Do not translate CR's */
   lpPrintFile->fileio = 0;             /* No print file open */   

   /* Get size of a page */
   lpPrintFile->pageHeight = GetDeviceCaps(lpPrintFile->hPrintDC, VERTRES);
   lpPrintFile->pageWidth  = GetDeviceCaps(lpPrintFile->hPrintDC, HORZRES);

   /* Create font based on default font */
   lpPrintFile->hFont = 0;
   lpPrintFile->active = TRUE;
   PrintFileControl( PRINTFILESETFONT, 0,0l);
   lpPrintFile->active = FALSE;

   spool[0] = 0;
   lstrcpy( spool, (LPSTR) lpPrintPort);
   lstrcpy( spool+lstrlen( (LPSTR)spool),(LPSTR) SPACE_STR+1);
   lstrcpy( spool+lstrlen( (LPSTR)spool),(LPSTR) thePrintName);
   lstrcpy( spool+lstrlen( (LPSTR)spool),(LPSTR) SPACE_STR+1);
   lstrcpy( spool+lstrlen( (LPSTR)spool),(LPSTR) lpPrintType);
   lstrcpy( lpPrintFile->title, (LPSTR) thePrintName);

   SetAbortProc(lpPrintFile->hPrintDC, abortDlgProc);

   if(Escape(lpPrintFile->hPrintDC, STARTDOC, lstrlen ((LPSTR)spool ), spool , (LPSTR) 0) <= 0)
   {
      DeleteDC(lpPrintFile->hPrintDC);
      GlobalUnlock(hPrintFile);
      hPrintFile = GlobalFree(hPrintFile);
      return FALSE;
   }

   if(showDialog)
   {
      lpPrintFile->hAbortDlg = CreateDialog (theInstance, MAKEINTRESOURCE (IDABORTDLG), theWnd, dbAbortDlg);
   }

   lpPrintFile->active = TRUE;

   GlobalUnlock(hPrintFile);

   return(TRUE);
}


BOOL PrintFileOff()
{
   BYTE tmp[STR255]; /* jtfnew */

   if(!hPrintFile)
      return(FALSE);
   lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);

   lpPrintFile->openCount--;

   if(lpPrintFile->fileio)
   {
      _close(lpPrintFile->fileio);
      lpPrintFile->fileio = 0;
      if ( lstrlen( lpPrintFile->tmpFile ) > 0 ) /* jtfnew */
      {
         lstrcpy ( tmp, (LPSTR) lpPrintFile->tmpFile);
         MDeleteFile(tmp);
         lpPrintFile->tmpFile[0] = 0;
      }
   }

   if(lpPrintFile->charCount > 0)
      PrintFileLineFeed(TRUE);

   if(lpPrintFile->openCount > 0)
   {
      lpPrintFile->cancelAbort = FALSE;
      GlobalUnlock(hPrintFile);
      return(TRUE);                          /* Assume leave print channel open */
   }

   if((lpPrintFile->prtLine > 0) || (lpPrintFile->charCount > 0) || (lpPrintFile->cancelAbort))
      PrintFilePageFeed();

   if(lpPrintFile->hFont)
       DeleteObject(lpPrintFile->hFont);

   Escape(lpPrintFile->hPrintDC, ENDDOC, 0, 0, (LPSTR) 0);

   if(lpPrintFile->hAbortDlg)
   {
      DestroyWindow (lpPrintFile->hAbortDlg);
   }

   DeleteDC(lpPrintFile->hPrintDC);

   while(GlobalUnlock(hPrintFile));
   hPrintFile = GlobalFree(hPrintFile);

   return(FALSE);
}


void PrintFilePageFeed ()
{
      if (!hPrintFile) return;
       else
      lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);

      lpPrintFile->prtLine = 0;

      switch (Escape (lpPrintFile->hPrintDC, NEWFRAME, 0, NULL, (LPSTR) NULL))
         {
         case SP_ERROR:                         /* General Error                */
            break;
         case SP_OUTOFDISK:                     /* Out of disk space            */
            break;
         case SP_OUTOFMEMORY:                      /* Out of memory                */
            break;
         default:
            break;
         }

     GlobalUnlock(hPrintFile);

}
      


void PrintFileShutDown ()
{
     if (!hPrintFile) return;
       else
     while (PrintFileOff());
     
}

void PrintFileLineFeed (BOOL nextLine)
{
BYTE  temp[255];
HFONT hOldFont;
INT   i;
INT   pix,cy;
   pix = 0;

   if (!hPrintFile) return;
       else
    lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);

   if (lpPrintFile->hFont)
      hOldFont = SelectObject( lpPrintFile->hPrintDC, lpPrintFile->hFont);

   if (lpPrintFile->charCount > 0)
   {
      lpPrintFile->lineBuffer[lpPrintFile->charCount] = 0;

      i = lpPrintFile->charCount;

      /* purge blanks from end of line */
      if ( (nextLine) && (i > 1) ) /* jtfnew */
         while ( (lpPrintFile->lineBuffer[lpPrintFile->charCount-1] == ' ') && (lpPrintFile->charCount > 0) )
            lpPrintFile->charCount--;

   if ( (lpPrintFile->charCount-lpPrintFile->pixColCount) > 0) /* jtfnew */
      { /* jtfnew */
      TextOut (lpPrintFile->hPrintDC, lpPrintFile->pixCount, lpPrintFile->prtLine * lpPrintFile->nLineHeight, 
                 (lpPrintFile->lineBuffer + lpPrintFile->pixColCount), lpPrintFile->charCount-lpPrintFile->pixColCount);


          /* JAP had said...BUG BUG, port macro screwed this up, so this is best guess
      pix = LOWORD( GetTextExtent(lpPrintFile->hPrintDC,
                    (lpPrintFile->lineBuffer + 
                    lpPrintFile->pixColCount), 
                    lpPrintFile->charCount-lpPrintFile->pixColCount) ); */


/* getextextent was giving DWORD back with high=ht low=width -sdj
   MGetTextExtent gives bool back, and takes PINT pcx and PINT pcy as args -sdj
   as the code was doing LOWORD, it was interested in width, in pix -sdj
   so giving address of pix as pcx and added cy and giving &cy as pcy -sdj */

      MGetTextExtent(lpPrintFile->hPrintDC,
                    (lpPrintFile->lineBuffer + 
                    lpPrintFile->pixColCount)  ,
                    lpPrintFile->charCount-lpPrintFile->pixColCount,
                    &pix,
                    &cy);


      lpPrintFile->pixColCount = lpPrintFile->charCount;

      lpPrintFile->pixCount = pix +lpPrintFile->pixCount;
      } /* jtfnew */


   }

   if(nextLine)
   {
      lpPrintFile->charCount = 0;
      lpPrintFile->pixCount = 0;
      lpPrintFile->pixColCount = 0;
      lpPrintFile->prtLine++;
   }

   if (lpPrintFile->hFont)
      SelectObject( lpPrintFile->hPrintDC, hOldFont);

   GlobalUnlock(hPrintFile);
}


/*---------------------------------------------------------------------------*/
/* PrintFileString() -                                           [jtf] [mbb] */
/*---------------------------------------------------------------------------*/

VOID PrintFileString(LPSTR    lpchr, LONG     count, BOOL     bCRtoLF)
{
   INT   icount, i;
   BYTE  chr;

   if ( (!hPrintFile) || (count == 0) ) /* jtfnew */            /* no print channel open */
      return;
   if((lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile)) != NULL)
   {
      if(!lpPrintFile->fileio)               /* disabled while file printing */
      {
         for(icount = 0; icount < count; icount += 1)
         {
            switch((BYTE) lpchr[icount])     /* mbbx 2.01.06 ... jtf 3.18 */
            {
            case TAB:
               for(i = lpPrintFile->tab - ((lpPrintFile->charCount) % lpPrintFile->tab); i > 0; i--)
                  lpPrintFile->lineBuffer[lpPrintFile->charCount++] = ' ';
               break;

            case CR:
               if(!bCRtoLF)
              
                  break;
                                             /* else fall thru... */
            case LF:
               PrintFileLineFeed(TRUE);
               break;

            case FF:
               PrintFilePageFeed();
               break;

            default:
               if(lpPrintFile->charCount >= lpPrintFile->lineLength)
                  PrintFileLineFeed(TRUE);
               if(lpPrintFile->prtLine >= lpPrintFile->pageLength-1) /* jtf 3.20 */
                  PrintFilePageFeed();

               lpPrintFile->lineBuffer[lpPrintFile->charCount++] = lpchr[icount];   /* mbbx 2.01.06 ... jtf 3.18 */
               break;
            }

            if(lpPrintFile->cancelAbort)
               break;
         }
      }

      GlobalUnlock(hPrintFile);
   }
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BOOL PrintFileControl(UINT  msg, WPARAM wParam, LPARAM lParam)
{
   RECT  pageRect;
   TEXTMETRIC tmMetric;
   HFONT hOldFont;

   if (!hPrintFile) return(FALSE);
    else
   lpPrintFile = (LPPRINTREC) GlobalLock(hPrintFile);

   if (msg & PRINTFILEBOLD)
      if (wParam) lpPrintFile->font.lfWeight = 700;
         else lpPrintFile->font.lfWeight = 400;

   if (msg & PRINTFILEUNDERLINE)
      lpPrintFile->font.lfUnderline = (BYTE)wParam;

   if (msg & PRINTFILEITALIC)
      lpPrintFile->font.lfItalic = (BYTE)wParam;

   if (msg & PRINTFILESTRIKEOUT)
      lpPrintFile->font.lfStrikeOut = (BYTE)wParam;

   if (msg & PRINTFILEQUALITY)
      if (wParam) lpPrintFile->font.lfQuality = DEFAULT_QUALITY;
         else  lpPrintFile->font.lfQuality = DRAFT_QUALITY;

   if (msg & PRINTFILECRTOLF)
      lpPrintFile->CRtoLF = (BOOL)wParam;

   if (msg & PRINTFILENORMAL)
      {
      lpPrintFile->font.lfItalic = FALSE;
      lpPrintFile->font.lfUnderline = FALSE;
      lpPrintFile->font.lfStrikeOut = FALSE;
      lpPrintFile->font.lfQuality = DEFAULT_QUALITY;
      lpPrintFile->font.lfWeight = 400;
    }

   if (msg & PRINTFILETAB)
      if (wParam <= TABMAX) lpPrintFile->tab = (INT)wParam;

   if (msg & PRINTFILEFONTFACE)
   {
      if(*(LPSTR)(lParam) != '?')
         lstrcpy(lpPrintFile->font.lfFaceName,(LPSTR)lParam);
      lpPrintFile->font.lfHeight = (LONG)wParam*
         GetDeviceCaps(lpPrintFile->hPrintDC,LOGPIXELSY)/72;
   }

   if (msg & PRINTFILESETFONT)
   {
      PrintFileLineFeed(FALSE);
      if (lpPrintFile->font.lfHeight > 0) 
         lpPrintFile->font.lfHeight= lpPrintFile->font.lfHeight+5;
      lpPrintFile->font.lfWidth = 0;

      if (lpPrintFile->hFont)
         DeleteObject( lpPrintFile->hFont );
      lpPrintFile->hFont = CreateFontIndirect( &lpPrintFile->font);

      hOldFont = SelectObject( lpPrintFile->hPrintDC, lpPrintFile->hFont);

      GetTextFace(lpPrintFile->hPrintDC,LF_FACESIZE,
               lpPrintFile->font.lfFaceName);
      GetTextMetrics(lpPrintFile->hPrintDC,&tmMetric);
      lpPrintFile->font.lfHeight = tmMetric.tmHeight;
      lpPrintFile->font.lfWidth = tmMetric.tmAveCharWidth;

      if ( (GetDeviceCaps(lpPrintFile->hPrintDC,LOGPIXELSY)/72) >= 1)
         lpPrintFile->point = lpPrintFile->font.lfHeight / (GetDeviceCaps(lpPrintFile->hPrintDC,LOGPIXELSY)/72);
      else
         lpPrintFile->point = 0;

      if( (lpPrintFile->prtLine == 0) && (lpPrintFile->charCount == 0) )
      {
         lpPrintFile->nLineHeight = (SHORT)(tmMetric.tmHeight + tmMetric.tmExternalLeading);
         /* Calculate size of page */
         lpPrintFile->pageLength = max (lpPrintFile->pageHeight / lpPrintFile->nLineHeight , 0);
         lpPrintFile->lineLength = max (lpPrintFile->pageWidth / lpPrintFile->font.lfWidth , 0);
      }

      SelectObject( lpPrintFile->hPrintDC, hOldFont);
   }

   GlobalUnlock(hPrintFile);
   return TRUE;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\modeminp.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "video.h"
#include "printfil.h"

static BOOL decPrivate;                      /* True if ? in set mode string */
static BOOL heathPrivate;                    /* True if > in set mode string */

#define MAXANSIARGS 10
static INT  argNdx;
static INT  argCount;
static INT  ansiArg;
static INT  argList[MAXANSIARGS+1];

static INT  vidFG;

static INT p1;
static INT p2;

static INT saveCol = 0;
static INT saveLin = 0;


/*---------------------------------------------------------------------------*/
/* valIndex() - Return index into buffer given current line & column.  [scf] */
/*---------------------------------------------------------------------------*/

INT valIndex ()
{
   return ((curLin + savTopLine) * (maxChars + 2) + curCol);
}


/*---------------------------------------------------------------------------*/
/* cleanRect() - Erase nLines starting at line                               */
/*---------------------------------------------------------------------------*/

VOID cleanRect(INT  line, INT nLines)
{
   RECT  eraseRect;
   INT   eraseLine;

   eraseRect = hTE.viewRect;
   eraseRect.top = (line + (savTopLine - curTopLine)) * chrHeight;
   if((eraseLine = eraseRect.top + (nLines * chrHeight)) < eraseRect.bottom)
      eraseRect.bottom = eraseLine;

   if(eraseRect.top < eraseRect.bottom)
   {
      eraseColorRect((HDC) getPort(), (LPRECT) &eraseRect, ANORMAL);
      releasePort();
   }
}


/*---------------------------------------------------------------------------*/
/* scrollBuffer() -                                                   [scf]  */
/*---------------------------------------------------------------------------*/

proc scrollBuffer ()
{
   register INT line; // sdj: was unref- count;
   INT buffLines;
   RECT scrollRect, notScrollRect;

   buffLines = savTopLine - curTopLine;
   buffLines = min (buffLines, visScreenLine + 1);
   if (buffLines > 0)
   {
      scrollRect = notScrollRect = hTE.viewRect;
      if (lineFeeds < buffLines)
      {
         scrollRect.bottom = buffLines * chrHeight;
         ScrollWindow (hTermWnd, 0, -(lineFeeds * chrHeight), 
                 (LPRECT) &scrollRect, (LPRECT) &scrollRect);
      }
      lineFeeds = min (buffLines, lineFeeds);

      line = -lineFeeds;
      if(curTopLine == 0)
         line += (visScreenLine+1) - savTopLine;
      reDrawTermScreen(0, lineFeeds, line);

      notScrollRect.top = scrollRect.bottom;             /* Only validate our */
      ValidateRect (hTermWnd, (LPRECT) &notScrollRect);  /* stuff that we     */
   }                                                     /* repaint           */
   lineFeeds = 0;
}


/*---------------------------------------------------------------------------*/
/* doScroll() -                                                              */
/*---------------------------------------------------------------------------*/

proc doScroll ()
{
   INT top, bottom, line, nLines; //sdj: was unref- buffLines;
   RECT scrollRect, uncoveredRect;

   top = savTopLine - curTopLine + scrollBegin;
   bottom = top + (scrollEnd + 1 - scrollBegin);
   top = max (top, 0);
   bottom = min (bottom, visScreenLine + 1);
   scrollRect.top = top * chrHeight;
   scrollRect.bottom = bottom * chrHeight;
   scrollRect.right = hTE.viewRect.right;
   scrollRect.left = hTE.viewRect.left;
   getPort ();
   clipRect (&hTE.viewRect);
   if (scrollRect.bottom > scrollRect.top) 
   {
      hideTermCursor ();
      if (abs(nScroll) < bottom - top)
      {
         ScrollWindow (hTermWnd, 0, -(nScroll * chrHeight), 
                    (LPRECT) &scrollRect, (LPRECT) &scrollRect);
         uncoveredRect.right = hTE.viewRect.right;
         uncoveredRect.left  = hTE.viewRect.left;
         if (nScroll < 0)  /* Inserting lines */
         {
            uncoveredRect.top = scrollRect.top;
            uncoveredRect.bottom = scrollRect.top + ((-nScroll) * chrHeight);
         } else            /* Line feeds or deleting lines */
         {
            uncoveredRect.top = scrollRect.bottom - nScroll * chrHeight;
            uncoveredRect.bottom = scrollRect.bottom;
         }
         ValidateRect (hTermWnd, (LPRECT) &uncoveredRect);
      }
      nLines = min (abs(nScroll), bottom - top);
      if (nScroll > 0)
         top = bottom - nLines + curTopLine - savTopLine;
      else
         top = top + curTopLine - savTopLine;
      for (line = top; line < top + nLines; line++)
         attrib[line][LFLAGS] = (LDIRTY | LCLEAR);
      showTermCursor ();
   }
   releasePort ();
   nScroll = 0;
}

/*---------------------------------------------------------------------------*/
/* termCleanUp() -                                                           */
/*---------------------------------------------------------------------------*/

VOID termCleanUp ()
{
   register INT line, lin2;
   BYTE lattr;
   // sdj: was unref local - BYTE *attr;

   checkSelect();
   if(nScroll != 0)
      doScroll();
   if(lineFeeds != 0)
      scrollBuffer();

   for(line = 0; line <= maxScreenLine+1; )
   {
      lattr = attrib[line][LFLAGS];
      if(lattr & LDIRTY)
      {
         updateLine(line);
         line++;
      }
      else if(lattr & LCLEAR)
      {
         attrib[line][LFLAGS] = 0;
         for(lin2 = line+1; lin2 <= maxScreenLine; lin2++)
         {
            if (lattr != attrib[lin2][LFLAGS])
               break;
            attrib[lin2][LFLAGS] = 0;
         }
         cleanRect (line, lin2 - line);
         line = lin2;
      }
      else
         line++;
   }
   termDirty = FALSE;                        /* mbbx: termLine -> termDirty */
}

/*---------------------------------------------------------------------------*/
/* putChar() - Put received characters into buffer                     [scf] */
/*---------------------------------------------------------------------------*/

proc putChar(BYTE ch)
{
   INT  ndx;
   LPBYTE txtPtr;
   LPBYTE txtSrc;
   LPBYTE txtDst;
   INT  theLine;
   INT  len;
   BYTE *attr;

   txtPtr = GlobalLock(hTE.hText);
   if(!statusLine)
   {
      ndx = (curLin + savTopLine) * (maxChars + 2) + curCol;
      theLine = curLin;
   }
   else
   {
      ndx     = curCol;
      txtPtr  = (LPBYTE) line25;
      theLine = maxScreenLine + 1;
   }
   attr = attrib[theLine];
//   if (attr[curCol] & ADIRTY)
//      termCleanUp();
   if (chInsMode)
   {
      len = maxChars - curCol - 2;
      if (len > 0)
      {
         txtSrc = txtPtr + ndx;
         txtDst = txtSrc + 1;
         blockMove (txtSrc, txtDst, len);
         txtSrc = (LPBYTE) attrib + theLine * ATTRROWLEN + curCol;
         txtDst = txtSrc + 1;
         blockMove (txtSrc, txtDst, len);
         attr[LFLAGS] = LCLEAR;
      }
   }

   if(!(termData.flags & TF_DIM))
      txtPtr[ndx] = ch;

   GlobalUnlock (hTE.hText);

   attr[curCol]  = curAttrib | ADIRTY;
   attr[LFLAGS] |= LDIRTY;
   
   termDirty     = TRUE;
   termCleanUp();
}

/*---------------------------------------------------------------------------*/
/* checkSelect() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

VOID checkSelect()
{
   LONG savTopNdx;
   if (activSelect)
   {
      noSelect = FALSE;
      savTopNdx = savTopLine*(maxChars + 2);
      if (hTE.selEnd > savTopNdx)
         if (savTopNdx <= hTE.selStart)
         {
            termSetSelect (MAXINTL, MAXINTL);
            activSelect = FALSE;
         }
         else
            termSetSelect (hTE.selStart, savTopNdx);
   }
   else
      if(!noSelect)
      {
         termSetSelect (MAXINTL, MAXINTL);
         noSelect = TRUE;
      }
}

/*---------------------------------------------------------------------------*/
/* clrAttrib() -                                                       [scf] */
/*---------------------------------------------------------------------------*/

VOID clrAttrib (INT startLin, INT endLin, INT startCol, INT endCol)
{
   INT lin, col;

   for (lin = startLin; lin <= endLin; lin++)
      for (col = startCol; col <= endCol; col++)
         attrib[lin][col] = 0;
}


/*---------------------------------------------------------------------------*/
/* clrLines() -                                                              */
/*---------------------------------------------------------------------------*/

proc clrLines (INT lin1, INT lin2)
{
   LPBYTE txt, attr;
   register INT line;

   txt = (LPBYTE)GlobalLock (hTE.hText) + (savTopLine + lin1) * (maxChars + 2);
   if(lin1 == 24)
      txt = (LPBYTE) line25; 
   for(line = lin1; line <= lin2; line++) 
   {
      if(!protectMode)                       /* mbbx: protected fields */
      {
         attr = attrib[line];
         if(attr[LFLAGS])
            termCleanUp();
         lsetmem(txt, CHFILL, maxChars);
         lsetmem(attr, 0, maxChars);
         attr[LFLAGS] = LCLEAR;
         attr[LATTRIB] = LNORMAL;            /* mbbx: mac version */
         txt += maxChars + 2;
         attr += ATTRROWLEN;
      }
      else
         clrChars(line, 0, maxChars-1);
   }
   GlobalUnlock (hTE.hText);
   termDirty = TRUE;                         /* mbbx: set dirty flag */
}


/*---------------------------------------------------------------------------*/
/* clrChars() -                                                              */
/*---------------------------------------------------------------------------*/

proc clrChars (INT line, INT col1, INT col2)
{
   LPBYTE txt, attr;
   register INT col;

   txt = (LPBYTE)GlobalLock(hTE.hText) + (savTopLine + line) * (maxChars + 2) + col1;
   if(line == 24)
      txt = (LPBYTE) line25 + col1; 
   attr = attrib[line] + col1;
   for(col = col1; col <= col2; col++)
   {
      if(*attr & ADIRTY)
         termCleanUp();
      if(!protectMode || !(*attr & APROTECT))   /* mbbx: protected fields */
      {
         *txt = CHFILL;
         *attr |= ADIRTY;
      }
      txt += 1;
      attr += 1;
   }
   attrib[line][LFLAGS] = LDIRTY;
   GlobalUnlock (hTE.hText);
   termDirty = TRUE;                         /* mbbx: set dirty flag */
}


/*---------------------------------------------------------------------------*/
/* getUnprot() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

VOID getUnprot(INT   begLin, INT   begCol, INT   *lin, INT   *col)
{
   INT   iLin;
   INT   iCol;

   *lin = 0;
   *col = 0;
   for(iLin = begLin; iLin < maxScreenLine; iLin++)      /* MBBX: TEST LIMITS!!! */
      for(iCol = begCol; iCol < maxChars; iCol++)
         if(!(attrib[iLin][iCol] & APROTECT))
         {
            *lin = iLin;
            *col = iCol;
            break;
         }
}


/*---------------------------------------------------------------------------*/
/* getProtCol() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

INT getProtCol()
{
   INT   col;

   for(col = curCol; col+1 < maxChars; col++)
      if(attrib[curLin][col+1] & APROTECT)
         break;

   return(col);
}


/*---------------------------------------------------------------------------*/
/* pCursToggle() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

proc pCursToggle ()
{
   if (cursorOn == 1)
      offCursor ();
   else if (cursorOn == 0)
      onCursor ();
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursOn() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc pCursOn ()
{
   onCursor ();
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursOff() -                                                        [scf] */
/*---------------------------------------------------------------------------*/

proc pCursOff ()
{
   offCursor ();
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursRC() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc pCursRC ()
{
   INT maxWide;

   if (escLin == -1)
   {
      escLin = ch - ' ';
      if ((escLin < 0) || (escLin > maxScreenLine))
         termState = NULL;
   }
   else 
   {
      escCol = ch - ' ';
      if ((escCol >= 0) && (escCol < maxChars))
      {
         curLin = escLin;
         curCol = escCol;
         maxWide = maxChars / 2 - 1;
         if (attrib[curLin][LATTRIB] != LNORMAL)
            if (curCol > maxWide)
               curCol = maxWide;
      }
      termState = NULL;
   }
   if (termState == NULL)
      escLin = -1;
}


/*---------------------------------------------------------------------------*/
/* pSetStatusLine() -                                                        */
/*---------------------------------------------------------------------------*/

proc pSetStatusLine()                        /* mbbx 1.03: TV925 ... */
{
   curLin = 24;
   curCol = 0;
   statusLine = TRUE;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursHome() - Home the terminal emulation cursor                    [scf] */
/*---------------------------------------------------------------------------*/

proc pCursHome ()
{
   curLin = 0;
   curCol = 0;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pVideo() -                                                          [scf] */
/*---------------------------------------------------------------------------*/

proc pVideo(BYTE attr)
{
   if(attr == 0)
      curAttrib = 0;
   else
      curAttrib |= attr;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursRelative() - Move cursor relative to current position          [scf] */
/*---------------------------------------------------------------------------*/

proc pCursRelative (INT  dh, INT  dv)
{
   INT  maxWide;

   curLin += dv;
   curCol += dh;
   if (curLin < 0)
      curLin = 0;
   else if (curLin > maxScreenLine)
      curLin = maxScreenLine;
   if (curCol < 0)
      curCol = 0;
   else if (curCol > (maxChars - 1))
      curCol = maxChars - 1;
   if (attrib[curLin][LATTRIB] != LNORMAL)
   {
      maxWide = maxChars / 2 - 1;
      if (curCol > maxWide)
         curCol = maxWide;
   }
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCursUp() - Move terminal emulation cursor up one relative to curr  [scf] */
/*---------------------------------------------------------------------------*/

proc pCursUp ()
{
   pCursRelative (0, -1);
}


/*---------------------------------------------------------------------------*/
/* pCursDn() - Move terminal emulation cursor down one relative to curr [scf]*/
/*---------------------------------------------------------------------------*/

proc pCursDn ()
{
   pCursRelative (0, 1);
}


/*---------------------------------------------------------------------------*/
/* pCursRt() - Move terminal emulation cursor right one relative to curr[scf]*/
/*---------------------------------------------------------------------------*/

proc pCursRt ()
{
   pCursRelative (1, 0);
}


/*---------------------------------------------------------------------------*/
/* pCursLt() - Move terminal emulation cursor left one relative to curr [scf]*/
/*---------------------------------------------------------------------------*/

proc pCursLt ()
{
   pCursRelative (-1, 0);
}


/*---------------------------------------------------------------------------*/
/* pVPosAbsolute() -                                                   [scf] */
/*---------------------------------------------------------------------------*/

proc pVPosAbsolute ()
{
   INT vPos;

   vPos = chAscii & 0x1f;
   curLin = vPos % (maxScreenLine + 1);
   escSeq = FALSE;
   escExtend = EXNONE;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pHPosAbsolute() --                                                  [scf] */
/*---------------------------------------------------------------------------*/

proc pHPosAbsolute ()
{
   INT hPos;

   hPos = ((chAscii & 0x70) / 16) * 10;   /* to BCD! */
   hPos += chAscii & 0x0f;
   curCol = hPos % 80;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClrScr() - Clear the screen including attributes.                        */
/*---------------------------------------------------------------------------*/

VOID NEAR pClrScr()
{
   pCursHome();
   clrLines(0, maxScreenLine);
   termState = NULL;
}


VOID FAR fpClrScr()                          /* mbbx: called from aFAR ... */
{
   pClrScr();
}


/*---------------------------------------------------------------------------*/
/* pClrBol() - Clear terminal emulation video from current to beg. of line.  */
/*---------------------------------------------------------------------------*/

proc pClrBol ()
{
   if (curCol == maxChars-1)
      clrLines (curLin, curLin);
   else
      clrChars (curLin, 0, curCol);
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClrBop() - Clear terminal emulation video from curr to beg. of page.     */
/*---------------------------------------------------------------------------*/

proc pClrBop ()
{
   pClrBol ();
   if (curLin > 0)
      clrLines (0, curLin-1);
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClrEol() - Clear logical IT video from present to end of line.     [scf] */
/*---------------------------------------------------------------------------*/

proc pClrEol ()
{
   if (curCol == 0)
      clrLines (curLin, curLin);
   else
      clrChars (curLin, curCol, maxChars-1);
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClrEop() - Clear the logical IT video from present to end of page. [scf] */
/*---------------------------------------------------------------------------*/

proc pClrEop ()
{
   pClrEol ();
   if (curLin < maxScreenLine)
      clrLines (curLin + 1, maxScreenLine);
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClrLine () Clear logical IT video from beginning to end of line.   [scf] */
/*---------------------------------------------------------------------------*/

proc pClrLine ()
{
   clrLines (curLin, curLin);
}


/*---------------------------------------------------------------------------*/
/* scrollAttrib () -                                                   [scf] */
/*---------------------------------------------------------------------------*/

proc scrollAttrib (INT  startLin, INT  endLin, INT  nLines, BOOL up)
{
   LPBYTE  txtSrc;
   LPBYTE  txtDst;
   INT     len;
   // sdj: was unref local - INT	lin;
   // sdj: was unref local - INT	col;

   if ((endLin - startLin) >= nLines)
   {
      txtSrc = (LPBYTE) attrib[0] + startLin*ATTRROWLEN;
      txtDst = txtSrc + nLines*ATTRROWLEN;
      len    = (endLin - startLin + 1 - nLines)*ATTRROWLEN;
      if (up)
         blockMove(txtDst, txtSrc, len);
      else
         blockMove(txtSrc, txtDst, len);
   }
}

/*---------------------------------------------------------------------------*/
/* pLF() -                                                                   */
/*---------------------------------------------------------------------------*/

proc pLF()
{
   LPBYTE txtDst, txtSrc;
   // sdj: was unref local - LONG	newStart, newEnd;
   INT	  len; // sdj: was unref local - maxLin, savLin, bottomLine;
   // sdj: was unref local - INT	width, height;

   checkSelect ();
   UpdateWindow(hTermWnd); /* jtf 3.30 */
   if(curLin == scrRgnEnd)
   {
      if(savTopLine == (maxLines - (maxScreenLine + 2))) /* no buffer left */
      {
         if(savTopLine > 0)                  /* mbbx 1.01: (maxLines == 25) */
         {
            txtDst = GlobalLock (hTE.hText);
            txtSrc = txtDst + maxChars + 2;
            len = (savTopLine - 1) * (maxChars + 2);
            blockMove(txtSrc, txtDst, len);
            txtSrc = txtDst + (savTopLine + scrRgnBeg) * (maxChars + 2);
            txtDst = txtDst + len;
            blockMove(txtSrc, txtDst, (DWORD) maxChars);
            GlobalUnlock(hTE.hText);
            if(curTopLine + visScreenLine < savTopLine)
            {
               if (curTopLine > 0)
                  curTopLine--;
               else
                  lineFeeds++;
            }
            else
               lineFeeds++;
         }
         pDelLin(scrRgnBeg, scrRgnEnd, 1);
      }
      else  /* plenty of buffer */
      {
         if (scrRgnBeg != 0 || scrRgnEnd != maxScreenLine)
         {
            txtSrc = (LPBYTE)GlobalLock (hTE.hText) + savTopLine * (maxChars + 2);
            txtDst = txtSrc + maxChars + 2;
            blockMove (txtSrc, txtDst,  
                        (DWORD) (maxScreenLine + 1) * (maxChars + 2));
            txtDst = txtSrc;
            txtSrc += (scrRgnBeg + 1) * (maxChars + 2);
            blockMove (txtSrc, txtDst, (DWORD) maxChars);
            GlobalUnlock (hTE.hText);
            if (curTopLine + visScreenLine >= savTopLine)
            {
               curTopLine++;
               lineFeeds++;
            }
            savTopLine++;
            pDelLin (scrRgnBeg, scrRgnEnd, 1);
         }
         else 
         {
            if(nScroll > 0)
            {
               if(((scrollBegin == scrRgnBeg) && (scrollEnd == scrRgnEnd)) && 
                  ((nScroll + 1) < ((scrRgnEnd + 1 - scrRgnBeg) >> 2)))
               {
                  nScroll++;
               }
               else
                  termCleanUp();
            }
            else if(nScroll < 0)
               termCleanUp ();

            if(nScroll == 0)
            {
               scrollBegin = scrRgnBeg;
               scrollEnd = scrRgnEnd;
               nScroll = 1;
            }
            if (curTopLine + visScreenLine >= savTopLine)
            {
               curTopLine++;
               lineFeeds++;
            }
            savTopLine++;
            scrollAttrib (scrRgnBeg, scrRgnEnd, 1, TRUE);
            attrib[scrRgnEnd][LFLAGS] = 0;
            clrLines (scrRgnEnd, scrRgnEnd);
         }
      }

      nScrollPos.y = curTopLine;
      updateTermScrollBars(FALSE);

      termDirty = TRUE;
   }
   else
   {
      pCursRelative(0, 1);
      if((curLin - savTopLine) - nScrollPos.y == visScreenLine+1)  /* mbbx: TEST */
         scrollDown(SB_VERT, SB_LINEDOWN, 1);
   }
}

/*---------------------------------------------------------------------------*/
/* pInsLin() - Insert a line into the logical video screen.            [scf] */
/*---------------------------------------------------------------------------*/

proc pInsLin (INT maxLin, INT nLines)
{
   INT line, lin1;
   INT  len;
   LPBYTE txtSrc;
   LPBYTE txtDst;

   if (statusLine)
     clrLines (24,24);
   else
   {
      if(nScroll < 0)
      {
         if(((scrollBegin == curLin) && (scrollEnd == maxLin)) && 
            ((abs(nScroll) + nLines) <= ((maxLin + 1 - curLin) >> 1)))
         {
            nScroll -= nLines;
         }
         else
            termCleanUp();
      }
      else if(nScroll > 0)
         termCleanUp();

      if(nScroll == 0)
      {
         scrollBegin = curLin;
         scrollEnd = maxLin;
         nScroll = -nLines;
      }
      for(line = maxLin - nLines + 1; line <= maxLin; line++)
         if(attrib[line][LFLAGS])
         {
            termCleanUp();
            break;
         }
      scrollAttrib (curLin, maxLin, nLines, FALSE);
      txtSrc = (LPBYTE)GlobalLock (hTE.hText) + 
            (curLin + savTopLine) * (maxChars + 2);
      txtDst = txtSrc + nLines * (maxChars + 2);
      len = (maxLin + 1 - curLin - nLines) * (maxChars + 2);
 
      if (len > 0)
         blockMove (txtSrc, txtDst, (DWORD) len);
      line = curLin + nLines - 1;
      for (lin1 = curLin; lin1 <= line; lin1++)
         attrib[lin1][LFLAGS] = 0;
      clrLines (curLin, line);
      GlobalUnlock (hTE.hText);
   }
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pDelLin() - Delete a line                                                 */
/*---------------------------------------------------------------------------*/

proc pDelLin (INT curLin, INT maxLin, INT nLines)
{
   INT line, lin1;
   INT  len;
   LPBYTE txtSrc;
   LPBYTE txtDst;

   if(statusLine)
      clrLines(24, 24);
   else
   {
      if(nScroll > 0)
      {
         if(((scrollBegin == curLin) && (scrollEnd == maxLin)) && 
            ((nScroll + nLines) <= ((maxLin + 1 - curLin) >> 2)))
         {
            nScroll += nLines;
         }
         else
            termCleanUp();
      }
      else if(nScroll < 0)
         termCleanUp();

      if(nScroll == 0)
      {
         scrollBegin = curLin;
         scrollEnd = maxLin;
         nScroll = nLines;
      }
      for(line = curLin; line < curLin + nLines; line++)
         if(attrib[line][LFLAGS])
         {
            termCleanUp();
            break;
         }
      scrollAttrib (curLin, maxLin, nLines, TRUE);
      txtDst = (LPBYTE)GlobalLock (hTE.hText) + 
            (curLin + savTopLine) * (maxChars + 2);
      txtSrc = txtDst + nLines * (maxChars + 2);
      len = (maxLin + 1 - curLin - nLines) * (maxChars + 2);
      if (len > 0)
         blockMove (txtSrc, txtDst, (DWORD) len);
      line = maxLin - nLines + 1;
      for (lin1 = line; lin1 <= maxLin; lin1++)
         attrib[lin1][LFLAGS] = 0;
      clrLines (line, maxLin);
      GlobalUnlock (hTE.hText);
   }
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pDelChar() - Delete a char from the terminal emulation video.       [scf] */
/*---------------------------------------------------------------------------*/

proc pDelChar(INT nChars)
{
   INT  ndx;
   // sdj: was unref local - INT	savCol;
   INT  theLine;

   DWORD len;

   LPBYTE txtSrc;
   LPBYTE txtDst;
   // sdj: was unref local - LPBYTE txtPtr;
   LPBYTE globalHeap;

   globalHeap = GlobalLock(hTE.hText);
   if(!protectMode)                          /* mbbx: protected fields */
      len = maxChars - nChars - curCol;
   else
      len = getProtCol() - nChars - (curCol+1);
   if(statusLine)
   {
      theLine = maxScreenLine + 1;
      txtDst  = (LPBYTE) line25 + curCol;
   }
   else
   {
      theLine = curLin;
      txtDst  = globalHeap + valIndex ();
   }
   if (len > 0)
   {
      txtSrc  = txtDst + nChars;
      blockMove (txtSrc, txtDst, len);
   }
   else
   {
      nChars = maxChars - curCol;
      len = 0;
   }
   txtSrc = txtDst + len;
   for (ndx = 0; ndx <= (nChars - 1); ndx++)
      txtSrc[ndx] = CHFILL;
   GlobalUnlock (hTE.hText);
   attrib[theLine][LFLAGS] = LCLEAR | LDIRTY;
}


/*---------------------------------------------------------------------------*/
/* begGraphics() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

VOID begGraphics ()   /* macx */
{
   termCleanUp ();
   offCursor ();
}


/*---------------------------------------------------------------------------*/
/* endGraphics() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

VOID endGraphics ()   /* macx */
{
   onCursor ();
}

/*---------------------------------------------------------------------------*/
/* pGrChar () -                                                              */
/*---------------------------------------------------------------------------*/

static HDC graphicsPort;

#define GRCOLBEG  48
#define GRLINBEG  0
#define MAXGRCOL  512

proc pGrSemi ()
{
/* jtfterm */
}


/*---------------------------------------------------------------------------*/
/* pGrDoIt() -                                                               */
/*---------------------------------------------------------------------------*/

proc pGrDoIt (INT    len, HBRUSH p)
{
/* jtfterm */
}


/*---------------------------------------------------------------------------*/
/* pGrFill() -                                                        [scf]  */
/*---------------------------------------------------------------------------*/

proc pGrFill ()
{
   ch = theChar;
   if (ch == 7)
   {
      sysBeep ();
      vidGraphics = GRNONE;
      termState = NULL;
      chrWidth    = stdChrWidth;
      chrHeight   = stdChrHeight;
      endGraphics ();
   }
   else if (ch != CR && ch != LF)
   {
      if (vidBG == -1)
         vidBG = (ch - ' ')*chrWidth;
      else
      {
         vidFG = (ch - ' ')*chrWidth;
         if (vidBG > 0)
            pGrDoIt(vidBG, blackBrush);
         if (vidFG > 0)
            pGrDoIt(vidFG, theBrush);
         vidBG = -1;
      }
   }
   else
      termState = NULL;
} 


/*---------------------------------------------------------------------------*/
/* pGrChar()                                                                 */
/*---------------------------------------------------------------------------*/

proc pGrChar ()
{
   HRGN  hClipRgn;
   RECT  clpRect;
 
   getPort ();
   graphicsPort = thePort;

   GetClientRect (hTermWnd, (LPRECT) &clpRect);
   hClipRgn = CreateRectRgnIndirect ((LPRECT) &clpRect);
   SelectClipRgn(thePort, hClipRgn);
   DeleteObject (hClipRgn);

   ch = the8Char;
   if (vidGraphics == GRSEMI)
      if ((the8Char & 0x80) != 0)
         pGrSemi ();
      else
         termState = NULL;
   else
      pGrFill ();
   releasePort ();
}


/*---------------------------------------------------------------------------*/
/* pSetGrMode() -                                                      [scf] */
/*---------------------------------------------------------------------------*/

proc pSetGrMode()
{
/* jtfterm */
}


/*---------------------------------------------------------------------------*/
/* pSetMode() -                                                        [scf] */
/*---------------------------------------------------------------------------*/

proc pSetMode ()
{
   BYTE chSet;

   termState = NULL;
   if((trmParams.emulate >= ITMVT52) && (trmParams.emulate <= ITMVT220)) /* mbbx: why VT52??? */
      switch (ch)
      {
         case 0x0e:
         case 0x0f:
            if (ch == 0x0e)
               shiftCharSet = 1;
            else
               shiftCharSet = 0;
            chSet = charSet[shiftCharSet];
            if ((chSet == '0') || (chSet == '2'))
               curAttrib |= AGRAPHICS;
            else
               curAttrib &= ANOTGRAPHICS;
            break;
         case 'x': /* VT52/Heath*/
            escExtend = EXSETMODE;
            termState = pSetMode;
            break;
         case 'y': /* VT52/Heath */
            escExtend = EXRESETMODE;
            termState = pSetMode;
            break;
         case '=': 
            keyPadAppMode = TRUE;
            break;
         case '>':
            keyPadAppMode = FALSE;
            break;
         case '<':
            trmParams.emulate = ITMVT100;
            resetEmul ();
            break;
         case '5': /* VT52/Heath */
            if (escExtend == EXSETMODE)
              pCursOff ();
            else
              pCursOn ();
            break;
         case '7': /* VT52/Heath */
            keyPadAppMode = (escExtend == EXSETMODE);
            break;
         case '@':
            chInsMode = TRUE;
            break;
         case 'O':
            chInsMode = FALSE;
            break;
      }
}

/*---------------------------------------------------------------------------*/
/* pDecScs() - VT-100 character set selection.                         [scf] */
/*---------------------------------------------------------------------------*/

proc pDecScs ()
{
   BYTE chSet;

   termState = NULL;
   switch (ch)
   {
      case '(':
         decScs = 0;
         termState = pDecScs;
         break;
      case ')':
         decScs = 1;
         termState = pDecScs;
         break;
      case 'A':
      case 'B':
      case '0':
      case '1':
      case '2':
         charSet[decScs] = ch;
         chSet = charSet[shiftCharSet];
         if ((chSet == '0') || (chSet == '2'))
            curAttrib |= AGRAPHICS;
         else
            curAttrib &= ANOTGRAPHICS;
         break;
   }
}

/*---------------------------------------------------------------------------*/
/* getArg() -                                                                */
/*---------------------------------------------------------------------------*/

#define getArg    ((argNdx < argCount) ? argList[argNdx++] : 0)

/*---------------------------------------------------------------------------*/
/* getParms ()                                                               */
/*---------------------------------------------------------------------------*/

proc getParms ()
{
   p1 = getArg;
   p2 = getArg;
}


/*---------------------------------------------------------------------------*/
/* pInquire() -                                                        [scf] */
/*---------------------------------------------------------------------------*/

proc pInquire()                              /* mbbx 1.04: VT220... */
{
   STRING respStr[32];

   *respStr = 0;

   switch(trmParams.emulate)
   {
   case ITMVT100:
      getParms();
      if(p1 == 0)
         memcpy(respStr, "\7\033[?1;2c", 9);
      break;

   case ITMVT52:
      memcpy(respStr, "\3\033/Z", 5);
      break;
   }

   if(*respStr)
      termStr(respStr, 0, FALSE);

   termState = NULL;
}



/*---------------------------------------------------------------------------*/
/* pTab() -                                                            [scf] */
/*---------------------------------------------------------------------------*/

proc pTab()
{
   INT  ndx;
   INT  savCol;
   INT  lin, col;

   if(!protectMode)
   {
      savCol = curCol;
      ndx    = curCol + 1;
      while (ndx <= 131)
         if(tabs[ndx] == 1)
         {
            curCol = ndx;
            ndx    = 133;
         }
         else
            ndx++;
   }
   else                                      /* mbbx: tab for protected mode */
   {
      lin = 0;
      col = 0;
      repeat
         getUnprot(lin, col, &lin, &col);
      until((lin >= curLin) && (col >= curCol));
      ndx = 0;
      curLin = lin;
      curCol = col;
   }

   if((ndx == 132) || (curCol >= maxChars))
      curCol = maxChars - 1;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClearAllTabs() -                                                   [scf] */
/*---------------------------------------------------------------------------*/

proc pClearAllTabs ()
{
   INT  ndx;

   for (ndx = 0; ndx <= 131; ndx++)
      tabs[ndx] = 0;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pSetTab() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc pSetTab ()
{
   tabs[curCol] = 1;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pClearTab() -                                                       [scf] */
/*---------------------------------------------------------------------------*/

proc pClearTab ()
{
   tabs[curCol] = 0;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pCmpSrvResponse() -                                                 [scf] */
/*---------------------------------------------------------------------------*/

proc pCmpSrvResponse ()
{
/* jtfterm */
}


/*---------------------------------------------------------------------------*/
/* pSndCursor() -                                                      [scf] */
/*---------------------------------------------------------------------------*/

proc pSndCursor()
{
   LONG  finalTicks;

   termState = NULL;

   switch(trmParams.emulate)
   {
   case ITMVT52:
      modemWr (0x1b); delay (5, &finalTicks);
      modemWr ('Y');  delay (5, &finalTicks);
      modemWr ((BYTE) curLin + ' '); delay (5, &finalTicks);
      modemWr ((BYTE) curCol + ' '); delay (5, &finalTicks);
      break;
   }
}


/*---------------------------------------------------------------------------*/
/* pIndex() -                                                                */
/*---------------------------------------------------------------------------*/

proc pIndex ()
{

   if (curLin == scrRgnEnd)
      pDelLin (scrRgnBeg, scrRgnEnd, 1);
   else
      pCursRelative (0, 1);
}

/*---------------------------------------------------------------------------*/
/* pRevIndex() -                                                       [scf] */
/*---------------------------------------------------------------------------*/

proc pRevIndex ()
{
   if (curLin == scrRgnBeg)
      pInsLin (scrRgnEnd, 1);
   else
      pCursRelative (0, -1);
}


/*---------------------------------------------------------------------------*/
/* pSetLineAttrib() -                                                  [scf] */
/*---------------------------------------------------------------------------*/

proc pSetLineAttrib ()
{
   BYTE lAttr;
   INT  theLin;
   INT  savCol;
   INT  ndx;
   INT  half;
   LPBYTE txtPtr;
   LPBYTE globalHeap;

   lAttr = -1;
   switch (ch)
   {
      case '3':
         lAttr = LHIGHTOP;
         break;
      case '4':
         lAttr = LHIGHBOTTOM;
         break;
      case '5':
         lAttr = LNORMAL;
         break;
      case '6':
         lAttr = LWIDE;
         break;
   }
   if (statusLine)
      theLin = 24;
   else
      theLin = curLin;
   if (lAttr != -1)
      if (lAttr != attrib[theLin][LATTRIB])
      {
         savCol = curCol;
         curCol = 0;
         half = maxChars;
         if (lAttr != LNORMAL)
         {
            half = maxChars / 2;
            globalHeap = GlobalLock (hTE.hText);
            txtPtr = globalHeap + valIndex ();
            for (ndx = half; ndx <= (maxChars - 1); ndx++)
            {
               txtPtr[ndx] = ' ';
               attrib[theLin][ndx] = 0;
            }
            GlobalUnlock (hTE.hText);
         }
         attrib[theLin][LATTRIB] = lAttr;
         attrib[theLin][LFLAGS] = LCLEAR | LDIRTY;      /* mbbx: mac version */
         reDrawTermLine (theLin, 0, half);
         curCol = savCol;
      }

   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pInsChar() -                                                        [scf] */
/*---------------------------------------------------------------------------*/

proc pInsChar ()
{
   BOOL savMode;

   if(!protectMode)
   {
      savMode = chInsMode;
      chInsMode = TRUE;
      putChar (' ');
      chInsMode = savMode;
      termState = NULL;
   }
   else
      pDelChar(1);
}


/*---------------------------------------------------------------------------*/
/* pSaveCursorPos() -                                                        */
/*---------------------------------------------------------------------------*/

proc pSaveCursorPos ()
{
   saveCol = curCol;
   saveLin = curLin;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pRestoreCursorPos() -                                                     */
/*---------------------------------------------------------------------------*/

proc pRestoreCursorPos ()
{
   curCol = saveCol;
   curLin = saveLin;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pEscSkip                                                                  */
/*---------------------------------------------------------------------------*/

proc pEscSkip ()
{
   escSkip--;
   if (escSkip <= 0)
      termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* Some change of state procedures                                           */
/*---------------------------------------------------------------------------*/

proc pNullState ()
{
   termState = NULL;
}

proc pCursorState ()
{
   termState = pCursRC;
}	

proc pVPosState ()
{
   termState = pVPosAbsolute;
}

proc pHPosState ()
{
   termState = pHPosAbsolute;
}

proc pLAttrState ()
{
   termState = pSetLineAttrib;
}

/*---------------------------------------------------------------------------*/
/* pAnsi() -                                                           [scf] */
/*---------------------------------------------------------------------------*/

proc pAnsi()
{
   if((chAscii >= '0') && (chAscii <= '?'))
      (*ansiParseTable[chAscii-'0'])();
   else
   {
      if(ansiArg)
         argList[argCount++] = ansiArg;

      (*aEscTable[chAscii &= 0x7F])();       /* mbbx 1.06: modemInp() not masking 8th bit */

      if(termState != aEscTable[chAscii])    /* mbbx 1.10: VT220 8BIT patch !!! */
         termState = NULL;
   }
}

proc pAnsiState ()
{
   termState = pAnsi;
   argNdx = 0;
   argCount = 0;
   ansiArg = 0;
   decPrivate = FALSE;
   heathPrivate = FALSE;
}

proc pGrState ()
{
   termState = pSetGrMode;
}

proc pSkipState ()
{
   escSkip = emulInfo[chAscii] - 128;
   termState = pEscSkip;
}

proc pReverseOff()                           /* mbbx: pProtOff -> pReverseOff */
{
   pVideo(0);
}

proc pReverseOn()                            /* mbbx: pProtOn -> pReverseOn */
{
   pVideo(ABOLD);                               /* mbbx per jtfx */
}

proc pProtOff()                              /* mbbx */
{
   protectMode = FALSE;
   termState = NULL;
}

proc pProtOn()                               /* mbbx */
{
   protectMode = TRUE;
   termState = NULL;
}

proc pBegProtect()                           /* mbbx 1.03: TV925... */
{
   pVideo(APROTECT);
   pVideo(ABOLD);
}

proc pEndProtect()                           /* mbbx 1.03: TV925... */
{
   pVideo(ANORMAL);
}

proc pBegGraphics()                          /* mbbx 1.03: TV925... */
{
   curAttrib |= AGRAPHICS;
   termState = NULL;
}

proc pEndGraphics()                          /* mbbx 1.03: TV925... */
{
   curAttrib &= ANOTGRAPHICS;
   termState = NULL;
}

/*---------------------------------------------------------------------------*/
/* Some patches                                                              */
/*---------------------------------------------------------------------------*/

proc pLinDel ()
{
   pDelLin(curLin, maxScreenLine, 1);        /* mbbx per slcx */
}

proc pCharDel ()
{
   pDelChar(1);
}

proc pLinIns ()
{
   pInsLin(maxScreenLine, 1);
}

proc pNextLine ()
{
   pLF ();
   curCol = 0;
}


proc pClrAll()
{
   protectMode = FALSE;
   pClrScr();
}


proc pPrintOn()
{
   PrintFileComm(TRUE);         /* mbbx 1.03: prAction(!prtFlag); */
   termState = NULL;
}


proc pPrintOff()
{
   // sdj: was unref local - BYTE	work[STR255];

   PrintFileComm(FALSE);         /* mbbx 1.03: prAction(!prtFlag); */
   termState = NULL;
}

/*---------------------------------------------------------------------------*/

#define TRANS_PRINT_BUFFER       4

STRING   transPrtBuf[TRANS_PRINT_BUFFER+1];

proc pTransPrint()                           /* mbbx 2.01.32 ... */
{
   if(trmParams.emulate == ITMVT100)
   {
      getParms();
      switch(p1)
      {
      case 5:
         transPrintFlag = TRUE;
         *transPrtBuf = 0;                /* slc gold 017 */
         break;

      case 4:
         PrintFileComm(FALSE);
         transPrintFlag = FALSE;
         break;

      case 1:
         /* print cursor line */
         break;

      case 0:
         /* print screen */
         break;
      }
   }
   else
      transPrintFlag = TRUE;

   if(transPrintFlag)
      PrintFileComm(TRUE);

   termState = NULL;
}

/*---------------------------------------------------------------------------*/


proc pVideoAttrib()                          /* mbbx 1.03: added breaks !!! */
{
   switch(trmParams.emulate)
   {
/* jtfterm */
   }
   termState = NULL;
}


proc pVideoAttribState()
{
   termState = pVideoAttrib;
}


proc pCursorOnOff()
{
   if(chAscii != '0')
      pCursOn();
   else
      pCursOff();
}


proc pCursorOnOffState()
{
   termState = pCursorOnOff;
}


/*---------------------------------------------------------------------------*/
/* pAnswerBack() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

proc pAnswerBack()
{
#ifdef ORGCODE
   INT     i;
#else
   DWORD     i;
#endif

   BYTE    saveEcho;
   LONG    finalTicks;
   STRING  temp[DCS_ANSWERBACKSZ+1];                  /* rkhx 2.00 */

   saveEcho = trmParams.localEcho;
   trmParams.localEcho = FALSE;              /* mbbx 1.10: CUA */

   strcpy(temp+1, trmParams.answerBack);     /* rkhx 2.00 */
   *temp = strlen(temp+1);
   stripControl(temp);
   for(i = 1; i <= *temp; i++)
   {
      modemWr(temp[i]);
      delay(2, &finalTicks);
   }

   trmParams.localEcho = saveEcho;
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pEchoOff() -                                                        [mbb] */
/*---------------------------------------------------------------------------*/

proc pEchoOff()
{
   trmParams.localEcho = FALSE;              /* mbbx 1.10: CUA */
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pEchoOn() -                                                         [mbb] */
/*---------------------------------------------------------------------------*/

proc pEchoOn()
{
   trmParams.localEcho = TRUE;               /* mbbx 1.10: CUA */
   termState = NULL;
}


/* mbbx: added to make the TABLE handling consistent 1/6/88 */

proc pCR()
{
   if((trmParams.emulate == ITMDELTA) && (curCol > 0))
   {
      while(curCol < maxChars)
      {
         putChar(SP);
         curCol++;
      }
   }
   curCol = 0;

   if(statusLine)                            /* mbbx 1.03: TV925 per slcx... */
   {
      curLin = 0;
      statusLine = FALSE;
   }
}


proc pBackSpace()
{
   if(curCol > 0) /* jtf 3.14 */
      curCol--;
/* jtf 3.33   putChar(SP); */  /* desctructive backspace 3.17 */ 

}


proc pBeep()
{
   if(trmParams.sound)                       /* mbbx 1.04: synch */
      sysBeep();
}


/*---------------------------------------------------------------------------*/
/* pEscSequence                                                              */
/*---------------------------------------------------------------------------*/

proc pEscSequence()
{
   (*pEscTable[chAscii & 0x7F])();           /* mbbx 2.00: modemInp() not masking 8th bit */
}


/*------------------  >>> pAnsi() Global Declarations <<<  ------------------*/

/* Procedure pAnsi () */

/*---------------------------------------------------------------------------*/
/* aSetCompLevel() - set VT220 Compatibility Level                 [mbb/rkh] */
/*---------------------------------------------------------------------------*/

VOID NEAR aSetCompLevel()                    /* mbbx 1.10: VT220 8BIT... */
{
   BYTE  newEmul;

   termState = NULL;

   switch(ch)
   {
   case '"':
      termState = aSetCompLevel;
      break;

   case 'p':
      switch(getArg)
      {
      case 61:
         newEmul = ITMVT100;
         break;
      case 62:
         newEmul = ITMVT220;
         trmParams.fCtrlBits = !(getArg == 1);
         break;
      default:
         return;
      }

      if(newEmul != trmParams.emulate)
      {
         trmParams.emulate = newEmul;
         resetEmul();
      }
      break;
   }
}


VOID NEAR pSetCtrlBits()                     /* mbbx 2.00: VT220 8BIT... */
{
   termState = NULL;

   switch(ch)
   {
   case ' ':
      termState = pSetCtrlBits;
      break;
   case 'F':
      trmParams.fCtrlBits = FALSE;
      break;
   case 'G':
      trmParams.fCtrlBits = TRUE;
      break;
   }
}


/*---------------------------------------------------------------------------*/
/* aCursor()                                                           [scf] */
/*---------------------------------------------------------------------------*/

proc aCursor()
{
   register INT lin, col;

   getParms ();
   if (p1 == 0)
      p1 = 1;
   if (p2 == 0)
      p2 = 1;
   lin = p1 - 1;
   col = p2 - 1;
   if (originMode)
   {
      lin += scrRgnBeg;
      if (lin < scrRgnEnd)
         curLin = lin;
      else
         curLin = scrRgnEnd;
   }
   else
      if (lin <= maxScreenLine)
      {
         if (statusLine)
         {
            statusLine = FALSE;
         }
         curLin = lin;
      }
      else
      {
         if (!statusLine)
         {
            statusLine = TRUE;
         }
         curLin = maxScreenLine;
      }
   if (col < maxChars)
      curCol = col;
}


/*---------------------------------------------------------------------------*/
/* aClrEol() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aClrEol ()
{
   getParms ();
   if (p1 == 0)
      pClrEol ();
   else if (p1 == 1)
      pClrBol ();
   else if (p1 == 2)
   {
      pClrBol ();
      pClrEol ();
   }
}


/*---------------------------------------------------------------------------*/
/* aClrEop() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aClrEop ()
{
   getParms ();
   if (p1 == 0)
      pClrEop ();
   else if (p1 == 2)
      pClrScr ();
   else if (p1 == 1)
      pClrBop ();
}


/*---------------------------------------------------------------------------*/
/* aCursUp() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aCursUp ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   pCursRelative (0, (INT) -p1);
}


/*---------------------------------------------------------------------------*/
/* aCursDn() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aCursDn ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   pCursRelative (0, (INT) p1);
}


/*---------------------------------------------------------------------------*/
/* aCursRt() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aCursRt ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   pCursRelative ((INT) p1, 0);
}


/*---------------------------------------------------------------------------*/
/* aCursLt() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aCursLt ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   pCursRelative ((INT) -p1, 0);
}


/*---------------------------------------------------------------------------*/
/* aClearTabs() -                                                      [scf] */
/*---------------------------------------------------------------------------*/

proc aClearTabs ()
{
   getParms ();
   if (p1 == 3)
      pClearAllTabs ();
   else if (p1 == 0)
      pClearTab ();
}


/*---------------------------------------------------------------------------*/
/* aVideo() -                                                          [scf] */
/*---------------------------------------------------------------------------*/

proc aVideo ()
{
   repeat
   {
      switch ((WORD) getArg)
      {
         case 0:
            curAttrib &= AGRAPHICS;
            break;
         case 1:
            curAttrib |= ABOLD;
            break;
         case 4:
            curAttrib |= AUNDERLINE;
            break;
         case 5:
            curAttrib |= ABLINK;
            break;
         case 7:
            curAttrib |= AREVERSE;
            break;
      }
   }
   until (argNdx == argCount);
}


/*---------------------------------------------------------------------------*/
/* aSetMode() -                                                        [mbb] */
/*---------------------------------------------------------------------------*/

proc aSetMode()                              /* mbbx 2.00: cleanup... */
{
   while(argNdx < argCount)
   {
      switch(ch)
      {
      case 'h':
         if(decPrivate)                      /* SET DEC private modes */
         {
            switch(getArg)
            {
            case 1:
               cursorKeyMode = TRUE;
               break;
            case 6:
               originMode = TRUE;
               curLin     = scrRgnBeg;
               curCol     = 0;
               break;
            case 7:
               trmParams.lineWrap = TRUE;    /* mbbx 1.10: CUA... */
               break;
            }
         }
         else if(heathPrivate)               /* RESET heath private modes */
         {
            switch(getArg)
            {
            case 5:
               pCursOn();
               break;
            case 7:
               keyPadAppMode = FALSE;
               break;
            }
         }
         else
         {
            switch(getArg)
            {
            case 4:
               chInsMode = TRUE;
               break;
            }
         }
         break;

      case 'l':
         if(decPrivate)                      /* RESET DEC private modes */
         {
            switch(getArg)
            {
            case 1:
               cursorKeyMode = FALSE;
               break;
            case 2:
               trmParams.emulate = ITMVT52;
               resetEmul ();
               break;
            case 6:
               originMode = FALSE;
               pCursHome();
               break;
            case 7:
               trmParams.lineWrap = FALSE;   /* mbbx 1.10: CUA... */
               break;
            }
         }
         else if(heathPrivate)
         {
            switch(getArg)                   /* SET HEATH private modes */
            {
            case 5:
               pCursOff();
               break;
            case 7:
               keyPadAppMode = TRUE;
               break;
            }
         }
         else
         {
            switch(getArg)
            {
            case 4:
               chInsMode = FALSE;
               break;
            }
         }
         break;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* aReport() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aReport()                               /* mbbx 1.04: cleanup... */
{
   STRING   respStr[16];

   getParms();
   switch(p1)
   {
   case 6:
      sprintf(respStr+1, "\033[%d;%dR", curLin+1, curCol+1);
      *respStr = strlen(respStr+1);
      break;

   case 5:
      memcpy(respStr, "\4\033[0n", 5);
      break;
   }

   if(*respStr != 0)
      termStr(respStr, 0, FALSE);
}



/*---------------------------------------------------------------------------*/
/* aSetScrRgn() -                                                      [scf] */
/*---------------------------------------------------------------------------*/

proc aSetScrRgn ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   if (p2 == 0)
      p2 = 1;
   if ((p2 > p1) && (p2 <= (maxScreenLine + 1)))
   {
      scrRgnBeg = p1 - 1;
      scrRgnEnd = p2 - 1;
   }
   else if (p2 == 1)
   {
      scrRgnBeg = 0;
      scrRgnEnd = maxScreenLine;
   }
   if (originMode)
      curLin = scrRgnBeg;
   else
      curLin = 0;
   curCol = 0;
}


/*---------------------------------------------------------------------------*/
/* aDelLin() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aDelLin ()
{
   INT  len;

   getParms ();
   if (p1 == 0)
      p1 = 1;
   if ((curLin >= scrRgnBeg) && (curLin <= scrRgnEnd))
   {
      len = scrRgnEnd - curLin + 1;
      if (p1 > len)
         p1 = len;
      pDelLin(curLin, scrRgnEnd, (INT) p1);  /* mbbx per slcx */
      curCol = 0;
   }
}


/*---------------------------------------------------------------------------*/
/* aInsLin() -                                                         [scf] */
/*---------------------------------------------------------------------------*/

proc aInsLin ()
{
   INT  len;

   getParms ();
   if (p1 == 0)
      p1 = 1;
   if ((curLin >= scrRgnBeg) && (curLin <= scrRgnEnd))
   {
      len = scrRgnEnd - curLin + 1;
      if (p1 > len)
         p1 = len;
      pInsLin (scrRgnEnd, (INT) p1);
      curCol = 0;
   }
}


/*---------------------------------------------------------------------------*/
/* aDelChar() -                                                        [scf] */
/*---------------------------------------------------------------------------*/

proc aDelChar ()
{
   getParms ();
   if (p1 == 0)
      p1 = 1;
   pDelChar ((INT) p1);
}


/*---------------------------------------------------------------------------*/
/* VT-100 exceptions (same terminator for ANSI and non-Ansi sequence)        */
/*---------------------------------------------------------------------------*/

proc pVT100H ()
{
   if (termState == pAnsi)
      aCursor ();
   else
      pSetTab ();
   termState = NULL;
}

proc pVT100D ()
{
   if (termState == pAnsi)
      aCursLt ();
   else
      pLF ();
   termState = NULL;
}

proc pVT100M ()
{
   if (termState == pAnsi)
      aDelLin ();
   else
      pRevIndex ();
   termState = NULL;
}

proc pVT100c()
{
   if(termState == pAnsi)
      pInquire();                            /* mbbx 1.10: aReport() was wrong! */
   else
   {
      resetEmul();
      pClrScr();
   }
   termState = NULL;
}


proc pVT100P()                               /* mbbx: new routine */
{
   if(termState == pAnsi)
      aDelChar();
   else
      termState = pDCS;                      /* mbbx: yterm */
}


/*---------------------------------------------------------------------------*/
/* pDCS() -                                                                  */
/*---------------------------------------------------------------------------*/

proc pDCS()
{
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* pDCSTerminate() -                                                         */
/*---------------------------------------------------------------------------*/

proc pDCSTerminate()
{
   termState = NULL;
}


/*---------------------------------------------------------------------------*/
/* Ansi Parser Routines                                                      */
/*---------------------------------------------------------------------------*/

proc ansiArgument ()   /* chAscii IN ['0' .. '9'] */
{
   ansiArg = (ansiArg*10) + chAscii - '0';
}

proc ansiDelimiter ()  /* chAscii == ';' */
{
   if (argCount < MAXANSIARGS)
      argList[argCount++] = ansiArg;
   ansiArg = 0;
}

proc ansiHeathPrivate ()  /* chAscii == '>' */
{
   heathPrivate = TRUE;
}

proc ansiDecPrivate ()   /* chAscii == '?' */
{
   decPrivate = TRUE;
}


/*---------------------------------------------------------------------------*/
/* putRcvChar() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR writeRcvChar(BYTE  theChar)
{
LPSTR lpBuffer;                                                         /* rjs bugs 016 */
   lpBuffer = GlobalLock(xferBufferHandle);                             /* rjs bugs 016 */

   if((!xferSaveCtlChr) && ((theChar == BS) || (theChar == DEL)))	/* rjs bugs 016 */
      {
      // sdj: if the very first character in the 1k pkt happens to
      // sdj: be BS or DEL, then --xferBufferCount is going to be
      // sdj: 64K! causing the access violation.
      // sdj: lets not write the BS,DEL into the text file in these
      // sdj: cases because what needs to be changed is the last byte
      // sdj: of the last pkt which was written to the file! forget
      // sdj: that for the time being and avoid the access violation.
      if (xferBufferCount)
      lpBuffer[--xferBufferCount] = 0x00;				/* rjs bugs 016 */
      }
   else                                                                 /* rjs bugs 016 */
      lpBuffer[xferBufferCount++] = theChar;                            /* rjs bugs 016 */

   if (xferBufferCount == 1024)                                         /* rjs bugs 016 */
     if (_lwrite((INT)xferRefNo, (LPSTR)lpBuffer,(INT) 1024) != 1024)   /* rjs bugs 016 */
   {
      GlobalUnlock(xferBufferHandle);                                   /* rjs bugs 016 */
      xferEnd();

      TF_ErrProc(STREWRERR, MB_OK | MB_ICONHAND, 999);
      return(FALSE);
   }

      GlobalUnlock(xferBufferHandle);                                   /* rjs bugs 016 */
      if (xferBufferCount==1024) xferBufferCount = 0;                   /* rjs bugs 016 */

   if(( (xferLength += 1) % 0x0400 ) == 0L )                            /* rjs bugs 016 */
      showBBytes(xferLength, FALSE);

   return(TRUE);
}


VOID NEAR putRcvChar(BYTE  theChar)
{
   BYTE  the7Char = theChar & 0x7F;

   if(xferTableSave)
   {
      switch(the7Char)
      {
      case CR:
         tblPos = TBLBEGINLINE;
         break;

      case TAB:
         tblPos = TBLSPACES;
         return;

      case SP:
         if(tblPos < TBLSPACES)
            tblPos += 1;
         return;

      default:
         if(xferSaveCtlChr || (the7Char == FF) || (the7Char == LF) || 
            ((the7Char >= 0x20) && (the7Char <= 0x7E)))
         {
            switch(tblPos)
            {
            case TBLONESPACE:
               if(!writeRcvChar(SP))
                  return;
               break;
            case TBLSPACES:
               if(!writeRcvChar(TAB))
                  return;
               break;
            }

            tblPos = TBLNONSPACE;
         }
         break;
      }
   }

   if(xferSaveCtlChr || (the7Char == TAB) || (the7Char == FF) || (the7Char == LF) || 
      (the7Char == CR) || (the7Char == BS) || (the7Char == DEL) ||   /* rjs bugs 016 -> add BS and DEL */
      ((the7Char >= 0x20) && (the7Char <= 0x7E)))
   {
      writeRcvChar(theChar);
   }
}

/*---------------------------------------------------------------------------*/
/* checkTransPrint() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

#define TRANS_PRINT_BUFFER       4

STRING   transPrtBuf[TRANS_PRINT_BUFFER+1];

VOID NEAR checkTransPrint(BYTE  theChar)
{
   switch(theChar)
   {
   case 0x14:
      if((trmParams.emulate == ITMADDS) || (trmParams.emulate == ITMTVI925))
         transPrintFlag |= 0x8000;
      break;

   case '4':
      if((trmParams.emulate == ITMADDS) && (*transPrtBuf == 1))
         transPrintFlag = FALSE;
      break;

   case 'a':
      if((trmParams.emulate == ITMTVI925) && (*transPrtBuf == 1))
         transPrintFlag = FALSE;
      break;

   case 'i':
      if(((trmParams.emulate == ITMVT220) || (trmParams.emulate == ITMVT100)) && 
         (*transPrtBuf == 3) && (transPrtBuf[2] == '[') && (transPrtBuf[3] == '4'))
      {
         if(transPrintFlag)
         {
            transPrintFlag = FALSE;
            PrintFileComm(FALSE);
         }
      }
      break;
   }

   if(transPrintFlag || (prtFlag && !prtPause))
   {
      if(((theChar & 0x7F) != ESC) && !(transPrintFlag & 0x8000))
         transPrtBuf[++(*transPrtBuf)] = theChar;

      if(((theChar & 0x7F) == ESC) || (transPrintFlag & 0x8000) || (*transPrtBuf == 1) || (*transPrtBuf >= TRANS_PRINT_BUFFER))
      {
         if(*transPrtBuf > 0)
         {
            PrintFileString((LPSTR) transPrtBuf+1, (LONG) *transPrtBuf, FALSE);
            *transPrtBuf = 0;
         }

         if((theChar & 0x7F) == ESC)
         {
            transPrtBuf[++(*transPrtBuf)] = ESC;
            if((theChar == 0x9B) && (trmParams.emulate == ITMVT220))
               transPrtBuf[++(*transPrtBuf)] = '[';
         }

         if(transPrintFlag & 0x8000)
            transPrintFlag = FALSE;
      }
   }

   if(transPrintFlag && !prtFlag)
      PrintFileComm(TRUE);
}


/*---------------------------------------------------------------------------*/
/* modemInp () -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

VOID modemInp(INT   theChar, BOOL  bRcvComm)
{
   cursorValid = FALSE;

   the8Char = (BYTE) theChar;

   if(bRcvComm)      /* mbbx 2.00: not restricted... */
   {
      if((xferFlag == XFRRCV) && !xferPaused)
         putRcvChar(the8Char);
   }

   if(transPrintFlag || (prtFlag && !prtPause))
      checkTransPrint(the8Char);

   chAscii = the8Char;                       /* ... mbbx 2.00: mask done in getMdmChar() */
   ch = chAscii;                             /* mbbx: patch */

   if((chAscii & 0x7F) == ESC)               /* mbbx 2.00: not masking 8th bit... */
   {
      if((the8Char & 0x80) && (trmParams.emulate == ITMVT220))    /* mbbx 1.10: CSI = ESC + '[' */
         pAnsiState();
      else
         termState = escHandler;
   }
   else if(termState)                        /* mbbx 2.00: do this AFTER checking for ESC... */
      (*termState)();
   else if((chAscii >= 0x20) && (chAscii != 0x7F))    /* mbbx 1.04: ics... */
   {
      putChar(chAscii);
      if(curCol < maxChars-1)
         curCol += 1;
      else if(trmParams.lineWrap)            /* mbbx 1.10: CUA... */
      {
         curCol = 0;
         pLF();
      }
   }
   else
      (*escHandler)();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\netubci.h ===
/*****************************************************************************/
/* UBNETCI: definitions for Ungermann-Bass Command interpreter interface     */
/*****************************************************************************/

/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/

#define INT_UBNETCI           0x6B

#define UBC_CALL_WRITE        0x00           /* int 6B calls... */
#define UBC_CALL_READ         0x01
#define UBC_CALL_CONTROL      0x06
#define UBC_CALL_STATUS       0x07
#define UBC_CALL_READBREAK    0x08

#define UBC_PORT_COM1         0x00
#define UBC_PORT_COM2         0x01

#define UBC_CNTRL_CMD_BREAK   0x02
#define UBC_CNTRL_CMD_DISCON  0x04
#define UBC_CNTRL_CMD_HOLD    0x06
#define UBC_CNTRL_CMD_ENABLEXON  0x08           /* slc swat */
#define UBC_CNTRL_CMD_DISABLEXON 0x10

#define UBC_STAT_IDLE         0xFF
#define UBC_STAT_CI           0x00
#define UBC_STAT_NET          0x01


/*****************************************************************************/
/* Forward Procedure Definitions                                             */
/*****************************************************************************/

VOID UBC_exitSerial();
VOID UBC_resetSerial(recTrmParams *, BOOL);  /* mbbx 2.01.141 */

BOOL UBC_mdmConnect();
VOID UBC_modemReset();
VOID UBC_modemSendBreak(INT);
INT NEAR UBC_ReadComm(LPSTR, INT);
VOID UBC_modemBytes();
INT NEAR UBC_WriteComm(LPSTR, INT);
BOOL UBC_modemWrite(LPSTR, INT);
/* WORD NEAR UBC_CallNetCI(BYTE, WORD, LPBYTE, WORD);   tge gold 006 */
WORD UBC_CallNetCI(BYTE, WORD, LPBYTE, WORD);
WORD UBC_LOW_CallNetCI(WORD, WORD, WORD, WORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\phone.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31
#define  USECOMM

#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "connect.h"


/*--------------------- >>> Local Global Declarations <<< -------------------*/

static INT retryCnt;
static INT timeOutSec;                       /* mbbx 2.00: display time remaining */


/*---------------------------------------------------------------------------*/
/* dbDialing() - Dialing dialog box message proccessing.                     */
/*---------------------------------------------------------------------------*/

#define MAX_DIAL_STRLEN             21       /* mbbx 2.00: CUA */

INT_PTR APIENTRY dbDialing(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
   CHAR  tmp1[TMPNSTR], tmp2[TMPNSTR];
   COMSTAT  serInfo;

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);                      /* mbbx 2.00: CUA... */

      strcpy(tmp1, trmParams.phone);
      if(strlen(tmp1) > MAX_DIAL_STRLEN)
         strcpy(tmp1+(MAX_DIAL_STRLEN-3), "...");
      SetDlgItemText(hDlg, IDDIALING, tmp1);

      retryCnt = 0;
      itemHit = -1;

      if(!SetTimer(hDlg, -1, 128, NULL))    /* rjs bugs 006 */
      {
         LoadString(hInst, STRERRNOTIMERS, tmp1, TMPNSTR);
         MessageBox(hDlg, tmp1, NULL, MB_OK | MB_ICONEXCLAMATION);
         break;
      }

      return(TRUE);

   case WM_TIMER:
      if(itemHit == -1)
      {
         sprintf(tmp1, "%u", timeOutSec = trmParams.dlyRetry);    /* mbbx 2.00: time remaining... */
         SetDlgItemText(hDlg, IDDIALTIME, tmp1);

         if(!sPortErr)    /* rjs bug2 */
         {
            termSendCmd(trmParams.originate, strlen(trmParams.originate), TRUE);    /* mbbx 2.01.19 ... */
            getMdmResult();

            termSendCmd(trmParams.dialPrefix, strlen(trmParams.dialPrefix), FALSE);

            strcpy(tmp1, trmParams.phone);      /* mbbx 2.01.18 ... */
            strcpy(tmp1+strlen(tmp1), trmParams.phone2);
            termSendCmd(tmp1, strlen(tmp1), 0x0080 | FALSE);

            termSendCmd(trmParams.dialSuffix, strlen(trmParams.dialSuffix), TRUE);

         }
         else
            modemReset();

         dialStart = tickCount();
         itemHit = 0;
      }
      else if(itemHit == 0)
      {
         updateTimer();

         if(trmParams.fCarrier)               /* mbbx 1.10: CUA... */
            mdmConnect();
         else if(modemBytes())
         {
            getMdmResult();
            mdmOnLine = (mdmValid && (mdmResult[2] == 'C'));
//            mdmOnLine = TRUE;
         }

         if(mdmOnLine)
         {
            getMdmResult();
            if(trmParams.flgSignal)
            {
               sysBeep();
               sysBeep();                    /* mbbx 2.00: more noise for signal... */
               sysBeep();
            }
            timerAction(TRUE, TRUE);         /* mbbx 1.03 */
            break;
         }

         if((tickCount() - dialStart) > (DWORD)((trmParams.dlyRetry > 30) ? (trmParams.dlyRetry * 60) : (30 * 60)))
         {
            if((trmParams.flgRetry) && ((retryCnt < trmParams.cntRetry) || (trmParams.cntRetry == 255)))
            {
               LoadString(hInst, STR_RETRYCOUNT, tmp1, TMPNSTR);
               sprintf(tmp2, tmp1, ++retryCnt);
               SetDlgItemText(hDlg, IDDIALRETRY, tmp2);

               if(trmParams.flgSignal)       /* mbbx 2.00: redial beep optional... */
                  sysBeep();

               itemHit = -1;
            }
            else
            {
               if(!sPortErr)    /* rjs bug2 */
                  modemWr(CR);
               break;
            }
         }
         else if((INT)(trmParams.dlyRetry - ((tickCount() - dialStart) / 60)) != timeOutSec)
         {
            sprintf(tmp1, "%u", timeOutSec = trmParams.dlyRetry - ((tickCount() - dialStart) / 60));
            SetDlgItemText(hDlg, IDDIALTIME, tmp1);
         }
      }
      return(TRUE);

   case WM_COMMAND:                          /* mbbx 2.00: only one control... */
      modemWr(CR);
      break;

   default:
      return(FALSE);
   }

   KillTimer(hDlg, -1);                      /* mbbx 2.00: eliminate statics... */
   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* dialPhone() -                                                       [scf] */
/*---------------------------------------------------------------------------*/

VOID dialPhone()
{
   BYTE tmp1[TMPNSTR];
   DCB  dcb;

   if(trmParams.comDevRef == ITMDLLCONNECT)  /* slc nova 031 */
   {
      DLL_ConnectConnector(ghCCB, TRUE);
      return;
   }

   if(*trmParams.phone == 0)                 /* Don't dial if no phone no.   */
      doSettings(IDDBPHON, dbPhon);

   if(*trmParams.phone == 0)                 /* Don't dial if no phone no.   */
      return;

   while(modemBytes())
      rdModem(FALSE);

   offCursor();
   if(mdmOnLine)                             /* Tell user to hang up         */
   {
      LoadString(hInst, STR_HANGUP, tmp1, TMPNSTR);
         itemHit = testBox(NULL, -(MB_OK | MB_ICONHAND), STR_ERRCAPTION, tmp1);
      onCursor();
      return;
   }

   if(trmParams.flgRetry )
      trmParams.cntRetry = 255;

   dialing = TRUE;
   DialogBox(hInst, MAKEINTRESOURCE(IDDBDIALING), GetFocus(), dbDialing);
   dialing = FALSE;

   onCursor();
   trmParams.cntRetry = 0;
}


/*---------------------------------------------------------------------------*/
/* hangUpPhone() -                                                   [scf]   */
/*---------------------------------------------------------------------------*/

VOID hangUpPhone()
{
   if(trmParams.comDevRef == ITMDLLCONNECT)  /* slc nova 031 */
   {
      DLL_DisconnectConnector(ghCCB);
      return;
   }

   SetCursor(LoadCursor(NULL, IDC_WAIT));    /* mbbx 1.10: ala jtf */

   delay(33, NULL);                          /* mbbx 0.62: formerly 66 ticks */

   termSendCmd(trmParams.hangSuffix, strlen(trmParams.hangSuffix), 0x0040 | TRUE);  /* mbbx 2.01.19 ... */
   getMdmResult();

   if(trmParams.fCarrier)                     /* mbbx 1.10: carrier... */
      mdmConnect();
   else
      mdmOnLine = FALSE;

   modemReset();                             /* mbbx: isolate COM */
   timerAction(FALSE, FALSE);                /* mbbx 1.03 */

   SetCursor(LoadCursor(NULL, IDC_ARROW));   /* mbbx 1.10: ala jtf */
}


/*---------------------------------------------------------------------------*/
/* getMdmResult() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID getMdmResult()
{
   LONG  begTime;

   begTime = tickCount();
   *mdmResult = 0;
   mdmValid = FALSE;

   repeat
   {
      rdModem(TRUE);
      if(!dialing)
         idleProcess();
   }
   until(mdmValid || ((tickCount() - begTime) > 90));

   if(!mdmValid && (*mdmResult >= 2))
      mdmValid = TRUE;                       /* mbbx: override timeout !!! */
}


/*---------------------------------------------------------------------------*/
/* termSendCmd() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

/* convert ==>       ABCDEFGHIJKLMNOPQRSTUVWXYZ */
#define PHONE_CHARS "2223334445556667-77888999-"

BOOL termSendCmd(BYTE *   str, int      nBytes, WORD     wFlags)
{
   INT   ndx;

   if(wFlags & 0x0040)                       /* get modem's attention */
   {
      if(nBytes == 0)
         return(TRUE);

      termSendCmd(trmParams.hangPrefix, strlen(trmParams.hangPrefix), (3 << 8) | FALSE);
      delay(66, NULL);
      getMdmResult();
   }

   for(ndx = 0; ndx < nBytes; ndx += 1)
   {
      if(wFlags & 0x0080)                    /* xlate phone string */
      {
         if((str[ndx] >= 'A') && (str[ndx] <= 'Z'))
            str[ndx] = PHONE_CHARS[str[ndx] - 'A'];
         else if((str[ndx] >= 'a') && (str[ndx] <= 'z'))
            str[ndx] = PHONE_CHARS[str[ndx] - 'a'];
      }

      modemWr(str[ndx]);

      if((wFlags & 0xFF00) > 0)
         delay(((wFlags >> 8) & 0x00FF), NULL);

      if(!dialing)                           /* mbbx 2.01.19: why is this needed ??? */
         idleProcess();
   }

   if(wFlags & 0x0001)                       /* send CR */
      modemWr(CR);

   if(wFlags & 0x0002)                       /* clear modem response */
      getMdmResult();

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\rdmodem.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"


BREAKCOND breakcondition_rdModem;
                        

/*---------------------------------------------------------------------------*/
/* rdModem() - Read characters from system modem into local IT buffer. [scf] */
/*---------------------------------------------------------------------------*/

VOID rdModem(BOOL rFlag)
{
   INT  i;
   INT  yieldCount;
   MSG  msg;

   if(modemBytes())
   {
      if(answerMode)
      {
         theChar = getMdmChar(TRUE);         /* mbbx 1.06A: ics new xlate */
         return;
      }

      later = FALSE;
      hideTermCursor();
      yieldCount = 0;
      getPort();

      repeat
      {
         theChar = (the8Char = getMdmChar(TRUE));  /* mbbx 1.06A: ics new xlate... */

         if(rFlag)
         {
            modemInp(the8Char, TRUE);        /* mbbx: make this optional ??? */

            if(mdmResult[0] < MDMRESLEN)
               mdmResult[++(*mdmResult)] = theChar;
            if(theChar != LF)
            {
               if(mdmResult[0] == 1)
                  mdmResult[0] = 0;          /* throw it away!!! */
            }
            else if(mdmResult[0] > 2)
               mdmValid = TRUE;
            later = TRUE;
         }
         else
         {
            if(xferWaitEcho)
               if(xferTxtType == XFRLINE)    /* (jtfx) */
               {
                  if(theChar == xferLinStr[xferWaitEcho])
                     if(xferWaitEcho == xferLinStr[0])
                        xferWaitEcho = FALSE;
                     else
                        xferWaitEcho++;
               }
               else if((xferTxtType == XFRCHAR) && (theChar == xferCharEcho))    /* (jtfx) */
                  xferWaitEcho = FALSE;

            modemInp(the8Char, TRUE);        /* mbbx 1.10 */
            if(theChar == CR)
               if(trmParams.inpCRLF)         /* mbbx 1.10: CUA */
                  modemInp(LF, TRUE);

            if(!modemBytes())
               later = TRUE;

            if(++yieldCount == YIELDCHARS)
            {
               termCleanUp();                /* mbbx: per mac version */
               yieldCount = 0;
               if(yield(&msg, (HWND) NULL))   /* mbbx */
                  later = TRUE;
            }
         }
      } until(later);

      activSelect = FALSE;    /* rjs bugs 020 */
      termCleanUp();
      showTermCursor();
      releasePort();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\rcvbfile.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "fileopen.h"
#include "task.h"


/*---------------------------------------------------------------------------*/
/* rcvBPre() -                                                         [mbb] */
/*---------------------------------------------------------------------------*/

VOID rcvBPre(BYTE *fileName)
{
   WORD  fScale = ((xferBinType != XFRYMODEM) && (xferBinFork == XFRBOTH)) ? IDSCALE : 0;

   showXferCtrls(IDSTOP | IDFORK | fScale | IDSENDING | IDBERRORS);
   showRXFname(fileName, STR_RECEIVING);
}


/*---------------------------------------------------------------------------*/
/* rcvPutBFile() -                                              [scf]        */
/*---------------------------------------------------------------------------*/

BOOL rcvPutBFile()
{
   BOOL     rcvPutBFile = FALSE;
   FSReply  reply;
   WORD     wMode;
   BYTE     fileExt[FILENAMELEN+1];
   OFSTRUCT file;


      wMode = FO_PUTFILE; /* jtf 3.31 | ((xferBinType == XFRYMODEM) ? FO_BATCHMODE : FO_NONDOSFILE); */
      if(xferBinType == XFRKERMIT)
     /* jtf 3.17    wMode |= FO_REMOTEFILE */ ;
      getFileDocData(FILE_NDX_DATA, reply.vRefNum, reply.fName, fileExt, NULL);
      *macFileName = 0;
                                             /* mbbx 1.10: CUA... */
      if(reply.vRefNum[strlen(reply.vRefNum) - 1] != '\\')
         strcat(reply.vRefNum, "\\");

      if(reply.good = FileOpen(reply.vRefNum, reply.fName, macFileName, fileExt, 
                               NULL, FO_DBRCVFILE, NULL, wMode))
      {
         useMacFileName = (*macFileName != 0);
      }

   if(reply.good)
   {
      setFileDocData(FILE_NDX_DATA, reply.vRefNum, reply.fName, NULL, NULL);  /* mbbx 2.00: no forced extents */

      strcpy(xferVRefNum+1, reply.vRefNum);  /* mbbx 0.62: save the path !!! */
      *xferVRefNum = strlen(xferVRefNum+1);

      xferRefNo = 0;
      if(xferBinType != XFRYMODEM)           /* mbbx 1.01: ymodem */
      {
         strcpy(xferFname+1, useMacFileName ? macFileName : reply.fName);
         *xferFname = strlen(xferFname+1);

         if((xferBinType == XFRYTERM) && !answerMode)       /* mbbx: yterm */
            return(FALSE);
#ifdef ORGCODE
         strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
#else

         strcpy(reply.vRefNum+strlen(reply.vRefNum), "\\");
         strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
         DEBOUT("rcvPutBfile: opening %s\n",reply.vRefNum);
         DEBOUT("rcvPutBfile: %s","using O_CREAT|O_TRUNC, S_IWRITE args\n");
#endif
         /* jtf 3.20 */
         if((xferRefNo = OpenFile((LPSTR) reply.vRefNum, (LPOFSTRUCT)&file,
                                  OF_WRITE | OF_CREATE)) == -1)
         {
            xferRefNo = 0;                   /* mbbx 2.00: remove XTalk... */
            rcvErr(reply.fName);
            return(FALSE);
         }
      }

      xferErrors  = 0;
      xferLength  = 0L;
      xferPct     = 0;
      xferOrig    = -1;

      rcvBPre(reply.fName);
      rcvPutBFile = TRUE;
   }

   return(rcvPutBFile);
}


/*---------------------------------------------------------------------------*/
/* rcvBFile() -                                                  [scf]       */
/*---------------------------------------------------------------------------*/

VOID rcvBFile()
{
   if(xferFlag != XFRNONE)                   /* mbbx 1.10: answerMode... */
   {
      return;
   }

   xferFast  = FALSE;

   if(!answerMode)
   {
      switch(trmParams.xBinType)
      {
      case ITMXMODEM:
         xferBinType = XFRXMODEM;
         break;

      case ITMKERMIT:
         KERRCVFLAG = KERFILE;
         xferBinType = XFRKERMIT;
         break;
      }
   }

      xferBinFork = XFRDATA;


   if(rcvPutBFile())
   {
      xferFlag = XFRBRCV;
   }
}



/*---------------------------------------------------------------------------*/
/* rcvTerminate() -                                             [scf]        */
/*---------------------------------------------------------------------------*/

VOID rcvTerminate()
{
   BYTE        filePath[PATHLEN];
   OFSTRUCT    dummy;

   if(xferRefNo != 0)                        /* mbbx 1.01: ymodem */
   {
      _lclose(xferRefNo);
      strcpy(filePath, xferVRefNum+1);
      strcpy(filePath+strlen(filePath), xferFname+1);
      MOpenFile((LPSTR) filePath, (LPOFSTRUCT) &dummy, OF_DELETE);
   }
}


/*---------------------------------------------------------------------------*/
/* rcvAbort() -                                                  [scf]       */
/*---------------------------------------------------------------------------*/

VOID rcvAbort()
{
   BYTE tmp1[TMPNSTR+1];

      LoadString(hInst, STR_ABORTRCV, (LPSTR) tmp1, TMPNSTR);
      testBox(NULL, -(MB_ICONEXCLAMATION | MB_OK), STR_APPNAME, tmp1, &xferFname[1]);
   rcvTerminate();
}


/*---------------------------------------------------------------------------*/
/* rcvFileErr() -                                               [scf]        */
/*---------------------------------------------------------------------------*/

VOID rcvFileErr()
{
   memcpy(taskState.string, xferFname, *xferFname+2);
   TF_ErrProc(STREWRERR, MB_OK | MB_ICONHAND, 999);


   rcvTerminate();
}



/*---------------------------------------------------------------------------*/
/* xRcvBFile() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

VOID xRcvBFile()
{
   BYTE  saveDataBits, saveParity, saveFlowCtrl;

   termSendCmd(trmParams.binRXPrefix, strlen(trmParams.binRXPrefix), 0x42 | TRUE);   /* mbbx 2.01.19 ... */

   saveDataBits = trmParams.dataBits;        /* mbbx 2.00: auto adjust settings... */
   saveParity   = trmParams.parity;
   saveFlowCtrl = trmParams.flowControl;     /* mbbx 2.00.05: eliminate flowSerial()... */

   trmParams.dataBits = ITMDATA8;
   trmParams.parity = ITMNOPARITY;
   trmParams.flowControl = ITMNOFLOW;
   resetSerial(&trmParams, FALSE, FALSE, 0);  /* mbbx 2.00.05: auto reset... */

   switch(xferBinType)
   {
   case XFRXMODEM:
      XM_RcvFile(0x0800);                    /* XM_CRC */
      break;

   case XFRKERMIT:
      KER_Receive(FALSE);                    /* rkhx 2.00 */
      break;
   }

   if((trmParams.dataBits != saveDataBits) || (trmParams.parity != saveParity) || (trmParams.flowControl != saveFlowCtrl))
   {
      trmParams.dataBits = saveDataBits;
      trmParams.parity = saveParity;
      trmParams.flowControl = saveFlowCtrl;
      resetSerial(&trmParams, FALSE, FALSE, 0); /* slc swat */
   }

   termSendCmd(trmParams.binRXSuffix, strlen(trmParams.binRXSuffix), 0x42 | TRUE);   /* mbbx 2.01.19 ... */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\scroll.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"


/*---------------------------------------------------------------------------*/
/* updateTermScrollBars() -                                            [mbb] */
/*---------------------------------------------------------------------------*/

VOID updateTermScrollBars(BOOL  bScroll)
{
   INT   saveScrollRange, offset;

   saveScrollRange = nScrollRange.y;
   if((offset = maxScreenLine - visScreenLine) < 0)
      offset = 0;
   if((nScrollRange.y = savTopLine + offset) < 0)
      nScrollRange.y = 0;

   if(((nScrollPos.y > 0) && (nScrollPos.y == saveScrollRange)) || (nScrollPos.y > nScrollRange.y)) 
      nScrollPos.y = nScrollRange.y;

   if(!trmParams.fHideTermVSB)
   {
      SetScrollRange(hTermWnd, SB_VERT, 0, (nScrollRange.y > 0) ? nScrollRange.y : 1, FALSE);
      if (GetScrollPos(hTermWnd, SB_VERT) != nScrollPos.y)    /* jtf 3.14 */
         SetScrollPos(hTermWnd, SB_VERT, nScrollPos.y, TRUE);
   }
   else
      SetScrollRange(hTermWnd, SB_VERT, 0, 0, TRUE);

   if(!trmParams.fHideTermHSB)
   {
      SetScrollRange(hTermWnd, SB_HORZ, 0, (nScrollRange.x > 0) ? nScrollRange.x : 1, FALSE);
      if (GetScrollPos(hTermWnd, SB_HORZ) != nScrollPos.x)    /* jtf 3.14 */
         SetScrollPos(hTermWnd, SB_HORZ, nScrollPos.x, TRUE);
   }
   else
      SetScrollRange(hTermWnd, SB_HORZ, 0, 0, TRUE);

   if(bScroll)
      scrollBits();
}


/*---------------------------------------------------------------------------*/
/* scrollTermWindow() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

proc scrollTermWindow(INT  dh, INT  dv)
{
   ScrollWindow(hTermWnd, -dh*chrWidth, -dv*chrHeight, (LPRECT) &hTE.viewRect,
                (LPRECT) &hTE.viewRect);
}


/*---------------------------------------------------------------------------*/
/* scrollTermLine() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

proc scrollTermLine(INT  newLine, INT  dh, INT  dv)
{
   RECT  r;

   getPort();
   hTE.active = 0;

   if(dv > 0)
      r.top = hTE.viewRect.bottom - stdChrHeight;
   else
      r.top = 0;
   r.left = hTE.viewRect.left;
   r.bottom = r.top + stdChrHeight;
   r.right = hTE.viewRect.right;

   scrollTermWindow(dh, dv);
   ValidateRect(hTermWnd, (LPRECT) &r);

   reDrawTermLine(newLine, 0, maxChars);
   clipRect(&r);
   termActivate(&hTE);
   releasePort();
}


/*---------------------------------------------------------------------------*/
/* scrollBits() - Move text on term. screen + some IT house keeping.   [mbb] */
/*---------------------------------------------------------------------------*/

VOID scrollBits()
{
   INT   oldTopLine;
   INT   oldLeftCol;
   INT   dh, dv;
   INT   offset;
   INT   lin;

   oldLeftCol = curLeftCol;
   oldTopLine = curTopLine;

   curLeftCol = nScrollPos.x;
   curTopLine = nScrollPos.y;
   dh = curLeftCol - oldLeftCol;
   dv = curTopLine - oldTopLine;

   hideTermCursor();
   if(dh != 0)
   {
      scrollTermWindow(dh, dv);
      UpdateWindow(hTermWnd);
   }
   else if(dv == 1)
      scrollTermLine(curTopLine-savTopLine+visScreenLine, dh, dv);
   else if(dv == -1)
      scrollTermLine(curTopLine-savTopLine, dh, dv);
   else if(dv != 0)
   {
      termDeactivate(&hTE); 
      reDrawTermScreen(0, visScreenLine+1, curTopLine - savTopLine);    /* mbbx 2.00: jtf disp2... */
      termActivate(&hTE); 
   }
   showTermCursor();

   if((curTopLine + visScreenLine) > (savTopLine + maxScreenLine))   /* mbbx 2.00.06: jtf disp2... */
      cleanRect(maxScreenLine+1, (visScreenLine + curTopLine) - (savTopLine + maxScreenLine));
}


/*---------------------------------------------------------------------------*/
/* scrollUp() -                                                              */
/*---------------------------------------------------------------------------*/

VOID scrollUp(INT   nBar, INT   partCode, INT   deltaLines)
{
   LONG   *pScrollPos;

   if(partCode == SB_LINEUP)
   {
      pScrollPos = ((nBar == SB_VERT) ? &nScrollPos.y : &nScrollPos.x);

      if(*pScrollPos > 0)
      {
         *pScrollPos -= deltaLines;
         updateTermScrollBars(TRUE);
      }
   }
}


/*---------------------------------------------------------------------------*/
/* scrollDown() -                                                            */
/*---------------------------------------------------------------------------*/

VOID scrollDown(INT   nBar, INT   partCode, INT   deltaLines)
{
   LONG  *pScrollRange, *pScrollPos;

   if(partCode == SB_LINEDOWN)
   {
      if(nBar == SB_VERT)
      {
         pScrollRange = &nScrollRange.y;
         pScrollPos   = &nScrollPos.y;
      }
      else
      {
         pScrollRange = &nScrollRange.x;
         pScrollPos   = &nScrollPos.x;
      }

      if(*pScrollPos < *pScrollRange)
      {
         *pScrollPos += deltaLines;
         updateTermScrollBars(TRUE);
      }
   }
}


/*---------------------------------------------------------------------------*/
/* pageScroll() -                                                            */
/*---------------------------------------------------------------------------*/

VOID pageScroll(INT   which)
{
   if(which == SB_PAGEUP)
   {
      if((nScrollPos.y -= (visScreenLine + 1)) < 0)
         nScrollPos.y = 0;
   }
   else
   {
      if((nScrollPos.y += (visScreenLine + 1)) > nScrollRange.y)
         nScrollPos.y = nScrollRange.y;
   }

   updateTermScrollBars(TRUE);
   termCleanUp();
}


/*---------------------------------------------------------------------------*/
/* hPageScroll() -                                                           */
/*---------------------------------------------------------------------------*/

VOID hPageScroll(INT   which)
{
   nScrollPos.x = ((which == SB_PAGEUP) ? 0 : nScrollRange.x);
   updateTermScrollBars(TRUE);
   termCleanUp();                            /* mbbx 1.04: per jtfx */
}


/*---------------------------------------------------------------------------*/
/* trackScroll() -                                                     [scf] */
/*---------------------------------------------------------------------------*/

VOID trackScroll(INT   nBar, INT   partCode)
{
   LONG  *pScrollRange, *pScrollPos;
   INT   amount;

   if(nBar == SB_VERT)
   {
      pScrollRange = &nScrollRange.y;
      pScrollPos   = &nScrollPos.y;
   }
   else
   {
      pScrollRange = &nScrollRange.x;
      pScrollPos   = &nScrollPos.x;
   }

   amount = (((partCode == SB_LINEUP) || (partCode == SB_PAGEUP)) ? -1 : 1);

   if(((amount == -1) && (*pScrollPos > 0)) || ((amount == 1) && (*pScrollPos < *pScrollRange)))
   {
      if((partCode == SB_PAGEUP) || (partCode == SB_PAGEDOWN))
      {
         if(nBar == SB_VERT)
         {
            if(amount == -1)
            {
               if((*pScrollPos -= ((hTE.viewRect.bottom - hTE.viewRect.top) / chrHeight)) < 0)
                  *pScrollPos = 0;
            }
            else
            {
               if((*pScrollPos += ((hTE.viewRect.bottom - hTE.viewRect.top) / chrHeight)) > *pScrollRange)
                  *pScrollPos = *pScrollRange;
            }
         }
         else
            *pScrollPos += ((amount == -1) ? 0 : *pScrollRange);
      }
      else
         *pScrollPos += amount;

      updateTermScrollBars(FALSE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\pwin32.c ===
#include <excpt.h>
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include <dde.h>
#include "port1632.h"

/*** this is replaced by the regulat WinMain call

HANDLE APIENTRY MGetInstHandle()
{
    return((HANDLE)NtCurrentPeb()->ImageBaseAddress);
}

*********/


  
/*----------------------------------USER-------------------------------------*/


/*-------------------------------------DEV-----------------------------------*/

    
/*-----------------------------------KERNEL----------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\prtsetup.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"


/*---------------------------------------------------------------------------*/

#define PRTLISTSIZE              2048


/*---------------------------------------------------------------------------*/
/* Print Setup Utilities                                               [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR PrtGetList(HANDLE   *hList, LPSTR    *lpList)
{
   BYTE  szDevices[MINRESSTR];

   if((*hList = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD) PRTLISTSIZE)) == NULL)
      return(FALSE);

   if((*lpList = GlobalLock(*hList)) == NULL)
   {
      *hList = GlobalFree(*hList);
      return(FALSE);
   }

   LoadString(hInst, STR_INI_DEVICES, (LPSTR) szDevices, sizeof(szDevices));
   return(GetProfileString((LPSTR) szDevices, NULL, NULL_STR, *lpList, PRTLISTSIZE));  /* mbbx 2.01.97 ... */
/* return(GetProfileString((LPSTR) szDevices, NULL, NULL, *lpList, PRTLISTSIZE)); */
}


/*---------------------------------------------------------------------------*/

VOID NEAR PrtFreeList(HANDLE   hList)
{
   GlobalUnlock(hList);
   GlobalFree(hList);
}


/*---------------------------------------------------------------------------*/

WORD NEAR PrtGetDevice(BYTE  *pDevice, BYTE  *pDriver, BYTE  *pPort)
{
   WORD  PrtGetDevice;
   BYTE  szDevice[MINRESSTR], work[STR255];
   BYTE  *pch;

   LoadString(hInst, STR_INI_DEVICES, (LPSTR) szDevice, sizeof(szDevice));
   GetProfileString((LPSTR) szDevice, (LPSTR) pDevice, NULL_STR, (LPSTR) work, sizeof(work));

   *pDriver = 0;
   *pPort = 0;
   sscanf(work, "%[^,]%c%s", pDriver, szDevice, pPort);

   for(pch = pDriver + strlen(pDriver); (pch > pDriver) && (*(pch-1) == 0x20); pch -= 1);
   *pch = 0;

   if(PrtGetDevice = (*pPort != 0))
   {
      for(pch = pPort; *pch != 0; pch += 1)
         if(*pch == ',')
         {
            *pch = 0;
            PrtGetDevice += 1;
         }

      *(pch+1) = 0;
   }

   return(PrtGetDevice);
}


/*---------------------------------------------------------------------------*/

BOOL NEAR PrtTestDevice(BYTE  *pDevice, BYTE  *pDriver, BYTE  *pPort, BYTE  *pResult)
{
   BYTE  szWindows[MINRESSTR], szDevice[MINRESSTR];
   BYTE  work[STR255];

   sprintf(pResult, "%s,%s,%s", pDevice, pDriver, pPort);

   LoadString(hInst, STR_INI_WINDOWS, (LPSTR) szWindows, sizeof(szWindows));
   LoadString(hInst, STR_INI_DEVICE, (LPSTR) szDevice, sizeof(szDevice));
   GetProfileString((LPSTR) szWindows, (LPSTR) szDevice, NULL_STR, (LPSTR) work, sizeof(work));
   /* changed from strcmpi -sdj */
   return(lstrcmpi(pResult, work) == 0);
}


/*---------------------------------------------------------------------------*/
/* PrtInitList() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR PrtInitList(HWND  hDlg)
{
   HANDLE   hList;
   LPSTR    lpList;
   INT      nSelect, nCount, ndx, ndx2;
   BYTE     work[STR255], szDriver[80], szPort[128], szDevice[128];

   SetCursor(LoadCursor(NULL, IDC_WAIT));

   if(PrtGetList(&hList, &lpList))
   {
      nSelect = -1;
      nCount = 0;

      for(ndx = 0; (lpList[ndx] != 0) && (ndx < PRTLISTSIZE); 
          ndx += (lstrlen(lpList + ndx) + 1))
      {
         lstrcpy((LPSTR) work, lpList + ndx);
         if(PrtGetDevice(work, szDriver, szPort))
         {
            for(ndx2 = 0; szPort[ndx2] != 0; 
                ndx2 += (strlen(szPort + ndx2) + 1))
            {
               if(PrtTestDevice(work, szDriver, szPort + ndx2, szDevice))
                  nSelect = nCount;

               strcpy(szDevice, work);
               LoadString(hInst, STR_INI_ON, (LPSTR) szDevice + strlen(szDevice), MINRESSTR);
               strcpy(szDevice + strlen(szDevice), szPort + ndx2);
               SendDlgItemMessage(hDlg, IDPRINTNAME, LB_INSERTSTRING, -1, (LPARAM) szDevice);

               nCount += 1;
            }
         }
      }

      if(nSelect != -1)
         SendDlgItemMessage(hDlg, IDPRINTNAME, LB_SETCURSEL, nSelect, 0L);
      else
      {
         EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
         EnableWindow(GetDlgItem(hDlg, IDPRTSETUP), FALSE);
      }

      PrtFreeList(hList);
   }

   SetCursor(LoadCursor(NULL, IDC_ARROW));
}


/*---------------------------------------------------------------------------*/
/* PrtDoCommand() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR PrtDoCommand(HWND  hDlg, BOOL  bSetup)
{
   HANDLE   hList, hDriver;
   LPSTR    lpList;
   INT      nSelect, nPorts, ndx;
   CHAR     work[STR255], szDriver[80], szPort[128], szDevice[128];
   FARPROC  lpDriver;

   if((nSelect = (INT)SendDlgItemMessage(hDlg, IDPRINTNAME, LB_GETCURSEL, 0, 0L)) == -1)
      return(TRUE);

   SetCursor(LoadCursor(NULL, IDC_WAIT));

   if(PrtGetList(&hList, &lpList))
   {
      for(ndx = 0; nSelect >= 0; ndx += (lstrlen(lpList + ndx) + 1))
      {
         lstrcpy(work, lpList + ndx);
         if((nPorts = PrtGetDevice(work, szDriver, szPort)) > nSelect)
         {
            for(ndx = 0; nSelect > 0; ndx += (strlen(szPort + ndx) + 1))
            {
               if(szPort[ndx] == 0)
                  break;

               nSelect -= 1;
            }
            break;
         }

         nSelect -= nPorts;
      }

      PrtFreeList(hList);

      if(nSelect == 0)
      {
         if(bSetup)
         {
            strcpy(szDriver + strlen(szDriver), DRIVER_FILE_TYPE+2);
/* jtf 3.14            if((hDriver = fileLoadLibrary(szDriver)) != NULL) */

         /*if((hDriver = MLoadLibrary((LPSTR) szDriver)) >= 32)
            LoadLibrary >= 32  changed to LoadLibrary != NULL -sdj*/
#ifdef ORGCODE
         if((hDriver = LoadLibrary((LPSTR) szDriver)) >= 32) /* jtf 3.14 */
#else
         if((hDriver = LoadLibrary((LPSTR) szDriver)) != NULL) /* jtf 3.14 */
#endif
            {
               LoadString(hInst, STR_INI_DEVICEMODE, (LPSTR) szDevice, sizeof(szDevice));
               if(lpDriver = GetProcAddress(hDriver, (LPSTR) szDevice))
                  (*lpDriver) (hDlg, hDriver, (LPSTR) work, (LPSTR) szPort);

               FreeLibrary(hDriver);
            }
         }
         else if(!PrtTestDevice(work, szDriver, szPort + ndx, szDevice))
         {
            LoadString(hInst, STR_INI_WINDOWS, (LPSTR) work, sizeof(work));
            LoadString(hInst, STR_INI_DEVICE, (LPSTR) szDriver, sizeof(szDriver));
            WriteProfileString((LPSTR) work, (LPSTR) szDriver, (LPSTR) szDevice);
         }
      }
   }

   SetCursor(LoadCursor(NULL, IDC_ARROW));

   return(bSetup);
}


/*---------------------------------------------------------------------------*/
/* dbPrtSetup() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL  APIENTRY dbPrtSetup(HWND  hDlg, WORD  message, WPARAM wParam, LONG  lParam)
{
   BOOL  result;

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      PrtInitList(hDlg);                     /* mbbx 2.01.149 ... */
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
      case IDCANCEL:
      case IDPRTSETUP:
         result = (GET_WM_COMMAND_ID(wParam, lParam) != IDCANCEL);
         break;

      case IDPRINTNAME:
         switch(GET_WM_COMMAND_CMD(wParam, lParam))
         {
         case LBN_SELCHANGE:
            result = (SendDlgItemMessage(hDlg, IDPRINTNAME, LB_GETCURSEL, 0, 0L) != -1);
            EnableWindow(GetDlgItem(hDlg, IDOK), result);
            EnableWindow(GetDlgItem(hDlg, IDPRTSETUP), result);
            return(TRUE);

         case LBN_DBLCLK:
            result = TRUE;
            break;

         default:
            return(TRUE);
         }
         break;

      default:
         return(FALSE);
      }
      break;

   default:
      return(FALSE);
   }

   if(result)                                /* mbbx 2.01.149 ... */
   {
      if(PrtDoCommand(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == IDPRTSETUP))
         return(TRUE);
   }

   EndDialog(hDlg, 0);
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\settings.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31

#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"                            /* mbbx 1.04: using taskState.string */
#include "connect.h"
#include <ctype.h>    /* adding for prototype of isalpha() -sdj*/

#define SAVEPARAMS                  struct saveParams    /* mbbx 1.04 ... */
#define PSAVEPARAMS                 SAVEPARAMS *

struct saveParams
{
   HANDLE            hData;
   recTrmParams FAR  *lpData;
   INT               saveLevel;
};


/*---------------------------------------------------------------------------*/
/* doSettings() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL doSettings(INT      dbResID, DLGPROC  dbProc)
{
   BOOL     doSettings = FALSE;
   CHAR     work[STR255];

   doSettings = DialogBox(hInst, MAKEINTRESOURCE(dbResID), hItWnd, dbProc);

   if(doSettings == -1)
   {
      LoadString(hInst, STR_OUTOFMEMORY, work, STR255-1);
      testMsg(work,NULL,NULL);
   }

   return(doSettings);
}


/*---------------------------------------------------------------------------*/
/* initDlgPos() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

VOID initDlgPos(HWND hDlg)
{
   RECT  dialogRect, windowRect;


   GetWindowRect(hDlg, &dialogRect);
   dialogRect.right -= dialogRect.left;
   dialogRect.bottom -= dialogRect.top;

   GetWindowRect(hItWnd, &windowRect);
   windowRect.left += (((windowRect.right - windowRect.left) - dialogRect.right) / 2);
   windowRect.top += (((windowRect.bottom - windowRect.top) - dialogRect.bottom) / 2);

   if(windowRect.left < 10)
      windowRect.left = 10;
   else if((windowRect.left + dialogRect.right) > (GetSystemMetrics(SM_CXSCREEN) - 10))
      windowRect.left = (GetSystemMetrics(SM_CXSCREEN) - 10) - dialogRect.right;

   if(windowRect.top < 10)
      windowRect.top = 10;
   else if((windowRect.top + dialogRect.bottom) > (GetSystemMetrics(SM_CYSCREEN) - 10))
      windowRect.top = (GetSystemMetrics(SM_CYSCREEN) - 10) - dialogRect.bottom;

   MoveWindow(hDlg, windowRect.left, windowRect.top, dialogRect.right, dialogRect.bottom, FALSE);
}


/*---------------------------------------------------------------------------*/
/* loadListData() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR loadListData(HWND  hDlg, INT   nItem, INT   nList)
{
   INT   ndx;
   CHAR  work[STR255];

   for(ndx = 0; LoadString(hInst, nList + ndx, work, STR255-1); ndx += 1)
      SendDlgItemMessage(hDlg, nItem, LB_INSERTSTRING, -1, (LPARAM) work);
}


/*---------------------------------------------------------------------------*/
/* dbPhon() -                                                                */
/*---------------------------------------------------------------------------*/

INT_PTR  APIENTRY dbPhon(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   BYTE szPhone[((DCS_MODEMCMDSZ-1)*2)+1];
   BYTE work[255]; /* jtf 3.20 */
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      SendDlgItemMessage(hDlg, ITMPHONENUMBER, EM_LIMITTEXT, sizeof(szPhone)-1, 0L);  /* mbbx 2.00 */
      strcpy(szPhone,trmParams.phone);
      strcpy(szPhone+strlen(szPhone),trmParams.phone2);
      SetDlgItemText(hDlg, ITMPHONENUMBER, szPhone);

      SetDlgItemInt(hDlg, ITMRETRYTIME, trmParams.dlyRetry, FALSE);
      CheckDlgButton(hDlg, ITMRETRY, trmParams.flgRetry);
      CheckDlgButton(hDlg, ITMSIGNAL, trmParams.flgSignal);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         GetDlgItemText(hDlg, ITMPHONENUMBER, szPhone, sizeof(szPhone));
         strncpy(trmParams.phone, szPhone, DCS_MODEMCMDSZ);
         trmParams.phone[DCS_MODEMCMDSZ-1] = 0;
         strcpy(trmParams.phone2, szPhone+strlen(trmParams.phone));

         if((trmParams.dlyRetry = GetDlgItemInt(hDlg, ITMRETRYTIME, NULL, FALSE)) < 30)
            { /* jtf 3.20 */
            LoadString(hInst, STR_MINTIME, work, STR255-1);
            testMsg(work,NULL,NULL);
            trmParams.dlyRetry = 30;
            }
         trmParams.flgRetry = (BYTE)IsDlgButtonChecked(hDlg, ITMRETRY);
         trmParams.flgSignal = (BYTE)IsDlgButtonChecked(hDlg, ITMSIGNAL);
         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         break;

      case ITMRETRY:
      case ITMSIGNAL:
         CheckDlgButton(hDlg, GET_WM_COMMAND_ID(wParam, lParam), !IsDlgButtonChecked(hDlg, GET_WM_COMMAND_ID(wParam, lParam)));
         return(TRUE);

      default:
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/*  dbEmul() -                                                               */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbEmul(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      chkGrpButton(hDlg, ITMTERMFIRST, ITMTERMLAST, (trmParams.emulate != ITMDELTA) ? trmParams.emulate : ITMTTY);
      initDlgPos(hDlg);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         if((wParam = whichGrpButton(hDlg, ITMTERMFIRST, ITMTERMLAST)) != trmParams.emulate)
         {
            trmParams.emulate = (BYTE)wParam;
            resetEmul();
         }
         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         break;

      default:
         chkGrpButton(hDlg, ITMTERMFIRST, ITMTERMLAST, GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* dbTerm() - Terminal Settings dialog control.                        [mbb] */
/*---------------------------------------------------------------------------*/

/* mbbx 2.00: all new font enumeration code... */

int APIENTRY nextFontName(const LOGFONT *lpLogFont, const TEXTMETRIC *lpTextMetrics, 
                          DWORD          FontType, LPARAM lParam)

{
   HWND hDlg = (HWND)lParam;
   BYTE testStr[40];
   BYTE testStr1[40];

   if (lpLogFont->lfPitchAndFamily & FIXED_PITCH)  /* jtf 3.21 */
#ifdef ORGCODE
      SendDlgItemMessage((HWND) LOWORD((LONG) lpData), ITMFONTFACE, LB_ADDSTRING, 0, (LONG) lpLogFont->lfFaceName);
#else
      SendDlgItemMessage(hDlg, ITMFONTFACE, LB_ADDSTRING, 0, (LPARAM) lpLogFont->lfFaceName);
#endif

   lstrcpy( testStr, (LPSTR) lpLogFont->lfFaceName); /* jtf 3.21 */
   LoadString(hInst, STR_INI_FONTFACE, testStr1, LF_FACESIZE);
   /* changed from strcmpi -sdj */
   if (lstrcmpi(testStr,testStr1) == 0)
#ifdef ORGCODE
      SendDlgItemMessage((HWND) LOWORD((LONG) lpData), ITMFONTFACE, LB_ADDSTRING, 0, (LONG) lpLogFont->lfFaceName);
#else
      SendDlgItemMessage(hDlg, ITMFONTFACE, LB_ADDSTRING, 0, (LPARAM) lpLogFont->lfFaceName);
#endif
   return(TRUE);
}


VOID NEAR loadFontNames(HWND  hDlg)
{
   getPort();
#ifdef ORGCODE
   EnumFonts(thePort, NULL, nextFontName, ((LONG) hDlg));
#else
   EnumFonts(thePort, NULL, nextFontName, (LPARAM) hDlg);
#endif
   releasePort();

   SendDlgItemMessage(hDlg, ITMFONTFACE, LB_SELECTSTRING, -1, (LPARAM) (trmParams.fontFace));
}


VOID NEAR loadFontSizes(HWND  hDlg, BYTE  *faceName, INT   fontSize)
{
   CHAR  sizeList[64], work[16];
   INT   ndx, ndx1;

   listFontSizes(faceName, sizeList, 64-1);

   ndx = -1;
   for(ndx1 = 7; ndx1 < 64; ndx1 += 1)
      if(sizeList[ndx1] != 0)
      {
         sprintf(work, "%d", ndx1);
         SendDlgItemMessage(hDlg, ITMFONTSIZE, LB_INSERTSTRING, -1, (LPARAM) (work));

         if((ndx1 <= fontSize) || (ndx == -1))
            ndx += 1;
      }

   SendDlgItemMessage(hDlg, ITMFONTSIZE, LB_SETCURSEL, ndx, 0L);
}


INT NEAR getFontSize(HWND hDlg)                   /* mbbx 2.00: font selection... */
{
   INT   ndx;
   CHAR  work[16];

   ndx = (INT)SendDlgItemMessage(hDlg, ITMFONTSIZE, LB_GETCURSEL, 0, 0L);
   SendDlgItemMessage(hDlg, ITMFONTSIZE, LB_GETTEXT, ndx, (LPARAM) (work));
   sscanf(work, "%d", &ndx);

   return(ndx);
}

INT_PTR APIENTRY dbTerm(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   WORD  tempWord;
   BOOL  tempBool;

   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      if((((PSAVEPARAMS) taskState.string)->hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) == NULL)
         break;
      ((PSAVEPARAMS) taskState.string)->lpData = (recTrmParams FAR *) GlobalLock(((PSAVEPARAMS) taskState.string)->hData);
      *(((PSAVEPARAMS) taskState.string)->lpData) = trmParams;

      CheckDlgButton(hDlg,   ITMLINEWRAP,    trmParams.lineWrap);
      CheckDlgButton(hDlg,   ITMLOCALECHO,   trmParams.localEcho);
      CheckDlgButton(hDlg,   ITMSOUND,       trmParams.sound);
      CheckDlgButton(hDlg,   ITMINCRLF,      trmParams.inpCRLF);
      CheckDlgButton(hDlg,   ITMOUTCRLF,     trmParams.outCRLF);
      CheckRadioButton(hDlg, ITM80COL,       ITM132COL, trmParams.columns);
      CheckRadioButton(hDlg, ITMBLKCURSOR,   ITMUNDCURSOR, trmParams.termCursor);
      CheckDlgButton(hDlg,   ITMBLINKCURSOR, trmParams.cursorBlink);

      loadFontNames(hDlg);                   /* mbbx 2.00: font selection... */
      loadFontSizes(hDlg, trmParams.fontFace, trmParams.fontSize);

      ((PSAVEPARAMS) taskState.string)->saveLevel = -1;

      loadListData(hDlg, ITMTRANSLATE, STR_ICS_NAME);
      SendDlgItemMessage(hDlg, ITMTRANSLATE, LB_SETCURSEL, trmParams.language, 0L);

      SetDlgItemInt(hDlg, ITMBUFFERLINES, trmParams.bufferLines = maxLines, FALSE); /* mbbx 2.00.03 ... */

      CheckDlgButton(hDlg, ITMSCROLLBARS, !trmParams.fHideTermVSB);
      CheckDlgButton(hDlg, ITMIBMXANSI, trmParams.setIBMXANSI); /* rjs swat */
      CheckDlgButton(hDlg, ITMWINCTRL,  trmParams.useWinCtrl);  /* rjs swat */

      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
                                             /* mbbx 2.00.03 ... */
/* rjs bug2 002 */
         tempWord = GetDlgItemInt(hDlg, ITMBUFFERLINES, (BOOL FAR *)&tempBool, FALSE);

         if(tempBool)
         {
            if(tempWord > 399)
            {
               MessageBeep(0);
               lParam = 0xFFFF0000;
               SendDlgItemMessage(hDlg, ITMBUFFERLINES, EM_SETSEL, GET_EM_SETSEL_MPS( 0, lParam));
               return(TRUE);
            }
         }
         else
         {
               MessageBeep(0);
               lParam = 0xFFFF0000;
               SendDlgItemMessage(hDlg, ITMBUFFERLINES, EM_SETSEL, GET_EM_SETSEL_MPS(0, lParam));
               return(TRUE);
         }
/* end rjs bug2 002 */

         if(tempWord != trmParams.bufferLines)
            trmParams.bufferLines = tempWord;

         resetTermBuffer();

         icsResetTable((WORD) SendDlgItemMessage(hDlg, ITMTRANSLATE, LB_GETCURSEL, 0, 0L));

         if(((PSAVEPARAMS) taskState.string)->saveLevel != -1)    /* mbbx 2.00: font selection... */
            buildTermFont();

         updateTermScrollBars(FALSE);

         if(!IsIconic(hItWnd))/* rjs bugs 015 */
            sizeTerm(0L);

         termData.flags |= TF_CHANGED;

         // clears the hTermWnd make sure there's no garbage left
         // when font is changed.
         InvalidateRect (hTermWnd, NULL, TRUE);
         UpdateWindow (hTermWnd);
         break;

      case IDCANCEL:
         trmParams = *(((PSAVEPARAMS) taskState.string)->lpData);
         break;

      case ITMIBMXANSI:
         CheckDlgButton(hDlg, ITMIBMXANSI, trmParams.setIBMXANSI = !trmParams.setIBMXANSI);
         return(TRUE);
      case ITMLINEWRAP:
         CheckDlgButton(hDlg, ITMLINEWRAP, trmParams.lineWrap = !trmParams.lineWrap);
         return(TRUE);
      case ITMLOCALECHO:
         CheckDlgButton(hDlg, ITMLOCALECHO, trmParams.localEcho = !trmParams.localEcho);
         return(TRUE);
      case ITMSOUND:
         CheckDlgButton(hDlg, ITMSOUND, trmParams.sound = !trmParams.sound);
         return(TRUE);

      case ITMINCRLF:
         CheckDlgButton(hDlg, ITMINCRLF, trmParams.inpCRLF = !trmParams.inpCRLF);
         return(TRUE);
      case ITMOUTCRLF:
         CheckDlgButton(hDlg, ITMOUTCRLF, trmParams.outCRLF = !trmParams.outCRLF);
         return(TRUE);

      case ITM80COL:
      case ITM132COL:
         CheckRadioButton(hDlg, ITM80COL, ITM132COL, trmParams.columns = wParam);
         return(TRUE);

      case ITMBLKCURSOR:
      case ITMUNDCURSOR:
         CheckRadioButton(hDlg, ITMBLKCURSOR, ITMUNDCURSOR, trmParams.termCursor = wParam);
         return(TRUE);
      case ITMBLINKCURSOR:
         CheckDlgButton(hDlg, ITMBLINKCURSOR, trmParams.cursorBlink = !trmParams.cursorBlink);
         return(TRUE);

      case ITMFONTFACE:
// -sdj 10/09 LBN_ HAS CHANGED IN WIN32, have to take care of this in spec.
#ifdef ORGCODE
         if(HIWORD(lParam) == LBN_SELCHANGE)    /* mbbx 2.00: font selection... */
#else
         if(HIWORD(wParam) == LBN_SELCHANGE)    /* mbbx 2.00: font selection... */
#endif
         {
            SendDlgItemMessage(hDlg, ITMFONTFACE, LB_GETTEXT, SendDlgItemMessage(hDlg, ITMFONTFACE, LB_GETCURSEL, 0, 0L), 
                               (LPARAM) (trmParams.fontFace));

            SendDlgItemMessage(hDlg, ITMFONTSIZE, LB_RESETCONTENT, 0, 0L);
            loadFontSizes(hDlg, trmParams.fontFace, trmParams.fontSize);
         }
      case ITMFONTSIZE:

// -sdj 10/09 LBN_ HAS CHANGED IN WIN32, have to take care of this in spec.
#ifdef ORGCODE
         if(HIWORD(lParam) == LBN_SELCHANGE)    /* mbbx 2.00: font selection... */
#else
         if(HIWORD(wParam) == LBN_SELCHANGE)    /* mbbx 2.00: font selection... */
#endif
         {
            trmParams.fontSize = getFontSize(hDlg);
            ((PSAVEPARAMS) taskState.string)->saveLevel = 0;
         }
         return(TRUE);

      case ITMTRANSLATE:
      case ITMBUFFERLINES:
         return(TRUE);

      case ITMSCROLLBARS:
         CheckDlgButton(hDlg, ITMSCROLLBARS, !(trmParams.fHideTermVSB = !trmParams.fHideTermVSB));
         trmParams.fHideTermHSB = trmParams.fHideTermVSB;
         return(TRUE);

      case ITMWINCTRL:
         CheckDlgButton(hDlg, ITMWINCTRL, trmParams.useWinCtrl = !trmParams.useWinCtrl);
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   if(((PSAVEPARAMS) taskState.string)->hData != NULL)
   {
      GlobalUnlock(((PSAVEPARAMS) taskState.string)->hData);
      GlobalFree(((PSAVEPARAMS) taskState.string)->hData);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* dbFkey() - Dialog box control for function keys.                          */
/*---------------------------------------------------------------------------*/

VOID NEAR setDlgFkeys(HWND  hDlg, INT   level)
{
   INT   key;

   for(key = 0; key < DCS_NUMFKEYS; key += 1)
   {
      SetDlgItemText(hDlg, ITMFKEYTITLE+(key+1), trmParams.fKeyTitle[level-1][key]); /* rkhx 2.00 */
      SetDlgItemText(hDlg, ITMFKEYTEXT+(key+1), trmParams.fKeyText[level-1][key]);
   }
}


VOID NEAR getDlgFkeys(HWND  hDlg, INT   level)
{
   INT   key;

   for(key = 0; key < DCS_NUMFKEYS; key += 1)
   {
      GetDlgItemText(hDlg, ITMFKEYTITLE+(key+1), trmParams.fKeyTitle[level-1][key], DCS_FKEYTITLESZ-2); /* rkhx 2.00 */
      GetDlgItemText(hDlg, ITMFKEYTEXT+(key+1), trmParams.fKeyText[level-1][key], DCS_FKEYTEXTSZ-2); /* jtf 3.12 */
   }
}


INT_PTR APIENTRY dbFkey(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      if((((PSAVEPARAMS) taskState.string)->hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) == NULL)
         break;
      ((PSAVEPARAMS) taskState.string)->lpData = (recTrmParams FAR *) GlobalLock(((PSAVEPARAMS) taskState.string)->hData);
      *(((PSAVEPARAMS) taskState.string)->lpData) = trmParams;
      ((PSAVEPARAMS) taskState.string)->saveLevel = curLevel;


      for(wParam = 1; wParam <= DCS_NUMFKEYS; wParam += 1)
      {
         SendDlgItemMessage(hDlg, ITMFKEYTITLE + wParam, EM_LIMITTEXT, DCS_FKEYTITLESZ-2, 0L);
         SendDlgItemMessage(hDlg, ITMFKEYTEXT + wParam, EM_LIMITTEXT, DCS_FKEYTEXTSZ-3, 0L); /* jtf 3.12 */
      }
      setDlgFkeys(hDlg, curLevel);

      CheckRadioButton(hDlg, ITMLEVEL1, ITMLEVEL4, ITMLEVEL1+(curLevel-1));

      CheckDlgButton(hDlg, ITMSHOWFKEYS, trmParams.environmentFlags & DCS_EVF_FKEYSSHOW);    /* mbbx 2.00: show fkeys... */
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         getDlgFkeys(hDlg, curLevel);

         setFKeyLevel(curLevel, TRUE);       /* mbbx 2.00 */

         if(IsDlgButtonChecked(hDlg, ITMSHOWFKEYS))   /* mbbx 2.00: show fkeys... */
         {
            if(!(trmParams.environmentFlags & DCS_EVF_FKEYSSHOW))
            {
               showHidedbmyControls(TRUE, TRUE);
               trmParams.environmentFlags |= DCS_EVF_FKEYSSHOW;
            }
         }
         else
	    trmParams.environmentFlags &= ~DCS_EVF_FKEYSSHOW;

// -sdj: 02jun92 when keys visible is ticked and ok pressed
//	 IsDlgButtonChecked(hDlg, AUTOARRANGE ) is called, but
//	 AUTOARRANGE is not present in the rc file, NT doesnt like
//	 this any more! If this flag is important then we need to
//	 define this some place to avoid Unknown control Id error
//	 from USER.

#ifdef BUGBYPASS
#else
         if(IsDlgButtonChecked(hDlg, ITMAUTOARRANGE))
            trmParams.environmentFlags |= DCS_EVF_FKEYSARRANGE;
         else
	    trmParams.environmentFlags &= ~DCS_EVF_FKEYSARRANGE;
#endif

         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         trmParams = *(((PSAVEPARAMS) taskState.string)->lpData);
         curLevel = ((PSAVEPARAMS) taskState.string)->saveLevel;
         break;

      case ITMLEVEL1:
      case ITMLEVEL2:
      case ITMLEVEL3:
      case ITMLEVEL4:
         CheckRadioButton(hDlg, ITMLEVEL1, ITMLEVEL4, GET_WM_COMMAND_ID(wParam, lParam));
         getDlgFkeys(hDlg, curLevel);
         setDlgFkeys(hDlg, curLevel = wParam-(ITMLEVEL1-1));
         return(TRUE);

      case ITMSHOWFKEYS:                     /* mbbx 2.00 ... */
         CheckDlgButton(hDlg, GET_WM_COMMAND_ID(wParam, lParam), !IsDlgButtonChecked(hDlg, GET_WM_COMMAND_ID(wParam, lParam)));
         return(TRUE);

      default:
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   if(((PSAVEPARAMS) taskState.string)->hData != NULL)
   {
      GlobalUnlock(((PSAVEPARAMS) taskState.string)->hData);
      GlobalFree(((PSAVEPARAMS) taskState.string)->hData);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* dbTxtX() - Control for Text transfer dialogue box.                        */
/*---------------------------------------------------------------------------*/

VOID NEAR enableStdItems(HWND  hDlg, BOOL  bEnable)
{
   ShowWindow(GetDlgItem(hDlg, ITMSTDGRP), bEnable ? SW_SHOWNOACTIVATE : SW_HIDE);
   ShowWindow(GetDlgItem(hDlg, ITMSTDXON), bEnable && (trmParams.flowControl == ITMXONFLOW) ? SW_SHOWNOACTIVATE : SW_HIDE);
   ShowWindow(GetDlgItem(hDlg, ITMSTDHARD), bEnable && (trmParams.flowControl == ITMHARDFLOW) ? SW_SHOWNOACTIVATE : SW_HIDE);
   ShowWindow(GetDlgItem(hDlg, ITMSTDNONE), bEnable && (trmParams.flowControl == ITMNOFLOW) ? SW_SHOWNOACTIVATE : SW_HIDE);
   UpdateWindow(hDlg);     /* rjs bugs 001 */
}


VOID NEAR enableChrItems(HWND  hDlg, BOOL  bEnable)
{
   INT   nCmdShow, nResID;

   nCmdShow = bEnable ? SW_SHOWNOACTIVATE : SW_HIDE;
   for(nResID = ITMCHRGRP; nResID <= ITMCHRUNITS; nResID += 1)
      ShowWindow(GetDlgItem(hDlg, nResID), nCmdShow);

   if(bEnable)
      EnableWindow(GetDlgItem(hDlg, ITMCHRTIME), trmParams.xChrType == ITMCHRDELAY);

   UpdateWindow(hDlg);     /* rjs bugs 001 */
}


VOID NEAR enableLinItems(HWND  hDlg, BOOL  bEnable)
{
   INT   nCmdShow, nResID;

   nCmdShow = bEnable ? SW_SHOWNOACTIVATE : SW_HIDE;
   for(nResID = ITMLINGRP; nResID <= ITMLINSTR; nResID += 1)
      ShowWindow(GetDlgItem(hDlg, nResID), nCmdShow);

   if(bEnable)
   {
      EnableWindow(GetDlgItem(hDlg, ITMLINTIME), trmParams.xLinType == ITMLINDELAY);
      EnableWindow(GetDlgItem(hDlg, ITMLINSTR), trmParams.xLinType == ITMLINWAIT);
   }

   UpdateWindow(hDlg);     /* rjs bugs 001 */
}


INT_PTR APIENTRY dbTxtX(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   DWORD  temp;
   BYTE  tempStr[16];

   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      if((((PSAVEPARAMS) taskState.string)->hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) == NULL)
         break;
      ((PSAVEPARAMS) taskState.string)->lpData = (recTrmParams FAR *) GlobalLock(((PSAVEPARAMS) taskState.string)->hData);
      *(((PSAVEPARAMS) taskState.string)->lpData) = trmParams;

      CheckRadioButton(hDlg, ITMSTD, ITMLIN, trmParams.xTxtType);
      enableStdItems(hDlg, trmParams.xTxtType == ITMSTD);
      enableChrItems(hDlg, trmParams.xTxtType == ITMCHR);
      enableLinItems(hDlg, trmParams.xTxtType == ITMLIN);

      CheckRadioButton(hDlg, ITMCHRDELAY, ITMCHRWAIT, trmParams.xChrType);
      SetDlgItemInt(hDlg, ITMCHRTIME, trmParams.xChrDelay, FALSE);

      CheckRadioButton(hDlg, ITMLINDELAY, ITMLINWAIT, trmParams.xLinType);
      SetDlgItemInt(hDlg, ITMLINTIME, trmParams.xLinDelay, FALSE);
      SendDlgItemMessage(hDlg, ITMLINSTR, EM_LIMITTEXT, DCS_XLINSTRSZ-1, 0L); /* rkhx 2.00 */
      SetDlgItemText(hDlg, ITMLINSTR, trmParams.xLinStr);

      CheckDlgButton(hDlg, ITMWORDWRAP, trmParams.xWordWrap);
      EnableWindow(GetDlgItem(hDlg, ITMWRAPCOL), trmParams.xWordWrap);
      SetDlgItemInt(hDlg, ITMWRAPCOL, trmParams.xWrapCol, FALSE);
      initDlgPos(hDlg);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         trmParams.xTxtType = whichGrpButton(hDlg, ITMSTD, ITMLIN);
#ifdef OLDCODE       /* rjs bugs 007 */
         trmParams.xChrDelay = GetDlgItemInt(hDlg, ITMCHRTIME, NULL, FALSE);
         trmParams.xLinDelay = GetDlgItemInt(hDlg, ITMLINTIME, NULL, FALSE);
         trmParams.xWrapCol  = GetDlgItemInt(hDlg, ITMWRAPCOL, NULL, FALSE);
#endif
         GetDlgItemText(hDlg, ITMLINSTR, trmParams.xLinStr, DCS_XLINSTRSZ-1); /* rkhx 2.00 */

 /* rjs bugs 007 */
         GetDlgItemText(hDlg, ITMCHRTIME, tempStr, DCS_XLINSTRSZ-1); /* rjs bugs 007 */
         temp = 0;
         while(tempStr[temp])
            if(isalpha(tempStr[temp++]))
            {
               MessageBeep(0);
               return(TRUE);
            }
         sscanf(tempStr, "%u", &temp);
         if(temp > 255)
         {
            MessageBeep(0);
            return(TRUE);
         }
         trmParams.xChrDelay = temp;

         GetDlgItemText(hDlg, ITMLINTIME, tempStr, DCS_XLINSTRSZ-1); /* rjs bugs 007 */
         temp = 0;
         while(tempStr[temp])
            if(isalpha(tempStr[temp++]))
            {
               MessageBeep(0);
               return(TRUE);
            }
         sscanf(tempStr, "%u", &temp);
         if(temp > 255)
         {
            MessageBeep(0);
            return(TRUE);
         }
         trmParams.xLinDelay = temp;

         GetDlgItemText(hDlg, ITMWRAPCOL, tempStr, DCS_XLINSTRSZ-1); /* rjs bugs 007 */
         temp = 0;
         while(tempStr[temp])
            if(isalpha(tempStr[temp++]))
            {
               MessageBeep(0);
               return(TRUE);
            }
         sscanf(tempStr, "%u", &temp);
         if(temp > 255)
         {
            MessageBeep(0);
            return(TRUE);
         }

         trmParams.xWrapCol = temp;
         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         trmParams = *(((PSAVEPARAMS) taskState.string)->lpData);
         break;

      case ITMSTD:
      case ITMCHR:
      case ITMLIN:
            CheckRadioButton(hDlg, ITMSTD, ITMLIN, trmParams.xTxtType = GET_WM_COMMAND_ID(wParam, lParaqm));
            enableLinItems(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == ITMLIN);
            enableChrItems(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == ITMCHR);
            enableStdItems(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == ITMSTD);
            return(TRUE);

      case ITMCHRDELAY:
      case ITMCHRWAIT:
         if(trmParams.xTxtType == ITMCHR)
         {
            CheckRadioButton(hDlg, ITMCHRDELAY, ITMCHRWAIT, trmParams.xChrType = GET_WM_COMMAND_ID(wParam, lParam));
            enableChrItems(hDlg, TRUE);
         }
         return(TRUE);

      case ITMLINDELAY:
      case ITMLINWAIT:
         if(trmParams.xTxtType == ITMLIN)
         {
            CheckRadioButton(hDlg, ITMLINDELAY, ITMLINWAIT, trmParams.xLinType = GET_WM_COMMAND_ID(wParam, lParam));
            enableLinItems(hDlg, TRUE);
         }
         return(TRUE);

      case ITMWORDWRAP:
         CheckDlgButton(hDlg, ITMWORDWRAP, trmParams.xWordWrap = !trmParams.xWordWrap);
         EnableWindow(GetDlgItem(hDlg, ITMWRAPCOL), trmParams.xWordWrap);
         if(trmParams.xWordWrap)
         {
            SetFocus(GetDlgItem(hDlg, ITMWRAPCOL));
            SendDlgItemMessage(hDlg, ITMWRAPCOL, EM_SETSEL, GET_EM_SETSEL_MPS(0, MAKELONG(0, 0x7FFF)));
         }
         return(TRUE);

      default:
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   if(((PSAVEPARAMS) taskState.string)->hData != NULL)
   {
      GlobalUnlock(((PSAVEPARAMS) taskState.string)->hData);
      GlobalFree(((PSAVEPARAMS) taskState.string)->hData);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* dbBinX() - Dialogue box control for Binary File Transfers.                */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbBinX(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      chkGrpButton(hDlg, ITMKERMIT, ITMXMODEM, trmParams.xBinType);
      initDlgPos(hDlg);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
//	  trmParams.xBinType = whichGrpButton(hDlg, ITMDYNACOMM, ITMYTERM);
// change this to kermit,xmodem, to avoid controlid unknown error from user
// -sdj 02jun92
	  trmParams.xBinType = whichGrpButton(hDlg, ITMKERMIT, ITMXMODEM);
         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         break;

      default:
// change this to kermit,xmodem, to avoid control id unknown error from user
// -sdj 02jun92
//	  chkGrpButton(hDlg, ITMDYNACOMM, ITMYTERM, GET_WM_COMMAND_ID(wParam, lParam));
	  chkGrpButton(hDlg, ITMKERMIT, ITMXMODEM, GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}

/*---------------------------------------------------------------------------*/
/* dbComm() -                                                          [mbb] */
/*---------------------------------------------------------------------------*/

#ifdef ORGCODE
BYTE  comDevList[5];
#else
BYTE  comDevList[20];
#endif


VOID initComDevSelect(HWND hDlg,WORD  wListID,BOOL bInit)  /* mbbx 2.01.09 ... */
{
   BYTE  str1[8], str2[8], str3[16];
   INT   ndx;

   loadListData(hDlg, wListID, STR_COM_CONNECT);

   LoadString(hInst, STR_COM_CONNECT+2, str1, sizeof(str1));
   comDevList[0] = 0;
   for(ndx = 1; ndx <= MaxComPortNumberInMenu; ndx += 1)
   {
      //sprintf(str2, str1, ndx);
      //if(GetProfileString("ports", (LPSTR) str2, (LPSTR) NULL_STR, (LPSTR) str3, sizeof(str3)))

      if (TRUE)
      {
	 SendDlgItemMessage(hDlg, wListID, LB_INSERTSTRING, -1, (LPARAM) (arComNumAndName[ndx].PortName));
         comDevList[++comDevList[0]] = ndx;
      }
   }

#ifdef ORGCODE
#else

   comDevList[(comDevList[0])+1] = ndx;

   //MaxComPortNumberInMenu	 = ndx-1;

   SendDlgItemMessage(hDlg, wListID, LB_INSERTSTRING, -1, (LPARAM)"TELNET");

#endif



   if(bInit)
   {
      ndx = 0;
   }
   else
   {
      loadListData(hDlg, wListID, STR_COM_CONNECT+4);

      if(trmParams.comDevRef < ITMNETCOM)
      {
         for(ndx = comDevList[0]; ndx > 0; ndx -= 1)
            if(comDevList[ndx] == trmParams.comPortRef)
               break;
      }
      else
         ndx = trmParams.comDevRef + (comDevList[0] - 1);
   }

   SendDlgItemMessage(hDlg, wListID, LB_SETCURSEL, ndx, 0L);
}


BYTE getComDevSelect(HWND hDlg, WORD wListID, BYTE *newDevRef)  /* mbbx 2.01.09 ... */
{
   BYTE  comPortRef = 0;

   if((*newDevRef = SendDlgItemMessage(hDlg, wListID, LB_GETCURSEL, 0, 0L)) != (BYTE) -1)
   {
#ifdef ORGCODE
      if(*newDevRef <= comDevList[0])
#else
      if(*newDevRef <= (comDevList[0])+1)
#endif
      {
         if(*newDevRef > ITMNOCOM)
         {
            comPortRef = comDevList[*newDevRef];
            *newDevRef = ITMWINCOM;
         }
      }
      else
         *newDevRef -= (comDevList[0] - 1);
   }
   else
      *newDevRef = ITMNOCOM;

   return(comPortRef);
}


/*---------------------------------------------------------------------------*/

VOID NEAR enableGrpItems(HWND  hDlg, INT   itemFirst, INT   itemLast, INT   itemSelect)
{
   INT   itemNext;

   CheckRadioButton(hDlg, itemFirst, itemLast, itemSelect);
   for(itemNext = itemFirst; itemNext <= itemLast; itemNext += 1)
      EnableWindow(GetDlgItem(hDlg, itemNext), itemSelect);
}


VOID NEAR enableCommItems(HWND  hDlg, BYTE  comDevRef)
{
   WORD  wBaudID;

   switch(trmParams.speed)
   {
   case 110:
      wBaudID = ITMBD110;
      break;
   case 300:
      wBaudID = ITMBD300;
      break;
   case 600:
      wBaudID = ITMBD600;
      break;
   case 2400:
      wBaudID = ITMBD240;
      break;
   case 4800:
      wBaudID = ITMBD480;
      break;
   case 9600:
      wBaudID = ITMBD960;
      break;
   case 14400:
      wBaudID = ITMBD144;
      break;
   case 19200:
      wBaudID = ITMBD192;
      break;

   case 38400:
      wBaudID = ITMBD384;
      break;
   case 57600:
      wBaudID = ITMBD576;
      break;
   case 57601:
      wBaudID = ITMBD1152;
      break;
   //case 57602:
   //	wBaudID = ITMBD1280;
   //	break;


   default:
      wBaudID = ITMBD120;
      trmParams.speed = 1200;
      break;
   }

   switch(comDevRef)
   {
   case ITMWINCOM:
      enableGrpItems(hDlg, ITMBD110, ITMBD1152, wBaudID);
      enableGrpItems(hDlg, ITMDATA5, ITMDATA8, trmParams.dataBits); /* jtf 3.24 */
      enableGrpItems(hDlg, ITMSTOP1, ITMSTOP2, trmParams.stopBits);
      enableGrpItems(hDlg, ITMNOPARITY, ITMSPACEPARITY, trmParams.parity);
      enableGrpItems(hDlg, ITMXONFLOW, ITMNOFLOW, trmParams.flowControl);
      if(trmParams.dataBits == ITMDATA5) /* jtf 3.24 */
        {
        EnableWindow(GetDlgItem(hDlg, ITMDATA6), FALSE);
        EnableWindow(GetDlgItem(hDlg, ITMDATA7), FALSE);
        EnableWindow(GetDlgItem(hDlg, ITMDATA8), FALSE);
        }
      else
        EnableWindow(GetDlgItem(hDlg, ITMDATA5), FALSE);

      break;

   default:
      enableGrpItems(hDlg, ITMBD110, ITMBD1152, 0);
      enableGrpItems(hDlg, ITMDATA5, ITMDATA8, 0);  /* jtf 3.24 */
      enableGrpItems(hDlg, ITMSTOP1, ITMSTOP2, 0);
      enableGrpItems(hDlg, ITMNOPARITY, ITMSPACEPARITY, 0);
      enableGrpItems(hDlg, ITMXONFLOW, ITMNOFLOW, 0);
      break;
   }

   CheckDlgButton(hDlg, ITMPARITY, (comDevRef == ITMWINCOM) ? trmParams.fParity : FALSE);
   EnableWindow(GetDlgItem(hDlg, ITMPARITY), (comDevRef == ITMWINCOM) ? TRUE : FALSE);
   CheckDlgButton(hDlg, ITMCARRIER, (comDevRef == ITMWINCOM) ? trmParams.fCarrier : FALSE);
   EnableWindow(GetDlgItem(hDlg, ITMCARRIER), (comDevRef == ITMWINCOM) ? TRUE : FALSE);
}


INT_PTR APIENTRY dbComm(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   WORD  wCurSel;                            /* seh nova 005 */
   LPCONNECTOR_CONTROL_BLOCK  lpWorkCCB;     /* slc nova 047 */
   WORD  lastItem;                           /* slc nova 117 */
   WORD  lastPort;			     /* slc nova 117 */
   BOOL  prevcarrier;

   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      if((((PSAVEPARAMS) taskState.string)->hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) == NULL)
         break;
      ((PSAVEPARAMS) taskState.string)->lpData = (recTrmParams FAR *) GlobalLock(((PSAVEPARAMS) taskState.string)->hData);
      *(((PSAVEPARAMS) taskState.string)->lpData) = trmParams;

      trmParams.newDevRef = -1;              /* mbbx 2.00: network... */
      enableCommItems(hDlg, trmParams.comDevRef);

      initComDevSelect(hDlg, ITMCONNECTOR, FALSE);    /* mbbx 2.01.09 ... */

/* rjs bug2 - add tcp/ip connector for microsoft */
      EnableWindow(GetDlgItem(hDlg, ITMSETUP), FALSE);   /* slc nova 031, seh nova 005 */
      ShowWindow(GetDlgItem(hDlg, ITMSETUP), SW_HIDE);   /* seh nova 005 */
      addConnectorList(hDlg, ITMCONNECTOR);  /* slc nova 012 bjw gold 027 */
      ghWorkConnector = NULL;                /* slc nova 031 */
      if(trmParams.comDevRef == ITMDLLCONNECT)
      {
         SendDlgItemMessage(hDlg, ITMCONNECTOR, LB_SETCURSEL, trmParams.comExtRef - 1, 0L);
         ghWorkConnector = ghCCB;            /* slc nova 031 */
      }
/* end of rjs bug2 */
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:


         if(!trmParams.fResetDevice)
         {
            if(trmParams.newDevRef != (BYTE) -1)   /* mbbx 2.00.04: force reload... */
               trmParams.fResetDevice = TRUE;
         }

         if(trmParams.newDevRef == ITMDLLCONNECT)  /* slc nova 031 */
         {
            if((ghWorkConnector != NULL) &&
               (ghWorkConnector != ghCCB))
            {
               GlobalFree(ghCCB);
               ghCCB = ghWorkConnector;
               ghWorkConnector = NULL;
            }
         }

         resetSerial(&trmParams, (trmParams.newDevRef != (BYTE) -1), FALSE, 0);  /* slc swat */

         if(sPort == (HANDLE)-1)
	    break;	 //return(TRUE);

         if((trmParams.newDevRef != (BYTE) -1) && (trmParams.comDevRef != trmParams.newDevRef))
            return(TRUE);

         termData.flags |= TF_CHANGED;
         break;

      case IDCANCEL:
         trmParams = *(((PSAVEPARAMS) taskState.string)->lpData);
         break;

/* rjs bug2 - begin */
      case ITMSETUP:
         if(ghWorkConnector != NULL)
            DLL_SetupConnector(ghWorkConnector, TRUE);
         SetFocus(GetDlgItem(hDlg, IDOK));
         return(TRUE);
/* rjs bug2 - end */

      case ITMBD110:
      case ITMBD300:
      case ITMBD600:                         /* mbbx 2.00: support 600 baud... */
      case ITMBD120:
      case ITMBD240:
      case ITMBD480:
      case ITMBD960:
      case ITMBD144:
      case ITMBD192:
      case ITMBD384:
      case ITMBD576:
      case ITMBD1152:
         switch(GET_WM_COMMAND_ID(wParam, lParam))
         {
         case ITMBD110:
            trmParams.speed = 110;
            break;
         case ITMBD300:
            trmParams.speed = 300;
            break;
         case ITMBD600:
            trmParams.speed = 600;
            break;
         case ITMBD120:
            trmParams.speed = 1200;
            break;
         case ITMBD240:
            trmParams.speed = 2400;
            break;
         case ITMBD480:
            trmParams.speed = 4800;
            break;
         case ITMBD960:
	    trmParams.speed = 9600;
	    break;
	 case ITMBD144:
	    trmParams.speed = 14400;
            break;
         case ITMBD192:
	    trmParams.speed = 19200;
	    break;
	 case ITMBD384:
	    trmParams.speed = 38400;
	    break;
	 case ITMBD576:
	    trmParams.speed = 57600;
	    break;
	 case ITMBD1152:
	    trmParams.speed = 57601;
	    break;
	 //case ITMBD1280:
	 //   trmParams.speed = 57602;
	 //   break;


         }

	 CheckRadioButton(hDlg, ITMBD110, ITMBD1152, GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);

      case ITMDATA8:                         /* mbbx 2.00 ... */
         if(trmParams.parity != ITMNOPARITY)
            CheckRadioButton(hDlg, ITMNOPARITY, ITMSPACEPARITY, trmParams.parity = ITMNOPARITY);
                                             /* then fall thru... */
      case ITMDATA5:
      case ITMDATA6:
      case ITMDATA7:
         CheckRadioButton(hDlg, ITMDATA5, ITMDATA8, trmParams.dataBits = GET_WM_COMMAND_ID(wParam, lParam)); /* jtf 3.24 */
         return(TRUE);

      case ITMSTOP5:                      /* jtf 3.24 */
         CheckRadioButton(hDlg, ITMSTOP1, ITMSTOP2, trmParams.stopBits = GET_WM_COMMAND_ID(wParam, lParam));
         CheckRadioButton(hDlg, ITMDATA5, ITMDATA8, trmParams.dataBits = ITMDATA5); /* jtf 3.24 */
         EnableWindow(GetDlgItem(hDlg, ITMDATA5), TRUE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA6), FALSE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA7), FALSE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA8), FALSE);
         return(TRUE);
        
      case ITMSTOP1:
      case ITMSTOP2:
         EnableWindow(GetDlgItem(hDlg, ITMDATA5), FALSE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA6), TRUE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA7), TRUE);
         EnableWindow(GetDlgItem(hDlg, ITMDATA8), TRUE);
         if (trmParams.dataBits = ITMDATA5)
            CheckRadioButton(hDlg, ITMDATA5, ITMDATA8, trmParams.dataBits = ITMDATA8); /* jtf 3.24 */
         CheckRadioButton(hDlg, ITMSTOP1, ITMSTOP2, trmParams.stopBits = GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);

      case ITMODDPARITY:                     /* mbbx 2.00 ... */
      case ITMEVENPARITY:
      case ITMMARKPARITY:
      case ITMSPACEPARITY:
         if(trmParams.dataBits == ITMDATA8)
            CheckRadioButton(hDlg, ITMDATA5, ITMDATA8, trmParams.dataBits = ITMDATA7); /* jtf 3.24 */
                                             /* then fall thru... */
      case ITMNOPARITY:
         CheckRadioButton(hDlg, ITMNOPARITY, ITMSPACEPARITY, trmParams.parity = GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);

      case ITMXONFLOW:
      case ITMHARDFLOW:
      case ITMNOFLOW:
         CheckRadioButton(hDlg, ITMXONFLOW, ITMNOFLOW, trmParams.flowControl = GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);

      case ITMCONNECTOR:
         switch(GET_WM_COMMAND_CMD(wParam, lParam))              /* mbbx 2.00: network... */
         {
	 case LBN_SELCHANGE:		     /* mbbx 2.01.09 ... */
            lastItem = trmParams.newDevRef;  /* slc nova 117 */
            lastPort = trmParams.comPortRef; /* slc nova 117 */
            trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, &trmParams.newDevRef);

            if(trmParams.comPortRef > ITMCOM4)
            {
               wCurSel = (WORD) SendDlgItemMessage(hDlg, ITMCONNECTOR, LB_GETCURSEL, 0, 0L);  /* seh nova 005 */
               SendDlgItemMessage(hDlg, ITMCONNECTOR, LB_GETTEXT, wCurSel,
                                 (LPARAM) gszWork); /* bjw gold 027, seh nova 005 */

               if((ghWorkConnector == NULL) ||   /* slc nova 031 */
                  (ghWorkConnector == ghCCB))
               {
                  ghWorkConnector = GlobalAlloc(GHND | GMEM_ZEROINIT, (DWORD)sizeof(CONNECTOR_CONTROL_BLOCK));
               }

               EnableWindow(GetDlgItem(hDlg, ITMSETUP), FALSE);   /* slc nova 031 */
               ShowWindow(GetDlgItem(hDlg, ITMSETUP), SW_HIDE);
               if(loadConnector(hDlg, ghWorkConnector, gszWork, FALSE)) /* slc nova 031 */
               {
                  trmParams.comExtRef = (BYTE)(wCurSel + 1);
                  trmParams.newDevRef = ITMDLLCONNECT;
                  lstrcpy(trmParams.szConnectorName, gszWork);

                  if(DLL_HasSetupBox(ghWorkConnector))   /* slc nova 031 */
                  {
                     EnableWindow(GetDlgItem(hDlg, ITMSETUP), TRUE);
                     ShowWindow(GetDlgItem(hDlg, ITMSETUP), SW_SHOW);
                  }
               }
            }

            enableCommItems(hDlg, trmParams.newDevRef);
	    trmParams.fResetDevice = FALSE;
            break;
	 }
	 return(TRUE);



      case ITMPARITY:
         CheckDlgButton(hDlg, ITMPARITY, trmParams.fParity = !trmParams.fParity);
         return(TRUE);

      case ITMCARRIER:
	 prevcarrier = trmParams.fCarrier;
	 CheckDlgButton(hDlg, ITMCARRIER, trmParams.fCarrier = !trmParams.fCarrier);
	 //-sdj if fcarrier is disabled by the user, reset the mdmOnLine flag
	 //-sdj so that, the Dial menu item gets enabled. bug# 735
	 if (prevcarrier && !(trmParams.fCarrier) ) mdmOnLine = FALSE;
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   if(((PSAVEPARAMS) taskState.string)->hData != NULL)
   {
      GlobalUnlock(((PSAVEPARAMS) taskState.string)->hData);
      GlobalFree(((PSAVEPARAMS) taskState.string)->hData);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}

/*---------------------------------------------------------------------------*/
/* dbModem() -                                                         [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR loadModemData(HWND  hDlg, WORD  wMdmType)
{
   WORD  nResID;
   INT   ndx;
   BYTE  work[STR255];

   switch(wMdmType)
   {
   case ITMHAYES:
      nResID = STR_MDM_HAYES;
      break;
   case ITMMULTITECH:
      nResID = STR_MDM_MNP;
      break;
   case ITMTRAILBLAZER:
      nResID = STR_MDM_TELEBIT;
      break;
   default:                                  /* ITMNOMODEM */
      nResID = STR_MDM_NONE;
      break;
   }

   for(ndx = 0; ndx < 10; ndx ++)      /* rjs swat - changed to 10 from 11 */
   {
      LoadString(hInst, nResID + ndx, work, STR255-1);
      SetDlgItemText(hDlg, ITMDIAL + ndx, work);
   }

   ndx++;

   LoadString(hInst, nResID + ndx, work, STR255-1);
   SetDlgItemText(hDlg, ITMDIAL + ndx, work);
}


INT_PTR APIENTRY dbModem(HWND  hDlg, UINT  message, WPARAM wParam, LPARAM lParam)
{
   updateTimer();

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);

      if((((PSAVEPARAMS) taskState.string)->hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) == NULL)
         break;
      ((PSAVEPARAMS) taskState.string)->lpData = (recTrmParams FAR *) GlobalLock(((PSAVEPARAMS) taskState.string)->hData);
      *(((PSAVEPARAMS) taskState.string)->lpData) = trmParams;

      SetDlgItemText(hDlg, ITMDIAL, trmParams.dialPrefix);
      SetDlgItemText(hDlg, ITMDIAL+1, trmParams.dialSuffix);
      SetDlgItemText(hDlg, ITMHANGUP, trmParams.hangPrefix);
      SetDlgItemText(hDlg, ITMHANGUP+1, trmParams.hangSuffix);
      SetDlgItemText(hDlg, ITMBINTX, trmParams.binTXPrefix);
      SetDlgItemText(hDlg, ITMBINTX+1, trmParams.binTXSuffix);
      SetDlgItemText(hDlg, ITMBINRX, trmParams.binRXPrefix);
      SetDlgItemText(hDlg, ITMBINRX+1, trmParams.binRXSuffix);
      SetDlgItemText(hDlg, ITMFASTQRY, trmParams.fastInq);
      SetDlgItemText(hDlg, ITMFASTQRY+1, trmParams.fastRsp);
      SetDlgItemText(hDlg, ITMANSWER, trmParams.answer);
      SetDlgItemText(hDlg, ITMORIGIN, trmParams.originate);

      CheckRadioButton(hDlg, ITMMODEMFIRST, ITMMODEMLAST, trmParams.xMdmType);

      ((PSAVEPARAMS) taskState.string)->saveLevel = -1;
      
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         GetDlgItemText(hDlg, ITMDIAL, trmParams.dialPrefix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMDIAL+1, trmParams.dialSuffix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMHANGUP, trmParams.hangPrefix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMHANGUP+1, trmParams.hangSuffix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMBINTX, trmParams.binTXPrefix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMBINTX+1, trmParams.binTXSuffix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMBINRX, trmParams.binRXPrefix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMBINRX+1, trmParams.binRXSuffix, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMFASTQRY, trmParams.fastInq, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMFASTQRY+1, trmParams.fastRsp, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMANSWER, trmParams.answer, DCS_MODEMCMDSZ-1);
         GetDlgItemText(hDlg, ITMORIGIN, trmParams.originate, DCS_MODEMCMDSZ-1);

         trmParams.xMdmType = whichGrpButton(hDlg, ITMMODEMFIRST, ITMMODEMLAST);

         termData.flags |= TF_CHANGED;

         break;

      case IDCANCEL:
         trmParams = *(((PSAVEPARAMS) taskState.string)->lpData);
         break;

      case ITMHAYES:
      case ITMMULTITECH:
      case ITMTRAILBLAZER:
      case ITMNOMODEM:
         CheckRadioButton(hDlg, ITMMODEMFIRST, ITMMODEMLAST, GET_WM_COMMAND_ID(wParam, lParam));
         loadModemData(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
         return(TRUE);

      default:
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   EndDialog(hDlg, TRUE);
   return(TRUE);
}




/*---------------------------------------------------------------------------*/
/* chkGrpButton() -  Toggle on radio buttons.                                */
/*---------------------------------------------------------------------------*/

VOID chkGrpButton(HWND hDlg, INT iFirst, INT iLast, INT item)
{
   if((item >= iFirst) && (item <= iLast))   /* mbbx 1.04 ... */
      CheckRadioButton(hDlg, iFirst, iLast, item);
}


/*---------------------------------------------------------------------------*/
/* whichGrpButton() - Return which button in a group was pressed.            */
/*---------------------------------------------------------------------------*/

BYTE whichGrpButton(HWND  hDlg, INT   iFirst, INT iLast)
{
   INT   which;

   for(which = iFirst; which <= iLast; which += 1)
      if(IsDlgButtonChecked(hDlg, which))
         return((BYTE) which);

   return((BYTE) iFirst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\serial.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31
#define  USECOMM

#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "connect.h"

/*---------------------------------------------------------------------------*/
/* exitSerial() -                                                  [mbb/rkh] */
/*---------------------------------------------------------------------------*/

VOID NEAR WIN_exitSerial()                   /* mbbx 2.00: network... */
{
   DCB   dcb;

   if(GetCommState(sPort, (DCB FAR *) &dcb) == 0)  /* mbbx 1.04: RTS/DTR disable... */
   {
      dcb.fRtsControl = RTS_CONTROL_DISABLE;
      dcb.fDtrControl = DTR_CONTROL_DISABLE;
      EscapeCommFunction(sPort,CLRRTS);
      EscapeCommFunction(sPort,CLRDTR);

      DEBOUT("SetCommState from Win_exitSerial for comport=%lx\n",sPort);
      if(!SetCommState(sPort,(DCB FAR *) &dcb))
      {
         DEBOUT("FAIL: SetCommState from Win_exitSerial for comport=%lx\n",sPort);
      }
   }


#ifdef ORGCODE
   FlushComm(sPort, 1);
   FlushComm(sPort, 0);
#else
   DEBOUT("FlushFileBuffers from Win_exitSerial: comport %lx\n",sPort);
#ifndef BUGBYPASS
   DEBOUT("FlushFileBuffers from Win_exitSerial: BYPASSING FLUSH DUE TO BUG %lx\n",sPort);
#else
   if (!FlushFileBuffers(sPort))
    {
    DEBOUT("FAIL: FlushFileBuffers comport %lx\n",sPort);
    }
#endif

   DEBOUT("PurgeComm from Win_exitSerial:comport %lx\n",sPort);
   if (!PurgeComm(sPort,0))
    {
    DEBOUT("FAIL: PurgeComm comport %lx\n",sPort);
    }
#endif

   SetCommMask(sPort, EV_RXCHAR);
   //WaitForSingleObject(hMutex, 500);
   bPortIsGood = FALSE;



    /**********
    {
    // Make suer sPort gets closed, bug#9671
    // Actually a bug in serial driver, The fix is a
    // quick hack, should be removed once the driver
    // is fixed.

    int cnt=20;

    while (cnt-- && CloseHandle(sPort)) Sleep (200);
    }
    **********/

    //
    //  We can't close the handle twice now.
    //  So, just close it and wait a little.
    //

    Sleep (200);
    CloseHandle (sPort);
    Sleep (200);



   sPort = NULL;
   //ReleaseMutex(hMutex);
}


VOID exitSerial()                            /* mbbx 2.00: network... */
{
   switch(trmParams.comDevRef)
   {
   case ITMWINCOM:
      WIN_exitSerial();
      break;

   case ITMDLLCONNECT:                       /* slc nova 012 bjw nova 02 */
      DLL_ExitConnector(ghCCB, &trmParams);  /* slc nova 031 */
      break;
   }

   trmParams.comDevRef = ITMNOCOM;
}


/*---------------------------------------------------------------------------*/
/* resetSerial() -                                                 [mbb/rkh] */
/*---------------------------------------------------------------------------*/

VOID NEAR WIN_resetSerial(recTrmParams *trmParams, BOOL bLoad, NEARPROC errProc)
{
   INT            attempts;
   // sdj: this is replaced by global szCurrentPortName ;BYTE	   tmp1[TMPNSTR+1];
   BYTE 	  tmp1[TMPNSTR+1],tmp2[TMPNSTR+1];
   DCB		  dcb;
   DCB		  PrevDcb;
   COMMTIMEOUTS   CommTimeOuts;
   BOOL 	  bRc;
   DWORD	  dwError;
   COMMPROP	  CommProp;  // -sdj sep92 on low mem rx buffer can be < 1024

   modemReset();                             /* mbbx 0.72: avoid hang if XOFF-ed */

   if(bLoad)
   {
      for(attempts = 0; trmParams->comDevRef == ITMNOCOM; attempts += 1)
      {
	 if(trmParams->comPortRef > MaxComPortNumberInMenu)

	    strcpy(szCurrentPortName, "\\\\.\\TELNET");

	 else

         {
	   // LoadString(hInst, STR_COM, (LPSTR) tmp2, MINRESSTR);
	   //	 sprintf(szCurrentPortName, tmp2, trmParams->comPortRef);
	   strcpy(szCurrentPortName,arComNumAndName[trmParams->comPortRef].PortName);
         }


	 if( (sPort != NULL) && (sPort != (HANDLE)-1) )
	   {
	    SetCommMask(sPort, 0);   // so that waitcommevent comes out; -sdj
	    sPort = NULL;
	   }

	 sPort = CreateFile(szCurrentPortName, GENERIC_READ|GENERIC_WRITE, 0, NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

         if (sPort == (HANDLE)-1)
	 {
	    dwError	= GetLastError();
	    bPortIsGood = FALSE;
            if(!(*errProc)(trmParams, attempts))
               return;
         }
         else
	    {
	        SetCommMask(sPort, EV_RXCHAR); // -sdj 27apr92  telnet deadlock
	        dwWriteFileTimeout = 5000;	   // -sdj 28apr92  telnet debug

            trmParams->comDevRef                     = ITMWINCOM;
            CommTimeOuts.ReadIntervalTimeout         = 0xFFFFFFFF;
            CommTimeOuts.ReadTotalTimeoutMultiplier  = 0;
            CommTimeOuts.ReadTotalTimeoutConstant    = 0;
            CommTimeOuts.WriteTotalTimeoutMultiplier = 0;

            if (trmParams->flowControl == ITMHARDFLOW)
            {
               CommTimeOuts.WriteTotalTimeoutConstant   = 5000;   // 5msecs
            }
            else
            {
               CommTimeOuts.WriteTotalTimeoutConstant   = 10000;  //10secs
            }

            if (!(bRc = SetCommTimeouts(sPort,&CommTimeOuts) ) )
            {
               if(!(*errProc)(trmParams, attempts))
                  return;
	        }

	        //  There may be data already waiting to be read - i.e. data
	        //	that arrived before we set comm mask.  This data will not
	        //	be uncovered by wait mask, so we must try to read it.
	    
	        gotCommEvent = TRUE;

         }
      } // endof for
   }    // endof if bload

   /* This would work on both win30 and win32 -sdj*/
/*   if(GetCommState(sPort, (DCB FAR *) &dcb) == 0) -sdj*/

DEBOUT("HACK : %s\n","rc of GetCommState: not checked for now");
   {
      GetCommState(sPort, (DCB FAR *) &dcb);
      GetCommState(sPort, (DCB FAR *) &PrevDcb);

      // -sdj sep92 on low mem rx buffer can be < 1024
      // -sdj set rx buffer to nice 4096 bytes size
      // -sdj driver will do its best and set the Rx buffer to this size
      // -sdj if it fails then dwCurrentRxQueue will be the one we have
      // -sdj so do getcommprop again to fetch this value, which can
      // -sdj be used to set xoff and xon lims

      GetCommProperties(sPort,&CommProp);

      SetupComm(sPort,4096,4096);

      CommProp.dwCurrentRxQueue = 0; // -sdj dirty it so that we
				     // -sdj can use this only if !=0
      GetCommProperties(sPort,&CommProp);

      // sdj: added this code to take care of extra baud rates support

      if (trmParams->speed <= 57600)
	{
	 dcb.BaudRate = trmParams->speed;	/* mbbx 2.00: allow any baud... */
	}
      else
	{
	if (trmParams->speed == 57601)
	    {
	    // sdj: this means 115.2K baud rate which cannot fit into BYTE!
	    dcb.BaudRate = 115200;
	    }
	else{
	     if (trmParams->speed == 57602)
		{
		dcb.BaudRate = 128000;
		}
	     else
		{
		// sdj: something wrong! default to 1200
		dcb.BaudRate = 1200;
		}
	    }
	}

      dcb.ByteSize = 8 + (trmParams->dataBits - ITMDATA8);
      dcb.Parity = NOPARITY + (trmParams->parity - ITMNOPARITY);
      dcb.StopBits = ONESTOPBIT + (trmParams->stopBits - ITMSTOP1);

//      dcb.RlsTimeout   = 0;
//      dcb.CtsTimeout   = (trmParams->flowControl == ITMHARDFLOW) ? 5 : 0;  /* mbbx 1.10: CUA */
//      dcb.DsrTimeout   = 0;

      dcb.fBinary      = TRUE;
      dcb.fRtsControl  = RTS_CONTROL_ENABLE;
      dcb.fParity      = trmParams->fParity;    /* mbbx 1.10: CUA */
      dcb.fOutxCtsFlow = (trmParams->flowControl == ITMHARDFLOW);    /* mbbx 1.10: CUA... */
      dcb.fOutxDsrFlow = FALSE;
      dcb.fDtrControl  = DTR_CONTROL_ENABLE;

      dcb.fOutX        =
      dcb.fInX         = (trmParams->flowControl == ITMXONFLOW);
      dcb.fErrorChar   = trmParams->fParity;    /* mbbx 1.10: CUA */
      dcb.fNull        = FALSE;
//      dcb.fChEvt       = FALSE;
//      dcb.fDtrFlow     = FALSE;

if (trmParams->flowControl == ITMHARDFLOW)
    {
      dcb.fRtsControl     = RTS_CONTROL_HANDSHAKE;    /* mbbx 1.10: CUA... */
    }

      dcb.XonChar      = XON;
      dcb.XoffChar     = XOFF;

      /* -sdj sep92, this is 1k/4=256, 9M system can have RXQ=256
	 -sdj in that case SetCommState can fail due to invalid
	 -sdj parameters of xoff xon limits
      dcb.XonLim       = NINQUEUE / 4;
      dcb.XoffLim      = NINQUEUE / 4;
      */

      // -sdj if for some wierd reason dwCurrentRxQueue is not
      // -sdj filled in by the driver, then let xon xoff lims
      // -sdj be the default which the driver has.
      // -sdj (dwCurrentRxQueue was set to 0 before calling Get again)

      if (CommProp.dwCurrentRxQueue != 0)
	 {
	  dcb.XonLim	= (WORD)(CommProp.dwCurrentRxQueue / 4);
	  dcb.XoffLim	= (WORD)(CommProp.dwCurrentRxQueue / 4);
	 }

      dcb.ErrorChar    = '?';
      dcb.EofChar      = CNTRLZ;
      dcb.EvtChar      = 0;
      dcb.wReserved    = 0;

#ifdef ORGCODE
      if(SetCommState((DCB FAR *) &dcb) == 0)
      {
#else
      if(SetCommState(sPort, (DCB FAR *) &dcb) == 0)
      {

DEBOUT("FAIL: SetCommState for comport=%lx\n",sPort);
#endif
         mdmOnLine = FALSE;                  /* mbbx 1.10: carrier... */
	 mdmConnect();
	 LoadString(hInst, STR_SETCOMFAIL, (LPSTR) tmp1, TMPNSTR);
	 LoadString(hInst, STR_ERRCAPTION, (LPSTR) tmp2, TMPNSTR);
	 MessageBox(hItWnd, (LPSTR) tmp1, (LPSTR)tmp2, MB_OK | MB_APPLMODAL);
	 SetCommState(sPort,&PrevDcb);
         return;
      }

#ifdef ORGCODE
#else
    /*DWORD ReadIntervalTimeout;           Maximum time between read chars. */
    /*DWORD ReadTotalTimeoutMultiplier;    Multiplier of characters.        */
    /*DWORD ReadTotalTimeoutConstant;      Constant in milliseconds.        */
    /*DWORD WriteTotalTimeoutMultiplier;   Multiplier of characters.        */
    /*DWORD WriteTotalTimeoutConstant;     Constant in milliseconds.        */

               DEBOUT("Win_resetSerial: %s\n","Setting Comm timeouts");
               CommTimeOuts.ReadIntervalTimeout          = 0xFFFFFFFF;
               CommTimeOuts.ReadTotalTimeoutMultiplier   = 0;
               CommTimeOuts.ReadTotalTimeoutConstant     = 0;
               CommTimeOuts.WriteTotalTimeoutMultiplier  = 0;

               if (trmParams->flowControl == ITMHARDFLOW)
               {
                  CommTimeOuts.WriteTotalTimeoutConstant   = 5000;  //5 msecs
               }
               else
               {
                  CommTimeOuts.WriteTotalTimeoutConstant   = 10000; //10secs
               }

               if (!(bRc = SetCommTimeouts(sPort,&CommTimeOuts) ) )
               {
                  DEBOUT("FAIL: SetCommTimeouts failed rc: %lx\n",bRc);
                  mdmOnLine = FALSE;                  /* mbbx 1.10: carrier... */
                  mdmConnect();
                  return;
               }
#endif
   }

bPortIsGood = TRUE;	   /* now the port is properly initialized -sdj 05/21/92*/
			  //-sdj for telnet-quit processing
bPortDisconnected = FALSE; /* there is no problem of port_was_opened_but_not_working */

}


VOID resetSerial(recTrmParams *trmParams, BOOL bLoad,BOOL  bInit,BYTE byFlowFlag) /* slc swat */
{
   /* LPCONNECTOR_CONTROL_BLOCK	lpCCB; -sdj no unref variables please ; slc nova 031 */

   if(bLoad)
   {
      if(!trmParams->fResetDevice)
         trmParams->newDevRef = trmParams->comDevRef;

      exitSerial();
   }

   switch(bLoad ? trmParams->newDevRef : trmParams->comDevRef)
   {

   case ITMNOCOM:

    break;


   default:      // case ITMWINCOM:
      WIN_resetSerial(trmParams, bLoad, bInit ? (NEARPROC)resetSerialError0 : (NEARPROC)resetSerialError1 /*, byFlowFlag*/); /* slc swat */
      break;

#ifdef OLDCODE

   case ITMWINCOM:
      WIN_resetSerial(trmParams, bLoad, bInit ? (NEARPROC)resetSerialError0 : (NEARPROC)resetSerialError1 /*, byFlowFlag*/); /* slc swat */
      break;

   case ITMDLLCONNECT:                       /* slc nova 012 bjw nova 002 */
      if((lpCCB = (LPCONNECTOR_CONTROL_BLOCK)GlobalLock(ghCCB)) != NULL)   /* slc nova 031 */
      {
         if(lpCCB->hConnectorInst == NULL)   /* first time? */
            if(!loadConnector(NULL, ghCCB, (LPSTR)trmParams->szConnectorName, FALSE))
               return;
         GlobalUnlock(ghCCB);

         trmParams->comDevRef = ITMDLLCONNECT;
         DLL_SetupConnector(ghCCB, FALSE);   /* slc nova 031 */
      }
      break;

#endif

   }

   trmParams->fResetDevice = FALSE;
}


/*---------------------------------------------------------------------------*/
/* resetSerialError0 - called during initialization;                   [mbb] */
/*                     auto attempt other COM port, then fail                */
/*---------------------------------------------------------------------------*/

BOOL PASCAL NEAR resetSerialError0(recTrmParams *trmParams, WORD count)
{
   BYTE  tmp1[TMPNSTR+1];
   BYTE  tmp2[TMPNSTR+1];

   //sdj: if this is a telnet port then advice the user to go to
   //sdj: the control panel and see if telnet service is started
   //sdj: else stick with the original msg of selected com port not
   //sdj: available, select other port.

   if (!strcmp(szCurrentPortName,"\\\\.\\TELNET"))
    {
     LoadString(hInst, STR_TELNETFAIL, (LPSTR) tmp1, TMPNSTR);
    }
   else
    {
     LoadString(hInst, STR_OTHERCOM, (LPSTR) tmp1, TMPNSTR);
    }
   LoadString(hInst, STR_ERRCAPTION, (LPSTR) tmp2, TMPNSTR);

   MessageBox(hItWnd, (LPSTR) tmp1, (LPSTR)tmp2, MB_OK | MB_APPLMODAL);
   doSettings(IDDBCOMM, dbComm);

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* resetSerialError1 - default case (e.g., after loading settings)     [mbb] */
/*                     prompt to attempt other COM port, then fail           */
/*---------------------------------------------------------------------------*/

BOOL PASCAL NEAR resetSerialError1(recTrmParams *trmParams, WORD count)
{
   BYTE  tmp1[TMPNSTR+1];
   BYTE  tmp2[TMPNSTR+1];

   if(count > 0)
   {
      LoadString(hInst, STR_NOCOMMPORTS, (LPSTR) tmp1, TMPNSTR);    /* mbbx 1.00 */
      testMsg(tmp1,NULL,NULL);
   }
   else
   {
   //sdj: if this is a telnet port then advice the user to go to
   //sdj: the control panel and see if telnet service is started
   //sdj: else stick with the original msg of selected com port not
   //sdj: available, select other port.

   if (!strcmp(szCurrentPortName,"\\\\.\\TELNET"))
    {
     LoadString(hInst, STR_TELNETFAIL, (LPSTR) tmp1, TMPNSTR);
    }
   else
    {
      LoadString(hInst, STR_OTHERCOM, (LPSTR) tmp1, TMPNSTR);
    }
      LoadString(hInst, STR_ERRCAPTION, (LPSTR) tmp2, TMPNSTR);
      MessageBox(hItWnd, (LPSTR) tmp1, (LPSTR)tmp2, MB_OK | MB_APPLMODAL);

      trmParams->comPortRef = ITMNOCOM;       /* mbbx 1.10: CUA */
   }
   return(FALSE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\showstat.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "video.h"


/*---------------------------------------------------------------------------*/
/* showXferCtrls() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID setXferCtrlButton(WORD wCtrlID, WORD wResID)      /* mbbx 2.00: xfer ctrls... */
//WORD  wCtrlID;
//WORD  wResID;
{
   BYTE  work[MINRESSTR];

   LoadString(hInst, wResID, (LPSTR) work, MINRESSTR);
   SetWindowText(GetDlgItem(hdbXferCtrls, wCtrlID), (LPSTR) work);
}


INT NEAR placeXferCtrl(HWND  hCtrl, INT   fCtrlLeft)
{
   RECT  fCtrlRect;

   GetWindowRect(hCtrl, (LPRECT) &fCtrlRect);
   fCtrlRect.right -= fCtrlRect.left;
   MoveWindow(hCtrl, fCtrlLeft, 0, fCtrlRect.right, fCtrlRect.bottom - fCtrlRect.top, FALSE);

   return(fCtrlLeft + fCtrlRect.right);
}


VOID showXferCtrls(WORD fShowCtrls)               /* mbbx 2.00: xfer ctrls... */
//WORD  fShowCtrls;
{
   INT	 fCtrlLeft;

      //sdj: the status line does not get updates when you come back
      //sdj: to terminal focus.

      if (hdbmyControls != NULL)
	{
	 if(IsWindowVisible(hdbmyControls))
	    {
            InvalidateRect(hdbmyControls, NULL, FALSE);
            UpdateWindow(hdbmyControls);
            }
	}


   if(fShowCtrls)
   {
      fCtrlLeft = placeXferCtrl(xferCtlStop, 0);

      if(fShowCtrls & IDPAUSE)
      {
         fCtrlLeft = placeXferCtrl(xferCtlPause, fCtrlLeft);
      }

      if(fShowCtrls & IDFORK)
      {
         fCtrlLeft = placeXferCtrl(GetDlgItem(hdbXferCtrls, IDFORK), fCtrlLeft);
      }

      fCtrlLeft = placeXferCtrl(xferCtlScale, fCtrlLeft);

      fCtrlLeft = placeXferCtrl(GetDlgItem(hdbXferCtrls, IDSENDING), fCtrlLeft);

      if(fShowCtrls & IDBERRORS)
      {
         fCtrlLeft = placeXferCtrl(GetDlgItem(hdbXferCtrls, IDBERRORS), fCtrlLeft);
      }

      ShowWindow(hdbXferCtrls, SW_SHOWNOACTIVATE);

      if(fShowCtrls & IDPAUSE)
      {
         ShowWindow(xferCtlPause, SW_SHOWNOACTIVATE);
      }

      if(fShowCtrls & IDFORK)
      {
#ifdef ORGCODE
         bSetUp(SPACE_STR+1);
#else
         bSetup(SPACE_STR+1);
#endif
      }

      if(fShowCtrls & IDSCALE)
         showScale();
      else
         showBBytes(0L, TRUE);

      if(fShowCtrls & IDBERRORS)
      {
         showBErrors(0);
      }

   }
   else
   {
      ShowWindow(hdbXferCtrls, SW_HIDE);

      ShowWindow(xferCtlPause, SW_HIDE);
      ShowWindow(GetDlgItem(hdbXferCtrls, IDFORK), SW_HIDE);
      ShowWindow(GetDlgItem(hdbXferCtrls, IDBERRORS), SW_HIDE);
   }
}


/*---------------------------------------------------------------------------*/
/* setItemText() - Set the text of a dialog item                             */
/*---------------------------------------------------------------------------*/

HDC NEAR beginXferCtrlUpdate(HWND  hCtrl, RECT  *ctrlRect, BOOL  bRepaint)
{
   HDC      hDC;
   HBRUSH   hBrush;

   hDC = GetDC(hCtrl);
   GetClientRect(hCtrl, (LPRECT) ctrlRect);

   if(bRepaint)
      FillRect(hDC, (LPRECT) ctrlRect, (HBRUSH) GetStockObject(GRAY_BRUSH));

   InflateRect((LPRECT) ctrlRect, -1, -1);

   if(bRepaint)
   {
      hBrush = CreateSolidBrush(RGB(vidAttr[ANORMAL & AMASK].bkgd[VID_RED], 
                                    vidAttr[ANORMAL & AMASK].bkgd[VID_GREEN], 
                                    vidAttr[ANORMAL & AMASK].bkgd[VID_BLUE]));
      FillRect(hDC, (LPRECT) ctrlRect, hBrush);
      DeleteObject(hBrush);

      FrameRect(hDC, (LPRECT) ctrlRect, (HBRUSH) GetStockObject(BLACK_BRUSH));
   }

   return(hDC);
}


VOID NEAR setItemText(INT   item, BYTE  *str, BOOL  bRepaint)
{
   HWND     hItem;
   HDC      hDC;
   RECT     rect;

   hItem = GetDlgItem(hdbXferCtrls, item);

   if(bRepaint)
   {
      UpdateWindow(hdbXferCtrls);
      if(!IsWindowVisible(hItem))
         ShowWindow(hItem, SW_SHOWNOACTIVATE);
   }

   hDC = beginXferCtrlUpdate(hItem, &rect, bRepaint);
   InflateRect((LPRECT) &rect, -4, -1);
   SetBkColor(hDC, RGB(vidAttr[ANORMAL & AMASK].bkgd[VID_RED], 
                       vidAttr[ANORMAL & AMASK].bkgd[VID_GREEN], 
                       vidAttr[ANORMAL & AMASK].bkgd[VID_BLUE]));
   SetTextColor(hDC, RGB(vidAttr[ANORMAL & AMASK].text[VID_RED], 
                         vidAttr[ANORMAL & AMASK].text[VID_GREEN], 
                         vidAttr[ANORMAL & AMASK].text[VID_BLUE]));
   DrawText(hDC, (LPSTR) str, strlen(str), (LPRECT) &rect, DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
   ReleaseDC(hItem, hDC);
}

/*---------------------------------------------------------------------------*/
/* bSetUp() -                                                          [mbb] */
/*---------------------------------------------------------------------------*/

VOID bSetup(BYTE  *str)            /* mbbx 2.00: moved from XFERUTIL.C ... */
{
   setItemText(IDFORK, str, TRUE);
   strcpy(strRXFork, str);
}


/*---------------------------------------------------------------------------*/
/* showScale() - Draw the % done scale for file transfers.        [scf]      */
/*---------------------------------------------------------------------------*/

#define SECTIONS        10
#define TICKWIDTH       2

VOID showScale()                             /* mbbx 2.00: xfer ctrls... */
{
   HDC      hDC;
   RECT     rBase, rect;
   INT      increment, error, tickHeight, ndx, offset;
   HBRUSH   hBrush;

   *strRXBytes = 255;                        /* IDSCALE is scale, not bytes count */

   UpdateWindow(hdbXferCtrls);
   hDC = beginXferCtrlUpdate(xferCtlScale, &rBase, TRUE);   /* mbbx 2.00: xfer ctrls... */

   InflateRect((LPRECT) &rBase, -1, -1);
   increment = rBase.right / SECTIONS;
   error = rBase.right - (increment * SECTIONS);
   tickHeight = rBase.bottom / 2;

   hBrush = CreateSolidBrush(RGB(vidAttr[ANORMAL & AMASK].text[VID_RED], 
                                 vidAttr[ANORMAL & AMASK].text[VID_GREEN], 
                                 vidAttr[ANORMAL & AMASK].text[VID_BLUE]));
   for(ndx = 1; ndx < SECTIONS; ndx += 1)
   {
      offset = (ndx * increment) + ((ndx * error) / SECTIONS);
      SetRect((LPRECT) &rect, (rBase.left + offset) - TICKWIDTH, 
              (ndx != SECTIONS / 2) ? tickHeight : tickHeight - (tickHeight / 2), 
              (rBase.left + offset) + TICKWIDTH, rBase.bottom);
      FillRect(hDC, (LPRECT) &rect, hBrush);
   }
   DeleteObject(hBrush);

   ReleaseDC(xferCtlScale, hDC);
}

/*---------------------------------------------------------------------------*/
/* updateProgress() Update the scale (thermometer) for xfers                 */
/*---------------------------------------------------------------------------*/

VOID updateProgress(BOOL  redraw)
{
   HDC   hDC;
   RECT  ctrlRect;
   INT   left, right;

   if(redraw)
   {
      xferPct = 0;
      icon.last = 0;

      if(IsIconic(hItWnd))
      {
         myDrawIcon(getPort(), TRUE);
         releasePort();
      }
      else
         showScale();
   }

   progress = 256 - (xferBytes * 256) / (xferOrig ? xferOrig : 1);   /* avoid div by zero */
   if(IsIconic(hItWnd))
      updateIcon();
   else
   {   
      if(progress > xferPct)
      {
         hDC = GetDC(xferCtlScale);
         GetClientRect(xferCtlScale, (LPRECT) &ctrlRect);
         InflateRect((LPRECT) &ctrlRect, -2, -2);  /* mbbx 2.00: xfer ctrls... */
         ctrlRect.right -= ctrlRect.left;
         left = (INT) (((LONG) xferPct * (LONG) ctrlRect.right) / 256);
         right = (INT) (((LONG) progress * (LONG) ctrlRect.right) / 256);
         ctrlRect.right = ctrlRect.left + (INT) right;
         ctrlRect.left += (INT) left;
         InvertRect(hDC, (LPRECT) &ctrlRect);
         ReleaseDC(xferCtlScale, hDC);
      }
   }

   if(progress > xferPct)
      xferPct = progress;
}


/*---------------------------------------------------------------------------*/
/* showBBytes() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

VOID showBBytes(LONG  cnt, BOOL  bRepaint)
{
   BYTE tmp1[TMPNSTR+1];
   BYTE tmp2[TMPNSTR+1];

   LoadString(hInst, STR_BYTECOUNT, (LPSTR) tmp1, TMPNSTR);
   sprintf(tmp2, tmp1, cnt);
   setItemText(IDSCALE, tmp2, bRepaint);
   strcpy(strRXBytes, tmp2);
}


/*---------------------------------------------------------------------------*/
/* showRXFname() -                                                           */
/*---------------------------------------------------------------------------*/

VOID showRXFname(BYTE  *fileName, INT   actionString)
{
   BYTE  tmp1[TMPNSTR+1];

   LoadString(hInst, actionString, (LPSTR) tmp1, TMPNSTR);
   strcpy(tmp1+strlen(tmp1), fileName);
   setItemText(IDSENDING, tmp1, TRUE);       /* mbbx 2.00: xfer ctrls */
   strcpy(strRXFname, tmp1);
}


/*---------------------------------------------------------------------------*/
/* showBErrors() -                                               [scf]       */
/*---------------------------------------------------------------------------*/

VOID showBErrors(INT  cnt)
{
   BYTE tmp1[TMPNSTR+1];
   BYTE tmp2[TMPNSTR+1];
   
   LoadString(hInst, STR_RETRIES, (LPSTR) tmp1, TMPNSTR);   /* mbbx 1.00 ... */
   sprintf(tmp2, tmp1, cnt);
   setItemText(IDBERRORS, tmp2, TRUE);       /* mbbx 2.00: xfer ctrls */
   strcpy(strRXErrors, tmp2);
}


/*---------------------------------------------------------------------------*/
/* updateIndicators() -                                                      */
/*---------------------------------------------------------------------------*/

VOID updateIndicators()                      /* mbbx 2.00: moved from DCUTIL2.C ... */
{
   if(xferFlag != XFRNONE)
   {
      UpdateWindow(hdbXferCtrls);            /* mbbx 1.04: fkeys... */

      if(*strRXFork != 0)
         setItemText(IDFORK, strRXFork, TRUE);  /* mbbx 2.00: xfer ctrls... */

      if(*strRXBytes == 255)
         updateProgress(TRUE);
      else if(*strRXBytes != 0)
         setItemText(IDSCALE, strRXBytes, TRUE);

      if(*strRXFname != 0)
         setItemText(IDSENDING, strRXFname, TRUE);

      if(*strRXErrors != 0)
         setItemText(IDBERRORS, strRXErrors, TRUE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\task.h ===
#define NULL_TASK                -1
struct                                       /* misc TASK parameters */
{
   STRING   string[STR255];
} taskState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\sndbfile.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "fileopen.h"
#include "task.h"

VOID sndBPre(BYTE  *fname, INT   actionString)
{
   showXferCtrls(IDSTOP | IDFORK | IDSCALE | IDSENDING | IDBERRORS);    /* mbbx 2.00: xfer ctrls... */
   showRXFname(fname, actionString);
}


/*---------------------------------------------------------------------------*/
/* sndBFileErr() -                                               [scf]       */
/*---------------------------------------------------------------------------*/

VOID sndBFileErr(INT    ioErrFlag, STRING *fileName)
{
   memcpy(taskState.string, fileName, *fileName+2);
   TF_ErrProc(ioErrFlag, MB_OK | MB_ICONHAND, 999);      /* taskState.error */
}

#ifdef ORGCODE
#else
VOID swapWords(PVOID pVoid)
{
WORD wTmpHigh,wTmpLow;
PWORD pw;

pw = (PWORD)pVoid;

wTmpHigh = *pw;
wTmpLow  = *(pw+1);
*pw = wTmpLow;
*(pw+1) = wTmpHigh;

}
#endif


/*---------------------------------------------------------------------------*/
/* getSndBFile() -                                             [scf]         */
/*---------------------------------------------------------------------------*/

BOOL getSndBFile(INT  actionString)
{
   BOOL     getSndBFile;
   FSReply  reply;
   INT      refNo;
   DOSTIME  fileDate;
   LONG     secs;
   LONG     tmp;
   WORD     wMode;
   BYTE     fileExt[FILENAMELEN+1];
   OFSTRUCT file;

   getSndBFile = FALSE;
   *reply.vRefNum = *reply.fName = 0;

   wMode = FO_GETFILE | FO_FILEEXIST;     /* rjs - added fileexist */
   if(xferBinType == XFRYMODEM)           /* mbbx 1.01 */
      wMode |= FO_BATCHMODE;
   else if(xferBinType == XFRKERMIT)
   /* jtf 3.17   wMode |= FO_REMOTEFILE */ ;
   getFileDocData(FILE_NDX_DATA, reply.vRefNum, reply.fName, fileExt, NULL);
   *macFileName = 0;

   if(reply.vRefNum[strlen(reply.vRefNum) - 1] != '\\')
      strcat(reply.vRefNum, "\\");

   if(reply.good = FileOpen(reply.vRefNum, reply.fName, macFileName, fileExt, 
                            NULL, FO_DBSNDFILE, NULL, wMode))
   {
      useMacFileName = (*macFileName != 0);
   }

   if(reply.good)
   {
      setFileDocData(FILE_NDX_DATA, reply.vRefNum, reply.fName, NULL, NULL);  /* mbbx 2.00: no forced extents */

      strcpy(xferVRefNum+1, reply.vRefNum);  /* mbbx 0.62: save the path !!! */
      *xferVRefNum = strlen(xferVRefNum+1);

      strcpy(xferFname+1, useMacFileName ? macFileName : reply.fName);
      *xferFname = strlen(xferFname+1);

      xferRefNo = 0;
      if(xferBinType != XFRYMODEM)           /* mbbx 1.01: ymodem */
      {
         if((xferBinType == XFRYTERM) && !answerMode)          /* mbbx: yterm */
            return(FALSE);
#ifdef ORGCODE
         strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
#else

         strcpy(reply.vRefNum+strlen(reply.vRefNum), "\\");
         strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);

         DEBOUT("getSndBFile: opening the file[%s]\n",reply.vRefNum);
         DEBOUT("getSndBFile: with flags      [%lx]\n",O_RDONLY);
#endif

         if((xferRefNo = OpenFile((LPSTR) reply.vRefNum, (LPOFSTRUCT)&file,
                                   OF_READ)) == -1)
         {
            sndBFileErr(STRFERROPEN, reply.fName);
            xferRefNo = 0;
            return FALSE;
         }
         if((xferBytes = fileLength(xferRefNo)) == -1L)
         {
            sndBFileErr(STRFERROPEN, reply.fName);
            if(xferBinType == XFRYTERM)         /* mbbx: yterm */
               answerMode = FALSE;
            _lclose(xferRefNo);
            xferRefNo = 0;
            return FALSE;
         }
         xferParams.ioFlLgLen = xferBytes; 
         swapWords (&xferParams.ioFlLgLen);       /* intel tch tch */
         xferParams.ioFlRLgLen = 0l;
         xferLgLen = xferBytes;

         getFileDate (&fileDate, xferRefNo);

         secs = 0;

         xferParams.ioFlCrDat  =  
         xferParams.ioFlMdDat  = secs;
         xferParams.fdFlags    = 0;

      }
      else
      {
         xferBytes = 1L;
      }

      xferErrors  = 0;
      xferLength  = 0L;
      xferOrig    = xferBytes;
      xferPct     = 0;

      sndBPre(reply.fName, actionString);
      getSndBFile = TRUE;
   }

   return(getSndBFile);
}


/*---------------------------------------------------------------------------*/
/* sndBFile() - Send a binary file.                              [scf]       */
/*---------------------------------------------------------------------------*/

VOID sndBFile()
{
   if(xferFlag != XFRNONE)                   /* mbbx 1.10: answerMode... */
   {
      return;
   }

   xferFast  = FALSE;

   if(!answerMode)
   {
      switch(trmParams.xBinType)
      {
      case ITMXMODEM:
         xferBinType = XFRXMODEM;
         break;

      case ITMKERMIT:
         xferBinType = XFRKERMIT;
         break;
      }
      xferBinFork = XFRDATA;
   }

   if(getSndBFile(STR_SENDING))
      xferFlag = XFRBSND;
}


/*---------------------------------------------------------------------------*/
/* sndAbort() -                                                  [scf]       */
/*---------------------------------------------------------------------------*/

VOID sndAbort  ()
{
   BYTE tmp1[TMPNSTR+1];

      LoadString(hInst, STR_ABORTSND, (LPSTR) tmp1, TMPNSTR);
      testMsg(tmp1, &xferFname[1],NULL);
}


/*---------------------------------------------------------------------------*/
/* xSndBFile() -                                                             */
/*---------------------------------------------------------------------------*/

VOID xSndBFile()
{
   BYTE  saveDataBits, saveParity, saveFlowCtrl;

   termSendCmd(trmParams.binTXPrefix, strlen(trmParams.binTXPrefix), 0x0042 | TRUE);   /* mbbx 2.01.19 ... */

   saveDataBits = trmParams.dataBits;        /* mbbx 2.00: auto adjust settings... */
   saveParity   = trmParams.parity;
   saveFlowCtrl = trmParams.flowControl;     /* mbbx 2.00.05: eliminate flowSerial()... */

   if((xferBinType != XFRKERMIT) && (xferBinType != XFRYTERM))
   {
      trmParams.dataBits = ITMDATA8;
      trmParams.parity = ITMNOPARITY;
      trmParams.flowControl = ITMNOFLOW;
      resetSerial(&trmParams, FALSE, FALSE, 0); /* slc swat */
   }

   switch(xferBinType)
   {
   case XFRXMODEM:
      XM_SndFile(0x0800);                    /* XM_CRC */
      break;

   case XFRKERMIT:
      KER_Send();                            /* rkhx 2.00 */
      break;

   }

   if((trmParams.dataBits != saveDataBits) || (trmParams.parity != saveParity) || (trmParams.flowControl != saveFlowCtrl))
   {
      trmParams.dataBits = saveDataBits;
      trmParams.parity = saveParity;
      trmParams.flowControl = saveFlowCtrl;
      resetSerial(&trmParams, FALSE, FALSE, 0); /* slc swat */
   }

   termSendCmd(trmParams.binTXSuffix, strlen(trmParams.binTXSuffix), 0x0042 | TRUE);   /* mbbx 2.01.19 ... */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\term.c ===
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"


/*---------------------------------------------------------------------------*/

BOOL  insertionPoint;
LONG  anchorNdx, lastNdx;


/*---------------------------------------------------------------------------*/
/* pointToLong() - Convert coordinates (pt.x, pt.y) relative to the          */
/*                 current display to an absolute buffer index.              */
/*---------------------------------------------------------------------------*/

VOID pointToLong(POINT	pt, LONG *l)
{
   INT row, col;

   if((col = ((pt.x + (chrWidth / 2) - 1) / chrWidth) + curLeftCol) < 0)
      col = 0;
   else if(col > maxChars)
      col = maxChars;

   if((row = (pt.y / chrHeight) + curTopLine) < 0)
      row = 0;
   else if(row > maxLines)
   {
      row = maxLines;
      col = 0;
   }

   *l = (row * (maxChars + 2)) + col;
}


/*---------------------------------------------------------------------------*/
/* rcToPoint () - Convert absolute rc.row, rc.col to coordinates (GDI)       */
/*                relative to the currently displayed portion of the buffer. */
/*---------------------------------------------------------------------------*/

VOID rcToPoint (ROWCOL rc, POINT *pt, INT bottom)
{
   pt->y = hTE.viewRect.top  + (rc.row - curTopLine) * chrHeight + bottom;
   pt->x = hTE.viewRect.left + (rc.col - curLeftCol) * chrWidth;
}   


/*---------------------------------------------------------------------------*/
/* rcToPointS () - Convert absolute rc.row, rc.col to coordinates (GDI)       */
/*                relative to the currently displayed portion of the buffer. */
/*---------------------------------------------------------------------------*/

#ifdef NOMORE
VOID rcToPointS (ROWCOL rc, POINT *pt, INT bottom)
{
   pt->y = hTE.viewRect.top  + (rc.row - curTopLine) * chrHeight + bottom;
   pt->x = hTE.viewRect.left + (rc.col - curLeftCol) * chrWidth;
}   
#endif


/*---------------------------------------------------------------------------*/
/* longToPoint () - Convert selection to coordinates relative                */
/*                  to the currently displayed portion of the buffer.        */
/*---------------------------------------------------------------------------*/

VOID longToPoint(LONG sel, POINT *pt)
{
   ROWCOL   rc;

   rc.row = sel / (maxChars + 2);
   if((rc.col = sel % (maxChars + 2)) > maxChars)
      rc.col = maxChars;
   rcToPoint(rc, pt, 0);
}


/*---------------------------------------------------------------------------*/
/* hiliteSelect() -                                                          */
/*---------------------------------------------------------------------------*/

VOID NEAR invertSelectRect(NPRECT   pRect)
{
   INT   viewRectEnd, offset;

   viewRectEnd = hTE.viewRect.bottom;
   if((offset = (curTopLine + visScreenLine) - (savTopLine + maxScreenLine)) > 0)
      viewRectEnd -= (offset * chrHeight);

   if(pRect->top > viewRectEnd)
      pRect->top = viewRectEnd;
   if(pRect->bottom > viewRectEnd)
      pRect->bottom = viewRectEnd;

   InvertRect(thePort, (LPRECT) pRect);
}


VOID hiliteSelect(LONG  lSelStart, LONG  lSelEnd)
{
   ROWCOL   selStart, selEnd;
   RECT     hiliteRect;

   getPort();

   selStart.row = lSelStart / (maxChars + 2);
   selStart.col = lSelStart % (maxChars + 2);
   selEnd.row   = lSelEnd   / (maxChars + 2);
   selEnd.col   = lSelEnd   % (maxChars + 2);

   if(lSelEnd > lSelStart)
   {
      if(selStart.row == selEnd.row)
      {
         rcToPoint(selStart, (PPOINT) &hiliteRect.left, 0);
         rcToPoint(selEnd, (PPOINT) &hiliteRect.right, chrHeight);
         invertSelectRect(&hiliteRect);
      }
      else
      {
         rcToPoint(selStart, (PPOINT) &hiliteRect.left, 0);
         selStart.col = maxChars;
         rcToPoint(selStart, (PPOINT) &hiliteRect.right, chrHeight);
         invertSelectRect(&hiliteRect);
         selStart.row += 1;
         selStart.col = 0;

         if(selEnd.row > selStart.row)
         {
            rcToPoint(selStart, (PPOINT) &hiliteRect.left, 0);
            selStart.row = selEnd.row - 1;
            selStart.col = maxChars;
            rcToPoint(selStart, (PPOINT) &hiliteRect.right, chrHeight);
            invertSelectRect(&hiliteRect);
            selStart.col = 0;
         }

         if(selStart.col != selEnd.col)
         {
            selStart.row = selEnd.row;
            rcToPoint(selStart, (PPOINT) &hiliteRect.left, 0);
            rcToPoint(selEnd, (PPOINT) &hiliteRect.right, chrHeight);
            invertSelectRect(&hiliteRect);
         }
      }
   }
   else if((lSelEnd == lSelStart) && insertionPoint)
   {
      rcToPoint(selStart, (PPOINT) &hiliteRect.left, 0);
      rcToPoint(selEnd, (PPOINT) &hiliteRect.right, chrHeight);
      hiliteRect.right += GetSystemMetrics(SM_CXBORDER);
      invertSelectRect(&hiliteRect);
   }

   releasePort();
}


/*---------------------------------------------------------------------------*/
/* termActivate() -                                                          */
/*---------------------------------------------------------------------------*/

VOID termActivate (tEHandle *hTE)
{
   if (!hTE->active)
   {
      hiliteSelect (hTE->selStart, hTE->selEnd);
      hTE->active = TRUE;
   }
}


/*---------------------------------------------------------------------------*/
/* termDeactivate() -                                                        */
/*---------------------------------------------------------------------------*/

VOID termDeactivate (tEHandle *hTE)
{
   if (hTE->active)
   {
      hiliteSelect (hTE->selStart, hTE->selEnd);
      hTE->active = FALSE;
   }
}


/*---------------------------------------------------------------------------*/
/* termSetSelect() -                                                         */
/*---------------------------------------------------------------------------*/

VOID termSetSelect (LONG   selStart, LONG   selEnd)
{
   LONG  eob;

   eob = maxLines * (maxChars + 2);
   if (selStart > eob)
      selStart = eob;
   if (selEnd > eob)
      selEnd = eob;
   if (hTE.active)
   {
      hiliteSelect (hTE.selStart, hTE.selEnd);
      hiliteSelect (selStart, selEnd);
   }
   hTE.selStart = selStart;
   hTE.selEnd   = selEnd;
}


/*---------------------------------------------------------------------------*/
/* extendSelect () -                                                         */
/*---------------------------------------------------------------------------*/

VOID extendSelect (LONG anchorRc, LONG lastRc)
{
   if (lastRc < hTE.selStart)
   {
      if (anchorRc == hTE.selStart)
         termSetSelect (lastRc, anchorRc);
      else
      {
         hiliteSelect (lastRc, hTE.selStart);
         hTE.selStart = lastRc; 
      }
   }
   else if (lastRc > hTE.selEnd)
   {
      if (anchorRc == hTE.selEnd)
         termSetSelect (anchorRc, lastRc);
      else
      {
         hiliteSelect (hTE.selEnd, lastRc);
         hTE.selEnd = lastRc;
      }
   }
   else
   {
      if (anchorRc == hTE.selStart)
      {
         hiliteSelect (lastRc, hTE.selEnd);
         hTE.selEnd = lastRc;
      }
      else
      {
         hiliteSelect (hTE.selStart, lastRc);
         hTE.selStart = lastRc;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* keyBoardToMouse() -                                                       */
/*---------------------------------------------------------------------------*/
VOID keyBoardToMouse(INT partCode)               /* mbbx 2.01.185 ... */
{
   DEBOUT("keyBoardToMouse(): %s\n","TAKE CARE OF LastPoint MPOIN/POINT");

   switch(partCode)
   {
   case VK_LEFT:
      if((lastPoint.x > 0) || (curLeftCol > 0))
      {
         lastPoint.x -= chrWidth;
         break;
      }
                                             /* else fall thru... */
   case VK_UP:
      if((lastPoint.y > 0) || (curTopLine > 0))
      {
         lastPoint.y -= chrHeight;
         if(partCode == VK_LEFT)
            lastPoint.x = (maxChars * chrWidth);
      }
      else
         MessageBeep(0);
      break;

   case VK_RIGHT:
   case VK_DOWN:
      if(lastPoint.y <= (((savTopLine + maxScreenLine) - curTopLine) * chrHeight))
      {
         if((partCode == VK_RIGHT) && 
            (lastPoint.x < ((maxChars - curLeftCol) * chrWidth)))
         {
            lastPoint.x += chrWidth;
         }
         else if(((lastPoint.y += chrHeight) > (((savTopLine + maxScreenLine) - 
            curTopLine) * chrHeight)) || (partCode == VK_RIGHT))
         {
            lastPoint.x = -((curLeftCol + 1) * chrWidth);
         }
      }
      else
         MessageBeep(0);
      break;
   }
}


/*---------------------------------------------------------------------------*/
/* termClick() - Handles mouse & keyboard for selection ranges.              */
/*---------------------------------------------------------------------------*/

VOID hideInsertionPoint()
{
   if(hTE.selStart == hTE.selEnd)
      hiliteSelect(hTE.selStart, hTE.selEnd);
   insertionPoint = FALSE;
}


/*---------------------------------------------------------------------------*/

BOOL stillDown(BOOL keyboard)
{
   MSG  msg;
   BOOL result;

   result = TRUE;

   if (!keyboard)
   {
      if (PeekMessage(&msg, hTermWnd, WM_MOUSEFIRST, WM_MOUSELAST, TRUE))
      {
         switch (msg.message)
         {
            case WM_LBUTTONUP:
               result = FALSE;
               break;
            case WM_MOUSEMOVE:
//               lastPoint = MAKEMPOINT(msg.lParam);
               lastPoint.x = (LONG)LOWORD(msg.lParam);
               lastPoint.y = (LONG)HIWORD(msg.lParam);
               break;
         }
      }
   }
   else 
      result = FALSE;

   return result;
}


/*---------------------------------------------------------------------------*/

VOID showInsertionPoint()
{
   insertionPoint = TRUE;
   if(hTE.selStart == hTE.selEnd)
      hiliteSelect(hTE.selStart, hTE.selEnd);
}


/*---------------------------------------------------------------------------*/

VOID termClick(POINT anchorPt, BOOL extend, INT partCode)
{
   BOOL  keyboard;

   if (scrapSeq || ((xferFlag != XFRNONE) && (xferFlag != XFRRCV)) ) 
         return; 

   hideInsertionPoint();

   if(keyboard = (partCode != 0))
   {
      if((hTE.selStart == hTE.selEnd) && !extend)
      {
         if(anchorPt.y < 0)
            anchorPt.y = 0;
         else if(anchorPt.y > ((visScreenLine + 1) * chrHeight))
            anchorPt.y = ((visScreenLine + 1) * chrHeight);

         lastPoint = anchorPt;
         pointToLong(anchorPt, &anchorNdx);
         termSetSelect(anchorNdx, anchorNdx);
      }
      else
      {
         longToPoint(lastNdx, &lastPoint);
         if(lastNdx == hTE.selStart)
            anchorNdx = hTE.selEnd;
         else
            anchorNdx = hTE.selStart;
      }

      keyBoardToMouse(partCode);
   }
   else
   {
      SetCapture(hTermWnd);

      lastPoint = anchorPt;
      pointToLong(anchorPt, &anchorNdx);

      if(extend)
      {
         if(anchorNdx >= hTE.selStart)
            anchorNdx = hTE.selStart;
         else
            anchorNdx = hTE.selEnd;
      }
      else
         termSetSelect(anchorNdx, anchorNdx);
   }

   repeat
   {
      pointToLong(lastPoint, &lastNdx);
      pasClikLoop();

      if(keyboard && !extend)
      {
         anchorNdx = lastNdx;
         termSetSelect(lastNdx, lastNdx);
      }
      else
         extendSelect(anchorNdx, lastNdx);
   }
   until(!stillDown(keyboard));

   if(!keyboard)
      ReleaseCapture();

   showInsertionPoint();
}


/*---------------------------------------------------------------------------*/
/* getPort() -                                                               */
/*---------------------------------------------------------------------------*/

HDC getPort ()
{
   if (thePort == 0)
   { 
      thePort = GetDC (hTermWnd);
      SelectObject (thePort, hTE.hFont);
      portLocks = 1;
   }
   else
      portLocks++;
   return thePort;
}


/*---------------------------------------------------------------------------*/
/* releasePort() -                                                           */
/*---------------------------------------------------------------------------*/

VOID releasePort ()
{
   if (--portLocks <= 0)
   {
      ReleaseDC (hTermWnd,thePort);
      thePort = 0;
   }
}


/*---------------------------------------------------------------------------*/
/* pasClickLoop() -                                                          */
/*---------------------------------------------------------------------------*/

BOOL  APIENTRY pasClikLoop()                /* mbbx 2.01.185 ... */
{
   INT   ndx;
   POINT PointL;

   if (lastPoint.y < hTE.viewRect.top - chrHeight) 
         lastPoint.y = hTE.viewRect.top - chrHeight; /* jtf 3.21 */
   if (lastPoint.y > hTE.viewRect.bottom) 
         lastPoint.y = hTE.viewRect.bottom; /* jtf 3.21 */

/* changed &hTE.viewRect  to &(hTE.viewRect) to see if error goes -sdj */
/* Actual error was due to lastPoint being MPOINT ie POINTS, changed type -sdj */
/* changed lastPoint back to MPOINT and taking care of conversion here -sdj*/

   if(!PtInRect((LPRECT) &(hTE.viewRect), lastPoint))
   {
      for(ndx = lastPoint.y; ndx < hTE.viewRect.top; ndx += chrHeight)
         trackScroll(SB_VERT, SB_LINEUP);
      while(ndx >= hTE.viewRect.bottom)
      {
         trackScroll(SB_VERT, SB_LINEDOWN);
         ndx -= chrHeight;
      }

      for(ndx = lastPoint.x; ndx < hTE.viewRect.left; ndx += chrWidth)
         trackScroll(SB_HORZ, SB_LINEUP);
      while(ndx >= hTE.viewRect.right)
      {
         trackScroll(SB_HORZ, SB_LINEDOWN);
         ndx -= chrWidth;
      }

      scrollBits();
   }

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\termfile.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31
#define  USECOMM

#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "fileopen.h"
#include "task.h"


/*---------------------------------------------------------------------------*/

#define DCS_OLD_FKEYLEVELS       4
#define DCS_OLD_NUMFKEYS         8
#define DCS_OLD_FKEYLEN          64
#define DCS_OLD_FKEYTITLESZ      20
#define DCS_OLD_XTRALEN          44
#define DCS_OLD_MDMCMDLEN        32
#define DCS_OLD_MISCSTRLEN       21


#define TITLEREC                 struct tagTITLEREC

struct tagTITLEREC
{
   BYTE  title[DCS_OLD_FKEYTITLESZ];
   BYTE  xtra[DCS_OLD_XTRALEN];
};


#define oldTrmParams             struct tagOldTrmParams
#define LPOLDSETTINGS            oldTrmParams FAR *

struct tagOldTrmParams
{
   INT         inpRefNum;
   INT         outRefNum;
   INT         emulate;
   INT         dataBits;
   INT         parity;
   INT         speed;
   INT         stopBits;
   BYTE        col80Or132;
   BYTE        flowControl;
   BOOL     localEcho;
   BOOL     lineWrap;
   BOOL     inpCRLF;
   BOOL     outCRLF;
   BOOL     inpLFCR;
   BOOL     fCtrlBits;
   STRING      fKeyText[DCS_OLD_FKEYLEVELS][DCS_OLD_NUMFKEYS][DCS_OLD_FKEYLEN];
   TITLEREC    fKeyTitle[DCS_OLD_FKEYLEVELS][DCS_OLD_NUMFKEYS];
   STRING      phone[DCS_OLD_MDMCMDLEN];
   STRING      binTXPrefix[DCS_OLD_MDMCMDLEN];
   STRING      dialPrefix[DCS_OLD_MDMCMDLEN];
   STRING      binTXSuffix[DCS_OLD_MDMCMDLEN];
   STRING      dialSuffix[DCS_OLD_MDMCMDLEN];
   STRING      binRXPrefix[DCS_OLD_MDMCMDLEN];
   STRING      hangPrefix[DCS_OLD_MDMCMDLEN];
   STRING      binRXSuffix[DCS_OLD_MDMCMDLEN];
   STRING      hangSuffix[DCS_OLD_MDMCMDLEN];
   STRING      fastInq[DCS_OLD_MDMCMDLEN];
   STRING      originate[DCS_OLD_MDMCMDLEN];
   STRING      fastRsp[DCS_OLD_MDMCMDLEN];
   STRING      answer[DCS_OLD_MDMCMDLEN];
   STRING      strXtra8[DCS_OLD_MDMCMDLEN];
   BOOL     flgRetry;
   BYTE        padding2;
   INT         dlyRetry;
   INT         cntRetry;
   BOOL     flgSignal;
   BYTE        version;
   BOOL     carrierFlag;
   BYTE        padding3;
   STRING      xLinStr[DCS_OLD_MISCSTRLEN+1];
   STRING      mdmConnect[DCS_OLD_MISCSTRLEN+1];
   STRING      strXtra2[DCS_OLD_MISCSTRLEN+1];
   STRING      strXtra3[DCS_OLD_MISCSTRLEN+1];
   STRING      strXtra4[DCS_OLD_MISCSTRLEN+1];
   INT         rcvBlSz;
   INT         sendBlSz;
   INT         retryCt;
   BYTE        remote;
   BYTE        padding9;
   INT         xtraInt[4];
   INT         xWrapCol;
   BYTE        termCursor;
   BOOL     cursorBlink;
   BOOL     bsKey;
   BYTE        language;
   STRING      autoExecute[DCS_OLD_FKEYLEN];
   BYTE        xTxtType;
   BYTE        xChrType;
   INT         xChrDelay;
   BYTE        xLinType;
   BYTE        padding10;
   INT         xLinDelay;
   BYTE        xMdmType;
   BOOL     xWordWrap;
   BYTE        xBinType;
   BYTE        xBinFork;
};


/*---------------------------------------------------------------------------*/

#define MSSETTINGS               struct tagMSSETTINGS
#define LPMSSETTINGS             MSSETTINGS FAR *

struct tagMSSETTINGS
{
   INT     iCRC;               /* The CRC checksum for the settings */
   INT     iVersion;           /* The version number */
   BOOL    fModem;             /* True if port is connected to a modem */
   BOOL    fNewLine;           /* True if new-line button is on */
   BOOL    fLocalEcho;         /* True if local-echo button is on */
   BOOL    fAutoWrap;          /* True if auto-wrap button is on */
   BOOL    fVT52;              /* True if term is VT52, false if ANSI */
   BOOL    fLarge;             /* True for large text size */
   BOOL    fTone;              /* True if dial type is tone */
   BOOL    fFast;              /* True if dial pulses are short */
   INT     clnBuf;             /* Count of lines in buffer */
   INT     iBaud;              /* The baud rate */
   INT     iPort;              /* The port number */
   INT     iByteSize;          /* The number of bits per char */
   INT     iStopBits;          /* The number of stop bits */
   INT     iParity;            /* The parity method */
   INT     iHandshake;         /* The handshake method */
   INT     iAnswer;            /* The number of seconds to wait for answer */
   INT     iToneWait;          /* Number of seconds to wait for tone */
   CHAR    szPhNum[30];        /* The phone number */
   CHAR    szFNCapture[128];   /* The capture file name */
   INT     iCountry;           /* The character translation country code */
};


/*---------------------------------------------------------------------------*/

BOOL termInitSetup(HANDLE);                  /* ==> termfile.h */
VOID termCloseEnable(BOOL);
BOOL termCloseFile(VOID);
BOOL termCloseAll(VOID);
BOOL termSaveFile(BOOL);
BOOL NEAR termReadFile(BYTE *);
VOID NEAR termCloseWindow(VOID);
BOOL NEAR termCloseFileInternal(VOID);
INT TF_ErrProc(WORD, WORD, WORD);

BOOL NEAR readTermSettings(INT, WORD);       /* mbbx 2.00: was LONG */
VOID NEAR convertMSToIBM(LPMSSETTINGS, recTrmParams *);
BOOL NEAR writeTermSettings(INT);
VOID NEAR convertInternalToVirtual(LPSETTINGS, LPSETTINGS); /* rkhx 2.00 */


/*---------------------------------------------------------------------------*/
/* termInitSetup() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

BOOL termInitSetup(HANDLE   hPrevInstance)
{
   // sdj: was unref local- WNDCLASS	termClass;

   activTerm = FALSE;

   strcpy(termData.filePath, fileDocData[FILE_NDX_SETTINGS].filePath);
   *termData.fileName = 0;
   strcpy(termData.fileExt, fileDocData[FILE_NDX_SETTINGS].fileExt);
   LoadString(hInst, STR_TERMINAL, (LPSTR) termData.title, MINRESSTR);
   termData.flags = TF_DEFTITLE;

   resetEmul();                              /* must have init settings! */

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* termFile() -                                                        [mbb] */
/*---------------------------------------------------------------------------*/

BOOL termFile(BYTE *filePath, BYTE *fileName,BYTE *fileExt,BYTE *title,WORD flags)
{
   BYTE  work[PATHLEN];
   RECT  termRect;
   BYTE  OEMname[STR255];            /* jtf 3.20 */

   if(strlen(fileName) > 0)                  /* mbbx 1.03 ... */
   {
#ifdef ORGCODE
      strcpy(work, filePath);                /* mbbx 2.00: no forced extents... */
      strcpy(work+strlen(work), fileName);      /* jtf 3.20 */
#else
      strcpy(work, filePath);                /* mbbx 2.00: no forced extents... */
      strcpy(work+strlen(work), "\\");      /* jtf 3.20 */
      strcpy(work+strlen(work), fileName);      /* jtf 3.20 */
#endif


      // JYF -- replace below two lines with following if()
      //        to remove the use of AnsiToOem()
      //
      //AnsiToOem((LPSTR) work, (LPSTR) OEMname); /* jtf 3.20 */
      //if(!fileExist(OEMname))

      if (!fileExist(work))
         return(FALSE);
   }

   if(termCloseFileInternal())
   {
      if((flags & TF_DEFTITLE) && (strlen(fileName) > 0))
         strcpy(termData.title, fileName);
      else
         strcpy(termData.title, title);
      SetWindowText(hTermWnd, (LPSTR) termData.title);
      setAppTitle();

      SetCursor(LoadCursor(NULL, IDC_WAIT));

      strcpy(termData.filePath, filePath);
      strcpy(termData.fileName, fileName);
      strcpy(termData.fileExt, fileExt);
      termData.flags = flags | (termData.flags & (TF_DIM | TF_HIDE));

      setDefaults();                         /* mbbx 2.00: do this first! */
      if(strlen(fileName) > 0)
      {
         if(!termReadFile(work))
            doFileNew(); /* jtf 3.31 */
      }

      activTerm = TRUE;

      setFKeyLevel(1, TRUE);       /* mbbx 2.00 ... */
      showHidedbmyControls(trmParams.environmentFlags & DCS_EVF_FKEYSSHOW, TRUE);   /* jtf 3.20 */
      resetSerial(&trmParams, TRUE, FALSE, 0);
      resetEmul();
      initChildSize(&termRect);              /* mbbx 2.00: reset window pos... */
      if(IsZoomed(hTermWnd))
         SetFocus(NULL);

      if(!(termData.flags & TF_HIDE))
         showTerminal(TRUE, TRUE);

      SetCursor(LoadCursor(NULL, IDC_ARROW));
   }

   gotCommEvent = TRUE;
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* termCloseFile() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

BOOL termCloseFile(VOID)
{
   BOOL  termCloseFile = TRUE;

   if(activTerm)
   {
      if(termCloseFile = termCloseFileInternal())
         termCloseWindow();
   }

   return(termCloseFile);
}


/*---------------------------------------------------------------------------*/
/* termCloseAll() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL termCloseAll(VOID)
{
   return(termCloseFile());
}


/*---------------------------------------------------------------------------*/
/* termSaveFile() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL termSaveFile(BOOL  bGetName)
{
   BOOL        termSaveFile = TRUE;
   BYTE        titleText[MINRESSTR];
   BYTE        filePath[PATHLEN+1];
   INT         hFile;
   // sdj: was unref local - OFSTRUCT	ofDummy;
   BYTE        fileName[PATHLEN];

   SetCursor(LoadCursor(NULL, IDC_WAIT));

   if(activTerm)
   {
      if(bGetName || (strlen(termData.fileName) == 0))
      {
         /* rjs swat - default to *.trm if no default term name */
         if(strlen(termData.fileName))
            strcpy(fileName, termData.fileName);
         else
            strcpy(fileName, "*.TRM");
         /* end rjs swat */

                                             /* mbbx 1.10: CUA... */
         LoadString(hInst, !bGetName ? STR_SAVE : STR_SAVEAS, (LPSTR) titleText, MINRESSTR);

         if(termData.filePath[strlen(termData.filePath) - 1] != '\\')
            strcat(termData.filePath, "\\");

         termSaveFile = FileOpen(termData.filePath, fileName, NULL, termData.fileExt,
                                 titleText, 0, NULL, FO_PUTFILE | FO_FORCEEXTENT);

         if(strrchr(fileName, '\\'))
            strcpy(termData.fileName, strrchr(fileName, '\\') + 1);
         else
            strcpy(termData.fileName, fileName);
      }

      if(termSaveFile)
      {
         setFileDocData(FILE_NDX_SETTINGS, termData.filePath, termData.fileName, NULL, NULL);   /* mbbx 2.00: no forced extents... */

         if(termData.flags & TF_DEFTITLE)
         {
            strcpy(termData.title, termData.fileName);
            SetWindowText(hTermWnd, (LPSTR) termData.fileName);
            setAppTitle();                   /* mbbx 1.00 */
         }

#ifdef ORGCODE
         strcpy(filePath, termData.filePath);
         strcpy(filePath+strlen(filePath), termData.fileName);
#else

         /* jtf 3.20 */

         strcpy(filePath, termData.filePath);
         strcpy(filePath+strlen(filePath), "\\");
         strcpy(filePath+strlen(filePath), termData.fileName);

      DEBOUT("termSaveFile: opening the file[%s]\n",filePath);
      DEBOUT("termSaveFile: with flags      [%lx]\n",O_WRONLY|O_TRUNC|O_CREAT|S_IWRITE);
#endif
         if((hFile = _open((LPSTR) filePath, O_WRONLY | O_TRUNC | O_CREAT, S_IWRITE)) != -1)
         {
            if(termSaveFile = writeTermSettings(hFile))
               termData.flags &= ~TF_CHANGED;

            _close(hFile);
         }
         else
            termSaveFile = FALSE;

         if(!termSaveFile)
         {
            TF_ErrProc(STREWRERR, MB_OK | MB_ICONHAND, 999);
            strcpy(termData.fileName, "");      /* rjs swat */
         }
      }
      else
         strcpy(termData.fileName, "");      /* rjs swat */
   }

   SetCursor(LoadCursor(NULL, IDC_ARROW));

   return(termSaveFile);
}


/*---------------------------------------------------------------------------*/
/* termReadFile() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR termReadFile(BYTE  *filePath)
{
   BOOL        termReadFile = FALSE;
   INT         hFile;
   // sdj: was unref local - OFSTRUCT	ofDummy;
   // sdj: was unref local - LOGFONT	logFont;
   BYTE        *junk;

   /* jtf 3.20 */
   DEBOUT("termReadFile: opening the file[%s]\n",filePath);
   DEBOUT("termReadFile: with flags      [%lx]\n",O_RDONLY);

   junk = strrchr(filePath, '.');
   AnsiUpper((LPSTR)junk);

   if((hFile = _open((LPSTR) filePath, O_RDONLY)) != -1)
   {
      if(termReadFile = readTermSettings(hFile, _filelength(hFile)))
      {
         resetTermBuffer();               /* mbbx 1.03 */
         icsResetTable((WORD) trmParams.language);    /* mbbx 1.04: ics */
         buildTermFont();                    /* mbbx 2.00: font selection... */
         trmParams.fResetDevice = TRUE;      /* mbbx 2.00: network... */
         trmParams.newDevRef = trmParams.comDevRef;
         trmParams.comDevRef = ITMNOCOM;
      }

      _close(hFile);
   }
   else
      TF_ErrProc(STRFERROPEN, MB_OK | MB_ICONHAND, 999);

   return(termReadFile);
}


/*---------------------------------------------------------------------------*/
/* termCloseWindow() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR termCloseWindow(VOID)
{
   if(IsWindowVisible(hTermWnd))
   {
      if(childZoomStatus(0x0001, 0) && (countChildWindows(FALSE) == 1))
      {
         childZoomStatus(0, 0x4000);
         ShowWindow(hTermWnd, SW_RESTORE);
      }
      /* added typecast to param 2 as HWND -sdj*/
      SetWindowPos(hTermWnd,(HWND) 1, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_HIDEWINDOW);
      selectTopWindow();                     /* mbbx 1.03 ... */
   }
}


/*---------------------------------------------------------------------------*/
/* termCloseFileInternal() -                                           [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR termCloseFileInternal(VOID)
{
   BOOL  termCloseFileInternal = TRUE;
   if(activTerm)
   {
      if(termData.flags & TF_NOCLOSE)        /* mbbx 1.01 */
      {
         termCloseFileInternal = FALSE;
      }
      else if(xferFlag != XFRNONE)
      {
         if(termCloseFileInternal = (TF_ErrProc(STR_STOPXFER, MB_YESNO | MB_ICONEXCLAMATION, 0) == IDYES))
         {
            xferBytes = 0;
            xferEndTimer = 0;
            xferWaitEcho = FALSE;
            xferStopped = TRUE;
            xferEnd();

         }
      }

      if(termCloseFileInternal)
      {
         if(termData.flags & TF_CHANGED)
         {
            switch(TF_ErrProc(STR_SAVECHANGES, MB_YESNOCANCEL | MB_ICONEXCLAMATION, 0))
            {
            case IDYES:
               termCloseFileInternal = termSaveFile(FALSE);    /* mbbx 2.00 */
               break;
            case IDCANCEL:
               termCloseFileInternal = FALSE;
               break;
            }
         }

         if(termCloseFileInternal)
	 {
            exitSerial();
            activTerm = FALSE;
         }
      }
   }

   return(termCloseFileInternal);
}


/*---------------------------------------------------------------------------*/
/* TF_ErrProc() -                                                            */
/*---------------------------------------------------------------------------*/

INT TF_ErrProc(WORD errMess, WORD errType,WORD  errCode)
{
   // sdj: was unref local - INT	result;
   //BYTE  temp1[PATHLEN]; /* rjs bugs 008 -> from 80 to 255 sdj:see below..*/
   BYTE  temp1[256];	 /* sdj: rjs just said it should be 255 but left it 80!*/
			   /* sdj: with PATHLEN as 80, LoadString was corrupting the */
			   /* sdj: stack with a err popup of invalid rcbfile */




   BYTE  temp2[80];


   GetWindowText(hItWnd, (LPSTR) temp2, 80);
   if(!strchr(temp2, '-'))
   {
      sprintf(temp1, " - %s", termData.title);
      strcpy(temp2+strlen(temp2), temp1);
   }

/* NOTE: some messages use taskState.result to pass fileName to error handler... */
   LoadString(hInst, errMess, (LPSTR) temp1, 255); /* rjs bugs 008 -> from 80 to 255 */

   MessageBeep(0);
   /* jtf 3.20 this was GetFocus() changed to GetActiveWindow() to stop rip */
   return(MessageBox(GetActiveWindow(), (LPSTR) temp1, (LPSTR) temp2, errType));
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/* SETTINGS FILE I/O ROUTINES                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* readTermSettings() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR readTermSettings(INT hFile, WORD fileSize)  /* mbbx 2.00: support NEW & OLD DCS and MS settings... */
//INT   hFile;
//WORD  fileSize;                              /* mbbx 2.00: was LONG */
{
   BOOL     readTermSettings = FALSE;
   HANDLE   hData;
   LPSTR    lpData;
   BOOL     flag; /* jtf 3.31 */

   flag = TRUE;   /* jtf 3.31 */

   if((hData = GlobalAlloc(GMEM_MOVEABLE, (DWORD) fileSize)) != NULL)
   {
      if((lpData = GlobalLock(hData)) != NULL)
      {

  /******** this was to debug the 4K trm file/struct compact bug
	    now we can avoid this noise on the debug machine, so
	    that we get the satisfaction of resolving one more bug(5399)!

  DbgPrint("sizeof (recTrm)                 = %lx\n",sizeof(trmParams));
  DbgPrint("Address of trmParams.fileID     = %lx\n",&(trmParams.fileID));
  DbgPrint("Address of trmParams.newDevRef  = %lx\n",&(trmParams.newDevRef));
  DbgPrint("Address of trmParams.speed      = %lx\n",&(trmParams.speed));
  DbgPrint("Address of trmParams.answerBack = %lx\n",&(trmParams.answerBack));
  DbgPrint("Address of trmParams.bufferLines= %lx\n",&(trmParams.bufferLines));
  DbgPrint("Address of trmParams.retryCt    = %lx\n",&(trmParams.retryCt));
  DbgPrint("Address of trmParams.xWrapCol   = %lx\n",&(trmParams.xWrapCol));
  DbgPrint("Address of trmParams.xLinStr    = %lx\n",&(trmParams.xLinStr));
  DbgPrint("Address of trmParams.phone      = %lx\n",&(trmParams.phone));
  DbgPrint("Address of trmParams.dialSuffix = %lx\n",&(trmParams.dialSuffix));


  **************/


         if(_read(hFile, lpData, fileSize) == fileSize)
         {
            readTermSettings = TRUE;         /* mbbx 2.00: read OLD DCS... */


            switch(fileSize)
            {
            case sizeof(recTrmParams):
               lmovmem(lpData, (LPBYTE) &trmParams, fileSize);
               break;
            case sizeof(MSSETTINGS):
               convertMSToIBM((LPMSSETTINGS) lpData, &trmParams);
               break;
            default:
               TF_ErrProc(STRFERRFILELENGTH, MB_OK | MB_ICONHAND, 999);
               flag = FALSE; /* jtf 3.31 */
               readTermSettings = FALSE;
               break;
            }
         }

         GlobalUnlock(hData);
      }

      GlobalFree(hData);
   }

   if ((!readTermSettings) && (flag))
      TF_ErrProc(STRFERRREAD, MB_OK | MB_ICONHAND, 999);

   return(readTermSettings);
}

/*---------------------------------------------------------------------------*/
/* convertMSToIBM() -                                                  [mbb] */
/*---------------------------------------------------------------------------*/

#define MS_HSSOFTWARE      0
#define MS_HSHARDWARE      1
#define MS_HSNONE          2

#define MS_IDS_NONE        0
#define MS_IDS_BRITISH     1
#define MS_IDS_DANISH      2
#define MS_IDS_FINNISH     3
#define MS_IDS_FRENCH      4
#define MS_IDS_CANADIAN    5
#define MS_IDS_GERMAN      6
#define MS_IDS_ITALIAN     7
#define MS_IDS_SPANISH     8
#define MS_IDS_SWEDISH     9
#define MS_IDS_SWISS       10

VOID NEAR convertMSToIBM(LPMSSETTINGS   lpMSSettings, recTrmParams   *ptrTrmParams)
{

   ptrTrmParams->outCRLF   = (BYTE) lpMSSettings->fNewLine;
   ptrTrmParams->localEcho = (BYTE) lpMSSettings->fLocalEcho;
   ptrTrmParams->lineWrap  = (BYTE) lpMSSettings->fAutoWrap;
   ptrTrmParams->bufferLines = lpMSSettings->clnBuf;   /* jtf term */

   ptrTrmParams->emulate = lpMSSettings->fVT52 ? ITMVT52 : ITMVT100;
   ptrTrmParams->speed = lpMSSettings->iBaud; /* jtf term */
   switch(lpMSSettings->iPort)               /* mbbx 2.00: network... */
   {
   case 0: /* jtf term */
   case 1:
      ptrTrmParams->comDevRef = ITMWINCOM;
      ptrTrmParams->comPortRef = ITMCOM1 + (lpMSSettings->iPort); /* jtf term */
      break;
   default:
      ptrTrmParams->comDevRef = ITMNOCOM;
      break;
   }

   switch(lpMSSettings->iByteSize)
   {
   case 4:
      ptrTrmParams->dataBits = ITMDATA4;
      break;
   case 5:
      ptrTrmParams->dataBits = ITMDATA5;
      break;
   case 6:
      ptrTrmParams->dataBits = ITMDATA6;
      break;
   case 7:
      ptrTrmParams->dataBits = ITMDATA7;
      break;
   default:
      ptrTrmParams->dataBits = ITMDATA8;
      break;
   }

   switch(lpMSSettings->iStopBits)
   {
   case ONE5STOPBITS:
      ptrTrmParams->stopBits = ITMSTOP5;
      break;
   case TWOSTOPBITS:
      ptrTrmParams->stopBits = ITMSTOP2;
      break;
   default:
      ptrTrmParams->stopBits = ITMSTOP1;
      break;
   }

   switch(lpMSSettings->iParity)
   {
   case EVENPARITY:
      ptrTrmParams->parity = ITMEVENPARITY;
      break;
   case ODDPARITY:
      ptrTrmParams->parity = ITMODDPARITY;
      break;
   case MARKPARITY:
      ptrTrmParams->parity = ITMMARKPARITY;
      break;
   case SPACEPARITY:
      ptrTrmParams->parity = ITMSPACEPARITY;
      break;
   default:
      ptrTrmParams->parity = ITMNOPARITY;
      break;
   }

   switch(lpMSSettings->iHandshake)
   {
   case MS_HSHARDWARE:
      ptrTrmParams->flowControl = ITMHARDFLOW;
      break;
   case MS_HSNONE:
      ptrTrmParams->flowControl = ITMNOFLOW;
      break;
   default:
      ptrTrmParams->flowControl = ITMXONFLOW;
      break;
   }

   ptrTrmParams->dlyRetry = (lpMSSettings->iAnswer + lpMSSettings->iToneWait);
   lstrcpy(ptrTrmParams->phone, lpMSSettings->szPhNum);

   switch(lpMSSettings->iCountry)
   {
   case MS_IDS_BRITISH:
      ptrTrmParams->language = ICS_BRITISH;
      break;
   case MS_IDS_GERMAN:
      ptrTrmParams->language = ICS_GERMAN;
      break;
   case MS_IDS_FRENCH:
      ptrTrmParams->language = ICS_FRENCH;
      break;
   case MS_IDS_SWEDISH:
      ptrTrmParams->language = ICS_SWEDISH;
      break;
   case MS_IDS_ITALIAN:
      ptrTrmParams->language = ICS_ITALIAN;
      break;
   case MS_IDS_SPANISH:
      ptrTrmParams->language = ICS_SPANISH;
      break;
   case MS_IDS_DANISH:
      ptrTrmParams->language = ICS_DANISH;
      break;
   case MS_IDS_FINNISH:
      ptrTrmParams->language = ICS_FINISH;
      break;
   case MS_IDS_CANADIAN:
      ptrTrmParams->language = ICS_CANADIAN;
      break;
   case MS_IDS_SWISS:
      ptrTrmParams->language = ICS_SWISS;
      break;
   default:
      ptrTrmParams->language = ICS_NONE;
      break;
   }
}


/*---------------------------------------------------------------------------*/
/* writeTermSettings() -                                               [scf] */
/*---------------------------------------------------------------------------*/

BOOL NEAR writeTermSettings(INT  fileHandle)
{
   BOOL        writeTermSettings = FALSE;
   HANDLE      hSettings;
   LPSETTINGS  lpSettings;

   if((hSettings = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(recTrmParams))) != NULL)
   {
      if(lpSettings = (LPSETTINGS) GlobalLock(hSettings))
      {
         lmovmem((LPBYTE) &trmParams, (LPBYTE) lpSettings, sizeof(recTrmParams));

         /* perform conversions here, if necessary... */

         if(_write(fileHandle, (LPSTR) lpSettings, sizeof(recTrmParams)) == sizeof(recTrmParams)) /* jtf 3.15 */
            writeTermSettings = TRUE;

         GlobalUnlock(hSettings);
      }

      GlobalFree(hSettings);
   }

   return(writeTermSettings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\textxfer.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "fileopen.h"
#include "task.h"


/*---------------------------------------------------------------------------*/
/* sndPre() -                                                                */
/*---------------------------------------------------------------------------*/

VOID sndPre(BYTE  *fileName, INT   actionString)
{
   showXferCtrls(IDSTOP | IDPAUSE | IDSCALE | IDSENDING);   /* mbbx 2.00: xfer ctrls... */
   showRXFname(fileName, actionString);
}


/*---------------------------------------------------------------------------*/
/* sndFileErr() -                                                            */
/*---------------------------------------------------------------------------*/

VOID sndFileErr(BYTE  *fileName, INT   wID)
{
   BYTE tmp1[TMPNSTR+1];

      LoadString(hInst, wID, tmp1, TMPNSTR);
      testMsg("%s %s", tmp1, fileName);
}


/*---------------------------------------------------------------------------*/
/* getSndTFile() -                                                           */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY FO_SendTextFile(HWND hDlg,UINT  message,WPARAM  wParam,LPARAM lParam)    /* mbbx 2.00: new FO hook scheme... */
{
   switch(message)
   {
   case WM_INITDIALOG:
      if(xferSndLF != 0)
         CheckDlgButton(hDlg, (xferSndLF > 0) ? FO_IDSNDLF : FO_IDSNDNOLF, TRUE);
      break;

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case FO_IDSNDLF:
         if(xferSndLF == -1)
            CheckDlgButton(hDlg, FO_IDSNDNOLF, FALSE);
         xferSndLF = ((xferSndLF == 1) ? 0 : 1);
         CheckDlgButton(hDlg, FO_IDSNDLF, xferSndLF);
         break;
      case FO_IDSNDNOLF:
         if(xferSndLF == 1)
            CheckDlgButton(hDlg, FO_IDSNDLF, FALSE);
         xferSndLF = ((xferSndLF == -1) ? 0 : -1);
         CheckDlgButton(hDlg, FO_IDSNDNOLF, xferSndLF);
         break;
      }
      break;
   }
    return FALSE;
}


BOOL getSndTFile(INT   actionString)
{
   BYTE        fileExt[FILENAMELEN+1];
   FSReply     reply;
   BYTE        szTitle[MINRESSTR];
   OFSTRUCT    file;

   DEBOUT("getSndTFile: %s\n","Got IN");
   getFileDocData(FILE_NDX_MEMO, reply.vRefNum, reply.fName, fileExt, NULL);  /* mbbx 1.03 */


   if(actionString == STR_VIEWING)
   {
      xferSndLF = 0;                      /* mbbx: WAS xferSndLF = TRUE; */
      LoadString(hInst, STR_VIEWTEXTFILE, szTitle, MINRESSTR);
   }
   else
   {
      xferSndLF = -1; /* jtf 3.22 */
      LoadString(hInst, STR_SENDTEXTFILE, szTitle, MINRESSTR);
   }

                                          /* mbbx 2.00: new FO hook scheme... */
   DEBOUT("getSndTFile: %s\n","Calling FileOpen");
   if(reply.vRefNum[strlen(reply.vRefNum) - 1] != '\\')
      strcat(reply.vRefNum, "\\");

   reply.good = FileOpen(reply.vRefNum, reply.fName, NULL, fileExt, szTitle,
                         FO_DBSNDTEXT, FO_SendTextFile, FO_FILEEXIST);

   if(reply.good)
   {
      DEBOUT("getSndTFile: %s\n","FileOpen reply was good");
      setFileDocData(FILE_NDX_MEMO, reply.vRefNum, reply.fName, fileExt, NULL);  /* mbbx 2.00: no forced extents */

      strcpy(xferVRefNum+1, reply.vRefNum);  /* mbbx 0.62: save the path !!! */
      *xferVRefNum = strlen(xferVRefNum+1);

      strcpy(xferFname+1, reply.fName);
      *xferFname = strlen(xferFname+1);
#ifdef ORGCODE
      strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
#else
      strcpy(reply.vRefNum+strlen(reply.vRefNum), "\\");
      strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
      DEBOUT("getSndTFile: opening the file[%s]\n",reply.vRefNum);
      DEBOUT("getSndTFile: with flags      [%lx]\n",O_RDONLY);

#endif
      /* jtf 3.20 */

      if((xferRefNo = OpenFile(reply.vRefNum, &file,
                               OF_READ)) == -1)
      {
	 //sndFileErr (STRFERROPEN, reply.fName); BUG:12588 args are swaped!
	 sndFileErr (reply.fName,STRFERROPEN);
         DEBOUT("getSndTFile: %s\n","Got OUT with FAIL(open)");
         return FALSE;
      }

      if ((xferBytes = fileLength (xferRefNo)) == -1l)
      {
	 //sndFileErr (STRFERRFILELENGTH, reply.fName); BUG:12588 args are swapped!
	 sndFileErr (reply.fName,STRFERRFILELENGTH);
         DEBOUT("getSndTFile: %s\n","Got OUT with FAIL(filelength)");
         return FALSE;
      }

      DEBOUT("getSndTFile: size of file put in xferBytes=%lx\n",xferBytes);
      xferOrig = xferBytes;
      xferPct = 0;
      sndPre(reply.fName, actionString);
      DEBOUT("getSndTFile: %s\n","Got OUT with success");
      return TRUE;
   }

   DEBOUT("getSndTFile: %s\n","Got OUT with FAIL(!reply.good)");
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* sndTfile() -                                                              */
/*---------------------------------------------------------------------------*/

VOID sndTFile ()
{
   xferFlag     = XFRNONE;
   xferPaused   = FALSE;
   xferTxtType  = (TTXTTYPE) (trmParams.xTxtType - ITMSTD);
   xferChrType  = (TCHRTYPE) (trmParams.xChrType - ITMCHRDELAY);
   xferLinType  = (TLINTYPE) (trmParams.xLinType - ITMLINDELAY);
   xferChrDelay = trmParams.xChrDelay;
   xferLinDelay = trmParams.xLinDelay;
   strcpy(xferLinStr+1, trmParams.xLinStr);
   xferLinStr[0] = strlen(trmParams.xLinStr);
   stripControl(xferLinStr);

   if(getSndTFile(STR_SENDING))
   {
      xferFlag  = XFRSND;
      *outBuf   = 0;                         /* (mbbx) clear out residuals */
      if(trmParams.xWordWrap)
      {
         outBufCol = 0;
         outBufSeq = FALSE;
         xferBlkSize = 1;                    /* (xmbb) */
      }
   }
}


/*---------------------------------------------------------------------------*/
/* typTFile() -                                                              */
/*---------------------------------------------------------------------------*/

VOID typTFile()
{
   xferFlag = XFRNONE;
   xferPaused = FALSE;
   xferStopped = FALSE;

   if(getSndTFile(STR_VIEWING))
   {
      xferFlag = XFRTYP;
      *outBuf  = 0;                          /* (mbbx) */
      if(trmParams.xWordWrap && (xferSndLF >= 0))     /* mbb?: wth??? */
      {
         outBufCol = 0;
         outBufSeq = FALSE;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* rcvErr() -                                                                */
/*---------------------------------------------------------------------------*/

VOID rcvErr(BYTE  *fileName)
{
   strcpy(taskState.string+1, fileName);
   *taskState.string = strlen(fileName);
   TF_ErrProc(STREWRERR, MB_OK | MB_ICONHAND, 999);

}


/*---------------------------------------------------------------------------*/
/* rcvPutFile() -                                                            */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY FO_RcvTextFile(HWND hDlg,UINT  message,WPARAM wParam,LPARAM lParam)  /* mbbx 2.00: new FO hook scheme... */
//HWND  hDlg;
//WORD  message;
//WPARAM wParam;
//LONG  lParam;
{
   switch(message)
   {
   case WM_INITDIALOG:
      xferAppend = FALSE;
      CheckDlgButton(hDlg, FO_IDCTRL, xferSaveCtlChr);
      CheckDlgButton(hDlg, FO_IDTABLE, xferTableSave);
      break;

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case FO_IDAPPEND:
         if(xferAppend = !xferAppend)
            pFOData->wMode |= FO_FILEEXIST;
         else
            pFOData->wMode &= ~FO_FILEEXIST;
         CheckDlgButton(hDlg, FO_IDAPPEND, xferAppend);
         break;
      case FO_IDCTRL:
         CheckDlgButton(hDlg, FO_IDCTRL, xferSaveCtlChr = !xferSaveCtlChr);
         break;
      case FO_IDTABLE:
         CheckDlgButton(hDlg, FO_IDTABLE, xferTableSave = !xferTableSave);
         break;
      }
      break;
   }
   return FALSE;
}


VOID rcvPutFile(FSReply *reply, BYTE *fileExt)
{
   *reply->fName = 0;                        /* mbbx 2.00: CUA */

                                             /* mbbx 2.00: new FO hook scheme... */
   if(reply->vRefNum[strlen(reply->vRefNum) - 1] != '\\')
      strcat(reply->vRefNum, "\\");

   reply->good = FileOpen(reply->vRefNum, reply->fName, NULL, fileExt, NULL, 
                          FO_DBRCVTEXT, FO_RcvTextFile, FO_PUTFILE);
}


/*---------------------------------------------------------------------------*/
/* rcvPre() - Show transfer control & set up for receiving text.[scf]        */
/*---------------------------------------------------------------------------*/

VOID rcvPre(BYTE *fileName, INT  actionString)
{
   xferFlag = XFRRCV;
   xferBytes = -1;                           /* Special flag to enable stop  */
   xferPaused = FALSE;                       /* button                       */
   xferLength = 0L;                          /* mbbx 2.00: mac */
   tblPos = TBLBEGINLINE;

   showXferCtrls(IDSTOP | IDPAUSE | IDSENDING);    /* mbbx 2.00: xfer ctrls... */
   showRXFname(fileName, actionString);

}


/*---------------------------------------------------------------------------*/
/* rcvTFile() -                                                              */
/*---------------------------------------------------------------------------*/

VOID rcvTFile()
{
   FSReply     reply;
   BYTE        fileExt[FILENAMELEN+1];
   OFSTRUCT    file;
   BYTE     OEMname[STR255];            /* jtf 3.20 */

   getFileDocData(FILE_NDX_MEMO, reply.vRefNum, NULL, fileExt, NULL);  /* mbbx 1.03 */

   xferSaveCtlChr = FALSE;
   xferTableSave  = FALSE;
   rcvPutFile(&reply, fileExt);

   if(reply.good)
   {
      setFileDocData(FILE_NDX_MEMO, reply.vRefNum, reply.fName, fileExt, NULL);  /* mbbx 2.00: no forced extents */

      strcpy(xferVRefNum+1, reply.vRefNum);  /* mbbx 0.62: save the path !!! */
      *xferVRefNum = strlen(xferVRefNum+1);

      strcpy(xferFname+1, reply.fName);
      *xferFname = strlen(xferFname+1);
#ifdef ORGCODE
      strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
#else
      strcpy(reply.vRefNum+strlen(reply.vRefNum), "\\");
      strcpy(reply.vRefNum+strlen(reply.vRefNum), reply.fName);
#endif

      // JYF -- replace below two lines with the following if ()
      //        to remove the use of AnsiToOem()
      //
      //AnsiToOem(reply.vRefNum, OEMname); /* jtf 3.20 */
      //if(xferAppend && fileExist(OEMname))

      if (xferAppend && fileExist((LPSTR)reply.vRefNum))
      {
         /* jtf 3.20 */
         DEBOUT("rcvTFile: doing open(%s)\n",reply.vRefNum);
         DEBOUT("rcvTFile: with flag [%lx]\n",O_WRONLY);

         if((xferRefNo = OpenFile(reply.vRefNum, 
                                  &file, 
                                  OF_WRITE | OF_CANCEL)) == -1)
         {
            rcvErr(reply.fName);
            return;
         }
         _lseek(xferRefNo, 0L, 2);
      }
      else
      {
         /* jtf 3.20 */
         DEBOUT("rcvTFile: doing open(%s)\n",reply.vRefNum);
         DEBOUT("rcvTFile: with flag [%lx]\n",O_WRONLY|O_CREAT|O_TRUNC|S_IWRITE);

         if((xferRefNo = OpenFile(reply.vRefNum, 
                                  &file, 
                                  OF_WRITE | OF_CREATE)) == -1)
         {
            rcvErr(reply.fName);
            return;
         }
      }

      xferBufferCount = 0;                                           /* rjs bugs 016 */
      xferBufferHandle = GlobalAlloc(GMEM_MOVEABLE, (DWORD) 1024);   /* rjs bugs 016 */
      rcvPre(reply.fName, STR_RECEIVING);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\tskctrl.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"


/*****************************************************************************/
/* taskInit() -                                                              */
/*****************************************************************************/

VOID taskInit()
{
   kbdLock = KBD_UNLOCK;                     /* should be part of taskState */
   memcpy(taskState.string, NULL_STR, 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\trmspcl.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"

/*---------------------------------------------------------------------------*/
/* getScrCh() -                                                         [scf]*/
/*---------------------------------------------------------------------------*/

BOOL getScrCh ()
{
   BOOL result;

   if (textIndex < textLength)
   {
      rdCH[1] = textPtr[textIndex];
      textIndex++;
      result = TRUE;
   }
   else
      result = FALSE;
   return TRUE;
}


/*---------------------------------------------------------------------------*/
/* stripLeadingSpaces() -                                               [scf]*/
/*---------------------------------------------------------------------------*/

VOID stripLeadingSpaces ()
{
   INT  i;
   BYTE whiteSpace[20];

   sprintf (whiteSpace," %c%c",CHFILL,TAB);
   i = outBuf[0] - 1;
   while (strchr (whiteSpace, outBuf[i]))
   {
      outBuf[i] = CR;
      outBuf[0]--;
      i--;
   }
}


/*---------------------------------------------------------------------------*/
/* getChxmit() - Get xmit char. from clipBoard or file.                 [scf]*/
/*---------------------------------------------------------------------------*/

BOOL getChxmit()
{
   BOOL     result = FALSE;
   INT      err;
   STRING   str[2];
   BYTE     whiteSpace[20];
   DWORD    charsRead;

   if(!trmParams.xWordWrap || (xferFlag == XFRTYP) || (scrapSeq && copiedTable))
   {
      if(scrapSeq)
      {
         if(getScrCh())
            result = TRUE;
      }
      else
      {
         charsRead = _lread((int)xferRefNo, (LPSTR)(&rdCH[1]), ioCnt);
         if(charsRead == (DWORD)ioCnt)
            result = TRUE;
         else if(charsRead != 0)
         {
            if(charsRead != (DWORD)-1)
               charsRead = 0;
            else
               result = TRUE;
         }
         else
            result = FALSE;
      }
      outBufSeq = FALSE;
      return(result);
   }

   if(!outBufSeq)
   {
      repeat
      {
         if(scrapSeq)
         {
            if(getScrCh())
               err = ioCnt;
            else
               err = ioCnt + 1;
         }
         else
         {
            err = _lread(xferRefNo, (LPSTR)(&rdCH[1]), ioCnt);
         }

         if(err == ioCnt)
         {
            str[0] = 0x01; str[1] = rdCH[1];
            concat (outBuf, str, outBuf);
            outBufCol++;
            if (rdCH[1] == CR)
               outBufCol = 0;
            else if (rdCH[1] == LF)
               outBufCol--;
            else if(outBufCol > trmParams.xWrapCol) /* WRN as outBufCol is BOOL*/
            {                                       /* and xWrapCol is INT */
               xferBytes++;
               str[1] = LF;
               concat (outBuf, outBuf, str);
               xferBytes++;
               str[1] = CR;
               concat (outBuf, outBuf, str);
               outBufSeq = TRUE;
               stripLeadingSpaces ();
               outBufCol = (INT) outBuf[0];
            }
            sprintf(whiteSpace," %c%c%c%c",TAB,CHFILL,CR,LF);
            if (strchr(whiteSpace,rdCH[1]))
               outBufSeq = TRUE;
         }
         else
            if (*outBuf == 0)
               return result;
            else
               outBufSeq = TRUE;
      }
      until(outBufSeq);
   }

   if(outBufSeq)
   {
      ioCnt = 1;
      result = TRUE;
      rdCH[1] = outBuf[outBuf[0]];
      if (*outBuf > 1)
         outBuf[0]--;
      else
      {
         outBufSeq = FALSE;
         outBuf[0] = 0;
      }
   }

   return(result);
}


/*---------------------------------------------------------------------------*/
/* xferFile() - Transfer & Receive text file handling.           [scf] [mbb] */
/*---------------------------------------------------------------------------*/

/* NOTE: xferFile no longer masks off the high order bit of the
   chars sent -- I don't see how they could have gotten SET in the first place
   whether they came from a file or the clipboard. [mbbx 1.02] */

VOID xferFile()
{
   BOOL  breakXfer;
   int   ndx;

   breakXfer = (xferPaused || xferStopped);

   if(xferEndTimer > 0)
      if(xferEndTimer > tickCount())  /* WRN xferEndTimer is LONG and */
         breakXfer = TRUE;            /* and GetCurrentTime returns DWORD*/
      else                            /* but was same in 3.0 too -sdj */
         xferEndTimer = 0;

   if(xferWaitEcho)
      breakXfer = TRUE;


   while(!breakXfer)
   {
      rxEventLoop();

      ioCnt = 1;

      if((xferViewPause == 0) &&             /* mbbx: auto line count */
         (((xferFlag == XFRTYP) ) || 
          ((xferFlag == XFRSND) && !trmParams.xWordWrap &&     /* mbbx 1.03: lineWrap -> xWordWrap */
           (xferTxtType == XFRNORMAL))))
      {
         if((ioCnt = YIELDCHARS) > xferBytes)
            ioCnt = xferBytes;
      }

      if(xferBytes > 0)
      {
         if(getChxmit())
         {
            for(ndx = 1; ndx <= ioCnt; ndx++)
            {
                                             /* mbbx 1.10: set rdCh[0] to LF if appending LF's... */
               if(((theChar = rdCH[ndx]) != CR) || (rdCH[0] != CR))  /* mbbx 1.02: CR CR LF -> CR */
               {
                  rdCH[0] = theChar;         /* mbbx 1.02: save char... */

                  if((theChar != LF) || (xferSndLF != -1))  /* mbbx: strip LF's */
                  {
                     if(xferFlag == XFRTYP)
                        modemInp(theChar, FALSE);
                     else
                        modemWr(theChar);
                  }

                  if (xferStopped) 
                     break; /* jtf 3.30 */

                  if(((theChar == CR) && (xferSndLF != 0)) || ((theChar == LF) && (xferSndLF == 0)))
                  {
                     if(xferSndLF == 1)                    /* mbbx: append LF's */
                     {
                        if(xferFlag == XFRTYP)
                           modemInp(LF, FALSE);
                        else
                           modemWr(LF);
                        rdCH[0] = LF;        /* mbbx 1.10: last char sent = LF */
                     }

                     if(xferViewPause > 0)
                     {
                        if(++xferViewLine >= xferViewPause)
                        {
                           xferViewLine = 0;
                           termCleanUp();
                           xferPauseResume(TRUE, FALSE);    /* mbbx 2.00: xfer ctrls... */
                        }
                     }
                  }
               }
               else
                  theChar = 0;               /* mbbx 1.10: avoid 2 line waits on CR CR LF */

               xferBytes -= 1;
               if(!scrapSeq)
                  updateProgress(FALSE);
            }
         }
         else
            xferBytes = 0;
      }

      if((theChar == CR) || (xferBytes == 0) || (ioCnt > 1) || xferPaused ||
         (xferTxtType == XFRCHAR) || scrapSeq)
         break;                              /* mbbx: DO NOT set breakXfer !!! */
   }

   if(xferBytes == 0)
   {
      if(scrapSeq)
      {
         scrapSeq = FALSE;
         GlobalUnlock(tEScrapHandle);
         tEScrapHandle = GlobalFree(tEScrapHandle);
         if(!IsIconic(hItWnd))
            SetCursor(LoadCursor(NULL, IDC_ARROW));
         xferBytes = 1L; /* Need so pasting during a Rcv. Text doesn't terminate */
      }
      else
      {
         termCleanUp();                      /* mbbx: finish term update */
         xferEnd();
      }
   }

   if(((xferFlag == XFRSND) || scrapSeq) && !breakXfer)
   {
      if(xferTxtType == XFRCHAR)
      {
         if(xferChrType == XFRCHRDELAY)
            xferEndTimer = tickCount() + (xferChrDelay * 6);
         else
         {
            xferWaitEcho = TRUE;
            xferCharEcho = theChar; /* jtf 3.30 allow ansi text & 0x7f; */
         }
      }
      else if((xferTxtType == XFRLINE) && (theChar == CR))
      {
         if (xferLinType == XFRLINDELAY)
            xferEndTimer = tickCount() + (xferLinDelay * 6);
         else
            xferWaitEcho = TRUE;
      }
   }
}


/*---------------------------------------------------------------------------*/
/* termSpecial() -                                                      [scf]*/
/*---------------------------------------------------------------------------*/

VOID termSpecial()
{
   RECT     buttonRect;
   HDC      hButtonDC;
   BOOL     breakTerm;
   BOOL     breakKey;  /* jtf 3.20 */
                                             /* mbbx: these WERE static vars */
   STRING   execStr[STR255];
   INT      execNdx;
   INT      brkLen;
   LONG     finalTicks;

   breakKey  = FALSE;  /* jtf 3.20 */
   breakTerm = FALSE;

   if(useScrap)
   {
      if((textPtr = GlobalLock (tEScrapHandle)) != NULL)
         xferBytes = textLength = (LONG) lstrlen(textPtr);
      else
         xferBytes = textLength = 0;

      textIndex  = 0;
      useScrap   = FALSE;
      scrapSeq   = TRUE;
      xferSndLF  = (trmParams.outCRLF ? 0 : -1);   /* mbbx 1.10: CUA */
      *outBuf    = 0;

      if(trmParams.xWordWrap && !copiedTable)
      {
         outBufCol   = 0;
         outBufSeq   = FALSE;
         xferBlkSize = 1;
      }

      xferTxtType  = (TTXTTYPE) (trmParams.xTxtType - ITMSTD);
      xferChrType  = (TCHRTYPE) (trmParams.xChrType - ITMCHRDELAY);
      xferLinType  = (TLINTYPE) (trmParams.xLinType - ITMLINDELAY);
      xferChrDelay = trmParams.xChrDelay;
      xferLinDelay = trmParams.xLinDelay;
      if (!IsIconic (hItWnd))
         SetCursor (LoadCursor (NULL, IDC_WAIT));
   }
  /* WRN fKeyNdx is INT and *fKeyStr is BYTE -sdj */
   if(fKeyNdx <= *fKeyStr)                   /* mbbx 2.00: dc terminal... */
   {
      if((theChar = fKeyStr[fKeyNdx++]) == '^')
      {
         if((fKeyNdx <= *fKeyStr) && ((theChar = fKeyStr[fKeyNdx++]) == '$'))
            theChar = 0xFF;
         else if(theChar != '^')
         {
            if(theChar == '~')
               theChar = '^';                /* NOTE: must use ^~ to send 0x1E */

            if(((theChar >= 'A') && (theChar <= '_')) || ((theChar >= 'a') && (theChar <= 'z')))
               theChar &= 0x1F;
            else
               theChar = fKeyStr[(--fKeyNdx)-1];
         }
      }

      if(theChar != 0xFF)
      {
         sendKeyInput(theChar);              /* mbbx: per slc request */

      }
      else                                   /* special ctrl strings... */
      {
         if(((theChar = fKeyStr[fKeyNdx++]) >= 'a') && (theChar <= 'z'))
            theChar -= 0x20;

         while((fKeyNdx <= *fKeyStr) && (fKeyStr[fKeyNdx] == ' '))
            fKeyNdx++;

         switch(theChar)
         {
         case 'L':                           /* ^$L - level */
            setFKeyLevel(fKeyStr[fKeyNdx++] - '0', FALSE);  /* mbbx 2.00: bReset */
            break;

         case 'C':                           /* mbbx 2.00: ^$C - call... */
            dialPhone();
            break;
         case 'H':                           /* mbbx 2.00: ^$H - hangup... */
            hangUpPhone();
            break;

         case 'B':                           /* ^$B - break */
            breakKey = TRUE;   /* jtf 3.20 */
         case 'D':                           /* mbbx 1.04: ^$D - delay */
            brkLen = 2;
            if(((theChar = fKeyStr[fKeyNdx]) >= '0') && (theChar <= '9'))
            {
               brkLen = theChar - '0';
               if(((theChar = fKeyStr[++fKeyNdx]) >= '0') && (theChar <= '9'))
               {
                  fKeyNdx += 1;
                  brkLen = (brkLen * 10) + (theChar - '0');
               }
            }

            if(breakKey)   /* jtf 3.20 */
               modemSendBreak(brkLen);
            else
               delay(brkLen*60, &finalTicks);   /* mbbx 1.04: ^$D <secs> */
            break;
         }
      }
   }

   if(!breakTerm)
   {
      switch(xferFlag)
      {
      case XFRSND:
      case XFRTYP:
         if(!gbXferActive)
         {
            gbXferActive = TRUE;
            xferFile();
            gbXferActive = FALSE;
         }
         break;
      case XFRRCV:
         if(!gbXferActive)
         {
            gbXferActive = TRUE;
            if(xferBytes == 0)                  /* stop button was clicked */
               xferEnd();
            gbXferActive = FALSE;
         }
         break;
      default:
         if(!gbXferActive)
         {
            gbXferActive = TRUE;
            if(scrapSeq)
               xferFile();
            gbXferActive = FALSE;
         }
         break;
      }
   }

   if(!breakTerm)
      rdModem(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\terminal.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define  NOGDICAPMASKS     TRUE
#define  NOVIRTUALKEYCODES TRUE
#define  NOICONS	         TRUE
#define  NOKEYSTATES       TRUE
#define  NOSYSCOMMANDS     TRUE
#define  NOATOM	         TRUE
#define  NOCLIPBOARD       TRUE
#define  NODRAWTEXT	      TRUE
#define  NOMINMAX	         TRUE
#define  NOOPENFILE	      TRUE
#define  NOSCROLL	         TRUE
#define  NOHELP            TRUE
#define  NOPROFILER	      TRUE
#define  NODEFERWINDOWPOS  TRUE
#define  NOPEN             TRUE
#define  NO_TASK_DEFINES   TRUE
#define  NOLSTRING         TRUE
#define  WIN31

#include <stdlib.h>       /* adding for _searchenv and exit crt -sdj*/
#include <windows.h>
#include <port1632.h>
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "video.h"                           /* mbbx 1.04: per jtfx 1.1 */
#include <ctype.h>

VOID NEAR PASCAL DestroyWindows()
{
   if(hdbmyControls)
      DestroyWindow(hdbmyControls);
   if(hdbXferCtrls)
      DestroyWindow(hdbXferCtrls);
   if(hTermWnd)
      DestroyWindow(hTermWnd);
}

/*---------------------------------------------------------------------------*/
/* WinMain() - entry point from Windows                                [mbb] */
/*---------------------------------------------------------------------------*/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, INT cmdShow)
{
   CHAR  errmsg[115],caption[18];
   VOID  (APIENTRY *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
   // -sdj was unreferenced local var: DWORD tickCount;

   readDateTime(startTimer);      

   trmParams.comDevRef = ITMNOCOM;

   if(!initConnectors(TRUE))      
      return (FALSE);

   /* Added 02/2591 w-dougw  check that all windows are created. */
   if(!initWindows(hInstance, hPrevInstance, cmdShow))
   {
      LoadString(hInstance,STR_ERRCAPTION,caption,sizeof(caption));
      LoadString(hInstance,STR_OUTOFMEMORY,errmsg,79);
      MessageBox(NULL,errmsg,caption,MB_ICONHAND|MB_SYSTEMMODAL);
      return(FALSE);
   }
   initDialogs();
   if(!setup())
   {
      LoadString(hInstance,STR_ERRCAPTION,caption,sizeof(caption));
      LoadString(hInstance,STR_OUTOFMEMORY,errmsg,79);
      MessageBox(NULL,errmsg,caption,MB_ICONHAND|MB_SYSTEMMODAL);
      return(FALSE);  
   }
   DEBOUT("Calling: %s\n","readCmdLine()");
   readCmdLine(lpszCmdLine);                 /* mbbx 2.00 ... */
   DEBOUT("Outof: %s\n","readCmdLine()");

   DEBOUT("Calling: %s\n","PrintFileInit()");
   PrintFileInit(); /* jtfterm */
   DEBOUT("Outof: %s\n","PrintFileInit()");

   /* Register as a good little pen-windows app
    */
   /* NOTE**** have to confirm that this is the way to go GetSystemMet RC-sdj*/
   /* added typecasting of (HANDLE) to param 1 */
   if (lpfnRegisterPenApp = (VOID *)GetProcAddress(IntToPtr(GetSystemMetrics(SM_PENWINDOWS)),
         "RegisterPenApp"))
       (*lpfnRegisterPenApp)(1, TRUE);

   DEBOUT("Calling: %s\n","mainProcess()");
   mainProcess();                            /* now load _WINMAIN segment */
   DEBOUT("Outof: %s\n","mainProcess()");

   /* Make sure to de-register if you register
    */
   if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)(1, FALSE);

   PrintFileShutDown(); /* jtfterm */

   DestroyWindow(hdbXferCtrls);        /* rjs swat */
   DestroyWindow(hdbmyControls);       /* jtf 3.33 */
   DestroyWindow(hItWnd);              /* rjs swat */

   freeItResources();

   exit((int)msg.wParam);
/*ExitProcess((DWORD)msg.wParam);  should this be used instead of exit()?-sdj*/
}


/* was
BOOL registerIt(hInstance)
HANDLE   hInstance;
*/


/*---------------------------------------------------------------------------*/
/* initWndClass() -                                                    [mbb] */
/*---------------------------------------------------------------------------*/

BOOL initWndClass()                          /* mbbx 1.04 ... */
{
   WNDCLASS    wndClass;

   wndClass.style          = CS_HREDRAW | CS_VREDRAW;
   wndClass.lpfnWndProc    = DC_WndProc;
   wndClass.cbClsExtra     = 0;
   wndClass.cbWndExtra     = 0;
   wndClass.hInstance      = hInst;
   wndClass.hIcon          = (HICON) NULL; 
   wndClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wndClass.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE+1);    /* mbbx 2.00 ... */
   wndClass.lpszMenuName   = (LPSTR) szAppName_private;
   wndClass.lpszClassName  = (LPSTR) szAppName_private;

   if(!RegisterClass((LPWNDCLASS) &wndClass))   /* register DYNACOMM class */
      return(FALSE);

   wndClass.style          = CS_DBLCLKS; /* jtf 3.21 | CS_HREDRAW | CS_VREDRAW; */
   wndClass.lpfnWndProc    = TF_WndProc;
   wndClass.hIcon          = (HICON) NULL;
   wndClass.hCursor        = LoadCursor(NULL, IDC_IBEAM);
   wndClass.hbrBackground  = (HBRUSH) NULL;
   wndClass.lpszMenuName   = (LPSTR) NULL;
   wndClass.lpszClassName  = (LPSTR) DC_WNDCLASS;

   if(!RegisterClass((LPWNDCLASS) &wndClass))   /* register TERMINAL class */
      return(FALSE);

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* initPort () - Initialize hTE text rectangles  and init thePort            */
/* thePort is always 0 or an active DC of hTermWnd                           */
/* portLocks is count of number of un'releasePort'ed getPort calls           */

extern BOOL insertionPoint;

VOID initPort ()
{
   insertionPoint = TRUE;
   thePort   = 0;
   portLocks = 0;
   hTE.active = TRUE;
   hTE.selStart = hTE.selEnd = MAXROWCOL;

   /* Added 02/22/91 for win 3.1 common dialog interface */
   hDevNames = NULL;
   hDevMode  = NULL;
}


/*---------------------------------------------------------------------------*/
/* initIcon()                                                                */
/*---------------------------------------------------------------------------*/

VOID initIcon()
{
   // -sdj was unreferenced var:  CHAR	temp[10];

   icon.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(ICO_DYNACOMM));

   icon.flash = FALSE;

   icon.dx = GetSystemMetrics(SM_CXICON)/16;
   icon.dy = GetSystemMetrics(SM_CYICON)/16;

}



/*---------------------------------------------------------------------------*/
/* createWindows() - Determine tube size and create all Windows.             */
/*---------------------------------------------------------------------------*/

BOOL createWindows(INT   cmdShow)
{
   INT      ndx;
   // -sdj was unreferenced local var: HMENU	hSysMenu;
   BYTE     work[80]; // -sdj was unrefenced var: , work1[80], work2[80];

   LoadString(hInst, STR_APPNAME, (LPSTR) work, MINRESSTR);
   strcpy(work+strlen(work), " - ");
   LoadString(hInst, STR_TERMINAL, (LPSTR) work+strlen(work), MINRESSTR);

   //sdj: using the values from the registry instead of hardcoding it

   if(!(hItWnd = CreateWindow((LPSTR) szAppName_private,
                         (LPSTR) work,
                         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
			 WindowXPosition,
			 WindowYPosition,
			 WindowWidth,
			 WindowHeight, // was hardcoded to: 10,10,400,400, win31:CW_USEDEFAULT, 0, CW_USEDEFAULT, 0
                         (HWND) NULL,
                         (HMENU) NULL,
                         (HANDLE) hInst,
                         (LPSTR) NULL)))
	return(FALSE);

   LoadString(hInst, STR_INI_MAXIMIZED, (LPSTR) work, MINRESSTR);
   if(!GetProfileInt((LPSTR) szAppName_private, (LPSTR) work, 0) || 
      (cmdShow == SW_SHOWMINNOACTIVE) || (cmdShow == SW_SHOWMINIMIZED) || (cmdShow == SW_MINIMIZE))
   {
      ShowWindow(hItWnd, cmdShow);
   }
   else
      ShowWindow(hItWnd, SW_SHOWMAXIMIZED);

   if(!(hdbmyControls = CreateDialog(hInst, getResId(IDDBMYCONTROLS), 
    hItWnd, dbmyControls)))
      return(FALSE);
   for(ndx = 0; ndx < DCS_NUMFKEYS; ndx += 1)   /* mbbx 2.00: moved from hidemyControls... */
   {
      fKeyHandles[ndx] = GetDlgItem(hdbmyControls, IDFK1 + ndx);
      DEBOUT("createWindows: fKeyHandles[]=%lx from GetDlgItem()\n",fKeyHandles[ndx]);
   }
   LoadString(hInst, STR_TERMINAL, (LPSTR) work, MINRESSTR);
   if(!(hTermWnd = CreateWindow((LPSTR) DC_WNDCLASS,
                           (LPSTR) work,
                           /* Removed WS_THICKFRAME jtf 3.21 */
                           WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_CLIPSIBLINGS | CS_BYTEALIGNWINDOW,
                           0, 0, 0, 0,
                           hItWnd,
                           (HMENU) NULL,
                           (HANDLE) hInst,
                           (LPSTR) NULL))) 
	return(FALSE);


   if(!(hdbXferCtrls = CreateDialog(hInst, getResId(IDDBXFERCTRLS),
                                    hTermWnd, dbmyControls)))
   {
	return(FALSE);
   }

	/* mbbx 1.04 */
   xferCtlStop = GetDlgItem(hdbXferCtrls, IDSTOP);    /* mbbx 2.00: moved from hidemyControls()... */
   xferCtlPause = GetDlgItem(hdbXferCtrls, IDPAUSE);
   xferCtlScale = GetDlgItem(hdbXferCtrls, IDSCALE);
   showXferCtrls(0);
}


/*---------------------------------------------------------------------------*/
/* sizeWindows() -                                                           */
/*---------------------------------------------------------------------------*/

VOID sizeWindows()
{
   RECT  fKeysRect;
   RECT  ctrlsRect;
   RECT  termRect;

   setDefaultFonts();

   GetWindowRect(hdbmyControls, &fKeysRect);
   GetWindowRect(fKeyHandles[0], &ctrlsRect);   /* mbbx 2.00: fkeys... */
   MoveWindow(hdbmyControls, 0, fKeysRect.top, fKeysRect.right, 
              fKeysHeight = ((ctrlsRect.bottom - ctrlsRect.top) * 2), FALSE);

   GetClientRect(hItWnd, &fKeysRect);  /* mbbx 2.00: may not init maximized... */
   sizeFkeys(MAKELONG(fKeysRect.right, fKeysRect.bottom));


   GetWindowRect(hdbXferCtrls, &ctrlsRect);  /* mbbx 1.04: fkeys... */
   ctrlsHeight = ctrlsRect.bottom - ctrlsRect.top;

   initChildSize(&termRect);
   MoveWindow(hTermWnd, 0, 0, termRect.right, termRect.bottom, FALSE); /* jtf 3.21 */
}
/*---------------------------------------------------------------------------*/
/* initWindows() -                                                           */
/*---------------------------------------------------------------------------*/

BOOL initWindows(HANDLE   hInstance, HANDLE   hPrevInstance, INT      cmdShow)
{

   BYTE     str[MINRESSTR];

   hInst = hInstance;

   /* Added 02/26/91 for window existence */
   hItWnd = NULL;
   hdbmyControls = NULL;
   hTermWnd = NULL;
   hdbXferCtrls = NULL;
   hEdit = NULL;
   fKeyHdl = NULL;

   LoadString(hInst, STR_APPNAME_PRIVATE, (LPSTR) szAppName_private, 20);
   LoadString(hInst, STR_APPNAME, (LPSTR) szAppName, 20);
   LoadString(hInst, STR_DEVELOPER, (LPSTR) szMessage, 80);
   LoadString(hInst, STR_NOMEMORY,(LPSTR)NoMemStr,sizeof(NoMemStr)); /* rjs msoft ??? */


   //sdj: lets try and see if the x,y,width,height are in the win.ini
   //sdj: if so use them and save the values in the global variables
   //sdj: so that these can be used by the createwindow call during init
   //sdj: and can be saved using getwindowrect just before the user exits
   //sdj: the terminal app.

   //sdj: defaults are	 10,10,400,400. win31 had: CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,

   LoadString(hInst, STR_INI_XPOSITION, (LPSTR) str, MINRESSTR);
   WindowXPosition = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 10);

   LoadString(hInst, STR_INI_YPOSITION, (LPSTR) str, MINRESSTR);
   WindowYPosition = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 10);

   LoadString(hInst, STR_INI_WIDTH, (LPSTR) str, MINRESSTR);
   WindowWidth = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 400);

   LoadString(hInst, STR_INI_HEIGHT, (LPSTR) str, MINRESSTR);
   WindowHeight = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 400);




   setDefaultAttrib(TRUE);                   /* mbbx 1.04: ...szAppName loaded */

   if(!hPrevInstance)
   {
      if(!initWndClass())                    /* mbbx 1.04 ... */
          return(FALSE);
   }

   initPort();
   initIcon();

   theBrush   = GetStockObject (WHITE_BRUSH);
   blackBrush = GetStockObject (BLACK_BRUSH);

   if(!createWindows(cmdShow))
     return(FALSE);

   sizeWindows();

   maxScreenLine = MAXSCREENLINE;            /* rjs moved from size windows */

   hMenu = GetMenu(hItWnd);

   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* initDialogs() - Do all dialogbox initialization. [scf]                    */
/*---------------------------------------------------------------------------*/

VOID initDialogs()                           /* mbbx: remove ALL of these... */
{
}


/*---------------------------------------------------------------------------*/
/* dbPortInit() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

INT_PTR APIENTRY dbPortInit(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef WIN32
   WORD	temp_wParam;	
#endif

   switch(message)
   {
   case WM_INITDIALOG:
      initDlgPos(hDlg);
      initComDevSelect(hDlg, ITMCONNECTOR, TRUE);
      return(TRUE);

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         break;

      case ITMCONNECTOR:
         if(GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
            break;
         return(TRUE);
      }
      break;

   default:
      return(FALSE);
   }

   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, &trmParams.newDevRef);
   trmParams.fResetDevice = TRUE;
#ifdef WIN32
   /* code in next block passes address of wParam to function*/
   /* so we pass temp variable instead, since we need extract ID from wParam under WIN32*/
   temp_wParam = GET_WM_COMMAND_ID(wParam, lParam);
#endif

#ifdef ORGCODE
   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &wParam);
#else
   trmParams.comPortRef = getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &temp_wParam);
#endif
   resetSerial(&trmParams, TRUE, TRUE, FALSE);   /* slc swat */

   if(trmParams.comDevRef != trmParams.newDevRef)
   {
      exitSerial();
      return(TRUE);
   }
   exitSerial();

#ifdef ORGCODE
   EndDialog(hDlg, (INT) getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &wParam));
#else
   if (!(getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &temp_wParam)))
    {
    EndDialog(hDlg,TRUE);
    }
   else{
    EndDialog(hDlg, (INT) getComDevSelect(hDlg, ITMCONNECTOR, (BYTE *) &temp_wParam));
       }
#endif
   return(TRUE);
}


/*---------------------------------------------------------------------------*/
/* setProfileExtent() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

/* mbbx: 1.01 - moved from itutil1.c */

BOOL NEAR setProfileExtent(BYTE  *section, BYTE  *extent)
{
   BOOL  setProfileExtent = FALSE;
   BYTE  str[80];
   BYTE  temp[80];

   if(!GetProfileString((LPSTR) section, (LPSTR) extent, (LPSTR) NULL_STR, (LPSTR) temp, 80))
   {
      strcpy(temp, extent);
      AnsiLower((LPSTR) temp);
      sprintf(str, "%s.exe ^.%s", szAppName_private, temp);
      AnsiLower((LPSTR) str);
      WriteProfileString((LPSTR) section, (LPSTR) temp, (LPSTR) str);
      setProfileExtent = TRUE;
   }

   return(setProfileExtent);
}


/*---------------------------------------------------------------------------*/
/* initFileDocData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR initFileDocData(FILEDOCTYPE fileType, WORD strResID,BYTE  *fileExt,BYTE *szSection)   /* mbbx 2.00 ... */
{
   BYTE  work1[MINRESSTR], work2[80];

   LoadString(hInst, strResID, (LPSTR) work1, MINRESSTR);
   GetProfileString((LPSTR) szAppName_private, (LPSTR) work1, (LPSTR) NULL_STR, (LPSTR) work2, 80);

   getDataPath(fileType, fileDocData[fileType].filePath, work2);

   strcpy(fileDocData[fileType].fileExt, fileExt);
   if(!getFileType(work2, fileDocData[fileType].fileExt))
      strcpy(work2, fileDocData[fileType].fileExt);

   strcpy(fileDocData[fileType].fileName, fileDocData[fileType].fileExt+1);

   if(work2[strlen(work2)-1] != '*')
      return(setProfileExtent(szSection, fileDocData[fileType].fileExt+3));

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* initProfileData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

#define DEFBUFFERLINES           100         /* mbbx 1.10... */

VOID initProfileData()                       /* mbbx: 1.01 ... */
{
   BYTE     str[MINRESSTR], str2[MINRESSTR], portName[16];
   INT      ndx;
   // -sdj eas unreferenced local var: FARPROC	lpdbPortInit;
   BOOL     notify;

   LoadString(hInst, STR_INI_PORT, (LPSTR) str, MINRESSTR);
   if(!GetProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) NULL_STR, (LPSTR) portName, 5))
   {
      trmParams.comDevRef = ITMNOCOM;        /* jtf 3.33 */
      trmParams.speed     = 1200;            /* jtf 3.33 */
      trmParams.dataBits  = ITMDATA8;        /* jtf 3.33 */
      trmParams.stopBits  = ITMSTOP1;        /* jtf 3.33 */
      trmParams.parity    = ITMNOPARITY;     /* jtf 3.33 */
      if((ndx = doSettings(IDDBPORTINIT, dbPortInit)) != -1)   /* mbbx 2.01.10 ... */
      {
         LoadString(hInst, (ndx > 0) ? STR_COM : STR_COM_CONNECT, (LPSTR) str2, MINRESSTR);
         sprintf(portName, str2, ndx);
         WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) portName);
      }
   }


   LoadString(hInst, STR_INI_SWAP, (LPSTR) str, MINRESSTR);
   if((ndx = GetProfileInt((LPSTR) szAppName_private, (LPSTR) str, 0)) > 0)
      *taskState.string = (BYTE)sprintf(taskState.string+1, "%d", SetSwapAreaSize(ndx));

   LoadString(hInst, STR_INI_INTL, (LPSTR) str, MINRESSTR);
   LoadString(hInst, STR_INI_IDATE, (LPSTR) str2, MINRESSTR);
   intlData.iDate = GetProfileInt((LPSTR) str, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_SDATE, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "/", (LPSTR) intlData.sDate, 2);
   LoadString(hInst, STR_INI_ITIME, (LPSTR) str2, MINRESSTR);
   intlData.iTime = GetProfileInt((LPSTR) str, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_STIME, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) ":", (LPSTR) intlData.sTime, 2);
   LoadString(hInst, STR_INI_S1159, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "AM", (LPSTR) intlData.s1159, 4);
   LoadString(hInst, STR_INI_S2359, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str, (LPSTR) str2, (LPSTR) "PM", (LPSTR) intlData.s2359, 4);

   LoadString(hInst, STR_INI_EXTENSIONS, (LPSTR) str, MINRESSTR);
   notify = initFileDocData(FILE_NDX_SETTINGS, STR_INI_SETTINGS, SETTINGS_FILE_TYPE, str);
   if(initFileDocData(FILE_NDX_TASK, STR_INI_TASK, TASK_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_SCRIPT, STR_INI_SCRIPT, SCRIPT_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_MEMO, STR_INI_MEMO, MEMO_FILE_TYPE, str))
      notify = TRUE;
   if(initFileDocData(FILE_NDX_DATA, STR_INI_DATA, DATA_FILE_TYPE, str))
      notify = TRUE;
   if(notify)
#ifdef ORGCODE
      SendMessage(0xFFFF, WM_WININICHANGE, 0, (LONG) ((LPSTR) str));
#else
      SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM) str);
#endif
}

// sdj: added this code to get the list of comm ports which the serial driver
// sdj: recognized while loading the system.
// sdj: if this number of ports is > 9 then it is set to 9
// sdj: and if this info cannot be retrieved this this is set to 4 as before


void GetNumCommPortsInSystem(LPBYTE pMaxCom)
{

int   i,j, nEntries;
DWORD	dwSize, dwBufz;
DWORD	dwType;
HKEY	 hkey;
char	 szSerial[40];
char	 szCom[40];
char	 szCom2[40];
char	 szFormat[200];
BYTE	tmp1[TMPNSTR+1];
BYTE	tmp2[TMPNSTR+1];


//  NT Registry keys to find COM port to Serial Device mapping

char szRegSerialMap[] = "Hardware\\DeviceMap\\SerialComm";

  //////////////////////////////////////////////////////////////////////
  //	Get list of valid COM ports from DEVICEMAP in registry
  //////////////////////////////////////////////////////////////////////

*pMaxCom = 0;
i = 0;


if (!RegOpenKeyEx (HKEY_LOCAL_MACHINE, szRegSerialMap,
						     0L, KEY_READ, &hkey))
	 {
	     dwBufz = sizeof(szSerial);
	     dwSize = sizeof(szCom);
	     nEntries = i = 0;

	     while (!RegEnumValue (hkey, i++, szSerial, &dwBufz,
				     NULL, &dwType, szCom, &dwSize))
	     {
		 if (dwType != REG_SZ)
		     continue;

		++nEntries;

//		arComNumAndName[nEntries].Index = nEntries;
//		strcpy(arComNumAndName[nEntries].PortName,szCom);
//
		 dwSize = sizeof(szCom);
		 dwBufz = sizeof(szSerial);

	     if (nEntries > 19) break; // lets not bother with >= 20 entries

	     }
	    RegCloseKey (hkey);
	    *pMaxCom = (BYTE)nEntries;
	    arComNumAndName[0].Index = (BYTE)nEntries;

	 }
	 else
	{
	// sdj: could not find the list of comm ports in the registry, so
	// sdj: stick with the original terminal hardcoded value of com1-4
	LoadString(hInst, STR_NOCOMMPORTS, (LPSTR) tmp1, TMPNSTR);	  /* mbbx 1.00 */
	LoadString(hInst, STR_ERRCAPTION, (LPSTR) tmp2, TMPNSTR);
	MessageBox(NULL, (LPSTR) tmp1, (LPSTR)tmp2, MB_OK | MB_APPLMODAL);
	*pMaxCom = 0;
	 }

//sdj: if maxcomm is > 9 set it to 9
//
if (*pMaxCom > 9) *pMaxCom = 9;
//
//

strcpy(szCom,"COM%d");

for (i=1,j=1; i<= 9; i++)
    {
    sprintf(szCom2,szCom,i);
    if (QueryDosDevice(szCom2,szFormat,400))
	{
	arComNumAndName[j].Index = (BYTE)j;
	strcpy(arComNumAndName[j].PortName,szCom2);
	j++;
	}
    }


}

/*---------------------------------------------------------------------------*/
/* setup() - Reset all varibles, read settings file & emulation.       [scf] */
/*---------------------------------------------------------------------------*/

BOOL setup()                                 /* mbbx 2.00: no cmd line... */
{
   // -sdj was unreferenced local var: BYTE path[PATHLEN+1];
   // -sdj was unreferenced local var: BYTE tmp1[TMPNSTR+1];
   // -sdj was unreferenced local var: INT	ndx;
   SetRect (&cursorRect, 0, 0, 0, 0);
   vScrollShowing = TRUE;
   serNdx         = 0;
   cursorTick     = -1l;
   cursBlinkOn    = FALSE;
   cursorOn       = TRUE;
   activCursor    = 1;
   prtFlag        = FALSE;
   useScrap       = FALSE;
   copiedTable    = FALSE;
   *fKeyStr       = 0;                       /* mbbx 2.00: fKeySeq... */
   fKeyNdx        = 1;
   scrapSeq       = FALSE;

   xferFlag       = XFRNONE;
   xferPaused     = FALSE;
   xferBreak      = FALSE;                   /* mbbx 2.00: xfer ctrls */
   xferEndTimer   = 0;
   xferWaitEcho   = FALSE;
   xferViewPause  = 0;                       /* mbbx: auto line count */
   xferViewLine   = 0;
   xferPSChar     = 0;                           /* mbbx 1.02: packet switching */
   *strRXErrors   =
   *strRXBytes    =
   *strRXFname    =
   *strRXFork     = 0;
   taskInit();
   keyMapInit();                             /* mbbx 1.04: keymap */

   debugFlg       = FALSE;                   /* how does this get enabled??? */

   mdmOnLine      = FALSE;
   dialing        = FALSE;
   answerMode     = FALSE;
   protectMode    = FALSE;                   /* mbbx: emulation state */
   KER_getflag    = FALSE;

   gotCommEvent   = TRUE;
   sPort	  = NULL;
   bPortIsGood	  = FALSE;		     /* it is not yet opened */
					     //-sdj for telnet-quit processing
   bPortDisconnected = TRUE;		     /* this will ensure that reads dont
						occur before resetserial inits this to
						FALSE, it will be set to true by checkcommevent
						if for some reason, wait(getlasterror) is not
						IO_PENDING */

   bgOutStandingWrite = FALSE;               /* slc swat */

   //MaxComPortNumberInMenu = 5;
						/* this will get set to proper
						value when the win.ini is
						looked at for COMn entries,
						but during init, this needs
						to be set to > COM1 -sdj:04/21/92 */

   GetNumCommPortsInSystem(&MaxComPortNumberInMenu);

   if((hemulKeyInfo = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD) SIZEOFEMULKEYINFO)) == NULL)
      return(FALSE);


   initProfileData();                        /* mbbx: 1.01 */

   hTE.hText = NULL;
   DEBOUT("Calling: %s\n","setDefaults()");
   setDefaults();
   DEBOUT("Outof: %s\n","setDefaults()");

   DEBOUT("Calling: %s\n","setFKeyLevel()");
   setFKeyLevel(1, FALSE);           /*   jtfterm */
   DEBOUT("Outof: %s\n","setFKeyLevel()");

   DEBOUT("Calling: %s\n","termInitSetup()");
   termInitSetup(NULL);
   DEBOUT("Outof: %s\n","termInitSetup()");

   strcpy(szMessage, szAppName);
   return(TRUE);
}

/*---------------------------------------------------------------------------*/
/* readCmdLine() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BOOL fileDocExist(WORD  fileType, BYTE  *filePath)
{
   BOOL  fileDocExist;
   BYTE  savePath[PATHLEN], testPath[PATHLEN];
   BYTE  OEMname[STR255];

   strcpy(savePath, filePath);
   getDataPath(fileType, testPath, savePath);
   strcat(testPath, savePath);

   // JYF -- replace below lines with followin if()
   //        to remove the use of AnsiToOem()
   //
   //AnsiToOem((LPSTR) testPath, (LPSTR) OEMname); /* jtf 3.20 */
   //if(fileDocExist = fileExist(OEMname)) /* jtf 3.20 */

   if (fileDocExist = fileExist(testPath))
      strcpy(filePath, testPath);


   return(fileDocExist);
}


WORD NEAR getFileDocType(BYTE  *filePath)
{
   BYTE  fileExt[16];
   WORD  fileType;

   *fileExt = 0;
   if(!getFileType(filePath, fileExt))
   {
      forceExtension(filePath, NO_FILE_TYPE+2, FALSE);
      if(fileDocExist(FILE_NDX_DATA, filePath) || fileDocExist(FILE_NDX_SETTINGS, filePath))
         return(FILE_NDX_SETTINGS); /* jtf 3.11 */
   }

   for(fileType = FILE_NDX_SETTINGS; fileType <= FILE_NDX_MEMO; fileType += 1)
   {
      if(*fileExt == 0)
         forceExtension(filePath, fileDocData[fileType].fileExt+2, TRUE);
      else if((fileType < FILE_NDX_MEMO) && (strcmp(fileDocData[fileType].fileExt+2, fileExt) != 0))
         continue;

      if(fileDocExist(FILE_NDX_DATA, filePath) || fileDocExist(fileType, filePath) || (*fileExt != 0))
         return(fileType);
   }

   return(FILE_NDX_DATA);
}


BOOL NEAR initTermFile(BYTE  *filePath)
{
   getDataPath(FILE_NDX_SETTINGS, fileDocData[FILE_NDX_SETTINGS].filePath, filePath);

   LoadString(hInst, STR_TERMINAL, (LPSTR) termData.title, MINRESSTR);
                                             /* mbbx 2.00: no forced extents... */
   return(termFile(fileDocData[FILE_NDX_SETTINGS].filePath, filePath, 
                   fileDocData[FILE_NDX_SETTINGS].fileExt, termData.title, TF_DEFTITLE));
}


VOID NEAR readCmdLine(LPSTR lpszCmdLine)
{
   INT   ndx, ndx2;
   BYTE  filePath[PATHLEN];
   BYTE  tmpFilePath[PATHLEN];
   INT   nEditWnd = 0;
   BYTE  OEMname[STR255];              /* jtf 3.20 */
   BYTE  work[STR255];                 /* jtf 3.28 */
   BYTE  work1[STR255];                /* jtf 3.28 */
   INT   testFlag;
   
   saveFileType = FILE_NDX_SETTINGS; /* jtf 3.11 */

   AnsiUpper(lpszCmdLine);
   for(ndx = 0; lpszCmdLine[ndx] != 0; )     /* mbbx 2.00 ... */
   {
      while(lpszCmdLine[ndx] == 0x20)
         ndx++;

      if(lpszCmdLine[ndx] == 0)
         break;

      for(ndx2 = 0; (filePath[ndx2] = lpszCmdLine[ndx]) != 0; ndx2 += 1)
      {
         ndx += 1;
         if(filePath[ndx2] == 0x20)
         {
            filePath[ndx2] = 0;
            break;
         }
      }
      strcpy(work1,filePath);
      
      if(!activTerm)
         initTermFile(filePath);
   }

   ndx = lstrlen(lpszCmdLine);
   while(ndx)
   {
      ndx--;
      if(isspace(lpszCmdLine[ndx]))
         lpszCmdLine[ndx] = 0x00;
   }

   if ((!activTerm) && (lstrlen(lpszCmdLine) > 0))
   {
      LoadString(hInst, STRERRNOFILE, (LPSTR) work, STR255-1); /* jtf 3.15 */
      strcpy(filePath,work1);
      forceExtension(filePath, SETTINGS_FILE_TYPE+2, FALSE);
      sprintf(work1, work, filePath);
      testFlag = MessageBox(GetActiveWindow(), (LPSTR) work1, (LPSTR) szAppName, MB_OKCANCEL);

      if (testFlag==IDOK)
      {
         if (filePath[1]==':')
         {
            filePath[0]='A';
         }
         else
         {
            strcpy(work,filePath);
            strcpy(filePath,"A:");
            strcpy(filePath+2,work);
         }
      
         initTermFile(filePath);
      }
   }
   if(!activTerm)                            /* mbbx 2.00: term init... */
   {
      LoadString(hInst, STR_AUTOLOAD, (LPSTR) filePath, PATHLEN); /* jtf 3.17 */

      // JYF -- replace below two lines with the following if()
      //        to remove the use of AnsiToOem()
      //
      //AnsiToOem((LPSTR) filePath, (LPSTR) OEMname); /* jtf 3.20 */
      //if (fileExist(OEMname)) /* jtf 3.20 */

      if (fileExist(filePath))
         initTermFile(filePath);
      else
         {
         _searchenv( filePath, "PATH", tmpFilePath );
         if(strlen(tmpFilePath)>0)
            initTermFile(tmpFilePath);
         }

      if(!activTerm)
      {
         if((nEditWnd -= 1) >= 0)
            termData.flags |= TF_HIDE;
         else
            saveFileType = FILE_NDX_SETTINGS;

         activTerm = TRUE;
         resetSerial(&trmParams, TRUE, TRUE,0);

         if(!(termData.flags & TF_HIDE))
            showTerminal(TRUE, TRUE);
      }
   }
   if(!IsIconic(hItWnd))   /* rjs bugs 015 */
      sizeTerm(0L); /* jtf 3.21 */
}


/*---------------------------------------------------------------------------*/
/* freeItResources()- Free up all windows resource b/4 back to DOS executive.*/
/*                    Internal house keeping.  Note: Close that serial port. */
/*---------------------------------------------------------------------------*/

VOID freeItResources()
{
   // -sdj was unreferenced local var: INT	ndx;

   exitSerial();
   keyMapCancel();                           /* mbbx 1.04: keymap */

   DeleteObject(hTE.hFont);
   clearFontCache();                         /* mbbx 2.00: redundant code... */

   GlobalFree(hTE.hText);
   GlobalFree(hemulKeyInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\video.h ===
/*****************************************************************************/
/* Constant Definitions                                                      */
/*****************************************************************************/

#define VID_CALCTEXT             0x8000      /* mbbx 1.03 ... */
#define VID_CALCBKGD             0x4000
#define VID_CALCATTR             0x2000

#define VID_BOLD                 0x0001
#define VID_REVERSE              0x0002
#define VID_ITALIC               0x0004
#define VID_UNDERLINE            0x0008
#define VID_STRIKEOUT            0x0010
#define VID_MASK                 (VID_BOLD | VID_REVERSE | VID_ITALIC | VID_UNDERLINE | VID_STRIKEOUT)

#define VID_RED                  0
#define VID_GREEN                1
#define VID_BLUE                 2

#define VID_MAXFONTCACHE         6           /* mbbx 1.04: per jtfx 1.1 ... */

#define VID_DRAW_TOP             0x01        /* mbbx 1.04: per jtfx 1.1 ... */
#define VID_DRAW_BOTTOM          0x02
#define VID_DRAW_LEFT            0x04
#define VID_DRAW_RIGHT           0x08
#define VID_DRAW_SCAN1           0x10
#define VID_DRAW_SCAN3           0x20
#define VID_DRAW_SCAN7           0x40
#define VID_DRAW_SCAN9           0x80


/*****************************************************************************/
/* Variable Declarations                                                     */
/*****************************************************************************/

struct                                       /* mbbx 1.03 ... */
{
   BYTE  text[3];
   BYTE  bkgd[3];
   WORD  flags;
} vidAttr[32];


struct                                       /* mbbx 1.04: per jtfx 1.1 ... */
{
   HANDLE   hFont;
   WORD     flags;
} vidFontCache[VID_MAXFONTCACHE];


struct
{
   BYTE  buffer;
   BYTE  display;
} vidGraphChars[64];


INT   vidCharWidths[256];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\winrev.h ===
/* This file is copied to winrev.h before compiling 'C' source files... */

#define    WINDOWS_30  TRUE

#define    NOMETAFILE 
#define    NOSOUND
#define    NOKANJI	  

#ifdef WINDOWS_30
#define NOLSTRING    TRUE  /* jtf win3 mod */
#else
#define ES_OEMCONVERT 0
#define SS_NOPREFIX  128L   /* 0x80 - don't do "&" character translation */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\wndproc.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "video.h"
#include "printfil.h"

extern BOOL bZoomFlag;                       /* itutil2.c - zoomTerm() [mbb] */

VOID NEAR PASCAL FreeList(HANDLE *hList)
{
   GlobalUnlock(*hList);
   GlobalFree(*hList);
}

/*---------------------------------------------------------------------------*/
/* DC_WndProc()                                                        [mbb] */
/*---------------------------------------------------------------------------*/

HWND dlgGetFocus()                           /* mbbx 2.01.85 ... */
{
   HWND  hWnd;

   if(((hWnd = GetActiveWindow()) == NULL) || !IsChild(hItWnd, hWnd))  /* mbbx 2.01.179 (2.01.150) ... */
      hWnd = hItWnd;

   hWnd = GetActiveWindow(); /* jtf gold 044 */
   if (hWnd == NULL) testMsg("BAD WINDOW",NULL,NULL);
   return(hWnd);
}


VOID selectTopWindow()                       /* mbbx 1.03 ... */
{
   HWND  hTopWnd;

   if(((hTopWnd = GetTopWindow(hItWnd)) == NULL) || (hTopWnd == hdbmyControls))
      hTopWnd = hItWnd;
if (hTopWnd != NULL) /* jtfterm */
   SetFocus(hTopWnd);
}



LRESULT APIENTRY DC_WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   LRESULT        DC_WndProc = 0L;
   // sdj: was unref local - HWND	   hTopWnd;
   PAINTSTRUCT    ps;
   BYTE           work[STR255];              /* jtf 3.15 */
   // sdj: was unref local - RECT	  clipRect;
   // sdj: was unref local - HDC		  tempDC;
   INT		  testFlag;		     /* jtf 3.23 */
   RECT 	  hItWndRectToSave;	     // sdj: added this to save wndsize
   char 	  tmpstr[10];
   BYTE 	  str[MINRESSTR];


   DEBOUT("DC_WndProc: msg[%lx] GOT IT\n",message);
   switch(message)
   {
   case WM_WININICHANGE:  /* jtf 3.21 */
      setDefaultAttrib(TRUE);
      InvalidateRect(hTermWnd, NULL, TRUE);
      InvalidateRect(hdbmyControls, NULL, TRUE);
      UpdateWindow(hTermWnd);
      UpdateWindow(hdbmyControls);
      break;

   /* changed all wParam == hSomething to wParam == (WPARAM) hSomething -sdj*/
   case WM_SETCURSOR: /* jtf 3.20 allow hour glass to stay hour */
      if (scrapSeq && (wParam == (WPARAM)hTermWnd) && (LOWORD(lParam) == HTCLIENT) ) /* jtf 3.30 */
         {
         SetCursor(LoadCursor(NULL, IDC_WAIT));
         return (TRUE);
         }
      if ( ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDMORE) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDTIMER) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK1) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK2) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK3) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK4) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK5) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK6) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK7) ) ||
         ( wParam == (WPARAM)GetDlgItem(hdbmyControls, IDFK8) ) )
            {
            SetCursor(LoadCursor(hInst, (LPSTR) "hand"));
            return(TRUE);
            }
      DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_SIZE:
      if(wParam != SIZEICONIC)
         DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      if ((wParam != SIZEICONIC) && (hdbmyControls != NULL) && (!IsIconic(hItWnd)) )/* rjs bugs 015 -> add wParam == SIZEICONIC */
      {
         sizeFkeys(lParam); 
         if ((hTermWnd != NULL) && (!IsIconic(hItWnd)) )
            sizeTerm(0L);
         if(IsWindowVisible(hdbmyControls))
            UpdateWindow(hdbmyControls);
      }
      break;

   case WM_SETFOCUS:
   case WM_KILLFOCUS:                        /* rjs bugs 011 */
      if  (hTermWnd != NULL)     /* jtf 3.30  */
	 UpdateWindow(hTermWnd); /* jtf 3.30 */

      //sdj: the status line does not get updates when you come back
      //sdj: to terminal focus.

      if (hdbmyControls != NULL)
	{
	 if(IsWindowVisible(hdbmyControls))
	    {
	    InvalidateRect(hdbmyControls, NULL, FALSE);
	    UpdateWindow(hdbmyControls);
	    }
	}

      if(message == WM_SETFOCUS)             /* rjs bugs 011 */
      {
         showTermCursor();                   /* rjs bugs 011 */
         selectTopWindow();                  /* mbbx 1.03 */
      }
      else                                   /* rjs bugs 011 */
         hideTermCursor();                   /* rjs bugs 011 */
      break;

/* jtfterm   case WM_ERASEBKGND:                     
      GetClipBox((HDC) wParam, (LPRECT) &clipRect);
      eraseColorRect((HDC) wParam, (LPRECT) &clipRect, ANORMAL);
      DC_WndProc = 1L;
      break; */

   case WM_ERASEBKGND:                     /* jtf 3.17 */
      if(IsIconic(hWnd))
         return DefWindowProc(hWnd,WM_ICONERASEBKGND,wParam,lParam);
      else
      {
         DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
         break;
      }
   
   case WM_QUERYDRAGICON: /* jtf 3.17 */
      return (LRESULT)icon.hIcon;

   case WM_PAINT:
      if(IsIconic(hWnd))
      {
         BeginPaint(hWnd, (LPPAINTSTRUCT) &ps);
         myDrawIcon(ps.hdc, !ps.fErase);
         EndPaint(hWnd, (LPPAINTSTRUCT) &ps);
         break;
      }

      DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_CLOSE:
   case WM_QUERYENDSESSION:
         testFlag = 0;
	 /* Added 02/22/91 for win  3.1 common print dialog w-dougw */
	 if(hDevNames)
	   FreeList(&hDevNames);
	 if(hDevMode)
	   FreeList(&hDevMode);

         if (mdmOnLine)
         {
            LoadString(hInst, STRERRHANGUP, (LPSTR) work, STR255-1); /* jtf 3.15 */
            testFlag = MessageBox(GetActiveWindow(), (LPSTR) work, (LPSTR) szAppName, MB_YESNOCANCEL);
         }
         if (testFlag==IDCANCEL)
            break;
         if (testFlag==IDYES)
            hangUpPhone();

         WinHelp(hTermWnd,(LPSTR) work, (WORD) HELP_QUIT,0L);
         if (prtFlag)  
	    PrintFileComm(!prtFlag); /* jtf 3.15 */

	 //sdj: lets get the current window x,y,width,height and save it into
	 //sdj: the registry so that next time we load the settings user wants
	 //sdj: only save the values into registry if the api succeeds


	 if(GetWindowRect(hWnd,&hItWndRectToSave))
	    {

	    WindowXPosition = (int)hItWndRectToSave.left;
	    WindowYPosition = (int)hItWndRectToSave.top;
	    WindowWidth     = ((int)hItWndRectToSave.right - WindowXPosition);
	    WindowHeight    = ((int)hItWndRectToSave.bottom - WindowYPosition);

	    sprintf(tmpstr,"%d",WindowXPosition);
	    LoadString(hInst, STR_INI_XPOSITION, (LPSTR) str, MINRESSTR);
	    WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) tmpstr);

	    sprintf(tmpstr,"%d",WindowYPosition);
	    LoadString(hInst, STR_INI_YPOSITION, (LPSTR) str, MINRESSTR);
	    WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) tmpstr);

	    sprintf(tmpstr,"%d",WindowWidth);
	    LoadString(hInst, STR_INI_WIDTH, (LPSTR) str, MINRESSTR);
	    WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) tmpstr);

	    sprintf(tmpstr,"%d",WindowHeight);
	    LoadString(hInst, STR_INI_HEIGHT, (LPSTR) str, MINRESSTR);
	    WriteProfileString((LPSTR) szAppName_private, (LPSTR) str, (LPSTR) tmpstr);

	    }



         if(doneFlag = termCloseAll())    /* mbbx 1.01... */
         {
         return(TRUE); /* jtf 3.33 */
/*         DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);  jtf 3.33, 3.28 and 3.26 */
         }
      break;

   case WM_QUERYOPEN:
      flashIcon(FALSE, FALSE);
      DC_WndProc = 1L;
      break;

   case WM_ENDSESSION:
      doneFlag = wParam;           
      break;

   case WM_NCLBUTTONDBLCLK:
      if((wParam == HTCAPTION) && childZoomStatus(0x0001, 0))
      {
         ShowWindow(GetTopWindow(hItWnd), SW_RESTORE);
         break;
      }
      DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_KEYDOWN:                       /* mbbx 1.04: keymap ... */
   case WM_KEYUP:
   case WM_SYSKEYDOWN:
   case WM_SYSKEYUP:
      if (wParam == VK_F10)                     /* jtf 3.21 */
      {
         DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
         break;
      }
      termKeyProc(hWnd, message, wParam, lParam);
      break;

   case WM_COMMAND:
      doCommand(hWnd, wParam, lParam);
      break;

   case WM_INITMENUPOPUP:
      initMenuPopup(LOWORD(lParam));
      break;

   default:
      DC_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      // idleProcess();  -sdj CAUSES RECURSION AND GDI/USER DEATH
      break;
   }

DEBOUT("DC_WndProc: msg[%lx] PRCESSED\n",message);
   return(DC_WndProc);
}


/*---------------------------------------------------------------------------*/
/* TF_WndProc()                                                        [mbb] */
/*---------------------------------------------------------------------------*/

VOID termKeyProc(HWND hWnd, UINT message, WPARAM wParam,LPARAM lParam)    /* mbbx 1.04: keymap ... */
{
   STRING   termStr[STR255];
   POINT   point;    /* porting macro  change (JAP) */

   if(keyMapTranslate(&wParam, &lParam, termStr))
   {
      if(!(lParam & (1L << 31)))
         fKeyStrBuffer(termStr+1, *termStr);    /* termStr -> fKeyStr */
      return;
   }

   if(keyMapSysKey(hWnd, message, &wParam, lParam)) // sdj: AltGr
      return;

   if((hWnd == hTermWnd) && !(lParam & (1L << 31)))
   {
      switch(classifyKey((UINT)wParam))
      {
      case LONGBREAK:
         modemSendBreak(30);
         break;

      case SHORTBREAK:
         modemSendBreak(2);
         break;

      case TERMINALFKEY:
         if(keyPadSequence() && (*keyPadString > 0))     /* mbbx 1.04 ... */
            fKeyStrBuffer(keyPadString+1, *keyPadString);   /* keyPadString -> fKeyStr */
         else
            sysBeep();
         break;

      case SCROLLKEY:
         switch(wParam)
         {
         case VK_HOME:
         case VK_END:
/* rjs bugs 009 - add if statement from vk_prior case */
            if(keyMapState & VKS_CTRL)
            {
               nScrollPos.y = ((wParam == VK_HOME) ? 0 : nScrollRange.y);
               updateTermScrollBars(TRUE);
            }
            else
            {
               nScrollPos.x = ((wParam == VK_HOME) ? 0 : nScrollRange.x);
               updateTermScrollBars(TRUE);
            }
            break;

         case VK_PRIOR:
         case VK_NEXT:
            pageScroll((wParam == VK_PRIOR) ? SB_PAGEUP : SB_PAGEDOWN);
            break;

         case VK_UP:
         case VK_DOWN:
         case VK_RIGHT:
         case VK_LEFT:
            offCursor();
            longToPoint(hTE.selStart, &point);
            termClick(point, (keyMapState & VKS_SHIFT) ? TRUE : FALSE, wParam);
            onCursor();
            activSelect = TRUE;
            noSelect = FALSE;    /* rjs bugs 020 */
            break;
         }
         break;

      default:
         switch(wParam)
         {
         case VK_INSERT:
            switch(keyMapState & (VKS_SHIFT | VKS_CTRL))
            {
            case VKS_SHIFT:
               if (!scrapSeq && ((xferFlag == XFRNONE) || (xferFlag == XFRRCV)) ) /* jtf 3.17 disable send if in transfer */
                  doEditMenu(EMPASTE);
               break;
            case VKS_CTRL:
               if (!scrapSeq && ((xferFlag == XFRNONE) || (xferFlag == XFRRCV)) ) /* jtf 3.Final disable copy if in transfer */
                  doEditMenu(EMCOPY);
               break;
            case VKS_SHIFT | VKS_CTRL:
               if (!scrapSeq && ((xferFlag == XFRNONE) || (xferFlag == XFRRCV)) ) /* jtf 3.17 disable send if in transfer */
               doEditMenu(EMCOPYTHENPASTE);
               break;
            }
            break;

         case VK_BACK:
            if(keyMapState & VKS_CTRL)   /* rjs bugs 014 */
            {
               fKeyStrBuffer("\177", 1); /* rjs bugs 014 */
            }
            else                         /* rjs bugs 014 */
            {
               wParam = VK_DELETE;
               fKeyStrBuffer("\010\040\010", 3); /* jtf 3.33 */
            }
            break;

         case 'C':
         case 'c':
            if(!trmParams.useWinCtrl)
               break;

            switch(keyMapState & (VKS_SHIFT | VKS_CTRL | VKS_ALT))
            {
            case VKS_CTRL:
               if (!scrapSeq && ((xferFlag == XFRNONE) || (xferFlag == XFRRCV)) ) /* jtf 3.Final disable copy if in transfer */
                  doEditMenu(EMCOPY);
               return;
            default:
               break;
            }
            break;

         case 'V':
         case 'v':
            if(!trmParams.useWinCtrl)
               break;

            switch(keyMapState & (VKS_SHIFT | VKS_CTRL | VKS_ALT))
            {
            case VKS_CTRL:
               if (!scrapSeq && ((xferFlag == XFRNONE) || (xferFlag == XFRRCV)) ) /* jtf 3.Final disable copy if in transfer */
                  doEditMenu(EMPASTE);
               return;
            default:
               break;
            }
            break;
         }
	 keyMapKeyProc(hWnd, message, wParam, lParam);	// sdj: AltGr
         break;
      }
   }
}


/* mbbx 1.04: split DC & TF... */

LRESULT APIENTRY TF_WndProc(HWND  hWnd, UINT  message, WPARAM wParam, LPARAM lParam)
{
   LRESULT        TF_WndProc = 0L;
   INT            tmpPortLocks;
   HDC            tmpThePort;
   PAINTSTRUCT    ps;
   RECT           clipRect;                  /* mbbx 1.04: erase bkgd */
   POINT          point;

DEBOUT("TF_WndProc: msg[%lx] GOT IT\n",message);
   switch(message)
   {
   case WM_SIZE:
      break;

   case WM_SETFOCUS: 
   case WM_KILLFOCUS:
      if  (hTermWnd != NULL)     /* jtf 3.30  */
         UpdateWindow(hTermWnd); /* jtf 3.30 */
      if(message == WM_SETFOCUS)
      {
         BringWindowToTop(hWnd);
         if(childZoomStatus(0x4001, 0) && !IsZoomed(hWnd))
            ShowWindow(hWnd, SW_MAXIMIZE);
         showTermCursor(); /* rjs bugs 011 */
      }
      else
      {
         if(childZoomStatus(0x8000, 0) && IsZoomed(hWnd))
            ShowWindow(hWnd, SW_RESTORE);
         hideTermCursor(); /* rjs bugs 011 */
      }
      FlashWindow(hWnd, TRUE);
      TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_PAINT:
      offCursor();
      tmpThePort = thePort;
      tmpPortLocks = portLocks;


      BeginPaint(hWnd, (LPPAINTSTRUCT) &ps);
      thePort = ps.hdc;

      if (xferFlag <= XFRNONE)
          FrameRect(thePort, (LPRECT) &statusRect, blackBrush);     // This works, used to be after reDrawTermLine

      portLocks = 1;
      hTE.active = FALSE;
      SelectObject(thePort, hTE.hFont);


      /* rjs swat - was below next if block */
      termDeactivate(&hTE);   /* rjs swat - added this line */
      reDrawTermScreen(0, visScreenLine+1, curTopLine - savTopLine); /* jtf 3.20 this was up one line this should repaint faster */
      termActivate(&hTE);

      if(xferFlag > XFRNONE)                 /* mbbx 1.04: fkeys... */
         updateIndicators();
      else
         reDrawTermLine(maxScreenLine+1, 0, maxChars);

      EndPaint(hWnd, (LPPAINTSTRUCT) &ps);


      portLocks = tmpPortLocks;
      thePort = tmpThePort;
      onCursor();
      break;

   case WM_ERASEBKGND:                       /* mbbx 1.04: fkeys... */
      GetClipBox((HDC) wParam, (LPRECT) &clipRect);
      eraseColorRect((HDC) wParam, (LPRECT) &clipRect, ANORMAL);
      TF_WndProc = 1L;
      break;

   case WM_NCLBUTTONDOWN:
      BringWindowToTop(hWnd);
      SetFocus(hWnd);
      TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_KEYDOWN:                          /* mbbx 1.04: keymap ... */
   case WM_KEYUP:
   case WM_SYSKEYDOWN:
   case WM_SYSKEYUP:
      if (wParam==VK_F10)                     /* jtf 3.21 */
         {
         TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
         break;
         }
      termKeyProc(hWnd, message, wParam, lParam);
      break;

   case WM_CHAR:                             /* mbbx 1.04: keymap... */
      if((xferFlag == XFRNONE) || (xferFlag == XFRRCV) || xferPaused)
         if(!fKeyStrBuffer((BYTE *) &wParam, 1))
            sysBeep();

/* rjs bugs 017 -> this entire if statement */
      if(nScrollPos.y != nScrollRange.y)
         if(maxScreenLine < visScreenLine)
         {
            nScrollPos.y = nScrollRange.y;
            updateTermScrollBars(TRUE);
         }
         else
            if((maxScreenLine - visScreenLine) < curLin)
            {
               nScrollPos.y = nScrollRange.y;
               updateTermScrollBars(TRUE);
            }
/* rjs bugs 017 -> the end of the fix */

      break;

   case WM_SETCURSOR:  /* block resize box make it arrow jtfterm */
      if ( (LOWORD(lParam) == HTBOTTOMRIGHT) ||
           (LOWORD(lParam) == HTBOTTOM) )
         lParam = MAKELONG( HTNOWHERE, HIWORD(lParam) );
      TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      break;

   case WM_SYSCOMMAND:
      switch(wParam & 0xFFF0)
      {
      case SC_SIZE: /*  block resize box jtfterm */
         break; 
      case SC_CLOSE:
         termCloseFile();
         break;
      default:
         TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
         break;
      }
      break;

   case WM_HSCROLL:
      switch(GET_WM_HSCROLL_CODE(wParam, lParam))
      {
      case SB_LINEUP:
         scrollUp(SB_HORZ, GET_WM_HSCROLL_CODE(wParam, lParam), 1);
         break;
      case SB_LINEDOWN:
         scrollDown(SB_HORZ, GET_WM_HSCROLL_CODE(wParam, lParam), 1);
         break;
      case SB_PAGEUP:
      case SB_PAGEDOWN:
#ifdef ORGCODE
         hpageScroll(GET_WM_HSCROLL_CODE(wParam, lParam));
#else
/* it is coded a hPageScroll in scroll.c, no such routine as hpageScroll-sdj*/
         hPageScroll(GET_WM_HSCROLL_CODE(wParam, lParam));
#endif
         break;
      case SB_THUMBPOSITION:
         nScrollPos.x = GET_WM_HSCROLL_POS(wParam, lParam);
         updateTermScrollBars(TRUE);
         break;
      }
      break;

   case WM_VSCROLL:
      switch(GET_WM_VSCROLL_CODE(wParam, lParam))
      {
      case SB_LINEUP:
         scrollUp(SB_VERT, GET_WM_VSCROLL_CODE(wParam, lParam), 1);
         break;
      case SB_LINEDOWN:
         scrollDown(SB_VERT, GET_WM_VSCROLL_CODE(wParam, lParam), 1);
         break;
      case SB_PAGEUP:
      case SB_PAGEDOWN:
         pageScroll(GET_WM_VSCROLL_CODE(wParam, lParam));
         break;
      case SB_THUMBPOSITION:
         nScrollPos.y = GET_WM_VSCROLL_POS(wParam, lParam);
         updateTermScrollBars(TRUE);
         break;
      }
      break;

   case WM_LBUTTONDOWN:
      if(GetFocus() != hWnd)                 /* mbbx 1.04 ... */
      {
         BringWindowToTop(hWnd);
         SetFocus(hWnd);
         break;
      }

      offCursor();
//      termClick(MAKEMPOINT(lParam), (wParam & MK_SHIFT), FALSE);
      point.x = (LONG)LOWORD(lParam);
      point.y = (LONG)HIWORD(lParam);
      termClick(point, (wParam & MK_SHIFT), FALSE);
      onCursor();
      activSelect = TRUE;
      noSelect = FALSE;    /* rjs bugs 020 */
      break;

   default:
      TF_WndProc = DefWindowProc(hWnd, message, wParam, lParam);
      // idleProcess();   -sdj CAUSES RECURSION AND GDI/USER DEATH
      break;
   }

DEBOUT("TF_WndProc: msg[%lx] PRCESSED\n",message);
   return(TF_WndProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\winmain.c ===
/*===========================================================================*/
/*                                                                           */
/*  Windows DynaComm version 1.x -- Dynamic Communications for Windows 2.x   */
/*                                                                           */
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*---------------------------------------------------------------------------*/
/* This material is an unpublished work containing trade secrets which are   */
/* the property of Future Soft Engineering, Inc., and is subject to a        */
/* license therefrom.  It may not be disclosed, reproduced, adapted, merged, */
/* translated, or used in any manner without prior written consent from FSE. */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"
#include "dcdata.h"
#include "video.h"
#include "printfil.h"


/*---------------------------------------------------------------------------*/
/* mainProcess() - main process loop; called from _INITCODE:WINMAIN    [mbb] */
/*---------------------------------------------------------------------------*/

VOID FAR mainProcess()
{
   DWORD dwThreadID;
   
   doneFlag         = 
   gbThreadDoneFlag = FALSE;
   CommThreadExit   = FALSE;
   dwTimerRes       = 100;

   commThread = CreateThread(NULL, 0, checkCommEvent,
					 IntToPtr(dwTimerRes), CREATE_SUSPENDED | STANDARD_RIGHTS_REQUIRED,
					 &dwThreadID);

   if (commThread) 
   {
      SetThreadPriority(commThread, THREAD_PRIORITY_BELOW_NORMAL);
      ResumeThread(commThread);
   }
   
   overlapEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
   hMutex       = CreateMutex(NULL, FALSE, NULL);
   
   repeat
   {
      mainEventLoop();
   }
   until(doneFlag);

   // terminate threads here, not just close handles!!!!
   
//   TerminateThread(hwndThread, (DWORD)0);
//   CloseHandle(hwndThread);

//   while(WaitForSingleObject(hMutex, 1000) != 0)
//   {
//	Sleep((DWORD)50);
//	MessageBeep(0);
//   }

   if (WaitForSingleObject(hMutex, 2000) != 0)
      {
      // the comevent thread did not comeout in 2 sec, something wrong
      // Just kill it and indicate by Beep (for the timebeing) that
      // we have this wierd condition
      MessageBeep(0);
      TerminateThread(commThread, (DWORD)0);
      }

   else
      {
       // just in case if that thread as not done ExitThread(), kill it
       // maybe this is a overkill!
       TerminateThread(commThread, (DWORD)0);
       ReleaseMutex(hMutex);
      }


   CloseHandle(commThread);
   CloseHandle(hMutex);
}


/*---------------------------------------------------------------------------*/
/* mainEventLoop() - Main input from the application queue             [mbb] */
/*---------------------------------------------------------------------------*/

VOID FAR mainEventLoop()
{
   idleProcess();

   if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
   {
      if(!IsDialogMessage(hdbmyControls, &msg) && 
         !IsDialogMessage(hdbXferCtrls, &msg))
      {
         DispatchMessage(&msg);
      }
   }
}





DWORD  xSndThread (LPVOID lpParameter)
{
    DWORD  parentId = PtrToInt(lpParameter);
    AttachThreadInput (GetCurrentThreadId(), parentId, TRUE);
    xSndBFile();
    xferEnd();
    MessageBeep(10);
    gbXferActive = FALSE;
    return 0;
}


DWORD  xRcvThread (LPVOID lpParameter)
{
    DWORD  parentId = PtrToInt(lpParameter);
    AttachThreadInput (GetCurrentThreadId(), parentId, TRUE);
    xRcvBFile();
    xferEnd();
    MessageBeep(10);
    gbXferActive = FALSE;
    return 0;
}




/*---------------------------------------------------------------------------*/
/* idleProcess() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

void APIENTRY idleProcess(VOID)
{
   // sdj: was unref local - LONG	secs;
   // sdj: was unref local - LONG	finalTicks;
   // sdj: was unref local - HWND	hwnd;

static HANDLE  hThread;
static DWORD   dwId;


      updateTimer();

      if(!gbXferActive)
      {
         if (xferFlag == XFRBSND) 
         {
            gbXferActive = TRUE;
            hThread = CreateThread (NULL,
                                    0,
                                    xSndThread,
				    IntToPtr(GetCurrentThreadId()),
                                    TRUE,
                                    &dwId);
         }
         else if(xferFlag == XFRBRCV)
         {
            gbXferActive = TRUE;
            hThread = CreateThread (NULL,
                                    0,
                                    xRcvThread,
				    IntToPtr(GetCurrentThreadId()),
                                    TRUE,
                                    &dwId);
         }
         else
         {
            if (activTerm)
                termSpecial ();

            if(mdmConnect())
            {
               modemReset();
               timerAction(mdmOnLine, mdmOnLine);  /* mbbx 1.03 */
            }

            cursorAdjust();
            if(activTerm)
	       blinkCursor();

         }
      }

      Sleep((DWORD)10);

}


/*---------------------------------------------------------------------------*/
/* updateTimer() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID FAR updateTimer()                       /* mbbx 2.00: fkeys... */
{

#ifdef WIN32
WPARAM	wParam;
#endif

/* rjs bug2 001 */
   if(GetCurrentTime() - gIdleTimer >= 900)
   {
      gIdleTimer = GetCurrentTime();

      if((hItWnd != NULL) && IsWindowVisible(hdbmyControls))
#ifdef ORGCODE
         updateFKeyButton(MAKELONG(GetDlgItem(hdbmyControls, IDTIMER), BN_PAINT), FKB_UPDATE_TIMER);
#else
// sdj: 10/8/91 for bug#3277 changed
//                 wParam = MAKELONG(BN_PAINT, NULL); /* set HIWORD to cmd, LOWORD not used*/
// to:
                   wParam = MAKELONG(NULL,BN_PAINT); /* set HIWORD to cmd, LOWORD not used*/

         updateFKeyButton(wParam,(LPARAM)GetDlgItem(hdbmyControls, IDTIMER), FKB_UPDATE_TIMER);
#endif
   }
}

/*---------------------------------------------------------------------------*/
/* updateFKeyButton() -                                                [mbb] */
/*---------------------------------------------------------------------------*/


/* *****NOTE NOTE ******  this function will not work under win16, as */
/* I removed the textExtent variable and replaced with iHeigth and iWidth */
/* and didn't ifdef ORGCODE around the old code  (JAP)*/

BOOL updateFKeyButton(WPARAM wParam ,LPARAM lParam,WORD  status)        /* mbbx 2.01.163 ... */
{
   BOOL     updateFKeyButton = FALSE;
   HDC      hDC;
   RECT     timerRect, saveRect;
   DOSTIME  time;
   LONG     delta;
   BYTE     text[80];
   HBRUSH   hBrush, hOldBrush;
#ifdef ORGCODE
   DWORD    textExtent;
#else
int			iHeight;
int			iWidth;
#endif
   LONG     secs;       /* rjs bugs 004 */



   if(IsWindowVisible((HWND)GET_WM_COMMAND_HWND(wParam, lParam)))
   {
      hDC = GetWindowDC((HWND) GET_WM_COMMAND_HWND(wParam, lParam));

      GetClientRect(GET_WM_COMMAND_HWND(wParam,lParam), (LPRECT)&timerRect);
      CopyRect( &saveRect, &timerRect);
      InflateRect(&timerRect, -1, -1);

      switch(GET_WM_COMMAND_CMD(wParam, lParam))
      {
      case BN_CLICKED:
         if(updateFKeyButton = !(status & FKB_DISABLE_CTRL))
         {
            InvertRect(hDC, (LPRECT) &timerRect);
            delay(6, NULL);
            InvertRect(hDC, (LPRECT) &timerRect);
         }
         else
            sysBeep();
         break;

      case BN_PAINT:
         if(status & FKB_UPDATE_TIMER)
         {
            readDateTime(&time);

            if(timerActiv)
            {
               date2secs(&time, &delta);    

               date2secs(startTimer, &secs);

               delta -= secs;               

               if(delta < 0)                    /* rjs - msoft 4061 */
               {
                  delta = 0;
                  readDateTime(&startTimer);
               }

               time.hour = delta / 3600;
               delta -= (LONG) time.hour * 3600;
               time.minute = delta / 60;
               time.second = delta - time.minute * 60;
               sprintf(text, "%2.2d:%2.2d:%2.2d", time.hour, time.minute, time.second);
            }
            else
               getTimeString(text, &time);

            if(time.hour != lastTime.hour)
               status |= FKB_UPDATE_BKGD;
         }
         else
            SendMessage((HWND)GET_WM_COMMAND_HWND(wParam, lParam), WM_GETTEXT, 80, (LPARAM) text);

         if(status & FKB_UPDATE_BKGD)
         {
            hBrush = CreateSolidBrush(RGB(vidAttr[ANORMAL & AMASK].bkgd[VID_RED], 
                                          vidAttr[ANORMAL & AMASK].bkgd[VID_GREEN], 
                                          vidAttr[ANORMAL & AMASK].bkgd[VID_BLUE]));
            hOldBrush = (HBRUSH) SelectObject(hDC, hBrush);

            RoundRect(hDC, timerRect.left, timerRect.top, 
                      timerRect.right, timerRect.bottom, 10, 10);

            SelectObject(hDC, hOldBrush);
            DeleteObject(hBrush);
         }

         if((status & FKB_UPDATE_BKGD) || (time.second != lastTime.second))
         {
	         InflateRect(&timerRect, -4, -1);
            MGetTextExtent(hDC, (LPSTR) text, strlen(text), &iHeight, &iWidth);
            SetBkColor(hDC, RGB(vidAttr[ANORMAL & AMASK].bkgd[VID_RED], 
                                vidAttr[ANORMAL & AMASK].bkgd[VID_GREEN], 
                                vidAttr[ANORMAL & AMASK].bkgd[VID_BLUE]));

            if(!(status & FKB_DISABLE_CTRL))
            {
               SetTextColor(hDC, RGB(vidAttr[ANORMAL & AMASK].text[VID_RED], 
                                     vidAttr[ANORMAL & AMASK].text[VID_GREEN], 
                                     vidAttr[ANORMAL & AMASK].text[VID_BLUE]));
            }
            else
            {
               SetTextColor(hDC, (COLORREF)GetSysColor(COLOR_GRAYTEXT));
            }

            DrawText(hDC, (LPSTR) text, strlen(text), (LPRECT) &timerRect, 
                     (iWidth < (timerRect.right - timerRect.left)) ? 
                     DT_CENTER | DT_SINGLELINE | DT_VCENTER : DT_LEFT | DT_SINGLELINE | DT_VCENTER);

            if(status & FKB_UPDATE_TIMER)
               lastTime = time;
         }
         break;
      }
      ReleaseDC((HWND)GET_WM_COMMAND_HWND(wParam, lParam), hDC);
   }

   return(updateFKeyButton);
}


/*---------------------------------------------------------------------------*/
/* getTimeString() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID getTimeString(BYTE     *str, DOSTIME  *time)
{
   BYTE  work[16];
   BYTE     str1[MINRESSTR], str2[MINRESSTR];

   work[0] = 0;


   //sdj: the bug is about terminal not updating the timeformat
   //sdj: when control panel changes, it only updates while coming
   //sdj: up, when it inits the intlData elements. To fix this
   //sdj: update the iTime structure element before generating the
   //sdj: string, so that it reflects the current state saved by
   //sdj: the control panel applet. It is expensive to do this
   //sdj: because each time the paint msg comes, getprofile is called
   //sdj: but the other way is too complecated where you can wait
   //sdj: for the change in this value in the registry and signal
   //sdj: the change and call profile apis only when this flag is set
   //sdj: saving grace is that, this performance hit is only present
   //sdj: when bn_paint is received AND the timer mode is not on!

   LoadString(hInst, STR_INI_INTL, (LPSTR) str1, MINRESSTR);
   LoadString(hInst, STR_INI_IDATE, (LPSTR) str2, MINRESSTR);
   intlData.iDate = GetProfileInt((LPSTR) str1, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_SDATE, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str1, (LPSTR) str2, (LPSTR) "/", (LPSTR) intlData.sDate, 2);
   LoadString(hInst, STR_INI_ITIME, (LPSTR) str2, MINRESSTR);
   intlData.iTime = GetProfileInt((LPSTR) str1, (LPSTR) str2, 0);
   LoadString(hInst, STR_INI_STIME, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str1, (LPSTR) str2, (LPSTR) ":", (LPSTR) intlData.sTime, 2);
   LoadString(hInst, STR_INI_S1159, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str1, (LPSTR) str2, (LPSTR) "AM", (LPSTR) intlData.s1159, 4);
   LoadString(hInst, STR_INI_S2359, (LPSTR) str2, MINRESSTR);
   GetProfileString((LPSTR) str1, (LPSTR) str2, (LPSTR) "PM", (LPSTR) intlData.s2359, 4);



   if(!intlData.iTime)                       /* 12 Hour Clock */
   {
      if(time->hour < 12)
      {
         if(intlData.s1159[0] != 0)
            sprintf(work, " %s", intlData.s1159);
      }
      else
      {
         time->hour -= 12;

         if(intlData.s2359[0] != 0)
            sprintf(work, " %s", intlData.s2359);
      }

      if(time->hour == 0)
         time->hour = 12;
   }

   sprintf(str, "%02d%s%02d%s%02d%s", time->hour, intlData.sTime, time->minute, intlData.sTime, time->second, work);
}


/*---------------------------------------------------------------------------*/
/* cursorAdjust() - Catch terminal paint up with received characters.  [scf] */
/*---------------------------------------------------------------------------*/

VOID FAR cursorAdjust ()
{
   if(termDirty || (nScroll != 0))           /* mbbx: termLine -> termDirty */
      termCleanUp();
}


/*---------------------------------------------------------------------------*/
/* blinkCursor() -                                                      [scf]*/
/*---------------------------------------------------------------------------*/

VOID NEAR blinkCursor()
{
   RECT  rect;

   // BUG: Does not handle timer wraparound
   if(activTerm && (cursorOn > 0) && (GetCurrentTime() >= cursorTick))  /* mbbx 1.10: use msec... */
   {
      rectCursor(&rect);
      if(cursBlinkOn && memcmp(&cursorRect, &rect, sizeof(RECT)))
         toggleCursor(&cursorRect);

      cursorRect = rect;
      if(!cursBlinkOn || trmParams.cursorBlink)    /* mbbx 1.10: CUA */
         toggleCursor(&cursorRect);
      cursorTick = GetCurrentTime() + GetCaretBlinkTime();  /* mbbx 1.10: lilly... */
   }
}


/*---------------------------------------------------------------------------*/
/* checkInputBuffer() - support keystroke buffering (type-ahead)       [mbb] */
/*---------------------------------------------------------------------------*/
#ifdef OLDCODE
#define MAX_INPUT_BUFFER         64          /* allows 32 keystrokes */

WORD  inputBufferItems = 0;
MSG   inputBuffer[MAX_INPUT_BUFFER];

BOOL NEAR checkInputBuffer(MSG   *msg)
{
   WORD  ndx;

   if((kbdLock == KBD_BUFFER) || ((kbdLock == KBD_WAIT) ) || 
      ((inputBufferItems > 0) )) 
   {
      while(PeekMessage(msg, NULL, WM_KEYFIRST, WM_KEYLAST, TRUE))
      {
         if((msg->message == WM_KEYUP) && (inputBufferItems == 0))
            return(TRUE);
         else if(((msg->message == WM_KEYDOWN) || (msg->message == WM_KEYUP)) && 
                 (((msg->wParam >= '0') && (msg->wParam <= 'Z')) || (msg->wParam >= 0x80)))
         {
                                             /* mbbx 2.00: new xlate scheme... */
            if(!TranslateMessage(msg) || !PeekMessage(msg, NULL, WM_CHAR, WM_CHAR, TRUE))
               continue;
         }

         if(inputBufferItems < MAX_INPUT_BUFFER)
            inputBuffer[inputBufferItems++] = *msg;
         else
            sysBeep();
      }
   }
   else if(PeekMessage(msg, NULL, WM_CHAR, WM_CHAR, TRUE))
   {
      return(TRUE);
   }
   else if(inputBufferItems > 0)
   {
      *msg = inputBuffer[0];
      msg->hwnd = GetFocus();

      inputBufferItems -= 1;
      for(ndx = 0; ndx < inputBufferItems; ndx++)
         inputBuffer[ndx] = inputBuffer[ndx+1];

      return(TRUE);
   }

   return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\xferutil.c ===
/*===========================================================================*/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*===========================================================================*/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"
#include "task.h"


/*---------------------------------------------------------------------------*/
/* xferPauseResume() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

VOID xferPauseResume(BOOL  bPause, BOOL  bResume)
{
   setXferCtrlButton(IDPAUSE, !(xferPaused = bPause) ? STR_PAUSE : STR_RESUME);

   if(bResume)
   {
      if(xferViewPause > 0)

      xferEndTimer = 0;
      xferWaitEcho = FALSE;
   }
}


/*---------------------------------------------------------------------------*/
/* xferStopBreak() -                                                   [mbb] */
/*---------------------------------------------------------------------------*/

VOID xferStopBreak(BOOL  bStop)
{
   if(bStop)
   {
      xferBytes = 0;
      xferEndTimer = 0;
      xferWaitEcho = FALSE;
      xferStopped = TRUE;
   }
   else
      PostMessage(hTermWnd, WM_KEYDOWN, VK_CANCEL, 0L);
}


/*---------------------------------------------------------------------------*/
/* xferEnd() - Termination processing for file transfers.              [scf] */
/*---------------------------------------------------------------------------*/

VOID xferEnd()
{
   BYTE     OEMname[STR255];            /* jtf 3.20 */
   LPSTR lpBuffer;                              /* rjs bugs 016 */

   if (xferFlag == XFRRCV)                         /* rjs bugs 016 */
   {
      lpBuffer = GlobalLock(xferBufferHandle);  /* rjs bugs 016 */
      if (xferBufferCount > 0)                  /* rjs bugs 016 */
         _lwrite(xferRefNo, (LPSTR)lpBuffer, xferBufferCount); /* rjs bugs 016 */
      GlobalUnlock(xferBufferHandle);           /* rjs bugs 016 */
      xferBufferCount = 0;                      /* rjs bugs 016 */
      GlobalFree(xferBufferHandle);             /* rjs bugs 016 */
   }

   if(xferViewPause > 0)
   {
      xferViewPause = 0;
      xferViewLine  = 0;
   }

   xferFlag = XFRNONE;
   xferWaitEcho = FALSE;
   xferStopped = FALSE;
   chrHeight = stdChrHeight;
   chrWidth = stdChrWidth;

   showXferCtrls(0);                      /* mbbx 2.00: xfer ctrls... */
   xferPauseResume(FALSE, FALSE);

   *strRXErrors =
   *strRXBytes =
   *strRXFname =
   *strRXFork = 0;

   if(xferRefNo)
      _lclose(xferRefNo);
   LoadString(hInst, STR_TEMPFILE, (LPSTR) xferVRefNum+(*xferVRefNum)+1, 16);

   // JYF -- replace below two lines with the following if()
   //        to remove the use of AnsiToOem()
   //
   //AnsiToOem((LPSTR) (xferVRefNum+1), (LPSTR) OEMname); /* jtf 3.20 */
   //if(fileExist(OEMname)) /* jtf 3.20 */

   if (fileExist((LPSTR)xferVRefNum+1))
      MDeleteFile(xferVRefNum+1);
   KER_getflag = FALSE;

   flashIcon(TRUE, TRUE);

}


/*---------------------------------------------------------------------------*/
/* rxEventLoop() -                                              [scf]        */
/*---------------------------------------------------------------------------*/

/* mbbx 1.04: moved from RXEVNTLP.C ... */

VOID rxEventLoop()
{
   MSG msg;

//   while(PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
//      mainEventLoop ();

   idleProcess();

#ifdef SLEEP_FOR_CONTEXT_SWTICH
   Sleep((DWORD)5);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\terminal\xmodem.c ===
/*****************************************************************************/
/*          Copyright (c) 1987 - 1988, Future Soft Engineering, Inc.         */
/*                              Houston, Texas                               */
/*****************************************************************************/

#define NOLSTRING    TRUE  /* jtf win3 mod */
#include <windows.h>
#include "port1632.h"
#include "dcrc.h"
#include "dynacomm.h"


/*---------------------------------------------------------------------------*/

#define XM_ABORT                    0x8000
#define XM_COMPLETE                 0x4000
#define XM_BLKREPEAT                0x2000
#define XM_CRC                      0x0800
#define YM_1KBLK                    0x0400
#define YM_GOPTION                  0x0200
#define XM_RETRYMASK                0x001F   /* mbbx 1.04: relax 15 -> 31 */

#define XM_RETRIES                  0x0014   /* mbbx 1.04: relax 10 -> 20 */
#define XM_RETRYINITCRC             4
#define XM_RETRYINITCKS             10

#define XM_WAITRCVINIT              50       /* mbbx 1.04: relax... */
#define XM_WAITNEXTBLK              100
#define XM_WAITNEXTCHAR 	    50	     //sdj: was 20 to get rid of xmodem
					     //sdj: retries when moused moved..move to 50
#define XM_WAITSNDINIT              600


BOOL YM_RcvBatch(WORD);
BOOL NEAR YM_RcvFileInfo(WORD *, WORD *);

BOOL XM_RcvFile(WORD);
BOOL NEAR XM_RcvInit(WORD *, WORD *);
BOOL NEAR XM_RcvData(WORD *, WORD *);
BOOL NEAR XM_RcvBlockHeader(WORD *, WORD *);
BOOL NEAR XM_RcvBlockData(WORD *blockNumber, WORD blockSize,WORD *rcvStatus);
VOID NEAR XM_RcvBlockAbort(WORD *);
BOOL NEAR XM_RcvEnd();
VOID NEAR XM_RcvAbort();

BOOL YM_SndBatch(WORD);
BOOL NEAR YM_SndFileInfo(WORD *, BOOL);

BOOL XM_SndFile(WORD sndStatus);
BOOL NEAR XM_SndInit(WORD *);
BOOL NEAR XM_SndData(WORD *);
BOOL NEAR XM_SndBlockData(WORD *, WORD *, WORD *);
BOOL NEAR XM_SndEnd();
VOID NEAR XM_SndAbort();

BYTE XM_CheckSum(BYTE *dataBlock, WORD blockSize);              /* mbbx 2.00: NEAR -> FAR */
WORD XM_CalcCRC(BYTE *, INT);                /* mbbx 2.00: NEAR -> FAR */


/*---------------------------------------------------------------------------*/
/* UTILITIES --> RCVBFILE.C */

BOOL initXfrBuffer(WORD wBufSize);
VOID fillXfrBuffer(BYTE *, WORD);
WORD readXfrBuffer(BYTE *dataBlock,WORD  blockSize,BOOL bBlkRepeat);
BOOL writeXfrBuffer(BYTE *dataBlock, WORD blockSize,BOOL bBlkRepeat);
VOID grabXfrBuffer(BYTE *, WORD);
BOOL clearXfrBuffer();
VOID freeXfrBuffer();


/*---------------------------------------------------------------------------*/
/* XM_RcvFile() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL XM_RcvFile(WORD rcvStatus)
{
   WORD  blockSize;

   if(XM_RcvInit(&blockSize, &rcvStatus))
      if(XM_RcvData(&blockSize, &rcvStatus))
         if(XM_RcvEnd())
            return(TRUE);

   XM_RcvAbort();
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvInit() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_RcvInit(WORD  *blockSize, WORD  *rcvStatus)
{
   BYTE  work[3];
   WORD  retry;

   LoadString(hInst, STR_RI, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   *blockSize = 128;
   *rcvStatus |= XM_RETRIES;

   if(*rcvStatus & (YM_1KBLK | YM_GOPTION))
      *rcvStatus |= XM_CRC;

   while(*rcvStatus & XM_CRC)
   {
      for(retry = XM_RETRYINITCRC; retry > 0; retry -= 1)
      {
         modemWr('C');

         if(xferPSChar)                      /* mbbx 1.02: packet switching */
            modemWr(xferPSChar);

         if(waitRcvChar(work, XM_WAITRCVINIT, 0, CHSTX, CHSOH, CHEOT, CHCAN, NULL))
         {
            switch(work[0])
            {
            case CHSTX:
               *blockSize = 1024;
                                             /* then fall thru... */
            case CHSOH:
               return(TRUE);

            case CHEOT:
               *rcvStatus |= XM_COMPLETE;
               return(TRUE);

            case CHCAN:
               return(FALSE);
            }
         }

         if(xferStopped)
            return(FALSE);
      }

      *rcvStatus &= ((*rcvStatus & YM_GOPTION) ? ~YM_GOPTION : ~XM_CRC);
   }

   for(retry = XM_RETRYINITCKS; retry > 0; retry -= 1)   /* mbbx 1.04: relax */
   {
      modemWr(CHNAK);
      if(xferPSChar)                         /* mbbx 1.02: packet switching */
         modemWr(xferPSChar);

      if(waitRcvChar(work, XM_WAITRCVINIT, 0, CHSTX, CHSOH, CHEOT, CHCAN, NULL))
      {
         switch(work[0])
         {
         case CHSTX:
            *blockSize = 1024;
                                             /* then fall thru... */
         case CHSOH:
            return(TRUE);

         case CHEOT:
            *rcvStatus |= XM_COMPLETE;
            return(TRUE);

         case CHCAN:
            return(FALSE);
         }
      }

      if(xferStopped)
         break;

      showBErrors(++xferErrors);
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvData() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_RcvData(WORD  *blockSize, WORD  *rcvStatus)
{
   BYTE  work[3];
   WORD  blockNumber = 1;

   if(*rcvStatus & XM_COMPLETE)
      return(TRUE);

   LoadString(hInst, STR_DF, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   if(initXfrBuffer(12 * 1024))
   {
      XM_RcvBlockData(&blockNumber, *blockSize, rcvStatus);

      while(!(*rcvStatus & (XM_COMPLETE | XM_ABORT)))
      {
         if(XM_RcvBlockHeader(blockSize, rcvStatus))
            XM_RcvBlockData(&blockNumber, *blockSize, rcvStatus);
      }

      if(!(*rcvStatus & XM_ABORT))
         if(!clearXfrBuffer())
            *rcvStatus |= XM_ABORT;

      freeXfrBuffer();
   }

   return(!(*rcvStatus & XM_ABORT));
}


/*---------------------------------------------------------------------------*/
/* XM_RcvBlockHeader() -                                               [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_RcvBlockHeader(WORD  *blockSize, WORD  *rcvStatus)
{
   BYTE  work[1];

   if(waitRcvChar(work, XM_WAITNEXTBLK, 0, CHSTX, CHSOH, CHEOT, CHCAN, NULL))
   {
      switch(work[0])
      {
      case CHSTX:
         *blockSize = 1024;
         return(TRUE);

      case CHSOH:
         *blockSize = 128;
         return(TRUE);

      case CHEOT:
         *rcvStatus |= XM_COMPLETE;
         return(FALSE);

      case CHCAN:
         xferStopped = TRUE;
         break;
      }
   }

   XM_RcvBlockAbort(rcvStatus);
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvBlockData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_RcvBlockData(WORD *blockNumber, WORD blockSize,WORD *rcvStatus)
{
   BYTE  work[2];
   BOOL  bBlkRepeat;
   WORD  ndx;
   BYTE  dataBlock[1024];
   signed char i,j;

   while(waitRcvChar(work, XM_WAITNEXTCHAR, 0, 0) &&
         waitRcvChar(work+1, XM_WAITNEXTCHAR, 0, 0) &&
	 ( (j=(signed char)work[0]) == ~(i = (signed char)work[1])	) )

   //sdj: on mips xmodem rcv was broken due to (BYTE)~work[1]

   {
      if(bBlkRepeat = (work[0] != (BYTE) *blockNumber))
         if(work[0] != (BYTE) (*blockNumber-1))
            break;

      for(ndx = 0; ndx < blockSize; ndx += 1)
         if(!waitRcvChar(dataBlock+ndx, XM_WAITNEXTCHAR, 0, 0))
            break;
      if(ndx < blockSize)
         break;

      if(!waitRcvChar(work, XM_WAITNEXTCHAR, 0, 0))
         break;
      if(!(*rcvStatus & XM_CRC))
      {
         if(XM_CheckSum(dataBlock, blockSize) != work[0])
            break;
      }
      else
      {
         if(!waitRcvChar(work+1, XM_WAITNEXTCHAR, 0, 0) || (XM_CalcCRC(dataBlock, blockSize) != ((work[0] << 8) | work[1])))
            break;
      }

      if(!writeXfrBuffer(dataBlock, blockSize, bBlkRepeat))
      {
         xferStopped = TRUE;
         break;
      }

      if(!bBlkRepeat)                        /* mbb: reset retry counter */
      {
         *blockNumber += 1;
         *rcvStatus = (*rcvStatus & ~XM_RETRYMASK) | XM_RETRIES;

         if(*blockNumber > 1)                /* mbb: skip block 0 */
         {
            if(xferOrig > 0)
            {
               xferBytes -= blockSize;
               updateProgress(FALSE);
            }
            else
               showBBytes(xferLength += blockSize, FALSE);  /* mbbx 2.00: xfer ctrls */
         }
      }

      if(!(*rcvStatus & YM_GOPTION))
      {
         modemWr(CHACK);
         if(xferPSChar)                      /* mbbx 1.02: packet switching */
            modemWr(xferPSChar);
      }

      return(TRUE);
   }

   XM_RcvBlockAbort(rcvStatus);
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvBlockAbort() -                                                [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR XM_RcvBlockAbort(WORD  *rcvStatus)
{
   BYTE  work[1];

   if(xferStopped || (((*rcvStatus -= 1) & XM_RETRYMASK) == 0))
      *rcvStatus |= XM_ABORT;
   else
   {
      while(waitRcvChar(work, XM_WAITNEXTCHAR, 0, 0));
      modemWr(CHNAK);
      if(xferPSChar)                         /* mbbx 1.02: packet switching */
         modemWr(xferPSChar);
   }

   if(!xferStopped)
      showBErrors(++xferErrors);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvEnd() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_RcvEnd()
{
   BYTE  work[3];
   WORD  retry;

   LoadString(hInst, STR_RE, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   modemWr(CHACK);
   if(xferPSChar)                            /* mbbx 1.02: packet switching */
      modemWr(xferPSChar);

   for(retry = XM_RETRIES; retry > 0; retry -= 1)     /* mbbx 1.04: relax */
   {
      if(waitRcvChar(work, XM_WAITNEXTBLK / 2, 0, CHEOT, CHCAN, NULL))
      {
         switch(work[0])
         {
         case CHEOT:
            modemWr(CHACK);
            if(xferPSChar)                   /* mbbx 1.02: packet switching */
               modemWr(xferPSChar);
            showBErrors(++xferErrors);
            continue;

         case CHCAN:
            xferStopped = TRUE;
            break;
         }
      }

      if(xferStopped)
         break;

      return(TRUE);
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_RcvAbort() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR XM_RcvAbort()
{
   BYTE  work[1];

   rcvAbort();

   while(waitRcvChar(work, XM_WAITNEXTCHAR, 0, 0));
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   if(xferPSChar)                            /* mbbx 1.02: packet switching */
      modemWr(xferPSChar);
}


/*---------------------------------------------------------------------------*/
/* XM_SndFile() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL XM_SndFile(WORD sndStatus)
{
   if(XM_SndInit(&sndStatus))
      if(XM_SndData(&sndStatus))
         if(XM_SndEnd())
            return(TRUE);

   XM_SndAbort();
   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_SndInit() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_SndInit(WORD  *sndStatus)
{
   BYTE  work[3];

   LoadString(hInst, STR_SI, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   *sndStatus |= XM_RETRIES;

   if(waitRcvChar(work, XM_WAITSNDINIT, 0, 'C', CHNAK, CHCAN, 0))
   {
      switch(work[0])
      {
      case 'C':
         *sndStatus |= XM_CRC;
         if(!(*sndStatus & YM_1KBLK) && waitRcvChar(work, XM_WAITNEXTCHAR / 2, 0, 'K', 0))
            *sndStatus |= YM_1KBLK;
         return(TRUE);

      case CHNAK:
         *sndStatus &= ~(XM_CRC | YM_1KBLK);
         return(TRUE);

      case CHCAN:
         break;
      }
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_SndData() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_SndData(WORD  *sndStatus)
{
   BYTE  work[3];
   WORD  blockNumber = 1;
   WORD  blockSize;

   LoadString(hInst, STR_DF, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   if(initXfrBuffer(12 * 1024))
   {
      blockSize = (!(*sndStatus & YM_1KBLK) ? 128 : 1024);

      while(!(*sndStatus & (XM_COMPLETE | XM_ABORT)))
         XM_SndBlockData(&blockNumber, &blockSize, sndStatus);

      freeXfrBuffer();
   }

   return(!(*sndStatus & XM_ABORT));
}


/*---------------------------------------------------------------------------*/
/* XM_SndBlockData() -                                                 [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_SndBlockData(WORD *blockNumber, WORD *blockSize, WORD *sndStatus)
{
   BYTE  dataBlock[1024];
   WORD  dataBytes;
   WORD  wCRC;
   BYTE  work[1];
   BOOL  writeGood;

   switch(dataBytes = readXfrBuffer(dataBlock, *blockSize, (*sndStatus & XM_BLKREPEAT)))
   {
   case (WORD)-1:
      xferStopped = TRUE;
      break;

   case 0:
      *sndStatus |= XM_COMPLETE;
      return(TRUE);

   default:
      if((*blockSize == 1024) && (dataBytes <= (5 * 128)) && !(*sndStatus & XM_BLKREPEAT))
         readXfrBuffer(dataBlock, *blockSize = 128, TRUE);

      modemWr((*blockSize == 128) ? CHSOH : CHSTX);
      modemWr((BYTE) *blockNumber);
      modemWr((BYTE) ~*blockNumber);

      writeGood = modemWrite((LPSTR) dataBlock, (INT)(*blockSize));

      if(!writeGood)
      {
         wCRC = 0;
         break;
      }

      if(!(*sndStatus & XM_CRC))
         modemWr(XM_CheckSum(dataBlock, *blockSize));
      else
      {
         wCRC = XM_CalcCRC(dataBlock, *blockSize);
         modemWr(HIBYTE(wCRC));
         modemWr(LOBYTE(wCRC));
      }
      if(xferPSChar)                         /* mbbx 1.02: packet switching */
         modemWr(xferPSChar);

      if(!waitRcvChar(work, XM_WAITSNDINIT, 0, CHACK, CHNAK, CHCAN, (*blockNumber <= 1) ? 'C' : 0, 0))
      {
         xferStopped = TRUE;
         break;
      }

      switch(work[0])
      {
      case CHACK:
         *blockNumber += 1;
         *sndStatus = (*sndStatus & ~(XM_BLKREPEAT | XM_RETRYMASK)) | XM_RETRIES;

         if(*blockNumber > 1)
         {
            xferBytes -= *blockSize;
            updateProgress(FALSE);
         }
         return(TRUE);

      case CHNAK:
         break;

      case CHCAN:
         xferStopped = TRUE;
         break;
      }
      break;
   }

   if(xferStopped || (((*sndStatus -= 1) & XM_RETRYMASK) == 0))
      *sndStatus |= XM_ABORT;
   else
      *sndStatus |= XM_BLKREPEAT;

   if(!xferStopped)
      showBErrors(++xferErrors);

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_SndEnd() -                                                       [mbb] */
/*---------------------------------------------------------------------------*/

BOOL NEAR XM_SndEnd()
{
   BYTE  work[3];
   WORD  retry;

   LoadString(hInst, STR_SE, (LPSTR) work, 4);  /* mbbx 1.04: REZ... */
   bSetup(work);

   for(retry = XM_RETRIES; retry > 0; retry -= 1)     /* mbbx 1.04: relax */
   {
      modemWr(CHEOT);
      if(xferPSChar)                         /* mbbx 1.02: packet switching... */
         modemWr(xferPSChar);

      if(waitRcvChar(work, XM_WAITNEXTBLK, 0, CHACK, CHCAN, 0))   /* mbbx 1.04: relax 15 -> 60 */
      {
         switch(work[0])
         {
         case CHACK:
            return(TRUE);

         case CHCAN:
            xferStopped = TRUE;
            break;
         }
      }

      if(xferStopped)
         break;

      showBErrors(++xferErrors);
   }

   return(FALSE);
}


/*---------------------------------------------------------------------------*/
/* XM_SndAbort() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

VOID NEAR XM_SndAbort()
{
   BYTE  work[1];

   sndAbort();

   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(CHCAN);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   modemWr(BS);
   if(xferPSChar)                            /* mbbx 1.02: packet switching */
      modemWr(xferPSChar);
}


/*---------------------------------------------------------------------------*/
/* XM_CheckSum() -                                                     [mbb] */
/*---------------------------------------------------------------------------*/

BYTE XM_CheckSum(BYTE *dataBlock, WORD blockSize)       /* mbbx 2.00: NEAR -> FAR */
{
   BYTE  XM_CheckSum = 0;

   while(blockSize > 0)
      XM_CheckSum += dataBlock[--blockSize];

   return(XM_CheckSum);
}


/*---------------------------------------------------------------------------*/
/* XM_CalcCRC() -                                                      [mbb] */
/*---------------------------------------------------------------------------*/

WORD XM_CalcCRC(BYTE  *dataBlock, INT   blockSize)
{
   WORD  XM_CalcCRC = 0;
   INT   ndx;

   while(--blockSize >= 0)
   {
      XM_CalcCRC = XM_CalcCRC ^ (((WORD) *dataBlock++) << 8);
      for(ndx = 0; ndx < 8; ndx += 1)
      {
         if(XM_CalcCRC & 0x8000)
            XM_CalcCRC = (XM_CalcCRC << 1) ^ 0x1021;
         else
            XM_CalcCRC = (XM_CalcCRC << 1);
      }
   }

   return(XM_CalcCRC & 0xFFFF);
}


/*---------------------------------------------------------------------------*/
/* UTILITIES --> file buffering to be used by all RCV protocols !!!    [mbb] */
/*---------------------------------------------------------------------------*/

HANDLE   hXfrBuf;
LPSTR    lpXfrBuf;
WORD     wXfrBufSize;
WORD     wXfrBufBytes;
WORD     wXfrBufIndex;
WORD     wXfrBufExtend;


BOOL initXfrBuffer(WORD wBufSize)
{
   wXfrBufSize = wBufSize;
   if((hXfrBuf = GlobalAlloc(GMEM_MOVEABLE, (DWORD) wXfrBufSize)) != NULL)
   {
#ifdef ORGCODE
      if((lpXfrBuf = GlobalWire(hXfrBuf)) != NULL)
#else
      if((lpXfrBuf = GlobalLock(hXfrBuf)) != NULL)
#endif

      {
         wXfrBufBytes  = 0;
         wXfrBufIndex  = 0;
         wXfrBufExtend = 0;
         return(TRUE);
      }

      GlobalFree(hXfrBuf);
   }

   rcvFileErr();
   return(FALSE);
}



WORD readXfrBuffer(BYTE *dataBlock, WORD blockSize, BOOL bBlkRepeat)
{
   if(!bBlkRepeat)
      wXfrBufIndex += wXfrBufExtend;

   if((wXfrBufIndex+blockSize) > wXfrBufBytes)
   {
      if((wXfrBufBytes -= wXfrBufIndex) > 0)
         lmovmem(lpXfrBuf+wXfrBufIndex, lpXfrBuf, wXfrBufBytes);

      if((wXfrBufIndex = (WORD)_lread(xferRefNo, lpXfrBuf, wXfrBufSize-wXfrBufBytes)) == (WORD)-1)
      {
         return((WORD)-1);
      }

      wXfrBufBytes += wXfrBufIndex;
      wXfrBufIndex  = 0;
   }

   if((wXfrBufExtend = (wXfrBufBytes-wXfrBufIndex)) > 0)
   {
      if(wXfrBufExtend > blockSize)
         wXfrBufExtend = blockSize;
      lmovmem(lpXfrBuf+wXfrBufIndex, (LPSTR) dataBlock, wXfrBufExtend);
      if(wXfrBufExtend < blockSize)
         memset(dataBlock+wXfrBufExtend, CNTRLZ, blockSize-wXfrBufExtend);
   }

   return(wXfrBufExtend);
}


BOOL writeXfrBuffer(BYTE *dataBlock, WORD blockSize,BOOL bBlkRepeat)
{
   if(!bBlkRepeat)
      wXfrBufBytes += wXfrBufExtend;

   if((wXfrBufBytes+blockSize) > wXfrBufSize)
   {
      if(_lwrite(xferRefNo, lpXfrBuf, wXfrBufBytes) != wXfrBufBytes)
      {
         rcvFileErr();
         return(FALSE);
      }
      wXfrBufBytes = 0;
   }

   lmovmem((LPSTR) dataBlock, lpXfrBuf+wXfrBufBytes, wXfrBufExtend = blockSize);
   return(TRUE);
}


BOOL clearXfrBuffer()
{
   if(wXfrBufExtend > 0)
   {
      while(wXfrBufExtend > 0)               /* mbbx 1.04 ... */
      {
         if(*(lpXfrBuf+(wXfrBufBytes+wXfrBufExtend-1)) != CNTRLZ)
            break;
         wXfrBufExtend -= 1;
      }
      wXfrBufBytes += wXfrBufExtend;
      wXfrBufExtend = 0;
   }

   if(wXfrBufBytes > 0)
   {
      if(_lwrite(xferRefNo, lpXfrBuf, wXfrBufBytes) != wXfrBufBytes)
      {
         rcvFileErr();
         return(FALSE);
      }
      wXfrBufBytes = 0;
   }

   return(TRUE);
}


VOID freeXfrBuffer()
{
#ifdef ORGCODE
   GlobalUnWire(hXfrBuf);
#else
   GlobalUnlock(hXfrBuf);
#endif

   GlobalFree(hXfrBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\getuname\getuname.h ===
/*++

Copyright (c) 1997-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    getuname.h

Abstract:

    This file defines the string resource identifiers used by GetUName.dll.

Revision History:

    15-Sep-2000    JohnMcCo    Added support for Unicode 3.0
    17-Oct-2000    JulieB      Code cleanup

--*/



#ifndef GETUNAME_H
#define GETUNAME_H

#ifdef __cplusplus
extern "C" {
#endif




//
//  Constant Declarations.
//

//
//  Mnemonic for the longest possible name.
//  Must be as long as the longest (possibly localized) name.
//
#define MAX_NAME_LEN 256

//
//  Mnenonics for important code values in each range.
//
#define FIRST_EXTENSION_A         0x3400
#define LAST_EXTENSION_A          0x4db5
#define FIRST_CJK                 0x4e00
#define LAST_CJK                  0x9fa5
#define FIRST_YI                  0xa000
#define FIRST_HANGUL              0xac00
#define LAST_HANGUL               0xd7a3
#define FIRST_HIGH_SURROGATE      0xd800
#define FIRST_PRIVATE_SURROGATE   0xdb80
#define FIRST_LOW_SURROGATE       0xdc00
#define FIRST_PRIVATE_USE         0xe000
#define FIRST_COMPATIBILITY       0xf900

//
//  Mnemonics for the range name string ids.
//
#define IDS_UNAME                 0x0000
#define IDS_CJK_EXTA              FIRST_EXTENSION_A
#define IDS_CJK                   FIRST_CJK
#define IDS_HIGH_SURROGATE        FIRST_HIGH_SURROGATE
#define IDS_PRIVATE_SURROGATE     FIRST_PRIVATE_SURROGATE
#define IDS_LOW_SURROGATE         FIRST_LOW_SURROGATE
#define IDS_PRIVATE_USE           FIRST_PRIVATE_USE
#define IDS_UNDEFINED             0xFFFE                 // guaranteed to be not a character

//
//  Mnemonics for the Hangul syllable parts string ids.
//  Use the Hangul syllable range since we know that is unused.
//
#define IDS_HANGUL_SYLLABLE       FIRST_HANGUL
#define IDS_HANGUL_LEADING        (FIRST_HANGUL + 1)
#define IDS_HANGUL_MEDIAL         (FIRST_HANGUL + 0x100)
#define IDS_HANGUL_TRAILING       (FIRST_HANGUL + 0x200)



#ifdef __cplusplus
}
#endif

#endif // GETUNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\getuname\getuname.c ===
/*++

Copyright (c) 1997-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    getuname.c

Abstract:

    The CharMap accessory uses this DLL to obtain the Unicode name
    associated with each 16-bit code value.  The names are Win32 string
    resources and are localized for some languages.  The precomposed
    Korean syllables (Hangul) get special treatment to reduce the size
    of the string table.

    The module contains two external entry points:
        GetUName - Called by CharMap to get a name
        DLLMain  - Invoked by the system when the DLL is loaded and unloaded.


    BUGBUGS:
    (1) This module does not support UTF-16 (Unicode surrogate) names.
        To fix this would require changes to CharMap to pass pairs of code
        values.

    (2) The HangulName code assumes that the name parts are in the same order
        as in English instead of:
          "HANGUL SYLLABLE"+leading consonant+medial vowel+trailing consonant
        This is a localization sin since it does not work for all languages.

Revision History:

    15-Sep-2000    JohnMcCo    Added support for Unicode 3.0
    17-Oct-2000    JulieB      Code cleanup

--*/



//
//  Include Files.
//

#include <windows.h>
#include <uceshare.h>
#include "getuname.h"




//
//  Global Variables.
//

static HINSTANCE g_hInstance = NULL;





////////////////////////////////////////////////////////////////////////////
//
//  CopyUName
//
//  Copies the Unicode name of a code value into the buffer.
//
////////////////////////////////////////////////////////////////////////////

static int CopyUName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    //
    //  Attempt to load the string resource with the ID equal to the code
    //  value.
    //
    int nLen = LoadString(g_hInstance, wcCodeValue, lpBuffer, MAX_NAME_LEN);

    //
    //  If no such string, return the undefined code value string.
    //
    if (nLen == 0)
    {
        nLen = LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN);
    }

    //
    //  Return the length of the string copied to the buffer.
    //
    return (nLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeHangulName
//
//  Copy the Unicode name of the Hangul syllable code value into the buffer.
//  The Hangul syllable names are composed from the code value.  Each name
//  consists of three parts:
//      leading consonant
//      medial vowel
//      trailing consonant (which may be null)
//  The algorithm is explained in Unicode 3.0 Chapter 3.11
//  "Conjoining Jamo Behavior".
//
////////////////////////////////////////////////////////////////////////////

static int MakeHangulName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    const int nVowels = 21;            // number of medial vowel jamos
    const int nTrailing = 28;          // number of trailing consonant jamos

    //
    //  Copy the constant part of the name into the buffer.
    //
    int nLen = LoadString( g_hInstance,
                           IDS_HANGUL_SYLLABLE,
                           lpBuffer,
                           MAX_NAME_LEN );

    //
    //  Turn the code value into an index into the Hangul syllable block.
    //
    wcCodeValue -= FIRST_HANGUL;

    //
    //  Append the name of the leading consonant.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_LEADING + wcCodeValue / (nVowels * nTrailing),
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );
    wcCodeValue %= (nVowels * nTrailing);

    //
    //  Append the name of the medial vowel.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_MEDIAL + wcCodeValue / nTrailing,
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );
    wcCodeValue %= nTrailing;

    //
    //  Append the name of the trailing consonant.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_TRAILING + wcCodeValue,
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );

    //
    //  Return the total length.
    //
    return (nLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
//  This is the DLL init routine.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(
    HINSTANCE hInstance,               // handle of this DLL
    DWORD fdwReason,                   // reason we are here
    LPVOID lpReserved)                 // reserved and unused
{
    //
    //  If the DLL has just been loaded into memory, save the instance
    //  handle.
    //
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
    }

    return (TRUE);

    UNREFERENCED_PARAMETER(lpReserved);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUName
//
//  Copies the name of the Unicode character code value into the caller's
//  buffer.  The function value is the length of the name if it was found
//  and zero if not.
//
////////////////////////////////////////////////////////////////////////////

int APIENTRY GetUName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    //
    //  Perform a series of comparisons to determine in which range the code
    //  value lies.  If there were more ranges, it would be efficient to use
    //  a binary search.  However, with just a few ranges, the overhead is
    //  greater than the savings, especially since the first comparison
    //  usually succeeds.
    //

    //
    //  MOST SCRIPTS.
    //
    if (wcCodeValue < FIRST_EXTENSION_A)
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }

    //
    //  CJK EXTENSION A.
    //
    else if (wcCodeValue <= LAST_EXTENSION_A)
    {
         return (LoadString(g_hInstance, IDS_CJK_EXTA, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_CJK)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  CJK.
    //
    else if (wcCodeValue <= LAST_CJK)
    {
        return (LoadString(g_hInstance, IDS_CJK, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_YI)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  YI.
    //
    else if (wcCodeValue < FIRST_HANGUL)
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }

    //
    //  HANGUL SYLLABLE.
    //
    else if (wcCodeValue <= LAST_HANGUL)
    {
        return (MakeHangulName(wcCodeValue, lpBuffer));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_HIGH_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  NON PRIVATE USE HIGH SURROGATE.
    //
    else if (wcCodeValue < FIRST_PRIVATE_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_HIGH_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  PRIVATE USE HIGH SURROGATE.
    //
    else if (wcCodeValue < FIRST_LOW_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_PRIVATE_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  LOW SURROGATE.
    //
    else if (wcCodeValue < FIRST_PRIVATE_USE)
    {
        return (LoadString(g_hInstance, IDS_LOW_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  PRIVATE USE.
    //
    else if (wcCodeValue < FIRST_COMPATIBILITY)
    {
        return (LoadString(g_hInstance, IDS_PRIVATE_USE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  COMPATIBILITY REGION.
    //
    else
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\inc\uceshare.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    uceshare.h

Abstract:

    This file defines the header information used by both the
    getuname (getuname.dll) and uce (charmap.exe) directories.

Revision History:

    27-Nov-2000    JulieB      Created

--*/



#ifndef UCESHARE_H
#define UCESHARE_H

#ifdef __cplusplus
extern "C" {
#endif




//
//  External Functions.
//

int APIENTRY
GetUName(
    WCHAR wcCodeValue,
    LPWSTR lpBuffer);



#ifdef __cplusplus
}
#endif

#endif // UCESHARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\cdropsrc.h ===
//**********************************************************************
// File name: cdropsrc.h
//
// Definition of CDropSource
// Implements the IDropSource interface required for an application to
// act as a Source in a drag and drop operation
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef DROPSOURCE_H
#define DROPSOURCE_H

class CDropSource : public IDropSource {
private:
    ULONG   m_cRef;     // Reference counting information

public:
    // Constructor
    CDropSource();

    // IUnknown interface members
    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropSource specific members
    STDMETHODIMP QueryContinueDrag(BOOL, DWORD);
    STDMETHODIMP GiveFeedback(DWORD);
};

typedef CDropSource *PCDropSource;

#endif // DROPSOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\cdataobj.h ===
//**********************************************************************
// File name: cdataobj.h
//
// Definition of CImpIDataObject
// Implements the IDataObject interface required for Data transfer
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef CIMPIDATAOBJECT_H
#define CIMPIDATAOBJECT_H

class CImpIDataObject : public IDataObject {
private:
    ULONG   m_cRef;     // Reference counting information
    HWND    hWndDlg;    // Dialog handle cached for dumping Rich text
    TCHAR   m_lpszText[2];   // Pointer to text which is to be dragged

public:
    // Constructor
    CImpIDataObject(HWND hWndDlg);

    // IUnknown interface members
    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDataObject interface members
    STDMETHODIMP GetData(FORMATETC*, STGMEDIUM*);
    STDMETHODIMP GetDataHere(FORMATETC*, STGMEDIUM*);
    STDMETHODIMP QueryGetData(FORMATETC*);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC*, FORMATETC*);
    STDMETHODIMP SetData(FORMATETC*, STGMEDIUM*, BOOL);
    STDMETHODIMP EnumFormatEtc(DWORD, IEnumFORMATETC**);
    STDMETHODIMP DAdvise(FORMATETC*, DWORD, IAdviseSink*, DWORD*);
    STDMETHODIMP DUnadvise(DWORD);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA**);

    // Function which transfer data
    HRESULT RenderRTFText(STGMEDIUM* pMedium);
    HRESULT RenderPlainUnicodeText(STGMEDIUM* pMedium);
    HRESULT RenderPlainAnsiText(STGMEDIUM* pMedium);

    int SetText(LPTSTR);
};

typedef CImpIDataObject *PCImpIDataObject;

#endif // CIMPIDATAOBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\cdataobj.cxx ===
//**********************************************************************
// File name: cdataobj.cxx
//
// Definition of CImpIDataObject
// Implements the IDataObject interface required for Data transfer
//
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//       Modified RenderRTFText output procedure for charset
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>

#include "olecomon.h"
#include "enumfetc.h"
#include "cdataobj.h"
#include "uce.h"

// Chargrid supports three formats Rich Text, Plain text and Unicode text
// Of which the last two are standard and are already registered
CLIPFORMAT g_cfRichText = 0;

// List of FormatEtcs which are supported by Chargrid
// The first format is filled up in CImpIDataObject constructor
static FORMATETC g_FormatEtc[] =
{
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
};

//**********************************************************************
// CImpIDataObject::CImpIDataObject
//
// Purpose:
//      Constructor
//
// Parameters:
//      HWND hWnd           -  Dialog handle which has to be cached
//
// Return Value:
//      None
//**********************************************************************
CImpIDataObject::CImpIDataObject(HWND hWnd)
{
    // Initialise reference count to 0
    m_cRef = 1;
    hWndDlg = hWnd;
    m_lpszText[0] = 0;

    // Register Rich Text Clipboard format if necessary
    if (g_cfRichText == 0) {
        TCHAR szRTF[80];
        int iRet = LoadString(hInst, IDS_RTF, szRTF, 80);
        g_cfRichText = (CLIPFORMAT)RegisterClipboardFormat(szRTF);
//should hardcode clipboard format. we will do it after Win2K
//        g_cfRichText = (CLIPFORMAT)RegisterClipboardFormat(RTFFMT);
        g_FormatEtc[0].cfFormat = g_cfRichText;
    }
}

//**********************************************************************
// CImpIDataObject::QueryInterface
//
// Purpose:
//      Return a pointer to a requested interface
//
// Parameters:
//      REFIID riid         -   ID of interface to be returned
//      PPVOID ppv          -   Location to return the interface
//
// Return Value:
//      NOERROR             -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//**********************************************************************
STDMETHODIMP CImpIDataObject::QueryInterface(REFIID riid,
                                             PPVOID ppv)
{
    // Initialise interface pointer to NULL
    *ppv = NULL;

    // If the interface asked for is what we have set ppv
    if (riid == IID_IUnknown || riid == IID_IDataObject) {
        *ppv = this;
    }

    // Increment reference count if the interface asked for is correct
    // and return no error
    if (*ppv != NULL) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    // Else return no such interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
// CImpIDataObject::AddRef
//
// Purpose:
//      Increments the reference count for an interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CImpIDataObject::AddRef()
{
    TRACE(TEXT("In AddRef\n"));

    // Increment reference count
    return InterlockedIncrement((LONG*)&m_cRef);
}

//**********************************************************************
// CImpIDataObject::Release
//
// Purpose:
//      Decrements the reference count for the interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CImpIDataObject::Release()
{
    TRACE(TEXT("In Release\n"));

    // Decrement reference count
    InterlockedDecrement((LONG*)&m_cRef);

    // If there are no references then free current copy
    if (m_cRef == 0L) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//**********************************************************************
// CImpIDataObject::GetData
//
// Purpose:
//      Called by a data consumer to obtain data from a source data object
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                   -   Data was successfully retrieved and
//                                 placed in the storage medium provided
//      DATA_E_FORMATETC       -   Invalid value for pFormatetc
//**********************************************************************
STDMETHODIMP CImpIDataObject::GetData(FORMATETC* pFormatetc,
                                      STGMEDIUM* pMedium)
{
    SCODE   sc = DATA_E_FORMATETC; // Deflt return value data format not supported

    // Initialise the storage medium structure
    pMedium->tymed = NULL;
    pMedium->pUnkForRelease = NULL;
    pMedium->hGlobal = NULL;

    TRACE(TEXT("In GetData\n"));

    // Our CharGrid only supports drag and drop of text through global memory
    // Client wants plain text through global memory
    if (pFormatetc->cfFormat == CF_TEXT &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderPlainAnsiText(pMedium);
    }

    // Client wants Unicode text through global memory
    if (pFormatetc->cfFormat == CF_UNICODETEXT &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderPlainUnicodeText(pMedium);
    }

    // Client wants Rich Text through global memory
    if (pFormatetc->cfFormat == g_cfRichText &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderRTFText(pMedium);
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::GetDataHere
//
// Purpose:
//      Called by a consumer to obtain data with caller allocing memory
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      DATA_E_FORMATETC       -   Invalid value for pFormatetc
//**********************************************************************
STDMETHODIMP CImpIDataObject::GetDataHere(FORMATETC* pFormatetc,
                                          STGMEDIUM* pMedium)
{
    // This method says that the caller allocates and frees memory,
    // we dont support this method
    return ResultFromScode(DATA_E_FORMATETC);
}

//**********************************************************************
// CImpIDataObject::GetDataHere
//
// Purpose:
//      Determines whether the data object is capable of rendering the
//      data described in the FORMATETC structure
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//
// Return Value:
//      DV_E_FORMATETC         -   Invalid value for pFormatetc
//      S_OK                   -   Next call to GetData will be success
//**********************************************************************
STDMETHODIMP CImpIDataObject::QueryGetData(FORMATETC* pFormatetc)
{
    SCODE  sc = DV_E_FORMATETC; // dflt return value is invalid formatetc

    TRACE(TEXT("In QueryGetData\n"));

    // Our CharGrid only supports drag and drop of text through global memory

    // If the client wants text, unicode text or rich text through global memory
    // then return OK
    if (pFormatetc->cfFormat == CF_TEXT
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }
    else if (pFormatetc->cfFormat == CF_UNICODETEXT
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }
    else if (pFormatetc->cfFormat == g_cfRichText
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::GetCanonicalFormatEtc
//
// Purpose:
//      Provides a standard FORMATETC structure that is logically
//      equivalent to one that is more complex.
//
// Parameters:
//      FORMATETC* pFormatetcIn  -   Pointer to the FORMATETC structure
//      FORMATETC* pFormatetcOut -   Pointer to canonical equivalent
//
// Return Value:
//      E_NOTIMPL              -   This call is not implemented
//**********************************************************************

STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc(FORMATETC* pFormatetcIn,
                                                    FORMATETC* pFormatetcOut)
{
    // Chargrid does not support conversion of FORMATETC
    // Check for invalid input
    if (pFormatetcIn == NULL) {
        return ResultFromScode(E_INVALIDARG);
    }

    pFormatetcOut->ptd = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// CImpIDataObject::SetData
//
// Purpose:
//      Called by an object containing a data source to transfer data to
//      the object that implements this method
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//      BOOL       fRelease    -   Indicates who owns storage medium
//
// Return Value:
//      E_NOTIMPL              -   This call is not implemented
//**********************************************************************

STDMETHODIMP CImpIDataObject::SetData(FORMATETC* pFormatetc,
                                      STGMEDIUM* pMedium,
                                      BOOL       fRelease)
{
    // We do not allow another object to send data to us
    // So return error not implemented
    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// CImpIDataObject::EnumFormatEtc
//
// Purpose:
//      Creates an object for enumerating the FORMATETC structures for a data object
//
// Parameters:
//      DWORD            dwDirection     -   Pointer to the FORMATETC structure
//      IEnumFORMATETC** ppEnumFormatetc -   Pointer to canonical equivalent
//
// Return Value:
//      S_OK                             -   Enumerator object was successfully created.
//      E_NOTIMPL                        -   The direction specified by dwDirection is not supported.
//**********************************************************************
STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD            dwDirection,
                                            IEnumFORMATETC** ppEnumFormatetc)
{
    SCODE   sc = S_OK;

    *ppEnumFormatetc = NULL;

    TRACE(TEXT("In EnumFormatEtc\n"));

    // If the direction of enumeration is Get then create
    // an instance of the standard implementation of IEnumFmtEtc
    if (dwDirection == DATADIR_GET) {
        *ppEnumFormatetc = OleStdEnumFmtEtc_Create(
            sizeof(g_FormatEtc)/sizeof(g_FormatEtc[0]),
            g_FormatEtc);

        if (*ppEnumFormatetc == NULL) {
            sc = E_OUTOFMEMORY;
        }
    } else if (dwDirection == DATADIR_SET) {
        // Chargrid does not accept SetData
        sc = E_NOTIMPL;
    } else {
        // Anything else provided as direction is an error
        sc = E_INVALIDARG;
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::DAdvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::DAdvise(FORMATETC*,
                                      DWORD,
                                      IAdviseSink*,
                                      DWORD*)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::DUnadvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConnection)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::EnumDAdvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::EnumDAdvise(IEnumSTATDATA**)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::RenderRTFText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory in Rich Text format
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderRTFText(STGMEDIUM* pMedium)
{
    INT iCurrFont, iCharset, nIndex;
    FONTINFO *pFontInfo;
    TCHAR szFaceName[LF_EUDCFACESIZE];
    HANDLE hmemRTF;
    LPTSTR lpstrClipString;
    TCHAR achHeaderTmpl[] = TEXT("{\\rtf1\\ansi\\ansicpg%d {\\fonttbl{\\f0\\");
    TCHAR achHeader[sizeof(achHeaderTmpl) / sizeof(TCHAR) + 20];
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");
    INT cchUC;
    LPTSTR lpstrText;

    TRACE(TEXT("Rendering Rich Text\n"));

    lpstrText = m_lpszText;

#ifndef UNICODE_RTF
    LPWSTR pszRTFW;
#endif

#define MAXLENGTHFONTFAMILY 8
#define ALITTLEEXTRA 10    // covers extra characters + length of font size

    iCurrFont = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);
    nIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETITEMDATA, iCurrFont, 0L);
    pFontInfo = Font_pList+nIndex;
    lstrcpy(szFaceName, pFontInfo->szFaceName);
    iCharset = GetCurFontCharSet(hWndDlg);

    wsprintf(achHeader, achHeaderTmpl, (INT)(SHORT)GetACP());

    //
    //  16 times in case they're all > 7 bits (each chr -> \uc1\uddddddd\'xx)
    //  and room for the second byte of DBCS.
    //
    hmemRTF = GlobalAlloc( 0,
        CTOB(lstrlen((LPTSTR)achHeader) +
        MAXLENGTHFONTFAMILY +
        lstrlen(szFaceName) +
        lstrlen((LPTSTR)achMiddle) +
        2 * 16 * lstrlen(lpstrText) +
        ALITTLEEXTRA) );
    if (hmemRTF == NULL)
    {
        return 1;
    }

    lpstrClipString = (LPTSTR)GlobalLock(hmemRTF);

#ifndef UNICODE_RTF
    pszRTFW = lpstrClipString;
#endif

    lstrcpy(lpstrClipString, achHeader);

    // Add the correct charset string
    if (iCharset == SYMBOL_CHARSET)
    {
        lstrcat(lpstrClipString, (LPTSTR)TEXT("fnil\\fcharset2 "));
    }
    else
    {
        //
        //  Top four bits specify family.
        //
        switch (pFontInfo->PitchAndFamily & 0xf0)
        {
            case ( FF_DECORATIVE ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fdecor "));
                break;
            }
            case ( FF_MODERN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fmodern "));
                break;
            }
            case ( FF_ROMAN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("froman "));
                break;
            }
            case ( FF_SCRIPT ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fscript "));
                break;
            }
            case ( FF_SWISS ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fswiss "));
                break;
            }
            default :
            {
                TCHAR pchar[30];
                wsprintf(pchar, TEXT("fnil\\fcharset%d "), iCharset); 
                lstrcat(lpstrClipString, pchar);
                break;
            }
        }
    }

    lstrcat(lpstrClipString, szFaceName);

    lstrcat(lpstrClipString, (LPTSTR)achMiddle);

    //
    //  We need to do the text character by character, making sure
    //  that we output a special sequence \'hh for characters bigger
    //  than 7 bits long!
    //
    lpstrClipString = (LPTSTR)(lpstrClipString + lstrlen(lpstrClipString));

    cchUC = 0;
    char achTmp[2];
    char *pTmp = achTmp;
    int cch;

    while (*lpstrText)
    {
      cch = ConvertUnicodeToAnsiFont(hWndDlg, lpstrText, pTmp);
            //
            // Put in a \uc# to tell Unicode reader how many bytes to skip
            // and the \uN code to indicate the real unicode value.
            //
            if (cch != cchUC )
            {
                cchUC = cch;
                lpstrClipString += wsprintf( lpstrClipString,
                    TEXT("\\uc%d"),
                    (INT)(SHORT)cchUC );
            }

            lpstrClipString += wsprintf( lpstrClipString,
                TEXT("\\u%d"),
                (INT)(SHORT)*lpstrText );

            //
            //  Now put the \'xx string in to indicate the actual character.
            //
            lpstrText++;
            while (cch--)
            {
                *lpstrClipString++ = TEXT('\\');
                *lpstrClipString++ = TEXT('\'');
                wsprintf(achMiddle, TEXT("%x"), (INT)*pTmp++);
                *lpstrClipString++ = achMiddle[0];
                *lpstrClipString++ = achMiddle[1];
            }
    }
    *lpstrClipString++ = TEXT('}');
    *lpstrClipString++ = TEXT('\0');

#ifndef UNICODE_RTF
    {
        //
        //  RTF is only defined for ANSI, not for Unicode, therefore
        //  we need to convert the buffer before we put it on the
        //  clipboard.  Eventually, we should add autoconversion code
        //  to USER to handle this for us.
        //
        int cch;
        HANDLE hmemRTFA;
        LPSTR pszRTFA;

        cch = WideCharToMultiByte( CP_ACP,
            0,
            pszRTFW,
            (int)(lpstrClipString - pszRTFW),
            NULL,
            0,
            NULL,
            NULL );

        if (cch != 0 &&
            (hmemRTFA = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,cch)) != NULL)
        {
            pszRTFA = (char*)GlobalLock(hmemRTFA);

            WideCharToMultiByte( CP_ACP,
                0,
                pszRTFW,
                (int)(lpstrClipString - pszRTFW),
                pszRTFA,
                cch,
                NULL,
                NULL );

            GlobalUnlock(hmemRTFA);
            GlobalUnlock(hmemRTF);
            GlobalFree(hmemRTF);

            hmemRTF = hmemRTFA;
        }
    }
#endif

    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hmemRTF;

    return S_OK;
}

//**********************************************************************
// CImpIDataObject::RenderPlainAnsiText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory as Ansi Text
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderPlainAnsiText(STGMEDIUM* pMedium)
{
    HGLOBAL hText;
    LPSTR   pszText;
    int     nChars;

    TRACE(TEXT("Rendering plain ANSI text\n"));

    // Convert currently selected character from Wide Char to Multibyte
    nChars = WideCharToMultiByte(CP_ACP,
        0,
        m_lpszText,  // the currently selected character
        wcslen(m_lpszText),
        NULL,
        0,
        NULL,
        NULL );

    hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT, nChars+1);

    if (!hText) {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy the text to the global memory
    pszText = (LPSTR)GlobalLock(hText);
    nChars = WideCharToMultiByte(CP_ACP,
        0,
        m_lpszText,  // the currently selected character
        wcslen(m_lpszText),
        pszText,
        nChars+1,
        NULL,
        NULL);

    GlobalUnlock(hText);

    // Set the storage medium by which data is transferred as global memory
    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hText;

    return S_OK;
}

//**********************************************************************
// CImpIDataObject::RenderPlainUnicodeText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory as Unicode characters
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderPlainUnicodeText(STGMEDIUM* pMedium)
{
    HGLOBAL hText;
    LPTSTR  pszText;

    TRACE(TEXT("Rendering plain unicode text\n"));

    hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT,
        sizeof(WCHAR) * (wcslen(m_lpszText)+1));

    if (!hText) {
        TRACE(TEXT("Unable to alloc global memory\n"));
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy the text to the global memory
    pszText = (LPTSTR)GlobalLock(hText);
    wcscpy(pszText, m_lpszText);
    GlobalUnlock(hText);

    // Set the storage medium by which data is transferred as global memory
    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hText;

    return S_OK;
}


//**********************************************************************
// CImpIDataObject::SetText
//
// Purpose:
//      Sets the local pointer for text to be copied
//
// Parameters:
//      LPTSTR  lpszText    -   Pointer to text
//
// Return Value:
//      0                   -   Success
//**********************************************************************
int CImpIDataObject::SetText(LPTSTR lpszText)
{
    lstrcpy(m_lpszText, lpszText);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\cdropsrc.cxx ===
//**********************************************************************
// File name: cdropsrc.cxx
//
// Implementation file for CDropSource
// Implements the IDropSource interface required for an application to
// act as a Source in a drag and drop operation
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>

#include "olecomon.h"
#include "cdropsrc.h"

//**********************************************************************
// CDropSource::CDropSource
//
// Purpose:
//      Constructor
//
// Parameters:
//      None
// Return Value:
//      None
//**********************************************************************
CDropSource::CDropSource()
{
    TRACE(TEXT("Creating New Drop SOurce\n"));
    // Initialise reference count to 0
    m_cRef = 1;
}

//**********************************************************************
// CDropSource::QueryInterface
//
// Purpose:
//      Return a pointer to a requested interface
//
// Parameters:
//      REFIID riid         -   ID of interface to be returned
//      PPVOID ppv          -   Location to return the interface
//
// Return Value:
//      NOERROR             -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//**********************************************************************
STDMETHODIMP CDropSource::QueryInterface(REFIID riid,
                                         PPVOID ppv)
{
    // Initialise interface pointer to NULL
    *ppv = NULL;

    // If the interface asked for is what we have set ppv
    if (riid == IID_IUnknown || riid == IID_IDropSource) {
        *ppv = this;
    }

    // Increment reference count if the interface asked for is correct
    // and return no error
    if (*ppv != NULL) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    // Else return no such interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
// CDropSource::AddRef
//
// Purpose:
//      Increments the reference count for an interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::AddRef()
{
    // Increment reference count
    return InterlockedIncrement((LONG*)&m_cRef);
}


//**********************************************************************
// CDropSource::Release
//
// Purpose:
//      Decrements the reference count for the interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::Release()
{
    ULONG   ulTempCount;

    // Decrement reference count
    InterlockedDecrement((LONG*)&m_cRef);
    ulTempCount = m_cRef;

    // If there are no references then free current copy
    if (m_cRef == 0L) {
        delete this;
    }

    return ulTempCount;
}

//**********************************************************************
// CDropSource::QueryContinueDrag
//
// Purpose:
//      Determines whether a drag-and-drop operation should be continued,
//      canceled, or completed
//
// Parameters:
//      BOOL fEsc           -   Status of escape key since previous call
//      DWORD grfKeyState   -   Current state of keyboard modifier keys
//
// Return Value:
//      DRAGDROP_S_CANCEL   -   Drag operation is to be cancelled
//      DRAGDROP_S_DROP     -   Drop operation is to be completed
//      S_OK                -   Drag operation is to be continued
//**********************************************************************
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc,
                                            DWORD grfKeyState)
{
    // If escape key is pressed stop drag and drop
    if (fEsc) {
        return ResultFromScode(DRAGDROP_S_CANCEL);
    }

    // If LButton is up then complete the drag operation
    if (!(grfKeyState & MK_LBUTTON)) {
        return ResultFromScode(DRAGDROP_S_DROP);
    }

    return ResultFromScode(S_OK);
}

//**********************************************************************
// CDropSource::GiveFeedback
//
// Purpose:
//      Enables a source application to give visual feedback to the end
//      user during a drag-and-drop
//
// Parameters:
//      DWORD dwEffect      -   Effect of a drop operation
//
// Return Value:
//      DRAGDROP_S_USEDEFAULTCURSORS    -   Use default cursors
//**********************************************************************
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\codepage.cxx ===
/****************************************************************************

    CodePage.c

    PURPOSE : Codepage related utilities for Universal Character Explorer

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

BOOL CodePage_AddToList(LONG);

LONG *CodePage_pList       = NULL;
INT  CodePage_nCount       = 0;
LONG CodePage_lCurCodePage = 0;

/****************************************************************************

    Function : Enumerate code page callback function.

****************************************************************************/
BOOL
CALLBACK EnumCodePagesProc(
    LPTSTR lpCodePageString
    )
{
    LONG  lCodePageNum;
    TCHAR szBuf[256];

    lCodePageNum = _wtol(lpCodePageString);

    if(!IsValidCodePage(lCodePageNum))
    {
        return TRUE;
    }
    if(LoadString(hInst, lCodePageNum, szBuf, sizeof(szBuf)/sizeof(TCHAR)) == 0)
    {
        return TRUE;
    }

    CodePage_AddToList(lCodePageNum);
    return TRUE;
}

/****************************************************************************

    Function : Delete this list.

****************************************************************************/
BOOL
CodePage_DeleteList()
{
    free(CodePage_pList);
    CodePage_pList  = NULL;
    CodePage_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Function : initialize list

****************************************************************************/
BOOL
CodePage_InitList()
{
    if (CodePage_pList)
    {
        CodePage_DeleteList();
    }

    CodePage_pList  = NULL;
    CodePage_nCount = 0;

    //
    // we need 1200 (Unicode codepage) that EnumSystemCodePages won't give us
    //
    CodePage_AddToList(UNICODE_CODEPAGE);

    EnumSystemCodePages((CODEPAGE_ENUMPROC)EnumCodePagesProc, CP_INSTALLED);

    return TRUE;
}

/***************************************************************************

    Function : Add a code page value to list.

****************************************************************************/
BOOL
CodePage_AddToList(
    LONG lCodePage
    )
{
    int   i, j;
    WCHAR wcBuf[256];
    WCHAR wcBufNew[256];


    if (CodePage_pList == NULL)
    {
        CodePage_pList = (LONG *) malloc(sizeof(LONG));
        if (CodePage_pList == NULL)
        {
            return FALSE;
        }
        CodePage_pList[CodePage_nCount] = lCodePage;
    }
    else
    {
        CodePage_pList = (LONG *) realloc(CodePage_pList,
                                          sizeof(LONG)*(CodePage_nCount+1));
        if (CodePage_pList == NULL)
        {
            return FALSE;
        }

        LoadString(hInst, lCodePage, wcBufNew, sizeof(wcBufNew)/sizeof(WCHAR));
        for(i = 1; i < CodePage_nCount; i++)
        {
            LoadString(hInst, CodePage_pList[i], wcBuf, sizeof(wcBuf)/sizeof(WCHAR));
            if(CompareString(LOCALE_USER_DEFAULT, 0, wcBufNew, -1,  wcBuf, -1) == 1) break;
        }

        for(j = CodePage_nCount; j > i; j--)
        {
            CodePage_pList[j] = CodePage_pList[j-1];
        }
        CodePage_pList[i] = lCodePage;
    }

    CodePage_nCount++;
    return TRUE;
}

/****************************************************************************

    Function : Fill a combobox with code pages.

****************************************************************************/
BOOL
CodePage_FillToComboBox(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(
        hCombo,
        CB_RESETCONTENT,
        0,
        0 );

    for (i=0; i < CodePage_nCount; i++)
    {
       int   nIndex;
       TCHAR szBuf[256];

       if (CodePage_pList[i] == UNICODE_CODEPAGE)
       {
           LoadString(hInst,IDS_UNICODE,szBuf,sizeof(szBuf)/sizeof(TCHAR));
           nIndex = (int)SendMessage(
                        hCombo,
                        CB_ADDSTRING,
                        (WPARAM) 0,
                        (LPARAM) szBuf);
           if(nIndex != CB_ERR)
           {
               SendMessage(
                   hCombo,
                   CB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) CodePage_pList[i]);
           }
       }
       else
       {
           LoadString(hInst, CodePage_pList[i], szBuf, sizeof(szBuf)/sizeof(TCHAR));
           SendMessage(
               hCombo,
               CB_ADDSTRING,
               (WPARAM) 0,
               (LPARAM) szBuf);
       }
    }

    return TRUE;
}

/****************************************************************************

    Function : Get current selected codepage

/****************************************************************************/
LONG CodePage_GetCurSelCodePage(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nIndex;
    LONG lCodePage;

    if (hCombo == NULL)
    {
        return 0;
    }

    nIndex = (INT)SendMessage(
                hCombo,
                CB_GETCURSEL,
                (WPARAM) 0,
                (LPARAM) 0L);

    if (nIndex == CB_ERR)
    {
        return 0L;
    }

    lCodePage = CodePage_pList[nIndex];

    CodePage_lCurCodePage = lCodePage;
    return lCodePage;
}

/****************************************************************************

    Function : get current codepage value

/****************************************************************************/
LONG CodePage_GetCurCodePageVal()
{
   return CodePage_lCurCodePage;
}


/****************************************************************************

    Function : Set current codepage

/****************************************************************************/
// Set to this code page, if possible and return result of operation
BOOL CodePage_SetCurrent( LONG lCodePage , HWND hWnd , UINT uID )
{
  INT   i;
  HWND  hCombo = (HWND) GetDlgItem(hWnd,uID);
  DWORD dwResult;
  BOOL  bRet=FALSE;



  for( i=0; i<CodePage_nCount; i++)
  {
    if (CodePage_pList[i] == lCodePage)  // got a match
    {
      dwResult = (DWORD)SendMessage( hCombo,
                                     CB_SETCURSEL,
                                     (WPARAM) i,
                                     (LPARAM) 0L);
      if( CB_ERR != dwResult )
          bRet=TRUE;
    }
  }

  return bRet;
}

/****************************************************************************

    Function : Is this codepage on our list ?

/****************************************************************************/
BOOL
IsCodePageOnList(
    WORD wCodePage
    )
{
    int i = CodePage_nCount;

    while(i--)
    {
      if(CodePage_pList[i] == wCodePage)
          return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\cmdlg.h ===
/********************************************************************
 *
 *  Header Name : cmdlg.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 *
 ********************************************************************/

#ifndef __CMLG_H__
#define __CMLG_H__

#define ID_HELP                     100
#define ID_CLOSE                    101
#define ID_COPY                     102
#define ID_SELECT                   103
#define ID_STRING                   104
#define ID_FONT                     105
#define ID_TOPLEFT                  107
#define ID_CHARGRID                 108
#define ID_SUBSET                   109
#ifndef IDC_EDIT
#define IDC_EDIT                    1000
#endif

#define ID_ADVANCED                 119

#define IDBM_TT                     110

#define IDIC_UCE                    111

#define IDS_HELP                    112
#define IDS_RTF                     113
#define IDS_GROUPBY                 114
#define IDS_SYMBOLSET               115
#define IDS_EUDC                    116
#define IDS_ALT                     117
#define IDS_ALLFONTS                118

#define ID_CTLHOME                  121
#define ID_CTLEND                   122
#define ID_CTLLEFT                  123
#define ID_CTLRIGHT                 124
#define ID_CTLUP                    125
#define ID_CTLDOWN                  126
#define ID_CTLPRIOR                 127
#define ID_CTLNEXT                  128
#define ID_VIEWLB                   129
#define ID_VIEW                     130

#define ID_SEARCHNAME               131
#define ID_SEARCHINPUT              132
#define ID_SEARCH                   133
#define ID_STOPSEARCH               134
#define ID_FROMSPIN                 136
#define ID_FROMLB                   137
#define ID_TOTEXT                   138
#define ID_TOSPIN                   139
#define ID_FONTLB                   141
#define ID_APPLY                    142

#define ID_LISTBOX                  301
#define ID_GRID_HSCROLL             302
#define ID_GRID_VSCROLL             303

#define IDS_UNICODE                 300
#define IDS_NOCHARFOUND             400
#define IDS_SEARCH                  403
#define IDS_RESET                   405

#define IDS_ALL                     7001

#define ID_SUBSETLB                 201
#define ID_UNICODESUBSET            202
#define ID_NEXTSUBSET               203
#define ID_MAPSCROLL                204
#define ID_PREVSUBSET               205
#define ID_SEARCHSEL                206
#define IDM_COPY                    207
#define IDM_SEND                    208
#define IDM_FONT1                   209
#define IDM_FONT2                   210
#define IDM_FONT3                   211

#define ID_URANGE                   700
#define ID_FROM                     701
#define ID_FROMLABLE                702
#define ID_TO                       703
#define ID_TOLABLE                  704
#define ID_SURCONTROLS              705
#define ID_STATIC                   706

#endif  // __CMLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\display.cxx ===
/****************************************************************************

    Display.c

    PURPOSE: manage dispaly buffer for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

LPWSTR Display_pList  = NULL;
INT    Display_nCount = 0;

/****************************************************************************

    Display_DeleteList

****************************************************************************/
BOOL
Display_DeleteList()
{
    if (Display_pList)
    {
        free(Display_pList);
    }
    Display_pList  = NULL;
    Display_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Display_InitList

****************************************************************************/
BOOL
Display_InitList()
{
    Display_pList = NULL;
    Display_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Display_IsInCMapTable
    Optimised verion using binary search [v-nirnay]  Dec 25, 1997

****************************************************************************/
__inline BOOL
Display_IsInCMapTable(
    WCHAR  wCode,
    URANGE *pFontCMapTab,
    UINT    uFontCMapTabNum
    )
{
    INT uFirst=0, uLast=uFontCMapTabNum, uMiddle;
    BOOL fFound=FALSE;

    while ((uFirst <= uLast) && (fFound == FALSE))
    {
        uMiddle = (uFirst + uLast) / 2;
        if ((wCode >= pFontCMapTab[uMiddle].wcFrom) &&
            (wCode <= pFontCMapTab[uMiddle].wcTo))
        {
            fFound = TRUE;
        }
        else if (pFontCMapTab[uMiddle].wcFrom < wCode)
        {
            uFirst = uMiddle + 1;
        }
        else
        {
            uLast = uMiddle - 1;
        }
    }

    return fFound;
}

extern INT cchSymRow;

/****************************************************************************

    Display_CreateDispBuffer

****************************************************************************/
LPWSTR
Display_CreateDispBuffer(
    LPWSTR lpszSubsetChars,
    INT    nSubsetChars,
    URANGE *pCMapTab,
    INT    nNumofCMapTab,
    BOOL   bSubstitute )
{
    INT i,j;

    Display_DeleteList();

    if(nSubsetChars == 0)
    {
        return NULL;
    }

    Display_pList = (LPWSTR) malloc(sizeof(WCHAR) * (nSubsetChars + 1));
    if (! Display_pList)
    {
        return NULL;
    }

    if(lpszSubsetChars != NULL)
    {
        // Split so that bsubs does not burden normal loading process
        if (!bSubstitute)
        {
            for (i=0,j=0; i<nSubsetChars; i++)
            {
                if (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab))
                {
                    Display_pList[j] =  lpszSubsetChars[i];
                    j++;
                }
            }
            Display_pList[j] = (WCHAR)0;
        }
        else
        {
            for (i=0,j=0; i<nSubsetChars; i++)
            {
                // If character is space it means we have reached end of
                // line if there are no valid characters on this line
                // proceed, else fill up all characters from current
                // point to end of column with spaces. Skip all the
                // spaces in input buffer
                if ( (lpszSubsetChars[i] != (WCHAR)0x20 )
                && (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab)) )
                {
                    Display_pList[j] =  lpszSubsetChars[i];
                    j++;
                }
                else  // This is a hack for the grid control
                {
                    if( IsAnyListWindow() && (lpszSubsetChars[i] == (WCHAR)0x20))
                    {
                        DWORD dwLeft = ((j)%cchSymRow);
                        if (dwLeft == 0L)
                            continue;
                        dwLeft = cchSymRow - dwLeft;
                        while (dwLeft)
                        {
                            Display_pList[j] =  (WCHAR)' ';
                            j++; dwLeft--;
                        }
                        while ( (i < nSubsetChars) && (lpszSubsetChars[i] ==
                          (WCHAR)0x20) )
                        {
                            i++;
                        }
			i--;
                    }
                }
            }
            Display_pList[j] = (WCHAR)0;
        }
    }

    return Display_pList;
}

/****************************************************************************

    Display_CreateSubsetDispBuffer

****************************************************************************/
LPWSTR
Display_CreateSubsetDispBuffer(
    LPWSTR lpszSubsetChars,
    INT    nSubsetChars,
    URANGE *pCMapTab,
    INT    nNumofCMapTab,
    BOOL   bSubstitute,
    int    iFrom,
    int    iTo )
{
    INT i,j, nChars;

    Display_DeleteList();

    if(nSubsetChars == 0)
    {
        return NULL;
    }

    nChars = min(nSubsetChars, (iTo-iFrom+2));

    Display_pList = (LPWSTR) malloc(sizeof(WCHAR) * nChars);
    if (! Display_pList)
    {
        return NULL;
    }

    if(lpszSubsetChars != NULL)
    {
        i = 0;
        while ((i<nSubsetChars) && (lpszSubsetChars[i] < iFrom))
        {
            i++;
        }

        j = 0;
        while ((i<nSubsetChars) && (lpszSubsetChars[i] <= iTo))
        {
            if (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab))
            {
                Display_pList[j] =  lpszSubsetChars[i];
                j++;
            }
            else  // This is a hack for the grid control
            {
                if( bSubstitute && IsAnyListWindow() )
                {
                    Display_pList[j] = (WCHAR)' ';
                    j++;
                }
            }
            i++;
        }

        Display_pList[j] = (WCHAR)0;
    }

    return Display_pList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\helpids.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef HELPIDS_H
#define HELPIDS_H

#define IDH_UCE_SELECT                  103
#define IDH_UCE_COPY                    102
#define IDH_UCE_FONT                    105
#define IDH_UCE_ADVANCED                119
#define IDH_UCE_CHARSET                 130
#define IDH_UCE_SEARCHBYGROUP           202
#define IDH_UCE_SEARCHBYNAME            132
#define IDH_UCE_SEARCHRESET             133
#define IDH_UCE_COPYCHAR                104
#define IDH_UCE_GRIDCHAR                100
#define IDH_UCE_HELPBUTTON              135
#define IDH_UCE_GOTOUNICODE             140

#endif // HELPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\font.cxx ===
/****************************************************************************

    font.c

    PURPOSE: manage fonts for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */

#define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
#define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

#define SWAPW(a)        ((short) FS_2BYTE( (unsigned char *)(&a) ))
#define SWAPL(a)        ((long) FS_4BYTE( (unsigned char *)(&a) ))

FONTINFO *Font_pList  = NULL;
INT       Font_nCount = 0;

//
// kd.c
//

/****************************************************************************

  Font_EnumProc

****************************************************************************/
INT APIENTRY
Font_EnumProc(
    LPLOGFONT lpLogFont,
    NEWTEXTMETRICEX *lpTextMetric,
    int    nFontType,
    LPARAM hWnd)
{
    DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
    DWORD   FontType = 0;
    URANGE *pUniRange;
    DWORD   dwSize = 0;

    // excludes FE @ font
    if(lpLogFont->lfFaceName[0] == L'@') return (1);

//OEM FONT, BITMAP FONT will be treated as SYMBOL FONT
/*
    if(lpLogFont->lfCharSet == OEM_CHARSET)
    {
        if(lstrcmpi(lpLogFont->lfFaceName, L"Terminal") == 0)
        {
            FontType = OEM_FONTTYPE;
        }
    }
*/

    if (ntmFlags & NTM_PS_OPENTYPE)
    {
        FontType = PS_OPENTYPE_FONTTYPE;
    }
    else if (ntmFlags & NTM_TYPE1)
    {
        FontType = TYPE1_FONTTYPE;
    }
    else if (nFontType & TRUETYPE_FONT)
    {
        if (ntmFlags & NTM_TT_OPENTYPE)
            FontType = TT_OPENTYPE_FONTTYPE;
        else
            FontType = TRUETYPE_FONT;
    }
    else
    {
        FontType |= SYMBOL_FONTTYPE;
    }

    if(lpLogFont->lfCharSet == SYMBOL_CHARSET)
    {
        FontType |= SYMBOL_FONTTYPE;
    }

//
//SYMBOL/OEM/BITMAP FONT get the ANSI code points, we have to
//use ConvertAnsifontToUnicode later when we display them.
//
    if(FontType & SYMBOL_FONTTYPE)
    {
        pUniRange = (URANGE *) malloc (sizeof(URANGE));
        if (pUniRange)
        {
            pUniRange[0].wcFrom = 0x0021;
            pUniRange[0].wcTo   = 0x00FF;
            dwSize = 1;
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }

    }
/* treat OEM/BITMAP as SYMBOL
    else if(FontType & OEM_FONTTYPE)
    {
        dwSize = URanges(CP_OEMCP, NULL);
        pUniRange = (URANGE *) malloc (sizeof(URANGE) * dwSize);
        if (pUniRange)
        {
            URanges(CP_OEMCP, pUniRange);
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
    else if(FontType == 0)                                 // BitMap font
    {
        UINT cp = 0;

        if(lpLogFont->lfCharSet != OEM_CHARSET)
        {
           cp = CharSetToCodePage(lpLogFont->lfCharSet);
        }

        dwSize = URanges(cp, NULL);
        pUniRange = (URANGE *) malloc (sizeof(URANGE) * dwSize);
        if (pUniRange)
        {
            URanges(cp, pUniRange);
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
*/
    else if((FontType &  PS_OPENTYPE_FONTTYPE) ||
            (FontType &  TYPE1_FONTTYPE))
    {
        pUniRange = (URANGE *) malloc (sizeof(URANGE));
        if (pUniRange)
        {
            pUniRange[0].wcFrom = 0x0021;
            pUniRange[0].wcTo   = 0xFFFF;
            dwSize = 1;
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
    else    // TT_OPENTYPE_FONTTYPE || TRUETYPE_FONT
    {
        HFONT  hFontOld;
        LPVOID lpvBuffer = NULL;
        LPBYTE lp, lp1, lp2;
        DWORD  cbData;
        DWORD  dwTag = tag_CharToIndexMap;
        WORD   Num, i;
        HDC    hdc = GetWindowDC((HWND)hWnd);

        HFONT hFont = CreateFontIndirect(lpLogFont);
        hFontOld = (HFONT) SelectObject(hdc, hFont);
        dwTag = SWAPL(dwTag);
        if(!(cbData = GetFontData(hdc, dwTag, 0, NULL, 0)))
        {
            goto Close;
        }
        if(!(lpvBuffer = (LPVOID) malloc (cbData)))
        {
            goto Close;
        }
        GetFontData(hdc, dwTag, 0, lpvBuffer, cbData);

        Num = TWO_BYTE_NUM(((CMAP_HEAD*)lpvBuffer)->NumTables);
        lp1 = (BYTE*) ((BYTE*)lpvBuffer + sizeof(CMAP_HEAD));

        while(Num >0)
        {
          if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM)
//           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING
          {
             lp = (BYTE*)
                  lpvBuffer
                  + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

             if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
             {
                break;
             }
          }
          Num--;
          lp1 += sizeof(CMAP_TABLE);
        }

        if(Num == 0)                   // can't find Platform:3/Encoding:1 (Unicode)
        {
            goto Close;
        }

        Num  = (TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2));
        dwSize = Num>>1;
        pUniRange = (URANGE *) malloc (sizeof(URANGE)*dwSize);
        if (!pUniRange)
        {
            goto Close;
        }

        lp2  = lp  + sizeof(CMAP_FORMAT);        // lp2 -> first WCHAR of wcTo
        lp1  = lp2 + Num + 2;                    // lp1 -> first WCHAR of wcFrom
        for(i = 0; i < Num; i++, i++)
        {
            pUniRange[i>>1].wcFrom = TWO_BYTE_NUM((lp1+i));
            pUniRange[i>>1].wcTo   = TWO_BYTE_NUM((lp2+i));
        }

        //
        // Some fonts put glyphs in U+F000-F0FF,
        // It should be marked as a Symbol font as well.
        // For example, Guttman Adi (a Hebrew font from Office).
        //

        if( dwSize <= 2 &&
           (pUniRange[0].wcFrom >= 0xF000) &&
           (pUniRange[0].wcFrom <= 0xF0FF) )
        {
            if (pUniRange[0].wcFrom  < 0xF021)
            {
                pUniRange[0].wcFrom  = 0x0021;
            }
            else
            {
                pUniRange[0].wcFrom &= 0x00FF;
            }

            pUniRange[0].wcFrom &= 0x00FF;
            pUniRange[0].wcTo   &= 0x00FF;
            if(pUniRange[0].wcFrom < 0x0021)
               pUniRange[0].wcFrom = 0x0021;
            FontType |= SYMBOL_FONTTYPE;
        }

Close:
        DeleteObject(hFont);
        if(lpvBuffer) free(lpvBuffer);
        SelectObject(hdc, hFontOld);
        ReleaseDC((HWND)hWnd, hdc);
        if(dwSize == 0) return (1);
    }

    if (!Font_AddToList(lpLogFont, FontType, pUniRange, dwSize))
    {
        //
        // error message, add data error
        //
    }

    return (1);
}

/****************************************************************************

  EUDC_Fonts

****************************************************************************/
BOOL
EUDC_Fonts(LPLOGFONT lpLogFont)
{
    TCHAR EudcReg[] = TEXT("EUDC");
    TCHAR szFaceName[LF_EUDCFACESIZE];
    DWORD dwValue;
    TCHAR szFontFile[MAX_PATH];
    TCHAR szExpandedFontFile[MAX_PATH];
    DWORD dwData;
    DWORD dwType;
    LONG  Success;
    HKEY  hKey;
    int   i;

    DWORD    dwSize;
    URANGE  *pUniRange;

    HKEY  hKeyEUDC;
//    DWORD dwIndex;
    BOOL  bEUDC_TTE = FALSE;          // include EUDC.TTE only once

    Success = RegOpenKeyEx(
                  HKEY_CURRENT_USER,
                  EudcReg,
                  0,
                  KEY_READ,
                  &hKeyEUDC);
    if(Success != ERROR_SUCCESS) return FALSE;

// only display fonts of the current codepage.
//    for (dwIndex=0; ;dwIndex++)
    {
        TCHAR    szName[8];
        DWORD    cbName = sizeof(szName);
        wsprintf(szName,TEXT("%d"),GetACP());
        /*
        Success = RegEnumKeyEx( hKeyEUDC, dwIndex,
                                szName, &cbName,
                                NULL, NULL, NULL,
                                &ft );
        if(Success != ERROR_SUCCESS)
        {
          RegCloseKey(hKeyEUDC);
          return TRUE;
          //  break;
        }
        */
        Success = RegOpenKeyEx( hKeyEUDC,
                                szName,
                                0,
                                KEY_READ,
                                &hKey );
        if(Success != ERROR_SUCCESS)
        {
          RegCloseKey(hKeyEUDC);
          return TRUE;
          //  break;
        }

        for (i=0; ;i++)
        {
            dwValue = sizeof(szFaceName)/sizeof(TCHAR);
            dwData  = sizeof(szFontFile);

            Success = RegEnumValue(
                          hKey,
                          i,
                          szFaceName,
                          &dwValue,
                          NULL,
                          &dwType,
                          (LPBYTE)szFontFile,
                          &dwData
                      );
            if(Success != ERROR_SUCCESS)
            {
                break;
            }

            if(lstrcmpi(szFaceName, L"SystemDefaultEUDCFont") == 0)
            {
                if(bEUDC_TTE) continue;
                bEUDC_TTE = TRUE;
            }

            ExpandEnvironmentStrings(szFontFile, szExpandedFontFile, MAX_PATH);

            /*
             * if this is not 'full path'. Build 'full path'.
             *
             *   EUDC.TTE -> C:\WINNT40\FONTS\EUDC.TTE
             *
             * 1. filename should have drive letter.
             * 2. filename should have one '\\' ,at least, for root.
             */
            if ((szExpandedFontFile[1] != _T(':')) ||
                (_tcsstr(szExpandedFontFile, _T("\\")) == NULL)) {
                TCHAR tmp[MAX_PATH];
                lstrcpy(tmp, szExpandedFontFile);
                GetSystemWindowsDirectory(szExpandedFontFile, MAX_PATH);
                lstrcat(szExpandedFontFile, _T("\\FONTS\\"));
                lstrcat(szExpandedFontFile, tmp);
            }

            pUniRange = EUDC_Range(szExpandedFontFile, &dwSize);

            if (!pUniRange)
            {
              if((lstrcmpi(szFaceName, L"SystemDefaultEUDCFont") == 0) &&
                  bEUDC_TTE)
              bEUDC_TTE = false;
              continue;
            }

            lstrcpy(lpLogFont->lfFaceName, szFaceName);
            if (!Font_AddToList(lpLogFont, EUDC_FONTTYPE | TRUETYPE_FONT,
                                pUniRange, dwSize))
            {
                //
                // error message, add data error
                //
            }
        }
        RegCloseKey(hKey);
    }

    RegCloseKey(hKeyEUDC);
    return TRUE;
}

/****************************************************************************

    Function : Delete this list.

****************************************************************************/
BOOL
Font_DeleteList()
{
    INT i;

    for (i=0; i<Font_nCount; i++)
    {
        if (Font_pList[i].pUniRange)
        {
            free(Font_pList[i].pUniRange);
            Font_pList[i].pUniRange = NULL;
        }
    }
    free(Font_pList);
    Font_pList  = NULL;
    Font_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Function : Font_InitList

****************************************************************************/
BOOL
Font_InitList(HWND hWnd)
{
    LOGFONT lf;
    HDC     hDC;

    if (Font_pList)
    {
        Font_DeleteList();
    }

    Font_pList  = NULL;
    Font_nCount = 0;

    hDC = GetWindowDC(hWnd);

    lf.lfCharSet = 1;
    lf.lfFaceName[0] = 0;
    lf.lfPitchAndFamily = 0;
    EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC) Font_EnumProc, (LPARAM) hWnd, 0);
    ReleaseDC(hWnd, hDC);

    EUDC_Fonts(&lf);

    return TRUE;
}

/****************************************************************************

    Function : Font_AddToList

****************************************************************************/
BOOL
Font_AddToList(
    LPLOGFONT lpLogFont,
    DWORD    FontType,
    URANGE  *pUniRange,
    INT     nNumofUniRange
    )
{
    if (Font_pList == NULL)
    {
        Font_pList = (FONTINFO *)  malloc(sizeof(FONTINFO));
        if (Font_pList == NULL)
        {
            return FALSE;
        }
    }
    else
    {
        int i;

        if(!(FontType & EUDC_FONTTYPE))
        {
            for(i = 0; i < Font_nCount; i++)
            {
                if(lstrcmpi(Font_pList[i].szFaceName, lpLogFont->lfFaceName) == 0)
                {
                    if((lpLogFont->lfCharSet >  Font_pList[i].CharSet) &&      // BUGBUG
                       (lpLogFont->lfCharSet == SHIFTJIS_CHARSET    ||
                        lpLogFont->lfCharSet == CHINESEBIG5_CHARSET ||
                        lpLogFont->lfCharSet == GB2312_CHARSET      ||
                        lpLogFont->lfCharSet == HANGEUL_CHARSET       ))
                    {
                        Font_pList[i].CharSet = lpLogFont->lfCharSet;
                    }
                    return FALSE;
                }
            }
        }

        Font_pList = (FONTINFO *) realloc(Font_pList,
                                      sizeof(FONTINFO)*(Font_nCount+1));
        if (Font_pList == NULL)
        {
            return FALSE;
        }
    }

    lstrcpy(Font_pList[Font_nCount].szFaceName, lpLogFont->lfFaceName);
    Font_pList[Font_nCount].CharSet = lpLogFont->lfCharSet;
    Font_pList[Font_nCount].FontType = FontType;
    Font_pList[Font_nCount].PitchAndFamily = FF_DONTCARE;
    Font_pList[Font_nCount].pUniRange = pUniRange;
    Font_pList[Font_nCount].nNumofUniRange = nNumofUniRange;
    Font_nCount++;

    return TRUE;
}

/****************************************************************************

    Function : Font_FillToComboBox

****************************************************************************/
BOOL
Font_FillToComboBox(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;
    INT  nIndex;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(
        hCombo,
        CB_RESETCONTENT,
        0,
        0);

    for (i=0; i < Font_nCount; i++)
    {
        WCHAR  wcBuf[LF_EUDCFACESIZE];
				//bug #234220
        WCHAR  wcBuf1[LF_EUDCFACESIZE];

        if(((Font_pList[i].FontType & TRUETYPE_FONT) ||
            (Font_pList[i].FontType & TT_OPENTYPE_FONTTYPE)) &&
            (Font_pList[i].CharSet == SHIFTJIS_CHARSET    ||
             Font_pList[i].CharSet == CHINESEBIG5_CHARSET ||
             Font_pList[i].CharSet == GB2312_CHARSET      ||
             Font_pList[i].CharSet == HANGEUL_CHARSET)      )
        {
             Font_pList[i].FontType |= DBCS_FONTTYPE;
        }

        lstrcpy(wcBuf, Font_pList[i].szFaceName);
        if(Font_pList[i].FontType & EUDC_FONTTYPE)
        {
           if(lstrcmpi(Font_pList[i].szFaceName, L"SystemDefaultEUDCFont") == 0)
           {
              LoadString(hInst, IDS_ALLFONTS, wcBuf, LF_EUDCFACESIZE);
           }

           LoadString(hInst, IDS_EUDC, wcBuf1, LF_EUDCFACESIZE);
           lstrcat(wcBuf, wcBuf1);
        }

        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_ADDSTRING,
                     (WPARAM) 0,
                     (LPARAM) wcBuf);

        if (nIndex != CB_ERR)
        {
            SendMessage(
                hCombo,
                CB_SETITEMDATA,
                (WPARAM) nIndex,
                (LPARAM) i);
        }
    }
    return TRUE;
}

/****************************************************************************

    Function : Font_GetSelFontCharSet

****************************************************************************/
BYTE
Font_GetSelFontCharSet(
    HWND hWnd,
    UINT uID,
    INT  nIndex
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;

    if (hCombo == NULL)
    {
        return DEFAULT_CHARSET;
    }

    i = (INT)SendMessage(
            hCombo,
            CB_GETITEMDATA,
            (WPARAM) nIndex,
            (LPARAM) 0);

    if ((i >= 0) && (i < Font_nCount))
    {
        return Font_pList[i].CharSet;
    }
    else
    {
        return DEFAULT_CHARSET;
    }
}


/****************************************************************************

    Function : Font_SelectByCharSet

****************************************************************************/
BOOL
Font_SelectByCharSet(
    HWND hWnd,
    UINT uID,
    UINT CharSet
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nIndex;
    INT  i;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    //
    // do not swtich font if charset of the current font
    // is the same as CharSet
    //
    nIndex = (INT)SendMessage(
                 hCombo,
                 CB_GETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0);

    if( CharSet == Font_GetSelFontCharSet(hWnd, uID, nIndex))
    {
        return FALSE;
    }

    for (i = 0; i < Font_nCount; i++)
    {
        if ((Font_pList[i].CharSet == CharSet)       &&
            (Font_pList[i].FontType & DBCS_FONTTYPE)   )
        {
            break;
        }
    }
    if (i < Font_nCount)
    {
        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_FINDSTRING,
                     (WPARAM) -1,
                     (LPARAM) Font_pList[i].szFaceName);

        if (nIndex == CB_ERR)
        {
            return FALSE;
        }

        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_SETCURSEL,
                     (WPARAM) nIndex,
                     (LPARAM) 0);

        if (nIndex != CB_ERR)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}

/****************************************************************************

    Function : Font_IsWithinCodePage

****************************************************************************/
BOOL
Font_IsWithinCodePage(
    UINT   uCodePage,
    WCHAR  wc,
    WORD   *pAnsi
    )
{

    WORD   ctype;

    BOOL bSkip = FALSE;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);

    if ((!ctype)            ||
        ( ctype & C1_CNTRL) ||
        ( ctype & C1_SPACE) ||
        ( ctype & C1_BLANK)   )
    {
        return FALSE;
    }

    if (uCodePage == UNICODE_CODEPAGE)
    {
        *pAnsi = 0;
        return TRUE;
    }
    else
    {
        WCHAR wc2;

        WideCharToMultiByte(
            uCodePage,
            0,
            &(wc), 1,
            (char*) pAnsi, 2,
            NULL, NULL);

        MultiByteToWideChar(
            uCodePage,
            MB_PRECOMPOSED,
            (char*) pAnsi, 2,
            &wc2, 1);

        return (wc == wc2);
    }
}

/****************************************************************************

    Function : Font_GetCurCMapTable

****************************************************************************/
BOOL
Font_GetCurCMapTable(
    HWND   hWnd,
    UINT   uID,
    URANGE **ppCodeList,
    UINT   *puNum
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nItemIndex;
    INT  nIndex;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    nIndex = (INT)SendMessage(
                 hCombo,
                 CB_GETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0L);

    if (nIndex == CB_ERR)
    {
        return FALSE;
    }

    nItemIndex = (INT)SendMessage(
                     hCombo,
                     CB_GETITEMDATA,
                     (WPARAM) nIndex,
                     (LPARAM) 0);

    if ((nItemIndex < 0) || (nItemIndex >= Font_nCount))
    {
        return FALSE;
    }

    *ppCodeList = Font_pList[nItemIndex].pUniRange;
    *puNum      = Font_pList[nItemIndex].nNumofUniRange;

    return TRUE;
}

/****************************************************************************

    Function : Font_GetCharWidth32

****************************************************************************/
BOOL
Font_GetCharWidth32(
    HDC    hDC,
    UINT   chSymFirst,
    UINT   chSymLast,
    LPINT  lpdxp,
    LPWSTR pCode
    )
{
    UINT i;
    INT  nWidth;

    if (pCode == NULL)
    {
        return FALSE;
    }

    for (i=chSymFirst; i<=chSymLast; i++)
    {
        nWidth = 0;
        GetCharWidth32(
            hDC,
            (pCode[i]),
            (pCode[i]),
            &nWidth
        );
        *lpdxp = nWidth;
        lpdxp++;
    }
    return TRUE;
}

/****************************************************************************

    Function : Font_Avail

****************************************************************************/
BOOL
Font_Avail(
    UINT CharSet
    )
{
    int i;

    for (i = 0; i < Font_nCount; i++)
    {
        if (Font_pList[i].CharSet == CharSet)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************

    Function : return the first DBCS charset, 0 if none

****************************************************************************/
UINT
Font_DBCS_CharSet()
{
    int i;

    for (i = 0; i < Font_nCount; i++)
    {
        if (Font_pList[i].FontType & DBCS_FONTTYPE)
        {
            return Font_pList[i].CharSet;
        }
    }

    return 0;
}

/****************************************************************************

    Function : Simulate CMAP Unicode ranges for non-TTF fonts

****************************************************************************/
DWORD
URanges(UINT CodePage, URANGE *pUR)
{
    WCHAR wcBuf[128];
    WCHAR wcTmp;
    BYTE  cTmp, cBeg;
    int   nCount, i, j;
    DWORD nUR = 0;

    if(pUR != NULL)
    {
        pUR[nUR].wcFrom = (WCHAR) ASCII_BEG;
        pUR[nUR].wcTo   = (WCHAR) ASCII_END;
    }
    nUR++;

    cBeg   = HIANSI_BEG;
    if(CodePage != CP_OEMCP)
    {
        cBeg += 32;
    }

    nCount = 0;
    for(cTmp = cBeg; cTmp != 0; cTmp++)
    {
        if(MultiByteToWideChar(CodePage, 0, (char*)&cTmp, 1, &wcTmp, 1) == 0 ||
           wcTmp <= 0x009F ||
           (wcTmp >= 0xE000 && wcTmp <= 0xF8FF))
           continue;

        for(i = 0; i < nCount; i++)
        {
            if(wcBuf[i] >= wcTmp)
                break;
        }

        if(i < nCount)
        {
            for(j = nCount; j > i; j--)
            {
                wcBuf[j] = wcBuf[j-1];
            }
        }

        wcBuf[i] = wcTmp;
        nCount++;
    }

    if(nCount > 0)
    {
        i = 0;
        while(1)
        {
            if(i == (nCount-1))
            {
                if(pUR != NULL)
                {
                    pUR[nUR].wcFrom = wcBuf[i];
                    pUR[nUR].wcTo   = wcBuf[i];
                }
                nUR++;
                break;
            }

            for(j = i; j < nCount-1; j++)
            {
                if((wcBuf[j+1] - wcBuf[j]) != 1) break;
            }

            if(pUR != NULL)
            {
                pUR[nUR].wcFrom = wcBuf[i];
                pUR[nUR].wcTo   = wcBuf[j];
            }
            nUR++;

            if(j == (nCount-1))
            {
                break;
            }

            i = j + 1;
        }
    }

    return nUR;
}

/****************************************************************************

    Function : convert CharSet to CodePage

****************************************************************************/
UINT
CharSetToCodePage(BYTE cs)
{
    switch(cs)
    {
        case (OEM_CHARSET):
        case (ANSI_CHARSET):
            return 1252;

        case (SHIFTJIS_CHARSET):
            return 932;

        case (CHINESEBIG5_CHARSET):
            return 950;

        case (HANGEUL_CHARSET):
            return 949;

        case (GB2312_CHARSET):
            return 936;

        case (EASTEUROPE_CHARSET):
            return 1250;

        case (GREEK_CHARSET):
            return 1253;

        case (RUSSIAN_CHARSET):
            return 1251;

        case (TURKISH_CHARSET):
            return 1254;

        case (BALTIC_CHARSET):
            return 1257;

        case (VIETNAMESE_CHARSET):
            return 1258;

        case (THAI_CHARSET):
            return 874;

        case (ARABIC_CHARSET):
            return 1255;

        case (HEBREW_CHARSET):
            return 1256;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\gridlist.cxx ===
/********************************************************************
 *
 *  Module Name : gridlist.c
 *
 *  List box (one dim) and Grid (two dim) controls for
 *  parsing and viewing subsets
 *
 *  History :
 *       Sep 03, 1997  [samera]    wrote it.
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 **********************************************************************/


// BUGBUG: This stuff should really go into a precomp header
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "UCE.h"
#include "ucefile.h"

// global stuff

// Listbox
HWND  ghwnd     = NULL;
HWND  ghwndList = NULL;

const WCHAR wszListWndClass[]=L"LISTWNDCLASS";

#define LISTBOX_WIDTH    210
#define LISTBOX_HEIGHT   210

#define DIALOG_FONT_SIZE 8
#define DIALOG_FONT_NAME L"Microsoft Sans Serif"

// Grid Window
const WCHAR wszGridWndClass[]=L"GRIDWNDCLASS";
HWND  ghwndGrid = NULL;
HFONT hFont     = NULL;
HFONT hfList    = NULL;
HFONT hfStatic  = NULL;
HPEN  hpenDash  = NULL;

PUCE_MEMORY_FILE pGridUceMemFile = NULL;          // current active UCE file

// Grid Metrics
#define PAGE_SCROLL_SIZE 3
#define GRID_XANCHOR     5
#define GRID_YANCHOR     20
#define GRID_CELL_WIDTH  22
#define GRID_CELL_HEIGHT 22
#define GRID_MAX_COL     12
#define GRID_MAX_ROW     10
#define GRID_BOTTOM_SPACE 5
#define TITLE_X           5
#define TITLE_Y           2

INT  Grid_XAnchor;

INT  gnCurRow    = -1;
INT  gnCurCol    = -1;
INT  gnRowOffset = 0;
INT  gnColOffset = 0;
INT  gnMaxRow    = 0;
INT  gnMaxCol    = 0;
BOOL gbInDrag    = FALSE;
RECT grcGridWindow;
HWND ghwndHScroll, ghwndVScroll;
PWSTR gpwszWindowTitle;
WCHAR TableName[256];

WNDPROC fnOldListBox = NULL;
LRESULT CALLBACK EscapeProc (HWND, UINT, WPARAM, LPARAM);

/******************************Public*Routine******************************\
* CreateListWindow
*
* Create a list box in a window and set its title
*
* Return Value:
*
*   handle of create list window
*
\**************************************************************************/
HWND CreateListWindow( HWND hwndParent , PWSTR pwszWindowTitle )
{
  TEXTMETRIC tm;
  HDC   hDC;
  RECT  rc;
  HWND  hwnd;
  WCHAR buffer[64];
  int   xFrame, yFrame;
   LONG xpos;
   HWND dsktop;
   RECT drc;
   DWORD dwExStyle;

  gpwszWindowTitle = pwszWindowTitle;
  if(*pwszWindowTitle == L'0')
  {
     LoadString(hInst, _wtol(pwszWindowTitle), TableName, 256);
     gpwszWindowTitle = TableName;
  }

  // Let's know where to position it exactly
  if( NULL == ghwnd )
  {
    if( !UpdateListFont( hwndParent , ID_FONT ))
    {
      return NULL;
    }

    GetWindowRect( hwndParent , &rc );
    LoadString(hInst, IDS_GROUPBY,  buffer, 64);

      //fix for group by window too right
         dsktop = GetDesktopWindow();
         GetWindowRect(dsktop, &drc);
         if (rc.right + LISTBOX_WIDTH > drc.right)
            xpos = rc.left - LISTBOX_WIDTH;
         else
            xpos = rc.right;

    // Set the mirroring ExStyle if the main window has it.
    dwExStyle = GetWindowLong(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
    hwnd = CreateWindowEx( dwExStyle ,
                           wszListWndClass,
                           buffer,
                           WS_CAPTION | WS_BORDER | WS_VISIBLE |
                           WS_SYSMENU | WS_EX_CLIENTEDGE,
                           xpos,
                           rc.top,
                           LISTBOX_WIDTH,
                           LISTBOX_HEIGHT,
                           hwndParent, //if not use hwndParent, main window will come to top when activated
                           NULL,
                           hInst,
                           NULL
                         );

    xFrame = GetSystemMetrics( SM_CXSIZEFRAME );
    yFrame = GetSystemMetrics( SM_CYSIZEFRAME );

    if( NULL != hwnd )
    {
      HFONT hFontOld;
      ghwnd = hwnd;

      GetClientRect( hwnd , &rc );

      hDC = GetDC(hwndParent);
      hFontOld = (HFONT)SelectObject(hDC, hfStatic);

      // Find the height of the string
      GetTextMetrics(hDC, &tm);

      SelectObject(hDC, hFontOld);
      ReleaseDC(hwndParent, hDC);

         
      // Let's create the list box
      ghwndList = CreateWindowEx( WS_EX_CLIENTEDGE,
                                  L"LISTBOX",
                                  L"",
                                  WS_CHILD | WS_VISIBLE | LBS_NOTIFY
                                  | WS_VSCROLL | WS_HSCROLL,
                                  xFrame,
                                  tm.tmHeight + yFrame,
                                  rc.right - 2*xFrame,
                                  rc.bottom - tm.tmHeight - yFrame,
                                  hwnd,
                                  (HMENU)ID_LISTBOX,
                                  hInst,
                                  NULL
                                ) ;

      fnOldListBox = (WNDPROC)SetWindowLongPtr (ghwndList, GWLP_WNDPROC,
                                              (LPARAM) EscapeProc) ;

      SendMessage( ghwndList,
                   LB_RESETCONTENT,
                   0,
                   0
                 );
      ShowWindow( hwnd , SW_NORMAL );
      SetFocus(ghwndList);
    }
  }
  else
  {
      InvalidateRect( ghwnd , NULL , FALSE );
  }

  return ghwnd;
}

/******************************Public*Routine******************************\
* EscapeProc
*
* so that Escape key can close the window
*
\**************************************************************************/
LRESULT CALLBACK EscapeProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
   if (iMsg == WM_KEYDOWN)
   {
      switch(wParam)
      {
        case VK_ESCAPE:
          {
              SendMessage(ghwnd, WM_CLOSE, 0, 0L);
              return 0L;
          }
          break;

        case VK_F6:
          {

              SetFocus(hwndCharGrid);
              return 0L;
          }
          break;
      }
   }

  return CallWindowProc (fnOldListBox, hwnd, iMsg, wParam, lParam) ;
}

/******************************Public*Routine******************************\
* InitListWindow
*
* Register ListBox main window
*
* Return Value:
*
*   TRUE if successful operation, FALSE otherwise
*
\**************************************************************************/
BOOL InitListWindow( HINSTANCE hInstance )
{
  WNDCLASS  wcListWnd;

  wcListWnd.style = 0;
  wcListWnd.lpfnWndProc = ListWndProc;
  wcListWnd.cbClsExtra = 0;
  wcListWnd.cbWndExtra = 0;
  wcListWnd.hInstance = hInstance;
  wcListWnd.hIcon = NULL;
  wcListWnd.hCursor = LoadCursor(NULL, IDC_ARROW);
  wcListWnd.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
  wcListWnd.lpszMenuName =  NULL;
  wcListWnd.lpszClassName = wszListWndClass;

  return (RegisterClass(&wcListWnd));
}


/******************************Public*Routine******************************\
* ListWndProc
*
* ListBox's MainWindow Callback Proc
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
LRESULT CALLBACK ListWndProc( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  switch( uMsg )
  {
  case WM_CREATE:
    {
      SendMessage(ghwndList, LB_SETHORIZONTALEXTENT, (WPARAM)LISTBOX_WIDTH,
      (LPARAM)0L);
    }
    break;

  case WM_SETFOCUS:
    {
      SetFocus(ghwndList);
    }
    break;

  case WM_COMMAND:
    {
      switch( LOWORD(wParam) )
      {
      case ID_LISTBOX:
        {
          if( HIWORD(wParam) == LBN_SELCHANGE )
          {
            SubSetChanged( hwndDialog );
          }
        }

      default:
        return (DefWindowProc(hWnd, uMsg, wParam, lParam));
        break;
      }
    }
    break;

  case WM_PAINT:
    {
      PAINTSTRUCT  ps;
      HDC          hPaintDC;
      HFONT        hOldFont;

      BeginPaint(hWnd, &ps);
      hPaintDC = ps.hdc;
      hOldFont = (HFONT)SelectObject(hPaintDC, hfStatic);
      SetBkColor(hPaintDC, GetSysColor(COLOR_BTNFACE));
      TextOut(hPaintDC, TITLE_X, TITLE_Y, gpwszWindowTitle,
        wcslen(gpwszWindowTitle));
      SelectObject(hPaintDC, hOldFont);
      EndPaint(hWnd, &ps);
    }
    break;

  case WM_CLOSE:
    {
      WCHAR buffer[64];

      SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                   CB_SETCURSEL,
                   (WPARAM) 0,
                   (LPARAM) 0);
      LoadString(hInst, IDS_RESET, buffer, 64);
      SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
      EnableWindow(GetDlgItem(hwndDialog, ID_SEARCH), TRUE);
      SetSearched();
      SetFocus(GetDlgItem(hwndDialog, ID_SEARCH));

      DestroyWindow(hWnd);
    }
    break;

  case WM_DESTROY:
    {
      EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), TRUE);
      EnableSURControls(hwndDialog);
      ghwndList = ghwnd = NULL;

      // falls thru
    }

  default:
    return (DefWindowProc(hWnd, uMsg, wParam, lParam));
  }

  return 0L;
}


/******************************Public*Routine******************************\
* FillGroupsInListBox
*
* Fill listbox with Groups of current UCE_MEMORY_FILE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
void FillGroupsInListBox( HWND hWnd , PUCE_MEMORY_FILE pUceMemFile )
{
  PSTR        pFile   = (char*) pUceMemFile->pvData;
  PUCE_HEADER pHeader = (PUCE_HEADER)pUceMemFile->pvData;
  PUCE_GROUP  pGroup  = (PUCE_GROUP)(pFile+sizeof(UCE_HEADER));
  INT         nGroups = ((PUCE_HEADER)pFile)->NumGroup;
  INT         i;
  INT         nIndex;

  // Reset content
  if(NULL == ghwndList)
  {
    // let's create everything!
    if( !CreateListWindow( hWnd , (PWSTR) (pFile+pHeader->OffsetTableName) ))
      return ;
  }
  else
  {
    SendMessage( ghwndList,
                 LB_RESETCONTENT,
                 0,
                 0
               );
  }

  // Set the drawing font
  SendMessage( ghwndList ,
               WM_SETFONT ,
               (WPARAM)hfList,
               (LPARAM)MAKELONG(TRUE,0)
             );

  // Fill list box
  i=0;
  while( i<nGroups )
  {
    WCHAR wcBuf[256];

    PWSTR pwszGroup = (PWSTR)(pFile+pGroup->OffsetGroupName);
    if(*pwszGroup == L'0')
    {
        LoadString(hInst, _wtol(pwszGroup), wcBuf, 255);
        pwszGroup = wcBuf;
    }
    nIndex = (INT)SendMessage( ghwndList,
                               LB_ADDSTRING,
                               (WPARAM) 0,
                               (LPARAM) pwszGroup
                             );

    if (nIndex != LB_ERR)
    {
      SendMessage( ghwndList,
                   LB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) pGroup
                 );
    }
    pGroup++;
    i++;
  }

  // Set current selection to the 1st element
  SendMessage( ghwndList,
               LB_SETCURSEL,
               (WPARAM) 0,
               (LPARAM) 0L
             );

  return;
}


/******************************Public*Routine******************************\
* GetUnicodeCharsFromList
*
* Fills a buffer with unicode chars according to current group
* of (UCE_MEMORY_FILE) selection
*
* Return Value:
*   TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
BOOL GetUnicodeCharsFromList( HWND hWnd , PUCE_MEMORY_FILE pUceMemFile , PWSTR pwBuf  , UINT *puNum , BOOL *pbLineBreak)
{
  INT         nIndex;
  PUCE_GROUP  pGroup;
  BOOL        bRet=FALSE;
  PWSTR       pwCh;
  PSTR        pFile = (char*)pUceMemFile->pvData;


  // Reset content
  if(NULL == ghwndList)
  {
    PUCE_HEADER pHeader = (PUCE_HEADER)pFile;
    // let's create everything!
    if( !CreateListWindow( hWnd , (PWSTR) (pFile+pHeader->OffsetTableName) ))
      return FALSE;
  }

  nIndex = (INT)SendMessage( ghwndList,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0L
                           );

  if( nIndex != LB_ERR )
  {
    pGroup = (PUCE_GROUP) SendMessage( ghwndList,
                                       LB_GETITEMDATA,
                                       (WPARAM) nIndex,
                                       (LPARAM) 0L
                                       );

    // Fill in buffer

    *puNum = pGroup->NumChar;
    pwCh   = (PWSTR) (pFile+pGroup->OffsetGroupChar);

    GetWChars( *puNum , pwCh , pwBuf , puNum , pbLineBreak);

    bRet = TRUE;
  }

  return bRet;
}


/******************************Public*Routine******************************\
* DestroyListWindow
*
* Destroy the list window, if active
*
* Return Value:

* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyListWindow( void )
{
  if( ghwnd )
  {
    DestroyWindow( ghwnd );
  }

  return;
}


/******************************Public*Routine******************************\
* DestroyAllListWindows
*
* Destroy the list & grid window, if active. This is called when exiting
* UCE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyAllListWindows( void )
{
  DestroyListWindow();
  DestroyGridWindow();

  return;
}


/******************************Public*Routine******************************\
* IsListWindow
*
* Checks type of grid needed (1d or 2d) according to current active
* UCE_MEMORY_FILE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsListWindow( PUCE_MEMORY_FILE pUceMemFile )
{
  BOOL        bRet = FALSE;
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);

  if( pHeader->Row )
  {
    // Grid Window
    bRet = (ghwndGrid != NULL);
  }
  else
  {
    // List Window
    bRet = (ghwnd != NULL);
  }

  return bRet;
}


/*
 *******************************************
 *       Grid Window Control               *
 *******************************************/


/******************************Public*Routine******************************\
* InitGridWindow
*
* Register class of GridWindow
*
* Return Value:
*   TRUE if successful, FALSE otherwise
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL InitGridWindow( HINSTANCE hInstance )
{
  WNDCLASS  wcGridWnd;

  wcGridWnd.style = 0;
  wcGridWnd.lpfnWndProc = GridWndProc;
  wcGridWnd.cbClsExtra = 0;
  wcGridWnd.cbWndExtra = 0;
  wcGridWnd.hInstance = hInstance;
  wcGridWnd.hIcon = NULL ;
  wcGridWnd.hCursor = LoadCursor(NULL, IDC_ARROW);
  wcGridWnd.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
  wcGridWnd.lpszMenuName =  NULL;
  wcGridWnd.lpszClassName = wszGridWndClass;

  return (RegisterClass(&wcGridWnd));
}


/******************************Public*Routine******************************\
* CreateGridWindow
*
* Create Grid window and fills it with proper values from current UCE_MEMORY_FILE
*
* Return Value:
*   handle to grid window
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
HWND CreateGridWindow( HWND hwndParent , UINT uID , PUCE_MEMORY_FILE pUceMemFile )
{
  RECT rc;
  HWND hwnd;
  WCHAR buffer[64];
   LONG xpos;
   HWND dsktop;
   RECT drc;
   DWORD dwExStyle;

  // Let's know where to position it exactly
  if( NULL == ghwndGrid )
  {
    POINT pt;
    PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);

    gpwszWindowTitle = (PWSTR)((PSTR)pHeader+pHeader->OffsetTableName);
    if(*gpwszWindowTitle == L'0')
    {
        LoadString(hInst, _wtol(gpwszWindowTitle), TableName, 256);
        gpwszWindowTitle = TableName;
    }

    GetWindowRect( hwndParent , &rc );
    GetWindowGridSize( pUceMemFile , &pt , &gnColOffset , &gnRowOffset );

    pGridUceMemFile = pUceMemFile;

    // Let's create the font that is in the list
    if( !UpdateGridFont( hwndParent , ID_FONT ))
    {
      return NULL;
    }

    LoadString(hInst, IDS_GROUPBY,  buffer, 64);
      
      //fix for group by window too right
      dsktop = GetDesktopWindow();
      GetWindowRect(dsktop, &drc);
      if (rc.right + pt.x > drc.right)
         xpos = rc.left - pt.x;
      else
         xpos = rc.right;

      //rc.left+(rc.right-rc.left),
    dwExStyle = GetWindowLong(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
    hwnd = CreateWindowEx( dwExStyle ,
                           wszGridWndClass,
                           buffer,
                           WS_CAPTION | WS_BORDER | WS_SYSMENU | WS_EX_CLIENTEDGE,
                           xpos,
                           rc.top,
                           pt.x,
                           pt.y,
                           hwndParent,
                           NULL,
                           hInst,
                           NULL
                         );
    if( NULL != hwnd )
    {
      INT x,y;
      SCROLLINFO sinfo;

      sinfo.cbSize = sizeof(SCROLLINFO);
      ghwndGrid = hwnd;

      // let 's create the horiz scroll bar if needed
      if( gnColOffset )
      {
        // x =  GRID_XANCHOR;
        x =  Grid_XAnchor;
        y = (GRID_YANCHOR + (gnMaxRow*GRID_CELL_HEIGHT));
        ghwndHScroll = CreateWindowEx( 0,
                                       L"SCROLLBAR",
                                       L"",
                                       WS_CHILD | WS_VISIBLE | SBS_HORZ | SBS_TOPALIGN,
                                       x,
                                       y,
                                       (gnMaxCol*GRID_CELL_WIDTH),
                                       0,
                                       hwnd,
                                       (HMENU)ID_GRID_HSCROLL,
                                       hInst,
                                       NULL
                                     );

        // Let's adjust the scroll bar metrics
        sinfo.nMin = 0;
        sinfo.nMax = gnColOffset;
        sinfo.nPos = 0;
        sinfo.nPage= gnMaxCol;
        sinfo.fMask = SIF_RANGE|SIF_POS|SIF_PAGE;
        SetScrollInfo( ghwndHScroll , SB_CTL , &sinfo , TRUE );

        gnColOffset=0;
      }

      // let 's create the vert scroll bar if needed
      if( gnRowOffset )
      {
//      x = (GRID_XANCHOR + (gnMaxCol*GRID_CELL_WIDTH));
        x = (Grid_XAnchor + (gnMaxCol*GRID_CELL_WIDTH));
        y =  GRID_YANCHOR;
        ghwndVScroll = CreateWindowEx( 0,
                                       L"SCROLLBAR",
                                       L"",
                                       WS_CHILD | WS_VISIBLE | SBS_VERT | SBS_LEFTALIGN,
                                       x,
                                       y,
                                       0,
                                       (gnMaxRow*GRID_CELL_HEIGHT),
                                       hwnd,
                                       (HMENU)ID_GRID_VSCROLL,
                                       hInst,
                                       NULL
                                     );
        // Let's adjust the scroll bar metrics
        sinfo.nMin = 0;
        sinfo.nMax = gnRowOffset + gnMaxRow - 1;
        sinfo.nPos = 0;
        sinfo.nPage= gnMaxRow;
        sinfo.fMask = SIF_RANGE|SIF_POS|SIF_PAGE;
        SetScrollInfo( ghwndVScroll , SB_CTL , &sinfo , TRUE );

        gnRowOffset=0;
      }

      ShowWindow( hwnd , SW_NORMAL );
    }
  }

  return ghwndGrid;
}


/******************************Public*Routine******************************\
* GetWindowGridSize
*
* Get window size for grid, and if scroll bars are needed
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void GetWindowGridSize( PUCE_MEMORY_FILE pUceMemFile , POINT *pPt , INT *pnXScroll , INT *pnYScroll )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pUceMemFile->pvData;
  INT    xSize=0;
  INT    ySize=0;
  SIZE   size;
  HDC    hDC;
  HFONT  hFontOld;

  // some init stuff
  gnCurRow     =0;     // default to 1st row
  gnCurCol     =0;     // default to 1st col
  gnRowOffset  =0;
  gnColOffset  =0;
  gnMaxRow     =0;
  gnMaxCol     =0;
  gbInDrag     = FALSE;
  ghwndHScroll = ghwndVScroll = NULL;
  *pnXScroll   = *pnYScroll   = 0;

  // Calculate the basic (both edges)
  xSize += (2*GRID_XANCHOR);
  ySize += GRID_YANCHOR + GRID_BOTTOM_SPACE;

  xSize += (pHeader->Column * GRID_CELL_WIDTH);
  gnMaxCol = pHeader->Column;

  // See if wee need a horz scroll bar
  /*
  if( pHeader->Column > GRID_MAX_COL )
  {
    ySize += GetSystemMetrics( SM_CYHSCROLL );
    *pnXScroll = (pHeader->Column - GRID_MAX_COL);
    xSize += (GRID_CELL_WIDTH*GRID_MAX_COL);
    gnMaxCol = GRID_MAX_COL;
#if DBG
    OutputDebugString(L"\nShould use Horrizonal Scroll Bar");
#endif
  }
  else
  {
    xSize += (pHeader->Column * GRID_CELL_WIDTH);
    gnMaxCol = pHeader->Column;
#if DBG
    OutputDebugString(L"\nNo Horrizonal Scroll Bar Needed!");
#endif
  }
*/

  // See if we need a vert scroll bar
  if( pHeader->Row > GRID_MAX_ROW )
  {
    xSize += GetSystemMetrics( SM_CXVSCROLL );
    *pnYScroll = (pHeader->Row - GRID_MAX_ROW);
    ySize += (GRID_CELL_HEIGHT*GRID_MAX_ROW);
    gnMaxRow = GRID_MAX_ROW;
#if DBG
    OutputDebugString(L"\nShould use Vertical Scroll Bar");
#endif
  }
  else
  {
    ySize += (pHeader->Row * GRID_CELL_HEIGHT);
    gnMaxRow = pHeader->Row;
#if DBG
    OutputDebugString(L"\nNo Vertical Scroll Bar Needed!!");
#endif
  }

  // Update
  xSize += (2*GetSystemMetrics( SM_CXSIZEFRAME ));
  pPt->x = xSize;

  // Compute the size of the text which is the header for this grid
  hDC = GetDC(HWND_DESKTOP);
  hFontOld = (HFONT)SelectObject(hDC, hfStatic);
  GetTextExtentPoint32(hDC, gpwszWindowTitle,
    wcslen(gpwszWindowTitle), &size);
  SelectObject(hDC, hFontOld);
  ReleaseDC(HWND_DESKTOP, hDC);

  size.cx += (2*GRID_XANCHOR) + (2*GetSystemMetrics( SM_CXSIZEFRAME ));

  if( pPt->x < size.cx )            // kchang : for long Window Title
  {
      pPt->x = size.cx;
      Grid_XAnchor = ( pPt->x - gnMaxCol*GRID_CELL_WIDTH ) / 2
                      - GRID_XANCHOR;
  }
  else
  {
      Grid_XAnchor = GRID_XANCHOR;
  }

  // some add-ons
  ySize += (2*GetSystemMetrics( SM_CYSIZEFRAME ));
  ySize += GetSystemMetrics(SM_CYCAPTION);
  pPt->y = ySize;

  // Update our grid window control rect
  // grcGridWindow.left   = GRID_XANCHOR;
  grcGridWindow.left   = Grid_XAnchor;
  grcGridWindow.top    = GRID_YANCHOR;
  grcGridWindow.right  = (grcGridWindow.left + (gnMaxCol*GRID_CELL_WIDTH));
  grcGridWindow.bottom = (grcGridWindow.top  + (gnMaxRow*GRID_CELL_HEIGHT));

  return;
}


/******************************Public*Routine******************************\
* GridWndProc
*
* Grid Callback Window Proc
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
LRESULT CALLBACK GridWndProc( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  switch( uMsg )
  {
  case WM_CREATE:
    {
    }
    break;

  case WM_CHAR:
    {
       INT   nCurRow = gnCurRow;
       INT   nCurCol = gnCurCol;
       HDC   hDC     = GetDC( hWnd );
       WCHAR wchar   = (WCHAR) wParam;
       RECT  rc;
       WCHAR wc;
       INT   nTmpRow;
       INT   nTmpCol;

       gnCurRow = gnMaxRow-1;
       gnCurCol = gnMaxCol-1;
       while(1)
       {
          if(IsCellEnabled(gnCurRow, gnCurCol))
          {
              GetCurrentGroupChar( &wc );

              if(CompareString(0,
                     NORM_IGNORECASE     | NORM_IGNOREKANATYPE |
                     NORM_IGNORENONSPACE | NORM_IGNOREWIDTH,
                     &wc, 1,
                     &wchar, 1) == 2) 
                  break; 
          }

          if(--gnCurCol < 0)
          {
              if(--gnCurRow < 0)
              {
                  gnCurRow = nCurRow;
                  gnCurCol = nCurCol;
                  ReleaseDC( hWnd , hDC );
                  return 0L;
              }
              gnCurCol = gnMaxCol-1;
          }
       }

       nTmpRow = gnCurRow;
       nTmpCol = gnCurCol;

       gnCurRow = nCurRow;
       gnCurCol = nCurCol;
       GetCurrentRect( &rc );
       GetCurrentGroupChar( &wc );
       DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;

       gnCurRow = nTmpRow;
       gnCurCol = nTmpCol;
       GetCurrentRect( &rc );
       GetCurrentGroupChar( &wc );
       DrawGridCell( hDC , &rc , TRUE , wc , TRUE);

       ReleaseDC( hWnd , hDC );
       SubSetChanged( hwndDialog );
    }
    break;

  case WM_KEYDOWN:
    {
    BOOL bForward;
    BOOL bThisLine;
    INT  nCurRow = gnCurRow;
    INT  nCurCol = gnCurCol;

    PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;

    // If hWnd is mirrored swap left and right keys.
    if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
        if (wParam == VK_LEFT) {
            wParam = VK_RIGHT;
        } else if (wParam == VK_RIGHT) {
            wParam = VK_LEFT;
        }
    }

    switch( LOWORD(wParam) )
       {
       case VK_ESCAPE:
            SendMessage(ghwndGrid, WM_CLOSE, 0, 0L);
            return 0L;

       case VK_HOME:
            if(GetAsyncKeyState(VK_CONTROL))
            {
               if(ghwndVScroll)  GridVScroll(hWnd , uMsg , SB_TOP, 0);
                  nCurRow = 0;
            }
             nCurCol = 0;
            bForward = false;
            bThisLine = true;
            break;

       case VK_END:
            if(GetAsyncKeyState(VK_CONTROL))
            {
               if(ghwndVScroll)  GridVScroll(hWnd, uMsg, SB_BOTTOM, 0);
               nCurRow = pHeader->Row - 1;
            }
              nCurCol = gnMaxCol - 1;
            bForward = true;
            bThisLine = true;
            break;

vk_left:
       case VK_LEFT:
            if(nCurCol == 0)
            {
                 if (nCurRow > 0)
              {
                    nCurRow--;
                nCurCol = gnMaxCol-1;
                   if (ghwndVScroll) GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
              }
            }
               else
                 nCurCol--;
            bForward = false;
            bThisLine = false;
          break;

       case VK_TAB:
            if(GetAsyncKeyState(VK_SHIFT)) goto vk_left;
       case VK_RIGHT:
               if (nCurCol == gnMaxCol - 1)
            {
                 if (nCurRow < pHeader->Row -1)
              {
                    nCurRow++;
                   nCurCol = 0;
                   if (ghwndVScroll) GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
              }
            }
            else
            {
                 nCurCol++;
            }
            bForward = true;
            bThisLine = false;
            break;

       case VK_PRIOR:
            if(ghwndVScroll != NULL)
            {
               if(nCurRow < gnMaxRow)
                   nCurRow = 0;
               else
                   nCurRow = nCurRow - gnMaxRow;
               GridVScroll(hWnd , uMsg , SB_PAGEUP, 0);
            }
            else
            {
               nCurRow = 0;
            }
          bForward = false;
            bThisLine = true;
            break;

       case VK_NEXT:
            if(ghwndVScroll != NULL)
            {
               if(nCurRow >= (pHeader->Row - gnMaxRow))
                   nCurRow = pHeader->Row - 1;
               else
                   nCurRow += gnMaxRow;
               GridVScroll(hWnd , uMsg , SB_PAGEDOWN, 0);
            }
            else
            {
               nCurRow = gnMaxRow-1;
            }
         bForward = true;
            bThisLine = true;
            break;

       case VK_UP:
            if(ghwndVScroll != NULL)
            {
                GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
            }
            if (nCurRow > 0) nCurRow--;
         bForward = false;
            bThisLine = true;
            break;

       case VK_DOWN:
            if(ghwndVScroll != NULL)
            {
                GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
            }
         if (nCurRow < pHeader->Row - 1) nCurRow++;
         bForward = true;
            bThisLine = true;
            break;

       case VK_F6:
            SetFocus(hwndCharGrid);
            return 0L;
            break;

       default:
            return 0L;
       }

       if (!bForward)
       {
         while(!IsCellEnabled(nCurRow, nCurCol))
           if (nCurCol > 0)
               nCurCol--;
           else
             if (bThisLine)
             {
               ;
             }
             else
             {
                if (nCurRow > 0)
                {
                  nCurRow--;
                  nCurCol = gnMaxCol - 1;
                  if (ghwndVScroll != NULL) GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
                }
             }
       }
       else
       {
         while(!IsCellEnabled(nCurRow, nCurCol))
         {
           if (nCurCol < gnMaxCol - 1)
             nCurCol++;
           else
             if (bThisLine) //went too far , has to come back
             {
               while(!IsCellEnabled(nCurRow, nCurCol))
                 nCurCol --;
             }
             else
             {
               if (nCurRow < pHeader->Row - 1)
               {
                 nCurRow++;
                 nCurCol = 0;
                 if (ghwndVScroll != NULL) GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
               }
               else // went too far, has to come back
               {
                 while(!IsCellEnabled(nCurRow, nCurCol))
                   nCurCol --;
               }
             }
         }
       }

       {
          RECT  rc;
          WCHAR wc;
          HDC   hDC = GetDC( hWnd );

        //Erase focus frame of old cell 
          GetCurrentRect( &rc );
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;

        //draw focus frame of new cell
          gnCurRow = nCurRow;
          gnCurCol = nCurCol;
          GetCurrentRect( &rc );
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , TRUE , wc , TRUE);

          ReleaseDC( hWnd , hDC );
        InvalidateRect( hWnd , NULL , TRUE );
          SubSetChanged( hwndDialog );
       }

    }
    break;

  case WM_COMMAND:
    {
        return (DefWindowProc(hWnd, uMsg, wParam, lParam));
    }
  break;

  case WM_PAINT:
    {
      PAINTSTRUCT ps;
      HDC         hDC;
      HFONT       hOldFont;

      hDC = BeginPaint( hWnd , &ps );

      // Actual stuff
      DoPaint( hWnd , hDC );

      hOldFont = (HFONT)SelectObject(hDC, hfStatic);
      SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));
      TextOut(hDC, TITLE_X, TITLE_Y, gpwszWindowTitle,
        wcslen(gpwszWindowTitle));
      SelectObject(hDC, hOldFont);

      EndPaint( hWnd , &ps );
    }
    break;

  // scroll bar
  case WM_HSCROLL:
      GridHScroll( hWnd , uMsg , wParam , lParam );
    break;

  case WM_VSCROLL:
      GridVScroll( hWnd , uMsg , wParam , lParam );
    break;


  // Mouse events
  case WM_LBUTTONDOWN:
    {
      // Check if in our area, and if so start tracking
      POINT pt;
      pt.x = GET_X_LPARAM(lParam);
      pt.y = GET_Y_LPARAM(lParam);

      if( PtInRect( &grcGridWindow , pt ) && IsCellEnabled(  gnCurRow , gnCurCol ) )
      {
        RECT  rc;
        HDC   hDC;
        WCHAR wc;
        BOOL  bRet;
        INT   nCurRow,nCurCol;


        // Set capture & flag (need to check if this is the same cell or not
        SetCapture( hWnd );
        gbInDrag = TRUE;

        // Clear previous active
        bRet = GetCurrentRect( &rc );
        nCurRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
 //     nCurCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
        nCurCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

        if( bRet && !IsCellEnabled(  nCurRow , nCurCol ) )
        {
          break;
        }

        hDC = GetDC( hWnd );
        if( bRet )
        {
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;
        }

        // Indicate active cell
        gnCurRow = nCurRow;
        gnCurCol = nCurCol;
        if( GetCurrentRect( &rc ) )
        {
          GetCurrentGroupChar( &wc );
#if DBG
          {
            WCHAR wsz[64];
            wsprintf(&wsz[0],L"CodePoint=%x\n",wc);
            OutputDebugString( wsz );
          }
#endif
          DrawGridCell( hDC , &rc , TRUE , wc , TRUE) ;
        }

        ReleaseDC( hWnd , hDC );

        // This could be expensive for a large grid
        SubSetChanged( hwndDialog );
      }
    }
    break;

  case WM_MOUSEMOVE:
    {
      POINT pt;
      pt.x = GET_X_LPARAM(lParam);
      pt.y = GET_Y_LPARAM(lParam);
      // Move the rect as we drag in
      // get new active cell, if same then don't do anything
      // otherwise clear old and draw new one
      if( gbInDrag )
      {
        if( PtInRect( &grcGridWindow , pt ) )
        {
          WCHAR wc;
          RECT  rc;
          HDC   hDC;
          INT   nCurRow,nCurCol;
          BOOL  bRet=FALSE;

          // Some optimization so we don't draw all the time
          if( GridSamePointHit( pt ) )
            break;

          // Clear previous active
          nCurRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
//        nCurCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
          nCurCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

          bRet = GetCurrentRect( &rc ) ;

          if( bRet && !IsCellEnabled(  nCurRow , nCurCol ) )
            break;

          hDC = GetDC( hWnd );
          if( bRet )
          {
            GetCurrentGroupChar( &wc );
            DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;
          }

          // Indicate active cell
          gnCurRow = nCurRow;
          gnCurCol = nCurCol;
          if( GetCurrentRect( &rc ) )
          {
            GetCurrentGroupChar( &wc );
            DrawGridCell( hDC , &rc , TRUE , wc , TRUE) ;
          }

          ReleaseDC( hWnd , hDC );

          // This could be expensive for a large grid
          SubSetChanged( hwndDialog );
        }
      }
    }
    break;

  case WM_LBUTTONUP:
    {
      // Check if we are in drag mode
      if( gbInDrag )
      {
        ReleaseCapture();
        gbInDrag = FALSE;

        // no need to update current selection since I hook
        // it on WM_MOUSEMOVE
      }
    }
    break;

  case WM_CLOSE:
    {
      WCHAR buffer[64];

      SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                   CB_SETCURSEL,
                   (WPARAM) 0,
                   (LPARAM) 0);
      LoadString(hInst, IDS_RESET, buffer, 64);
      SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
      EnableWindow(GetDlgItem(hwndDialog, ID_SEARCH), TRUE);
      SetSearched();
      SetFocus(GetDlgItem(hwndDialog, ID_SEARCH));

      DestroyWindow(hWnd);
    }
    break;

  case WM_DESTROY:
    {
      EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), TRUE);
      EnableSURControls(hwndDialog);
      ghwndGrid = NULL;
      // fall through
    }

  default:
    return (DefWindowProc(hWnd, uMsg, wParam, lParam));
  }

  return 0L;
}


/******************************Public*Routine******************************\
* GridHScroll
*
* Grid Callback handler for WM_HSCROLL
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GridHScroll( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  SCROLLINFO sinfo;

  sinfo.cbSize = sizeof( SCROLLINFO );
  sinfo.fMask = SIF_PAGE|SIF_POS|SIF_RANGE;
  GetScrollInfo( ghwndHScroll , SB_CTL , &sinfo );

  switch( LOWORD( wParam ) )
  {
  case SB_TOP:
    gnColOffset=0;
    break;

  case SB_BOTTOM:
    gnColOffset=sinfo.nMax;
    break;

  case SB_LINEUP:
    if( gnColOffset )
      gnColOffset--;
    break;

  case SB_LINEDOWN:
    if( gnColOffset < sinfo.nMax )
      gnColOffset++;
    break;

  case SB_PAGEUP:
    if( gnColOffset >= PAGE_SCROLL_SIZE )
      gnColOffset -= PAGE_SCROLL_SIZE;
    else
      gnColOffset = 0;
    break;

  case SB_PAGEDOWN:
    if( (gnColOffset + PAGE_SCROLL_SIZE) <= (INT)sinfo.nMax )
      gnColOffset += PAGE_SCROLL_SIZE;
    else
      gnColOffset = sinfo.nMax;
    break;

  default:
    return FALSE;
  }

  // update position
  sinfo.nPos = gnColOffset;
  sinfo.fMask = SIF_POS;
  SetScrollInfo( ghwndHScroll , SB_CTL , &sinfo , TRUE );

  // Update the window (silent)
  InvalidateRect( hWnd , NULL , FALSE );

  return TRUE;
}


/******************************Public*Routine******************************\
* GridVScroll
*
* Grid Callback handler for WM_VSCROLL
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GridVScroll( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  SCROLLINFO sinfo;

  sinfo.cbSize = sizeof( SCROLLINFO );
  sinfo.fMask = SIF_PAGE|SIF_POS|SIF_RANGE;
  GetScrollInfo( ghwndVScroll , SB_CTL , &sinfo );

  switch( LOWORD( wParam ) )
  {
  case SB_TOP:
     gnRowOffset = 0;
    break;

  case SB_BOTTOM:
     gnRowOffset = sinfo.nMax - gnMaxRow + 1;
    break;

  case SB_LINEUP:
    if(gnRowOffset)
      gnRowOffset--;
    break;

  case SB_LINEDOWN:
    if( gnRowOffset < sinfo.nMax - gnMaxRow + 1)
      gnRowOffset++;
    break;

  case SB_PAGEUP:
    if( gnRowOffset > gnMaxRow )
      gnRowOffset -= gnMaxRow;
    else
      gnRowOffset = 0;
    break;

  case SB_PAGEDOWN:
    if( gnRowOffset < sinfo.nMax - gnMaxRow + 1 - gnMaxRow)
      gnRowOffset += gnMaxRow;
    else
      gnRowOffset= sinfo.nMax - gnMaxRow + 1;
    break;

  case ( SB_THUMBTRACK ) :
  case ( SB_THUMBPOSITION ) :
  {
    gnRowOffset = (HIWORD(wParam));
    break;
  }

  default:
    return FALSE;
  }

  // update position
  sinfo.nPos = gnRowOffset;
  sinfo.fMask = SIF_POS;
  SetScrollInfo( ghwndVScroll , SB_CTL , &sinfo , TRUE );

  // Update the window (silent)
  InvalidateRect( hWnd , NULL , FALSE );

  return TRUE;
}


/******************************Public*Routine******************************\
* DestroyGridWindow
*
* Destroys the grid window
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyGridWindow( void )
{
  if( ghwndGrid )
  {
    DestroyWindow( ghwndGrid );
  }

  return;
}


/******************************Public*Routine******************************\
* DoPaint
*
* Grid's WM_PAINT handler
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DoPaint( HWND hWnd , HDC hDC )
{
  RECT        rc;
  INT         i,j;
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER)),pRefGroup;
  PWSTR       pwCh;

  // Let's draw the grid first
  rc.top    = GRID_YANCHOR;
  rc.bottom = rc.top+GRID_CELL_HEIGHT;

  // set a reference group
  pRefGroup = pGroup;

  for( i=0 ; i<gnMaxRow ; i++ )
  {
//  rc.left   = GRID_XANCHOR;
    rc.left   = Grid_XAnchor;
    rc.right  = rc.left+GRID_CELL_WIDTH;

    for( j=0 ; j<gnMaxCol ; j++ )
    {
      // draw all cells
      pGroup  = pRefGroup + (((gnRowOffset+i)*pHeader->Column)+gnColOffset+j);
      pwCh    = (PWSTR)((PSTR)pGridUceMemFile->pvData+pGroup->OffsetGroupName) ;

      DrawGridCell( hDC ,
                    &rc ,
                    (((j+gnColOffset)==gnCurCol) && ((i+gnRowOffset)==gnCurRow) && (gnCurRow!=-1)) ,
                    *pwCh ,
                    IsCellEnabled((i+gnRowOffset) , (j+gnColOffset))
                  );
      rc.left  = rc.right;
      rc.right+= GRID_CELL_WIDTH;
    }

    // next row
//  rc.left   = GRID_XANCHOR;
    rc.left   = Grid_XAnchor;
    rc.right  = rc.left+GRID_CELL_WIDTH;
    rc.top    = rc.bottom;
    rc.bottom += GRID_CELL_HEIGHT;
  }

  return;
}



/******************************Public*Routine******************************\
* MyFrameRect
*
* Draw a dashed rect (replace FrameRect)
*
* Return Value:
*
* History:
*   Sept-04-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void MyFrameRect( HDC hDC , RECT *prc )
{
  HPEN hOldPen = (HPEN)SelectObject( hDC , hpenDash );

  MoveToEx( hDC , prc->left  , prc->top , NULL ) ;
  LineTo(   hDC , prc->right , prc->top ) ;
  LineTo(   hDC , prc->right , prc->bottom );
  LineTo(   hDC , prc->left  , prc->bottom );
  LineTo(   hDC , prc->left  , prc->top );

  SelectObject( hDC , hOldPen );

  return;
}

/******************************Public*Routine******************************\
* DrawGridCell
*
* Draws a grid cell on the current hDC and *prc rect, and fills with
* the 'wc' text
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DrawGridCell( HDC hDC , RECT *prc , BOOL bActive , WCHAR wc , BOOL bEnabled )
{
  HFONT    hOldFont;
  COLORREF oldTextColor,oldBkColor;
  INT      iWidth = 10;
  INT      xAnchor=prc->left;


  // text
  if( bEnabled )
  {
    oldTextColor = SetTextColor( hDC , RGB(0,0,0) );
    oldBkColor   = SetBkColor( hDC , RGB(255,255,255) );
  }
  else
  {
    oldTextColor = SetTextColor( hDC , RGB(128,128,128) );
//    oldTextColor = SetTextColor( hDC , RGB(128,128,128) );
//    oldBkColor   = SetBkColor( hDC , RGB(192,192,192) );
  }

  hOldFont = (HFONT)SelectObject( hDC , hFont );

  // Check is disabled, put space
  if( (WCHAR)0 == wc )
    wc = (WCHAR)0x20;

  GetCharWidth32( hDC , wc , wc , &iWidth );
  if( (prc->right-prc->left) > (iWidth) )
    xAnchor += (((prc->right-prc->left)-(iWidth))/2);

  ExtTextOut( hDC ,
              xAnchor,
              prc->top+4,
              ETO_OPAQUE | ETO_CLIPPED | ETO_IGNORELANGUAGE ,
              prc,
              &wc,
              1,
              NULL
            );


  // restore everything
  SelectObject( hDC , hOldFont );
  SetTextColor( hDC , oldTextColor );
  if( bEnabled )
    SetBkColor( hDC , oldBkColor );


  // rect everything else
  if( !bActive )
  {
    MyFrameRect( hDC , prc );//, GetStockObject( BLACK_BRUSH ) );
  }
  else
  {
    // Draw an inside focus if needed
    RECT rc;

    DrawFocusRect( hDC , prc );
    rc.left = prc->left+1;
    rc.right = prc->right-1;
    rc.top = prc->top+1;
    rc.bottom = prc->bottom-1;
    DrawFocusRect( hDC , &rc );
    rc.left += 1;
    rc.right -= 1;
    rc.top += 1;
    rc.bottom -= 1;
    DrawFocusRect( hDC , &rc );
  }

  return ;
}


/******************************Public*Routine******************************\
* GetCurrentRect
*
* Retreives the current active rect if visible
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline BOOL GetCurrentRect( RECT *prc )
{
  if( (-1 == gnCurRow) ||
      (gnCurRow < gnRowOffset) || (gnCurRow >= (gnRowOffset+gnMaxRow)) ||
      (gnCurCol < gnColOffset) || (gnCurCol >= (gnColOffset+gnMaxCol))
    )
  {
    return FALSE;
  }

//prc->left = GRID_XANCHOR+((gnCurCol-gnColOffset)*GRID_CELL_WIDTH);
  prc->left = Grid_XAnchor+((gnCurCol-gnColOffset)*GRID_CELL_WIDTH);
  prc->right = prc->left+GRID_CELL_WIDTH;
  prc->top = GRID_YANCHOR+((gnCurRow-gnRowOffset)*GRID_CELL_HEIGHT);
  prc->bottom = prc->top+GRID_CELL_HEIGHT;

  return TRUE;
}


/******************************Public*Routine******************************\
* GetCurrentGroupChar
*
* Retreives the current char (codepoint) of the currently selected group
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline void GetCurrentGroupChar( PWSTR pwCh )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));

  pGroup += (((gnCurRow)*pHeader->Column)+gnCurCol);
  *pwCh   = *(PWSTR)((PSTR)pGridUceMemFile->pvData+pGroup->OffsetGroupName) ;

  return;
}

/******************************Public*Routine******************************\
* IsCellEnabled
*
* Retreives the current char (codepoint) of the currently selected group
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/

__inline BOOL IsCellEnabled( INT nRow , INT nCol )
{
  DWORD       dwNum=0;
  DWORD       dwChOffset=0;
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));

  if(nRow >= pHeader->Row || nCol >= pHeader->Column) return FALSE;

  pGroup += (((nRow)*pHeader->Column)+nCol);
  dwChOffset   = pGroup->OffsetGroupName ;
  dwNum        = pGroup->NumChar ;

  return ((dwNum>0) && (dwChOffset!=0));
}

/******************************Public*Routine******************************\
* GridSamePointHit
*
* Checks if the point is within the lastly drawn rect. This is a good optimization
*
* Return Value:
*  TRUE if in same rect, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline BOOL GridSamePointHit( POINT pt )
{
  INT iNewRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
//INT iNewCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
  INT iNewCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

  if( (-1 == gnCurRow) ||
      ((iNewRow == gnCurRow) && (iNewCol == gnCurCol))
    )
  {
    return TRUE;
  }

  return FALSE;
}


/******************************Public*Routine******************************\
* GetUnicodeCharsFromGridWindow
*
* Reads the unicode content of the current selected group of the active
* UCE_MEMORY_FILE and fills in a buffer
*
* Return Value:
*  TRUE if successful, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GetUnicodeCharsFromGridWindow( HWND hWnd , PWSTR pwcBuf , UINT *puNum , BOOL *pbLineBreak)
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));
  PWSTR       pwc;

  if( -1 == gnCurRow )   // if invalid sel
    return FALSE;


  pGroup += (((gnCurRow)*pHeader->Column)+gnCurCol);
  pwc     = (PWSTR)((PSTR)pHeader+pGroup->OffsetGroupChar);
  *puNum = pGroup->NumChar;

  GetWChars( pGroup->NumChar , pwc , pwcBuf , puNum , pbLineBreak );

  return TRUE;
}


/******************************Public*Routine******************************\
* GetWChars
*
* Unified place to read wc from/tp
*
* Return Value:
*
* History:
*   Sept-18-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void GetWChars( INT nChars, WCHAR *pwc, WCHAR *pwcBuf, UINT *puNum, BOOL *pbLineBreak)
{
  DWORD dwI=0;
  DWORD dwCurCount=0;

  *pbLineBreak=FALSE;

  while( (INT)dwI<nChars )
  {
    // We need to fill the rest of row with spaces when we hit
    // a 0x0a. This is  to hack the current implementation
    // of the main grid
    if( (WCHAR)0x0a == *pwc )
    {
      DWORD dwLeft = ((dwCurCount)%20);
      dwLeft = 20L - dwLeft;
      *puNum += dwLeft;
      dwCurCount += dwLeft;
      while( dwLeft )
      {
        *pwcBuf = (WCHAR)' ';
        pwcBuf++;
        dwLeft--;
      }

      pwc++;
      *puNum -= 1;    // the 0x0a
      dwI++;
      *pbLineBreak=TRUE;
      continue;
    }

    // let's fill real stuff
    *pwcBuf = *pwc;

    // We need to fill the rest of row with spaces till we hit
    pwcBuf++;
    pwc++;
    dwI++;

    dwCurCount++;
  }
}

/******************************Public*Routine******************************\
* IsGridWindowAlive
*
* Checks if the grid window is created
*
* Return Value:
*  TRUE if so, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsGridWindowAlive( void )
{
  return (ghwndGrid != NULL) ;
}


/******************************Public*Routine******************************\
* IsAnyListWindow
*
* Checks if any grid/list window is created
*
* Return Value:
*  TRUE if so, otherwise FALSE
* History:
*   Sept-16-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsAnyListWindow( void )
{
  return ((ghwndGrid != NULL) || (ghwndList != NULL));
}

/******************************Public*Routine******************************\
* CreateResources
*
* Creates any global resources the would be needed during the app lifetime
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void CreateResources( HINSTANCE hInst, HWND hWnd )
{
  HDC hDC;

  InitListWindow( hInst );
  InitGridWindow( hInst );

  hpenDash = CreatePen( PS_SOLID , 0 , RGB(128,128,128));

  hDC = GetDC(hWnd);

//  hfStatic = CreateFont( -MulDiv(DIALOG_FONT_SIZE,
//                           GetDeviceCaps(hDC, LOGPIXELSY), 72),
  hfStatic = CreateFont( GRID_CELL_HEIGHT-7,
                         0,
                         0,0,0,
                         0,0,0,0,
                         OUT_DEFAULT_PRECIS,
                         CLIP_DEFAULT_PRECIS,
                         DEFAULT_QUALITY,
                         DEFAULT_PITCH|FF_DONTCARE,
                         DIALOG_FONT_NAME
                       );

  ReleaseDC(hWnd, hDC);
}


/******************************Public*Routine******************************\
* DeleteResources
*
* Deletes any global resources that had been created through CreateResources
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DeleteResources( void )
{
  if( hFont )
    DeleteObject( hFont );

  if( hfList )
    DeleteObject( hfList );

  if( hpenDash )
    DeleteObject( hpenDash );

  if( hfStatic )
    DeleteObject( hfStatic );

  UnregisterClass( wszListWndClass , hInst );
  UnregisterClass( wszGridWndClass , hInst );
}


/******************************Public*Routine******************************\
* CreateNewGridFont
*
* Creates a new font for the grid when the selection changes
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
/*
BOOL CreateNewGridFont( HWND hWnd , UINT uID )
{
  if( ghwndGrid )
  {
    UpdateGridFont( hWnd , uID );
    InvalidateRect( ghwndGrid , NULL , FALSE );
  }

  return TRUE;
}
*/


/******************************Public*Routine******************************\
* UpdateGridFont
*
* Creates a new hFont based on the current font selection
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL UpdateGridFont( HWND hwndParent , UINT uID )
{
/*
  INT  nIndex;
  INT  iCharset=0;
  BOOL bRet=FALSE;

  // Let's create the font that is in the list
  nIndex = SendDlgItemMessage( hwndParent,
                               uID,
                               CB_GETCURSEL,
                               (WPARAM) 0,
                               (LPARAM) 0L
                             );
  if( CB_ERR != nIndex )
  {
    WCHAR wszFontName[64];
    SendDlgItemMessage( hwndParent,
                        uID,
                        CB_GETLBTEXT,
                        (WPARAM) nIndex,
                        (LPARAM) (LPWSTR) &wszFontName[0]
                      );

    // if we have already created one, let's delete it
    if( hFont )
      DeleteObject( hFont );

    // Let's try grab a correct charset, if possible
    iCharset = Font_GetSelFontCharSet( hwndParent , ID_FONT , nIndex );

    hFont = CreateFont( (GRID_CELL_HEIGHT-6) ,
                        0,
                        0,0,0,
                        0,0,0,iCharset,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        &wszFontName[0]
                       );

    bRet = TRUE;
  }

  return bRet;
  */
  if( hFont )
    DeleteObject( hFont );

  hFont = CreateFont( (GRID_CELL_HEIGHT-6) ,
                      0,
                      0,0,0,
                      0,0,0,DEFAULT_CHARSET,
                      OUT_DEFAULT_PRECIS,
                      CLIP_DEFAULT_PRECIS,
                      PROOF_QUALITY,
                      VARIABLE_PITCH|FF_MODERN,
                      TEXT("MS Shell Dlg")
                     );

  return TRUE;
}

/******************************Public*Routine******************************\
* CreateNewListFont
*
* Creates a new font for the list when the selection changes
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
/*
BOOL CreateNewListFont( HWND hWnd , UINT uID )
{
  if( ghwndGrid )
  {
    UpdateListFont( hWnd , uID );
    InvalidateRect( ghwndList , NULL , FALSE );
  }

  return TRUE;
}
*/


/******************************Public*Routine******************************\
* UpdateListFont
*
* Creates a new hFont based on the current font selection
*
* Return Value:
*
* History:
\**************************************************************************/
BOOL UpdateListFont( HWND hwndParent , UINT uID )
{
/*
  INT  nIndex;
  INT  iCharset=0;
  BOOL bRet=FALSE;

  // Let's create the font that is in the list
  nIndex = SendDlgItemMessage( hwndParent,
                               uID,
                               CB_GETCURSEL,
                               (WPARAM) 0,
                               (LPARAM) 0L
                             );
  if( CB_ERR != nIndex )
  {
    // if we have already created one, let's delete it
    if( hfList )
      DeleteObject( hfList );

    // Let's try grab a correct charset, if possible
    iCharset = Font_GetSelFontCharSet( hwndParent , ID_FONT , nIndex );

    hfList = CreateFont( GRID_CELL_HEIGHT-7,            // 12,
                        0,
                        0,0,0,
                        0,0,0,iCharset,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        DIALOG_FONT_NAME
                       );

    bRet = TRUE;
  }

  return bRet;
*/
    int nHight = GRID_CELL_HEIGHT-7;

    if( hfList )
      DeleteObject( hfList );

    // If it is a BiDi localized use a one pixel biger font.
    if (GetWindowLongPtr(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
        nHight = GRID_CELL_HEIGHT-6;
    }

    hfList = CreateFont( nHight,            // 12,
                        0,
                        0,0,0,
                        0,0,0,DEFAULT_CHARSET,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        DIALOG_FONT_NAME
                       );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\enumfetc.c ===
//**********************************************************************
// File name: cdataobj.h
//
//  Standard implementation of IEnumFormatEtc. This code
//  is from \ole2\samp\ole2ui\enumfetc.c in the OLE 2 SDK.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#define STRICT  1
#include <windows.h>
#include <ole2.h>
#include "enumfetc.h"

typedef struct tagOleStdEnumFmtEtc {
  IEnumFORMATETCVtbl FAR* lpVtbl;
  ULONG m_dwRefs;       /* referance count */
  ULONG m_nIndex;       /* current index in list */
  ULONG m_nCount;       /* how many items in list */
  LPFORMATETC m_lpEtc;  /* list of formatetc */
} OLESTDENUMFMTETC, FAR* LPOLESTDENUMFMTETC;

VOID  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC pEtc);

STDMETHODIMP OleStdEnumFmtEtc_QueryInterface(
        LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt,
                                  LPFORMATETC rgelt, ULONG FAR* pceltFetched);
STDMETHODIMP  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt);
STDMETHODIMP  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis,
                                     LPENUMFORMATETC FAR* ppenum);

static IEnumFORMATETCVtbl g_EnumFORMATETCVtbl = {
        OleStdEnumFmtEtc_QueryInterface,
        OleStdEnumFmtEtc_AddRef,
        OleStdEnumFmtEtc_Release,
        OleStdEnumFmtEtc_Next,
        OleStdEnumFmtEtc_Skip,
        OleStdEnumFmtEtc_Reset,
        OleStdEnumFmtEtc_Clone,
};

/////////////////////////////////////////////////////////////////////////////


STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPMALLOC lpMalloc=NULL;
  LPOLESTDENUMFMTETC lpEF=NULL;
  DWORD dwSize;
  WORD i;
  HRESULT hRes;

  hRes = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
  if (hRes != NOERROR) {
    return NULL;
  }

  lpEF = (LPOLESTDENUMFMTETC)lpMalloc->lpVtbl->Alloc(lpMalloc,
                                                 sizeof(OLESTDENUMFMTETC));
  if (lpEF == NULL) {
    goto errReturn;
  }

  lpEF->lpVtbl = &g_EnumFORMATETCVtbl;
  lpEF->m_dwRefs = 1;
  lpEF->m_nCount = nCount;
  lpEF->m_nIndex = 0;

  dwSize = sizeof(FORMATETC) * lpEF->m_nCount;

  lpEF->m_lpEtc = (LPFORMATETC)lpMalloc->lpVtbl->Alloc(lpMalloc, dwSize);
  if (lpEF->m_lpEtc == NULL)
    goto errReturn;

  lpMalloc->lpVtbl->Release(lpMalloc);

  for (i=0; i<nCount; i++) {
    OleStdCopyFormatEtc(
            (LPFORMATETC)&(lpEF->m_lpEtc[i]), (LPFORMATETC)&(lpEtc[i]));
  }

  return (LPENUMFORMATETC)lpEF;

errReturn:
  if (lpEF != NULL)
    lpMalloc->lpVtbl->Free(lpMalloc, lpEF);

  if (lpMalloc != NULL)
    lpMalloc->lpVtbl->Release(lpMalloc);

  return NULL;

} /* OleStdEnumFmtEtc_Create()
   */


VOID
  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC lpEF)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
    LPMALLOC lpMalloc=NULL;
    WORD i;

    if (lpEF != NULL) {

        if (CoGetMalloc(MEMCTX_TASK, &lpMalloc) == NOERROR) {

            /* OLE2NOTE: we MUST free any memory that was allocated for
            **    TARGETDEVICES contained within the FORMATETC elements.
            */
            for (i=0; i<lpEF->m_nCount; i++) {
                OleStdFree(lpEF->m_lpEtc[i].ptd);
            }

            if (lpEF->m_lpEtc != NULL) {
                lpMalloc->lpVtbl->Free(lpMalloc, lpEF->m_lpEtc);
            }

            lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
            lpMalloc->lpVtbl->Release(lpMalloc);
        }
    }

} /* OleStdEnumFmtEtc_Destroy()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_QueryInterface(
                LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  *ppobj = NULL;

  if (IsEqualIID(riid,&IID_IUnknown) || IsEqualIID(riid,&IID_IEnumFORMATETC)){
    *ppobj = (LPVOID)lpEF;
  }

  if (*ppobj == NULL) return ResultFromScode(E_NOINTERFACE);
  else{
    OleStdEnumFmtEtc_AddRef(lpThis);
    return NOERROR;
  }

} /* OleStdEnumFmtEtc_QueryInterface()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  return lpEF->m_dwRefs++;

} /* OleStdEnumFmtEtc_AddRef()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  DWORD dwRefs = --lpEF->m_dwRefs;

  if (dwRefs == 0)
    OleStdEnumFmtEtc_Destroy(lpEF);

  return dwRefs;

} /* OleStdEnumFmtEtc_Release()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt, LPFORMATETC rgelt,
                      ULONG FAR* pceltFetched)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  ULONG nOffset;

  if (rgelt == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  while (i < celt) {
    nOffset = lpEF->m_nIndex + i;

    if (nOffset < lpEF->m_nCount) {
      OleStdCopyFormatEtc(
            (LPFORMATETC)&(rgelt[i]), (LPFORMATETC)&(lpEF->m_lpEtc[nOffset]));
      i++;
    }else{
      break;
    }
  }

  lpEF->m_nIndex += (WORD)i;

  if (pceltFetched != NULL) {
    *pceltFetched = i;
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Next()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  ULONG nOffset;

  while (i < celt) {
    nOffset = lpEF->m_nIndex + i;

    if (nOffset < lpEF->m_nCount) {
      i++;
    }else{
      break;
    }
  }

  lpEF->m_nIndex += (WORD)i;

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Skip()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  lpEF->m_nIndex = 0;

  return NOERROR;
} /* OleStdEnumFmtEtc_Reset()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis, LPENUMFORMATETC FAR* ppenum)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;

  if (ppenum == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  *ppenum = OleStdEnumFmtEtc_Create(lpEF->m_nCount, lpEF->m_lpEtc);

  // make sure cloned enumerator has same index state as the original
  if (*ppenum) {
      LPOLESTDENUMFMTETC lpEFClone = (LPOLESTDENUMFMTETC)*ppenum;
      lpEFClone->m_nIndex = lpEF->m_nIndex;
      return NOERROR;
  } else
      return ResultFromScode(E_OUTOFMEMORY);

} /* OleStdEnumFmtEtc_Clone()
   */

/*
 * OleStdCopyTargetDevice()
 *
 * Purpose:
 *  duplicate a TARGETDEVICE struct. this function allocates memory for
 *  the copy. the caller MUST free the allocated copy when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  ptdSrc      pointer to source TARGETDEVICE
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc
 *    if ptdSrc==NULL then retuns NULL is returned.
 *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc)
{
  DVTARGETDEVICE FAR* ptdDest = NULL;

  if (ptdSrc == NULL) {
    return NULL;
  }

  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc->tdSize)) != NULL) {
      memcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
  }

  return ptdDest;
}


/*
 * OleStdCopyFormatEtc()
 *
 * Purpose:
 *  Copies the contents of a FORMATETC structure. this function takes
 *  special care to copy correctly copying the pointer to the TARGETDEVICE
 *  contained within the source FORMATETC structure.
 *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy
 *  of the TARGETDEVICE will be allocated for the destination of the
 *  FORMATETC (petcDest).
 *
 *  OLE2NOTE: the caller MUST free the allocated copy of the TARGETDEVICE
 *  within the destination FORMATETC when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  petcDest      pointer to destination FORMATETC
 *  petcSrc       pointer to source FORMATETC
 *
 * Return Value:
 *    returns TRUE is copy is successful; retuns FALSE if not successful
 */
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
  if ((petcDest == NULL) || (petcSrc == NULL)) {
    return FALSE;
  }

  petcDest->cfFormat = petcSrc->cfFormat;
  petcDest->ptd      = OleStdCopyTargetDevice(petcSrc->ptd);
  petcDest->dwAspect = petcSrc->dwAspect;
  petcDest->lindex   = petcSrc->lindex;
  petcDest->tymed    = petcSrc->tymed;

  return TRUE;

}

/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
        return;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
        return;
    }

    pmalloc->lpVtbl->Free(pmalloc, pmem);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }
}

/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
    LPVOID pout;
    LPMALLOC pmalloc;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
        return NULL;
    }

    pout = (LPVOID)pmalloc->lpVtbl->Alloc(pmalloc, ulSize);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

    return pout;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\enumfetc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc);
STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\htmlhelp.h ===
/****************************************************************************
*                                                                           *
* HtmlHelp.h																*
*                                                                           *
* Copyright (c) 1996-1999 Microsoft Corp.                       			*
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

//	Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC		0x0000
#define HH_HELP_FINDER			0x0000	// WinHelp equivalent
#define HH_DISPLAY_TOC			0x0001	// not currently implemented
#define HH_DISPLAY_INDEX		0x0002	// not currently implemented
#define HH_DISPLAY_SEARCH		0x0003	// not currently implemented
#define HH_SET_WIN_TYPE 		0x0004
#define HH_GET_WIN_TYPE 		0x0005
#define HH_GET_WIN_HANDLE		0x0006
#define HH_GET_INFO_TYPES		0x0007	// not currently implemented
#define HH_SET_INFO_TYPES		0x0008	// not currently implemented
#define HH_SYNC 				0x0009
#define HH_ADD_NAV_UI			0x000A	// not currently implemented
#define HH_ADD_BUTTON			0x000B	// not currently implemented
#define HH_GETBROWSER_APP		0x000C	// not currently implemented
#define HH_KEYWORD_LOOKUP		0x000D
#define HH_DISPLAY_TEXT_POPUP	0x000E	// display string resource id or text in a popup window
#define HH_HELP_CONTEXT 		0x000F	// display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU	0x0010	// text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP		0x0011	// text popup help, same as WinHelp HELP_WM_HELP


#define HHWIN_PROP_ONTOP		  (1 << 1)	  // Top-most window (not currently implemented)
#define HHWIN_PROP_NOTITLEBAR	  (1 << 2)	  // no title bar
#define HHWIN_PROP_NODEF_STYLES   (1 << 3)	  // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES (1 << 4)	  // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE 	  (1 << 5)	  // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT	  (1 << 6)	  // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT	  (1 << 7)	  // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC	  (1 << 8)	  // automatically ssync contents and index
#define HHWIN_PROP_TRACKING 	  (1 << 9)	  // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH	  (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY	  (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES  (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE   (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN   (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR	  (1 << 15)   // Don't display a toolbar

#define HHWIN_PARAM_PROPERTIES		(1 << 1)	 // valid fsWinProperties
#define HHWIN_PARAM_STYLES			(1 << 2)	 // valid dwStyles
#define HHWIN_PARAM_EXSTYLES		(1 << 3)	 // valid dwExStyles
#define HHWIN_PARAM_RECT			(1 << 4)	 // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH		(1 << 5)	 // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE		(1 << 6)	 // valid nShowState
#define HHWIN_PARAM_INFOTYPES		(1 << 7)	 // valid ainfoTypes
#define HHWIN_PARAM_TB_FLAGS		(1 << 8)	 // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION		(1 << 9)	 // valid fExpanded
#define HHWIN_PARAM_TABPOS			(1 << 10)	 // valid tabpos
#define HHWIN_PARAM_TABORDER		(1 << 11)	 // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT	(1 << 12)	 // valid cHistory
#define HHWIN_PARAM_CUR_TAB 		(1 << 13)	 // valid curNavType

#define HHWIN_BUTTON_EXPAND 		(1 << 1)	 // Expand/contract button
#define HHWIN_BUTTON_BACK			(1 << 2)	 // Back button
#define HHWIN_BUTTON_FORWARD		(1 << 3)	 // Forward button
#define HHWIN_BUTTON_STOP			(1 << 4)	 // Stop button
#define HHWIN_BUTTON_REFRESH		(1 << 5)	 // Refresh button
#define HHWIN_BUTTON_HOME			(1 << 6)	 // Home button
#define HHWIN_BUTTON_BROWSE_FWD 	(1 << 7)	 // not implemented
#define HHWIN_BUTTON_BROWSE_BCK 	(1 << 8)	 // not implemented
#define HHWIN_BUTTON_NOTES			(1 << 9)	 // not implemented
#define HHWIN_BUTTON_CONTENTS		(1 << 10)	 // not implemented
#define HHWIN_BUTTON_SYNC			(1 << 11)	 // Sync button
#define HHWIN_BUTTON_OPTIONS		(1 << 12)	 // Options button
#define HHWIN_BUTTON_PRINT			(1 << 13)	 // Print button
#define HHWIN_BUTTON_INDEX			(1 << 14)	 // not implemented
#define HHWIN_BUTTON_SEARCH 		(1 << 15)	 // not implemented
#define HHWIN_BUTTON_HISTORY		(1 << 16)	 // not implemented
#define HHWIN_BUTTON_FAVORITES		(1 << 17)	 // not implemented
#define HHWIN_BUTTON_JUMP1			(1 << 18)
#define HHWIN_BUTTON_JUMP2			(1 << 19)
#define HHWIN_BUTTON_ZOOM        (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT    (1 << 21)
#define HHWIN_BUTTON_TOC_PREV    (1 << 22)

// Ralphs default toolbar.
//
//#define HHWIN_DEF_BUTTONS  (HHWIN_BUTTON_EXPAND | HHWIN_BUTTON_BACK | HHWIN_BUTTON_OPTIONS | HHWIN_BUTTON_PRINT)

// VSHH's default toolbar for testing purposes only.
//
#define HHWIN_DEF_BUTTONS  (HHWIN_BUTTON_TOC_NEXT | HHWIN_BUTTON_TOC_PREV | HHWIN_BUTTON_SYNC | HHWIN_BUTTON_EXPAND | \
                            HHWIN_BUTTON_BACK | HHWIN_BUTTON_OPTIONS | HHWIN_BUTTON_PRINT | HHWIN_BUTTON_ZOOM)

// Button IDs

#define IDTB_EXPAND 				200
#define IDTB_CONTRACT				201
#define IDTB_STOP					202
#define IDTB_REFRESH				203
#define IDTB_BACK					204
#define IDTB_HOME					205
#define IDTB_SYNC					206
#define IDTB_PRINT					207
#define IDTB_OPTIONS				208
#define IDTB_FORWARD				209
#define IDTB_NOTES					210 // not implemented
#define IDTB_BROWSE_FWD 			211
#define IDTB_BROWSE_BACK			212
#define IDTB_CONTENTS				213 // not implemented
#define IDTB_INDEX					214 // not implemented
#define IDTB_SEARCH 				215 // not implemented
#define IDTB_HISTORY				216 // not implemented
#define IDTB_FAVORITES				217 // not implemented
#define IDTB_JUMP1					218
#define IDTB_JUMP2					219
#define IDTB_ZOOM						221
#define IDTB_TOC_NEXT				222
#define IDTB_TOC_PREV				223

// Notification codes

#define HHN_FIRST	(0U-860U)
#define HHN_LAST	(0U-879U)

#define HHN_NAVCOMPLETE (HHN_FIRST-0)
#define HHN_TRACK		(HHN_FIRST-1)

typedef struct tagHHN_NOTIFY
{
	NMHDR	hdr;
	PCSTR	pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
	int 	  cbStruct; 	 // sizeof this structure
	HINSTANCE hinst;		 // instance handle for string resource
	UINT	  idString; 	 // string resource id, or text id if pszFile is specified in HtmlHelp call
	LPCTSTR   pszText;		 // used if idString is zero
	POINT	  pt;			 // top center of popup window
	COLORREF  clrForeground; // use -1 for default
	COLORREF  clrBackground; // use -1 for default
	RECT	  rcMargins;	 // amount of space between edges of window and text, -1 for each member to ignore
	LPCTSTR   pszFont;		 // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
	int 	  cbStruct; 	// sizeof this structure
	BOOL	  fReserved;	// must be FALSE (really!)
	LPCTSTR   pszKeywords;	// semi-colon separated keywords
	LPCTSTR   pszUrl;		// URL to jump to if no keywords found (may be NULL)
	LPCTSTR   pszMsgText;	// Message text to display in MessageBox if pszUrl is NULL and no keyword match
	LPCTSTR   pszMsgTitle;	// Message text to display in MessageBox if pszUrl is NULL and no keyword match
	LPCTSTR   pszWindow;	// Window to display URL in
	BOOL      fIndexOnFail;	// Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
	HHACT_EXPAND,
	HHACT_CONTRACT,
	HHACT_BACK,
	HHACT_FORWARD,
	HHACT_STOP,
	HHACT_REFRESH,
	HHACT_HOME,
	HHACT_SYNC,
	HHACT_OPTIONS,
	HHACT_PRINT,

	HHACT_TAB_CONTENTS,
	HHACT_TAB_INDEX,
	HHACT_TAB_SEARCH,
	HHACT_TAB_HISTORY,
	HHACT_TAB_FAVORITES,
};

typedef struct tagHHNTRACK
{
	NMHDR	hdr;
	PCSTR	pszCurUrl;	// Multi-byte, null-terminated string
	int 	idAction;	// HHACT_ value
} HHNTRACK;

enum {
	HHWIN_NAVTYPE_TOC,
	HHWIN_NAVTYPE_INDEX,
	HHWIN_NAVTYPE_SEARCH,
	HHWIN_NAVTYPE_HISTORY,		// not implemented
	HHWIN_NAVTYPE_FAVORITES,	// not implemented
};

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
	HHWIN_NAVTAB_TOP,
	HHWIN_NAVTAB_LEFT,
	HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19	// maximum number of tabs
enum {
	HH_TAB_CONTENTS,
	HH_TAB_INDEX,
	HH_TAB_SEARCH,
	HH_TAB_HISTORY,
	HH_TAB_FAVORITES,
};

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
	int cbStruct;			   // Sizeof structure in bytes.
	BOOL fUniCodeStrings;	   // TRUE if all strings are unicode.
	LPCTSTR pszSearchQuery;    // String containing the search query.
	LONG iProximity;		   // Word proximity.
	BOOL fStemmedSearch;	   // TRUE for StemmedSearch only.
	BOOL fTitleOnly;		   // TRUE for Title search only.
	BOOL fExecute;			   // TRUE to initiate the search.
	LPCTSTR pszWindow;		   // Window to display in
} HH_FTS_QUERY;


// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
	int 	cbStruct;		  // IN: size of this structure including all Information Types
	BOOL	fUniCodeStrings;  // IN/OUT: TRUE if all strings are in UNICODE
	LPCTSTR pszType;		  // IN/OUT: Name of a type of window
	DWORD	fsValidMembers;   // IN: Bit flag of valid members (HHWIN_PARAM_)
	DWORD	fsWinProperties;  // IN/OUT: Properties/attributes of the window (HHWIN_)

	LPCTSTR pszCaption; 	// IN/OUT: Window title
	DWORD	dwStyles;		// IN/OUT: Window styles
	DWORD	dwExStyles; 	// IN/OUT: Extended Window styles
	RECT	rcWindowPos;	// IN: Starting position, OUT: current position
	int 	nShowState; 	// IN: show state (e.g., SW_SHOW)

	HWND  hwndHelp; 		// OUT: window handle
	HWND  hwndCaller;		// OUT: who called this window

	HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

	// The following members are only valid if HHWIN_PROP_TRI_PANE is set

	HWND  hwndToolBar;		// OUT: toolbar window in tri-pane window
	HWND  hwndNavigation;	// OUT: navigation window in tri-pane window
	HWND  hwndHTML; 		// OUT: window displaying HTML in tri-pane window
	int   iNavWidth;		// IN/OUT: width of navigation window
	RECT  rcHTML;			// OUT: HTML window coordinates

	LPCTSTR pszToc; 		// IN: Location of the table of contents file
	LPCTSTR pszIndex;		// IN: Location of the index file
	LPCTSTR pszFile;		// IN: Location of the html file
	LPCTSTR pszHome;		// IN/OUT: html file to display when Home button is clicked
	DWORD	fsToolBarFlags; // IN: flags controling the appearance of the toolbar
	BOOL	fNotExpanded;	// IN: TRUE/FALSE to expand or contract, OUT: current state
	int 	curNavType; 	// IN/OUT: UI to display in the navigational pane
	int 	tabpos; 		// IN/OUT: NAVTAB_TOP, NAVTAB_LEFT, or NAVTAB_BOTTOM
	int 	idNotify;		// IN: ID to use for WM_NOTIFY messages
	BYTE	tabOrder[HH_MAX_TABS + 1];	  // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
	int 	cHistory;		// IN/OUT: number of history items to keep (default is 30)
	LPCTSTR pszJump1;		// Text for HHWIN_BUTTON_JUMP1
	LPCTSTR pszJump2;		// Text for HHWIN_BUTTON_JUMP2
	LPCTSTR pszUrlJump1;	// URL for HHWIN_BUTTON_JUMP1
	LPCTSTR pszUrlJump2;	// URL for HHWIN_BUTTON_JUMP2
	RECT	rcMinSize;		// Minimum size for window (ignored in version 1)
} HH_WINTYPE, *PHH_WINTYPE;

HWND
WINAPI
HtmlHelpA(
	HWND hwndCaller,
	LPCSTR pszFile,
	UINT uCommand,
	DWORD dwData
	);

HWND
WINAPI
HtmlHelpW(
	HWND hwndCaller,
	LPCWSTR pszFile,
	UINT uCommand,
	DWORD dwData
	);
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI	  (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\kd.cxx ===
/****************************************************************************

    kd.c

    PURPOSE: codepage related utilities for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#define  NOT_EUDC(wc)  ((wc)<0xE000||(wc)>0xF8FF)

///////////////////////////////////////////////////////////////
//
// For a give codePage,
//   fills in array of defined Unicode chars
//
//  Parameter : CodePage : 0 for Unicode
//                       : any valid codepage
//
//              lpWC     : WCHAR pointer to hold the result
//                       : set to NULL to get array size
//
//  Returns : 0 for a invalid codepage
//            number of WChar for a valid codepage
//
////////////////////////////////////////////////////////////////
long
WCharCP(
   UINT CodePage,
   WCHAR *lpWC)
{
  long   lRet = 0;
  CPINFO cpinfo;
  BYTE   mb[2];
  WCHAR  wc;
  WORD   ctype;

  if(CodePage == UNICODE_CODEPAGE)                  // cp-1200
  {
    for(wc = ASCII_BEG; wc < 0xFFFF; wc++)
    {
      if(NOT_EUDC(wc))                              // always include EUDC
      {
        GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
        if((!ctype))  continue;
      }

      if(lpWC != NULL) lpWC[lRet] = wc;
      lRet++;
    }
    return lRet;
  }

  if(!IsValidCodePage(CodePage))    return 0L;
  if(!GetCPInfo(CodePage, &cpinfo)) return 0L;

  // ASCii : 0x21 ~ 0x7F
  for(mb[0] = ASCII_BEG; mb[0] <= ASCII_END; mb[0]++)
  {
    if(MultiByteToWideChar(
            CodePage,
            MB_ERR_INVALID_CHARS,
            (const char *)mb, 1,
            &wc, 1) == 0)
        continue;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
    if(ctype & C1_CNTRL)
        continue;

    if(lpWC != NULL)
        lpWC[lRet] = wc;

    lRet++;
  }

// Single-Byte codepage only; Extended chars 0x80 ~ 0xFF

  for(mb[0] = HIANSI_BEG; mb[0] > 0; (mb[0])++)
  {
    if(MultiByteToWideChar(
                  CodePage,
                  MB_ERR_INVALID_CHARS,
                  (const char *)mb, 1,
                  &wc, 1) == 0)
          continue;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
    if((!ctype) ||
       ( ctype & C1_CNTRL))
       continue;

    if(lpWC != NULL)
        lpWC[lRet] = wc;

    lRet++;
  }

  if(cpinfo.MaxCharSize == 1)
      return lRet++;

  // DBCS only
  for(mb[0] = HIANSI_BEG; mb[0] < HIANSI_END; (mb[0])++)
  {
    if(!IsDBCSLeadByteEx(CodePage, mb[0]))
        continue;

    for(mb[1] = TRAILBYTE_BEG; mb[1] <= TRAILBYTE_END; (mb[1])++)
    {
      if(mb[1] == DELETE_CHAR)               // 0x7F is not a trail byte
          continue;

      if(MultiByteToWideChar(
                    CodePage,
                    MB_ERR_INVALID_CHARS,
                    (const char *)mb, 2,
                    &wc, 1) == 0)
            continue;

      if(NOT_EUDC(wc))                       // always include EUDC
      {
        GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
        if((!ctype) ||
           ( ctype & C1_CNTRL))
           continue;
      }

      if(lpWC != NULL)
          lpWC[lRet] = wc;

      lRet++;
    }
  }

  return lRet;
}

///////////////////////////////////////////////////////////
//
//  find defined glyphs from an EUDC TTF font (*.tte)
//
///////////////////////////////////////////////////////////

#define W_REVERSE(w)    ((w>>8)+(w<<8))
#define DW_REVERSE(dw)  ((dw>>24)+(dw<<24)+((dw&0x00FF0000)>>8)+((dw&0x0000FF00)<<8))

typedef struct
{
    char    cTag[4];        // ttcf
    DWORD   dwVersion;
    DWORD   dwDirCount;
    DWORD   dwOffset1;

} TTCHead;

typedef struct
{
    DWORD   dwVersion;
    WORD    wNumTables;
    WORD    wSearchRange;
    WORD    wEntrySelector;
    WORD    wRangeShift;

} Header;

typedef struct
{
    char    cTag[4];
    DWORD   dwCheckSum;
    DWORD   dwOffset;
    DWORD   dwLength;

} TableDir;

typedef struct
{
    DWORD   dwVersion;
    WORD    wNumGlyphs;

} maxp;

typedef struct
{
    DWORD   dwVersion;          // 00000001 (00 01 00 00)
    BYTE    Filler[46];
    WORD    IndexToLocFormat;   // 0 for short offset, 1 for long

} head;

typedef struct
{
    WORD    wVersion;           // 0
    WORD    wNumTables;

} cmapHead;

typedef struct
{
    WORD    wPlatform;           // 3 for Microsoft
    WORD    wEncoding;           // 1 for Unicode, 0 for Symbol
    DWORD   dwOffset;

} cmap;

typedef struct
{
    WORD    wFormat;             // 4
    WORD    wLength;
    WORD    wVersion;
    WORD    wSegCountX2;
    WORD    wSeachRange;
    WORD    wEntrySelector;
    WORD    wRangeShift;

} Format4;

typedef struct
{
    WORD    wBeg;
    WORD    wEnd;
    WORD    wDelta;

} URDelta;

//////////////////////////////////////////////////////////////////////////
//
//  Simulate cmap ranges for a EUDC TTTF font file (*.tte)
//
//      Path   : file name with path
//      pSize  : number of Unicode ranges returned
//
//      return : pointer to an array of Unicode ranges
//
//////////////////////////////////////////////////////////////////////////

URANGE* EUDC_Range(TCHAR* Path, DWORD* pSize)
{
    HANDLE   hTTF, hTTFMap;
    DWORD    dwFileSize;
    LPVOID   lpvTTF;
    BYTE    *lp;
    WORD     i;

    WORD     LocFormat;
    BYTE    *pLoca;
    DWORD    dwAdjustTTC;

    WORD     NumTables = 0;
    WORD     NumGlyphs = 0;
    WORD     NumURange = 0;
    URDelta *pURDelta  = 0;
    URANGE  *pUR = 0;

    *pSize = 0;

	hTTF = CreateFile(Path,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_READONLY,
                      NULL);
	if(hTTF == INVALID_HANDLE_VALUE)
	{
		return pUR;
	}
	
	dwFileSize = GetFileSize(hTTF, NULL);
	hTTFMap = CreateFileMapping(hTTF,
                                NULL,
                                PAGE_READONLY,
                                0,
                                dwFileSize,
                                NULL);
	if(hTTFMap == NULL)
	{
		CloseHandle(hTTF);
		return pUR;
	}

	lpvTTF = MapViewOfFile(hTTFMap, FILE_MAP_READ, 0, 0, 0);
	if(lpvTTF == NULL)
	{
		CloseHandle(hTTFMap);
		CloseHandle(hTTF);
		return pUR;
	}

    lp = (BYTE*) lpvTTF;
    dwAdjustTTC = 0;
	if(lp[0] == 't' && lp[1] == 't' && lp[2] == 'c' && lp[3] == 'f')
    {
        TTCHead* ptr = (TTCHead*) lpvTTF;
        dwAdjustTTC = DW_REVERSE(ptr->dwOffset1);
    }

    lpvTTF = (BYTE*) lpvTTF + dwAdjustTTC;
    NumTables = W_REVERSE(((Header*)lpvTTF)->wNumTables);
    if(NumTables == 0) goto NextTTF;

    lp = (BYTE*) lpvTTF + sizeof(Header);
	for(i = 0; i < NumTables; i++)
	{
        TableDir* pTD = (TableDir*) lp;

		if( lp[0] == 'm' && lp[1] == 'a' &&
			lp[2] == 'x' && lp[3] == 'p')
        {
            maxp*   pmaxp = (maxp*) ((BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset));

            NumGlyphs = W_REVERSE(pmaxp->wNumGlyphs);
        }
		else if( lp[0] == 'h' && lp[1] == 'e' &&
			     lp[2] == 'a' && lp[3] == 'd')
        {
            head*   phead = (head*) ((BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset));

            LocFormat = W_REVERSE(phead->IndexToLocFormat);
        }
		else if( lp[0] == 'l' && lp[1] == 'o' &&
			     lp[2] == 'c' && lp[3] == 'a')
        {
            pLoca = (BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset);
        }
		else if( lp[0] == 'c' && lp[1] == 'm' &&
			     lp[2] == 'a' && lp[3] == 'p')
        {
            cmapHead *pCH;
            cmap     *pCmap;
            Format4  *pF4;
            BYTE     *pByte;
            WORD      wNum;
            int       i;

            pCH   = (cmapHead*) ((BYTE*)lpvTTF + DW_REVERSE(pTD->dwOffset));
            wNum  = W_REVERSE(pCH->wNumTables);
            pCmap = (cmap*) ((BYTE*)pCH + sizeof(cmapHead));
            for(i = 0; i < wNum; i++)
            {
                WORD Platform = W_REVERSE(pCmap->wPlatform);
                WORD Encoding = W_REVERSE(pCmap->wEncoding);
                if( Platform == 3 && (Encoding == 1 || Encoding == 0 ))
                {
                    WORD Format;

                    pF4 = (Format4*) ((BYTE*)pCH + DW_REVERSE(pCmap->dwOffset));
                    Format = W_REVERSE(pF4->wFormat);
                    if(Format == 4)
                    {
                        int   k;
                        WORD  w;

                        NumURange = (W_REVERSE(pF4->wSegCountX2) >> 1) - 1;
                        pURDelta   = (URDelta*) malloc(sizeof(URDelta)*NumURange);
                        if(!pURDelta) goto NextTTF;
                        pByte = (BYTE*) pF4 + sizeof(Format4);
                        for(k = 0; k < NumURange; k++)
                        {
                            w = *(WORD*)(pByte + sizeof(WORD)*k);
                            pURDelta[k].wEnd   = W_REVERSE(w);
                            w = *(WORD*)(pByte + sizeof(WORD)*(NumURange+1)   + 2 + sizeof(WORD)*k);
                            pURDelta[k].wBeg   = W_REVERSE(w);
                            w = *(WORD*)(pByte + sizeof(WORD)*(NumURange+1)*2 + 2 + sizeof(WORD)*k);
                            pURDelta[k].wDelta = W_REVERSE(w);
                        }
                    }

                    break;
                }
                pCmap += sizeof(cmap);
            }
        }

        lp += sizeof(TableDir);
	}

    if(NumGlyphs == 0) goto NextTTF;
    if(pLoca     == 0) goto NextTTF;
    if(NumURange == 0) goto NextTTF;
    if(pURDelta  == 0) goto NextTTF;

    {
        WORD  wLen = 4;
        WORD  wc;
        WORD  wGIdx;
        BOOL  HasGlyph;

        if(LocFormat == 0) wLen = 2;

        for(i = 0; i < NumURange; i++)
        {
            for(wc = pURDelta[i].wBeg; wc <= pURDelta[i].wEnd; wc++)
            {
                HasGlyph = FALSE;
                wGIdx = wc + pURDelta[i].wDelta;
                if(wGIdx > NumGlyphs)
                {
                    if(pUR) free(pUR);
                    pUR = 0;
                    goto NextTTF;
                }

                if(LocFormat == 0)
                {
                    if(*(WORD*)(pLoca + wLen * wGIdx) != *(WORD*)(pLoca + wLen * (wGIdx + 1)))
                        HasGlyph = TRUE;
                }
                else
                {
                    if(*(DWORD*)(pLoca + wLen * wGIdx) != *(DWORD*)(pLoca + wLen * (wGIdx + 1)))
                        HasGlyph = TRUE;
                }

                if(HasGlyph)
                {
                    if(pUR == 0)
                    {
                        (*pSize)++;
                        pUR = (URANGE *) malloc (sizeof(URANGE));
                        if(pUR == 0) goto NextTTF;
                        pUR[0].wcFrom = wc;
                        pUR[0].wcTo   = wc;
                    }
                    else
                    {
                        if(wc - pUR[(*pSize)-1].wcTo == 1)
                        {
                            (pUR[(*pSize)-1].wcTo)++;
                        }
                        else
                        {
                            (*pSize)++;
                            pUR = (URANGE *) realloc ((void*)pUR, sizeof(URANGE)*(*pSize));
                            if(pUR == 0) goto NextTTF;

                            pUR[(*pSize)-1].wcFrom = wc;
                            pUR[(*pSize)-1].wcTo   = wc;

                        }
                    }
                }           // if(HasGlyph)
            }               // for each Unicode range
        }                   // for all Unicode ranges.
    }

NextTTF:

//	UnMapViewOfFile(lpvTTF);
	CloseHandle(hTTFMap);
	CloseHandle(hTTF);
    if(pURDelta) free(pURDelta);
    return pUR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\oleedit.h ===
//**********************************************************************
// File name: oleedit.h
//
// Header file for extensions required to enable drag and drop with edit
// controls
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef OLEEDIT_H
#define OLEEDIT_H

BOOL SetEditProc(HWND hWndEdit);
LRESULT CALLBACK OleEnabledEditControlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL PointInSel(HWND hWnd, POINT ptDragStart);
int EditCtrlDragAndDrop(HWND hWndDlg, HWND hWndEdit, LPDROPSOURCE pDropSource);
int XToCP(HWND hWnd, LPTSTR lpszText, POINT ptDragStart);

#endif // OLEEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\resource.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by uce.rc
//
#define IDD_FONTCHANGEMSG               102
#define IDC_EDIT                        1000
#define IDC_CHECKNOMSG                  1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\olecomon.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#ifndef OLECOMON_H
#define OLECOMON_H

typedef LPVOID* PPVOID;
int DoDragAndDrop(HWND hWnd, LPDROPSOURCE pDropSource);

#ifdef _DEBUG
#define TRACE    OutputDebugString

#else // _DEBUG

#define TRACE    NOP_FUNCTION

#endif // _DEBUG

#endif // OLECOMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\oleedit.cxx ===
//**********************************************************************
// File name: oleedit.cxx
//
// Implements the extensions required to enable drag and drop with edit
// controls
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>

#include "olecomon.h"
#include "cdataobj.h"
#include "cdropsrc.h"
#include "uce.h"
#include "oleedit.h"

WNDPROC fnEditProc = NULL;

//**********************************************************************
// SetEditProc
//
// Purpose:
//      Replaces current Edit window procedure with a new procedure
//      capable of handling drag and drop
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
BOOL SetEditProc(HWND hWndEdit)
{
    fnEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)OleEnabledEditControlProc);

    return TRUE;
}

//**********************************************************************
// OleEnabledEditControlProc
//
// Purpose:
//      Edit control procedure capable of handling drag and drop
//
//**********************************************************************
LRESULT CALLBACK OleEnabledEditControlProc(HWND    hWnd,
                                           UINT    uMessage,
                                           WPARAM  wParam,
                                           LPARAM  lParam)
{
    static POINT        ptDragStart;
    static BOOL         fPendingDrag = FALSE;
    static LPDROPSOURCE pDropSource = NULL;

    switch(uMessage) {
    case WM_LBUTTONDOWN:
        {
            // In case there is no drop source create one
            if (pDropSource == NULL) {
                // Create an instance of CDropSource for Drag and Drop
                pDropSource = new CDropSource;

                if (pDropSource == NULL) {
                    // Show error message and prevent window from being shown
                    return -1;
                }
            }

            // Store the point at which LBUTTON was down
            ptDragStart.x = (int)(short)LOWORD (lParam);
            ptDragStart.y = (int)(short)HIWORD (lParam);

            // Find it point is in current selection
            // If it is then go to drag mode
            if (PointInSel(hWnd, ptDragStart)) {
                fPendingDrag = TRUE;

                // Start timer
                SetTimer(hWnd, 1, nDragDelay, NULL);
                SetCapture(hWnd);

                // Do not pass control to edit window because it removes selection
                return TRUE;
            }

            break;
        }

    case WM_LBUTTONUP:
        {
            // Button came up before starting drag so clear flags and timer
            if (fPendingDrag)
            {
                ReleaseCapture();
                KillTimer(hWnd, 1);
                fPendingDrag = FALSE;
            }
            break;
        }

    case WM_MOUSEMOVE:
        {
            int x, y;

            // If a drag is pending and mouse moves beyond threshold
            // then start our drag and drop operation
            if (fPendingDrag)
            {
                x = (int)(short)LOWORD (lParam);
                y = (int)(short)HIWORD (lParam);

                // Find if the point at which the mouse is is beyond the
                // min rectangle enclosing the point at which LBUTTON
                // was down
                if (! (((ptDragStart.x - nDragMinDist) <= x)
                    && (x <= (ptDragStart.x + nDragMinDist))
                    && ((ptDragStart.y - nDragMinDist) <= y)
                    && (y <= (ptDragStart.y + nDragMinDist))) )
                {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    EditCtrlDragAndDrop(GetParent(hWnd), hWnd, pDropSource);
                }
            }
            break;
        }

    case WM_TIMER:
        {
            // If the user has kept LBUTTON down for long then
            // start drag and drop operation
            ReleaseCapture();
            KillTimer(hWnd, 1);
            fPendingDrag = FALSE;

            // perform the modal drag/drop operation.
            EditCtrlDragAndDrop(GetParent(hWnd), hWnd, pDropSource);

            break;
        }

    case WM_DESTROY:
        {
            // Release pDropSource it will automatically destroy itself
            if (pDropSource)
                pDropSource->Release();

            break;
        }
    }

    return CallWindowProc(fnEditProc, hWnd, uMessage, wParam, lParam) ;
}

//**********************************************************************
// PointInSel
//
// Purpose:
//      Finds if the point provided is in current selection of edit control
//
// Parameters:
//      HWND  hWnd          -   Edit Control Handle
//      POINT ptDragStart   -   Point to be checked
//
// Return Value:
//      TRUE                -   Point in selection
//      FALSE               -   Point not in selection
//**********************************************************************
static BOOL PointInSel(HWND hWnd,
                       POINT ptDragStart)
{
    DWORD   dwStart, dwEnd;
    int     dwCharPos;
    TCHAR   szMessage[40];
    HGLOBAL hText;
    int     nChars, nRetChars;
    LPTSTR  lpszEditText;

    // Get current selection
    SendMessage(hWnd, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);

    // IF there is not selection
    if (dwStart == dwEnd) {
        return FALSE;
    }

    // EM_CHARFROMPOS did not work, find why
    // dwCharPos = SendMessage(hWnd, EM_CHARFROMPOS, (WPARAM)0L, (LPARAM)&ptDragStart);

    // Get text from edit control
    nChars = GetWindowTextLength(hWnd);
    if (!(hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT, CTOB((nChars + 1)))))
    {
        return (FALSE);
    }
    lpszEditText = (LPTSTR)GlobalLock(hText);

    nRetChars = GetWindowText(hWnd, lpszEditText, nChars+1);
    GlobalUnlock(hText);

    // Find char from click
    dwCharPos = XToCP(hWnd, lpszEditText, ptDragStart);
    GlobalFree(hText);

    wsprintf(szMessage, TEXT("%d %d %d\n"), dwStart, dwEnd, dwCharPos);
    TRACE(szMessage);

    // Find if it is within selection
    if (((DWORD)dwCharPos >= dwStart) && ((DWORD)dwCharPos < dwEnd)) {
        return TRUE; // Lbutton was down in selection
    }

    return FALSE;
}

//**********************************************************************
// XToCP
//
// Purpose:
//      Returns char index of the character nearest to specified point
//
// Parameters:
//      HWND    hWnd        -   Edit Control Handle
//      LPTSTR  lpszText    -   Edit control text
//      POINT   ptDragStart -   Point to be checked
//
// Return Value:
//      int                 -   Char nearest to specified point
//**********************************************************************
static int XToCP(HWND   hWnd,
                 LPTSTR lpszText,
                 POINT  ptDragStart)
{
    int     nLength, i, x = 0, xPos = ptDragStart.x;
    int     iWidth[2];
    BOOL    fSuccess, fCharFound=FALSE;
    HDC     hDC;
    HFONT   hFont, hOldFont;

    nLength = wcslen(lpszText);
    hDC = GetDC(hWnd);
    hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, (WPARAM)0L, (LPARAM)0L);
    hOldFont = (HFONT)SelectObject(hDC, hFont);

    for(i=0; i<nLength; i++) {
        fSuccess = GetCharWidth32(hDC,
            lpszText[i],
            lpszText[i],
            iWidth);

        if (fSuccess == FALSE) {
            ReleaseDC(hWnd, hDC);
            return -1;
        }

        x += iWidth[0];

        if (x > xPos) {
            fCharFound = TRUE;
            break;
        }
    }

    SelectObject(hDC, hOldFont);
    ReleaseDC(hWnd, hDC);

    return ((fCharFound==TRUE)? i: -1);
}

//**********************************************************************
// EditCtrlDragAndDrop
//
// Purpose:
//      Does drag and drop of text currently selected in edit control
//
// Parameters:
//      HWND          hWnd        -   Edit Control Handle
//      LPDROPSOURCE  pDropSource -   Pointer to drop source
//
// Return Value:
//      0                         -   Success
//      -1                        -   Failure
//**********************************************************************
static int EditCtrlDragAndDrop(HWND         hWndDlg,
                               HWND         hWndEdit,
                               LPDROPSOURCE pDropSource)
{
    PCImpIDataObject    pDataObject;
    DWORD               dwEffect, dwStart, dwEnd;
    LPTSTR              lpszEditText, lpszSelectedText;
    HGLOBAL             hText;
    int                 nChars, nRetChars;

    // Get current selection
    SendMessage(hWndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);
    // IF there is not selection
    if (dwStart == dwEnd) {
        return 0;
    }

    nChars = GetWindowTextLength(hWndEdit);
    if (!(hText = GlobalAlloc(0, CTOB((nChars + 1)))))
    {
        return (-1);
    }
    lpszEditText = (LPTSTR)GlobalLock(hText);
    nRetChars = GetWindowText(hWndEdit, lpszEditText, nChars+1);

    // The text in which we are interested is the selected text
    lpszSelectedText = lpszEditText + dwStart;
    lpszSelectedText[dwEnd-dwStart] = 0;

    GlobalUnlock(hText);

    // Create an instance of the DataObject
    pDataObject = new CImpIDataObject(hWndDlg);

    if (pDataObject == NULL)
    {
        GlobalFree(hText);
        return -1;
    }

    pDataObject->SetText(lpszSelectedText);

    // Do drag and drop with copy
    DoDragDrop(pDataObject, pDropSource, DROPEFFECT_COPY, &dwEffect);

    // Free instance of DataObject
    pDataObject->Release();

    GlobalFree(hText);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\subset.cxx ===
/****************************************************************************

    Subset.c

    PURPOSE: Subset related utilities for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#include "ucefile.h"

extern DWORD gFontType;

//
// Char buffer
//
WCHAR wcUnicodeBuffer[M64K];

/****************************************************************************

    Fill Subsets from UCE files

****************************************************************************/
BOOL
Subset_FillComboBox(
   HWND hWnd,
   UINT uID        )
{
  INT              i=0;
  INT              nIndex;
  PUCE_MEMORY_FILE pUceMemFile;
  INT              cFiles;
  PWSTR            pwszSubsetName;
  WCHAR            wszID[LF_SUBSETSIZE];              // I know it is "ALL"
  HWND             hCombo = (HWND) GetDlgItem(hWnd,uID);

  if(NULL == hCombo)
  {
    return FALSE;
  }

  SendMessage( hCombo,
               CB_RESETCONTENT,
               0,
               0
             );

  // Let's add the All subset (hardcoded)
  if( LoadString( hInst , IDS_ALL , wszID , LF_SUBSETSIZE ) &&
  	 wszID[0] )
  {
    nIndex = (INT)SendMessage( hCombo,
                               CB_ADDSTRING,
                               (WPARAM) 0,
                               (LPARAM)(PCWSTR) &wszID[0]
                             );

    if (nIndex != CB_ERR)
    {
      SendMessage( hCombo,
                   CB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) 0
                 );
    }

    // set the current selection here
    SendMessage( hCombo,
                 CB_SETCURSEL,
                 (WPARAM) nIndex,
                 (LPARAM) 0
               );

  }


  cFiles = UCE_GetFiles( &pUceMemFile );

  while( i<cFiles )
  {
    WORD cp;
    BOOL IsCpOnList;

    // make sure required codepage is on our list

    cp = UCE_GetCodepage( &pUceMemFile[i] );
    if(cp == UNICODE_CODEPAGE)
    {
        IsCpOnList = TRUE;
    }
    else
    {
        IsCpOnList = IsCodePageOnList(cp);
    }

    if( IsCpOnList )
    {
      WCHAR wcBuf[256];

      UCE_GetTableName( &pUceMemFile[i] , &pwszSubsetName );
      if(*pwszSubsetName == L'0')
      {
          LoadString(hInst, _wtol(pwszSubsetName), wcBuf, 255);
          pwszSubsetName = wcBuf;
      }
      nIndex = (INT)SendMessage( hCombo,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) pwszSubsetName
                                );

      if (nIndex != CB_ERR)
      {
        SendMessage( hCombo,
                     CB_SETITEMDATA,
                     (WPARAM) nIndex,
                     (LPARAM)(PUCE_MEMORY_FILE) &pUceMemFile[i]
                   );
      }
    }

    i++;
  }

  return TRUE;

}

/****************************************************************************

    Read the current UCE pointer

****************************************************************************/
BOOL
GetCurrentUCEFile(
    PUCE_MEMORY_FILE *ppUceMemFile,
    HWND   hWnd,
    UINT   uID   )
{
  INT  nIndex;
  BOOL bRet = FALSE;

  nIndex = (INT)SendDlgItemMessage( hWnd,
                                    uID,
                                    CB_GETCURSEL,
                                    (WPARAM) 0,
                                    (LPARAM) 0L
                                  );

  if( nIndex != CB_ERR )
  {
    *ppUceMemFile = (PUCE_MEMORY_FILE) SendDlgItemMessage( hWnd,
                                                           uID,
                                                           CB_GETITEMDATA,
                                                           (WPARAM) nIndex,
                                                           (LPARAM) 0L
                                                         );
    bRet = TRUE;
  }

  return bRet;
}

/****************************************************************************

    Get a Unicode buffer for the current view/subset when subset is all

    Called to retreive what to display

****************************************************************************/
BOOL
Subset_GetUnicodeCharsToDisplay(
HWND   hWnd,
UINT   uID,
LONG   lCodePage,
PWSTR *ppCodeList,
UINT  *puNum,
BOOL  *pbLineBreak)
{
  PUCE_MEMORY_FILE pUceMemFile= NULL;
  HWND             hCombo     = (HWND) GetDlgItem(hWnd,uID);

  if(NULL == hCombo)
  {
    return FALSE;
  }

  // Get the Unicode of the current code page
  if( !GetCurrentUCEFile( &pUceMemFile , hWnd ,uID ) || (NULL == pUceMemFile) )
  {
    return GetUnicodeBufferOfCodePage( lCodePage , ppCodeList , puNum );
  }
  else
  {
    if( pUceMemFile )
    {
      // Let's retreive the Unicode subset from the list
      // and throw it back to the display

      if( !Subset_GetUnicode(    // if fail, then select as if All is selected
                    hWnd,
                    pUceMemFile,
                    ppCodeList,
                    puNum,
                    pbLineBreak ))
        return GetUnicodeBufferOfCodePage( lCodePage , ppCodeList , puNum );
    }
  }

  return TRUE;
}

/****************************************************************************

  Convert a codepage to unicode buffer

****************************************************************************/
BOOL
GetUnicodeBufferOfCodePage(
        LONG   lCodePage,
        PWSTR *ppwBuf,
        UINT  *puNum )
{
  *puNum  = WCharCP( lCodePage, wcUnicodeBuffer);
  *ppwBuf = wcUnicodeBuffer ;

  return (*puNum);
}

/****************************************************************************

   Decide whether to retreive unicode from 1-d or 2-d current selection

****************************************************************************/
BOOL
Subset_GetUnicode(
        HWND hWnd,
        PUCE_MEMORY_FILE pUceMemFile,
        PWSTR *ppwBuf,
        UINT *puNum,
        BOOL *pbLineBreak )
{
  BOOL bRet = FALSE;

  switch( ((PUCE_HEADER)(pUceMemFile->pvData))->Row )
  {
  case 0:           // 1-d array
    {
      // should delete grid window if any

      bRet = GetUnicodeCharsFromList(
                                     hWnd,
                                     pUceMemFile,
                                     &wcUnicodeBuffer[0],
                                     puNum,
                                     pbLineBreak
                                    );
    }
    break;

  default:          // 2-d array
    {
      // should delete list window, if any
      bRet = GetUnicodeCharsFromGridWindow(
                                           hWnd,
                                           &wcUnicodeBuffer[0],
                                           puNum,
                                           pbLineBreak
                                          );                 // till now
    }
    break;

  }

  // Update user buffer
  *ppwBuf = &wcUnicodeBuffer[0];

  return bRet;
}


/****************************************************************************

    When user selchange a subset, let's call our guys (if really changed)
    to bring up a new list (if required)
    must call SubSetChanged(...) after this

****************************************************************************/
BOOL
Subset_OnSelChange(
    HWND hWnd,
    UINT uID )
{
  static PUCE_MEMORY_FILE pLastUceMemFile = NULL;
  PUCE_MEMORY_FILE        pCurUceMemFile;
  PSTR                    pFile;
  PUCE_HEADER             pHeader;

  DWORD                   dw;
  WCHAR                  *pWC;

  // Let's know if it changed really
  if( !GetCurrentUCEFile( &pCurUceMemFile , hWnd , uID ) ||
      (NULL == pCurUceMemFile)
    )
  {
    pLastUceMemFile = pCurUceMemFile;
    DestroyAllListWindows();
    return FALSE;
  }

  // Need to check also if the window list is available
  if( (pLastUceMemFile == pCurUceMemFile) && IsListWindow( pCurUceMemFile ) )
    return FALSE;

  // If so, let's update our list view or grid
  pFile = (PSTR) pCurUceMemFile->pvData;
  pHeader  = (PUCE_HEADER) pCurUceMemFile->pvData;
  pLastUceMemFile = pCurUceMemFile;

  dw  = *(((DWORD*)pCurUceMemFile->pvData)+1);
  pWC = (WCHAR*)(((BYTE*)pCurUceMemFile->pvData)+dw);
  if(lstrcmp(pWC, L"010200") == 0)                             // Ideograf.UCE
  {
     UINT CharSet;

     if(!(gFontType & DBCS_FONTTYPE) &&
        (CharSet = Font_DBCS_CharSet()) != 0)
     {
         Font_SelectByCharSet(hWnd, ID_FONT, CharSet);
     }
  }
  else
  {
      CHARSETINFO csi;
      CPINFO      cpinfo;

      // Indicate change of view to a new font
      GetCPInfo(pHeader->Codepage, &cpinfo);
      if(cpinfo.MaxCharSize > 1 &&
         TranslateCharsetInfo((DWORD*)pHeader->Codepage, &csi, TCI_SRCCODEPAGE))
      {
          Font_SelectByCharSet(hWnd,ID_FONT, csi.ciCharset);
      }
  }

  // Let's fetch the most appropriate code page
  if( CodePage_SetCurrent( pHeader->Codepage , hWnd , ID_VIEW ) )
  {
      PostMessage( hWnd ,
                   WM_COMMAND,
                   MAKELONG(ID_VIEW,CBN_SELCHANGE),
                   0L );
  }

  switch( pHeader->Row )
  {
  case 0:
    // Destroy grid if needed
    DestroyGridWindow();
    CreateListWindow( hWnd , (PWSTR)(pFile+pHeader->OffsetTableName) ) ;
    FillGroupsInListBox( hWnd , pCurUceMemFile );
    break;

  default:
    DestroyListWindow();
    DestroyGridWindow();
    CreateGridWindow( hWnd , ID_FONT , pCurUceMemFile );
    // create grid if needed
    break;
  }

  EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), FALSE);

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\ucefile.h ===
/********************************************************************
 *
 *  Header Name : ucefile.h
 *
 *  UCE file data structures
 *
 *
 *  History :
 *         Sep 02, 1997  [samera]   wrote it
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 *********************************************************************/

#ifndef __UCEFILE_H__
#define __UCEFILE_H__

#define MAX_UCE_FILES    32

typedef struct
{
  char Signature[4] ;        // should be "UCEX"
  DWORD OffsetTableName;     // Subset name
  WORD Codepage;
  WORD NumGroup;
  WORD Row;
  WORD Column;

} UCE_HEADER, *PUCE_HEADER;


//  UCEX Group Structure
typedef struct
{
  DWORD OffsetGroupName;
  DWORD OffsetGroupChar;
  DWORD NumChar;
  DWORD Reserved;

} UCE_GROUP, *PUCE_GROUP;


typedef struct Structtag_UCE_FILES
{
  HANDLE hFile;     // UCE physical file handle
  HANDLE hMapFile;  // UCE memory map file handle
  PVOID pvData;     // Start of committed address space for the file

} UCE_MEMORY_FILE, *PUCE_MEMORY_FILE;


// export
UINT UCE_EnumFiles( void );
void UCE_CloseFiles( void );
INT UCE_GetFiles( UCE_MEMORY_FILE **ppUceMemFile );
BOOL UCE_GetTableName( PUCE_MEMORY_FILE pUceMemFile , PWSTR *ppszTableName );
WORD UCE_GetCodepage( PUCE_MEMORY_FILE pUceMemFile );

#endif  // __UCEFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\ucefile.cxx ===
/********************************************************************
 *
 *  Module Name : ucefile.c
 *
 *  UCE-File parser
 *
 *  History :
 *       Sep 02, 1997  [samera]    wrote it.
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 **********************************************************************/

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "uce.h"
#include "ucefile.h"


// Current opened UCE files
UCE_MEMORY_FILE  gUceFiles[MAX_UCE_FILES];
PUCE_MEMORY_FILE gpUceFile=&gUceFiles[0];
INT              gnUceFiles=0;
INT              gnMaxUceFiles=MAX_UCE_FILES;


/******************************Public*Routine******************************\
* UCE_LoadFile
*
* Load a UCE file (by mapping it in the process address space & commit it)
* it returns both ptr+handle of file
* 
* Return Value:
* TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL UCE_LoadFile( PWSTR pwszFileName , PUCE_MEMORY_FILE pMemFile )
{
  HANDLE hFile;
  HANDLE hMapFile;
  PVOID  pvFile;
  DWORD  dwFileSize;
  WORD   CodePage;
  DWORD  dwOffset;
  WCHAR *pWC;

  // Open and map file
  hFile = CreateFile( pwszFileName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_READONLY,
                      NULL
                    );

  if( INVALID_HANDLE_VALUE == hFile )
    goto File_Err;

  dwFileSize = GetFileSize( hFile , NULL );

  hMapFile = CreateFileMapping( hFile ,
                                NULL,
                                PAGE_READONLY,
                                0,
                                dwFileSize,
                                NULL
                              );

  if( (NULL == hMapFile) || (dwFileSize<sizeof(UCE_HEADER)) )
    goto File_Err1;

  pvFile = MapViewOfFile( hMapFile ,
                          FILE_MAP_READ,
                          0,
                          0,
                          0
                        ) ;

  if( NULL == pvFile )
    goto File_Err2;

  // verify header
  if( *((DWORD *)pvFile) != 0x58454355L ) // XECU
    goto File_Err3;

//
// The Ideograph by Radical UCE file should be included
// only if one of the 4 DBCS font and NLS is installed.
//
  dwOffset = *(((DWORD*)pvFile)+1);
  pWC = (WCHAR*)(((BYTE*)pvFile)+dwOffset);
  if(lstrcmp(pWC, L"010200") == 0)             // Ideograf.UCE
  {
     if(Font_DBCS_CharSet() == 0)
         goto File_Err3;
     if((IsValidLanguageGroup(LGRPID_JAPANESE, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_SIMPLIFIED_CHINESE, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_KOREAN, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_TRADITIONAL_CHINESE, LGRPID_INSTALLED) == FALSE))
        goto File_Err3;
  }
  
//
// A UCE file with a Non-Unicode DBCS codepage
// is included only if font & NLS are installed.
//
  CodePage = *(((WORD*)pvFile)+4);
  if(CodePage != UNICODE_CODEPAGE)
  {
      CPINFO      cpi;
      CHARSETINFO csi;

      if(!IsValidCodePage(CodePage) ||         // invalid codepage
         !GetCPInfo(CodePage, &cpi) )
      {
         goto File_Err3;
      }
                                
      if(cpi.MaxCharSize >1  &&                // DBCS  
         TranslateCharsetInfo((DWORD*)CodePage, &csi, TCI_SRCCODEPAGE))
      {
          if(!Font_Avail(csi.ciCharset))       // no font with matched charset
          {
              goto File_Err3;
          }
      }
      else
      {
          //
          // SBCS or no GDI charset, include it anyway.
          //
      }

      if(CodePage == 932)
      {
         if(IsValidLanguageGroup(LGRPID_JAPANESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 936)
      {
         if(IsValidLanguageGroup(LGRPID_SIMPLIFIED_CHINESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 949)
      {
         if(IsValidLanguageGroup(LGRPID_KOREAN, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 950)
      {
         if(IsValidLanguageGroup(LGRPID_TRADITIONAL_CHINESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
  }

  // save handle 
  pMemFile->hFile    = hFile;
  pMemFile->hMapFile = hMapFile;
  pMemFile->pvData   = pvFile;

  return TRUE;


  // Error Handler
File_Err3:
  UnmapViewOfFile(pvFile);
File_Err2:
  CloseHandle(hMapFile);
File_Err1:
  CloseHandle(hFile);
File_Err:
  
  return FALSE;
}


/******************************Public*Routine******************************\
* Uce_AddFile
*
* Add a UCE_MEMORY_File to our global list
* 
* Return Value:
* TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL Uce_AddFile( PUCE_MEMORY_FILE pUceMemFile )
{
  PVOID pv;
  BOOL  bRet=TRUE;

  // Check if we still have enough space on our global list
  if( gnMaxUceFiles == gnUceFiles )
  {
    // Need more memory space
    pv = LocalAlloc( LMEM_FIXED , (gnMaxUceFiles+MAX_UCE_FILES)*sizeof(UCE_MEMORY_FILE));
    if( pv )
    {
      memcpy( pv , gpUceFile , sizeof(UCE_MEMORY_FILE)*gnMaxUceFiles ) ;
      if( gpUceFile != &gUceFiles[0] )
      {
        LocalFree( gpUceFile ) ;
      }
      gpUceFile = (PUCE_MEMORY_FILE)pv ;
      gnMaxUceFiles += MAX_UCE_FILES;
    }
    else
    {
     bRet = FALSE;
    }
  }

  // Let's add the file now
  if( bRet )
  {
      int    i, j;
      WCHAR  wcBuf[256];
      WCHAR  wcBufNew[256];
      PWSTR  pwszSubsetName;

      UCE_GetTableName( pUceMemFile , &pwszSubsetName );
      if(*pwszSubsetName == L'0')
      {
          LoadString(hInst, _wtol(pwszSubsetName), wcBufNew, 255);
      }
      else
      {
          lstrcpy(wcBufNew, pwszSubsetName);
      }

      for(i = 0; i < gnUceFiles; i++)
      {
          UCE_GetTableName( &gpUceFile[i] , &pwszSubsetName );
          if(*pwszSubsetName == L'0')
          {
              LoadString(hInst, _wtol(pwszSubsetName), wcBuf, 255);
          }
          else
          {
              lstrcpy(wcBuf, pwszSubsetName);
          }

          if(CompareString(LOCALE_USER_DEFAULT, 0, wcBufNew, -1,  wcBuf, -1) == 1) break;
      }

      for(j = gnUceFiles; j > i; j--)
      {
          memcpy( &gpUceFile[j] , &gpUceFile[j-1] , sizeof(UCE_MEMORY_FILE) );
      }

      memcpy( &gpUceFile[i] , pUceMemFile , sizeof(UCE_MEMORY_FILE) );
      gnUceFiles++ ;
  }

  return bRet ;
}


/******************************Public*Routine******************************\
* UCE_EnumFiles
*
* Begin enumerate UCE files. Return number of correct find
* 
* Return Value:
*   Number of UCE entries found including the hardcoded 'All'
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
UINT UCE_EnumFiles( void )
{
    WIN32_FIND_DATA W32FindData;
    HANDLE          hFile;
    WCHAR           wszSysDir[MAX_PATH];
    WCHAR           wszFilePath[MAX_PATH];
    UCE_MEMORY_FILE uceMemFile;
    INT             nLen;

    // Get UCE directory
    GetSystemDirectory( wszSysDir, MAX_PATH );
    nLen = lstrlen( wszSysDir ) ;
    if( nLen )
    {
      if( wszSysDir[nLen-1] != L'\\' )
      {
        wszSysDir[nLen] = L'\\';
        wszSysDir[nLen+1] = 0;
        nLen++;
      }
    }

    lstrcpy( wszFilePath , wszSysDir ) ;
    lstrcat(wszFilePath, L"*.uce");

    hFile = FindFirstFile( wszFilePath , &W32FindData );

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
      do
      {
        if( !(W32FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) 
        {
            lstrcpy( wszFilePath , wszSysDir ) ;
            lstrcat( wszFilePath , W32FindData.cFileName ) ;
          if( !UCE_LoadFile( wszFilePath , &uceMemFile ) ) 
          {
            //
            // Warnning, same extention, but isn't a valid UCE
            //

          }
          else
          {
            // Add file to UCE list
            Uce_AddFile( &uceMemFile );
#if DBG
            OutputDebugString(L"\nUCE File Loaded:");
            OutputDebugString(wszFilePath);
#endif 
          }
        }
        

      } while( FindNextFile( hFile , &W32FindData ));

      FindClose( hFile );
    }

    return (gnUceFiles+1);  // +1 is for default hard-coded one
}

/**************************************************************************\

  Close All UCE files, and free memory if needed

\**************************************************************************/
void UCE_CloseFiles( void )
{
  while( gnUceFiles>0 )
  {
    gnUceFiles--;
    UnmapViewOfFile( gpUceFile[gnUceFiles].pvData );
    CloseHandle( gpUceFile[gnUceFiles].hMapFile );
    CloseHandle( gpUceFile[gnUceFiles].hFile ) ;
  }

  if( gpUceFile != &gUceFiles[0] )
  {
    LocalFree( gpUceFile );
  }

  return ;
}


/******************************Public*Routine******************************\
* UCE_GetFiles
*
* Read in current list of UCE_list
* 
* Return Value:
*   Current UCE_MEMORY_FILEs loaded
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
INT UCE_GetFiles( UCE_MEMORY_FILE **ppUceMemFile )
{
  *ppUceMemFile = gpUceFile ;

  return gnUceFiles;
}


/******************************Public*Routine******************************\
* UCE_GetTableName
*
* Position pointer to table name of current UCE_MEMORY_FILE
* 
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL UCE_GetTableName( PUCE_MEMORY_FILE pUceMemFile , PWSTR *ppszTableName )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);
  PSTR pFile= (PSTR)(pUceMemFile->pvData);

  *ppszTableName = (PWSTR)(pFile+pHeader->OffsetTableName);

  return TRUE;
}

/******************************Public*Routine******************************\
* UCE_GetCodepage
* 
* Return Value: table CodePage of current UCE_MEMORY_FILE
*
* History:
*   Nov-20-1997  kchang  created
\**************************************************************************/
WORD UCE_GetCodepage( PUCE_MEMORY_FILE pUceMemFile )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);
  PSTR pFile= (PSTR)(pUceMemFile->pvData);

  return (WORD)(pFile+pHeader->Codepage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\utils.cxx ===
/********************************************************************
 *
 *  Module Name : utils.c
 *
 *  Various utilities for UCE
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 ********************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

/********************************************************************

    Function : Set current selection in combobox.

********************************************************************/
BOOL LoadNeedMessage()
{
  TCHAR szVal[128] = TEXT("");
  DWORD dwRetVal;

  dwRetVal=GetProfileString(TEXT("MSUCE"),TEXT("DISPLAYFONTMSG"),NULL,(LPTSTR)szVal, sizeof(szVal)/sizeof(TCHAR));
  if (!dwRetVal)
    return true;
  else
    return (BOOL)(atoi((const char*)szVal));
}

void SaveNeedMessage(BOOL nMsg)
{
  if (nMsg)
    WriteProfileString(TEXT("MSUCE"), TEXT("DISPLAYFONTMSG"), TEXT("1"));
  else
    WriteProfileString(TEXT("MSUCE"), TEXT("DISPLAYFONTMSG"), TEXT("0"));
}


INT
LoadCurrentSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey,
    LPTSTR lpszDefault
    )
{
    TCHAR szValueName[128] = TEXT("");
    INT nIndex;
    DWORD dwRetVal;

    nIndex = CB_ERR;

    dwRetVal = GetProfileString(
                   TEXT("MSUCE"),
                   lpszKey,
                   NULL,
                   (LPTSTR)szValueName,
                   BTOC(sizeof(szValueName))
               );

    if (dwRetVal != 0)
    {
        nIndex = (INT) SendDlgItemMessage(
                           hWnd,
                           uID,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM)(LPTSTR)szValueName
                       );
    }

    /*
     * If there was no profile or the selection failed then try selecting
     * the Basic Latin block, if that fails then select the first one.
     */

    if (nIndex == CB_ERR)
    {
        nIndex = (INT) SendDlgItemMessage(
                           hWnd,
                           uID,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM) lpszDefault
                       );
    }

    nIndex = (INT)SendDlgItemMessage(
                 hWnd,
                 uID,
                 CB_SETCURSEL,
                 (WPARAM) (nIndex == CB_ERR) ? 0 : nIndex,
                 (LPARAM) 0L
             );

    return nIndex;
}

/********************************************************************

    Function : Used to save the current selection values in win.ini,
               so that it can be selected the next time UCE comes up.

********************************************************************/
BOOL
SaveCurrentSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValue[128] = TEXT("");
    INT nIndex;
    INT nRetVal;

    nIndex = (INT) SendDlgItemMessage(
                       hWnd,
                       uID,
                       CB_GETCURSEL,
                       (WPARAM) 0,
                       (LPARAM) 0L
                   );

    if (nIndex == CB_ERR)
    {
        return FALSE;
    }

    nRetVal = (INT)SendDlgItemMessage(
                  hWnd,
                  uID,
                  CB_GETLBTEXT,
                  (WPARAM) nIndex,
                  (LPARAM) szValue
              );

    if (nRetVal == CB_ERR)
    {
        return FALSE;
    }

    return WriteProfileString(TEXT("MSUCE"), lpszKey, szValue);
}

/********************************************************************

    Function : GetSystemPathName

********************************************************************/
VOID GetSystemPathName(
    PWSTR pwszPath,
    PWSTR pwszFileName,
    UINT  maxChar
    )
{
    UINT fnLen = wcslen(pwszFileName);
    UINT i = GetSystemDirectoryW(pwszPath, maxChar);

    // avoid error condition
    if (fnLen + 1 >= maxChar) {
        *pwszPath = L'\0';
        return;
    }
    if (i > 0 || i < maxChar - fnLen - 1) {
        pwszPath += i;
        if (pwszPath[-1] != L'\\')
            *pwszPath++ = L'\\';
    }
    wcscpy(pwszPath, pwszFileName);
}

/********************************************************************

    Function : Set current selection in combobox.

********************************************************************/
INT
LoadAdvancedSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValueName[128] = TEXT("");
    DWORD iCheckState;

    iCheckState = GetProfileInt(
                   TEXT("MSUCE"),
                   lpszKey,
                   0);

    fDisplayAdvControls = (iCheckState == 0)? FALSE: TRUE;

    return 0;
}

/********************************************************************

    Function : Used to save the current selection values in win.ini,
               so that it can be selected the next time UCE comes up.

********************************************************************/
BOOL
SaveAdvancedSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValue[128] = TEXT("");
    int   iCheckState;

    iCheckState = (fDisplayAdvControls == TRUE)? 1: 0;

    wsprintf(szValue, L"%d", iCheckState);

    return WriteProfileString(TEXT("MSUCE"), lpszKey, szValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ucharma2\dummy.c ===
/* Dummy file to force the linker to output $(TARGETNAME).exe
 * when we're just linking existing objects.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\uce.cxx ===
/*******************************************************************************

Module Name:

    UCE.c

Abstract:

    This module contains the main routines for the Universal Character Explorer,
    an new interface for selecting special characters.


    Copyright (c) 1997-1999 Microsoft Corporation.
********************************************************************************/

//
//  Include Files.
//

#define WIN31
#include "windows.h"
#include <stdio.h>
#include "ole2.h"
#include <richedit.h>
#include <port1632.h>
#include "stdlib.h"
#include "tchar.h"
#ifdef UNICODE
  #include "wchar.h"
#else
  #include "stdio.h"
#endif
#include "commctrl.h"
#include "htmlhelp.h"

#include <uceshare.h>
#include "winnls.h"
#include "olecomon.h"
#include "cdropsrc.h"
#include "cdataobj.h"
#include "UCE.h"
#include "ucefile.h"
//#include "oleedit.h"
#include "helpids.h"
#include "resource.h"

//
//  Macros.
//

#define FMagData(psycm)      ((psycm)->xpMagCurr != 0)
#define abs(x)               (((x) >= 0) ? (x) : (-(x)))

//
//  Constant Declarations.
//

#define STATUSPOINTSIZE      9              // point size of status bar font
#define FE_STATUSPOINTSIZE   10             // FE point size of status bar font
#define DX_BITMAP            20             // width of TT bitmap
#define DY_BITMAP            12             // height of TT bitmap

#define SEARCH_WORD_MAX      8
#define SEARCH_WORD_LEN      32

#define BACKGROUND           0x000000FF     // bright blue
#define BACKGROUNDSEL        0x00FF00FF     // bright purple

TCHAR ChmHelpPath[] = TEXT("charmap.chm");

//
//  Timer IDs
//
#define ID_SCROLLTIMER      8
#define ID_DRAGTIMER        1

// defines for hex edit control
#define ZERO        0x0030
#define MAX_CHARS   4

//
//  Debug Print Code.
//

#if 0
  TCHAR szDOUT[3] = TEXT("A\n");
  TCHAR szDbgBuf[256];
  #define DOUTL(p)     OutputDebugString(TEXT(p))
  #define DOUTCHN(ch)  if(0){}else {szDOUT[0] = ch; OutputDebugString(szDOUT);}
  #define DPRINT(p)    if(0){}else {wsprintf p; OutputDebugString(szDbgBuf);}
#else
  #define DOUTL(p)
  #define DOUTCHN(ch)
  #define DPRINT(p)
#endif

//
//  Global Variables.
//

HINSTANCE hInst;
HINSTANCE ghRichEditLib=NULL; // Module handle for rich edit library

INT    cchSymRow    = 20;     // number of characters across the character grid
INT    cchSymCol    = 10;     // number of rows in the character grid
UTCHAR chSymFirst   = 0;
UTCHAR chSymLast    = 200;
UTCHAR chRangeFirst = 0;
UTCHAR chRangeLast  = 200;
INT    chPos;
INT    chCurrPos;
BOOL   fSearched    = FALSE;
BOOL   fNeedReset   = FALSE;

SYCM   sycm;                       // tons of data need to do char grid painting
WORD   wCFRichText = 0;            // private clipboard format, rich text format
HFONT  hFontClipboard = NULL;      // tells us which font is in the clipboard
HANDLE hstrClipboard = NULL;       // contains the string which is in the clipboard
BOOL   fDelClipboardFont = FALSE;  // the clipboard font needs to be deleted

HBITMAP hbmFont = NULL;            // TT bitmap drawn before font facenames in combo

LONG   lEditSel = 0;               // contains the selection range of the EC
HBRUSH hStaticBrush;               // used for static controls during WM_CTLCOLOR
BOOL   fDisplayAdvControls = TRUE; // flag which decides whether advanced
                                   // are to be displayed
DWORD  gwExpandedHeight,           // dialog height in expanded state
       gwNormalHeight;             // dialog height when advanced controls are
                                   // hidden
BOOL   fScrolled;
WPARAM prevKeys;                   // Used in drag scrolling
LPARAM ptPrevMouse;                // Used in drag scrolling

BOOL   fSURChanged=FALSE;          // used to automatically change unicode
                                   // range when MAX_CHARS chars are typed
BOOL   fSURNeedsReset=FALSE;       // Unicode start pt has changed and reset
                                   // is needed

DWORD  gFontType;                  // for the current selected font
UINT   gKBD_CP = 0;                // codepage associated with the active keyboard
BOOL   gDisplayFontChgMsg = true;

//
//  Variables required for Drag and Drop
//
BOOL   fPendingDrag = FALSE;        // is a drag and drop operation pending
int    nDragDelay = 0;              // delay after LBUTTONDOWN after which
                                    // drag and drop starts
int    nDragMinDist = 0;            // minimum distance by which cursor has to
                                    // move before drag and drop is considered
int    nScrollInterval = 0;         // Scroll interval
int    iFromPrev=0x21, iToPrev=0xFFFD;

//
//  Useful window handles.
//
HWND hwndDialog;
HWND hwndCharGrid;
HWND hwndTT;

//
//  Data used to draw the status bar.
//
RECT rcStatusLine;                // bounding rect for status bar
INT  dyStatus;                    // height of status bar

INT   dxHelpField;                // width of help window
TCHAR szKeystrokeText[MAX_PATH];  // buffer for keystroke text
TCHAR szAlt[MAX_PATH];            // buffer for Alt+
HFONT hfontStatus;                // font used for text of status bar

TCHAR szTipText[MAX_PATH];        // Tip text


static const DWORD aHelpIDs[] = {
    ID_FONT,            IDH_UCE_FONT,
    ID_FONTLB,          IDH_UCE_FONT,
    ID_HELP,            IDH_UCE_HELPBUTTON,
    ID_CHARGRID,        IDH_UCE_GRIDCHAR,
    ID_TOPLEFT,         IDH_UCE_COPYCHAR,
    ID_STRING,          IDH_UCE_COPYCHAR,
    ID_SELECT,          IDH_UCE_SELECT,
    ID_COPY,            IDH_UCE_COPY,
    ID_ADVANCED,        IDH_UCE_ADVANCED,
    ID_VIEWLB,          IDH_UCE_CHARSET,
    ID_VIEW,            IDH_UCE_CHARSET,
    ID_URANGE,          IDH_UCE_GOTOUNICODE,
    ID_FROM,            IDH_UCE_GOTOUNICODE,
    ID_SUBSETLB,        IDH_UCE_SEARCHBYGROUP,
    ID_UNICODESUBSET,   IDH_UCE_SEARCHBYGROUP,
    ID_SEARCHNAME,      IDH_UCE_SEARCHBYNAME,
    ID_SEARCHINPUT,     IDH_UCE_SEARCHBYNAME,
    ID_SEARCH,          IDH_UCE_SEARCHRESET,
0,  0
};



static ValidateData validData[] = {
    ID_FROM, 0x0021, 0xFFFD, 0x0021, 4,
    ID_TO,   0x0021, 0xFFFD, 0xFFFD, 4
};



//
// as a display buffer
//
LPWSTR pCode=NULL;

////////////////////////////////////////////////////////////////////////////
//
//  WinMain
//
//  Calls initialization function, processes message loop, cleanup.
//
////////////////////////////////////////////////////////////////////////////

INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
    {
        return (FALSE);
    }

    //
    //  Initialize the OLE library
    //
    if (OleInitialize(NULL) != NOERROR)
        return FALSE;

    //
    //  Load the rich edit control library
    //

    if ((ghRichEditLib = LoadLibrary(L"RICHED20.DLL")) == NULL)
        return FALSE;   // Rich edit control initialisation failed


    InitCommonControls();


    //
    //  Perform initialization for this instance.
    //
    if (!InitInstance(hInstance, nCmdShow))
    {
        return (FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        //  Main message loop.
        //
        if (!IsDialogMessage(hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    //
    //  Free up some stuff.
    //
    if (hfontStatus)
    {
        DeleteObject(hfontStatus);
    }

    //
    //  Free the rich edit control library
    //
    FreeLibrary(ghRichEditLib);

    //
    //  Close the OLE library and free any resources that it maintains
    //
    OleUninitialize();

    return (INT)(msg.wParam);
}

////////////////////////////////////////////////////////////////////////////
//
//  InitApplication
//
//  Initializes window data and registers window class.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitApplication(
    HINSTANCE hInstance)
{
    WNDCLASS wc;

    //
    //  Register a window class that we will use to draw the character
    //  grid into.
    //
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_UCE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    return RegisterClass(&wc);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitInstance
//
//  Does some initialization and creates main window which is a dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitInstance(
    HINSTANCE   hInstance,
    INT         nCmdShow)
{
    CHARSETINFO csi;
    DWORD dw = GetACP();
/*
    LANGID PrimaryLangId = (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())));
    BOOL bFE = ((PrimaryLangId == LANG_JAPANESE) ||
                (PrimaryLangId == LANG_KOREAN)   ||
                (PrimaryLangId == LANG_CHINESE));
*/
    //
    //  Save the instance handle in a global variable.
    //
    hInst = hInstance;

    //
    //  This font will be used to paint the status line.
    //
    if (!TranslateCharsetInfo((DWORD*)IntToPtr(dw), &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }
/*
    hfontStatus = CreateFont( -PointsToHeight(bFE
                                                ? FE_STATUSPOINTSIZE
                                                : STATUSPOINTSIZE),
*/
    hfontStatus = CreateFont( -PointsToHeight(STATUSPOINTSIZE),
                              0, 0, 0, 400, 0, 0, 0,
                              csi.ciCharset,
                              OUT_DEFAULT_PRECIS,
                              CLIP_DEFAULT_PRECIS,
                              DEFAULT_QUALITY,
                              VARIABLE_PITCH,
                              TEXT("MS Shell Dlg") );

    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);

    //
    //  Create a main window for this application instance.
    //
    if (!(hwndDialog = CreateDialog( hInstance,
                                     TEXT("UCE"),
                                     NULL,
                                     UCEDlgProc )))
    {
        return (FALSE);
    }

    // Drag action starts after nDragDelay time
    nDragDelay = GetProfileInt(
        TEXT("windows"),
        TEXT("DragDelay"),
        DD_DEFDRAGDELAY
        );

    // If the mouse moves nDragMinDist from the place of LBUTTONDOWN
    // then Drag starts
    nDragMinDist = GetProfileInt(
        TEXT("windows"),
        TEXT("DragMinDist"),
        DD_DEFDRAGMINDIST
        );

    // Scroll Interval
    nScrollInterval = GetProfileInt(
        TEXT("windows"),
        TEXT("DragScrollInterval"),
        DD_DEFSCROLLINTERVAL
        );

    //
    //  Initialize keystroke text, make the window visible,
    //  update its client area, and return "success".
    //
    UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);


    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);

                // Potential for Bug#187822, tab order problem.
                // If the initial focus should be on ID_FONT, add this code,
                // otherwise initial focus will be on ID_CHARGRID
                {
                        HWND hTmp;
                        hTmp = GetDlgItem(hwndDialog, ID_FONT);
                        SetFocus(hTmp);
                }


    return (TRUE);

}

////////////////////////////////////////////////////////////////////////////
//
//  EnumChildProc
//
//  Gets called during init for each child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    LONG st;
    TCHAR szClass[MAX_PATH];

    //
    //  Get control class.
    //
    GetClassName(hwnd, szClass, MAX_PATH);
    if (lstrcmpi(szClass, TEXT("button")) == 0 )
    {
        //
        //  If it is a button, set the ex style to NOTIFYPARENT.
        //
        st = GetWindowLong(hwnd, GWL_EXSTYLE);
        st = st & ~WS_EX_NOPARENTNOTIFY;
        SetWindowLong(hwnd, GWL_EXSTYLE, st);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UCEDlgProc
//
//  Processes messages for the main window.  This window is a dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY UCEDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_KEYDOWN ) :
        {
            if(wParam == VK_F6)
            {
                if(ghwndList)
                    SetFocus(ghwndList);
                else if(ghwndGrid)
                    SetFocus(ghwndGrid);
                return 0L;
            }
            break;
        }

        case ( WM_CTLCOLORSTATIC ) :
        {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return ((INT_PTR)hStaticBrush);
            break;
        }

        case ( WM_INITDIALOG ) :
        {
            int   right_adjust;
            int   bottom_adjust;
            RECT  rectParent, rect;
            POINT pt;
            HWND  hwndCMSB;

            //
            //  Set buttons to send WM_PARENTNOTIFY.
            //
            EnumChildWindows(hWnd, EnumChildProc, (LPARAM)NULL );

            // Create the scroll bar first and then resize it in the Chargrid
            // window create routine
            hwndCMSB = CreateWindowEx(0L,
                                      TEXT("SCROLLBAR"),
                                      NULL,
                                      WS_CHILD | SBS_VERT | WS_VISIBLE,
                                      0,
                                      0,
                                      0,
                                      0,
                                      hWnd,
                                      (HMENU)ID_MAPSCROLL,
                                      hInst,
                                      NULL );

            //
            //  Create the character grid with dimensions which just fit
            //  inside the space allowed in the dialog.  When it processes
            //  the WM_CREATE message it will be sized and centered more
            //  accurately.
            //
            GetClientRect(hWnd, &rectParent);

            right_adjust  = (int)((rectParent.right/360) *9);
            bottom_adjust = (int)((rectParent.bottom/10) *3);

            if (!(hwndCharGrid =
                  CreateWindow( TEXT("CharGridWClass"),
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                                0, 0,
                                rectParent.right  - right_adjust,
                                rectParent.bottom - bottom_adjust,
                                hWnd,
                                (HMENU) ID_CHARGRID,
                                hInst,
                                NULL )))
            {
                DestroyWindow(hWnd);
                break;
            }

            GetWindowRect( hwndCharGrid, &rect );
            pt.x = rect.right;
            pt.y = rect.top;

            ScreenToClient(hWnd, &pt);

//pliu            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            // Compute the heights of the dialog in expanded and shrunk state
            ComputeExpandedAndShrunkHeight(hWnd);

            // Load registry setting to find if start state is expanded or shrunk
            LoadAdvancedSelection(hWnd, ID_ADVANCED, SZ_ADVANCED);

            // Resize the Dialog to correspond to expanded or shrunk state
            ResizeDialog(hWnd);

            // Compute client rect of the resized dialog
            GetClientRect(hWnd, &rectParent);

            //
            //  Initialize the status line data.
            //
            dxHelpField = 23 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            //
            //  Disable Copy & Search buttons.
            //
            EnableWindow(GetDlgItem(hWnd, ID_COPY),   FALSE);
            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

            if (Display_InitList())
            {
                pCode = NULL;
            }

            if (Font_InitList(hWnd))
            {
                Font_FillToComboBox(hWnd,ID_FONT);
                LoadCurrentSelection(hWnd,ID_FONT,SZ_FONT,SZ_FONT_DEFAULT);
            }

            if (CodePage_InitList())
            {
                CodePage_FillToComboBox(hWnd,ID_VIEW);
                LoadCurrentSelection(hWnd,ID_VIEW,SZ_CODEPAGE,SZ_CODEPAGE_DEFAULT);
            }

            CreateResources(hInst, hWnd);  // init gui stuff
            if( UCE_EnumFiles() )
            {
                Subset_FillComboBox( hWnd , ID_UNICODESUBSET );
            }

            // Initialise the ID_ADVANCED check box
            SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
                BM_SETCHECK,
                (WPARAM)((fDisplayAdvControls==TRUE)? BST_CHECKED: BST_UNCHECKED),
                (LPARAM)0L);

#ifndef DISABLE_RICHEDIT
            // Some richedit's initialization

            // Set and event mask for the rich edit control so that we
            // get a notification when text changes
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETEVENTMASK, 0, ENM_SELCHANGE);

            // Set necessary lang options
/* this is supposed to fix 374706, however, looks like you have to turn on IMF_AUTOFONT
   for RichEdit to change cursor correctly, but this flag cause RichEdit to lose font info.
            DWORD   dwOptions = SendMessage(GetDlgItem(hWnd, ID_STRING),
                                EM_GETLANGOPTIONS, 0, 0);
            dwOptions |= IMF_IMECANCELCOMPLETE | IMF_UIFONTS;
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETLANGOPTIONS, 0,
                        dwOptions);
*/
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETLANGOPTIONS, 0,
                        IMF_IMECANCELCOMPLETE | IMF_UIFONTS);

#else
            SendMessage(GetDlgItem(hWnd, IDC_EDIT), EM_SETEVENTMASK, 0,
                ENM_SELCHANGE);
#endif

            // Enable/diable SUR controls depending on the range selected
            EnableSURControls(hWnd);

            // Initialise the text in the two UR controls
            SetHexEditProc(GetDlgItem(hWnd, ID_FROM));
            SendMessage(GetDlgItem(hWnd, ID_FROM), EM_LIMITTEXT,
                (WPARAM)MAX_CHARS, (LPARAM)0L);

            // subclass the search edit box to handle the Enter key
            SetSearchEditProc(GetDlgItem(hWnd, ID_SEARCHINPUT));

            // Initialise codepage associated with the active keyboard
            {
                WCHAR wcBuf[8];

                if(GetLocaleInfo(LOWORD(GetKeyboardLayout(0)),
                                 LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
                {
                    gKBD_CP = (UINT) _wtol(wcBuf);
                }
            }

            //
            //  Fall through to WM_FONTCHANGE...
            //
        }

        case ( WM_FONTCHANGE ) :
        {
            //
            //  Get the fonts from the system and put them in the font
            //  selection combo box.
            //

            if (message == WM_FONTCHANGE)
            {
                SaveCurrentSelection(hWnd,ID_FONT,SZ_FONT);

                if (Font_InitList(hWnd))
                {
                    Font_FillToComboBox(hWnd,ID_FONT);
                }
                LoadCurrentSelection(hWnd,ID_FONT,SZ_FONT,SZ_FONT_DEFAULT);
            }

            SendMessage(hWnd, WM_COMMAND, MAKELONG(ID_FONT,CBN_SELCHANGE), 0L);

            if (message == WM_INITDIALOG)
            {
                SetFocus(hwndCharGrid);

                //
                //  Fall through to WM_SYSCOLORCHANGE...
                //
            }
            else
            {
                break;
            }
        }

        case ( WM_SYSCOLORCHANGE ) :
        {
            if (hbmFont)
            {
                DeleteObject(hbmFont);
            }
            hbmFont = LoadBitmaps(IDBM_TT);
//pliu            DeleteObject(hStaticBrush);
//pliu            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;
        }

        case ( WM_NOTIFY ):
        {
            int        iTextLength;
            LPNMHDR pnmh = (LPNMHDR)lParam;

#ifndef DISABLE_RICHEDIT
            if ((wParam == ID_STRING) && (pnmh->code == EN_SELCHANGE))
            {
                // If there is no text in the rich edit control then
                // disable the Copy button
                iTextLength = GetWindowTextLength(GetDlgItem(hWnd, ID_STRING));
                EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iTextLength);
            }
#else
            if ((wParam == IDC_EDIT) && (pnmh->code == EN_SELCHANGE))
            {
                // If there is no text in the rich edit control then
                // disable the Copy button
                iTextLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_EDIT));
                EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iTextLength);
            }
#endif
            break;
        }

        case ( WM_PARENTNOTIFY ) :
        {
            POINTS points;
            DWORD  dwMsgPos;
            POINT  point;

            DPRINT(( szDbgBuf,
                    TEXT("WM_PARENTNOTIFY: lParam:0x%08lX, wParam:0x%08lX\n"),
                    (DWORD)lParam,
                    (DWORD)wParam ));

            //
            //  We process this message to implement the context sensitive
            //  help.  Downclicks to controls are found here, the help
            //  message is updated in the status bar.
            //
            //  The parameters with this message are unreliable!
            //
            if (LOWORD(wParam) == WM_LBUTTONDOWN)
            {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
            }

            break;
        }

        case ( WM_VSCROLL ) :
        {
            ProcessScrollMsg(hWnd, LOWORD(wParam), HIWORD(wParam));
            return TRUE;
        }

        case ( WM_PAINT ) :
        {
            HBRUSH hBrush;
            RECT rcTemp;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            //
            //  This code implements painting of the status bar.
            //
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)))
            {
                //
                //  Status line top.
                //
                rcTemp.left   = 6 * dyBorder;
                rcTemp.right  = rcStatusLine.right - 8 * dyBorder;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line left side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 6 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)))
            {
                //
                //  Status line bottom.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcStatusLine.right - 8 * dyBorder;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line right side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);
            return (TRUE);
            break;
        }

        case ( WM_MEASUREITEM ) :
        {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = (HFONT)SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight =
                                  max(tm.tmHeight, DY_BITMAP);

            break;
        }

        case ( WM_DRAWITEM ) :
        {
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
            {
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);
            }
            break;
        }

        case ( WM_ASKCBFORMATNAME ) :
        {
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, (int)wParam);
            //should hardcode clipboard format, we'll do it after Win2K
            //lstrcpy((LPTSTR)lParam, RTFFMT);
            return (TRUE);
        }

        case ( WM_PAINTCLIPBOARD ) :
        {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard)
            {
                //
                //  Setup.
                //
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                //
                //  Paint.
                //
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText, lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                //
                //  Cleanup.
                //
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }
            return (TRUE);
        }

        case ( WM_SYSCOMMAND):
        {
            switch (wParam)
            {
                case (SC_CLOSE):
                  DestroyWindow(hWnd);
                  return (TRUE);
            }
            break;
        }

        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                //case ( IDCANCEL ) :
                case ( ID_CLOSE ) :
                {
                    DestroyWindow(hWnd);
                    return (TRUE);
                }

                case ( ID_SELECT ) :
                {
                  WCHAR wc = (WCHAR)pCode[sycm.chCurr];
                  ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
#ifndef DISABLE_RICHEDIT
                SetRichEditFont(hWnd, ID_STRING, sycm.hFont);
                //richedit screws up symbol font display
                //use ansi code so that it can display symbols correctly.
                if (gFontType & SYMBOL_FONTTYPE)
                {
                  if ((wc >= 0xf000) && (wc <= 0xf0ff))
                    wc = (WCHAR) (BYTE)pCode[sycm.chCurr];
                }
                SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR, wc, 0L);
                CopyTextToClipboard(hWnd);
#else
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, (WPARAM)(sycm.hFont), MAKELPARAM(true,0));
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_CHAR, wc, 0L);
#endif
                    break;
                }

                case ( ID_COPY ) :
                {
                    CopyTextToClipboard(hWnd);
                    return (TRUE);
                }

                case ( ID_FONT ) :
                {
                    static int preItem;
#ifdef DISABLE_RICHEDIT
                    if (HIWORD(wParam) == CBN_DROPDOWN)
                    {
                        preItem = SendDlgItemMessage(hWnd, ID_FONT, CB_GETCURSEL, 0, 0);
                    }
#endif
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        int nItem = (int)SendDlgItemMessage(hWnd, ID_FONT, CB_GETCURSEL,       0, 0);
#ifdef DISABLE_RICHEDIT
                        if ((gDisplayFontChgMsg) &&
                            (preItem != nItem) &&
                            GetWindowTextLength(GetDlgItem(hWnd, IDC_EDIT)))
                        {
                          int dlgRet = DialogBox(hInst, MAKEINTRESOURCE(IDD_FONTCHANGEMSG), hwndDialog, MsgProc);
                          if (dlgRet == IDCANCEL)
                          {
                            SendDlgItemMessage(hWnd, ID_FONT, CB_SETCURSEL, (WPARAM)preItem, 0);
                            return TRUE;
                          }
                        }
#endif
                        nItem = (int)SendDlgItemMessage(hWnd, ID_FONT, CB_GETITEMDATA, nItem, 0);
                        gFontType = Font_pList[nItem].FontType;

                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        if((ghwndList == NULL) && (ghwndGrid == NULL))
                        {
                            if(gFontType & SYMBOL_FONTTYPE)
                            {
                                if(CodePage_GetCurCodePageVal() != UNICODE_CODEPAGE)
                                {

                                    SendMessage( GetDlgItem(hWnd, ID_VIEW),
                                                 CB_SETCURSEL,
                                                 (WPARAM) 0,
                                                 (LPARAM) 0);
                                }
                                EnableWindow(GetDlgItem(hWnd, ID_VIEW),          FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_FROM),          FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), FALSE);
                            }
                            else
                            {
                                EnableWindow(GetDlgItem(hWnd, ID_VIEW),          TRUE);
                                EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   TRUE);
                                EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), TRUE);
                                if(UNICODE_CODEPAGE == CodePage_GetCurCodePageVal())
                                {
                                    EnableWindow(GetDlgItem(hWnd, ID_FROM),      TRUE);
                                }
                                else
                                {
                                    EnableWindow(GetDlgItem(hWnd, ID_FROM),      FALSE);
                                }
                            }
                        }
                        else //GroupBy windows present
                        {
                          if(gFontType & SYMBOL_FONTTYPE) //disable GroupBy
                          {
                            SendMessage(GetDlgItem(hWnd, ID_UNICODESUBSET), CB_SETCURSEL,
                                                   (WPARAM)0,(LPARAM) 0);
                            SendMessage(GetDlgItem(hWnd, ID_VIEW), CB_SETCURSEL,
                                                   (WPARAM)0,(LPARAM) 0);

                            // same as ID_VIEW changed
                            //--------------------------------
                            WCHAR buffer[256];

                            ExitMagnify(hwndCharGrid, &sycm);
                            sycm.chCurr = 0;

                            Subset_OnSelChange(hWnd , ID_UNICODESUBSET );
                            // Then say that subset has changed
                            SubSetChanged( hWnd );

                            fSearched  = FALSE;
                            fNeedReset = FALSE;
                            SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                            LoadString(hInst, IDS_SEARCH, buffer, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

                            // Enable or disable SUR controls
                            EnableSURControls(hWnd);
                            //--------------------------------

                            EnableWindow(GetDlgItem(hWnd, ID_VIEW),          FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_FROM),          FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), FALSE);
                          }
                          else
                          {
                            EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), TRUE);
                          }
                        }

                        RecalcUCE( hWnd,
                                   &sycm,
                                   nItem,
                                   TRUE );
#ifndef DISABLE_RICHEDIT
                        SetRichEditFont(hWnd, ID_STRING, sycm.hFont);
#else
                        SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, WPARAM(sycm.hFont), MAKELPARAM(true,0));
#endif

                        if(fNeedReset || fSearched)
                        {
                            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
                        }
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        // UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                }

                case ID_SEARCHINPUT:
                {
                    WCHAR buffer1[256];
                    WCHAR buffer2[256];

                    if( (HWND)lParam != GetFocus() )
                        break;

                    if(fSearched == TRUE) fNeedReset= TRUE;

                    GetWindowText((HWND)lParam, buffer1, 256);
                    if(swscanf(buffer1, L"%s", buffer2) > 0 &&
                       fSearched == FALSE)
                    {
                        LoadString(hInst, IDS_SEARCH, buffer1, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer1);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
                        EnableSURControls(hWnd, TRUE);
                    }
                    else
                    {
                        if(fNeedReset == FALSE)
                        {
                            LoadString(hInst, IDS_SEARCH, buffer1, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer1);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
                            fSearched = FALSE;
                            EnableSURControls(hWnd);
                        }
                        else
                        {
                            LoadString(hInst, IDS_RESET,  buffer2, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer2);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
                            fNeedReset = FALSE;
                            fSearched  = TRUE;
                        }
                    }
                    break;
                }

                case ID_SEARCH:
                {
                    WCHAR buffer[256];
                    WCHAR KeyWord[SEARCH_WORD_MAX][SEARCH_WORD_LEN];
                    WCHAR *ptr1;
                    int   i, j, k, word;
                    char  buffer3[256];
                    WCHAR wbuffer[256];
                    HDC   hdc;

                    if(fSearched == TRUE)
                    {
                        fSearched  = FALSE;
                        fNeedReset = FALSE;
                        SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                        LoadString(hInst, IDS_SEARCH, buffer, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
                        SendMessage(hWnd,
                                    WM_COMMAND,
                                    MAKELONG(ID_VIEW,CBN_SELCHANGE),
                                    0L);
                        EnableSURControls(hWnd);
                        break;
                    }

                    GetDlgItemText(hWnd, ID_SEARCHINPUT, buffer, 256);
                    memset(KeyWord, 0, sizeof(KeyWord));
                    ptr1 = buffer;
                    word = 1;

                    do
                    {
                        if(*ptr1 !=  ' ')
                        {
                            j = 0;

                            if(*ptr1 == '\"')   // this is a quoted string
                            {
                                while(*++ptr1 && *ptr1 != '\"')
                                {
                                    KeyWord[word][j++] = *ptr1;
                                }
                            }
                            else                // this is an unquoted string
                            {
                                do
                                {
                                    KeyWord[word][j++] = *ptr1++;
                                }
                                while(*ptr1 && *ptr1 != ' ');

                            }
                        }
                        _wcsupr(KeyWord[word]);
                        if(++word == SEARCH_WORD_MAX)
                            break;
                    }
                    while(*ptr1++ && *ptr1);

                    j = 0;
                    for(i = 0; i <= chRangeLast && pCode[i]; i++)
                    {
                        GetUName(pCode[i], wbuffer);
                        /*
                        MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                buffer3, -1,
                                wbuffer, 256); */
                        _wcsupr(wbuffer);

                        for(k = 0; k < word; k++)
                        {
                            if(wcsstr(wbuffer, KeyWord[k]) == NULL)
                                break;
                        }

                        if(k < word)
                            continue;

                        pCode[j++] = pCode[i];
                    }

                    pCode[j] = '\0';
                    chRangeLast = j - 1;
                    fSearched  = TRUE;
                    fNeedReset = TRUE;
                    LoadString(hInst, IDS_RESET,  buffer, 255);
                    SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
                    EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);

                    ExitMagnify(hwndCharGrid, &sycm);
                    sycm.chCurr = 0;
                    UpdateSymbolSelection(hWnd, FALSE);

                    hdc = GetDC(hwndDialog);
                    UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);

                    InvalidateRect(hwndCharGrid, NULL, TRUE);
                    ReleaseDC(hwndDialog, hdc);
                    break;
                }

                case ( ID_UNICODESUBSET ) :
                {
                    WCHAR buffer[256];

                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        Subset_OnSelChange(hWnd , ID_UNICODESUBSET );
                        // Then say that subset has changed
                        SubSetChanged( hWnd );

                        fSearched  = FALSE;
                        fNeedReset = FALSE;
                        SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                        LoadString(hInst, IDS_SEARCH, buffer, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

                        // Enable or disable SUR controls
                        EnableSURControls(hWnd);
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                    }

                    return (0L);
                }
#ifndef DISABLE_RICHEDIT
                case ( ID_STRING ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }
                    break;
                }
#else
                case ( IDC_EDIT ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }
                    break;
                }
#endif
                case ( ID_HELP ) :
                {
                    DoHelp(hWnd, TRUE);
                    break;
                }

                case (ID_VIEW) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        LONG lCodePage;
                        long lNumWChar;

                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        lCodePage = (LONG)CodePage_GetCurSelCodePage(hWnd,ID_VIEW);
                        if(lCodePage == 0)
                            break;
                        lNumWChar = WCharCP(lCodePage, NULL);
                        if(lNumWChar == 0)
                            break;
                        pCode = Display_CreateDispBuffer(NULL,
                                               lNumWChar, NULL, 0,FALSE);
                        if (pCode == NULL)
                            break;
                        WCharCP(lCodePage, pCode);
                        chRangeLast = lstrlen(pCode)-1;
                        sycm.chCurr = 0;

                        SendMessage(
                            hWnd,
                            WM_COMMAND,
                            MAKELONG(ID_FONT,CBN_SELCHANGE),
                            0L);


                        /* auto font selection according to the codepage.

                        if (lCodePage == UNICODE_CODEPAGE)
                        {
                            SendMessage(
                                hWnd,
                                WM_COMMAND,
                                MAKELONG(ID_FONT,CBN_SELCHANGE),
                                0L);
                        }
                        else
                        {
                            CPINFO      cpinfo;

                            GetCPInfo(lCodePage, &cpinfo);
                            if(cpinfo.MaxCharSize > 1)
                            {
                                CHARSETINFO csi;

                                if(!TranslateCharsetInfo((DWORD*)lCodePage,
                                                &csi, TCI_SRCCODEPAGE))
                                {
                                    csi.ciCharset = Font_GetSelFontCharSet(
                                                     hWnd,
                                                     ID_FONT,
                                                     (INT)SendDlgItemMessage(
                                                                hWnd,
                                                                ID_FONT,
                                                                CB_GETCURSEL,
                                                                0,
                                                                0L));
                                }

                                Font_SelectByCharSet(hWnd,ID_FONT,csi.ciCharset);
                            }
                            SendMessage(
                                hWnd,
                                WM_COMMAND,
                                MAKELONG(ID_FONT,CBN_SELCHANGE),
                                0L);
                        }
                        */

                        // Enable or disable SUR controls
                        EnableSURControls(hWnd);

                        if(fNeedReset || fSearched)
                        {
                            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
                        }
                     }
                    break;
                }

                case (ID_SUBFUNCCHANGED):
                    break;

                case (ID_ADVANCED):
                {
                    switch (HIWORD(wParam)) {
                    case BN_CLICKED:
                        ShowHideAdvancedControls( hWnd, wParam, lParam );
                        break;
                    }
                }
                break;

                case ( ID_FROM ) :
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        HWND hWndEdit = (HWND)lParam;
                        int nLen = GetWindowTextLength(hWndEdit);
                        if ((nLen == MAX_CHARS) && (fSURChanged == FALSE))
                        {
                            fSURChanged = TRUE;
                            ValidateValues(hWndEdit);
                        }
                        else
                        {
                            fSURChanged = FALSE;
                        }
                    }

                    break;
                }
            }
            break;
        }

        case ( WM_DESTROY ) :
        {
            SaveAdvancedSelection(hWnd,ID_ADVANCED,SZ_ADVANCED);
            SaveCurrentSelection(hWnd,ID_VIEW,SZ_CODEPAGE);
            SaveCurrentSelection(hWnd,ID_FONT,SZ_FONT);
            CodePage_DeleteList();
            Font_DeleteList();
            UCE_CloseFiles();
            DeleteResources();
            Display_DeleteList();

            DoHelp(hWnd, FALSE);

            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;
        }

        case ( WM_CLOSE ):
        {
            DestroyWindow(hwndDialog);
            break;
        }

        case ( WM_ACTIVATEAPP ) :
        {
#if 0
// (#326752) Postponed by richedit so we work around it here (wchao, 6-16-99).
#ifndef DISABLE_RICHEDIT
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    ID_STRING,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = (LONG)SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
#else
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    IDC_EDIT,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = SendDlgItemMessage(hWnd, IDC_EDIT, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, IDC_EDIT, EM_SETSEL, 0, 0L);
            }
#endif
#endif
            break;
        }

        case ( WM_CONTEXTMENU ) :
        {
            TCHAR    HelpPath[MAX_PATH];
            if( !GetWindowsDirectory( HelpPath, MAX_PATH))
                 return FALSE;
            wcscat((TCHAR *)HelpPath, TEXT("\\HELP\\CHARMAP.HLP"));
            WinHelp((HWND)(wParam),
                   HelpPath, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aHelpIDs);
            return TRUE;
        }

        case ( WM_HELP ) :
        {
            DoHelp(hWnd, TRUE);
            return TRUE;
        }

    }
    return (0L);
}

////////////////////////////////////////////////////////////////////////////
//
//  CharGridWndProc
//
//  Processes messages for the character grid window.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static LPDROPSOURCE pDropSource;
    static POINT        ptDragStart;

    switch (message)
    {
        case ( WM_CREATE ) :
        {
            RECT rect;
            HDC hdcScrn;
            POINT point1, point2;
            HWND hWndScroll;

            //
            //  Setup global.
            //
            hwndCharGrid = hWnd;

            GetClientRect(hWnd, &rect);

            //
            //  Calculate metrics for the character grid and the
            //  magnify window.
            //
            sycm.dxpBox = (rect.right  - 1) / (cchSymRow + 2);
            sycm.dypBox = (rect.bottom    ) / (cchSymCol + 3);
            sycm.dxpCM  = sycm.dxpBox * cchSymRow+1;
            sycm.dypCM  = sycm.dypBox * cchSymCol+1;  // space inside for border

                                                /*
            if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE))
            {
                sycm.dxpMag = sycm.dxpBox * 3 + 5;
            }
                                                else if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_HINDI) ||
                                                                                        (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_TAMIL))
            {*/
                sycm.dxpMag = sycm.dxpBox * 3 + 15 ; //Indic characters are wide (#178112)
            /*}
            else
            {
                sycm.dxpMag = sycm.dxpBox * 2 + 4; // twice the size + 2 bit border
            }*/
            sycm.dypMag = sycm.dypBox * 2 + 4;

            sycm.chCurr   = chSymFirst;
            sycm.hFontMag = NULL;
            sycm.hFont    = NULL;
            sycm.hdcMag   = NULL;
            sycm.hbmMag   = NULL;
            sycm.ypDest   = 0;

            sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;
            sycm.fMagnify = FALSE;

            //
            //  Size the window precisely so the grid fits and is centered.
            //
            MoveWindow( hWnd,
                        (rect.right  - sycm.dxpCM) / 2 + 2,  //- 4,
                        (rect.bottom - sycm.dypCM) / 2 - 18 + 20,
                        sycm.dxpCM + 2,
                        sycm.dypCM + 2,
                        FALSE );

            //
            //  Figure out what the offsets are between the dialog
            //  and the character grid window.
            //
            point1.x = point1.y = point2.x = point2.y = 0;
            ClientToScreen(hWnd, &point1);
            ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
            //
            // In a mirrored charmap point1.x - point2.x will be a -ve value
            //
            sycm.xpCM = abs(point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
            sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;


            //
            //  Create dc and bitmap for the magnify window.
            //
            if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
            {
                if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                {
                    SetTextColor( sycm.hdcMag,
                                  GetSysColor(COLOR_WINDOWTEXT) );
                    SetBkColor( sycm.hdcMag,
                                GetSysColor(COLOR_WINDOW) );
                    SetBkMode(sycm.hdcMag, OPAQUE);

                    if ((sycm.hbmMag =
                         CreateCompatibleBitmap( hdcScrn,
                                                 sycm.dxpMag,
                                                 sycm.dypMag * 2 )) == NULL)
                    {
                        ;
                        //DeleteDC(sycm.hdcMag);
                        //DeleteObject(sycm.hdcMag);
                    }
                    else
                    {
                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                    }
                }
                ReleaseDC(hWnd, hdcScrn);
            }

            // Create an instance of CDropSource for Drag and Drop
            pDropSource = new CDropSource;

            if (pDropSource == NULL) {
                // Show error message and prevent window from being shown
                return -1;
            }

            hWndScroll = GetDlgItem(GetParent(hWnd), ID_MAPSCROLL);

            GetWindowRect( hwndCharGrid, &rect );
            // Use MapWindowPoint instead of ScreenToClient to map the entire rect,
            // to swap the left and right in a mirrored window.
            MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT) &rect, 2);

            MoveWindow( hWndScroll,
                        rect.right+1,
                        rect.top+1,
                        sycm.dxpBox,
                        sycm.dypCM,
                        FALSE );
            break;
        }

        case ( WM_DESTROY ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            if (fDelClipboardFont)
            {
                DeleteObject(hFontClipboard);
            }
            if (sycm.hFont != NULL)
            {
                DeleteObject(sycm.hFont);
            }
            if (sycm.hFontMag != NULL)
            {
                DeleteObject(sycm.hFontMag);
            }
            if (sycm.hdcMag != NULL)
            {
                DeleteDC(sycm.hdcMag);
            }
            if (sycm.hbmMag != NULL)
            {
                DeleteObject(sycm.hbmMag);
            }

            // Release pDropSource it will automatically destroy itself
            pDropSource->Release();

            break;
        }

        case ( WM_SETFOCUS )  :
        {
            WCHAR wcBuf[8];
            UINT  cp;

            if(GetLocaleInfo(LOWORD(GetKeyboardLayout(0)),
                             LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
            {
                cp = _wtol(wcBuf);
                if(gKBD_CP != cp)
                {
                    gKBD_CP = cp;
                    HDC hDC = GetDC(hwndDialog);
                    UpdateKeystrokeText(hDC, sycm.chCurr, TRUE);
                    ReleaseDC(hwndDialog, hDC);
                }
            }
            //
            // fall through ...
            //
        }

        case ( WM_KILLFOCUS ) :
        {
            DOUTL("Focus\n");
            if (sycm.fMagnify == FALSE)
                DrawSymChOutlineHwnd( &sycm,
                                  hWnd,
                                  sycm.chCurr,
                                  TRUE,
                                  message == WM_SETFOCUS );
            sycm.fFocusState = (message == WM_SETFOCUS);

            break;
        }

        case ( WM_TIMER ) :
        {
            switch (wParam)
            {
                case ( ID_DRAGTIMER ) :
                {
                    // If the user has kept LBUTTON down for long then
                    // start drag and drop operation
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // Come out of magnify mode
                    if (sycm.fMouseDn)
                    {
                        ExitMagnify(hWnd, &sycm);
                    }

                    // perform the modal drag/drop operation.
                    DoDragAndDrop(GetParent(hWnd), pDropSource);
                    break;
                }

                case ( ID_SCROLLTIMER ) :
                {
                    DoDragScroll(hWnd, (WPARAM)prevKeys, (LPARAM)ptPrevMouse);
                    break;
                }
            }

            break;
        }

        case ( WM_LBUTTONDOWN ) :
        {
            RECT    rect;
            UINT    chMouseSymbol;

            DOUTL("WM_LBUTTONDOWN: In\n");

            chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

            // If cursor is off (magnified) and lbutton is clicked
            // exit magnify and go into drag mode ELSE magnify
            if ((sycm.fMagnify)&&(chMouseSymbol == sycm.chCurr))
            {
                // Store the point at which LBUTTON was down
                ptDragStart.x = (int)(short)LOWORD (lParam);
                ptDragStart.y = (int)(short)HIWORD (lParam);

                // Go into dragging mode
                fPendingDrag = TRUE;

                // Start timer
                SetTimer(hWnd, 1, nDragDelay, NULL);
                SetCapture(hWnd);
            }
            else
            {
                if(!pCode || *pCode == '\0')
                    return (0L);

                //
                //  Don't draw anything if there's an update region pending.
                //
                if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
                {
                    DOUTL("WM_LBUTTONDOWN: No upd rect\n");
                    break;
                }

                SetFocus(hWnd);
                SetCapture(hWnd);

                sycm.fMouseDn = TRUE;

                if ((!FMagData(&sycm))&&(sycm.fMagnify==FALSE))
                {
                    DOUTL("WM_LBUTTONDOWN: Drawing sym outline\n");
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                }
            }
            ShowWindow(hwndTT, SW_HIDE);

            //
            //  Fall through to WM_MOUSEMOVE...
            //
        }

        case ( WM_MOUSEMOVE ) :
        {
            int x, y;

            if (sycm.fCursorOff)
            {
                sycm.fCursorOff = FALSE;
                ShowCursor(TRUE);
            }
            // This part is for Drag and Drop
            // If a drag is pending and mouse moves beyond threshold
            // then start our drag and drop operation
            if (fPendingDrag)
            {
                x = (int)(short)LOWORD (lParam);
                y = (int)(short)HIWORD (lParam);

                // Find if the point at which the mouse is is beyond the
                // min rectangle enclosing the point at which LBUTTON
                // was down
                if (! (((ptDragStart.x - nDragMinDist) <= x)
                    && (x <= (ptDragStart.x + nDragMinDist))
                    && ((ptDragStart.y - nDragMinDist) <= y)
                    && (y <= (ptDragStart.y + nDragMinDist))) )
                {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    DoDragAndDrop(GetParent(hWnd), pDropSource);
                }
                break;
            }

            // This is the normal code
            if (sycm.fMouseDn)
            {
                POINT pt;
                UINT chMouseSymbol;

                DOUTL("WM_MOUSEMOVE: mouse is down\n");

                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);


                ClientToScreen(hWnd, (LPPOINT)&pt);

                if (WindowFromPoint(pt) == hWnd)
                {
                    // Kill the out of client are drag timer
                    KillTimer(hWnd, ID_SCROLLTIMER);

                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    //
                    //  Convert back to a 'points'-like thing.
                    //
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);

                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);
                    chPos = chMouseSymbol;
                    if(chPos + chSymFirst <= chRangeLast)
                    {
                        chCurrPos = chPos;
                    }
                    else
                    {
                        chPos = chCurrPos;
                    }

                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

                    // disable space display
                    if ( (chMouseSymbol > (UINT)chSymLast) ||
                         (IsAnyListWindow() &&
                          pCode &&
                          (pCode[chMouseSymbol] == (WCHAR)' ')) )
                    {
                        //
                        //  We're outside of current character range (but
                        //  still within the grid).  Restore cursor and
                        //  leave magnified character.
                        //
                        if (sycm.fCursorOff)
                        {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    }
                    else
                    {
                        //
                        //  We're in the grid and within the range of currently
                        //  displayed characters, display magnified character.
                        //
                        DOUTL("WM_MOUSEMOVE: in grid and subrange\n");

                        if (!sycm.fCursorOff)
                        {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        DOUTL("WM_MOUSEMOVE: movsymsel ");
                        DOUTCHN( (UTCHAR)chMouseSymbol );
                        MoveSymbolSel(&sycm, (UTCHAR)chMouseSymbol);
                    }
                }
                else
                {
                    //
                    //  Left grid, leave magnified character and restore
                    //  cursor.
                    //
                    DOUTL("In Drag Scroll\n");
                    if (sycm.fCursorOff)
                    {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }

                    // Here comes the scroll code for scrolling when we are
                    // outside the client area
                    DoDragScroll(hWnd, wParam, lParam);
                }
            }
            else
            {
                MSG   msg;

                //we need to fill out a message structure and pass
                //it to the tooltip with the TTM_RELAYEVENT message

                msg.hwnd    = hWnd;
                msg.message = message;
                msg.wParam  = wParam;
                msg.lParam  = lParam;
                GetCursorPos(&msg.pt);
                msg.time = GetMessageTime();

                SendMessage(hwndTT, TTM_RELAYEVENT, 0, (LPARAM)&msg);
            }

            DOUTL("WM_MOUSEMOVE: Leaving\n");
            break;
        }

        case ( WM_CANCELMODE ) :
        case ( WM_LBUTTONUP )  :
        {
            //ShowWindow(hwndTT, SW_SHOWNA);

            if (sycm.fMouseDn)
            {
                KillTimer(hWnd, ID_SCROLLTIMER);
            }
            sycm.fMouseDn = FALSE;
            ReleaseCapture();

            // This part is for drag and drop
            // Button came up before starting drag so clear flags and timer
            if (fPendingDrag)
            {
                ReleaseCapture();
                KillTimer(hWnd, 1);
                fPendingDrag = FALSE;
                ExitMagnify(hWnd, &sycm);
            }
            break;
        }

        case ( WM_LBUTTONDBLCLK ) :
        {
            UINT chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

            if (chMouseSymbol <= chRangeLast &&
                pCode[chMouseSymbol] &&
                pCode[chMouseSymbol] != (WCHAR)' ' )
            {
                WCHAR wc = (WCHAR)pCode[sycm.chCurr];
                ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
#ifndef DISABLE_RICHEDIT
                SetRichEditFont(hwndDialog, ID_STRING, sycm.hFont);
                //richedit screws up symbol font display
                //we have to convert to ansi to display symbol font
                if (gFontType & SYMBOL_FONTTYPE)
                {
                  if ((wc >= 0xf000) && (wc <= 0xf0ff))
                    wc = (WCHAR)(BYTE)pCode[sycm.chCurr];
                }
                SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, wc, 0L);
                CopyTextToClipboard(hwndDialog);
#else
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, (WPARAM)(sycm.hFont), MAKELPARAM(true,0));
                SendDlgItemMessage(hwndDialog, IDC_EDIT, WM_CHAR, wc, 0L);
#endif
            }
            if(sycm.fMagnify)
            {
               ExitMagnify(hwndCharGrid, &sycm);
            }
            break;
        }

        case ( WM_GETDLGCODE ) :
        {
            //
            //  Necessary to obtain arrow and tab messages.
            //
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;
        }

        case ( WM_KEYDOWN ) :
        {
            UTCHAR chNew = sycm.chCurr;
            INT    cchMoved;

            fScrolled = FALSE;

            // If hWnd is mirrored swap left and right keys.
            if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
                if (wParam == VK_LEFT) {
                    wParam = VK_RIGHT;
                } else if (wParam == VK_RIGHT) {
                    wParam = VK_LEFT;
                }
            }

            switch (wParam)
            {
                case ( VK_F6 ) :
                {
                    if(ghwndList)
                        SetFocus(ghwndList);
                    else if(ghwndGrid)
                        SetFocus(ghwndGrid);
                    return 0L;
                }

                case ( VK_LEFT ) :
                {
                    if(chNew == 0 || --chNew >= chSymFirst)
                        break;

                    SendMessage(hWnd, WM_KEYDOWN, VK_UP, 0L);

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_UP ) :
                {
                    if ((chNew -  cchSymRow) >= chRangeFirst &&
                        (chNew -= (UTCHAR)cchSymRow) < chSymFirst)
                    {
                        if (!ScrollMap(GetParent(hWnd), -cchSymRow, TRUE))
                            return (0L);

                        while(pCode[chNew] == L' ')
                            --chNew;
                        sycm.chCurr = chNew;
                        RestoreSymMag(hWnd, &sycm);
                        fScrolled = TRUE;
                    }
                    break;
                }

                case ( VK_RIGHT ) :
                {
                    if ((chNew+1) > chRangeLast)
                        break;
                    if (++chNew <= chSymLast && pCode[chNew] != L' ')
                        break;

                    if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

                    sycm.chCurr = ((chNew-1)/cchSymRow)*cchSymRow;
                    SendMessage(hWnd, WM_KEYDOWN, VK_DOWN, 0L);
                    return (0L);
                }

                case ( VK_DOWN ) :
                {
                                                                          if ((chNew +  cchSymRow) <= chRangeLast &&
                        (chNew += (UTCHAR)cchSymRow) <= chSymLast)
                              break;

                    if (!ScrollMap(GetParent(hWnd), cchSymRow, TRUE))
                        return (0L);

                    while(pCode[chNew] == L' ')
                        --chNew;
                    sycm.chCurr = chNew;
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    break;
                }

                case ( VK_NEXT ) :
                {
                    if(chRangeLast <= chSymLast)
                    {
                        while(chNew+cchSymRow <= chRangeLast)
                            chNew += (UTCHAR)cchSymRow;
                        break;
                    }

                    if((cchMoved =
                        ScrollMapPage(GetParent(hWnd), FALSE, TRUE)) == 0)
                    {
                        ValidateRect(hWnd, NULL);
                        return (0L);
                    }
                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    chNew += (UTCHAR)cchMoved;
                    if(chNew > chRangeLast)
                       sycm.chCurr = chNew = chNew - cchSymRow;

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_PRIOR ) :
                {
                    if(chSymLast < cchSymRow*cchSymCol)
                    {
                        while(chNew-cchSymRow >= 0)
                            chNew -= (UTCHAR)cchSymRow;
                        break;
                    }

                    if ((cchMoved =
                        ScrollMapPage( GetParent(hWnd), TRUE, TRUE )) == 0)
                    {
                        ValidateRect(hWnd, NULL);
                        return (0L);
                    }

                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    chNew += (UTCHAR)cchMoved;

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_HOME ) :
                {
                    if(GetAsyncKeyState(VK_CONTROL))
                    {
                        chNew = 0;
                        if(chSymLast > cchSymRow*cchSymCol)
                        {
                            sycm.chCurr = 0;
                            ScrollMap(GetParent(hWnd),
                                      cchSymRow*cchSymCol -chSymLast - 1,
                                      TRUE);
                            RestoreSymMag(hWnd, &sycm);
                            fScrolled = TRUE;
                        }
                    }
                    else
                    {
                        chNew = (chNew/cchSymRow)*cchSymRow;
                    }
                    break;
                }

                case ( VK_END ) :
                {
                    if(GetAsyncKeyState(VK_CONTROL))
                    {
                        chNew = chRangeLast;
                        if(chSymLast < chRangeLast)
                        {
                            int iTemp = ((chRangeLast + cchSymRow)/cchSymRow)
                                        *cchSymRow - chSymLast - 1;

                            ScrollMap(GetParent(hWnd), iTemp, TRUE);
                            RestoreSymMag(hWnd, &sycm);
                            sycm.chCurr = chRangeLast;
                            fScrolled = TRUE;
                        }
                    }
                    else
                    {
                        chNew = ((chNew+cchSymRow)/cchSymRow)*cchSymRow-1;

                        while(pCode[chNew] == L' ')
                            --chNew;

                        if(chNew > chRangeLast)
                            chNew = chRangeLast;
                    }
                    break;
                }

                            default :
                {
                   return (0L);
                }
            }

            if (!FMagData(&sycm))
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

            while ((pCode[chNew] == L' ') && (chNew > chSymFirst))
                --chNew;

            // If scrolled and magnifed draw magnified character
            if ((fScrolled == FALSE) && (sycm.fMagnify == TRUE))
               MoveSymbolSel(&sycm, chNew);
            else
            {
                HDC  hdc;

                // else set focus to true and draw normal character
                BOOL fFocus;
                sycm.fFocusState = TRUE;
                if (fFocus = sycm.fFocusState)
                {
                    sycm.fFocusState = FALSE;
                }

                hdc = GetDC(hwndDialog);
                UpdateKeystrokeText(hdc, chNew, TRUE);
                ReleaseDC(hwndDialog, hdc);

                DrawSymChOutlineHwnd(&sycm, hWnd, chNew, TRUE, fFocus);
                sycm.chCurr = chNew;
            }

                                                {       //#bug 234106 refresh
                                                        HWND hwndCharGrid, hwndSB;
                                                        hwndCharGrid = GetDlgItem(GetParent(hWnd), ID_CHARGRID);
                                                        hwndSB = GetDlgItem(GetParent(hWnd), ID_MAPSCROLL);
                                                        InvalidateRect(hwndCharGrid, NULL, TRUE);
                                                        InvalidateRect(hwndSB, NULL, TRUE);
                                                }

            break;
        }

        case ( WM_CHAR ) :
        {
            WCHAR wch = (WCHAR)wParam;

            if (sycm.fMouseDn)
                break;

        // If space is typed in and user is in Magnify mode exit magnify
        // else enter magnify
            if (wch == ' ')
            {
                if (sycm.fMagnify)
                {
                    ExitMagnify(hwndCharGrid, &sycm);
                }
                else
                {
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                    MoveSymbolSel(&sycm, (UTCHAR)sycm.chCurr, TRUE);
                }
            }

            break;
        }

        case ( WM_PAINT ) :
        {
            HDC hdc;
            PAINTSTRUCT ps;

            DOUTL("WM_PAINT: In\n");

            hdc = BeginPaint(hWnd, &ps);
            DOUTL("WM_PAINT: drawing map\n");
            DrawSymbolMap(&sycm, hdc);

            if(fScrolled)
            {
               DOUTL("WM_PAINT: drawing scroll\n");
               // Drawing correct outline is handled in DrawSymbolMap so no need
               // to do it again here

                // IF the character is magnified draw magnified character
                if (sycm.fMagnify)
                {
                    MoveSymbolSel(&sycm, sycm.chCurr, TRUE);
                }

                fScrolled = FALSE;
            }
            else
            {
                if (sycm.fMagnify)
                {
                    DOUTL("WM_PAINT: drawing magnify\n");
                    MoveSymbolSel(&sycm, sycm.chCurr, TRUE);
                }
            }

            EndPaint(hWnd, &ps);

            DOUTL("WM_PAINT: Leaving\n");
            return (TRUE);
        }

        case ( WM_NOTIFY ) :
        {
            // Tooltip sends a notification to get text to be displayed

            LPTOOLTIPTEXT lptt = (LPTOOLTIPTEXT)lParam;
            POINT pt;
            WCHAR wc;
            INT   x, y, ch;
            DWORD dwPos = GetMessagePos();
            char  szMessageA[MAX_PATH*2];
            WCHAR szMessageW[MAX_PATH];
            LONG  lCodePage;

            if(pCode == NULL || *pCode == 0) break;

            switch (lptt->hdr.code)
            {
                case TTN_NEEDTEXT:
                {
                    pt.x = LOWORD(dwPos);
                    pt.y = HIWORD(dwPos);

                    // Convert the point from screen coordinates to our
                    // window coordinates
                    MapWindowPoints(HWND_DESKTOP, hWnd, &pt, 1);

                    // Now given the point find which rectangle it lies in
                    x = pt.x / sycm.dxpBox;
                    y = pt.y / sycm.dypBox;

                    ch = chSymFirst + y*cchSymRow + x;

                    // If in magnify mode and mouse is in magnify rect then show
                    // tip for the magnified character
                    if (sycm.fMagnify == TRUE)
                    {
                        RECT  rcMagnify;
                        POINT ptLeftTop;

                        ptLeftTop.x = sycm.xpMagCurr;
                        ptLeftTop.y = sycm.ypMagCurr;

                        MapWindowPoints(hwndDialog, hwndCharGrid, &ptLeftTop, 1);

                        rcMagnify.left   = ptLeftTop.x;
                        rcMagnify.right  = rcMagnify.left + sycm.dxpMag;
                        rcMagnify.top    = ptLeftTop.y;
                        rcMagnify.bottom = rcMagnify.top + sycm.dypMag;

                        if (PtInRect(&rcMagnify, pt))
                        {
                            ch = sycm.chCurr;
                        }
                    }

                    if ((ch > chSymLast) || (ch > chRangeLast))
                        break;

                    wc = pCode[ch];

                    // Dont show tips for filler characters
                    if (wc == 0x20)
                        break;

                    if(gFontType & SYMBOL_FONTTYPE)
                    {
                        LoadString(hInst, IDS_SYMBOLSET, szMessageW, MAX_PATH);
                        wsprintf(szTipText, TEXT("%s : 0x%2X"),szMessageW, wc);
                    }
                    else
                    {
                        GetUName(wc, szMessageW);
                        /*
                        MultiByteToWideChar(
                            CP_ACP, 0,
                            szMessageA, -1,
                            szMessageW, MAX_PATH);*/

                        if((lCodePage = CodePage_GetCurCodePageVal())
                            != UNICODE_CODEPAGE)
                        {
                            BYTE mb[2];
                            WORD wCharCode;

                            if (WideCharToMultiByte(
                                lCodePage, WC_NO_BEST_FIT_CHARS,
                                &wc, 1,
                                (char*)mb, 2,
                                NULL, NULL ) == 1)
                            {
                                wCharCode = mb[0];     // single-byte
                            }
                            else
                            {
                                wCharCode = (mb[0]<<8) | mb[1];
                            }

                            wsprintf(szTipText, TEXT("U+%04X (0x%2X): %s"),
                                     wc, wCharCode, szMessageW);
                        }
                        else
                        {
                            wsprintf(szTipText, TEXT("U+%04X: %s"),
                                     wc, szMessageW);
                        }
                    }
                    lstrcpyn(lptt->szText, szTipText, 80);
                }

                default:
                    break;
            }
        }
          break;

        case ( WM_INPUTLANGCHANGE ):
        {
            WCHAR wcBuf[8];
            UINT  cp;

            if(GetLocaleInfo(LOWORD(lParam), LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
            {
                cp = _wtol(wcBuf);
                if(gKBD_CP != cp)
                {
                    gKBD_CP = cp;
                    HDC hDC = GetDC(hwndDialog);
                    UpdateKeystrokeText(hDC, sycm.chCurr, TRUE);
                    ReleaseDC(hwndDialog, hDC);
                }
            }
            return TRUE;
        }

              default :
        {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }

    }
    return (0L);
}

///////////////////////////////////////////////////////////////////////////
//
// When enumerate Bitmap font, Symbol font, OEM font, we got the ANSI code
// points instead of Unicode. So when these fonts are going to be displayed
// we have to convert them to Unicode. (We can use TextOutA, but in
// SendDlgItemMessage, it has to be Unicode.)
//
// We can not convert it using the charset information given by the LOGFONT
// during font enumeration. Those charset information are not accurate. For
// example, in Thai system, "Small fonts" contains Thai characters, but the
// CharSet in LOGFONT is 0. However, the CharSet information in TextMetrics
// is correct.
////////////////////////////////////////////////////////////////////////////
DWORD GetCurFontCharSet(HWND hWnd)
{
  DWORD cs;
  HDC hdc;
  HFONT hfOld;
  TEXTMETRIC tm;

  hdc = GetDC(hWnd);
  hfOld = (HFONT)SelectObject(hdc, sycm.hFont);
  GetTextMetrics(hdc, &tm);
  cs = MAKELONG(tm.tmCharSet, 0);
  SelectObject(hdc, hfOld);
  ReleaseDC(hWnd, hdc);
  return cs;
}

int ConvertAnsifontToUnicode(HWND hWnd, char* mb, WCHAR* wc)
{
  CHARSETINFO csi;
  WORD cp = CP_ACP;
  int  ret = 1;
  DWORD cs;

  if (gFontType & SYMBOL_FONTTYPE)
  {
    cs = GetCurFontCharSet(hWnd);
    if (TranslateCharsetInfo((DWORD *)IntToPtr(cs), &csi, TCI_SRCCHARSET))
      cp = (WORD)(csi.ciACP);
    if ((ret = MultiByteToWideChar(cp, 0, mb, 1, wc, 1)) != 1)
      if ((ret = MultiByteToWideChar(CP_ACP, 0, mb, 1, wc, 1)) != 1)
        *wc = (WCHAR)(BYTE)(*mb);
  }
  return ret;
}

int ConvertUnicodeToAnsiFont(HWND hWnd, WCHAR* wc, char* mb)
{
  CHARSETINFO csi;
  WORD cp = CP_ACP;
  int ret = 1;
  DWORD cs;

  cs = GetCurFontCharSet(hWnd);
  if (TranslateCharsetInfo((DWORD *)IntToPtr(cs), &csi, TCI_SRCCHARSET))
    cp = (WORD)(csi.ciACP);
  if ((ret = WideCharToMultiByte(cp, 0, wc, 1, mb, 1, NULL, NULL)) == 0)
    if ((ret = WideCharToMultiByte(CP_ACP, 0, wc, 1, mb, 1, NULL, NULL)) == 0)
      *mb = (char)(BYTE)(*wc);
  return ret;
}

////////////////////////////////////////////////////////////////////////////
//
//  ProcessScrollMsg
//
////////////////////////////////////////////////////////////////////////////

VOID ProcessScrollMsg(
    HWND hwndDlg,
    int nCode,
    int nPos)
{
    UTCHAR chNew = sycm.chCurr;
    HWND hwndGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    int cchScroll;

    switch( nCode )
    {
        case ( SB_LINEUP ) :
        {
            cchScroll = -cchSymRow;
            break;
        }
        case ( SB_LINEDOWN ) :
        {
            cchScroll = cchSymRow;
            break;
        }
        case ( SB_PAGEUP ) :
        {
            cchScroll = (int)TRUE;
            break;
        }
        case ( SB_PAGEDOWN ) :
        {
            cchScroll = (int)FALSE;
            break;
        }
        case ( SB_THUMBTRACK ) :
        case ( SB_THUMBPOSITION ) :
        {
            cchScroll = (nPos * cchSymRow + chRangeFirst) - chSymFirst;
            break;
        }
        default :
        {
            return;
        }
    }

    if (nCode == SB_PAGEUP || nCode == SB_PAGEDOWN)
    {
        if (!ScrollMapPage(hwndDlg, (BOOL)cchScroll, TRUE))
        {
            return;
        }

        //
        //  ScrollMapPage will do the right thing to sycm.chCurr.
        //
        chNew = sycm.chCurr;
        fScrolled = TRUE;
        while(pCode[chNew] == L' ')
            --chNew;
    }
    else
    {
        if (cchScroll == 0 || !ScrollMap(hwndDlg, cchScroll, TRUE))
        {
            return;
        }

        //
        //  Keep the current symbol inside the window.
        //
        while (chNew > chSymLast)
        {
            chNew -= (UTCHAR)cchSymRow;
        }

        while (chNew < chSymFirst)
        {
            chNew += (UTCHAR)cchSymRow;
        }
        while(pCode[chNew] == L' ')
            --chNew;
    }

    sycm.chCurr = chNew;
    RestoreSymMag(hwndGrid, &sycm);
}

////////////////////////////////////////////////////////////////////////////
//
//  ScrollMapPage
//
//  Scrolls the map up or down by a page.  See ScrollMap().
//
////////////////////////////////////////////////////////////////////////////

INT ScrollMapPage(
    HWND hwndDlg,
    BOOL fUp,
    BOOL fRePaint)
{
    INT cchScroll = cchFullMap;

    if (fUp)
    {
        cchScroll = -cchScroll;
    }

    if ((chSymFirst + cchScroll) < chRangeFirst)
    {
        cchScroll = (chRangeFirst - chSymFirst);
    }
    else if ((chSymLast + cchScroll) > chRangeLast)
    {
        cchScroll = (1+(chRangeLast-chSymLast-1)/cchSymRow)*cchSymRow;
    }

    return (ScrollMap(hwndDlg, cchScroll, fRePaint) ? cchScroll : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMap
//
//  Scrolls the map up or down if there are too many chars to fit in the
//  chargrid.
//
////////////////////////////////////////////////////////////////////////////

BOOL ScrollMap(
    HWND hwndDlg,
    INT cchScroll,
    BOOL fRePaint)
{
    HWND hwndSB, hwndCharGrid;
    INT chFirst = chSymFirst + cchScroll;
    INT chLast = chSymLast + cchScroll;
    HDC hdc;

    if ((chFirst < chRangeFirst) || (chLast > chRangeLast + cchSymRow - 1))
    {
        return (FALSE);
    }
    hwndCharGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    hwndSB = GetDlgItem(hwndDlg, ID_MAPSCROLL);
    SetScrollPos(hwndSB, SB_CTL, (chFirst - chRangeFirst) / cchSymRow, TRUE);

    UpdateSymbolRange(hwndDlg, chFirst, chLast);

    if ((hwndDlg != NULL) && ((hdc = GetDC(hwndDlg)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = (HFONT)SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
        }
        ReleaseDC(hwndDlg, hdc);
    }

    if (fRePaint)
    {
        InvalidateRect(hwndSB, NULL, TRUE);
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  ChFromSymLParam
//
//  Determines the character to select from the mouse position (lParam).
//
////////////////////////////////////////////////////////////////////////////

UINT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
    return (min( cchSymRow - 1,
                 max(0, ((INT)LOWORD(lParam) - 1) / psycm->dxpBox) ) +
            min( cchSymCol - 1,
                 max(0, ((INT)HIWORD(lParam) - 1) / psycm->dypBox) ) *
            cchSymRow + chSymFirst);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutlineHwnd
//
//  Gets a DC for hwnd, calls DrawSymChOutline.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutlineHwnd(
    PSYCM psycm,
    HWND hwnd,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HDC hdc = GetDC(hwnd);

    DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
    ReleaseDC(hwnd, hdc);
}


//
// Get physical font dimension from the given logical font.
// This routine may scale down the logical font size to match the best
// possible viewable size of the given font (wchao).
//
BOOL GetViewableFontDimensions (
    HDC             hdc,
    int             dypInch,        // presentation device's logical pixel per inch
    LOGFONT*        plf,            // (in/out) requested logical font
    HFONT*          phFontOld,      // (out) -optional- original font in the dc
    HFONT*          phFontNew,      // (out) new created font
    TEXTMETRIC*     ptm)            // (out) physical dimensions of *phFontNew
{
    if (!phFontNew || !ptm)
        return FALSE;

    LONG    iHeightSave = plf->lfHeight;
    LONG    iDir = plf->lfHeight < 0 ? -1 : 1;
    HFONT   hFont = CreateFontIndirect(plf);
    HFONT   hFontOld = (HFONT)SelectObject(hdc, hFont);

    GetTextMetrics(hdc, ptm);


    // This loop is only needed by bitmap font as it was digitized (either scaling up or down)
    // by GDI to a greater resolution. This makes the character looks chunky (imagine how bad
    // it would be for "Small Fonts" scaled up to 13pt). We scale down the font until it
    // matches screen resolution.

    while (plf->lfHeight && ptm->tmDigitizedAspectY != dypInch)
    {
        plf->lfHeight -= iDir;      // scaling down
        DeleteObject(hFont);
        hFont = CreateFontIndirect(plf);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, ptm);
    }

    if (ptm->tmDigitizedAspectY != dypInch || !ptm->tmHeight)
    {
        // If we get here. GDI is really messed up.
        //
        plf->lfHeight = iHeightSave;
        DeleteObject(hFont);
        hFont = CreateFontIndirect(plf);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, ptm);
    }

    *phFontNew = hFont;

    if (phFontOld)
        *phFontOld = hFontOld;

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////
//
//  RecalcUCE
//
//  Recalculates fixed character map data (font info, sizes, etc.).
//
////////////////////////////////////////////////////////////////////////////

VOID RecalcUCE(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
    HDC          hdc;
    TEXTMETRIC   tm;
    UINT ch;
    LPINT lpdxp;
    HFONT        hFont;
    LOGFONT      LogFont;
    LONG         iCurSel;
    int          dypInch;

    //
    //  Get rid of the old font handles.
    //
    if (hFontClipboard && (hFontClipboard == psycm->hFont))
    {
        fDelClipboardFont = TRUE;
    }
    if (psycm->hFont && (hFontClipboard != psycm->hFont))
    {
        DeleteObject(psycm->hFont);
    }
    if (psycm->hFontMag)
    {
        DeleteObject(psycm->hFontMag);
    }

    hdc = GetDC(hwndCharGrid);

    //  Get device y logical pixel per inch
    dypInch = GetDeviceCaps(hdc, LOGPIXELSY);

    //
    //  Set these to zero.
    //
    LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                      LogFont.lfWeight = 0;
    LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
                       LogFont.lfOutPrecision = LogFont.lfClipPrecision =
                       LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;

    //
    //  Let the facename and size define the font.
    //
    //  LogFont.lfCharSet = DEFAULT_CHARSET;

    //  Work around the GDI bug that assumes the font's default charset
    //  is always the system default locale.
    //
    LogFont.lfCharSet = Font_pList[iCombo].CharSet;

    //
    //  Get the facename from the combo box.
    //
    if(lstrcmpi(Font_pList[iCombo].szFaceName, L"SystemDefaultEUDCFont") == 0)
      lstrcpy(LogFont.lfFaceName, _T("MS Sans Serif"));
    else
      lstrcpy(LogFont.lfFaceName, Font_pList[iCombo].szFaceName);


    //
    //  Enable Block listbox and set defaults appropriately.
    //
    iCurSel = (LONG)SendDlgItemMessage( hwndDlg,
                                        ID_UNICODESUBSET,
                                        CB_GETCURSEL,
                                        0,
                                        0L );
    UpdateSymbolSelection( hwndDlg, TRUE);

    //
    //  Create the magnify font.
    //
    LogFont.lfHeight = psycm->dypMag - 5;        // Allow for whitespace.
    psycm->hFontMag = CreateFontIndirect(&LogFont);


    //
    //  Create the grid font
    //
    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        LogFont.lfHeight = 16;
    }
    else
    {
        LogFont.lfHeight = psycm->dypBox - 6;    // 3-pixel top/bottom barring.
    }


    GetViewableFontDimensions(hdc, dypInch, &LogFont, &hFont, &psycm->hFont, &tm);


    //  Font with significant descent-ascent (round) ratio
    //  e.g. most Thai fonts, Traditional Arabic.

    if (tm.tmAscent && MulDiv(tm.tmDescent, 10, tm.tmAscent) > 4)
    {
        DeleteObject(psycm->hFont);
        LogFont.lfHeight = -LogFont.lfHeight;       // request it as character height
        GetViewableFontDimensions(hdc, dypInch, &LogFont, NULL, &psycm->hFont, &tm);
        LogFont.lfHeight = tm.tmHeight;             // now take the actual cell height
    }


    //  Maximum avg width allowed inside a grid box
    LONG    iMaxAveBoxWidth = MulDiv(tm.tmHeight, psycm->dxpBox, psycm->dypBox) - 2;   // 1-pixel side barrings
    LONG    tmHeightLast = tm.tmHeight;


    //  Narrow down allowance for non-symbol proportional font
    if (tm.tmCharSet != SYMBOL_CHARSET &&
        tm.tmAveCharWidth != tm.tmMaxCharWidth)
        iMaxAveBoxWidth = MulDiv(iMaxAveBoxWidth, 70, 100); // 70% looks good for most fonts specially FE's.


    //  Try & Fit the font in grid box
    while (tm.tmAveCharWidth > iMaxAveBoxWidth)
    {
        DeleteObject(psycm->hFont);
        LogFont.lfHeight--;
        GetViewableFontDimensions(hdc, dypInch, &LogFont, NULL, &psycm->hFont, &tm);

        // Nothing better, let's get out of here.
        if (tm.tmHeight == tmHeightLast)
            break;

        tmHeightLast = tm.tmHeight;
    }

    psycm->xpCh = 2;

    psycm->ypCh = (psycm->dypBox - tm.tmHeight + 1) / 2;    // y offset display position in a grid box

    lpdxp = (LPINT) psycm->rgdxp;

    Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);

    SelectObject(hdc, hFont);

    for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
    {
        *lpdxp = (psycm->dxpBox - *lpdxp) / 2;
    }

    ReleaseDC(hwndCharGrid, hdc);

    psycm->xpMagCurr = 0;              // No magnification data

    // Set the tooltip window for the character grid
    ResizeTipsArea(hwndCharGrid, &sycm);

    if (fRedraw)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolMap
//
//  Draws all of the pieces of the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC hdc)
{
    BOOL fFocus;

    DrawSymbolGrid(psycm, hdc);
    DrawSymbolChars(psycm, hdc);
    //
    //  We need to force the focus rect to paint if we have the focus
    //  since the old focus rect has been drawn over already.
    //
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }

    if (psycm->fMagnify == FALSE)
    {
        DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolGrid
//
//  Draws the symbol character map grid.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)

{
    INT cli;                // count of lines
    INT xp, yp;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    HPEN hpenOld;
    INT xpos, ypos;

    hpenOld = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID,
                                                 1,
                                                 GetSysColor(COLOR_WINDOWFRAME)));
    //
    //  Draw horizontal lines.
    //
    xp = psycm->dxpCM + 1;
    yp = 1;
    ypos = 0;
    cli = cchSymCol+1;
    while (cli--)
    {
        MoveToEx(hdc, 1, yp, NULL);
        LineTo(hdc, xp, yp);
        yp += dypBox;
        ypos += 1;
     }

    //
    //  Draw vertical lines.
    //
    yp = psycm->dypCM;
    xp = 1;
    xpos = 0;
    cli = cchSymRow+1;
    while (cli--)
    {
        MoveToEx(hdc, xp, 1, NULL);
        LineTo(hdc, xp, yp);
        xp += dxpBox;
        xpos += 1;
    }

    DeleteObject(SelectObject(hdc, hpenOld));
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolChars
//
//  Draws the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC hdc)
{
    INT    dxpBox  = psycm->dxpBox;
    INT    dypBox  = psycm->dypBox;

    INT    cch;
    INT    x, y;
    INT    yp;
    TCHAR   ch;

    HFONT  hFontOld;
    RECT   rect;
    LPRECT lprect = (LPRECT) &rect;
    LPINT lpdxp;

    if ((pCode == NULL) || (*pCode == '\0'))
    {
        return;
    }

    //
    // Setup the font and colors.
    //
    hFontOld = (HFONT) SelectObject(hdc, psycm->hFont);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    //
    // Draw characters.
    //
    cch = 1;
    ch = chSymFirst;

    lpdxp = (LPINT) psycm->rgdxp;

    rect.top = 2;
    yp = psycm->ypCh;
    rect.bottom = rect.top + dypBox - 1;

    for (y = 0; y++ < cchSymCol;)
    {
        rect.left  = psycm->xpCh;
        rect.right = rect.left + dxpBox - 1;
        for (x = 0; (x++ < cchSymRow) && (ch <= chSymLast);)
        {
          WCHAR wc = pCode[ch];
          ConvertAnsifontToUnicode(hwndCharGrid, (char*)&pCode[ch], &wc);
          ExtTextOutW( hdc,
                       rect.left + (*lpdxp++),
                       yp,
                       ETO_OPAQUE | ETO_CLIPPED,
                       lprect,
                       &wc,
                       1,
                       NULL );
/*
// Unify display using ExtTextOutW
            if(gFontType & SYMBOL_FONTTYPE)
            {
                char mb = (char)pCode[ch];
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &mb,
                             1,
                             NULL );
            }
            else if(gFontType & OEM_FONTTYPE)
            {
                char mb;
                WideCharToMultiByte(CP_OEMCP, WC_NO_BEST_FIT_CHARS,
                    &pCode[ch], 1, &mb, 1, NULL, NULL);
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &mb,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &(pCode[ch]),
                             1,
                             NULL );
            }
*/
           ch++;
           if(ch > chRangeLast)
           {
              return;
           }
           rect.left  += dxpBox;
           rect.right += dxpBox;
        }
        yp += dypBox;
        rect.top += dypBox;
        rect.bottom += dypBox;
    }

    SelectObject(hdc, hFontOld);
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutline
//
//  Draws an outline around the symbol in the character map.  If fVisible,
//  then it draws the outline, otherwise it erases it.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutline(
    PSYCM psycm,
    HDC hdc,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HBRUSH hbrOld;
    RECT rc;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;

    hbrOld = (HBRUSH)SelectObject( hdc,
                           CreateSolidBrush(GetSysColor( fVisible
                                                           ? COLOR_WINDOWFRAME
                                                           : COLOR_WINDOW )) );
    ch -= chSymFirst;

    rc.left   = (ch % cchSymRow) * dxpBox + 2;
    rc.right  = rc.left + dxpBox - 1;
    rc.top    = (ch / cchSymRow) * dypBox + 2;
    rc.bottom = rc.top  + dypBox - 1;

    //
    //  Draw selection rectangle.
    //
    PatBlt(hdc, rc.left,      rc.top - 2,    dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left,      rc.bottom + 1, dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left - 2,  rc.top,        1,          dypBox - 1, PATCOPY);
    PatBlt(hdc, rc.right + 1, rc.top,        1,          dypBox - 1, PATCOPY);

    DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

    //
    //  Deal with the focus rectangle.
    //
    if (fFocus != psycm->fFocusState)
    {
        DrawFocusRect(hdc, &rc);
        psycm->fFocusState = fFocus;
    }

    SelectObject(hdc, hbrOld);
}

////////////////////////////////////////////////////////////////////////////
//
//  MoveSymbolSel
//
//  Changes the current symbol selection.  Handles drawing of magnified
//  characters.
//
////////////////////////////////////////////////////////////////////////////

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew,
    BOOL fRepaint)
{
    HDC hdc;
    HDC hdcMag = psycm->hdcMag;
    RECT rc;
    HFONT hFontOld;
    HFONT hFontMag;                    // old font in memory dc
    HPEN hpenOld;

    UTCHAR chNorm = chNew - chSymFirst + cchSymRow;

    INT dxpMag = psycm->dxpMag;        // for quick reference
    INT dypMag = psycm->dypMag;
    INT ypMemSrc  = psycm->ypDest;
    INT ypMemDest = ypMemSrc ^ dypMag;
    INT xpCurr  = psycm->xpMagCurr;
    INT ypCurr  = psycm->ypMagCurr;
    INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
    INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
    INT dxpCh;  // width of extra character space (used to center char in box)
    INT dypCh;
    SIZE sz;

    DOUTL("MoveSymbolSel: In\n");

    if(chNew > chRangeLast)
    {
        return;
    }

    if ((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)
        && (fRepaint == FALSE))
    {
        DOUTL("MoveSymbolSel: ch == cur && fMag... exiting\n");
        return;
    }

    hdc = GetDC(hwndDialog);

    //
    //  Setup the magnified font character.
    //
    hFontMag = (HFONT)SelectObject(hdcMag, psycm->hFontMag);

    if (pCode != NULL   &&  chNew <= chRangeLast) {
        GetTextExtentPointW(hdcMag, &pCode[chNew], 1, &sz);
    }

    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 2;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 2;
    }
    else
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
    }
    hpenOld = (HPEN)SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));
    hFontOld = (HFONT)SelectObject(hdc, psycm->hFontMag);

    //
    //  Copy screen data to offscreen bitmap.
    //
    BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

    //
    //  Setup DC.
    //
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);


    if (FMagData(psycm))
    {
        INT xpT  = xpNew - xpCurr;     // point of overlap in offscreen data
        INT ypT  = ypNew - ypCurr;
        INT dxpT = dxpMag - abs(xpT);  // size of overlap
        INT dypT = dypMag - abs(ypT);


        DOUTL("MoveSymbolSel: FMagData\n");

        if ((dxpT > 0) && (dypT > 0))
        {
            INT xpTmax,  ypTmax;   // max(0, xpT);
            INT xpTmin,  ypTmin;   // min(0, xpT);
            INT xpTnmin, ypTnmin;  // min(0, -xpT);

            DOUTL("MoveSymbolSel: dxpT > 0 && dypT > 0\n");

            if (xpT < 0)
            {
                xpTnmin = - (xpTmin = xpT);
                xpTmax  = 0;
            }
            else
            {
                xpTmax  = xpT;
                xpTnmin = xpTmin = 0;
            }
            if (ypT < 0)
            {
                ypTnmin = - (ypTmin = ypT);
                ypTmax  = 0;
            }
            else
            {
                ypTmax  = ypT;
                ypTnmin = ypTmin = 0;
            }

            rc.left  = xpTmax;
            rc.right = xpTmin + dxpMag;
            rc.top   = ypTmax + ypMemSrc;
            rc.bottom= ypTmin + dypMag + ypMemSrc;

            //
            //  Copy overlapping offscreen data.
            //
            BitBlt( hdcMag,
                    xpTnmin,
                    ypTnmin + ypMemDest,
                    dxpT,
                    dypT,
                    hdcMag,
                    xpTmax,
                    ypTmax  + ypMemSrc,
                    SRCCOPY );

            //
            //  Print part of char over old screen data.
            //
            WCHAR wc = pCode[chNew];
//            ConvertAnsifontToUnicode(hwndDialog, psycm->hFontMag, (char*)&pCode[chNew], &wc);
            ConvertAnsifontToUnicode(hwndDialog, (char*)&pCode[chNew], &wc);
            ExtTextOutW( hdcMag,
                         xpT + dxpCh,
                         ypT + dypCh + ypMemSrc,
                         ETO_OPAQUE | ETO_CLIPPED,
                         (LPRECT)&rc,
                         &wc,
                         1,
                         NULL );

        }
        //
        //  Restore old screen data.
        //
        BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);
    }

    rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
    rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;

    //
    //  The rectangle.
    //
    MoveToEx(hdc, rc.left, rc.top, NULL);
    LineTo(hdc, rc.left, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.top);
    LineTo(hdc, rc.left, rc.top);

    //
    //  The shadow.
    //
    MoveToEx(hdc, rc.right, rc.top + 1, NULL);
    LineTo(hdc, rc.right, rc.bottom);
    LineTo(hdc, rc.left, rc.bottom);
    MoveToEx(hdc, rc.right + 1, rc.top + 2, NULL);
    LineTo(hdc, rc.right + 1, rc.bottom + 1);
    LineTo(hdc, rc.left + 1, rc.bottom + 1);

    rc.left++;
    rc.top++;
    rc.right--;
    rc.bottom--;

    //
    //  Draw magnified character on screen.
    //
    WCHAR wc = pCode[chNew];
    ConvertAnsifontToUnicode(hwndCharGrid, (char*)&pCode[chNew], &wc);
    ExtTextOutW( hdc,
                 xpNew + dxpCh,
                 ypNew + dypCh,
                 ETO_OPAQUE | ETO_CLIPPED,
                 (LPRECT)&rc,
                 &(wc),
                 1,
                 NULL );

    psycm->ypDest = ypMemDest;

    DeleteObject(SelectObject(hdc, hpenOld));
    SelectObject(hdc, hFontOld);
    SelectObject(hdcMag, hFontMag);

    UpdateKeystrokeText(hdc, chNew, TRUE);

    ReleaseDC(hwndDialog, hdc);

    psycm->chCurr = chNew;
    psycm->fMagnify = TRUE;
    DOUTL("MoveSymbolSel: Leaving\n");
}

////////////////////////////////////////////////////////////////////////////
//
//  RestoreSymMag
//
//  Restores the screen data under the magnifier.
//
////////////////////////////////////////////////////////////////////////////

VOID RestoreSymMag(
    HWND  hWndGrid,
    PSYCM psycm)
{
    if (FMagData(psycm))
    {
        HDC hdc = GetDC(hwndDialog);

        // Does not overwrite scroll bar
        BitBlt( hdc,
                psycm->xpMagCurr,
                psycm->ypMagCurr,
                psycm->dxpMag,
                psycm->dypMag,
                psycm->hdcMag,
                0,
                psycm->ypDest,
                SRCCOPY );

        ReleaseDC(hwndDialog, hdc);

        psycm->xpMagCurr = 0;     // flag - no data offscreen (see FMagData)
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  GetEditText
//
//  Returns HANDLE containing the text in the edit control.
//
//  NOTE: Caller is responsible for freeing this handle!
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    DWORD dwSel;

#ifndef DISABLE_RICHEDIT
    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);
#else
    hwndEditCtl = GetDlgItem(hwndDlg, IDC_EDIT);
#endif
    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    if (hmem) {
        lpstrText = (LPTSTR)GlobalLock(hmem);
    
        cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);
    
        dwSel = (DWORD)SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);
    
        if (LOWORD(dwSel) != HIWORD(dwSel))
        {
            //
            //  If there is a selection, then only get the selected text.
            //
            *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
            lstrcpy(lpstrText, lpstrText + LOWORD(dwSel));
        }
    
        GlobalUnlock(hmem);
    
        if (cchText == 0)
        {
            hmem = GlobalFree(hmem);
        }
    }

    return (hmem);
}

////////////////////////////////////////////////////////////////////////////
//
//  PointsToHeight
//
//  Calculates the height in pixels of the specified point size for the
//  current display.
//
////////////////////////////////////////////////////////////////////////////

INT PointsToHeight(
    INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return (iHeight);
}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateKeystrokeText
//
//  Calculates and updates the text string displayed in the Keystroke
//  field of the status bar.  It repaints the status field if fRedraw is
//  TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateKeystrokeText(
    HDC hdc,
    UTCHAR chNew,
    BOOL fRedraw)
{
    if (!pCode || *pCode == '\0')
    {
       LoadString(hInst,
                  IDS_NOCHARFOUND,
                  szKeystrokeText,
                  sizeof(szKeystrokeText)/sizeof(TCHAR));
    }
    else
    {
        char  szMessageA[MAX_PATH*2];
        WCHAR szMessageW[MAX_PATH];
        LONG  lCodePage;
        BYTE  mb[2];
        WORD  wCharCode;

        szAlt[0] = 0;

        if(gFontType & SYMBOL_FONTTYPE)
        {
           LoadString(hInst, IDS_SYMBOLSET, szMessageW, MAX_PATH);
           wsprintf(szKeystrokeText,TEXT("%s : 0x%2X"), szMessageW, pCode[chNew]);
        }
        else
        {
            GetUName(pCode[chNew],szMessageW);
            /* MultiByteToWideChar(CP_ACP, 0, szMessageA, -1, szMessageW, MAX_PATH);*/

            if((lCodePage = CodePage_GetCurCodePageVal()) != UNICODE_CODEPAGE)
            {
                int i;

                i = WideCharToMultiByte(
                        lCodePage, WC_NO_BEST_FIT_CHARS,
                        &pCode[chNew], 1,
                        (char*)mb, 2,
                        NULL, NULL );

                if(i == 1)
                {
                    wCharCode = mb[0];               // single-byte
                }
                else
                {
                    wCharCode = (mb[0]<<8) | mb[1];  // double-byte
                }

                wsprintf(szKeystrokeText,TEXT("U+%04X (0x%2X): %s"),
                         pCode[chNew], wCharCode,szMessageW);
            }
            else
            {
                wsprintf(szKeystrokeText, TEXT("U+%04X: %s"),
                         pCode[chNew], szMessageW);
            }

            // add keystroke info to high ANSI char
            // exclude Control chars
            if((pCode[chNew] > 0x009F) &&
               (WideCharToMultiByte(gKBD_CP, WC_NO_BEST_FIT_CHARS,
                                    &pCode[chNew],1,
                                    (char*)mb,2,NULL,NULL) == 1)
               && (*mb > 0x7F))
            {
               LoadString(hInst, IDS_ALT, szMessageW, MAX_PATH);
                           wsprintf(szAlt, TEXT("%s: Alt+0%d"), szMessageW, *mb);
            }
        }

    }

    if (fRedraw)
    {
        PaintStatusLine(hdc, FALSE, TRUE);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SubSetChanged
//
//  Sets the ANSI bit if appropriate and then calls UpdateSymbolSelection
//  and then repaints the window.
//
//  Repaints Keystroke field if HWND != NULL.
//
//  Redraws the char grid.
//
////////////////////////////////////////////////////////////////////////////

VOID SubSetChanged(
    HWND hwnd)
{
    HDC hdc;

    ExitMagnify(hwndCharGrid, &sycm);
    UpdateSymbolSelection(hwnd, TRUE);
    if ((hwnd != NULL) && ((hdc = GetDC(hwnd)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = (HFONT)SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (pCode)
        {
            Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
        }
        ReleaseDC(hwnd, hdc);
    }

    if(sycm.chCurr != 0)
    {
        sycm.chCurr = 0;
        HDC hDC = GetDC(hwndDialog);
        UpdateKeystrokeText(hDC, sycm.chCurr, FALSE);
        ReleaseDC(hwndDialog, hDC);
        InvalidateRect(hwndDialog, NULL, TRUE);
    }
    InvalidateRect(hwndCharGrid, NULL, TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolSelection
//
//  Updates the values of the following global values:
//      chRangeFirst
//      chRangeLast
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolSelection(
    HWND hwnd,
    BOOL bUpdateRange)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = 0;

    if(bUpdateRange)
    {
        LPWSTR lpszSubsetChar=NULL;
        INT    nSubsetChar = 0;
        BOOL   bLineBreak=FALSE;

        URANGE *pCMapTab = NULL;
        INT    nNumofCMapTab = 0;

        LONG lCodePage;

        lCodePage = CodePage_GetCurSelCodePage(hwnd,ID_VIEW);

        Subset_GetUnicodeCharsToDisplay(
                    hwnd,
                    ID_UNICODESUBSET,
                    lCodePage,
                    &lpszSubsetChar,
                    (unsigned int*)&nSubsetChar,
                    &bLineBreak);

        Font_GetCurCMapTable(hwnd,ID_FONT,&pCMapTab,(unsigned int*)&nNumofCMapTab);

        pCode = Display_CreateDispBuffer(
                        lpszSubsetChar,
                        nSubsetChar,
                        pCMapTab,
                        nNumofCMapTab,
                        bLineBreak);
    }

    if(pCode == NULL || *pCode == 0)
    {
           chRangeLast = 0;
    }
    else
    {
           chRangeLast = lstrlen(pCode)-1;
    }

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;
        if (i < cchSymRow)
        {
            i = 1;
        }
        else
        {
            i = (i+cchSymRow-1) / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);
    UpdateSymbolRange(hwnd, chFirst, chLast);

    //adjust character position
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
          hFont = (HFONT)SelectObject(hdc, sycm.hFont);
          lpdxp = (LPINT)sycm.rgdxp;

          if (pCode)
          {
            Font_GetCharWidth32(hdc, chFirst, chLast, lpdxp,pCode);
          }

          SelectObject(hdc, hFont);

          for (ch = (UINT) chFirst; ch <= (UINT) chLast; ch++, lpdxp++)
          {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
          }
          ReleaseDC(hwnd, hdc);
        }
    }
}

VOID SetSpecificSelection(HWND hwnd,
                          int iFrom,
                          int iTo)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = 0;

    LPWSTR lpszSubsetChar=NULL;
    INT    nSubsetChar = 0;
    BOOL   bLineBreak=FALSE;

    URANGE *pCMapTab = NULL;
    INT    nNumofCMapTab = 0;

    LONG lCodePage;

    lCodePage = CodePage_GetCurSelCodePage(hwnd,ID_VIEW);

    Subset_GetUnicodeCharsToDisplay(
                hwnd,
                ID_UNICODESUBSET,
                lCodePage,
                &lpszSubsetChar,
                (unsigned int*)&nSubsetChar,
                &bLineBreak);

    Font_GetCurCMapTable(hwnd,ID_FONT,&pCMapTab,(unsigned int*)&nNumofCMapTab);

    pCode = Display_CreateSubsetDispBuffer(
                    lpszSubsetChar,
                    nSubsetChar,
                    pCMapTab,
                    nNumofCMapTab,
                    bLineBreak,
                    iFrom,
                    iTo);

    if (pCode && pCode[0])
    {
        chRangeLast = lstrlen(pCode)-1;
    }

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;
        if (i < cchSymRow)
        {
            i = 1;
        }
        else
        {
            i = (i+cchSymRow-1) / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);
    UpdateSymbolRange(hwnd, chFirst, chLast);

    //adjust character position
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
          hFont = (HFONT)SelectObject(hdc, sycm.hFont);
          lpdxp = (LPINT)sycm.rgdxp;

          if (pCode)
          {
            Font_GetCharWidth32(hdc, chFirst, chLast, lpdxp,pCode);
          }

          SelectObject(hdc, hFont);

          for (ch = (UINT) chFirst; ch <= (UINT) chLast; ch++, lpdxp++)
          {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
          }
          ReleaseDC(hwnd, hdc);
        }
    }

}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolRange
//
//  Updates the values of the following global values:
//      chSymFirst
//      chSymLast
//      sycm.chCurr
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolRange(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;

    chSymFirst = (UTCHAR)FirstChar;
    chSymLast = (UTCHAR)LastChar;

    sycm.chCurr = chSymOffset + chSymFirst;

    if (sycm.chCurr > chSymLast)
    {
        sycm.chCurr = chSymFirst;
    }
    while(sycm.chCurr>chSymFirst && pCode[sycm.chCurr] == L' ')
             --sycm.chCurr;

    if (hwnd != NULL)
    {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintStatusLine
//
//  Paints the Help and Keystroke fields in the status bar.
//
//  Repaints Help field if fHelp == TRUE.
//  Repaints Keystroke field if fKeystroke == TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
    {
        hfontOld = (HFONT)SelectObject(hdc, hfontStatus);
    }

    //
    //  Set the text and background colors.
    //
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fKeystroke)
    {
        //
        //  Now the character text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rcStatusLine.right - 9 * dyBorder;

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szKeystrokeText,
                    lstrlen(szKeystrokeText),
                    NULL );

        //
        //  Now the keystroke Alt+ text, with a gray background.
        //
        if(szAlt[0])
        {
          rect.left   += dxHelpField;
/*
          ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szAlt,
                    lstrlen(szAlt),
                    NULL );
*/
          UINT ta = GetTextAlign(hdc);
          UINT tb = ta | TA_RIGHT;
          SetTextAlign(hdc, tb);
          ExtTextOut( hdc,
                    rect.right - dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE,
                    &rect,
                    szAlt,
                    lstrlen(szAlt),
                    NULL );
          SetTextAlign(hdc, ta);
        }
    }

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DoHelp
//
//  Invokes help if fInvokeHelp is true, or dismisses help if fInvokeHelp
//  is FALSE.
//
////////////////////////////////////////////////////////////////////////////

VOID DoHelp(
    HWND hWnd,
    BOOL fInvokeHelp)
{
        if (fInvokeHelp)
        {
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HH_DISPLAY_TOPIC, 0L);
//BUGBUG    HtmlHelp(hWnd, ChmHelpPath, HH_DISPLAY_TOPIC, 0L);
        }
        else
        {
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HHWIN_PROP_POST_QUIT, 0L);
//BUGBUG    HtmlHelp(hWnd, ChmHelpPath, HHWIN_PROP_POST_QUIT, 0L);
        }
}

////////////////////////////////////////////////////////////////////////////
//
//  ExitMagnify
//
//  Releases mouse capture, exits magnify mode, and restores the cursor.
//
////////////////////////////////////////////////////////////////////////////

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    BOOL fFocus;
    //
    //  Release capture, remove magnified character, restore cursor.
    //
    ReleaseCapture();
    RestoreSymMag(hWnd, psycm);
    psycm->fFocusState = TRUE;
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, fFocus);
    if (psycm->fCursorOff)
    {
        ShowCursor(TRUE);
    }
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
    psycm->fMagnify = FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  SetEditCtlFont
//
//  Creates a font for the Edit control that visually matches the handle
//  given, but is guaranteed not to be bigger than the size of the edit
//  control.
//
////////////////////////////////////////////////////////////////////////////

void SetEditCtlFont(
    HWND hwndDlg,
    int idCtl,
    HFONT hfont)
{
    static HFONT hfNew = NULL;
    LOGFONT lfNew;
    HWND hwndCtl = GetDlgItem(hwndDlg, idCtl);
    RECT rc;

    if (hfNew != NULL)
    {
        DeleteObject(hfNew);
    }

    GetWindowRect(hwndCtl, &rc);

    if (GetObject(hfont, sizeof(lfNew), &lfNew) != 0)
    {
        lfNew.lfHeight = rc.bottom - rc.top - 8;
        lfNew.lfWidth  = lfNew.lfEscapement = lfNew.lfOrientation =
        lfNew.lfWeight = 0;

        hfNew = CreateFontIndirect(&lfNew);
    }
    else
    {
        hfNew = hfont;
    }

    SendMessage(hwndCtl, WM_SETFONT, (WPARAM)hfNew, (LPARAM)TRUE);

    if (hfNew == hfont)
    {
        hfNew = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SetSearched
//
////////////////////////////////////////////////////////////////////////////
void SetSearched(void)
{
  fSearched = TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  ComputeExpandedAndShrunkHeight
//  Computes the height of the dialog in expanded and shrunk state
//
////////////////////////////////////////////////////////////////////////////
void ComputeExpandedAndShrunkHeight(HWND hDlg)
{
    RECT rDlg, rButton;

    // Initially dialog is created in expanded state so expanded height is
    // same as current dialog height
    GetWindowRect(hDlg, &rDlg);
    gwExpandedHeight = rDlg.bottom - rDlg.top;

    // Shrunk height of dialog is y position of Advanced checkbox plus
    // height of status line plus some separator
    GetWindowRect(GetDlgItem(hDlg, ID_ADVANCED), &rButton);
    gwNormalHeight = rButton.bottom - rDlg.top + dyStatus
        + GetSystemMetrics(SM_CYFRAME);
}

////////////////////////////////////////////////////////////////////////////
//
//  ShowHideAdvancedControls
//  Toggles ID_ADVANCED checkbox and resizes the dialog accordingly
//
////////////////////////////////////////////////////////////////////////////
int ShowHideAdvancedControls(
                HWND hWnd,
                WPARAM wParam,
                LPARAM lParam)
{
    RECT    rectParent;
    int     iCheckState;

    // Get Current Check State
    iCheckState = (int)SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
        BM_GETCHECK,
        (WPARAM)0L,
        (LPARAM)0L);

    // Toggle fDisplayAdvancedControls
    fDisplayAdvControls = (iCheckState == BST_CHECKED)? FALSE: TRUE;

    SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                 CB_SETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0);

    if(fDisplayAdvControls == FALSE)
    {
        // Since we are going back to a simple window close the list
        // which are already open
         if(ghwndList || ghwndGrid)
         {
             fSearched = TRUE;
             DestroyAllListWindows();
         }

         if(CodePage_GetCurSelCodePage(hWnd,ID_VIEW) != UNICODE_CODEPAGE)
         {
             SendMessage( GetDlgItem(hwndDialog, ID_VIEW),
                          CB_SETCURSEL,
                          (WPARAM) 0,
                          (LPARAM) 0);
             fSearched = TRUE;
         }
    }
    else
    {
         // Getting ready to show advanced controls
         WCHAR buffer[256];

         fSearched  = FALSE;
         fNeedReset = FALSE;

         SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
         LoadString(hInst, IDS_SEARCH, buffer, 255);
         SetDlgItemText(hWnd, ID_SEARCH, buffer);
         EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

         // Initialise and enable SUR controls
         EnableSURControls(hWnd);
    }

    // Change Dialog Size and enable/diable advanced controls
    ResizeDialog(hWnd);

    // Set the status line size
    GetClientRect(hWnd, &rectParent);
    rcStatusLine = rectParent;
    rcStatusLine.top = rcStatusLine.bottom - dyStatus;

    // Toggle ID_ADVANCED check
    SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
        BM_SETCHECK,
        (WPARAM)((fDisplayAdvControls==TRUE)? BST_CHECKED: BST_UNCHECKED),
        (LPARAM)0L
    );

    // Force a paint message
    InvalidateRect(hWnd, NULL, TRUE);

    if(fSearched || fNeedReset)
    {
        SendMessage( hWnd,
                     WM_COMMAND,
                     MAKELONG(ID_VIEW,CBN_SELCHANGE),
                     0L);
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  ResizeDialog - Sets the dialog height to correspond to initial start state
//
////////////////////////////////////////////////////////////////////////////
void ResizeDialog(HWND hWnd)
{
    RECT rDlg;
    int  iDisplay;

    // Get size of dialog
    GetWindowRect(hWnd, &rDlg);

    // Change Dialog Size
    if (fDisplayAdvControls == FALSE)
    {
        MoveWindow(hWnd, rDlg.left, rDlg.top,
            rDlg.right - rDlg.left, gwNormalHeight, TRUE);
        iDisplay = SW_HIDE;
    }
    else
    {
        MoveWindow(hWnd, rDlg.left, rDlg.top, rDlg.right - rDlg.left,
            gwExpandedHeight, TRUE);
        iDisplay = SW_NORMAL;
    }

    // Show or hide controls depending on whether expanded dialog is
    // being shown or normal dialog is shown
    ShowWindow(GetDlgItem(hWnd, ID_VIEWLB), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_VIEW), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SUBSETLB), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCHNAME), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCHINPUT), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCH), iDisplay);

    // All SUR controls
    ShowWindow(GetDlgItem(hWnd, ID_URANGE), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_FROM), iDisplay);
}

////////////////////////////////////////////////////////////////////////////
//
//  DoDragAndDrop - Calls the modal drag and drop proc for CharGrid
//
////////////////////////////////////////////////////////////////////////////
int DoDragAndDrop(HWND hWnd, LPDROPSOURCE pDropSource)
{
    PCImpIDataObject    pDataObject;
    DWORD               dwEffect;
    TCHAR               szCurrSelection[2];

    SetRichEditFont(hwndDialog, ID_STRING, sycm.hFont);
    WCHAR wc = (WCHAR)pCode[sycm.chCurr];
    ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
    //rich edit screws up symbol fonts
    if (gFontType & SYMBOL_FONTTYPE)
    {
      if ((wc >= 0xf000) && (wc <= 0xf0ff))
        wc = (WCHAR) (BYTE)pCode[sycm.chCurr];
    }
    szCurrSelection[0] = wc;
    szCurrSelection[1] = 0;

    // Create an instance of the DataObject
    pDataObject = new CImpIDataObject(hWnd);

    pDataObject->SetText(szCurrSelection);

    // Do drag and drop with copy
    DoDragDrop(pDataObject, pDropSource, DROPEFFECT_COPY, &dwEffect);

    // Free instance of DataObject
    pDataObject->Release();

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  CopyTextToClipboard - Copies text from the rich edit control to clipboard
//
////////////////////////////////////////////////////////////////////////////
static void CopyTextToClipboard(HWND hWndDlg)
{
    DWORD   dwSelStart, dwSelEnd;
    HWND    hWndRichEdit;

#ifndef DISABLE_RICHEDIT
    hWndRichEdit = GetDlgItem(hWndDlg, ID_STRING);
#else
    hWndRichEdit = GetDlgItem(hWndDlg, IDC_EDIT);
#endif

    SendMessage(hWndRichEdit, EM_GETSEL, (WPARAM)&dwSelStart,
        (LPARAM)&dwSelEnd);

    if (dwSelStart == dwSelEnd)
    {
        // There is no text that has been selected currently
        // So select the entire text and copy it to clipboard


        // Temporarily hide selection
        SendMessage(hWndRichEdit, EM_HIDESELECTION, (WPARAM)TRUE, (LPARAM)0);
        // Select entire text
        SendMessage(hWndRichEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        // Copy text to clipboard
        SendMessage(hWndRichEdit, WM_COPY, 0L, 0L);
        // Restore the hidden selection
        SendMessage(hWndRichEdit, EM_SETSEL, (WPARAM)dwSelStart,
            (LPARAM)dwSelEnd);
        SendMessage(hWndRichEdit, EM_HIDESELECTION, (WPARAM)FALSE, (LPARAM)0);
    }
    else
    {
        SendMessage(hWndRichEdit, WM_COPY, 0L, 0L);
    }

}

////////////////////////////////////////////////////////////////////////////
//
//  CompareCharFormats - Compares two CHARFORMATS
//  returns 1 if they are equal
//          0 if not equal
//
////////////////////////////////////////////////////////////////////////////
static int CompareCharFormats(CHARFORMAT* pcf1, CHARFORMAT* pcf2)
{
        /*
    return ( (pcf1->bPitchAndFamily == pcf2->bPitchAndFamily)
        && (lstrcmp(pcf1->szFaceName, pcf2->szFaceName) == 0)
        && (pcf1->bCharSet == pcf2->bCharSet)
        );
        */
  return ((lstrcmp(pcf1->szFaceName, pcf2->szFaceName) == 0));
}

////////////////////////////////////////////////////////////////////////////
//
//  SetRichEditFont - Compares the charformat of the current selection
//  with the charformat for the font in the chargrid. If they are not
//  equal then it sets a new charformat
//
////////////////////////////////////////////////////////////////////////////
static void SetRichEditFont(HWND hWndDlg, int idCtl, HFONT hFont)
{
    CHARFORMAT  cf, cfCurr;
    LOGFONT     lf;
    HWND        hWndRichEdit;
    RECT        rc;
    HDC         hDC;
    int         iLogPixelsYDisplay, iFontDeviceHt;
    DWORD       dwSelStart, dwSelEnd;
    HFONT       hFontEdit, hFontOld;
    TEXTMETRIC  tm;

    hWndRichEdit = GetDlgItem(hWndDlg, idCtl);
    SendMessage(hWndRichEdit, EM_GETRECT, 0, (LPARAM)&rc);
    hDC = GetDC(hWndDlg);

    hWndRichEdit = GetDlgItem(hWndDlg, ID_STRING);

    SendMessage(hWndRichEdit, EM_GETSEL, (WPARAM)&dwSelStart,
        (LPARAM)&dwSelEnd);

    // Font cell height (logical units)
    iFontDeviceHt = rc.bottom - rc.top - 2;

    // Convert font height from logical units to twips for rich edit
    // Return logical units per inch
    iLogPixelsYDisplay = GetDeviceCaps(hDC, LOGPIXELSY);

    // Get the CharFormat of the current selection
    cfCurr.cbSize = sizeof(cfCurr);
    SendMessage(hWndRichEdit, EM_GETCHARFORMAT, TRUE, (LPARAM)&cfCurr);

    // Get the Log font structure from the current font
    if (GetObject(hFont, sizeof(lf), &lf) == 0)
    {
        ReleaseDC(hWndDlg, hDC);
        return;
    }

    // Logical cell height
    lf.lfHeight = iFontDeviceHt;

    cf.bCharSet = (BYTE) GetCurFontCharSet(hWndRichEdit);

    // Fill out the CHARFORMAT structure to get the character effects.
    cf.cbSize = sizeof (cf);
    cf.dwMask = CFM_BOLD | CFM_FACE | CFM_ITALIC |
                    CFM_SIZE | CFM_UNDERLINE | CFM_OFFSET | CFM_CHARSET;
    cf.dwEffects = 0;

    // Set attributes
    if (lf.lfWeight >= FW_BOLD)
        cf.dwEffects |= CFE_BOLD;
    if (lf.lfItalic)
        cf.dwEffects |= CFE_ITALIC;

    if (lf.lfUnderline)
        cf.dwEffects |= CFE_UNDERLINE;

    cf.bPitchAndFamily = lf.lfPitchAndFamily;

    // Figure physical font internal leading

    GetViewableFontDimensions(hDC, iLogPixelsYDisplay, &lf, &hFontOld, &hFontEdit, &tm);


    // rich edit needs character height not cell height.
    // character height = cell height - internal leading
    //
    // logical units * points/inch * twips/point
    // ------------------------------------------
    // logical units / inch
    //
    cf.yHeight = MulDiv(tm.tmHeight - tm.tmInternalLeading, 1440, iLogPixelsYDisplay);

    SelectObject(hDC, hFontOld);
    DeleteObject(hFontEdit);

    cf.yOffset = 0;

    // Set the new typeface, preserving the previous effects.
    wcscpy(cf.szFaceName, lf.lfFaceName);

    if (CompareCharFormats(&cf, &cfCurr) == 0)
        SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    ReleaseDC(hWndDlg, hDC);

}

////////////////////////////////////////////////////////////////////////////
//
//  DoDragScroll - Routine for scrolling the map when the mouse button is
//  down and mouse pointer goes outside the character grid
//
////////////////////////////////////////////////////////////////////////////
int DoDragScroll(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rcClient;
    int     yMousePosn, iyDistance, iScrollTimer;
    DWORD   dwScrollDir;
    POINT   pt;

    // Store the current wParam and lParam so that they can be used for
    // next dragscroll
    prevKeys = wParam;
    ptPrevMouse = lParam;
    POINTSTOPOINT(pt, lParam);

    yMousePosn = pt.y;
    GetClientRect(hWnd, &rcClient);

    // Verify that we are out of the client area if not return
    if ((yMousePosn >= rcClient.top) && (yMousePosn <= rcClient.bottom))
    {
        KillTimer(hWnd, ID_SCROLLTIMER);
        return 0;
    }

    dwScrollDir = (yMousePosn < 0) ? VK_UP : VK_DOWN;

    iyDistance = (yMousePosn < 0) ?
        -yMousePosn : yMousePosn - rcClient.bottom;

    // Thus if iyDistance is less then then the scroll interval will be less
    iScrollTimer = 750 - ((UINT)iyDistance << 4);

    // Min value should be one
    if (iScrollTimer < 1)
        iScrollTimer = 1;

    // Scroll
    SendMessage(hWnd, WM_KEYDOWN, (WPARAM)dwScrollDir, (LPARAM)0L);

    // Set timer for next scroll
    SetTimer(hWnd, ID_SCROLLTIMER, iScrollTimer, NULL);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  FormatHex - Puts leading zeros and converts lower case to upper
//
////////////////////////////////////////////////////////////////////////////
int FormatHex(LPTSTR lpszText, LPTSTR lpszHexText, int nLen)
{
    int nChars, i, j;

    nChars = wcslen(lpszText);

    for (i=0; i<nLen-nChars; i++)
    {
        // Put the leading 0's
        lpszHexText[i] = ZERO;
    }

    for (j=0; j<nChars; j++)
    {
        // Convert all characters to upper
        lpszHexText[i+j] = towupper(lpszText[j]);
    }

    // Null terminate
    lpszHexText[nLen] = 0;

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControl - Initialises the default values for the SUR edit box
//                   with ID nControlId
//
////////////////////////////////////////////////////////////////////////////
int InitSURControl(HWND hWnd, int nControlId)
{
    int     i;
    TCHAR   szValue[256];

    for (i=0; i<sizeof(validData) / sizeof(validData[0]); i++)
    {
        if (validData[i].nControlId == nControlId)
        {
            // Set inital value
            wsprintf(szValue, L"%04X", validData[i].iDefaultValue);
            //SetDlgItemText(hWnd, nControlId, szValue);
            SetDlgItemText(hWnd, nControlId, L"");
        }
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControl - Initialises the default values for the SUR edit box
//                   with ID nControlId
//
////////////////////////////////////////////////////////////////////////////
int GetDefaultValue(int nControlId)
{
    int     i;

    for (i=0; i<sizeof(validData) / sizeof(validData[0]); i++)
    {
        if (validData[i].nControlId == nControlId)
        {
            return (validData[i].iDefaultValue);
        }
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControls - Initialises the default values for all SUR edit boxes
//
////////////////////////////////////////////////////////////////////////////
int InitSURControls(HWND hWnd)
{
    InitSURControl(hWnd, ID_FROM);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  UnicodeRangeChecked - Called when Unicode Range check box is checked
//
////////////////////////////////////////////////////////////////////////////
int UnicodeRangeChecked(HWND hWnd)
{
    if (IsDlgButtonChecked(hWnd, ID_URANGE) == BST_CHECKED)
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), TRUE);
        EnableWindow(GetDlgItem(hWnd, ID_TO), TRUE);
        InitSURControls(hWnd);

        // Show the current range
        SURangeChanged(hWnd);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), FALSE);
        EnableWindow(GetDlgItem(hWnd, ID_TO), FALSE);
        InitSURControls(hWnd);

        // Show the whole unicode range
        SURangeChanged(hWnd);
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  EnableSURControls - Enables or Disables SUR controls depending on
//                      currently selected CodePage and View
//
////////////////////////////////////////////////////////////////////////////
int EnableSURControls(HWND hWnd, BOOL fForceDisable)
{
    LONG    lCodePage;
    int     nIndex;
    BOOL    bEnabled=TRUE;


    if (fForceDisable || !IsWindowEnabled(GetDlgItem(hWnd, ID_VIEW)))
    {
        // Called when controls are to be forcibly disabled
        // irrespective of codepage and subset
        InitSURControls(hWnd);
        EnableWindow(GetDlgItem(hWnd, ID_URANGE), FALSE);
        EnableWindow(GetDlgItem(hWnd, ID_FROM), FALSE);
        iFromPrev = 0x21; iToPrev = 0xFFFD;
        return 0;
    }

    // SUR controls are disabled if Character Set is not Unicode
    // or SearchByGroup is not all
    lCodePage = (LONG)CodePage_GetCurSelCodePage(hWnd, ID_VIEW);

    nIndex = (int)SendDlgItemMessage(hWnd, ID_UNICODESUBSET, CB_GETCURSEL,
        (WPARAM) 0, (LPARAM) 0L);

    if ((lCodePage != UNICODE_CODEPAGE) || (nIndex != 0))
    {
        bEnabled = FALSE;
    }

    EnableWindow(GetDlgItem(hWnd, ID_URANGE), bEnabled);

    if (bEnabled == FALSE)
    {
        // Reset all the SUR controls
        InitSURControls(hWnd);
        EnableWindow(GetDlgItem(hWnd, ID_FROM), bEnabled);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), bEnabled);
        InitSURControls(hWnd);
    }

    // Reset values of iFromPrev and iToPrev
    iFromPrev = 0x21; iToPrev = 0xFFFD;

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  SURangeChanged - Called when contents of one of the SUR edit boxes
//  changes. This proc updates the chargrid if the contents of the edit
//  boxes are valid
//
////////////////////////////////////////////////////////////////////////////
int SURangeChanged(HWND hWnd)
{
    int     iFrom, iTo=0xFFFD, nLen;
    TCHAR   chBuffer[MAX_CHARS+1];
    WCHAR   buffer2[256];

    nLen = GetDlgItemText(hWnd, ID_FROM, chBuffer, MAX_CHARS+1);
    if (nLen != 0)
        swscanf(chBuffer, L"%x", &iFrom);
    else
        iFrom = 0x21;

    // Check limits
    if ((iFrom < 0x0021) || (iFrom > 0xFFFD))
    {
        iFrom = 0x0021;
        //InitSURControl(hWnd, ID_FROM);
    }

    // Check if the from and to values have changed
    if ((iFromPrev == iFrom) && (iToPrev == iTo))
    {
        // No change
        return 0;
    }

    // Selection should be the first one
    ExitMagnify(hwndCharGrid, &sycm);
    sycm.chCurr = 0;

    // Reload the buffer and set min and max range
    SetSpecificSelection(hWnd, iFrom, iTo);

    iFromPrev = iFrom;
    iToPrev = iTo;

    // Since the range has changed enable the reset button
    if (nLen != 0)
    {
        LoadString(hInst, IDS_RESET,  buffer2, 255);
        SetDlgItemText(hWnd, ID_SEARCH, buffer2);
        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
        fNeedReset = FALSE;
        fSearched  = TRUE;
    }
    else
    {
        LoadString(hInst, IDS_SEARCH,  buffer2, 255);
        SetDlgItemText(hWnd, ID_SEARCH, buffer2);
        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
        fNeedReset = FALSE;
        fSearched  = FALSE;
    }

    // Invalidate the charmap
    InvalidateRect(hwndCharGrid, NULL, TRUE);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  ValidateValues - Validates the values in SUR edit boxes. Also formats
//  edit box text in case of valid values
//
////////////////////////////////////////////////////////////////////////////
int ValidateValues(HWND hWnd)
{
    UINT    uCtrlID;
    int     iValue1, iValue2=0xFFFD, iDefault1;
    TCHAR   szText[MAX_CHARS+1],
            szHexText[MAX_CHARS+1];

    // Subset has changed so validate upper and lower limit
    // and redisplay grid
    GetWindowText(hWnd, szText, MAX_CHARS+1);
    swscanf(szText, L"%x", &iValue1);

    uCtrlID = GetDlgCtrlID(hWnd);
    iDefault1 = GetDefaultValue(uCtrlID);

    // This code was for validation of default values
    if (uCtrlID == ID_FROM)
    {
        if ((iValue1 < iDefault1) || (iValue1 > iValue2))
        {
            SURangeChanged(GetParent(hWnd));
            return 0;
        }
    }

    SURangeChanged(GetParent(hWnd));
    FormatHex(szText, szHexText, MAX_CHARS);
    SetWindowText(hWnd, szHexText);

    return 0;
}

static WNDPROC fnEditProc = NULL;

//**********************************************************************
// SetHexEditProc
//
// Purpose:
//      Replaces current Edit window procedure with a new procedure
//      capable of validating hex text
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
static BOOL SetHexEditProc(HWND hWndEdit)
{
    fnEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)HexEditControlProc);

    if (fnEditProc != NULL)
        return TRUE;
    else
        return FALSE;
}


//**********************************************************************
// HexEditControlProc
//
// Purpose:
//      Edit control procedure capable of handling Hex characters
//      Allows 0-9, a-f and converts a-f to A-F
//      Enter or space - cause refresh of grid with characters
//                       starting from text entered in ID_FROM
//      Escape         - if something is present in textbox clear box
//                     - if nothing is present in textbox close app
//
//**********************************************************************
static LRESULT CALLBACK HexEditControlProc(HWND    hWnd,
                                           UINT    uMessage,
                                           WPARAM  wParam,
                                           LPARAM  lParam)
{
    switch(uMessage)
    {
        case WM_GETDLGCODE:
        {
            return (DLGC_WANTALLKEYS);
            break;
        }

        case WM_KEYDOWN:
        {
            int iLen;

            switch (wParam)
            {
                case VK_ESCAPE:
                {
                    iLen = GetWindowTextLength(hWnd);
                    if (iLen)
                    {
                        InitSURControls(GetParent(hWnd));
                        ValidateValues(hWnd);
                    }
                    else
                    {
                        SendMessage(GetParent(hWnd), WM_CLOSE, 0, 0L);
                    }
                    break;
                }

                case VK_F6:
                {

                    SetFocus(hwndCharGrid);
                    return 0L;
                }

                case VK_TAB:
                {
                    PostMessage(GetParent(hWnd), WM_NEXTDLGCTL, 0, 0L);
                    break;
                }
            }

            break;
        }

        case WM_CHAR:
        {
            TCHAR   chCharCode;

            chCharCode = (TCHAR) wParam;

            // The only characters allowed are 0-9, a-f, A-F, ' ' and '\b'
            if ((chCharCode == ' ') || (chCharCode == VK_RETURN))
            {
                fSURChanged = TRUE;
                return ValidateValues(hWnd);
            }
            else
            {
                if (chCharCode == '\b')
                    break;

                // Validate chars
                if ((chCharCode >= '0')&&(chCharCode <= '9')
                    || (chCharCode >= 'A')&&(chCharCode <= 'F')
                    || (chCharCode >= 'a')&&(chCharCode <= 'f')
                    || (chCharCode == '\b'))
                {
                    // Char is ok
                    if ((chCharCode >= 'a')&&(chCharCode <= 'f'))
                        wParam = towupper(chCharCode);
                }
            }

            break;
        }

        case WM_KILLFOCUS:
        {
            ValidateValues(hWnd);
            break;
        }
    }

    return CallWindowProc(fnEditProc, hWnd, uMessage, wParam, lParam);
}

//**********************************************************************
// CreateTooltipWindow
//
// Purpose:  Creates a new tooltip window
//
// Parameters:  hWndParent   -  App Window handle
//
// Return Value:  Window handle of the tooltip window
//**********************************************************************
HWND CreateTooltipWindow(HWND hWndParent)
{
  hwndTT = CreateWindowEx( 0,
      TOOLTIPS_CLASS,
      NULL,
      WS_POPUP | TTS_ALWAYSTIP,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      10,
      10,
      hWndParent,
      NULL,
      hInst,
      NULL);

  if (hwndTT == (HWND) NULL)
    return (HWND) NULL;

  return hwndTT;
}

//**********************************************************************
// ResizeTipsArea
//
// Purpose:  Creates a new tooltip window and sets the rectangles for
//           each tooltip
//
// Parameters:  hWnd         -  App Window handle
//
// Return Value:  None
//**********************************************************************
void ResizeTipsArea(HWND hWndGrid, PSYCM psycm)
{
    TOOLINFO ti;    // tool information
    RECT     rcKey; // tool rectangle
    int      x, y;

    if (hwndTT != NULL)
        DestroyWindow(hwndTT);

    CreateTooltipWindow(hWndGrid);

    for (x=0; x<cchSymCol; x++)
    {
        for (y=0; y<cchSymRow; y++)
        {
             ZeroMemory(&ti, sizeof(ti));
             ti.cbSize   = sizeof(TOOLINFO);
             ti.uFlags   = 0;
             ti.hwnd     = hWndGrid;
             ti.lpszText = LPSTR_TEXTCALLBACK;

             rcKey.left    = (int)(y*psycm->dxpBox);
             rcKey.right   = (int)((y+1)*psycm->dxpBox);
             rcKey.top     = (int)(x*psycm->dypBox);
             rcKey.bottom  = (int)((x+1)*psycm->dypBox);

             ti.rect = rcKey;
             SendMessage(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
//  Paints the font facenames and TT bitmap in the font combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_EUDCFACESIZE];
    HBITMAP hOld;
    INT dy;
    DWORD   FontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LPARAM)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE | ETO_CLIPPED,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        int i;

        if (hbmFont)
        {
            hOld = (HBITMAP) SelectObject(hdcMem, hbmFont);

            i = (int)SendMessage(lpdis->hwndItem, CB_GETITEMDATA, (WPARAM) lpdis->itemID, (LPARAM) 0);

            FontType = Font_pList[i].FontType;
            if (FontType)
            {
                int xSrc;
                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if      (FontType & TRUETYPE_FONT ||
                         FontType & EUDC_FONTTYPE )
                    xSrc = 0;
                else if (FontType & TT_OPENTYPE_FONTTYPE)
                    xSrc = 2;
                else if (FontType & PS_OPENTYPE_FONTTYPE)
                    xSrc = 3;
                else if (FontType & TYPE1_FONTTYPE)
                    xSrc = 4;
                else
                    xSrc = -1;

                if (xSrc != -1)
                BitBlt( hDC,
                        lpdis->rcItem.left,
                        lpdis->rcItem.top + dy,
                        DX_BITMAP,
                        DY_BITMAP,
                        hdcMem,
                        xSrc * DX_BITMAP,
                        lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                        SRCCOPY );
            }
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  Loads DIB bitmaps and "fixes up" their color tables so that we get the
//  desired result for the device we are on.
//
//  This routine requires:
//    - the DIB is a 16 color DIB authored with the standard windows colors
//    - bright blue (00 00 FF) is converted to the background color
//    - light grey  (C0 C0 C0) is replaced with the button face color
//    - dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

HBITMAP LoadBitmaps(
    INT id)
{
    HDC hdc;
    HANDLE h, hRes;
    DWORD *p;
    LPBYTE lpBits;
    LPBITMAPINFOHEADER lpBitmapInfo;
    INT numcolors;
    DWORD rgbSelected, rgbUnselected;
    HBITMAP hbm;

    rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
    //
    //  Flip the colors.
    //
    rgbSelected = RGB( GetBValue(rgbSelected),
                       GetGValue(rgbSelected),
                       GetRValue(rgbSelected) );
    rgbUnselected = GetSysColor(COLOR_WINDOW);
    //
    //  Flip the colors.
    //
    rgbUnselected = RGB( GetBValue(rgbUnselected),
                         GetGValue(rgbUnselected),
                         GetRValue(rgbUnselected) );

    h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(hInst, (HRSRC) h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //

                numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
        p++;
    }
    UnlockResource(hRes);

    //
    //  Now create the DIB.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    //
    //  First skip over the header structure.
    //
    lpBits = (LPBYTE)(lpBitmapInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapInfo,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapInfo,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    GlobalUnlock(hRes);
    FreeResource(hRes);

    return (hbm);
}

static WNDPROC fnSearchEditProc = NULL;

//**********************************************************************
// SetSearchEditProc
//
// Purpose:
//      Replaces current Search Edit box procedure with a new procedure
//      to handle the Enter key
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
static BOOL SetSearchEditProc(HWND hWndEdit)
{
    fnSearchEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)SearchEditControlProc);

    if (fnSearchEditProc != NULL)
        return TRUE;
    else
        return FALSE;
}

//**********************************************************************
// SearchEditControlProc
//
// Purpose:
//      to handle :
//         Enter     - click the search/reset button
//
//**********************************************************************
static LRESULT CALLBACK SearchEditControlProc(HWND    hWnd,
                                              UINT    uMessage,
                                              WPARAM  wParam,
                                              LPARAM  lParam)
{
    if(uMessage == WM_KEYDOWN)
    {
        if(wParam   == VK_RETURN)
            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
        else if(wParam   == VK_F6)
            SetFocus(hwndCharGrid);
    }

    return CallWindowProc(fnSearchEditProc, hWnd, uMessage, wParam, lParam);
}

INT_PTR CALLBACK MsgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
      case ( WM_INITDIALOG ):
      {
        if (gDisplayFontChgMsg)
          SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                      BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0L);
        else
          SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                      BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0L);
        return TRUE;
      }
      case ( WM_COMMAND ) :
      {
        switch (LOWORD(wParam))
        {
          case (IDOK):
            EndDialog(hWnd, IDOK);
            return TRUE;
          case (IDCANCEL):
            EndDialog(hWnd, IDCANCEL);
            return TRUE;
          case (IDC_CHECKNOMSG):
            LRESULT iCheckState;
            iCheckState = SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                                      BM_GETCHECK,(WPARAM)0L,(LPARAM)0L);
            gDisplayFontChgMsg = (iCheckState == BST_CHECKED)? FALSE: TRUE;
            return TRUE;
        }
      }
      case ( WM_SYSCOMMAND):
      {
        switch (wParam)
        {
          case ((WPARAM)SC_CLOSE):
            EndDialog(hWnd, IDCANCEL);
            return TRUE;
        }
        break;
      }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\uce\uce\uce.h ===
/********************************************************************
 *
 *  Header Name : uce.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 *
 ********************************************************************/

#ifndef __UCE_H__
#define __UCE_H__

#include "cmdlg.h"
#include "ucefile.h"

#define BTOC(bytes)      ((bytes) / sizeof(TCHAR))
#define CTOB(cch)        ((cch) * sizeof(TCHAR))
#define UCHAR            unsigned char
#define UTCHAR           unsigned short

#define ASCII_BEG        0x21
#define ASCII_END        0x7F

#define HIANSI_BEG       0x80
#define HIANSI_END       0xFF

#define TRAILBYTE_BEG    0x40
#define TRAILBYTE_END    0xFE

#define DELETE_CHAR      0x7f
#define UNICODE_CODEPAGE 1200

#define cchFullMap       (200)

#define  TWO_BYTE_NUM(p)                           (((p[0])<<8)|(p[1]))
#define FOUR_BYTE_NUM(p) (((p[0])<<24)|((p[1])<<16)|((p[2])<<8)|(p[3]))

// Font types

#define TRUETYPE_FONT         0x00000004
#ifndef PS_OPENTYPE_FONTTYPE
#define PS_OPENTYPE_FONTTYPE  0x00010000
#endif
#ifndef TT_OPENTYPE_FONTTYPE
#define TT_OPENTYPE_FONTTYPE  0x00020000
#endif
#ifndef TYPE1_FONTTYPE
#define TYPE1_FONTTYPE        0x00040000
#endif
#define EUDC_FONTTYPE         0x10000000
#define SYMBOL_FONTTYPE       0x20000000
#define OEM_FONTTYPE          0x40000000
#define DBCS_FONTTYPE         0x80000000

//should be hardcoded but let's lock it during localization.
//we'll hardcode it after Win2K
//#define RTFFMT                TEXT("Rich Text Format")

typedef struct {
  char  TTCTag    [4];
  BYTE  Version   [4];
  BYTE  DirCount  [4];
  BYTE  OffsetTTF1[4];
} TTC_HEAD;

typedef struct {
  BYTE  Version      [4];
  BYTE  NumTables    [2];
  BYTE  SearchRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} TTF_HEAD;

typedef struct {
  char  Tag     [4];
  BYTE  CheckSum[4];
  BYTE  Offset  [4];
  BYTE  Length  [4];
} TABLE_DIR;

typedef struct {
  BYTE  Format[2];
  BYTE  NumRec[2];
  BYTE  Offset[2];
} NAME_TABLE;

#define FONT_SUBFAMILY_NAME 2
#define MICROSOFT_PLATFORM  3
#define UNICODE_INDEXING    1
#define CMAP_FORMAT_FOUR    4

typedef struct {
  BYTE  Platform[2];
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  LangID  [2];
  BYTE  NameID  [2];  // = 2 for font subfamily name
  BYTE  Length  [2];
  BYTE  Offset  [2];
} NAME_RECORD;

typedef struct {
  BYTE  Version  [2];
  BYTE  NumTables[2];
} CMAP_HEAD;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} CMAP_TABLE;

typedef struct {
  BYTE  Format       [2];  // must be 4
  BYTE  Length       [2];
  BYTE  Version      [2];
  BYTE  SegCountX2   [2];
  BYTE  SeachgRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} CMAP_FORMAT;

typedef struct {
  WCHAR wcFrom;
  WCHAR wcTo;
} URANGE;

typedef struct tagSYCM
  {
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;
    INT CPgNum;
    INT ChWidth;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fMagnify;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[256];
  } SYCM;
typedef SYCM *PSYCM;

typedef struct tagITEMDATA
  {
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
  } ITEMDATA;

#define LF_SUBSETSIZE    128
#define LF_CODEPAGESIZE  128
#define LF_EUDCFACESIZE  256 // wingdi defines length of FACESIZE as 32 chars.
                             // charmap attaches string "Private Characters" to
                             // face name. 256 should be long enough to handle
                             // face names. 

typedef struct tagUSUBSET
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
  } USUBSET;

typedef struct tagUCODEPAGE
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_CODEPAGESIZE];
  } UCODEPAGE;

#define MAX_LEN 50

typedef struct _tagFontInfo {
    TCHAR  szFaceName[LF_EUDCFACESIZE];
    BYTE   CharSet;
    DWORD  FontType;
    BYTE   PitchAndFamily;
    URANGE *pUniRange;
    UINT   nNumofUniRange;
} FONTINFO,*LPFONTINFO;

typedef struct tagValidateData {
    int nControlId;
    int iMinValue;
    int iMaxValue;
    int iDefaultValue;
    int iMaxChars;
} ValidateData;

/* Function declarations. */

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, INT);
INT_PTR  APIENTRY UCEDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT  APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK MsgProc(HWND, UINT, WPARAM, LPARAM);
UINT ChFromSymLParam(PSYCM, LPARAM);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcUCE(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR, BOOL fRepaint=FALSE);
VOID RestoreSymMag(HWND, PSYCM);
HANDLE GetEditText(HWND);
INT PointsToHeight(INT);

VOID PaintStatusLine(HDC, BOOL, BOOL);
VOID UpdateKeystrokeText( HDC hdc, UTCHAR chNew, BOOL fRedraw);

INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);

VOID ExitMagnify(HWND, PSYCM);

BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);

VOID UpdateSymbolSelection(HWND, BOOL);

VOID UpdateSymbolRange( HWND hwnd, INT FirstChar, INT LastChar );

VOID SubSetChanged( HWND hwnd);

DWORD GetCurFontCharSet(HWND hWnd);
int ConvertAnsifontToUnicode(HWND hWnd, char* mb, WCHAR* wc); 
int ConvertUnicodeToAnsiFont(HWND hWnd, WCHAR* wc, char* mb); 
VOID ProcessScrollMsg( HWND hwnd, int nCode, int nPos );
INT ScrollMapPage( HWND hwndDlg, BOOL fUp, BOOL fRePaint );
BOOL ScrollMap( HWND hwndDlg, INT cchScroll, BOOL fRePaint );
void SetEditCtlFont( HWND hwndDlg, int idCtl, HFONT hfont );
void GetFonts(void);
LONG WCharCP(UINT CodePage, WCHAR *lpWC);
URANGE* EUDC_Range(TCHAR* Path, DWORD* pSize);
void UnicodeBar(void);
int ShowHideAdvancedControls(HWND hWnd, WPARAM wParam, LPARAM lParam);
void ComputeExpandedAndShrunkHeight(HWND hDlg);
void ResizeDialog(HWND hWnd);

void CopyTextToClipboard(HWND hWndDlg);
void SetRichEditFont(HWND hwndDlg, int idCtl, HFONT hFont);
int DoDragScroll(HWND hWnd, WPARAM wParam, LPARAM lParam);
int UnicodeRangeChecked(HWND hWnd);
int EnableSURControls(HWND hWnd, BOOL fForceDisable=FALSE);
int SURangeChanged(HWND hWnd);
static BOOL SetHexEditProc(HWND hWndEdit);
static LRESULT CALLBACK HexEditControlProc(HWND hWnd,UINT uMessage, WPARAM  wParam, LPARAM  lParam);
static BOOL SetSearchEditProc(HWND hWndEdit);
static LRESULT CALLBACK SearchEditControlProc(HWND hWnd,UINT uMessage, WPARAM  wParam, LPARAM  lParam);
int ValidateValues(HWND hWnd);
void ResizeTipsArea(HWND hWndGrid, PSYCM psycm);

extern HINSTANCE hInst;
extern HWND hwndDialog;
extern HWND hwndCharGrid;

extern HWND ghwndList;
extern HWND ghwndGrid;
extern BOOL fDisplayAdvControls;
extern LPWSTR pCode;
extern SYCM   sycm;
extern int    nDragDelay, nDragMinDist;
extern FONTINFO *Font_pList;


#define M64K 65536


BOOL CodePage_InitList();
BOOL CodePage_DeleteList();
BOOL CodePage_AddToList(LONG);
BOOL CodePage_FillToComboBox(HWND ,UINT);
LONG CodePage_GetCurSelCodePage(HWND,UINT);
LONG CodePage_GetCurCodePageVal();
BOOL CodePage_SetCurrent( LONG  , HWND  , UINT  );
BOOL IsCodePageOnList( WORD );

BOOL Display_DeleteList();
BOOL Display_InitList();
LPWSTR Display_CreateDispBuffer(LPWSTR,INT,URANGE *,INT,BOOL);
LPWSTR Display_CreateSubsetDispBuffer(LPWSTR,INT,URANGE *,INT,BOOL,int,int);

BOOL Subset_FillComboBox( HWND hWnd , UINT uID );
BOOL Subset_GetUnicodeCharsToDisplay(HWND,UINT,LONG,LPWSTR *,UINT *,BOOL *);
BOOL GetUnicodeBufferOfCodePage( LONG , PWSTR *, UINT *) ;
BOOL Subset_GetUnicode( HWND, PUCE_MEMORY_FILE , PWSTR * , UINT *, BOOL *);
BOOL GetUnicodeCharsFromList( HWND , PUCE_MEMORY_FILE , PWSTR , UINT * , BOOL *);
BOOL Subset_OnSelChange( HWND hWnd , UINT uID ) ;

BOOL Font_InitList(HWND hWnd);
BOOL Font_DeleteList();
BOOL Font_AddToList(LPLOGFONT,DWORD,URANGE *,INT);
BOOL Font_FillToComboBox(HWND ,UINT);
BYTE Font_GetSelFontCharSet(HWND,UINT,INT);
BOOL Font_SelectByCharSet(HWND,UINT,UINT);
BOOL Font_GetCharWidth32(HDC ,UINT ,UINT ,LPINT, LPWSTR);
BOOL Font_GetCurCMapTable(HWND,UINT,URANGE **,UINT*);
BOOL Font_Avail(UINT);
UINT Font_DBCS_CharSet();
UINT CharSetToCodePage(BYTE cs);
DWORD URanges(UINT CodePage, URANGE *pUR);


// Grid & List Window

HWND CreateListWindow( HWND  , PWSTR  );
void CreateResources( HINSTANCE, HWND );
void DeleteResources( void );
LRESULT CALLBACK ListWndProc( HWND , UINT , WPARAM  , LPARAM );
LRESULT CALLBACK GridWndProc( HWND , UINT , WPARAM  , LPARAM );
void FillGroupsInListBox( HWND , PUCE_MEMORY_FILE ) ;
void DestroyListWindow( void );
void DestroyGridWindow( void );
void DestroyAllListWindows( void ) ;
BOOL IsListWindow( PUCE_MEMORY_FILE );
HWND CreateGridWindow( HWND hwndParent , UINT uID , PUCE_MEMORY_FILE pUceMemFile );
void GetWindowGridSize( PUCE_MEMORY_FILE  , POINT * , INT * , INT * );
BOOL GridHScroll( HWND  , UINT  , WPARAM  , LPARAM  );
BOOL GridVScroll( HWND  , UINT  , WPARAM  , LPARAM  );
void DrawGridCell( HDC  , RECT * , BOOL  , WCHAR  , BOOL );
void DoPaint( HWND  , HDC  );
__inline BOOL GetCurrentRect( RECT * );
__inline void GetCurrentGroupChar( PWSTR );
__inline BOOL GridSamePointHit( POINT );
BOOL GetUnicodeCharsFromGridWindow( HWND , PWSTR  , UINT * , BOOL *);
BOOL IsGridWindowAlive( void );
BOOL CreateNewGridFont( HWND  , UINT  );
BOOL CreateNewListFont( HWND  , UINT  );
BOOL UpdateGridFont( HWND  , UINT  );
BOOL UpdateListFont( HWND  , UINT  );
BOOL IsAnyListWindow( void );
void GetWChars( INT  , WCHAR * , WCHAR * , UINT * , BOOL *);
__inline BOOL IsCellEnabled( INT  , INT  );

INT  LoadCurrentSelection(HWND, UINT, LPTSTR, LPTSTR);
BOOL SaveCurrentSelection(HWND, UINT, LPTSTR);
VOID GetSystemPathName(PWSTR ,PWSTR ,UINT );
INT  LoadAdvancedSelection(HWND, UINT, LPTSTR);
BOOL SaveAdvancedSelection(HWND, UINT,LPTSTR);

BOOL LoadNeedMessage();
void SaveNeedMessage(BOOL nMsg);

void SetSearched(void);

#define SZ_CODEPAGE         TEXT("CodePage")
#define SZ_CODEPAGE_DEFAULT TEXT("1200")
#define SZ_SUBSET           TEXT("Subset")
#define SZ_SUBSET_DEFAULT   TEXT("All")         // cannot be macro ???
#define SZ_SUBFUNC          TEXT("SubFunc")
#define SZ_SUBFUNC_DEFAULT  TEXT("0")           // cannot be macro ???
#define SZ_FONT             TEXT("Font")
#define SZ_FONT_DEFAULT     TEXT("Arial")       // cannot be macro ???
#define SZ_ADVANCED         TEXT("Advanced")

#define ID_SUBFUNCCHANGED   501

// If debug functionality is needed turn to 1
//#define DBG 0

#ifdef _DEBUG
#define TRACE    OutputDebugString

#else // _DEBUG

#define TRACE    NOP_FUNCTION

#endif // _DEBUG
#endif  // __UCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ucharmap\charmap.c ===
/****************************************************************************

    PROGRAM: CharMap

    PURPOSE: Utility providing users an easy interface for selecting special
             characters.

    COMMENTS:
        Created by MikeSch (7-16-91)
        Partially derived from WinWord 2.0 Insert.Symbol dialog.

****************************************************************************/

#define WIN31
#include "windows.h"
#include <port1632.h>
#include "charmap.h"
#include "stdlib.h"
#include "tchar.h"
#ifdef UNICODE
#include "wchar.h"
#else
#include "stdio.h"
#endif
#include "commctrl.h"

/*
 * Macros
 */
#define FMagData(psycm) ((psycm)->xpMagCurr != 0)
#define abs(x) (((x) >= 0) ? (x) : (-(x)))

/*
 * Useful constants.
 */
#define STATUSPOINTSIZE          8      // Point size of status bar font.
#define DX_BITMAP               20      // Width of TT bitmap.
#define DY_BITMAP               12      // Height of TT bitmap.
#define BACKGROUND      0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright purple
#define BUTTONFACE      0x00C0C0C0      // bright grey
#define BUTTONSHADOW    0x00808080      // dark grey

// Font types
#define PS_OPENTYPE_FONT    0x0001
#define TT_OPENTYPE_FONT    0x0002
#define TRUETYPE_FONT       0x0004
#define TYPE1_FONT          0x0008

/*
 * Globals.
 */
HANDLE hInst;
INT cchSymRow = 32;          // Number of characters across the character grid.
INT cchSymCol = 8;           // Number of rows in the character grid.
UTCHAR chSymFirst = 32;
UTCHAR chSymLast  = 255;
SYCM sycm;                   // Tons of data need to do char grid painting.
UINT wCFRichText = 0;        // Private clipboard format, rich text format.
HFONT hFontClipboard = NULL; // Tells us which font is in the clipboard.
HANDLE hstrClipboard = NULL; // Contains the string which is in the clipboard.
BOOL fDelClipboardFont = FALSE; // The clipboard font needs to be deleted.
INT iControl = ID_CHARGRID;  // Index indicating which control has focus.
HBITMAP hbmFont = NULL;      // TT bitmap drawn before font facenames in combo.
LONG lEditSel = 0;           // Contains the selection range of the EC.
HBRUSH hStaticBrush;         // Used for static controls during WM_CTLCOLOR

//
// 04 Dec 92 - GregoryW
//    Currently there is no defined
//    interface for querying what character ranges a Unicode font
//    supports.  For now this table only has the subsets that contain
//    characters supported by the Lucida Sans Unicode font uncommented.
//    When we get an API that allows querying the font driver for
//    ranges of Unicode characters supported (and whether or not a font
//    is a Unicode font!) then all entries can be uncommented.
//
USUBSET aSubsetData[] = {{ 0x0020, 0x00ff, IDS_LATIN1},
                       { 0x0100, 0x017f, IDS_LATINEXA},
                       { 0x0180, 0x024f, IDS_LATINEXB},
                       { 0x0250, 0x02af, IDS_IPAEX},
                       { 0x02b0, 0x02ff, IDS_SPACINGMODIFIERS},
                       { 0x0300, 0x036f, IDS_COMBININGDIACRITICS},
                       { 0x0370, 0x03cf, IDS_BASICGREEK},
                       { 0x03d0, 0x03ff, IDS_GREEKSYMBOLS},
                       { 0x0400, 0x04ff, IDS_CYRILLIC},
// not supported       { 0x0530, 0x058f, IDS_ARMENIAN},
                       { 0x0590, 0x05ff, IDS_HEBREW},
// not supported       { 0x0600, 0x0652, IDS_BASICARABIC},
// not supported       { 0x0653, 0x06ff, IDS_ARABICEX},
// not supported       { 0x0900, 0x097f, IDS_DEVANAGARI},
// not supported       { 0x0980, 0x09ff, IDS_BENGALI},
// not supported       { 0x0a00, 0x0a7f, IDS_GURMUKHI},
// not supported       { 0x0a80, 0x0aff, IDS_GUJARATI},
// not supported       { 0x0b00, 0x0b7f, IDS_ORIYA},
// not supported       { 0x0b80, 0x0bff, IDS_TAMIL},
// not supported       { 0x0c00, 0x0c7f, IDS_TELUGU},
// not supported       { 0x0c80, 0x0cff, IDS_KANNADA},
// not supported       { 0x0d00, 0x0d7f, IDS_MALAYALAM},
// not supported       { 0x0e00, 0x0e7f, IDS_THAI},
// not supported       { 0x0e80, 0x0eff, IDS_LAO},
// not supported       { 0x10d0, 0x10ff, IDS_BASICGEORGIAN},
// not supported       { 0x10a0, 0x10cf, IDS_GEORGIANEX},
// not supported       { 0x1100, 0x11ff, IDS_HANGULJAMO},
// not supported       { 0x1e00, 0x1eff, IDS_LATINEXADDITIONAL},
// not supported       { 0x1f00, 0x1fff, IDS_GREEKEX},
// not supported       { 0x2000, 0x206f, IDS_GENERALPUNCTUATION},
// not supported       { 0x2070, 0x209f, IDS_SUPERANDSUBSCRIPTS},
                       { 0x20a0, 0x20cf, IDS_CURRENCYSYMBOLS},
// not supported       { 0x20d0, 0x20ff, IDS_COMBININGDIACRITICSFORSYMBOLS},
                       { 0x2100, 0x214f, IDS_LETTERLIKESYMBOLS},
// not supported       { 0x2150, 0x218f, IDS_NUMBERFORMS},
                       { 0x2190, 0x21ff, IDS_ARROWS},
                       { 0x2200, 0x22ff, IDS_MATHEMATICALOPS},
// not supported       { 0x2300, 0x23ff, IDS_MISCTECHNICAL},
// not supported       { 0x2400, 0x243f, IDS_CONTROLPICTURES},
// not supported       { 0x2440, 0x245f, IDS_OPTICALCHAR},
// not supported       { 0x2460, 0x24ff, IDS_ENCLOSEDALPHANUM},
// not supported       { 0x2500, 0x257f, IDS_BOXDRAWING},
// not supported       { 0x2580, 0x259f, IDS_BLOCKELEMENTS},
// not supported       { 0x25a0, 0x25ff, IDS_GEOMETRICSHAPES},
// not supported       { 0x2600, 0x26ff, IDS_MISCDINGBATS},
// not supported       { 0x2700, 0x27bf, IDS_DINGBATS},
// not supported       { 0x3000, 0x303f, IDS_CJKSYMBOLSANDPUNC},
// not supported       { 0x3040, 0x309f, IDS_HIRAGANA},
// not supported       { 0x30a0, 0x30ff, IDS_KATAKANA},
// not supported       { 0x3100, 0x312f, IDS_BOPOMOFO},
// not supported       { 0x3130, 0x318f, IDS_HANGULCOMPATIBILITYJAMO},
// not supported       { 0x3190, 0x319f, IDS_CJKMISC},
// not supported       { 0x3200, 0x32ff, IDS_ENCLOSEDCJKLETTERSANDMONTHS},
// not supported       { 0x3300, 0x33ff, IDS_CJKCOMPATIBILITY},
// not supported       { 0x3400, 0x3d2d, IDS_HANGUL},
// not supported       { 0x3d2e, 0x44b7, IDS_HANGULSUPPA},
// not supported       { 0x44b8, 0x4dff, IDS_HANGULSUPPB},
// not supported       { 0x4e00, 0x9fff, IDS_CJKUNIFIEDIDEOGRAPHS},
// not supported       { 0xe000, 0xf8ff, IDS_PRIVATEUSEAREA},
// not supported       { 0xf900, 0xfaff, IDS_CJKCOMPATIBILITYIDEOGRAPHS},
// not supported       { 0xfb00, 0xfb4f, IDS_ALPAHPRESENTATIONFORMS},
// not supported       { 0xfb50, 0xfdff, IDS_ARABICPRESENTATIONFORMSA},
// not supported       { 0xfe30, 0xfe4f, IDS_CJKCOMPFORMS},
// not supported       { 0xfe50, 0xfe6f, IDS_SMALLFORMVARIANTS},
// not supported       { 0xfe70, 0xfefe, IDS_ARABICPRESENTATIONFORMSB},
// not supported       { 0xff00, 0xffef, IDS_HALFANDFULLWIDTHFORMS},
// not supported       { 0xfff0, 0xfffd, IDS_SPECIALS}
                       };
INT cSubsets = sizeof(aSubsetData) / sizeof(USUBSET);
INT iCurSubset = 0;    // index of current Unicode subset - default to Latin-1

// Useful window handles.
HWND hwndDialog;
HWND hwndCharGrid;

// Data used to draw the status bar.
RECT rcStatusLine;                        // Bounding rect for status bar.
RECT rcToolbar[2];                        // Bounding rects for toolbars.
INT dyStatus;                             // Height of status bar.
INT dyToolbar[2];                         // Height of tool bars.
INT dxHelpField;                          // Width of help window.
INT dxKeystrokeField;                     // Width of keystroke window.
TCHAR szKeystrokeText[30];                // Buffer for keystroke text.
TCHAR szKeystrokeLabel[30];               // Buffer for keystroke label.
TCHAR szSpace[15];                        // Strings for keystroke description.
TCHAR szCtrl[15];
TCHAR szCtrlAlt[25];
TCHAR szShiftCtrlAlt[25];
TCHAR szAlt[15];
TCHAR szUnicodeLabel[23];                 // Buffer for Unicode label.
INT iKeystrokeTextStart;                  // Place to start appending text to above.
INT iUnicodeLabelStart;                   // Place to start appending text to above.
HFONT hfontStatus;                        // Font used for text of status bar.

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop, cleanup.

    COMMENTS:

****************************************************************************/

INT PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
            return (FALSE);

    InitCommonControls();

    // Perform initialization for this instance.
    if (!InitInstance(hInstance, nCmdShow)) {
        return (FALSE);
    }

    while (GetMessage(&msg,
            NULL,
            0,
            0))
    {
        // Filter for possible tabs now to implement context sensitive help.
        if (msg.message == WM_KEYDOWN)
            if (!UpdateHelpText(&msg, NULL))
                continue;

        // Main message loop.
        if (!IsDialogMessage(hwndDialog, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Free up some stuff.
    if (hfontStatus)
        DeleteObject(hfontStatus);
    if (hbmFont)
        DeleteObject(hbmFont);

    return (int)(msg.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

    COMMENTS:

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    /*
     * Register a window class that we will use to draw the character grid
     * into.
     */
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
        return (FALSE);

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_CHARMAP));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    if (!RegisterClass(&wc))
        return (FALSE);

    return TRUE;
}

/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Does some initialization and creates main window which is a
              dialog.

    COMMENTS:

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    INT i;

    // Save the instance handle in a global variable.
    hInst = hInstance;

    // This font will be used to paint the status line.
    hfontStatus = CreateFont(-PointsToHeight(STATUSPOINTSIZE), 0, 0, 0, 400, 0, 0, 0,
                     ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                     DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, TEXT("Helv"));
    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);
    dyToolbar[0] = 28;  /* defined by UI gods */
    dyToolbar[1] = 28;  /* defined by UI gods */

    // Load the Unicode subset names before initializing the main window.
    for (i = 0; i < cSubsets; i++) {
        if (!LoadString(
             hInst,
             aSubsetData[i].StringResId,
             (LPTSTR)aSubsetData[i].Name,
             50)
             )
            return (FALSE);
    }

    // Create a main window for this application instance.
    if (!(hwndDialog = CreateDialog(hInstance, TEXT("CharMap"), NULL,
                              CharMapDlgProc)))
        return (FALSE);

    /*
     * Initialize some strings used for the Keystroke status bar field.
     */
    // For international purposes, this string could be length 0.
    LoadString(
        hInst,
        IDS_KEYSTROKE,
        (LPTSTR)szKeystrokeLabel,
        BTOC(sizeof(szKeystrokeLabel))
        );
    if (!LoadString(
             hInst,
             IDS_UNICODELABEL,
             (LPTSTR)szUnicodeLabel,
             BTOC(sizeof(szUnicodeLabel))
             ))
    if (!LoadString(
             hInst,
             IDS_SPACE,
             (LPTSTR)szSpace,
             BTOC(sizeof(szSpace))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_CTRL,
             (LPTSTR)szCtrl,
             BTOC(sizeof(szCtrl))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_CTRLALT,
             (LPTSTR)szCtrlAlt,
             BTOC(sizeof(szCtrlAlt))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_SHIFTCTRLALT,
             (LPTSTR)szShiftCtrlAlt,
             BTOC(sizeof(szShiftCtrlAlt))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_ALT,
             (LPTSTR)szAlt,
             BTOC(sizeof(szAlt))
             ))
        return (FALSE);

    // Store the index to where we start adding status line text changes.
    iKeystrokeTextStart = lstrlen(szKeystrokeLabel);
    iUnicodeLabelStart = lstrlen(szUnicodeLabel);

    /*
     * Initialize keystroke text, make the window visible,
     * update its client area, and return "success".
     */
    UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);
    return (TRUE);

}

/****************************************************************************

    FUNCTION: CharMapDlgProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages for the main window.

    COMMENTS: This window is a dialog box.

****************************************************************************/

INT_PTR  APIENTRY CharMapDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message) {
        case WM_CTLCOLORSTATIC:
            {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return((INT_PTR)hStaticBrush);
            break;
            }

        case WM_INITDIALOG:
            {
            RECT rectParent, rectTopRightControl;
            INT iSubset;

            /*
             * Create the character grid with dimensions which just fit inside
             * the space allowed in the dialog.  When it processes the
             * WM_CREATE message it will be sized and centered more accurately.
             */
            GetClientRect(hWnd, &rectParent);
            GetWindowRect(GetDlgItem(hWnd, ID_CLOSE), &rectTopRightControl);
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.right));

            if (!(hwndCharGrid =
                CreateWindow(
                    TEXT("CharGridWClass"),
                    NULL,
                    WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                    1,
                    rectParent.top + dyToolbar[0] + dyToolbar[1],
                    rectParent.right - 1,
                    rectParent.bottom - rectParent.top - dyStatus - dyToolbar[0] - dyToolbar[1] - 1,
                    hWnd,
                    (HMENU) ID_CHARGRID,
                    hInst,
                    NULL
                    ))) {
                DestroyWindow(hWnd);
                break;
            }

            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            // Initialize the status line data.
            dxHelpField = 22 * rectParent.right / 32;
            dxKeystrokeField = 8 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            // Initialize the toolbars
            rcToolbar[0] = rectParent;
            rcToolbar[0].bottom = rcToolbar[0].top + dyToolbar[0];

            rcToolbar[1] = rcToolbar[0];
            rcToolbar[1].top = rcToolbar[0].bottom + GetSystemMetrics(SM_CYBORDER);
            rcToolbar[1].bottom = rcToolbar[1].top + dyToolbar[1];

            // Disable Copy button.
            EnableWindow(GetDlgItem(hWnd, ID_COPY), FALSE);

            /* fill "Subset" list box */
            for (iSubset = 0; iSubset < cSubsets; iSubset++) {
                SendDlgItemMessage(
                    hWnd,
                    ID_UNICODESUBSET,
                    CB_ADDSTRING,
                    0,
                    (LPARAM)aSubsetData[iSubset].Name
                    );

            }
            iCurSubset = SelectInitialSubset(hWnd);

            }

            /* fall through to WM_FONTCHANGE */
        case WM_FONTCHANGE:
            {
            HDC hdc = GetDC(hWnd);

            /*
             * Get the fonts from the system and put them in the font selection
             * combo box.
             */
            if (message == WM_FONTCHANGE) {
                SaveCurrentFont(hWnd);
                SendDlgItemMessage(hWnd, ID_FONT, CB_RESETCONTENT, 0, 0L);
            }

            EnumFontFamilies(hdc, NULL, (FONTENUMPROC)FontLoadProc, (LPARAM)hWnd);

            ReleaseDC(hWnd, hdc);

            // Setup character dimensions and select this font.
            RecalcCharMap(hWnd, &sycm, SelectInitialFont(hWnd),
                          (message == WM_FONTCHANGE));
            SendDlgItemMessage(hWnd, ID_STRING, WM_SETFONT,
                               (WPARAM)sycm.hFont, (DWORD)TRUE);

            if (message == WM_INITDIALOG)
                SetFocus(hwndCharGrid);
                /* fall through to WM_SYSCOLORCHANGE */
            else
                break;
            }

        case WM_SYSCOLORCHANGE:
            if (hbmFont)
                DeleteObject(hbmFont);
            hbmFont = LoadBitmaps(IDBM_TT);
            DeleteObject(hStaticBrush);
            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;

        case WM_PARENTNOTIFY:
            {
            POINTS points;
            DWORD dwMsgPos;
            POINT point;

            /*
             * We process this message to implement the context sensitive
             * help.  Downclicks to controls are found here, the help
             * message is updated in the status bar.
             */
            // BUG - The parameters with this message are unreliable!
            if (wParam == WM_LBUTTONDOWN) {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
                UpdateHelpText(NULL, WindowFromPoint(point));
            }

            }
            break;


    case WM_PAINT:

            {
            HBRUSH hBrush;
            RECT rcTemp, rectNextButton;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            /*
             * This code implements painting of the status bar.
             */
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            // Make the whole thing grey.
              if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) {
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp.left = rcToolbar[0].left;
                rcTemp.top = rcToolbar[0].top;
                rcTemp.right = rcToolbar[1].right;
                rcTemp.bottom = rcToolbar[1].bottom;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
              }

              GetWindowRect(GetDlgItem(hWnd, ID_TOPLEFT), &rectNextButton);
              ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.left));
              ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.right));
              // solid black line across bottom of toolbar
              if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) {
                rcTemp = rcToolbar[0];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp = rcToolbar[1];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // vertical line
                rcTemp.top = rcToolbar[0].top;
                rcTemp.bottom = rcToolbar[1].bottom;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                rcTemp.right = rectNextButton.left - 2;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
              }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

                // Status line top.
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line top.
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                // Status line left side.
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line left side.
                rcTemp.left = rcStatusLine.right - 9 * dyBorder - dxKeystrokeField;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

                // Status line bottom.
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line bottom.
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                // Status line right side.
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder + dxHelpField;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line right side.
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            // solid black line across top

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) {
            rcTemp = rcStatusLine;
            rcTemp.bottom = rcTemp.top;
            rcTemp.top -= dyBorder;
            FillRect(hdc, &rcTemp, hBrush);
            DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);

            return (TRUE);
            }

        case WM_MEASUREITEM:
            {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
                hFont = SelectObject(hDC, hFont);
            GetTextMetrics(hDC, &tm);
            if (hFont)
                SelectObject(hDC, hFont);
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = max(tm.tmHeight, DY_BITMAP);
            break;
            }

        case WM_DRAWITEM:
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);

            break;

        case WM_ASKCBFORMATNAME:
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, (UINT)wParam);

            return (TRUE);

        case WM_PAINTCLIPBOARD:
            {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard) {
                // Setup.
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                // Lets paint.
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText,
                        lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                // Cleanup.
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }

            return (TRUE);
            }

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return (TRUE);

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                case ID_CLOSE:
                    DestroyWindow(hWnd);
                    return (TRUE);
                    break;

                case ID_SELECT:
                    SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR,
                                       (WPARAM)sycm.chCurr, 0L);
                    break;

                case ID_COPY:
                    CopyString(hWnd);
                    return (TRUE);
                    break;

                case ID_FONT:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        RecalcCharMap(hWnd, &sycm,
                                      (INT)SendDlgItemMessage(hWnd, ID_FONT,
                                                              CB_GETCURSEL, 0, 0L),
                                      TRUE);
                        SendDlgItemMessage(hWnd, ID_STRING, WM_SETFONT,
                                           (WPARAM)sycm.hFont, (DWORD)TRUE);
                    } else if (HIWORD(wParam) == CBN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the CB.
                        UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                    break;

                case ID_UNICODESUBSET:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        INT iSubset;

                        iSubset = (INT)SendDlgItemMessage(
                                          hWnd,
                                          ID_UNICODESUBSET,
                                          CB_GETCURSEL,
                                          0, 0);
                        UpdateSymbolSelection(
                            hWnd,
                            aSubsetData[iSubset].BeginRange,
                            aSubsetData[iSubset].EndRange
                            );
                        InvalidateRect(hwndCharGrid, NULL, TRUE);
                    } else if (HIWORD(wParam) == CBN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the CB.
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    return 0;
                    break;

                case ID_NEXTSUBSET:
                    {
                        INT iCurSelection, iNumEntries;

                        iCurSelection = (INT)SendDlgItemMessage(
                                                 hWnd,
                                                 ID_UNICODESUBSET,
                                                 CB_GETCURSEL,
                                                 0, 0);
                        if (iCurSelection == CB_ERR) {
                             return 0;
                        }
                        iNumEntries = (INT)SendDlgItemMessage(
                                               hWnd,
                                               ID_UNICODESUBSET,
                                               CB_GETCOUNT,
                                               0, 0);
                        if (iNumEntries == CB_ERR) {
                             return 0;
                        }
                        if (iCurSelection++ < (iNumEntries - 1)) {
                            if (iCurSelection == 1) {
                                // Enable Previous button
                                EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), TRUE);
                            }

                            SendDlgItemMessage(
                                hWnd,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iCurSelection, 0);
                            UpdateSymbolSelection(
                                hWnd,
                                aSubsetData[iCurSelection].BeginRange,
                                aSubsetData[iCurSelection].EndRange
                                );
                            InvalidateRect(hwndCharGrid, NULL, TRUE);
                            if (iCurSelection == (iNumEntries - 1)) {
                                HWND hwndButton;

                                EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), FALSE);
                                //
                                // Only reset the button style and focus if
                                // the "Next" button currently has it.
                                //
                                if (iControl == ID_NEXTSUBSET) {
                                    SendDlgItemMessage(hwndDialog, ID_PREVSUBSET,
                                         BM_SETSTYLE, BS_DEFPUSHBUTTON, 1);
                                    SendDlgItemMessage(hwndDialog, ID_NEXTSUBSET,
                                        BM_SETSTYLE, BS_PUSHBUTTON, 1);
                                    hwndButton = GetDlgItem(hWnd, ID_PREVSUBSET);
                                    SetFocus(hwndButton);
                                    UpdateHelpText(NULL, hwndButton);
                                }
                            }
                        }

                    }
                    return 0;
                    break;

                case ID_PREVSUBSET:
                    {
                        INT iCurSelection;

                        iCurSelection = (INT)SendDlgItemMessage(
                                          hWnd,
                                          ID_UNICODESUBSET,
                                          CB_GETCURSEL,
                                          0, 0);
                        if (iCurSelection == CB_ERR) {
                             return 0;
                        }
                        if (iCurSelection > 0) {
                            iCurSelection--;

                            if (iCurSelection == (cSubsets - 2)) {
                                // Enable Next button
                                EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), TRUE);
                            }

                            SendDlgItemMessage(
                                hWnd,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iCurSelection, 0);
                            UpdateSymbolSelection(
                                hWnd,
                                aSubsetData[iCurSelection].BeginRange,
                                aSubsetData[iCurSelection].EndRange
                                );
                            InvalidateRect(hwndCharGrid, NULL, TRUE);
                            if (iCurSelection == 0) {
                                HWND hwndButton;

                                EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), FALSE);
                                //
                                // Only reset the button style and focus if
                                // the "Previous" button currently has it.
                                //
                                if (iControl == ID_PREVSUBSET) {
                                    SendDlgItemMessage(hwndDialog, ID_NEXTSUBSET,
                                         BM_SETSTYLE, BS_DEFPUSHBUTTON, 1);
                                    SendDlgItemMessage(hwndDialog, ID_PREVSUBSET,
                                         BM_SETSTYLE, BS_PUSHBUTTON, 1);
                                    hwndButton = GetDlgItem(hWnd, ID_NEXTSUBSET);
                                    SetFocus(hwndButton);
                                    UpdateHelpText(NULL, hwndButton);
                                }
                            }
                        }
                    }
                    return 0;
                    break;

                case ID_STRING:
                    if (HIWORD(wParam) == EN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the EC.
                        UpdateHelpText(NULL, (HWND)lParam);
                    } else if (HIWORD(wParam) == EN_CHANGE) {
                        // Disable Copy button if there are no chars in EC.
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }

                    break;

                case ID_HELP:
                    DoHelp(hWnd, TRUE);
                    break;
            }
            break;

        case WM_DESTROY:
            SaveCurrentFont(hWnd);
            SaveCurrentSubset(hWnd);
            DoHelp(hWnd, FALSE);
            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;

        case WM_ACTIVATEAPP:
            if (wParam) {
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, LOWORD(lEditSel), HIWORD(lEditSel));
            } else {
                lEditSel = (LONG)SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
            break;


    }
    return (FALSE);
}



/****************************************************************************

    FUNCTION: CharGridWndProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages for the character grid window.

    COMMENTS:

****************************************************************************/

LRESULT  APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (message) {
        case WM_CREATE:
                {
                RECT rect;
                HDC hdcScrn;
                POINT point1, point2;

                // Setup global.
                hwndCharGrid = hWnd;

                GetClientRect(hWnd, &rect);

                /*
                 * Calculate metrics for the character grid and the
                 * magnify window.
                 */
                sycm.dxpBox = (rect.right-1)  / (cchSymRow + 1);
                sycm.dypBox = (rect.bottom-2) / (cchSymCol + 1);
                sycm.dxpCM  = sycm.dxpBox * cchSymRow+1;
                sycm.dypCM  = sycm.dypBox * cchSymCol+1;        // space inside for border

                sycm.dxpMag = sycm.dxpBox * 2 + 4;      // twice the size + 2 bit border
                sycm.dypMag = sycm.dypBox * 2 + 4;

                sycm.chCurr   = chSymFirst;
                sycm.hFontMag = NULL;
                sycm.hFont    = NULL;
                sycm.hdcMag   = NULL;
                sycm.hbmMag   = NULL;
                sycm.ypDest   = 0;

                sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;

                // Size the window precisely so the grid fits and is centered.
                MoveWindow(hWnd, (rect.right - sycm.dxpCM + 1) / 2,
                                 (rect.bottom - sycm.dypCM + 1) / 2 + ((LPCREATESTRUCT)lParam)->y - 2,
                                 sycm.dxpCM + 2,
                                 sycm.dypCM + 2,
                                 FALSE);

                /*
                 * Figure out what the offsets are between the dialog
                 * and the character grid window.
                 */
                point1.x = point1.y = point2.x = point2.y = 0;
                ClientToScreen(hWnd, &point1);
                ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
                sycm.xpCM = (point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
                sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;


                // Create dc and bitmap for the magnify window.
                if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
                        {
                        if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                                {
                                SetTextColor(sycm.hdcMag,
                                             GetSysColor(COLOR_WINDOWTEXT));
                                SetBkColor(sycm.hdcMag,
                                           GetSysColor(COLOR_WINDOW));
                                SetBkMode(sycm.hdcMag, OPAQUE);
                                if ((sycm.hbmMag = CreateCompatibleBitmap(hdcScrn,
                                         sycm.dxpMag, sycm.dypMag*2)) == NULL)
                                        {
                                        DeleteObject(sycm.hdcMag);
                                        }
                                else
                                        {
                                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                                        }
                                }
                        ReleaseDC(hWnd, hdcScrn);
                        }
                }
            break;

        case WM_DESTROY:
            if (sycm.fMouseDn)
                ExitMagnify(hWnd, &sycm);
            if (fDelClipboardFont)
                DeleteObject(hFontClipboard);
            if (sycm.hFont != NULL)
                DeleteObject(sycm.hFont);
            if (sycm.hFontMag != NULL)
                DeleteObject(sycm.hFontMag);
            if (sycm.hdcMag != NULL)
                DeleteDC(sycm.hdcMag);
            if (sycm.hbmMag != NULL)
                DeleteObject(sycm.hbmMag);
            break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            RestoreSymMag(&sycm);
            DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, TRUE, message == WM_SETFOCUS);
            break;

        case WM_LBUTTONDOWN:
            {
            RECT rect;

            // Don't draw anything if there's an update region pending.
            if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
                break;

            SetFocus(hWnd);
            SetCapture(hWnd);

            sycm.fMouseDn = TRUE;

            if (!FMagData(&sycm))
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

            }

            // Fall through to WM_MOUSEMOVE

        case WM_MOUSEMOVE:
            if (sycm.fMouseDn) {
               POINT pt;
               UTCHAR chMouseSymbol;

               pt.x = LOWORD(lParam);
               pt.y = HIWORD(lParam);
                ClientToScreen(hWnd, (LPPOINT)&pt);
                if (WindowFromPoint(pt) == hWnd) {
                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    // convert back to a 'points'-like thing
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);
                    chMouseSymbol = (UTCHAR)ChFromSymLParam(&sycm, lParam);
                    if (chMouseSymbol > chSymLast) {
                        //
                        // We're outside of current character range (but still
                        // within the grid).  Restore cursor and leave
                        // magnified character.
                        //
                        if (sycm.fCursorOff) {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    } else {
                        //
                        // We're in the grid and within the range of currently
                        // displayed characters, display magnified character.
                        //
                        if (!sycm.fCursorOff) {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        MoveSymbolSel(&sycm, chMouseSymbol);
                    }
                } else {
                    // Left grid, leave magnified character and restore cursor.
                    if (sycm.fCursorOff) {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }
                }
            }
            break;

        case WM_CANCELMODE:
        case WM_LBUTTONUP:
            if (sycm.fMouseDn)
                ExitMagnify(hWnd, &sycm);

            break;

        case WM_LBUTTONDBLCLK:
            // Send this character to the entry field.
            SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR,
                               (WPARAM)sycm.chCurr, 0L);
            break;

        case WM_GETDLGCODE:
            // Necessary to obtain arrow and tab messages.
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;

        case WM_KEYDOWN:
                {
                UTCHAR chNew = sycm.chCurr;

                if (sycm.fMouseDn)
                    break;

                switch (wParam)
                        {
                case VK_LEFT:
                        if (--chNew < chSymFirst)
                                return 0L;
                        break;

                case VK_UP:
                        if ((chNew -= (UTCHAR)cchSymRow) < chSymFirst)
                                return 0L;
                        break;

                case VK_RIGHT:
                        if (++chNew > chSymLast)
                                return 0L;
                        break;

                case VK_DOWN:
                        if ((chNew += (UTCHAR)cchSymRow) > chSymLast)
                                return 0L;
                        break;

                default:
                                return 0L;
                        }       /* switch (wParam) */

                if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                MoveSymbolSel(&sycm, (UTCHAR)chNew);
                }
                break;

        case WM_CHAR:
                if (sycm.fMouseDn)
                    break;

                if (wParam >= chSymFirst  &&  wParam <= chSymLast) {
                    if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                    MoveSymbolSel(&sycm, (UTCHAR) wParam);
                    SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR,
                                       (WPARAM)sycm.chCurr, 0L);
                }
                break;

        case WM_PAINT:
            {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hWnd, &ps);
            DrawSymbolMap(&sycm, hdc);
            EndPaint(hWnd, &ps);
                return (TRUE);
            }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0L;
}

/****************************************************************************

    FUNCTION: ChFromSymLParam(PSYCM, LPARAM)

    PURPOSE:  Determine the character to select from the mouse
              position (lParam)

    COMMENTS:

****************************************************************************/

INT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
        return min(cchSymRow-1, max(0, ((INT) LOWORD(lParam)-1) / psycm->dxpBox))
                 + min(cchSymCol-1, max(0, ((INT) HIWORD(lParam)-1) / psycm->dypBox))
                        * cchSymRow + chSymFirst;
}


/****************************************************************************

    FUNCTION: DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);

    PURPOSE:  Gets a DC for hwnd, calls DrawSymChOutline.

    COMMENTS:

****************************************************************************/

VOID DrawSymChOutlineHwnd(
    PSYCM   psycm,
    HWND    hwnd,
    UTCHAR   ch,
    BOOL    fVisible,
    BOOL    fFocus)
{
        HDC hdc = GetDC(hwnd);
        DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
        ReleaseDC(hwnd, hdc);
}

/****************************************************************************

    FUNCTION: RecalcCharMap(HWND, PSYCM, int, BOOL);

    PURPOSE:  Recalculate fixed character map data (font info, sizes, etc.)

    COMMENTS:

****************************************************************************/

VOID RecalcCharMap(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
        HDC          hdc;
        TEXTMETRIC   tm;
        UINT         ch;
        LPINT        lpdxp;
        HFONT        hFont;
        LOGFONT      LogFont;

        // Get rid of the old font handles.
        if (hFontClipboard && hFontClipboard == psycm->hFont)
            fDelClipboardFont = TRUE;
        if (psycm->hFont && hFontClipboard != psycm->hFont)
            DeleteObject(psycm->hFont);
        if (psycm->hFontMag)
            DeleteObject(psycm->hFontMag);

        hdc = GetDC(hwndCharGrid);

        /*
         * Set up the LogFont structure.
         */
        // Make sure it fits in the grid.
        LogFont.lfHeight = psycm->dypBox - 3; // Allow for whitespace.
        // Set these guys to zero.
        LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                          LogFont.lfWeight = 0;
        // Set these at zero too.
        LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
            LogFont.lfOutPrecision = LogFont.lfClipPrecision =
            LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;
        // Let the facename and size define the font.
        LogFont.lfCharSet = ANSI_CHARSET;
        // Get the facename from the combo box.
        SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETLBTEXT, iCombo,
                           (LPARAM)(LPTSTR)LogFont.lfFaceName);

        /*
         * 27 Oct 92   GregoryW
         *   For now we don't have a way to determine if this is a
         *   Unicode font or an ANSI font.  The best we can do is
         *   look at the face name to see if it is the one Unicode
         *   font we recognize.
         */
        if (!lstrcmpi(LogFont.lfFaceName, TEXT("Lucida Sans Unicode"))) {
            LONG iCurSel;

            psycm->fAnsiFont = FALSE;
            // Enable Block listbox and set defaults appropriately.
            EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), TRUE);
            iCurSel = (LONG)SendDlgItemMessage(
                          hwndDlg,
                          ID_UNICODESUBSET,
                          CB_GETCURSEL,
                          0,
                          0L
                          );
            UpdateSymbolSelection(
                hwndDlg,
                aSubsetData[iCurSel].BeginRange,
                aSubsetData[iCurSel].EndRange
                );
            // Enable Previous button if not on first subset.
            if (iCurSel > 0) {
                EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), TRUE);
            } else {
                EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
            }
            // Enable Next button if not on last subset.
            if (iCurSel < (cSubsets - 1)) {
                EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), TRUE);
            } else {
                EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
            }
        } else {
            // put back the ANSI defaults and disable Unicode Block listbox
            psycm->fAnsiFont = TRUE;
            UpdateSymbolSelection(hwndDlg, 32, 255);
            EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
        }

        // Create the font.
        psycm->hFont = CreateFontIndirect(&LogFont);
        hFont = SelectObject(hdc, psycm->hFont);

        // Create the magnify font.
        LogFont.lfHeight = psycm->dypMag - 5;  // Allow for whitespace.
        psycm->hFontMag = CreateFontIndirect(&LogFont);

        /*
         * Calculate new values and place in window data structure.
         */
        GetTextMetrics(hdc, &tm);
        psycm->xpCh = 2;
        psycm->ypCh = (4 + psycm->dypBox - tm.tmHeight) / 2;

        lpdxp = (LPINT) psycm->rgdxp;

        GetCharWidth(hdc, chSymFirst, chSymLast, lpdxp);

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
                {
                    *lpdxp = (psycm->dxpBox - *lpdxp) / 2 - 1;
                }
        ReleaseDC(hwndCharGrid, hdc);

        psycm->xpMagCurr = 0;   // No magnification data

        if (fRedraw)
            InvalidateRect(hwndCharGrid, NULL, TRUE);
}

/****************************************************************************

    FUNCTION: DrawSymbolMap(PSYCM, HDC);

    PURPOSE:  Draw all of the pieces of the symbol character map

    COMMENTS:

****************************************************************************/

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC     hdc)
{
        BOOL fFocus;

        DrawSymbolGrid(psycm, hdc);
        DrawSymbolChars(psycm, hdc);
        /*
         * We need to force the focus rect to paint if we have the focus
         * since the old focus rect has been drawn over already.
         */
        if (fFocus = psycm->fFocusState)
            psycm->fFocusState = FALSE;
        DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
}


void MoveTo(HDC hdc, int x, int y){

   MoveToEx(hdc, x, y, NULL);
}

/****************************************************************************

    FUNCTION: DrawSymbolGrid(PSYCM, HDC);

    PURPOSE:  Draw the symbol character map grid.

    COMMENTS:

****************************************************************************/

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)
{
        INT    cli;             /* Count of lines */
        INT    xp, yp;
        INT    dxpBox  = psycm->dxpBox;
        INT    dypBox  = psycm->dypBox;
        HPEN   hpenOld;

        hpenOld = SelectObject(hdc, CreatePen(PS_SOLID, 1,
                                              GetSysColor(COLOR_WINDOWFRAME)));

        // Draw horizontal lines.
        xp = psycm->dxpCM + 1;
        yp = 1;
        cli = cchSymCol+1;
        while (cli--)
                {
                MoveTo(hdc, 1, yp);
                LineTo(hdc, xp, yp);
                yp += dypBox;
                }

        // Draw vertical lines.
        yp = psycm->dypCM;
        xp = 1;
        cli = cchSymRow+1;
        while (cli--)
                {
                MoveTo(hdc, xp, 1);
                LineTo(hdc, xp, yp);
                xp += dxpBox;
                }

        DeleteObject(SelectObject(hdc, hpenOld));
}

/****************************************************************************

    FUNCTION: DrawSymbolChars(PSYCM, HDC);

    PURPOSE:  Draw the symbol character map.

    COMMENTS:

****************************************************************************/

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC     hdc)
{
        INT    dxpBox  = psycm->dxpBox;
        INT    dypBox  = psycm->dypBox;

        INT    cch;
        INT    x, y;
        INT    yp;
        TCHAR   ch;

        HFONT  hFontOld;

        RECT   rect;
        LPRECT lprect = (LPRECT) &rect;
        LPINT lpdxp;

        // Setup the font and colors.
        hFontOld = (HFONT) SelectObject(hdc, psycm->hFont);
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetBkMode(hdc, OPAQUE);

        // Draw characters.
        cch = 1;
        ch = chSymFirst;

        lpdxp = (LPINT) psycm->rgdxp;

        rect.top = 2;
        yp = psycm->ypCh;
        rect.bottom = rect.top + dypBox - 1;

        for (y = 0; y++ < cchSymCol;)
                {
                rect.left  = psycm->xpCh;
                rect.right = rect.left + dxpBox - 1;
                for (x = 0; x++ < cchSymRow && ch <= chSymLast;)
                        {
                        if (psycm->fAnsiFont) {
                            ExtTextOutA(hdc, rect.left + (*lpdxp++), yp,
                                ETO_OPAQUE | ETO_CLIPPED, lprect, &(CHAR)ch, 1, NULL);
                        } else
                            ExtTextOutW(hdc, rect.left + (*lpdxp++), yp,
                                ETO_OPAQUE | ETO_CLIPPED, lprect, &ch, 1, NULL);
                        ch++;
                        rect.left  += dxpBox;
                        rect.right += dxpBox;
                        }
                yp += dypBox;
                rect.top += dypBox;
                rect.bottom += dypBox;
                }

        SelectObject(hdc, hFontOld);
}

/****************************************************************************

    FUNCTION: DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);

    PURPOSE:  Draw an outline around the symbol in the character map

    COMMENTS: If fVisible, draw outline else erase it.

****************************************************************************/

VOID DrawSymChOutline(
    PSYCM   psycm,
    HDC     hdc,
    UTCHAR   ch,
    BOOL    fVisible,
    BOOL    fFocus)
{
        HBRUSH hbrOld;
        RECT rc;
        INT dxpBox = psycm->dxpBox;
        INT dypBox = psycm->dypBox;

        hbrOld = SelectObject(hdc,
                              CreateSolidBrush(GetSysColor(fVisible ?
                                                           COLOR_WINDOWFRAME :
                                                           COLOR_WINDOW)));
        ch -= chSymFirst;

        rc.left   = (ch % cchSymRow) * dxpBox +2;
        rc.right  = rc.left + dxpBox -1;
        rc.top    = (ch / cchSymRow) * dypBox +2;
        rc.bottom = rc.top  + dypBox -1;

        // Draw selection rectangle.
        PatBlt( hdc, rc.left,    rc.top-2,    dxpBox-1, 1, PATCOPY);
        PatBlt( hdc, rc.left,    rc.bottom+1, dxpBox-1, 1, PATCOPY);
        PatBlt( hdc, rc.left-2,  rc.top,      1, dypBox-1, PATCOPY);
        PatBlt( hdc, rc.right+1, rc.top,      1, dypBox-1, PATCOPY);

        DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

        // Deal with the focus rectangle.
        if (fFocus != psycm->fFocusState) {
            DrawFocusRect(hdc, &rc);
            psycm->fFocusState = fFocus;
        }

        SelectObject(hdc, hbrOld);
}


/****************************************************************************

    FUNCTION: MoveSymbolSel(PSYCM, UTCHAR);

    PURPOSE:  Change the current symbol selection.  Handles drawing of
              magnified characters.

    COMMENTS:

****************************************************************************/

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew)
{
        HDC    hdc;
        HDC    hdcMag  = psycm->hdcMag;
        RECT   rc;
        HFONT  hFontOld;
        HFONT  hFontMag;        // old font in memory dc
        HPEN   hpenOld;

        UTCHAR chNorm = chNew - chSymFirst + 32;
        INT dxpMag = psycm->dxpMag;     // for quick reference
        INT dypMag = psycm->dypMag;
        INT ypMemSrc  = psycm->ypDest;
        INT ypMemDest = ypMemSrc ^ dypMag;
        INT xpCurr  = psycm->xpMagCurr;
        INT ypCurr  = psycm->ypMagCurr;
        INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
        INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
        INT dxpCh;      // width of extra character space (used to center char in box)
        INT dypCh;

        if (((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)))
                return;

        /*
         * Don't draw a magnified character if the char grid has an update
         * region or is not visible.
         */
        if (!IsWindowVisible(hwndCharGrid) || GetUpdateRect(hwndCharGrid, &rc, FALSE))
            return;

        hdc = GetDC(hwndDialog);

        // Setup the magnified font character.
        hFontMag = SelectObject(hdcMag, psycm->hFontMag);
        { SIZE sz;
          GetTextExtentPoint(hdcMag, &chNew, 1, &sz);

          dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
          dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
        }
        hpenOld = SelectObject(hdc, CreatePen(PS_SOLID, 1,
                                              GetSysColor(COLOR_WINDOWFRAME)));
        hFontOld = SelectObject(hdc, psycm->hFontMag);

        // Copy screen data to offscreen bitmap.
        BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

        // Setup DC.
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetBkMode(hdc, OPAQUE);

        if (FMagData(psycm))
                {
                INT xpT  = xpNew - xpCurr;              // point of overlap in offscreen data
                INT ypT  = ypNew - ypCurr;
                INT dxpT = dxpMag - abs(xpT);   // size of overlap
                INT dypT = dypMag - abs(ypT);

                if ((dxpT > 0) && (dypT > 0))
                        {
                        INT xpTmax,  ypTmax;   // max(0, xpT);
                        INT xpTmin,  ypTmin;   // min(0, xpT);
                        INT xpTnmin, ypTnmin;  // min(0, -xpT);

                        if (xpT < 0)
                                {
                                xpTnmin = - (xpTmin = xpT);
                                xpTmax  = 0;
                                }
                        else
                                {
                                xpTmax  = xpT;
                                xpTnmin = xpTmin = 0;
                                }
                        if (ypT < 0)
                                {
                                ypTnmin = - (ypTmin = ypT);
                                ypTmax  = 0;
                                }
                        else
                                {
                                ypTmax  = ypT;
                                ypTnmin = ypTmin = 0;
                                }

                        rc.left  = xpTmax;
                        rc.right = xpTmin + dxpMag;
                        rc.top   = ypTmax + ypMemSrc;
                        rc.bottom= ypTmin + dypMag + ypMemSrc;

                        // Copy overlapping offscreen data.
                        BitBlt(hdcMag, xpTnmin, ypTnmin + ypMemDest, dxpT, dypT,
                                   hdcMag, xpTmax,  ypTmax  + ypMemSrc, SRCCOPY);

                        // Print part of char over old screen data.
                        if (psycm->fAnsiFont) {
                            ExtTextOutA(hdcMag, xpT + dxpCh, ypT + dypCh + ypMemSrc,
                                ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &(CHAR)chNew, 1, NULL);
                        } else
                            ExtTextOutW(hdcMag, xpT + dxpCh, ypT + dypCh + ypMemSrc,
                                ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &chNew, 1, NULL);

                        }

                // Restore old screen data.
                BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);

                }

        rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
        rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;


        // The rectangle.
        MoveTo(hdc, rc.left, rc.top);
        LineTo(hdc, rc.left, rc.bottom - 1);
        LineTo(hdc, rc.right - 1, rc.bottom - 1);
        LineTo(hdc, rc.right - 1, rc.top);
        LineTo(hdc, rc.left, rc.top);

        // The shadow.
        MoveTo(hdc, rc.right, rc.top + 1);
        LineTo(hdc, rc.right, rc.bottom);
        LineTo(hdc, rc.left, rc.bottom);
        MoveTo(hdc, rc.right + 1, rc.top + 2);
        LineTo(hdc, rc.right + 1, rc.bottom + 1);
        LineTo(hdc, rc.left + 1, rc.bottom + 1);

        rc.left++;
        rc.top++;
        rc.right--;
        rc.bottom--;

        // Draw magnified character on screen.
        if (psycm->fAnsiFont) {
            ExtTextOutA(hdc, xpNew + dxpCh, ypNew + dypCh,
                   ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &(CHAR)chNew, 1, NULL);
        } else
            ExtTextOutW(hdc, xpNew + dxpCh, ypNew + dypCh,
                   ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &chNew, 1, NULL);

        psycm->ypDest = ypMemDest;

        DeleteObject(SelectObject(hdc, hpenOld));
        SelectObject(hdc, hFontOld);
        SelectObject(hdcMag, hFontMag);

        UpdateKeystrokeText(hdc, chNew, TRUE);

        ReleaseDC(hwndDialog, hdc);

        psycm->chCurr = chNew;
}

/****************************************************************************

    FUNCTION: RestoreSymMag(PSYCM);

    PURPOSE:  Restore the screen data under the magnifier.

    COMMENTS:

****************************************************************************/

VOID RestoreSymMag(
    PSYCM psycm)
{

        if (FMagData(psycm))
                {
                HDC hdc = GetDC(hwndDialog);

                BitBlt(hdc, psycm->xpMagCurr, psycm->ypMagCurr,
                        psycm->dxpMag, psycm->dypMag,
                        psycm->hdcMag, 0, psycm->ypDest, SRCCOPY);

                ReleaseDC(hwndDialog, hdc);

                psycm->xpMagCurr = 0;   // flag - no data offscreen (see FMagData)
                }
}


/****************************************************************************

    FUNCTION: FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, short, LPTSTR);

    PURPOSE:  Used by EnumFonts to load our combo box with all the fonts
              installed in the system.

    COMMENTS:

****************************************************************************/

INT  APIENTRY FontLoadProc(LPLOGFONT lpLogFont,
                           NEWTEXTMETRICEX* lpTextMetric,
                           DWORD nFontType,
                           LPARAM lpData)
{
    INT iPos;
    TCHAR szFace[LF_FACESIZE];

    // Check for duplicates.
    iPos = (INT)SendDlgItemMessage((HWND)lpData, ID_FONT, CB_FINDSTRING, (WPARAM)-1,
                                  (LPARAM)&lpLogFont->lfFaceName);

    if (iPos == CB_ERR) {
NotInListYet:
        // Doesn't exist, insert the facename into the combo box.
        iPos = (INT)SendDlgItemMessage((HWND)lpData, ID_FONT,
                                       CB_ADDSTRING, 0,
                                       (LPARAM)&lpLogFont->lfFaceName);
    } else {

        // make sure it is not just a substring (want a full match)
        SendDlgItemMessage((HWND)lpData, ID_FONT, CB_GETLBTEXT, iPos, (LPARAM)(LPTSTR)szFace);
        if (lstrcmpi(szFace, lpLogFont->lfFaceName))
            goto NotInListYet;

        // Already exists, blow out now if this is not a true type font.
        if (!(nFontType & TRUETYPE_FONTTYPE))
            return (1);
    }

    /*
     * Store the pertinant font information in the combo item data.
     */
    if ((iPos != CB_ERR) && (iPos != CB_ERRSPACE)) {
        ITEMDATA ItemData;
        DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
        SHORT   sFontType = 0;

        if (ntmFlags & NTM_PS_OPENTYPE)
        {
            sFontType = PS_OPENTYPE_FONT;
        }
        else if (ntmFlags & NTM_TYPE1)
        {
            sFontType = TYPE1_FONT;
        }
        else if (nFontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
            {
                sFontType = TT_OPENTYPE_FONT;
            }
            else
                sFontType = TRUETYPE_FONT;
        }

        ItemData.FontType = sFontType;
        ItemData.CharSet = lpLogFont->lfCharSet;
        ItemData.PitchAndFamily = lpLogFont->lfPitchAndFamily;

        SendDlgItemMessage((HWND)lpData, ID_FONT, CB_SETITEMDATA, iPos,
                           *(DWORD *)&ItemData);
    }

    // Continue enumeration.
    return (1);
}

/****************************************************************************

    FUNCTION: GetEditText(HWND);

    PURPOSE:  Returns HANDLE containing the text in the edit control.

    COMMENTS: Caller is responsible for freeing this handle!

****************************************************************************/

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    LRESULT dwSel;

    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);

    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    lpstrText = (LPTSTR)GlobalLock(hmem);

    cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);

    dwSel = SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);

    if (LOWORD(dwSel) != HIWORD(dwSel)) {
        // If there is a selection, then only get the selected text.
        *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
        lstrcpy(lpstrText, lpstrText + LOWORD(dwSel));
    }

    GlobalUnlock(hmem);

    if (cchText == 0)
        hmem = GlobalFree(hmem);

    return (hmem);
}

/****************************************************************************

    FUNCTION: CopyString(HWND);

    PURPOSE:  Implement the Copy function.

    COMMENTS:

****************************************************************************/

VOID CopyString(
    HWND hwndDlg)
{
    HANDLE hmem;
    LPTSTR lpstrText;

    if (hmem = GetEditText(hwndDlg)) {
        lpstrText = (LPTSTR)GlobalLock(hmem);

        // Copying string to clipboard.
        if (OpenClipboard(hwndDlg)) {
            EmptyClipboard();
            SendRTFToClip(hwndDlg, lpstrText);
#ifdef UNICODE
            SetClipboardData(CF_UNICODETEXT, hmem);
#else
            SetClipboardData(CF_TEXT, hmem);
#endif
            CloseClipboard();
        } else {
            // If we couldn't open the clipboard, then we need to free memory.
            GlobalUnlock(hmem);
            GlobalFree(hmem);
        }
    }
}

/****************************************************************************

    FUNCTION: SendRTFToClip(HWND, LPTSTR);

    PURPOSE:  Put the string in the clipboard using Rich Text Format.

    COMMENTS: Assumes that the clipboard has already been opened.

****************************************************************************/

VOID SendRTFToClip(
    HWND hwndDlg,
    LPTSTR lpstrText)
{
    INT iCurr