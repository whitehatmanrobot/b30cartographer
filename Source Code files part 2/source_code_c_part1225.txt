P2_IndexedTriangleFan_MS_32IND;  
                break;                        
        }        
    }

    // Call our rendering function
    if (pRenderFunc)
    {
        // As mentioned above, the actual range of indices seen by the driver
        // doesn't necessarily lie within the range zero to one less than
        // the number of vertices in the vertex buffer due to BaseVertexOffset.
        // If BaseVertexOffset is positive the range of valid indices is
        // smaller than the size of the vertex buffer (the vertices that
        // lie in the vertex buffer before the BaseVertexOffset are not
        // considered). Furthermore, if BaseVertexOffset a valid index can
        // actually by greater than the number of vertices in the vertex
        // buffer.
        //
        // To assist with the validation performed by the rendering functions
        // we here compute a minimum and maximum index which take into
        // account the value of BaseVertexOffset. Thus a test for a valid
        // index becomes:
        //
        // ((BaseIndexOffset + StartIndexOffset + Index) >= 0) &&
        // ((BaseIndexOffset + StartIndexOffset + Index) <  VertexCount)

        BaseIndexOffset = (BaseVertexOffset / (int)pContext->dwVerticesStride);

        DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP2 BaseIndexOffset = %d",
            BaseIndexOffset));

        (*pRenderFunc)(pContext,
                       PrimitiveCount,
                       (LPBYTE)lpIndices,
                       (LPD3DTLVERTEX)lpVertices,
                       BaseIndexOffset,
                       pContext->dwNumVertices,
                       &bError);     
    }
    
    DBG_EXIT(_D3D_OP_MStream_DrawIndxP2, 0);
} // _D3D_OP_MStream_DrawIndxP2



//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_ClipTriFan
//
// This function processes the D3DDP2OP_CLIPPEDTRIANGLEFAN DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_ClipTriFan(    
    P3_D3DCONTEXT* pContext, 
    DWORD FirstVertexOffset,
    DWORD dwEdgeFlags,
    DWORD PrimitiveCount)
{   
    BOOL bError;
    
    DBG_ENTRY(_D3D_OP_MStream_ClipTriFan);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_ClipTriFan "
               "FirstVertexOffset=%d dwEdgeFlags=0x%x PrimitiveCount=%d", 
               FirstVertexOffset, dwEdgeFlags, PrimitiveCount));

    if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
    {
        D3DHAL_DP2TRIANGLEFAN_IMM dp2TriFanWire;

        if (!__OP_ValidateStreams(pContext, FALSE))
        {
            DBG_EXIT(_D3D_OP_MStream_ClipTriFan, 0);
            return;
        }

        dp2TriFanWire.dwEdgeFlags = dwEdgeFlags;

        _D3D_R3_DP2_TriangleFanImm(pContext,
                                   (WORD)PrimitiveCount,
                                   (LPBYTE)&dp2TriFanWire,
                                   (LPD3DTLVERTEX)pContext->lpVertices,
                                   pContext->dwNumVertices,
                                   &bError);
        
        
    }
    else
    {
       _D3D_OP_MStream_DrawPrim2(pContext, 
                                 D3DPT_TRIANGLEFAN,
                                 FirstVertexOffset,
                                 PrimitiveCount);
    }
    
    DBG_EXIT(_D3D_OP_MStream_ClipTriFan, 0);
} // _D3D_OP_MStream_ClipTriFan

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawRectSurface
//
// This function processes the D3DDP2OP_DRAWRECTSURFACE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID _D3D_OP_MStream_DrawRectSurface(P3_D3DCONTEXT* pContext, 
                                     DWORD Handle,
                                     DWORD Flags,
                                     PVOID lpPrim)
{
    // High order surfaces are only supported for hw/drivers with
    // TnL support and 1.0 vertex shader support
    
} // _D3D_OP_MStream_DrawRectSurface

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawTriSurface
//
// This function processes the D3DDP2OP_DRAWTRISURFACE DP2 command token.
//
//-----------------------------------------------------------------------------                                     
VOID _D3D_OP_MStream_DrawTriSurface(P3_D3DCONTEXT* pContext, 
                                    DWORD Handle,
                                    DWORD Flags,
                                    PVOID lpPrim)
{
    // High order surfaces are only supported for hw/drivers with
    // TnL support and 1.0 vertex shader support

} // _D3D_OP_MStream_DrawTriSurface

#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_OP_Viewport
//
// This function processes the D3DDP2OP_VIEWPORTINFO DP2 command token.
//
//-----------------------------------------------------------------------------                                     

VOID _D3D_OP_Viewport(P3_D3DCONTEXT* pContext,
                      D3DHAL_DP2VIEWPORTINFO* lpvp)
{
#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode )
    {
         _D3D_SB_Record_Viewport(pContext, lpvp);
    }
    else
#endif // DX7_D3DSTATEBLOCKS    
    {
        pContext->ViewportInfo = *lpvp;
        DIRTY_VIEWPORT(pContext);
    }
} // _D3D_OP_Viewport

//-----------------------------------------------------------------------------
//
// _D3D_OP_ZRange
//
// This function processes the D3DDP2OP_ZRANGE DP2 command token.
//
//-----------------------------------------------------------------------------

VOID _D3D_OP_ZRange(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2ZRANGE* lpzr)
{
#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode )
    {
        _D3D_SB_Record_ZRange(pContext, lpzr);
    }
    else
#endif // DX7_D3DSTATEBLOCKS    
    {
        pContext->ZRange = *lpzr;
        DIRTY_VIEWPORT(pContext);
    }
} // _D3D_OP_ZRange

//-----------------------------------------------------------------------------
//
// _D3D_OP_UpdatePalette
//
// This function processes the D3DDP2OP_UPDATEPALETTE DP2 command token.
//
//      Note : This function is need to skip D3DDP2OP_UPDATEPALETTE sent down 
//             by some DX6 apps, even if when PALETTE TEXTURE is not supported
//             Also notice that for legacy DX apps, the palette doesn't get
//             properly restored in another app transitions into full screen
//             mode and back. This is because the (legacy) runtimes don't
//             sent proper notification (through UpdatePalette/SetPalette) of
//             this event
//
//-----------------------------------------------------------------------------

HRESULT _D3D_OP_UpdatePalette(P3_D3DCONTEXT* pContext,
                              D3DHAL_DP2UPDATEPALETTE* pUpdatePalette,
                              DWORD* pdwPalEntries)
{
#if DX7_PALETTETEXTURE
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    P3_SURF_INTERNAL* pTexture;

    // Find internal palette pointer from handle
    pPalette = GetPaletteFromHandle(pContext,
                                    pUpdatePalette->dwPaletteHandle);

    // Palette doesn't exist
    if (! pPalette) 
    {
        DISPDBG((WRNLVL, "_D3D_OP_UpdatePalette : Can't find palette"));
        return DDERR_INVALIDPARAMS;
    }

    // Check the range of palette entries
    if (pUpdatePalette->wStartIndex > LUT_ENTRIES)
    {
        DISPDBG((WRNLVL, 
                 "_D3D_OP_UpdatePalette : wStartIndex (%d) is bigger than 256", 
                 pUpdatePalette->wStartIndex));
        return DDERR_INVALIDPARAMS;
    }
    if ((pUpdatePalette->wStartIndex + pUpdatePalette->wNumEntries) 
                                                            > LUT_ENTRIES) 
    {
        DISPDBG((WRNLVL, "_D3D_OP_UpdatePalette : too many entries"));
        return DDERR_INVALIDPARAMS;
    }

    // Each palette is ARGB 8:8:8:8
    memcpy(((LPBYTE)(pPalette + 1)) + pUpdatePalette->wStartIndex*sizeof(DWORD),
           pdwPalEntries,
           pUpdatePalette->wNumEntries*sizeof(DWORD));

    // Check if the palette is in use
    // Palette Texture can not be used alone in the 2nd stage, so only the
    // 1st stage must be checked.
    if (pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP])
    {
        pTexture = GetSurfaceFromHandle(pContext,
                                        pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP]);
        if (pTexture)
        {
            if ((pTexture->pFormatSurface->DeviceFormat == SURF_CI8) &&
                (pTexture->dwPaletteHandle == pUpdatePalette->dwPaletteHandle))
            {
                DIRTY_TEXTURE(pContext);
            }
        }
    }
 
    return DD_OK;
#else
    return DD_OK;
#endif // DX7_PALETTETEXTURE
} // D3D_OP_UpdatePalette

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetPalette
//
// This function processes the D3DDP2OP_SETPALETTE DP2 command token.
//
//      Note : This function is need to skip D3DDP2OP_SETPALETTE sent down 
//             by some DX6 apps, even if when PALETTE TEXTURE is not supported
//
//-----------------------------------------------------------------------------

HRESULT _D3D_OP_SetPalettes(P3_D3DCONTEXT* pContext,
                            D3DHAL_DP2SETPALETTE* pSetPalettes,
                            int iNumSetPalettes)
{
#if DX7_PALETTETEXTURE
    int i;
    P3_SURF_INTERNAL* pTexture;
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    
    // Loop to process N surface palette association
    for (i = 0; i < iNumSetPalettes; i++, pSetPalettes++)
    {

        DISPDBG((DBGLVL,"SETPALETTE: Binding surf # %d to palette # %d",
                        pSetPalettes->dwSurfaceHandle,
                        pSetPalettes->dwPaletteHandle));               
    
        // Find internal surface pointer from handle
        pTexture = GetSurfaceFromHandle(pContext, 
                                        pSetPalettes->dwSurfaceHandle);
        if (! pTexture)
        {
            // Associated texture can't be found
            DISPDBG((WRNLVL, 
                     "SetPalettes : invalid texture handle %08lx",
                     pSetPalettes->dwSurfaceHandle));
            return DDERR_INVALIDPARAMS;
        }
 
        // Create the internal palette structure if necessary
        if (pSetPalettes->dwPaletteHandle)
        {
            // Find internal palette pointer from handle
            pPalette = GetPaletteFromHandle(pContext,
                                            pSetPalettes->dwPaletteHandle);    
    
            if (! pPalette)
            {
                pPalette = (D3DHAL_DP2UPDATEPALETTE *)
                                HEAP_ALLOC(FL_ZERO_MEMORY,
                                           sizeof(D3DHAL_DP2UPDATEPALETTE) 
                                                    + LUT_ENTRIES*sizeof(DWORD),
                                           ALLOC_TAG_DX(P));
                // Out of memory case
                if (! pPalette) 
                {
                    DISPDBG((WRNLVL, "_D3D_OP_SetPalettes : Out of memory."));
                    return DDERR_OUTOFMEMORY;
                }

                // Add this texture to the surface list
                if (! PA_SetEntry(pContext->pPalettePointerArray, 
                                  pSetPalettes->dwPaletteHandle, 
                                  pPalette))
                {
                    HEAP_FREE(pPalette);
                    DISPDBG((WRNLVL, "_D3D_OP_SetPalettes : "
                                     "PA_SetEntry() failed."));
                    return DDERR_OUTOFMEMORY;
                }

                // Set up the internal data structure
                pPalette->dwPaletteHandle = pSetPalettes->dwPaletteHandle;
                pPalette->wStartIndex = 0;
                pPalette->wNumEntries = LUT_ENTRIES;
            } 
        }

        // Record palette handle and flags in internal surface data
        pTexture->dwPaletteHandle = pSetPalettes->dwPaletteHandle;
        pTexture->dwPaletteFlags = pSetPalettes->dwPaletteFlags;

        // Mark texture as dirty if current texture is affected
        if ((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP] == 
                                               pSetPalettes->dwSurfaceHandle) ||
            (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP] == 
                                               pSetPalettes->dwSurfaceHandle))
        {
            DIRTY_TEXTURE(pContext);
        }

    }

    return DD_OK;
#else
    return DD_OK;
#endif // DX7_PALETTETEXTURE
} // _D3D_OP_SetPalettes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dprim.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dprim.c
*
* Content: D3D primitives rendering
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// For the mipmap LOD calculation

#define BIAS_SHIFT 1
#define CULL_HERE 1

#include <limits.h>
#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// Specialized hardaware rendering functions for the Permedia3, 
// for all primitve types
//
//-----------------------------------------------------------------------------

#define GET_FOG(x)  ((x) & 0xff000000 )
#define GET_SPEC(x) ((x) & 0x00ffffff )


#define SEND_R3FVFVERTEX_XYZ(Num, Index)        \
{                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | Num;       \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);    \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);    \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);    \
        dmaPtr += 4;                            \
        CHECK_FIFO(4);                          \
}

#define SEND_R3FVFVERTEX_XYZ_STQ(Num, Index)            \
{                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | Num;           \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;   \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;   \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                           \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);            \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);            \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);            \
        dmaPtr += 7;                                    \
        CHECK_FIFO(7);                                  \
}

#define SEND_R3FVFVERTEX_XYZ_FOG(Num, Index)                    \
{                                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_SPECULAR | Num;        \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);                    \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);                    \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);                    \
        MEMORY_BARRIER(); \
        dmaPtr[4] = GET_FOG( FVFSPEC(pv[Index])->specular );    \
        dmaPtr += 5;                                            \
        CHECK_FIFO(5);                                          \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_FOG(Num, Index)                \
{                                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;           \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;           \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                   \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                    \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);                    \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                    \
        MEMORY_BARRIER(); \
        dmaPtr[7] = GET_FOG( FVFSPEC(pv[Index])->specular );    \
        dmaPtr += 8;                                            \
        CHECK_FIFO(8);                                          \
}

#define SEND_R3FVFVERTEX_XYZ_RGBA(Num, Index)           \
{                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_COLOR | Num;   \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);            \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);            \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);            \
        MEMORY_BARRIER(); \
        dmaPtr[4] = FVFCOLOR(pv[Index])->color;         \
        MEMORY_BARRIER(); \
        dmaPtr += 5;                                    \
        CHECK_FIFO(5);                                  \
}
 
#define SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(Num, Index)                      \
{                                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);                            \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);                            \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);                            \
        MEMORY_BARRIER(); \
        dmaPtr[4] = FVFCOLOR(pv[Index])->color;                         \
        MEMORY_BARRIER(); \
        dmaPtr[5] = FVFSPEC(pv[Index])->specular;                       \
        dmaPtr += 6;                                                    \
        CHECK_FIFO(6);                                                  \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(Num, Index)                      \
{                                                                           \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;                       \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;                       \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                               \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                                \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);                                \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                                \
        MEMORY_BARRIER(); \
        dmaPtr[7] = FVFCOLOR(pv[Index])->color;                             \
        MEMORY_BARRIER(); \
        dmaPtr[8] = FVFSPEC(pv[Index])->specular;                           \
        dmaPtr += 9;                                                       \
        CHECK_FIFO(9);                                                     \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(Num, Index, offset)        \
{                                                                           \
        float TempY = Y_ADJUST(pv[Index]->sy);                              \
        if (offset == TRUE) TempY += 1.0f;                                  \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;                       \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;                       \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                               \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                                \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(TempY);                                        \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                                \
        MEMORY_BARRIER(); \
        dmaPtr[7] = FVFCOLOR(pv[Index])->color;                             \
        MEMORY_BARRIER(); \
        dmaPtr[8] = FVFSPEC(pv[Index])->specular;                           \
        dmaPtr += 9;                                                        \
        CHECK_FIFO(9);                                                      \
}

#define SEND_R3FVFVERTEX_STQ2(Num, Index)   \
{                                                   \
        MEMORY_BARRIER(); \
    dmaPtr[0] = GAMBIT_STQ_VTX | Num;               \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[1] = tc[Index].tu2;   \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[2] = tc[Index].tv2;   \
        MEMORY_BARRIER(); \
    dmaPtr[3] = q[Index];                           \
    dmaPtr += 4;                                    \
    CHECK_FIFO(4);                                  \
}

#if DX8_3DTEXTURES
#define SEND_R3FVFVERTEX_3DTEX(Num, Index)   \
{                                                    \
        MEMORY_BARRIER(); \
    dmaPtr[0] = GAMBIT_STQ_VTX | Num;                \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[1] = tc[Index].tw1;    \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[2] = 0; /* Not used */ \
        MEMORY_BARRIER(); \
    dmaPtr[3] = q[Index];                            \
    dmaPtr += 4;                                     \
    CHECK_FIFO(4);                                   \
}
#endif // DX8_3DTEXTURES

#if DX8_3DTEXTURES
#define GET_TC_3DTEX( Index ) \
        *(DWORD *)&tc[Index].tu1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tu;     \
        *(DWORD *)&tc[Index].tv1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tv;     \
        *(DWORD *)&tc[Index].tw1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tw;
#endif // DX8_3DTEXTURES

#define GET_TC( Index ) \
        *(DWORD *)&tc[Index].tu1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tu;     \
        *(DWORD *)&tc[Index].tv1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tv;

#if DX8_3DTEXTURES
#define GET_TC2_3DTEX( Index )    \
        *(DWORD *)&tc[Index].tu2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tu;     \
        *(DWORD *)&tc[Index].tv2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tv;     \
        *(DWORD *)&tc[Index].tw2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tw;
#endif // DX8_3DTEXTURES

#define GET_TC2( Index )    \
        *(DWORD *)&tc[Index].tu2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tu;     \
        *(DWORD *)&tc[Index].tv2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tv;

#define GET_ONE_TEXCOORD(vtx)                           \
        GET_TC(vtx);                                    \
        if( pContext->iTexStage[1] != -1 )          \
        {                                               \
            GET_TC2(vtx);                               \
        }

#define GET_TEXCOORDS() \
        GET_TC(0); GET_TC(1); GET_TC(2);        \
        if( pContext->iTexStage[1] != -1 )  \
        {                                       \
            GET_TC2(0); GET_TC2(1); GET_TC2(2); \
        }

#if DX8_3DTEXTURES
#define SCALE_BY_Q_3DTEX( Index )           \
    tc[Index].tu1 *= *(float *)&q[Index];   \
    tc[Index].tv1 *= *(float *)&q[Index];   \
    tc[Index].tw1 *= *(float *)&q[Index];
#endif // DX8_3DTEXTURES

#define SCALE_BY_Q( Index )                 \
    tc[Index].tu1 *= *(float *)&q[Index];   \
    tc[Index].tv1 *= *(float *)&q[Index];

#if DX8_3DTEXTURES
#define SCALE_BY_Q2_3DTEX( Index )          \
    tc[Index].tu2 *= *(float *)&q[Index];   \
    tc[Index].tv2 *= *(float *)&q[Index];   \
    tc[Index].tw2 *= *(float *)&q[Index];
#endif // DX8_3DTEXTURES

#define SCALE_BY_Q2( Index )                \
    tc[Index].tu2 *= *(float *)&q[Index];   \
    tc[Index].tv2 *= *(float *)&q[Index];

#define DRAW_LINE()                             \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawLine01_Tag;             \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_POINT()                            \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawPoint_Tag;              \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_LINE_01_OR_10( vtx )               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = vtx ? DrawLine01_Tag        \
                        : DrawLine10_Tag;       \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_TRIANGLE()                         \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawTriangle_Tag;           \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

//-----------------------------------------------------------------------------
// Easy edge flag renaming
//-----------------------------------------------------------------------------
#define SIDE_0      D3DTRIFLAG_EDGEENABLE1
#define SIDE_1      D3DTRIFLAG_EDGEENABLE2
#define SIDE_2      D3DTRIFLAG_EDGEENABLE3
#define ALL_SIDES   ( SIDE_0 | SIDE_1 | SIDE_2 )

//-----------------------------------------------------------------------------
// Cycle vertex indices for triangle strips viz. 0 -> 1, 1 -> 2, 2 -> 0
// See Graphics Gems 3, Pg 69.
//-----------------------------------------------------------------------------

#define INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b)   \
    vtx_a = 0;                                        \
    vtx_b = 0 ^ 1;                                    \
    pContext->dwProvokingVertex = 1;

#define CONST_c (0 ^ 1 ^ 2)

#define CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b)  \
        vtx_a ^= vtx_b;                               \
        vtx_b ^= CONST_c;                             \
        pContext->dwProvokingVertex = vtx_b;          \
        vtx_b ^= vtx_a;

//-----------------------------------------------------------------------------
// Local typedef for temporary texture coordinate storage
//-----------------------------------------------------------------------------

typedef struct
{
    float tu1;
    float tv1;
#if DX8_3DTEXTURES
    float tw1;
#endif // DX8_3DTEXTURES
    float tu2;
    float tv2;
#if DX8_3DTEXTURES
    float tw2;
#endif // DX8_3DTEXTURES
} TEXCOORDS;

//-----------------------------------------------------------------------------
// Macros to access and validate command and vertex buffer data
// These checks need ALWAYS to be made for all builds, free and checked. 
//-----------------------------------------------------------------------------
#define LP_FVF_VERTEX(lpBaseAddr, wIndex)                         \
         (LPD3DTLVERTEX)((LPBYTE)(lpBaseAddr) + (wIndex) * pContext->FVFData.dwStride)

#define LP_FVF_NXT_VTX(lpVtx)                                    \
         (LPD3DTLVERTEX)((LPBYTE)(lpVtx) + pContext->FVFData.dwStride)

#define CHECK_DATABUF_LIMITS(pbError, dwVBLen, iIndex )                        \
   {                                                                           \
        if (! (((LONG)(iIndex) >= 0) &&                                        \
               ((LONG)(iIndex) <(LONG)dwVBLen)))                               \
        {                                                                      \
            DISPDBG((ERRLVL,"D3D: Trying to read past Vertex Buffer limits "   \
                "%d limit= %d ",(LONG)(iIndex), (LONG)dwVBLen));               \
            *pbError = TRUE;                                                   \
            return;                                                            \
        }                                                                      \
   }

//-----------------------------------------------------------------------------
// Define values for FVF defaults
//-----------------------------------------------------------------------------
const FVFCOLOR     gc_FVFColorDefault = { 0xFFFFFFFF  };
const FVFSPECULAR  gc_FVFSpecDefault  = { 0x00000000  };
const FVFTEXCOORDS gc_FVFTexCoordDefault = { 0.0f, 
                                             0.0f 
#if DX8_3DTEXTURES
                                           , 0.0f 
#endif
                                           };

//-----------------------------------------------------------------------------
// Macros and functions for texture coord adjustment on wrapping
//-----------------------------------------------------------------------------

#define SHIFT_SET_0     1
#define SHIFT_SET_1     2


#define TEXSHIFT 1

#if TEXSHIFT
#if 0
// 8.0f as a DWORD
#define TEX_SHIFT_LIMIT 0x41000000
#define FP_SIGN_MASK    0x7fffffff

#define TEXTURE_SHIFT( coord )  \
    if(( *(DWORD *)&tc[0].##coord & FP_SIGN_MASK ) > TEX_SHIFT_LIMIT )  \
    {                                                                   \
        myFtoi( &intVal, tc[0].##coord );                               \
                                                                        \
        intVal &= ~1;                                                   \
                                                                        \
        tc[0].##coord -= intVal;                                        \
        tc[1].##coord -= intVal;                                        \
        tc[2].##coord -= intVal;                                        \
                                                                        \
        FLUSH_DUE_TO_WRAP( coord, TRUE );                               \
    }
#endif

#define TEX_SHIFT_LIMIT 4.0

#define TEXTURE_SHIFT( coord )  \
    if((tc[0].##coord >  TEX_SHIFT_LIMIT ) ||                           \
       (tc[0].##coord < -TEX_SHIFT_LIMIT ) )                            \
    {                                                                   \
        myFtoi( &intVal, tc[0].##coord );                               \
                                                                        \
        intVal &= ~1;                                                   \
                                                                        \
        tc[0].##coord -= intVal;                                        \
        tc[1].##coord -= intVal;                                        \
        tc[2].##coord -= intVal;                                        \
                                                                        \
        FLUSH_DUE_TO_WRAP( coord, TRUE );                               \
    }

#define WRAP_R3(par, wrapit, vertexSharing) if(wrapit) {        \
    float elp;                                                  \
    float erp;                                                  \
    float emp;                                                  \
    elp=(float)myFabs(tc[1].##par-tc[0].##par);                 \
    erp=(float)myFabs(tc[2].##par-tc[1].##par);                 \
    emp=(float)myFabs(tc[0].##par-tc[2].##par);                 \
    if( (elp > 0.5f) && (erp > 0.5f) )                          \
    {                                                           \
        if (tc[1].##par < tc[2].##par) { tc[1].##par += 1.0f; } \
        else { tc[2].##par += 1.0f; tc[0].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else if( (erp > 0.5f) && (emp > 0.5f) )                     \
    {                                                           \
        if (tc[2].##par < tc[0].##par) { tc[2].##par += 1.0f; } \
        else { tc[0].##par += 1.0f; tc[1].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else if( (emp > 0.5f) && (elp > 0.5f) )                     \
    {                                                           \
        if(tc[0].##par < tc[1].##par) { tc[0].##par += 1.0f; }  \
        else { tc[1].##par += 1.0f; tc[2].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else                                                        \
    {                                                           \
        DONT_FLUSH_DUE_TO_WRAP(par,vertexSharing);              \
    }                                                           \
} else {                                                        \
    DONT_FLUSH_DUE_TO_WRAP(par,vertexSharing);                  \
}
    
//-----------------------------------------------------------------------------
//
// __TextureShift
//
//-----------------------------------------------------------------------------
void 
__TextureShift( 
    P3_D3DCONTEXT *pContext, 
    TEXCOORDS tc[], 
    DWORD shiftMask )
{
    int intVal;

    if( shiftMask & SHIFT_SET_0 )
    {
        if( pContext->TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tu1 );
        }

        if( pContext->TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tv1 );
        }
    }

    if( shiftMask & SHIFT_SET_1 )
    {
        if( pContext->TextureStageState[1].m_dwVal[D3DTSS_ADDRESSU] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tu2 );
        }

        if( pContext->TextureStageState[1].m_dwVal[D3DTSS_ADDRESSV] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tv2 );
        }
    }
} // __TextureShift

#endif //TEXSHIFT

//-----------------------------------------------------------------------------
//
// __BackfaceCullNoTexture
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullNoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }         
        
    pContext->R3flushDueToTexCoordAdjust = 0;

    return 0;
} // __BackfaceCullNoTexture

//-----------------------------------------------------------------------------
//
// __BackfaceCullSingleTex
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullSingleTex( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    TEXCOORDS tc[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }    

    pContext->R3flushDueToTexCoordAdjust = 0;

#if TEXSHIFT
    __TextureShift( pContext, tc, SHIFT_SET_0 );
#endif

    return 0;
    
} // __BackfaceCullSingleTex

//-----------------------------------------------------------------------------
//
// __BackfaceCullAndMipMap
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullAndMipMap( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    TEXCOORDS tc[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;
    int iNewMipLevel;
    P3_SURF_INTERNAL* pTexture;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;

    P3_DMA_DEFS();

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }    

    // 39 for vertex data, 2 for triangle and 4 for possible LOD change
    // for the three vertex case - the one vertex case will check for
    // too much but this shouldn't be a problem.

    P3_DMA_GET_BUFFER_ENTRIES( 4 );

    pContext->R3flushDueToTexCoordAdjust = 0;

    if( Flags & SURFACE_TEXTURING )
    {
        float TextureArea, textureAreaFactor;
        int maxLevel;

        pTexture = pContext->pCurrentTexture[TEXSTAGE_0];

        // Setup LOD of texture # 0 (if necessary)
        if( pContext->bTex0Valid &&
            ( pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE )
            && pTexture->bMipMap )
        {
            maxLevel = pTexture->iMipLevels - 1;
            textureAreaFactor = pTexture->fArea * pContext->MipMapLODBias[TEXSTAGE_0];

            TextureArea = (((tc[0].tu1 - tc[2].tu1) * (tc[1].tv1 - tc[2].tv1)) -
                    ((tc[1].tu1 - tc[2].tu1) * (tc[0].tv1 - tc[2].tv1))) * textureAreaFactor;

            // Ensure that both of these values are positive from now on.

            *(signed long *)&PixelArea &= ~(1 << 31);
            *(signed long *)&TextureArea &= ~(1 << 31);

            FIND_PERMEDIA_MIPLEVEL();

            DISPDBG((DBGLVL,"iNewMipLevel = %x",iNewMipLevel));

            SEND_P3_DATA( LOD, iNewMipLevel << 8 );
        }

        pTexture = pContext->pCurrentTexture[TEXSTAGE_1];

        // Setup LOD of texture # 1 (if necessary)
        if( pContext->bTex1Valid && ( pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE )
                                            && pTexture->bMipMap )
        {
            ASSERTDD( pContext->bTex0Valid, "Second texture valid when first isn't" );

            maxLevel = pTexture->iMipLevels - 1;
            textureAreaFactor = pTexture->fArea * pContext->MipMapLODBias[TEXSTAGE_1];

            TextureArea = (((tc[0].tu2 - tc[2].tu2) * (tc[1].tv2 - tc[2].tv2)) -
                    ((tc[1].tu2 - tc[2].tu2) * (tc[0].tv2 - tc[2].tv2))) * textureAreaFactor;

            // Ensure that both of these values are positive from now on.

            *(signed long *)&PixelArea &= ~(1 << 31);
            *(signed long *)&TextureArea &= ~(1 << 31);

            FIND_PERMEDIA_MIPLEVEL();

            SEND_P3_DATA( LOD1, iNewMipLevel << 8 );
        }

        if( pContext->RenderStates[D3DRENDERSTATE_WRAP0] )
        {
            WRAP_R3( tu1, pContext->RenderStates[D3DRENDERSTATE_WRAP0] & D3DWRAP_U, TRUE );
            WRAP_R3( tv1, pContext->RenderStates[D3DRENDERSTATE_WRAP0] & D3DWRAP_V, TRUE );
        }
        else
        {
#if TEXSHIFT
            __TextureShift( pContext, tc, SHIFT_SET_0 );
#endif
        }

        if( pContext->RenderStates[D3DRENDERSTATE_WRAP1] )
        {
            WRAP_R3( tu2, pContext->RenderStates[D3DRENDERSTATE_WRAP1] & D3DWRAP_U, TRUE );
            WRAP_R3( tv2, pContext->RenderStates[D3DRENDERSTATE_WRAP1] & D3DWRAP_V, TRUE );
        }
        else
        {
#if TEXSHIFT
            __TextureShift( pContext, tc, SHIFT_SET_1 );
#endif
        }
    }

    P3_DMA_COMMIT_BUFFER();

    return 0;
    
} // __BackfaceCullAndMipMap

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_NoTexture
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_NoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 9 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        // 9 DWORDS.
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            // 8 DWORDS.
            SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag + (vtx*16), vtx);
        }
        else
        {
            // 7 DWORDS.
            SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag + (vtx*16), vtx);
        }

        // 2 DWORDS.
        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),
                                                RGBA_GETGREEN(Col0),
                                                RGBA_GETRED(Col0),
                                                RGBA_GETALPHA(Col0)));
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return 0;
    
} // __ProcessTri_1Vtx_NoTexture

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_NoTexture
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_NoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 20 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V1FloatS_Tag, 1);
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V2FloatS_Tag, 2);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_FOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_FOG(V2FloatS_Tag, 2);
        }
        else
        {
            SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ(V2FloatS_Tag, 2);
        }

        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),
                                            RGBA_GETGREEN(Col0),
                                            RGBA_GETRED(Col0),
                                            RGBA_GETALPHA(Col0)));
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return 0;
} // __ProcessTri_3Vtx_NoTexture

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_PerspSingleTexGouraud
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_PerspSingleTexGouraud( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    TEXCOORDS tc[3];
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
#if DX8_3DTEXTURES
    P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_0];
    BOOL b3DTexture = (pTexture ? pTexture->b3DTexture : FALSE);
#endif // DX8_3DTEXTURES

    P3_DMA_DEFS();

    // We need to refresh all texture coords as they will have been modified
    // by the scale by Q and potentially D3D wrapping or TextureShift.

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        GET_TC_3DTEX(0); GET_TC_3DTEX(1); GET_TC_3DTEX(2);
    }
    else
    {
        GET_TC(0); GET_TC(1); GET_TC(2);
    }
#else
    GET_TC(0); GET_TC(1); GET_TC(2);
#endif // DX8_3DTEXTURES

#if CULL_HERE
    if( __BackfaceCullSingleTex( pContext, pv, tc ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 15 );

    q[vtx] = *(DWORD *)&(pv[vtx]->rhw);


#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SCALE_BY_Q_3DTEX( vtx );
    }
    else
    {
        SCALE_BY_Q( vtx );
    }
#else
    SCALE_BY_Q( vtx );
#endif // DX8_3DTEXTURES

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V0FloatS1_Tag + (vtx*16), vtx);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return pContext->R3flushDueToTexCoordAdjust;
    
} // __ProcessTri_1Vtx_PerspSingleTexGouraud

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_PerspSingleTexGouraud
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_PerspSingleTexGouraud( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    TEXCOORDS tc[3];
    DWORD q[3];
    int forcedQ = 0;
    ULONG renderCmd = pContext->RenderCommand;
#if DX8_3DTEXTURES
    P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_0];
    BOOL b3DTexture = (pTexture ? pTexture->b3DTexture : FALSE);
#endif // DX8_3DTEXTURES

    P3_DMA_DEFS();

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        GET_TC_3DTEX(0); GET_TC_3DTEX(1); GET_TC_3DTEX(2);
    }
    else
    {
        GET_TC(0); GET_TC(1); GET_TC(2);
    }
#else
    GET_TC(0); GET_TC(1); GET_TC(2);
#endif // DX8_3DTEXTURES

#if CULL_HERE
    if( __BackfaceCullSingleTex( pContext, pv, tc ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 26 );

    q[0] = *(DWORD *)&(pv[0]->rhw);
    q[1] = *(DWORD *)&(pv[1]->rhw);
    q[2] = *(DWORD *)&(pv[2]->rhw);

    // Check for equal Q's

    if((( q[0] ^ q[1] ) | ( q[1] ^ q[2] )) == 0 ) 
    {
        // Force to 1.0f

        forcedQ = q[0] = q[1] = q[2] = 0x3f800000;
    }
    else
    {
#if DX8_3DTEXTURES
        if (b3DTexture)
        {
            SCALE_BY_Q_3DTEX( 0 );
            SCALE_BY_Q_3DTEX( 1 );
            SCALE_BY_Q_3DTEX( 2 );
        }
        else
        {
            SCALE_BY_Q( 0 );
            SCALE_BY_Q( 1 );
            SCALE_BY_Q( 2 );
        }
#else
        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );
#endif // DX8_3DTEXTURES
    }

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V0FloatS1_Tag, 0);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);

    
#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V1FloatS1_Tag, 1);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES( 15 );
    
#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V2FloatS1_Tag, 2);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V2FloatS_Tag, 2);

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return ( pContext->R3flushDueToTexCoordAdjust | forcedQ );
    
} // __ProcessTri_3Vtx_PerspSingleTexGouraud

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Generic
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Generic( 
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

    // We need to refresh all texture coords as they will have been modified
    // by the scale by Q and potentially D3D wrapping or TextureShift.

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[vtx] = *(DWORD *)&(pv[vtx]->rhw);
        SCALE_BY_Q( vtx );
    }

    // Send vertex data including check for flat shading

    P3_DMA_GET_BUFFER_ENTRIES( 16 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        // 9 DWORDS.
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            // 8 DWORDS.
            SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag + (vtx*16), vtx);
        }
        else
        {
            // 7 DWORDS.
            SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag + (vtx*16), vtx);
        }

        // 2 DWORDS.
        SEND_P3_DATA(ConstantColor,
            RGBA_MAKE(RGBA_GETBLUE(Col0),
                        RGBA_GETGREEN(Col0),
                        RGBA_GETRED(Col0),
                        RGBA_GETALPHA(Col0)));
    }

    // Send the second set of texture coordinates including scale-by-q

    if( pContext->iTexStage[1] != -1
                && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
    {
        DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

        if( Flags & SURFACE_PERSPCORRECT )
        {
            SCALE_BY_Q2( vtx );
        }

        // 4 DWORDS.
        SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag + (vtx*16), vtx);
    }

    RENDER_TRAPEZOID(renderCmd);

    // 2 DWORDS.
    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return pContext->R3flushDueToTexCoordAdjust;
} // __ProcessTri_1Vtx_Generic

//-----------------------------------------------------------------------------
// 
// __ProcessTri_3Vtx_Generic
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Generic( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    DWORD q[3];
    int forcedQ = 0;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;     
        
    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        // Check for equal Q's

        if((( q[0] ^ q[1] ) | ( q[1] ^ q[2] )) == 0 ) 
        {
            // Force to 1.0f

            forcedQ = q[0] = q[1] = q[2] = 0x3f800000;
        }
        else
        {
            SCALE_BY_Q( 0 );
            SCALE_BY_Q( 1 );
            SCALE_BY_Q( 2 );
        }
    }
    else
    {
        q[0] = q[1] = q[2] = 0x3f800000;
    }

    // Send vertex data including check for flat shading

    // Worst case 27 DWORDS
    P3_DMA_GET_BUFFER_ENTRIES(29);

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        if( Flags & SURFACE_TEXTURING )
        {
            // 9 DWORDs each.
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V2FloatS_Tag, 2);
        }
        else
        {
            // 6 DWORDs each.
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V2FloatS_Tag, 2);
        }
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_TEXTURING )
        {
            if( Flags & SURFACE_FOGENABLE )
            {
                // 8 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V2FloatS_Tag, 2);
            }
            else
            {
                // 7 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_STQ(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_STQ(V2FloatS_Tag, 2);
            }
        }
        else
        {
            if( Flags & SURFACE_FOGENABLE )
            {
                // 5 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_FOG(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_FOG(V2FloatS_Tag, 2);
            }
            else
            {
                // 4 DWORDs each.
                SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ(V2FloatS_Tag, 2);
            }
        }

        SEND_P3_DATA(ConstantColor,
            RGBA_MAKE(RGBA_GETBLUE(Col0),
                        RGBA_GETGREEN(Col0),
                        RGBA_GETRED(Col0),
                        RGBA_GETALPHA(Col0)));
    }

    // Send the second set of texture coordinates including scale-by-q

    if( pContext->iTexStage[1] != -1
                && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
    {
        DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

        if( Flags & SURFACE_PERSPCORRECT )
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }

        // 12 DWORDS    
        P3_DMA_COMMIT_BUFFER(); 
        P3_DMA_GET_BUFFER_ENTRIES(14);        
        // 4 DWORDs each.
        SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, 0);
        SEND_R3FVFVERTEX_STQ2(V1FloatS1_Tag, 1);
        SEND_R3FVFVERTEX_STQ2(V2FloatS1_Tag, 2);
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();    

    return ( pContext->R3flushDueToTexCoordAdjust | forcedQ );
} // __ProcessTri_3Vtx_Generic



//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Wire
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Wire(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_Wire"));
    return 1;
} // __ProcessTri_1Vtx_Wire

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_Wire
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Wire(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    int i;
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
    const int edges[] = { SIDE_0, SIDE_1, SIDE_2 };

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    RENDER_LINE(renderCmd);

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );

        if(pContext->iTexStage[1] != -1 )
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }
    }

    // Send vertex data including check for flat shading

    for( i = 0; i < 3; i++ )
    {
        int v0, v1;

        v0 = i;
        v1 = i + 1;

        if( v1 == 3 )
            v1 = 0;

        if( WireEdgeFlags & edges[i] )
        {
            P3_DMA_GET_BUFFER_ENTRIES(30);
            
            if( pContext->Flags & SURFACE_GOURAUD )
            {
                // 9 DWORDs each.            
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, v0);
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, v1);
            }
            else
            {
                DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

                if( Flags & SURFACE_SPECULAR )
                {
                    DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

                    CLAMP8888( Col0, Col0, Spec0 );
                }

                if( Flags & SURFACE_FOGENABLE )
                {
                    // 6 DWORDs each.                
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, v0);
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, v1);
                }
                else
                {
                    // 7 DWORDs each.                
                    SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, v0);
                    SEND_R3FVFVERTEX_XYZ_STQ(V1FloatS_Tag, v1);
                }

                SEND_P3_DATA(ConstantColor,
                    RGBA_MAKE(RGBA_GETBLUE(Col0),
                                RGBA_GETGREEN(Col0),
                                RGBA_GETRED(Col0),
                                RGBA_GETALPHA(Col0)));
            }

            // Send the second set of texture coordinates
            if( pContext->iTexStage[1] != -1
                    && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1] ))
            {
                // 4 DWORDs each.                
                SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, v0);
                SEND_R3FVFVERTEX_STQ2(V1FloatS1_Tag, v1);
            }

            DRAW_LINE();

            P3_DMA_COMMIT_BUFFER();            
        }
    }

    return 1;
} // __ProcessTri_3Vtx_Wire

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Point
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Point(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_Wire"));
    return 1;
} // __ProcessTri_1Vtx_Point

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_Point
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Point(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    int i;
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
    const int edges[] = { SIDE_0, SIDE_1, SIDE_2 };

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    RENDER_POINT(renderCmd);

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );

        if(pContext->iTexStage[1] != -1)
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }
    }

    // Send vertex data including check for flat shading

    for( i = 0; i < 3; i++ )
    {
        int v0, v1;

        v0 = i;
        v1 = i + 1;

        if( v1 == 3 )
            v1 = 0;

        if( WireEdgeFlags & edges[i] )
        {            
            P3_DMA_GET_BUFFER_ENTRIES( 16 );
            if( pContext->Flags & SURFACE_GOURAUD )
            {
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, v0);
            }
            else
            {
                DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

                if( Flags & SURFACE_SPECULAR )
                {
                    DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

                    CLAMP8888( Col0, Col0, Spec0 );
                }

                if( Flags & SURFACE_FOGENABLE )
                {
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, v0);
                }
                else
                {
                    SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, v0);
                }

                SEND_P3_DATA(ConstantColor,
                    RGBA_MAKE(RGBA_GETBLUE(Col0),
                                RGBA_GETGREEN(Col0),
                                RGBA_GETRED(Col0),
                                RGBA_GETALPHA(Col0)));
            }

            // Send the second set of texture coordinates

            if( pContext->iTexStage[1] != -1
                    && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
            {
                DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

                SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, v0);
            }

            DRAW_POINT();

            P3_DMA_COMMIT_BUFFER();
        }
    }

    return 1;
} // __ProcessTri_3Vtx_Point

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleList
// 
// Render D3DDP2OP_TRIANGLELIST triangles
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_TriangleList); 

    dwIndex = ((D3DHAL_DP2TRIANGLELIST*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + 3*dwPrimCount - 1);

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {    
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

        pv[0] = LP_FVF_NXT_VTX(pv[2]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
        pv[2] = LP_FVF_NXT_VTX(pv[1]);
    }

    DBG_EXIT(_D3D_R3_DP2_TriangleList,0); 
    
} // _D3D_R3_DP2_TriangleList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleFan
// 
// Render a D3DDP2OP_TRIANGLEFAN triangle
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleFan(
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);
    
    DBG_ENTRY(_D3D_R3_DP2_TriangleFan); 

    lastVtx = vtx = 2;

    dwIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex); 
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + dwPrimCount + 1);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

    for( i = 1; i < dwPrimCount; i++ )
    {
        vtx ^= 3; // 2 -> 1, 1 -> 2

        FLIP_CCW_CW_CULLING(pContext);

        pv[vtx] = LP_FVF_NXT_VTX(pv[lastVtx]);
       
        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);

    DBG_EXIT(_D3D_R3_DP2_TriangleFan,0);     
    
} // _D3D_R3_DP2_TriangleFan

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleFanImm
//
// Render D3DDP2OP_TRIANGLEFAN_IMM triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleFanImm(
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[3];
    DWORD i, dwEdgeFlags, eFlags;
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_TriangleFanImm); 

    lastVtx = vtx = 2;

    // Edge flags are used for wireframe fillmode
    dwEdgeFlags = ((D3DHAL_DP2TRIANGLEFAN_IMM *)lpPrim)->dwEdgeFlags;
    lpPrim += sizeof(D3DHAL_DP2TRIANGLEFAN_IMM); 

    // Vertices in an IMM instruction are stored in the
    // command buffer and are DWORD aligned

    lpPrim = (LPBYTE)((ULONG_PTR)( lpPrim + 3 ) & ~3 );

    pv[0] = (LPD3DTLVERTEX)lpPrim;
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // since data is in the command buffer, we've already verified it as valid

    // Build up edge flags for the next single primitive
    eFlags  = ( dwEdgeFlags & 1 ) ? SIDE_0 : 0;
    eFlags |= ( dwEdgeFlags & 2 ) ? SIDE_1 : 0;
    dwEdgeFlags >>= 2;

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, eFlags);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        pv[vtx] = LP_FVF_NXT_VTX(pv[lastVtx]);

        if( i == ( dwPrimCount - 1 ))
        {
            eFlags  = ( dwEdgeFlags & 1 ) ? SIDE_1 : 0;
            eFlags |= ( dwEdgeFlags & 2 ) ? SIDE_2 : 0;
        }
        else
        {
            eFlags = ( dwEdgeFlags & 1 ) ? SIDE_1 : 0;
            dwEdgeFlags >>= 1;
        }
        
        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, eFlags);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);

    DBG_EXIT(_D3D_R3_DP2_TriangleFanImm,0); 
    
} // _D3D_R3_DP2_TriangleFanImm

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleStrip
// 
// Render D3DDP2OP_TRIANGLESTRIP triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];
    int vtx_a, vtx_b, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_TriangleStrip);       

    dwIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + dwPrimCount + 1);

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

    lastVtx = 2;
    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        pv[vtx_a] = LP_FVF_NXT_VTX(pv[lastVtx]);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv,ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );

        lastVtx = vtx_a;
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_TriangleStrip,0);     
    
} // _D3D_R3_DP2_TriangleStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];
    int vtx_a, vtx_b, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip); 

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
    dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
    dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];

    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);            

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );

        lpPrim += sizeof(WORD);

        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan);     

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
    dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
    dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];

    lastVtx = vtx = 2;
    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
        pv[vtx] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
        lpPrim += sizeof(WORD);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, primData;
    WORD wFlags;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList); 

    pContext->dwProvokingVertex = 0;
    
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV1;
        dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV2;
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV3;
        wFlags  = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wFlags;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);  

        lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        (*pContext->pRendTri_3V)( pContext, pv, wFlags);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList2
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST2 triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList2( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList2); 
    
    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV1;
        dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV2;
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV3;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex0);    
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex1);           
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex2);           

        lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList2,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList2

//-----------------------------------------------------------------------------
//
// __ProcessLine
// 
// Render a single line
//
//-----------------------------------------------------------------------------
void
__ProcessLine(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[],
    D3DTLVERTEX *pProvokingVtx)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[2];
    DWORD q[2];
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();    

    RENDER_LINE(renderCmd);   

    GET_TC(0); GET_TC(1);

    P3_DMA_GET_BUFFER_ENTRIES(22);

    if (pContext->RenderStates[D3DRENDERSTATE_LINEPATTERN])    
    {
        // if we are line stippling then reset rendering for each line
        SEND_P3_DATA( UpdateLineStippleCounters , 0);
    }

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
    }
    else
    {
        q[0] = q[1] = 0;
    }

    if (Flags & SURFACE_GOURAUD)
    {
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pProvokingVtx)->color;                    
    
        SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, 1);

        if( pContext->Flags & SURFACE_SPECULAR )                    
        {                                                           
            DWORD Spec0 = GET_SPEC( FVFSPEC(pProvokingVtx)->specular );     
            CLAMP8888( Col0, Col0, Spec0 );                             
        }                                                               
        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),       
                                                RGBA_GETGREEN(Col0),    
                                                RGBA_GETRED(Col0),      
                                                RGBA_GETALPHA(Col0)));  
    }

    DRAW_LINE();

    P3_DMA_COMMIT_BUFFER();
   
} // __ProcessLine

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineList
// 
// Render D3DDP2OP_LINELIST lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart;
    DWORD i;
       
    DBG_ENTRY(_D3D_R3_DP2_LineList);

    wVStart = ((D3DHAL_DP2LINELIST*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen,
                           (LONG)wVStart + 2*dwPrimCount - 1)

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = LP_FVF_NXT_VTX(pv[1]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineList,0);
    
} // _D3D_R3_DP2_LineList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineListImm
// 
// Render D3DDP2OP_LINELIST_IMM lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineListImm( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_LineListImm);

    pv[0] = (LPD3DTLVERTEX)lpPrim;
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    
    // since data is in the command buffer, we've already verified it as valid

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = LP_FVF_NXT_VTX(pv[1]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineListImm,0);
    
} // _D3D_R3_DP2_LineListImm

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineStrip
// 
// Render D3DDP2OP_LINESTRIP lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_LineStrip);

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);    

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount);

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];
        pv[1] = LP_FVF_NXT_VTX(pv[1]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineStrip,0);    
    
} // _D3D_R3_DP2_LineStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD primData, dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList);
    
    for( i = 0; i < dwPrimCount; i++ )
    {
        primData = *(DWORD *)lpPrim;
        dwIndex0 = ( primData >>  0 ) & 0xffff;
        dwIndex1 = ( primData >> 16 );

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);        

        lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList,0);
    
} // _D3D_R3_DP2_IndexedLineList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList2
// 
// Render D3DDP2OP_INDEXEDLINELIST2 lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList2( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD primData, i;
    WORD wVStart, dwIndex0, dwIndex1;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList2);    

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    for( i = 0; i < dwPrimCount; i++ )
    {
        primData = *(DWORD *)lpPrim;
        dwIndex0 = ( (WORD)(primData >>  0) ) & 0xffff;
        dwIndex1 = ( (WORD)(primData >> 16) );

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0 + wVStart);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1 + wVStart);        

        lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList2,0);  
    
} // _D3D_R3_DP2_IndexedLineList2

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart, dwIndex, *pwIndx;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip);      

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);
    pwIndx = (WORD *)lpPrim;

    dwIndex = *pwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);        

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];       
    }
 
    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip

//-----------------------------------------------------------------------------
//
// __ProcessPoints
// 
// Render a set points specified by adjacent FVF vertices
//
//-----------------------------------------------------------------------------
void
__ProcessPoints(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[],
    DWORD dwCount)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    DWORD q[1];
    TEXCOORDS tc[1];
    ULONG renderCmd = pContext->RenderCommand;
    DWORD j;
    D3DTLVERTEX *ptmpV;

    P3_DMA_DEFS();

    ptmpV = pv[0];
    
    RENDER_LINE(renderCmd);   

    q[0] = 0;
    
    for( j = 0; j < dwCount; j++ )
    {
        P3_DMA_GET_BUFFER_ENTRIES( 20 );

        GET_TC(0);

        if( Flags & SURFACE_PERSPCORRECT )
        {
            q[0] = *(DWORD *)&(pv[0]->rhw);

            SCALE_BY_Q( 0 );
        }

        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(V0FloatS_Tag, 0, FALSE);
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(V1FloatS_Tag, 0, TRUE);

        DRAW_LINE();

        P3_DMA_COMMIT_BUFFER();
        
        pv[0] = LP_FVF_NXT_VTX(pv[0]);           
    }

    pv[0] = ptmpV;

} // __ProcessPoints

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_Points
// 
// Render D3DDP2OP_POINTS points
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_Points( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart, wCount;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_Points);      

    for( i = 0; i < dwPrimCount; i++ )
    {
        wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
        wCount = ((D3DHAL_DP2POINTS*)lpPrim)->wCount;
        lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

        // Check first & last vertex
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + wCount - 1);

        pv[0] = LP_FVF_VERTEX(lpVertices, 0);
        __ProcessPoints(pContext, pv, wCount);

        lpPrim += sizeof(D3DHAL_DP2POINTS);
    }

    DBG_EXIT(_D3D_R3_DP2_Points,0);       

} // _D3D_R3_DP2_Points

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_Points_DWCount
// 
// Render D3DDP2OP_POINTS points for DX8 case
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_Points_DWCount( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_Points_DWCount);      

    wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount - 1);

    pv[0] = LP_FVF_VERTEX(lpVertices, 0);
    __ProcessPoints(pContext, pv, dwPrimCount);

    DBG_EXIT(_D3D_R3_DP2_Points_DWCount,0);       

} // _D3D_R3_DP2_Points_DWCount

#if DX8_POINTSPRITES

#define SPRITETEXCOORDMAX 1.0f

//Size of maximum FVF that we can get. Used for temporary storage
typedef BYTE P3FVFMAXVERTEX[ 3 * sizeof( D3DVALUE ) +    // Position coordinates
                             5 * 4                  +    // D3DFVF_XYZB5
                                 sizeof( D3DVALUE ) +    // FVF_TRANSFORMED
                             3 * sizeof( D3DVALUE ) +    // Normals
                                 sizeof( DWORD )    +    // RESERVED1
                                 sizeof( DWORD )    +    // Diffuse color
                                 sizeof( D3DCOLOR ) +    // Specular color
                                 sizeof( D3DVALUE ) +    // Point sprite size
                             4 * 8 * sizeof( D3DVALUE )  // 8 sets of 4D texture coordinates
                           ];

//-----------------------------------------------------------------------------
//
// __Render_One_PointSprite
//
// Render a point sprite with FVF vertexes when the point sprite enable is on
//
// Note: this is not the most optimized implementation possible for 
//       pointprites on this hw. We are merely following the definition.
//       Later implementation will be optimized.
//-----------------------------------------------------------------------------
void
__Render_One_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *lpVertex)
{
    P3FVFMAXVERTEX fvfVUL, fvfVUR, fvfVLL, fvfVLR ;
    D3DVALUE fPntSize, fPntSizeHalf, fD2, fD, fScalePntSize, fFac;
    D3DTLVERTEX *pv[3];
    FVFOFFSETS OrigFVF;
    BOOL bTexturingWOTexCoords = FALSE;
    SAVE_CULLING_STATE(pContext);

    DBG_ENTRY(__Render_One_PointSprite);          

    // Get point sprite size , if FVF data comes with it, grab it from there
    if (pContext->FVFData.dwPntSizeOffset)
    {
        fPntSize = FVFPSIZE(lpVertex)->psize;
        DISPDBG((DBGLVL,"FVF Data fPntSize = %d",(LONG)(fPntSize*1000.0f) ));
    }
    else
    {
        fPntSize = pContext->PntSprite.fSize;
        DISPDBG((DBGLVL,"RS fPntSize = %d",(LONG)(fPntSize*1000.0f) ));        
    }

    // We don't need to compute the point size according to the scale
    // factors and viewport size, etc as we are not a TnL driver.
    // See the spec for deatils

    // Clamp fPntSize to limits defined by the driver caps (dvMaxPointSize)
    // and the D3DRS_POINTSIZE_MIN and D3DRS_POINTSIZE_MAX renderstates
    fPntSize = max(pContext->PntSprite.fSizeMin, 
                   fPntSize);
                   
    fPntSize = min( min(pContext->PntSprite.fSizeMax, 
                        P3_MAX_POINTSPRITE_SIZE), 
                    fPntSize);           

    // Divide by 2 to get the amount by which to modify vertex coords
    fPntSizeHalf =  fPntSize * 0.5f;

    // Initialize square vertex values
    memcpy( &fvfVUL, lpVertex, pContext->FVFData.dwStride);
    memcpy( &fvfVUR, lpVertex, pContext->FVFData.dwStride);
    memcpy( &fvfVLL, lpVertex, pContext->FVFData.dwStride);
    memcpy( &fvfVLR, lpVertex, pContext->FVFData.dwStride);

    // Make this a square of size fPntSize
    ((D3DTLVERTEX *)&fvfVUL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUL)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVUR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUR)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLL)->sy += fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLR)->sy += fPntSizeHalf;

    // This is for the case in which PntSprite.bEnabled is false
    // and we are texturing even if we have no tex  coord data in 
    // the pointsprite vertexes
    bTexturingWOTexCoords = (pContext->FVFData.dwNonTexStride == 
                              pContext->FVFData.dwStride )
                          && (!pContext->bTexDisabled);

    if (pContext->PntSprite.bEnabled || bTexturingWOTexCoords)  
    {
        // Remember orig FVF offsets in order to fake our own texcoords
        OrigFVF = pContext->FVFData;
    
        // We "create" new texturing info in our data in order to
        // process vertexes even without texturing coord info
        // This is OK since we are using P3FVFMAXVERTEX as the type
        // of our temporary data structures for each vertex so we
        // can't overflow.

        // If stage 0 texture is used
        pContext->FVFData.dwTexCount = 1;
        pContext->FVFData.dwTexOffset[0] =
        pContext->FVFData.dwTexCoordOffset[0] = 
                        pContext->FVFData.dwNonTexStride;
                        
        // If stage 1 texture is used
        // we can use the same tex coord set since they are equal
        pContext->FVFData.dwTexOffset[1] =
                    pContext->FVFData.dwTexCoordOffset[0];

        if (pContext->PntSprite.bEnabled)
        {
            // Set up texture coordinates according to spec 
            FVFTEX(&fvfVUL, 0)->tu = 0.0f;
            FVFTEX(&fvfVUL, 0)->tv = 0.0f;
           
            FVFTEX(&fvfVUR, 0)->tu = SPRITETEXCOORDMAX;
            FVFTEX(&fvfVUR, 0)->tv = 0.0f;
            
            FVFTEX(&fvfVLL, 0)->tu = 0.0f;
            FVFTEX(&fvfVLL, 0)->tv = SPRITETEXCOORDMAX;
            
            FVFTEX(&fvfVLR, 0)->tu = SPRITETEXCOORDMAX;
            FVFTEX(&fvfVLR, 0)->tv = SPRITETEXCOORDMAX;  
        }
        else
        {
            // if we got here then PntSprite.bEnabled is false 
            // so just make the tex coords == (0,0)
            FVFTEX(&fvfVUL, 0)->tu = 0.0f;
            FVFTEX(&fvfVUL, 0)->tv = 0.0f;
           
            FVFTEX(&fvfVUR, 0)->tu = 0.0f;
            FVFTEX(&fvfVUR, 0)->tv = 0.0f;
            
            FVFTEX(&fvfVLL, 0)->tu = 0.0f;
            FVFTEX(&fvfVLL, 0)->tv = 0.0f;
            
            FVFTEX(&fvfVLR, 0)->tu = 0.0f;
            FVFTEX(&fvfVLR, 0)->tv = 0.0f;           
        }

#if DX8_3DTEXTURES        
        // Allow for the case of 3D texturing
        FVFTEX(&fvfVUL, 0)->tw = 0.0f;    
        FVFTEX(&fvfVUR, 0)->tw = 0.0f;  
        FVFTEX(&fvfVLL, 0)->tw = 0.0f;          
        FVFTEX(&fvfVLR, 0)->tw = 0.0f;          
#endif        
    } 

   // Make sure Culling doesn't prevent pointsprites from rendering
   SET_CULLING_TO_NONE(pContext);  // culling state was previously saved

   // here we are going to send the required quad
   pv[0] = (D3DTLVERTEX*)&fvfVUL;
   pv[1] = (D3DTLVERTEX*)&fvfVUR;
   pv[2] = (D3DTLVERTEX*)&fvfVLL;
    __ProcessTri_3Vtx_Generic(pContext, pv, ALL_SIDES);

   pv[0] = (D3DTLVERTEX*)&fvfVLL;
   pv[1] = (D3DTLVERTEX*)&fvfVUR;
   pv[2] = (D3DTLVERTEX*)&fvfVLR;
    __ProcessTri_3Vtx_Generic(pContext, pv, ALL_SIDES); 

   // Restore original Culling settings
   RESTORE_CULLING_STATE(pContext);

   // Restore original FVF offsets 
   if (pContext->PntSprite.bEnabled || bTexturingWOTexCoords)     
   {
       pContext->FVFData = OrigFVF;
   }

   DBG_EXIT(__Render_One_PointSprite, 0);    
    
} // __Render_One_PointSprite

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_PointSprite
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_PointSprite"));
    return 1;
} // __ProcessTri_1Vtx_PointSprite


//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_PointSprite
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    __Render_One_PointSprite(pContext, pv[0]);
    __Render_One_PointSprite(pContext, pv[1]);
    __Render_One_PointSprite(pContext, pv[2]);    

    return 1;    
} // __ProcessTri_3Vtx_PointSprite

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_PointsSprite_DWCount
// 
// Render D3DDP2OP_POINTS points sprites
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_PointsSprite_DWCount( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart;
    DWORD j;

    DBG_ENTRY(_D3D_R3_DP2_PointsSprite_DWCount);      

    wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount - 1);

    pContext->dwProvokingVertex = 0;
    
    for( j = 0; j < dwPrimCount; j++ )
    {
        pv[0] = LP_FVF_VERTEX(lpVertices, j);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        __Render_One_PointSprite(pContext, pv[0]);           
    }

    DBG_EXIT(_D3D_R3_DP2_PointsSprite_DWCount,0);       


} // _D3D_R3_DP2_PointsSprite_DWCount

#endif // DX8_POINTSPRITES

#if DX8_MULTSTREAMS


// Macro to render a single triangle depending on the current Fillmode. 
// Notice that for proper line rendering we require one more element in pv (4)
#define RENDER_ONE_TRIANGLE_CYCLE(pContext, dwFillMode, pv, bVtxInvalid, vtx_a)\
{                                                                            \
    if (dwFillMode == D3DFILL_SOLID)                                         \
    {                                                                        \
        if( bVtxInvalid )                                                    \
            bVtxInvalid = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);    \
        else                                                                 \
            bVtxInvalid = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );          \
    }                                                                        \
    else if (dwFillMode == D3DFILL_WIREFRAME)                                \
    {                                                                        \
        if(!__BackfaceCullNoTexture( pContext, pv ))                         \
        {                                                                    \
            pv[3] = pv[0];                                                   \
            __ProcessLine(pContext, &pv[0], pv[pContext->dwProvokingVertex]);\
            __ProcessLine(pContext, &pv[1], pv[pContext->dwProvokingVertex]);\
            __ProcessLine(pContext, &pv[2], pv[pContext->dwProvokingVertex]);\
        }                                                                    \
    }                                                                        \
    else                                                                     \
/*#if DX8_POINTSPRITES*/                                                     \
    if(IS_POINTSPRITE_ACTIVE(pContext))                                      \
    {                                                                        \
        __ProcessTri_3Vtx_PointSprite( pContext, pv, ALL_SIDES );        \
    }                                                                        \
    else                                                                     \
/*#endif*/                                                                   \
    {                                                                        \
        if(!__BackfaceCullNoTexture( pContext, pv ))                         \
        {                                                                    \
            __ProcessPoints( pContext, &pv[0], 1);                           \
            __ProcessPoints( pContext, &pv[1], 1);                           \
            __ProcessPoints( pContext, &pv[2], 1);                           \
        }                                                                    \
    }                                                                        \
}

#define INIT_RENDER_ONE_TRIANGLE(pContext, dwFillMode, pv,VtxInvalid) \
{                                                       \
    int vtx_a_local = 0;                                \
    VtxInvalid= 1;                                      \
    RENDER_ONE_TRIANGLE_CYCLE(pContext,                 \
                              dwFillMode,               \
                              pv,                       \
                              VtxInvalid,               \
                              vtx_a_local);             \
}

#define RENDER_ONE_TRIANGLE(pContext, dwFillMode, pv)   \
{                                                       \
    int vtx_a = 0, VtxInvalid= 1;                       \
    RENDER_ONE_TRIANGLE_CYCLE(pContext,                 \
                              dwFillMode,               \
                              pv,                       \
                              VtxInvalid,               \
                              vtx_a);                   \
}

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList_MS_16IND
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD *pwIndx;
    DWORD dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList_MS_16IND);
    
    pwIndx = (WORD *)lpPrim;

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pwIndx++;
        dwIndex1 = *pwIndx++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  

        __ProcessLine( pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList_MS_16IND,0);
    
} // _D3D_R3_DP2_IndexedLineList_MS_16IND



//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip_MS_16IND
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD dwIndex, i;
    WORD *pwIndx;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip_MS_32IND);      

    pwIndx = (WORD *)lpPrim;
    
    dwIndex = *pwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];        
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip_MS_16IND,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles 
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList_MS_16IND); 

    DISPDBG((DBGLVL,"pContext = 0x%x dwPrimCount=%d lpPrim=0x%x lpVertices=0x%x "
               "IdxOffset=%d dwVertexBufferLen=%d ",
               pContext,(DWORD)dwPrimCount,lpPrim,lpVertices,
               IdxOffset, dwVertexBufferLen));
               

    pwIndexData = (WORD *)lpPrim;

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pwIndexData++;
        dwIndex1 = *pwIndexData++;
        dwIndex2 = *pwIndexData++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);  

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv);    
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList_MS_16IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles 
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    int  vtx_a, vtx_b, bCulled;
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];  
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND); 

    pwIndexData = (WORD *)lpPrim;    

    dwIndex0 = *pwIndexData++;
    dwIndex1 = *pwIndexData++;
    dwIndex2 = *pwIndexData++;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pwIndexData++;
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);            

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx_a); 
            
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles in  
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    int  vtx, lastVtx, bCulled;
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan_MS_16IND);     

    pwIndexData = (WORD *)lpPrim;
    
    dwIndex0 = *pwIndexData++;
    dwIndex1 = *pwIndexData++;
    dwIndex2 = *pwIndexData++;

    lastVtx = vtx = 2;
    
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pwIndexData++;
        pv[vtx] = LP_FVF_VERTEX(lpVertices, dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx);            

        lastVtx = vtx;

    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan_MS_16IND,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList_MS_32IND
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD *pdwIndx, dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList_MS_32IND);
    
    pdwIndx = (DWORD *)lpPrim;

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pdwIndx++;
        dwIndex1 = *pdwIndx++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);        

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList_MS_32IND,0);
    
} // _D3D_R3_DP2_IndexedLineList_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip_MS_32IND
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD dwIndex, *pdwIndx, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip_MS_32IND);      

    pdwIndx = (DWORD *)lpPrim;

    dwIndex = *pdwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pdwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);        

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip_MS_32IND,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip_MS_32IND

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, *pdwIndexData, i;
    D3DTLVERTEX *pv[4];
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList_MS_32IND); 

    DISPDBG((DBGLVL,"pContext = 0x%x dwPrimCount=%d lpPrim=0x%x lpVertices=0x%x "
               "IdxOffset=%d dwVertexBufferLen=%d ",
               pContext,(DWORD)dwPrimCount,lpPrim,lpVertices,IdxOffset,
               dwVertexBufferLen));
               

    pdwIndexData = (DWORD *)lpPrim;

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pdwIndexData++;
        dwIndex1 = *pdwIndexData++;
        dwIndex2 = *pdwIndexData++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);  

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv);         
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList_MS_32IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, *pdwIndexData;
    D3DTLVERTEX *pv[4];
    int vtx_a, vtx_b, bCulled;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];   
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND); 

    pdwIndexData = (DWORD *)lpPrim;    

    dwIndex0 = *pdwIndexData++;
    dwIndex1 = *pdwIndexData++;
    dwIndex2 = *pdwIndexData++;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pdwIndexData++;
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);            
        
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx_a);               
            
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, *pdwIndexData;
    D3DTLVERTEX *pv[4];
    int  vtx, lastVtx, bCulled;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan_MS_32IND);     

    pdwIndexData = (DWORD *)lpPrim;
    
    dwIndex0 = *pdwIndexData++;
    dwIndex1 = *pdwIndexData++;
    dwIndex2 = *pdwIndexData++;

    lastVtx = vtx = 2;
    
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pdwIndexData++;
        pv[vtx] = LP_FVF_VERTEX(lpVertices, dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx);   

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan_MS_32IND,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan_MS_32IND

#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_R3_PickVertexProcessor
//
// Pick appropriate triangle rendering functions based on texturing
//
//-----------------------------------------------------------------------------
void
_D3D_R3_PickVertexProcessor( 
    P3_D3DCONTEXT *pContext )
{
    DWORD Flags = pContext->Flags;

    DBG_ENTRY(_D3D_R3_PickVertexProcessor); 

    if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
    {
        // Wireframe mode renderers
        pContext->pRendTri_1V    = __ProcessTri_1Vtx_Wire;  
        pContext->pRendTri_3V = __ProcessTri_3Vtx_Wire;    
    }
    else if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT)
    {
#if DX8_DDI
        if(IS_POINTSPRITE_ACTIVE(pContext))
        {
            // Point sprite mode renderers    
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_PointSprite;  
            pContext->pRendTri_3V = __ProcessTri_3Vtx_PointSprite;      
        }
        else
#endif
        {
            // Point mode renderers    
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Point;  
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Point;      
        }
    }
    else
#if !defined(_WIN64)    
    // We avoid this path in IA64 as something is wrongly fed into the chip
    if( ( Flags & SURFACE_PERSPCORRECT ) && 
              ( Flags & SURFACE_GOURAUD )      && 
              (pContext->bTex0Valid)           && 
              (!pContext->bTex1Valid)           )
    {
        // Solid mode renderes for single textured-gouraud shaded-persp corr 
        if(( pContext->RenderStates[D3DRENDERSTATE_WRAP0] )
                        || ( pContext->RenderStates[D3DRENDERSTATE_WRAP1] ))
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Generic;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Generic;
        }
        else
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_PerspSingleTexGouraud;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_PerspSingleTexGouraud;
        }
    }
    else
#endif !defined(_WIN64)    
    {
        // Solid mode renderers for textured triangles    
        if( pContext->bTex0Valid || pContext->bTex1Valid )
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Generic;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Generic;
        }
        else
        {
        // Solid mode renderers for non-textured triangles           
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_NoTexture;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_NoTexture;
        }
    }


    


    DBG_EXIT(_D3D_R3_PickVertexProcessor,0); 
    
} // _D3D_R3_PickVertexProcessor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstate.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstate.c
*
* Content: D3D renderstates and texture stage states translation
*          into hardware specific settings.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------Public Routine----------------------------------
//
// D3DGetDriverState
//
// This callback is used by both the DirectDraw and Direct3D runtimes to obtain 
// information from the driver about its current state.
// NOTE: We need to hook up this callback even if we don't do anything in it
//
// Parameter
//
//      pgdsd 
//          Pointer to a DD_GETDRIVERSTATEDATA structure. 
//
//          .dwFlags 
//              Flags to indicate the data requested. 
//          .lpDD 
//              Pointer to a DD_DIRECTDRAW_GLOBAL structure describing the device. 
//          .dwhContext 
//              Specifies the ID of the context for which information is being 
//              requested. 
//          .lpdwStates 
//              Pointer to the Direct3D driver state data to be filled in by the 
//              driver. 
//          .dwLength 
//              Specifies the length of the state data to be filled in by the 
//              driver. 
//          .ddRVal 
//              Specifies the return value. 
//
//
// Note: If you're driver doesn't implement this callback it won't be 
//       recognized as a DX7 level driver
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DGetDriverState(
    LPDDHAL_GETDRIVERSTATEDATA pgdsd)
{
    P3_D3DCONTEXT*   pContext;

    DBG_CB_ENTRY(D3DGetDriverState);    

#if DX7_TEXMANAGEMENT_STATS
    if (pgdsd->dwFlags == D3DDEVINFOID_TEXTUREMANAGER)
    {
    
        if (pgdsd->dwLength < sizeof(D3DDEVINFO_TEXTUREMANAGER))
        {
            DISPDBG((ERRLVL,"D3DGetDriverState dwLength=%d is not sufficient",
                            pgdsd->dwLength));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        pContext = _D3D_CTX_HandleToPtr(pgdsd->dwhContext);

        // Check if we got a valid context handle.
        if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
        {
            pgdsd->ddRVal = D3DHAL_CONTEXT_BAD;
            DISPDBG((ERRLVL,"ERROR: Context not valid"));
            DBG_CB_EXIT(D3DGetDriverState, D3DHAL_CONTEXT_BAD);
            return (DDHAL_DRIVER_HANDLED);
        }
        // As the state buffer area lives in user memory, we need to
        // access it bracketing it with a try/except block. This
        // is because the user memory might under some circumstances
        // become invalid while the driver is running and then it
        // would AV. Also, the driver might need to do some cleanup
        // before returning to the OS.
        __try
        {
            _D3D_TM_STAT_GetStats(pContext,
                                  (LPD3DDEVINFO_TEXTUREMANAGER)pgdsd->lpdwStates);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // On this driver we don't need to do anything special
            DISPDBG((ERRLVL,"Driver caused exception at "
                            "line %u of file %s",
                            __LINE__,__FILE__));
            pgdsd->ddRVal = DDERR_GENERIC;    
            DBG_CB_EXIT(D3DGetDriverState,0);         
            return DDHAL_DRIVER_NOTHANDLED; 
        } 

        pgdsd->ddRVal = DD_OK;            
        
        DBG_CB_EXIT(D3DGetDriverState,0);         
        return DDHAL_DRIVER_HANDLED;         
    }
                          
#endif // DX7_TEXMANAGEMENT_STATS

    // Fall trough for any unhandled DEVICEINFOID's
    
    DISPDBG((ERRLVL,"D3DGetDriverState DEVICEINFOID=%08lx not supported",
                    pgdsd->dwFlags));

    pgdsd->ddRVal = DDERR_UNSUPPORTED;

    DBG_CB_EXIT(D3DGetDriverState,0);                     
    return DDHAL_DRIVER_NOTHANDLED;
    
} // D3DGetDriverState

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// _D3D_ST_CanRenderAntialiased
//
// Called when the D3DRENDERSTATE_ANTIALIAS RS is set to TRUE.
//
//-----------------------------------------------------------------------------
BOOL
_D3D_ST_CanRenderAntialiased(
    P3_D3DCONTEXT*   pContext,
    BOOL             bNewAliasBuffer)
{
    P3_SOFTWARECOPY* pSoftPermedia = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    P3_MEMREQUEST mmrq;
    DWORD dwResult;

    P3_DMA_DEFS();

#if DX8_MULTISAMPLING
    // Only 4 multisampling is supported
    // And DX7 does not specifiy the number of samples.

    if (pContext->pSurfRenderInt->dwSampling != 4)
    {
        return FALSE;
    }
#endif // DX8_MULTISAMPLING

    // Only allow AA rendering for 16-bit framebuffers with width and
    // height no larger than 1024. The size restriction comes because
    // later on we use the texture unit in order to shrink and filter
    // the resulting rendertarget. Since the maximum texture size
    // allowed in this hw is 2048, the maximum rendertarget we suppport
    // with antialiasing is 1024.
    if ((pContext->pSurfRenderInt->dwPixelSize != __GLINT_16BITPIXEL) ||
        (pContext->pSurfRenderInt->wWidth > 1024) ||
        (pContext->pSurfRenderInt->wHeight > 1024))
    {
        return FALSE;
    }

    // Do we need to release the current alias buffer
    if (bNewAliasBuffer) 
    {
        if (pContext->dwAliasBackBuffer != 0)
        {
            _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info,
                                     pContext->dwAliasBackBuffer);
            pContext->dwAliasBackBuffer = 0;
            pContext->dwAliasPixelOffset = 0;
        }
    
        if (pContext->dwAliasZBuffer != 0)
        {
            _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info,
                                     pContext->dwAliasZBuffer);
            pContext->dwAliasZBuffer = 0;
            pContext->dwAliasZPixelOffset = 0;
        }
    }

    if ((pContext->pSurfRenderInt) && (! pContext->dwAliasBackBuffer))
    {
        // Allocate a 2x buffer if we need to
        memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwBytes = pContext->pSurfRenderInt->lPitch * 2 *
                       pContext->pSurfRenderInt->wHeight * 2;
        mmrq.dwAlign = 8;
        mmrq.dwFlags = MEM3DL_FIRST_FIT;
        mmrq.dwFlags |= MEM3DL_FRONT;
        dwResult = _DX_LIN_AllocateLinearMemory(
                                &pThisDisplay->LocalVideoHeap0Info,
                                &mmrq);
                        
        // Did we get the memory we asked for?
        if (dwResult != GLDD_SUCCESS)
        {
            return FALSE;
        }
    
        // Set up new backbuffer for antialiasing
        pContext->dwAliasBackBuffer = mmrq.pMem;
        pContext->dwAliasPixelOffset = 
                pContext->dwAliasBackBuffer - 
                pThisDisplay->dwScreenFlatAddr;
    }

    if ((pContext->pSurfZBufferInt) && (! pContext->dwAliasZBuffer))
    {
        memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwBytes = pContext->pSurfZBufferInt->lPitch * 2 * 
                       pContext->pSurfZBufferInt->wHeight * 2;
        mmrq.dwAlign = 8;
        mmrq.dwFlags = MEM3DL_FIRST_FIT;
        mmrq.dwFlags |= MEM3DL_FRONT;

        dwResult = _DX_LIN_AllocateLinearMemory(
                        &pThisDisplay->LocalVideoHeap0Info, 
                        &mmrq);

        // Did we get the memory we asked for?
        if (dwResult == GLDD_SUCCESS)
        {
            pContext->dwAliasZBuffer = mmrq.pMem;
            pContext->dwAliasZPixelOffset = 
                        pContext->dwAliasZBuffer
                            - pThisDisplay->dwScreenFlatAddr;
        }
        else
        {
            // Couldn't get the antialiasing memory for the backbuffer
            if (pContext->dwAliasBackBuffer != 0)
            {
                _DX_LIN_FreeLinearMemory(
                            &pThisDisplay->LocalVideoHeap0Info, 
                            pContext->dwAliasBackBuffer);
                pContext->dwAliasBackBuffer = 0;
                pContext->dwAliasPixelOffset = 0;
            }

            // No enough resource for antialisde rendering
            return FALSE;
        }
    }

    return TRUE;
    
} // _D3D_ST_CanRenderAntialiased
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

//-----------------------------------------------------------------------------
//
// __ST_HandleDirtyP3State
//
// Setup any pending hardware state necessary to correctly render our primitives
//
//-----------------------------------------------------------------------------
void 
__ST_HandleDirtyP3State(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_D3DCONTEXT *pContext)
{
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    DISPDBG((DBGLVL,"Permedia context Dirtied, setting states:"));

    // ********************************************************************
    // NOTE: MAINTAIN STRICT ORDERING OF THESE EVALUATIONS FOR HW REASONS!!
    // ********************************************************************
    if (pContext->dwDirtyFlags == CONTEXT_DIRTY_EVERYTHING)
    {
        // Everything needs re-doing - re-set the blend status.
        RESET_BLEND_ERROR(pContext);
    }
    
    //*********************************************************
    // Has the z buffer/stencil buffer configuration changed ???
    //*********************************************************
    if ((pContext->dwDirtyFlags & CONTEXT_DIRTY_ZBUFFER) ||
        (pContext->dwDirtyFlags & CONTEXT_DIRTY_STENCIL))
    {

        if ( ( (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
               || (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) )
             && (pContext->pSurfZBufferInt) )
        {
            // This includes W buffering as well as Z buffering.
            // The actual W-specific stuff is set up later.
            if (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE] == TRUE)
            {
                switch ((int)pSoftP3RX->P3RXDepthMode.CompareMode)
                {
                    case __GLINT_DEPTH_COMPARE_MODE_ALWAYS:
                        // Although it seems as though the ReadDestination can be
                        // disabled, it can't.  The result isn't correct because the
                        // chip does a compare on the current value as an optimization
                        // for updating the Z [CM].

                        // NOTE! The P3 can actually do the optimisation if you
                        // use some other flags. This needs fixing in the future.
                        DISPDBG((ERRLVL,"** __ST_HandleDirtyP3State: "
                                     "please optimise the ZCMP_ALWAYS case"));

                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
                        break;
                    case __GLINT_DEPTH_COMPARE_MODE_NEVER:
                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;
                        break;
                    default:
                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
                        break;
                }
            }
            else
            {
                if ( ( pSoftP3RX->P3RXDepthMode.CompareMode == __GLINT_DEPTH_COMPARE_MODE_NEVER )
                  || ( pSoftP3RX->P3RXDepthMode.CompareMode == __GLINT_DEPTH_COMPARE_MODE_ALWAYS ) )
                {
                    pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
                }
                else
                {
                    pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                }
                pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;
            }

            // Enable Z test
            pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_ENABLE;
        }
        else
        {
            // ** Not Z Buffering
            // Disable Writes
            pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;

            // Disable Z test
            pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_DISABLE;
            
            // No reads
            pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
        }

        if (pContext->RenderStates[D3DRENDERSTATE_STENCILENABLE] != TRUE)
        {
            DISPDBG((DBGLVL,"Disabling Stencil"));
            pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_DISABLE;

        }
        else
        {
            DISPDBG((DBGLVL,"Enabling Stencil"));
            pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILFAIL])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILFAIL!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILZFAIL])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILZFAIL!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILPASS])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILPASS!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch (pContext->RenderStates[D3DRENDERSTATE_STENCILFUNC])
            {
                case D3DCMP_NEVER:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_LESS:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_EQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_LESSEQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_GREATER:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_NOTEQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_GREATEREQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_ALWAYS;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown D3DRENDERSTATE_STENCILFUNC!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            pSoftP3RX->P3RXStencilData.StencilWriteMask = (pContext->RenderStates[D3DRENDERSTATE_STENCILWRITEMASK] & 0xFF);
            pSoftP3RX->P3RXStencilData.CompareMask = (pContext->RenderStates[D3DRENDERSTATE_STENCILMASK] & 0xFF);
            pSoftP3RX->P3RXStencilData.ReferenceValue = (pContext->RenderStates[D3DRENDERSTATE_STENCILREF] & 0xFF);
        }

        P3_DMA_GET_BUFFER();
        P3_ENSURE_DX_SPACE(32);

        WAIT_FIFO(32);

        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
        COPY_P3_DATA(LBDestReadMode, pSoftP3RX->P3RXLBDestReadMode);
        COPY_P3_DATA(LBWriteMode, pSoftP3RX->P3RXLBWriteMode);
        COPY_P3_DATA(LBReadFormat, pSoftP3RX->P3RXLBReadFormat);
        COPY_P3_DATA(LBWriteFormat, pSoftP3RX->P3RXLBWriteFormat);
        COPY_P3_DATA(StencilData, pSoftP3RX->P3RXStencilData);
        COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Has the alphatest type changed?
    //*********************************************************
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHATEST)
    {
        DISPDBG((DBGLVL,"  Alpha testing"));

        P3_DMA_GET_BUFFER();
        P3_ENSURE_DX_SPACE(2);

        WAIT_FIFO(2);
        
        if (pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE] == FALSE)
        {
            pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_DISABLE;
            DISPDBG((DBGLVL,"Alpha test disabled, ChromaTest = %d",
                            pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE] ));
        }
        else
        {
            unsigned char ucChipAlphaRef;
            DWORD dwAlphaRef;

            if( pThisDisplay->dwDXVersion <= DX5_RUNTIME )
            {
                // Form 8 bit alpha reference value by scaling 1.16 fixed point to 0.8
                dwAlphaRef = pContext->RenderStates[D3DRENDERSTATE_ALPHAREF];

                // This conversion may need tweaking to cope with individual
                // apps' expectations. Fortunately, it's DX5 only, so there
                // are a finite number of them.
                if ( dwAlphaRef == 0x0000 )
                {
                    ucChipAlphaRef = 0x00;
                }
                else if ( dwAlphaRef < 0xfe00 )
                {
                    // Add the inverted top char to the bottom char, so that
                    // the rounding changes smoothly all the way up to 0xfe00.
                    dwAlphaRef += ~( dwAlphaRef >> 8 );
                    ucChipAlphaRef = (unsigned char)( dwAlphaRef >> 8 );
                }
                else if ( dwAlphaRef < 0xffff )
                {
                    // Clamp to make sure only 0xffff -> 0xff
                    ucChipAlphaRef = 0xfe;
                }
                else
                {
                    ucChipAlphaRef = 0xff;
                }

                DISPDBG((DBGLVL,"Alpha test enabled: Value = 0x%x, ChipAlphaRef = 0x%x",
                           pContext->RenderStates[D3DRENDERSTATE_ALPHAREF], 
                           ucChipAlphaRef ));
            }
            else
            {
                // ALPHAREF is an 8 bit value on input - just copy straight into the chip
                dwAlphaRef = (unsigned char)pContext->RenderStates[D3DRENDERSTATE_ALPHAREF];
                if ( dwAlphaRef > 0xff )
                {
                    ucChipAlphaRef = 0xff;
                }
                else
                {
                    ucChipAlphaRef = (unsigned char)dwAlphaRef;
                }

                DISPDBG((DBGLVL,"Alpha test enabled: AlphaRef = 0x%x", ucChipAlphaRef ));
            }

            pSoftP3RX->P3RXAlphaTestMode.Reference = ucChipAlphaRef;
            pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_ENABLE;
            switch (pContext->RenderStates[D3DRENDERSTATE_ALPHAFUNC])
            {
                case D3DCMP_GREATER:
                    DISPDBG((DBGLVL,"GREATER Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_GREATEREQUAL:
                    DISPDBG((DBGLVL,"GREATEREQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_LESS:
                    DISPDBG((DBGLVL,"LESS Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_LESSEQUAL:
                    DISPDBG((DBGLVL,"LESSEQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_NOTEQUAL:
                    DISPDBG((DBGLVL,"NOTEQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_EQUAL:
                    DISPDBG((DBGLVL,"EQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_NEVER:
                    DISPDBG((DBGLVL,"NEVER Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_ALWAYS;
                    break;
                default:
                    DISPDBG((ERRLVL,"Unsuported AlphaTest mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
        }
        COPY_P3_DATA(AlphaTestMode, pSoftP3RX->P3RXAlphaTestMode);

        P3_DMA_COMMIT_BUFFER();
    }
            
    //*********************************************************
    // Have the fogging parameters/state changed?
    //*********************************************************
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_FOG)
    {
        if (!pContext->RenderStates[D3DRENDERSTATE_FOGENABLE])
        {
            pContext->Flags &= ~SURFACE_FOGENABLE;

            pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
            // Don't need delta to do fog value setup
            pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;
            RENDER_FOG_DISABLE(pContext->RenderCommand);
        }
        else
        {
            DWORD CurrentEntry;
            DWORD TableEntry;
            float fEntry[256];
            float FogStart;
            float FogEnd;
            float FogDensity;
            LONG  lWaitFifoEntries;
            float fValue;
            float z;
            float zIncrement;
            DWORD dwFogTableMode = 
                        pContext->RenderStates[D3DRENDERSTATE_FOGTABLEMODE];
            DWORD dwFogColor = pContext->RenderStates[D3DRENDERSTATE_FOGCOLOR];

            // Enable fog in the render command
            pContext->Flags |= SURFACE_FOGENABLE;
            RENDER_FOG_ENABLE(pContext->RenderCommand);

            DISPDBG((DBGLVL,"FogColor (BGR): 0x%x", dwFogColor));
            
            P3_DMA_GET_BUFFER_ENTRIES(2)
            SEND_P3_DATA(FogColor, RGBA_MAKE(RGBA_GETBLUE (dwFogColor),
                                             RGBA_GETGREEN(dwFogColor),
                                             RGBA_GETRED  (dwFogColor),
                                             RGBA_GETALPHA(dwFogColor)) );
            P3_DMA_COMMIT_BUFFER();

            pSoftP3RX->P3RXFogMode.ZShift = 23; // Take the top 8 bits of the z value           

            switch (dwFogTableMode)
            {
            case D3DFOG_NONE:
                pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_ENABLE;
                break;
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
                //pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;                

                // Don't need delta to do fog value setup (z is used as fog lookup)
                pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;

                FogStart = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLESTART];
                FogEnd = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEEND];
                FogDensity = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEDENSITY];

                DISPDBG((DBGLVL,"FogStart = %d FogEnd = %d FogDensity = %d",
                                  (LONG)(FogStart*1000.0f),
                                  (LONG)(FogEnd*1000.0f),
                                  (LONG)(FogDensity*1000.0f) ));                           

                // Compute the fog tables in order to load the hw fog tables
                if (D3DFOG_LINEAR == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;

                    do
                    {
                        // Linear fog, so clamp top and bottom
                        if (z < FogStart) 
                        {
                            fValue = 1.0f;
                        }
                        else if (z > FogEnd)
                        {
                            fValue = 0.0f;
                        }
                        else 
                        {
                            // If the end == the start, don't fog
                            if (FogEnd == FogStart)
                            {   
                                fValue = 1.0f;
                            }
                            else
                            {
                                fValue = (FogEnd - z) / (FogEnd - FogStart);
                            }
                            ASSERTDD(fValue <= 1.0f, 
                                     "Error: Result to big");
                            ASSERTDD(fValue >= 0.0f, 
                                     "Error: Result negative");
                        }

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);
                }
                else if (D3DFOG_EXP == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;
                    do
                    {
                        float fz;

                        fz = z * FogDensity;

                        fValue = myPow(math_e, -fz);
                                                        
                        if (fValue <= 0.0f) fValue = 0.0f;
                        if (fValue > 1.0f) fValue = 1.0f;

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        DISPDBG((DBGLVL,"Table Entry %d = %f, for Z = %f", 
                                        TableEntry, fValue, z));
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);                     
                }
                else // must be if(D3DFOG_EXP2 == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;
                    do
                    {
                        float fz;

                        fz = z * FogDensity;

                        fValue = myPow(math_e, -(fz * fz));
                                                        
                        if (fValue <= 0.0f) fValue = 0.0f;
                        if (fValue > 1.0f) fValue = 1.0f;

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        DISPDBG((DBGLVL,"Table Entry %d = %f, for Z = %f", 
                                        TableEntry, fValue, z));
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);                     
                }

                P3_DMA_GET_BUFFER();
                lWaitFifoEntries = 2;

                // Pack the fog entries into the chip's fog table
                CurrentEntry = 0;
                for (TableEntry = 0; TableEntry < 256; TableEntry += 4)
                {
                    DWORD Val[4];
                    DWORD dwValue;
                    myFtoi((int*)&Val[0], fEntry[TableEntry]);
                    myFtoi((int*)&Val[1], fEntry[TableEntry + 1]);
                    myFtoi((int*)&Val[2], fEntry[TableEntry + 2]);
                    myFtoi((int*)&Val[3], fEntry[TableEntry + 3]);
                    
                    lWaitFifoEntries -= 2;
                    if (lWaitFifoEntries < 2)
                    {
                        P3_ENSURE_DX_SPACE(32);
                        WAIT_FIFO(32);
                        lWaitFifoEntries += 32;
                    }

                    dwValue = ((Val[0]      ) | 
                               (Val[1] <<  8) | 
                               (Val[2] << 16) | 
                               (Val[3] << 24));                                  
                    
                    SEND_P3_DATA_OFFSET(FogTable0, 
                                        dwValue, 
                                        CurrentEntry++);                       
                }

                P3_DMA_COMMIT_BUFFER();
                break;
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown fog table mode!"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                break;
            } // switch (dwFogTableMode)
        } // if (!pContext->RenderStates[D3DRENDERSTATE_FOGENABLE])

        P3_DMA_GET_BUFFER_ENTRIES(6);

        SEND_P3_DATA(ZFogBias, 0);
        COPY_P3_DATA(FogMode, pSoftP3RX->P3RXFogMode);
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();
    } // if (pContext->dwDirtyFlags & CONTEXT_DIRTY_FOG)


    //*********************************************************
    // Has any other texture state changed?
    //*********************************************************    
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        DISPDBG((DBGLVL,"  Texture State"));
        _D3DChangeTextureP3RX(pContext);
        DIRTY_GAMMA_STATE;
    }


    //*********************************************************
    // Has the alphablend type changed?
    //*********************************************************           
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHABLEND)
    {
        // This _must_ be done after where _D3DChangeTextureP3RX is done,
        // because it might need to change behaviour depending on
        // the D3D pipeline.    
        
        P3_DMA_GET_BUFFER_ENTRIES(6);

        if (pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE] == FALSE)
        {
            if ( pContext->bAlphaBlendMustDoubleSourceColour )
            {
                // We need to double the source colour, even with no other blend.
                pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
            }
        }
        else
        {
            BOOL bSrcUsesDst, bSrcUsesSrc, bDstUsesSrc, bDstUsesDst;

            pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_ENABLE;

            if ( pContext->bAlphaBlendMustDoubleSourceColour )
            {
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_DISABLE;
            }

            pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceTimesTwo = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestTimesTwo = __PERMEDIA_DISABLE;

            // Assumptions. Will be overridden below in certain cases.
            // AusesB means that the A blend function uses the B data.
            bSrcUsesSrc = TRUE;
            bDstUsesSrc = FALSE;
            bSrcUsesDst = FALSE;
            bDstUsesDst = TRUE;

            switch (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND])
            {
                case D3DBLEND_BOTHSRCALPHA:
                    bDstUsesSrc = TRUE;
                    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    break;
                case D3DBLEND_BOTHINVSRCALPHA:
                    bDstUsesSrc = TRUE;
                    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    break;
                default:
                    // Not a short-hand blend mode, look at source and dest
                    switch (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND])
                    {
                        case D3DBLEND_ZERO:
                            bSrcUsesSrc = FALSE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ZERO;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ZERO;
                            break;
                        case D3DBLEND_SRCCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX D3DBLEND_SRCCOLOR"));
                        case D3DBLEND_INVSRCCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX D3DBLEND_INVSRCCOLOR"));
                            //azn SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_BLEND );
                            // fall through 
                        case D3DBLEND_ONE:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                            break;
                        case D3DBLEND_SRCALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            break;
                        case D3DBLEND_INVSRCALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            break;
                        case D3DBLEND_DESTALPHA:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_DST_ALPHA;                            
                            break;
                        case D3DBLEND_INVDESTALPHA:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            break;
                        case D3DBLEND_DESTCOLOR:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_DST_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_DST_COLOR;
                            break;
                        case D3DBLEND_INVDESTCOLOR:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR;
                            break;
                        case D3DBLEND_SRCALPHASAT:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE;
                            break;
                        default:
                            DISPDBG((ERRLVL,"Unknown Source Blend on P3RX"));
                            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_BLEND );
                            break;
                    }

                    switch(pContext->RenderStates[D3DRENDERSTATE_DESTBLEND])
                    {
                        case D3DBLEND_ZERO:
                            bDstUsesDst = FALSE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                            break;
                        case D3DBLEND_DESTCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX %d D3DBLEND_DESTCOLOR"));
                        case D3DBLEND_INVDESTCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX %d D3DBLEND_INVDESTCOLOR"));
                            //azn SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_BLEND );
                            // fall through 
                        case D3DBLEND_ONE:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE;
                            break;
                        case D3DBLEND_SRCCOLOR:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_COLOR;
                            if ( pContext->bAlphaBlendMustDoubleSourceColour )
                            {
                                // SRCCOLOR needs to be doubled.
                                pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_ENABLE;
                            }
                            break;
                        case D3DBLEND_INVSRCCOLOR:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR;
                            if ( pContext->bAlphaBlendMustDoubleSourceColour )
                            {
                                // Can't do this. What they want is:
                                // (1-(srccolor * 2))*destcolor
                                // = destcolor - 2*srccolor*destcolor
                                // All we can do is:
                                // (1-srccolor)*destcolor*2
                                // = destcolor*2 - 2*srccolor*destcolor
                                // ...which is a very different thing of course.
                                // Fail the blend.
                                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );
                            }
                            break;
                        case D3DBLEND_SRCALPHA:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            break;
                        case D3DBLEND_INVSRCALPHA:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            break;
                        case D3DBLEND_DESTALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            break;
                        case D3DBLEND_INVDESTALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            break;
                        default:
                            DISPDBG((ERRLVL,"Unknown Destination Blend on P3RX"));
                            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                            break;
                    }
                    break;
            }

            if ( bSrcUsesDst || bDstUsesDst )
            {
                // Yep, using the destination data.
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
            }

            // We need to verify if the blending mode will use the alpha 
            // channel of the destination fragment (buffer) and if the buffer
            // does in fact have an alpha buffer. If not, we need to make sure
            // hw will assume this value == 1.0 (0xFF in ARGB). 
            // The D3DBLEND_SRCALPHASAT blend mode also involves the 
            // destination alpha
            
            pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_DISABLE;                
            
            if ((pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVDESTALPHA) ||
                (pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_DESTALPHA)    ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_INVDESTALPHA) ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_DESTALPHA)   ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_SRCALPHASAT))
            {
                if (!pContext->pSurfRenderInt->pFormatSurface->bAlpha)
                {
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_ENABLE;
                }
            }

            // We could now check if the src data is ever used. If not, bin
            // the whole previous pipeline! But this rarely happens.
            // A case where it might is if they are updating just the Z buffer,
            // but not changing the picture (e.g. for mirrors or portals).
        }

        COPY_P3_DATA(AlphaBlendAlphaMode, pSoftP3RX->P3RXAlphaBlendAlphaMode);
        COPY_P3_DATA(AlphaBlendColorMode, pSoftP3RX->P3RXAlphaBlendColorMode);
        COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have w buffering parameters changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_WBUFFER)
    {
        float noverf;
        float NF_factor;

        if ( (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) && 
             (pContext->pSurfZBufferInt) )
        {
            DISPDBG((DBGLVL,"WBuffer wNear: %f, wFar: %f", 
                             pContext->WBufferInfo.dvWNear, 
                             pContext->WBufferInfo.dvWFar));

            noverf = (pContext->WBufferInfo.dvWNear / 
                                        pContext->WBufferInfo.dvWFar);
            NF_factor = (1.0 / 256.0);

            // Compare range in decending order.
            // Note that Exponent Width is determined 
            // as DepthMode.ExponentWidth +1

            if (noverf >= (myPow(2,-0) * NF_factor))
            {
                // Use linear Z
                pSoftP3RX->P3RXDepthMode.NonLinearZ = FALSE;
            }
            else if (noverf >= (myPow(2,-1) * NF_factor))
            {
                // Use exp width 1, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 0;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-3) * NF_factor))
            {
                // Use exp width 2, exp scale 1
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 1;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-4) * NF_factor))
            {
                // Use exp width 2, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-7) * NF_factor))
            {
                // Use exp width 3, exp scale 1
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 2;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 1;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else
            {
                // Use exp width 3, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 3;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }

        }
        else
        {
            pSoftP3RX->P3RXDepthMode.NonLinearZ = FALSE;
        }

        P3_DMA_GET_BUFFER_ENTRIES(2);
        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have the rendertarget/ z buffer address changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_RENDER_OFFSETS)
    {
        DISPDBG((DBGLVL,"  Render Offsets"));
        _D3D_OP_SetRenderTarget(pContext, 
                                pContext->pSurfRenderInt, 
                                pContext->pSurfZBufferInt,
                                FALSE);

        P3_DMA_GET_BUFFER_ENTRIES(2);
        COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have the viewport parameters changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_VIEWPORT)
    {
        P3_DMA_GET_BUFFER_ENTRIES(12);

        DISPDBG((DBGLVL,"Viewport left: %d, top: %d, width: %d, height: %d",
                        pContext->ViewportInfo.dwX,
                        pContext->ViewportInfo.dwY,
                        pContext->ViewportInfo.dwWidth,
                        pContext->ViewportInfo.dwHeight));

        // If a valid viewport is setup, scissor it
        if ((pContext->ViewportInfo.dwWidth != 0) &&
            (pContext->ViewportInfo.dwHeight != 0))
        {
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                pSoftP3RX->P3RXScissorMinXY.X = pContext->ViewportInfo.dwX * 2;
                pSoftP3RX->P3RXScissorMinXY.Y = pContext->ViewportInfo.dwY * 2;
                pSoftP3RX->P3RXScissorMaxXY.X = (pContext->ViewportInfo.dwWidth * 2) + 
                                                    pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMaxXY.Y = (pContext->ViewportInfo.dwHeight * 2) + 
                                                    pContext->ViewportInfo.dwY;
            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                pSoftP3RX->P3RXScissorMinXY.X = pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMinXY.Y = pContext->ViewportInfo.dwY;
                pSoftP3RX->P3RXScissorMaxXY.X = pContext->ViewportInfo.dwWidth +
                                                    pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMaxXY.Y = pContext->ViewportInfo.dwHeight + 
                                                    pContext->ViewportInfo.dwY;
            }

            COPY_P3_DATA(ScissorMinXY, pSoftP3RX->P3RXScissorMinXY);
            COPY_P3_DATA(ScissorMaxXY, pSoftP3RX->P3RXScissorMaxXY);

            SEND_P3_DATA(YLimits, (pContext->ViewportInfo.dwY & 0xFFFF) | 
                                  (pSoftP3RX->P3RXScissorMaxXY.Y << 16));

            SEND_P3_DATA(XLimits, (pContext->ViewportInfo.dwX & 0xFFFF) | 
                                  (pSoftP3RX->P3RXScissorMaxXY.X << 16));
            
            // Enable user scissor
            SEND_P3_DATA(ScissorMode, 1);

            pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_ENABLE;
            COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);
        }
        else
        {
            SEND_P3_DATA(ScissorMode, 0);

            pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_DISABLE;
            COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);
        }

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Can we optimize the pipeline? (Depends on misc. RS)
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_PIPELINEORDER)
    {
        // Must switch over the router mode if we are testing and expect 
        // the Z to be discarded.
        P3_DMA_GET_BUFFER_ENTRIES(2);

        DISPDBG((DBGLVL, "  Pipeline order"));
        if (((pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) ||
             (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) &&
             (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE]))
        {
            SEND_P3_DATA(RouterMode, __PERMEDIA_DISABLE);
        }
        else
        {
            SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);
        }

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Can we optimize the alpha pipeline? (Depends on misc. RS)
    //********************************************************* 
    // DO AT THE END
    //*********************************************************     
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_OPTIMIZE_ALPHA)
    {
        P3_DMA_GET_BUFFER_ENTRIES(6);
        DISPDBG((DBGLVL, " Alpha optimizations"));

        pSoftP3RX->P3RXFBDestReadMode.AlphaFiltering = __PERMEDIA_DISABLE;

        // There may be an optimization when blending is on
        if (pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE])
        {
            // Check the RouterMode path
            if (((pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) ||
                 (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) &&
                 (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE]))
            {
                // Slow mode
    
            }
            else
            {
                // Fast mode.  The Z value will be written before the alpha test.  This means that we
                // can use the alpha test to discard pixels if it is not already in use.
                if (!(pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) &&
                    !(pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE]))
                {
                    // Check for known blends.
                    if ((pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA) ||
                         ((pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA) &&
                          (pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA)))
                    {
                        // SRCALPHA:INVSRCALPH
                        pSoftP3RX->P3RXAlphaTestMode.Reference = 0;
                        pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER;
                        
                        pSoftP3RX->P3RXFBDestReadMode.AlphaFiltering = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXFBDestReadEnables.ReferenceAlpha = 0xFF;
                    }
                }
            }
        }

        COPY_P3_DATA(FBDestReadEnables, pSoftP3RX->P3RXFBDestReadEnables);
        COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);
        COPY_P3_DATA(AlphaTestMode, pSoftP3RX->P3RXAlphaTestMode);

        P3_DMA_COMMIT_BUFFER();
    }

} // __ST_HandleDirtyP3State

//-----------------------------------------------------------------------------
//
// _D3D_ST_ProcessOneRenderState
//
//-----------------------------------------------------------------------------
#define NOT_HANDLED DISPDBG((DBGLVL, "             **Not Currently Handled**"));

DWORD 
_D3D_ST_ProcessOneRenderState(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRSType,
    DWORD dwRSVal)
{
    P3_SOFTWARECOPY* pSoftP3RX;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    DWORD *pFlags;
    DWORD *pdwTextureStageState_0, *pdwTextureStageState_1;
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    BOOL bDX7_Antialiasing = FALSE;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIASING

    P3_DMA_DEFS();

    DBG_ENTRY(_D3D_ST_ProcessOneRenderState); 

    pSoftP3RX = &pContext->SoftCopyGlint;

    DISPDBG((DBGLVL, "_D3D_ST_ProcessOneRenderState: dwType =%08lx, dwVal=%d",
                     dwRSType, dwRSVal));

    if (dwRSType >= D3DHAL_MAX_RSTATES)
    {
        DISPDBG((WRNLVL, "_D3D_ST_ProcessOneRenderState: OUT OF RANGE"
                         " dwType =%08lx, dwVal=%d", dwRSType, dwRSVal));
        return DD_OK;
    }

    // Store the state in the context
    pContext->RenderStates[dwRSType] = dwRSVal;

    // Prepare pointer to the contexts state flags for updates
    pFlags = &pContext->Flags;    

    // Prepare pointers to the stored TSS in case we need them
    pdwTextureStageState_0 =
                    &(pContext->TextureStageState[TEXSTAGE_0].m_dwVal[0]);
    pdwTextureStageState_1 = 
                    &(pContext->TextureStageState[TEXSTAGE_1].m_dwVal[0]);

    // Prepare DMA Buffer for 8 entries in case we need to add to it
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(8);
    WAIT_FIFO(8);

    // Process according to the type of renderstate. For multivalued 
    // renderstates do some kind of value checking and make sure to
    // setup valid defaults where needed.
    switch (dwRSType) 
    {
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are D3D renderstates which are still in use by DX8 Apps
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------  
        case D3DRENDERSTATE_ZENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZENABLE = 0x%x",dwRSVal));
            DIRTY_ZBUFFER(pContext);
            break;

        case D3DRENDERSTATE_FILLMODE:
            DISPDBG((DBGLVL, "SET D3DRS_FILLMODE =  0x%x",dwRSVal));
            switch (dwRSVal)
            {
                case D3DFILL_POINT:
                case D3DFILL_WIREFRAME:
                case D3DFILL_SOLID:
                    // These values are OK
                    break;
                default:
                    // We've received an illegal value, default to solid fills...
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown FILLMODE value"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    pContext->RenderStates[D3DRENDERSTATE_FILLMODE] = 
                                                                D3DFILL_SOLID;
                    break;
            }
            break;

        case D3DRENDERSTATE_SHADEMODE:
            DISPDBG((DBGLVL, "SET D3DRS_SHADEMODE = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DSHADE_PHONG:
                    // Can't actually do Phong, but everyone knows this and 
                    // assumes we use Gouraud instead.
                    SET_BLEND_ERROR ( pContext,  BS_PHONG_SHADING );
                    // fall through and setup Gouraud instead
                    
                case D3DSHADE_GOURAUD:
                    pSoftP3RX->ColorDDAMode.UnitEnable = 1;                
                    pSoftP3RX->ColorDDAMode.ShadeMode = 1;
                    COPY_P3_DATA(ColorDDAMode, pSoftP3RX->ColorDDAMode); 
                    
                    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = 1;
                    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = 0;
                    pSoftP3RX->P3RX_P3VertexControl.Flat = 0;
                    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
                    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
                    COPY_P3_DATA(VertexControl, pSoftP3RX->P3RX_P3VertexControl);
                    
                    *pFlags |= SURFACE_GOURAUD;
                    
                    // If we are texturing, some changes may need to be made
                    if (pdwTextureStageState_0[D3DTSS_TEXTUREMAP] != 0)
                    {
                        DIRTY_TEXTURE(pContext);
                    }
                    break;
                    
                case D3DSHADE_FLAT:
                    pSoftP3RX->ColorDDAMode.UnitEnable = 1;                  
                    pSoftP3RX->ColorDDAMode.ShadeMode = 0;
                    COPY_P3_DATA(ColorDDAMode, pSoftP3RX->ColorDDAMode);
                    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = 0;

                    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = 1;
                    pSoftP3RX->P3RX_P3VertexControl.Flat = 1;
                    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
                    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
                    COPY_P3_DATA(VertexControl, pSoftP3RX->P3RX_P3VertexControl);
                    
                    *pFlags &= ~SURFACE_GOURAUD;
                    // If we are texturing, some changes may need to be made
                    if (pdwTextureStageState_0[D3DTSS_TEXTUREMAP] != 0)
                    {
                        DIRTY_TEXTURE(pContext);
                    }
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown SHADEMODE value"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
            break;            

        case D3DRENDERSTATE_LINEPATTERN:
            DISPDBG((DBGLVL, "SET D3DRS_LINEPATTERN = 0x%x",dwRSVal));

            if (dwRSVal == 0)
            {
                pSoftP3RX->PXRXLineStippleMode.StippleEnable = __PERMEDIA_DISABLE;

                RENDER_LINE_STIPPLE_DISABLE(pContext->RenderCommand);                
            }
            else
            {
                pSoftP3RX->PXRXLineStippleMode.StippleEnable = __PERMEDIA_ENABLE;
                pSoftP3RX->PXRXLineStippleMode.RepeatFactor = 
                                                    (dwRSVal & 0x0000FFFF) -1 ;
                pSoftP3RX->PXRXLineStippleMode.StippleMask = 
                                                    (dwRSVal & 0xFFFF0000) >> 16;
                pSoftP3RX->PXRXLineStippleMode.Mirror = __PERMEDIA_DISABLE;

                RENDER_LINE_STIPPLE_ENABLE(pContext->RenderCommand);                               
            }

            COPY_P3_DATA( LineStippleMode, pSoftP3RX->PXRXLineStippleMode);
            break;

        case D3DRENDERSTATE_ZWRITEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZWRITEENABLE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                // Local Buffer Write mode
                if(!(*pFlags & SURFACE_ZWRITEENABLE))
                {
                    DISPDBG((DBGLVL, "Enabling Z Writes"));
                    *pFlags |= SURFACE_ZWRITEENABLE;
                    DIRTY_ZBUFFER(pContext);
                    DIRTY_PIPELINEORDER(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            else
            {
                if (*pFlags & SURFACE_ZWRITEENABLE)
                {
                    DISPDBG((DBGLVL, "Disabling Z Writes"));
                    *pFlags &= ~SURFACE_ZWRITEENABLE;
                    DIRTY_ZBUFFER(pContext);
                    DIRTY_PIPELINEORDER(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            break;

        case D3DRENDERSTATE_ALPHATESTENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHATESTENABLE = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            DIRTY_PIPELINEORDER(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;

        case D3DRENDERSTATE_LASTPIXEL:
            DISPDBG((DBGLVL, "SET D3DRS_LASTPIXEL = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_SRCBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_SRCBLEND = 0x%x",dwRSVal));
            DIRTY_ALPHABLEND(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;
            
        case D3DRENDERSTATE_DESTBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_DESTBLEND = 0x%x",dwRSVal));
            DIRTY_ALPHABLEND(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;
            
        case D3DRENDERSTATE_CULLMODE:
            DISPDBG((DBGLVL, "SET D3DRS_CULLMODE = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DCULL_NONE:              
                    SET_CULLING_TO_NONE(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;

                case D3DCULL_CCW:
                    SET_CULLING_TO_CCW(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;

                case D3DCULL_CW:
                    SET_CULLING_TO_CW(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown cull mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
            break;
            
        case D3DRENDERSTATE_ZFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_ZFUNC = 0x%x",dwRSVal));
            switch (dwRSVal)
            {
                case D3DCMP_NEVER:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_LESS:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_EQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_LESSEQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_GREATER:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_NOTEQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_GREATEREQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_ALWAYS;
                    break;                  
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown ZFUNC mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );

                    // Set Less or equal as default
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                        __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
            }
            DIRTY_ZBUFFER(pContext);
            break;
            
        case D3DRENDERSTATE_ALPHAREF:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHAREF = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            break;
            
        case D3DRENDERSTATE_ALPHAFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHAFUNC = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            break;
            
        case D3DRENDERSTATE_DITHERENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_DITHERENABLE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                pSoftP3RX->DitherMode.DitherEnable = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->DitherMode.DitherEnable = __PERMEDIA_DISABLE;
            } 
            COPY_P3_DATA(DitherMode, pSoftP3RX->DitherMode);
            break;

        case D3DRENDERSTATE_BLENDENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_BLENDENABLE = 0x%x",dwRSVal));

            // Although render states whose values are boolean in type are 
            // documented as only accepting TRUE(1) and FALSE(0) the runtime 
            // does not validate this and accepts any non-zero value as true. 
            // The sample driver interprets this strictly and does interpret 
            // values other than 1 as being TRUE. However, as the runtime 
            // does not offer validation your driver should interpret 0 as 
            // FALSE and any other non-zero value as TRUE. 
            
            if (dwRSVal != 0)
            {
                if(!(*pFlags & SURFACE_ALPHAENABLE))
                {
                    // Set the blend enable flag in the render context struct
                    *pFlags |= SURFACE_ALPHAENABLE;
                    DIRTY_ALPHABLEND(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            else 
            {
                if (*pFlags & SURFACE_ALPHAENABLE)
                {
                    // Turn off blend enable flag in render context struct
                    *pFlags &= ~SURFACE_ALPHAENABLE;
                    DIRTY_ALPHABLEND(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            break;

        case D3DRENDERSTATE_FOGENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_FOGENABLE = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;

        case D3DRENDERSTATE_SPECULARENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_SPECULARENABLE = 0x%x",dwRSVal));
            if (dwRSVal)
            {
                *pFlags |= SURFACE_SPECULAR;
                pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = 1;
            }
            else
            {
                *pFlags &= ~SURFACE_SPECULAR;
                pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = 0;
            }
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_ZVISIBLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZVISIBLE = %d", dwRSVal));
            if (dwRSVal)
            { 
                DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState:"
                             " ZVISIBLE enabled - no longer supported."));
            }
            break;

        case D3DRENDERSTATE_STIPPLEDALPHA:
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEDALPHA = 0x%x",dwRSVal));
            if(dwRSVal)
            {
                if (!(*pFlags & SURFACE_ALPHASTIPPLE))
                {
                    *pFlags |= SURFACE_ALPHASTIPPLE;
                    if (pContext->bKeptStipple)
                    {
                        RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                    }
                }
            }
            else 
            {
                if (*pFlags & SURFACE_ALPHASTIPPLE)
                {
                    // If Alpha Stipple is being turned off, turn the normal 
                    // stipple back on, and enable it.
                    int i;
                    for (i = 0; i < 32; i++)
                    {
                        P3_ENSURE_DX_SPACE(2);
                        WAIT_FIFO(2);
                        SEND_P3_DATA_OFFSET(AreaStipplePattern0, 
                                             (DWORD)pContext->CurrentStipple[i], i);
                    }

                    *pFlags &= ~SURFACE_ALPHASTIPPLE;

                    if (pContext->bKeptStipple)
                    {
                        RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                    }
                }
            }
            break;

        case D3DRENDERSTATE_FOGCOLOR:
            DISPDBG((DBGLVL, "SET D3DRS_FOGCOLOR = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEMODE:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEMODE = 0x%x", dwRSVal));
            DIRTY_FOG(pContext);
            break;            
            
        case D3DRENDERSTATE_FOGTABLESTART:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLESTART = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEEND:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEEND = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEDENSITY:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEDENSITY = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;

        case D3DRENDERSTATE_EDGEANTIALIAS:    
            DISPDBG((DBGLVL, "SET D3DRS_EDGEANTIALIAS = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;        

        case D3DRENDERSTATE_ZBIAS:    
            DISPDBG((DBGLVL, "SET D3DRS_ZBIAS = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;    

        case D3DRENDERSTATE_RANGEFOGENABLE:    
            DISPDBG((DBGLVL, "SET D3DRS_RANGEFOGENABLE = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;               

        case D3DRENDERSTATE_STENCILENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILENABLE = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILFAIL:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILFAIL = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILZFAIL:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILZFAIL = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILPASS:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILPASS = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILFUNC = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILREF:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILREF = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILMASK:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILMASK = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILWRITEMASK:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILENABLE = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;  

        case D3DRENDERSTATE_TEXTUREFACTOR:
            // Should not need to dirty anything. This is a good thing -
            // this may be changed frequently in between calls, and may be
            // the only thing to change. Used for some of the odder blend modes.
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREFACTOR = 0x%x", dwRSVal));            
            SEND_P3_DATA ( TextureEnvColor, FORMAT_8888_32BIT_BGR(dwRSVal) );
            SEND_P3_DATA ( TextureCompositeFactor0, FORMAT_8888_32BIT_BGR(dwRSVal) );
            SEND_P3_DATA ( TextureCompositeFactor1, FORMAT_8888_32BIT_BGR(dwRSVal) );
            break;

        case D3DRENDERSTATE_WRAP0:
        case D3DRENDERSTATE_WRAP1:        
        case D3DRENDERSTATE_WRAP2:        
        case D3DRENDERSTATE_WRAP3:
        case D3DRENDERSTATE_WRAP4:
        case D3DRENDERSTATE_WRAP5:
        case D3DRENDERSTATE_WRAP6:
        case D3DRENDERSTATE_WRAP7:        
            DISPDBG((DBGLVL, "SET D3DRS_WRAP %d = 0x%x", 
                        dwRSType - D3DRENDERSTATE_WRAP0, (DWORD)dwRSVal));                        
            DIRTY_TEXTURE(pContext);        
            break;

        case D3DRENDERSTATE_LOCALVIEWER:
            DISPDBG((DBGLVL, "SET D3DRS_LOCALVIEWER = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_CLIPPING:
            DISPDBG((DBGLVL, "SET D3DRS_CLIPPING = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_LIGHTING:
            DISPDBG((DBGLVL, "SET D3DRS_LIGHTING = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_AMBIENT:
            DISPDBG((DBGLVL, "SET D3DRS_AMBIENT = 0x%x", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;

        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are internal D3D renderstates which are created by 
        // the runtime. Apps don't send them. 
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------  

        case D3DRENDERSTATE_SCENECAPTURE:
            DISPDBG((DBGLVL, "SET D3DRS_SCENECAPTURE = 0x%x", dwRSVal));
            {
                DWORD dwFlag;

                if (dwRSVal)
                {
                    dwFlag = D3DHAL_SCENE_CAPTURE_START;
                }
                else
                {
                    dwFlag = D3DHAL_SCENE_CAPTURE_END;
                }
                
#if DX7_TEXMANAGEMENT
                if (dwRSVal)
                {
                    // Reset Texture Management counters for next frame
                    _D3D_TM_STAT_ResetCounters(pContext); 
                }
#endif // DX7_TEXMANAGEMENT                

                // Flush all DMA ops before going to next frame
                P3_DMA_COMMIT_BUFFER();
                
                _D3D_OP_SceneCapture(pContext, dwFlag);

                // Restart DMA ops
                P3_DMA_GET_BUFFER();
            }
            break;

#if DX7_TEXMANAGEMENT
        case D3DRENDERSTATE_EVICTMANAGEDTEXTURES:     
            DISPDBG((DBGLVL, "SET D3DRENDERSTATE_EVICTMANAGEDTEXTURES = 0x%x", 
                             dwRSVal));
            if (NULL != pContext->pTextureManager)
            {
                _D3D_TM_EvictAllManagedTextures(pContext);        
            }
            break;
#endif // DX7_TEXMANAGEMENT 
            
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are new DX8 renderstates which we need to process 
        // correctly in order to run DX8 apps
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

#if DX8_POINTSPRITES
        // Pointsprite support
        case D3DRS_POINTSIZE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fSize) = dwRSVal;
            break;

        case D3DRS_POINTSPRITEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSPRITEENABLE = 0x%x",dwRSVal));
            pContext->PntSprite.bEnabled = dwRSVal;
            break;

        case D3DRS_POINTSIZE_MIN:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE_MIN = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fSizeMin) = dwRSVal;
            break;

        case D3DRS_POINTSIZE_MAX:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE_MAX = 0x%x",dwRSVal)); 
            *(DWORD*)(&pContext->PntSprite.fSizeMax) = dwRSVal;
            break; 
            
        // All of the following point sprite related render states are
        // ignored by this driver since we are a Non-TnLHal driver.
        case D3DRS_POINTSCALEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALEENABLE = 0x%x",dwRSVal));
            pContext->PntSprite.bScaleEnabled = dwRSVal; 
            break;
            
        case D3DRS_POINTSCALE_A:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_A = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_A) = dwRSVal;
            break;

        case D3DRS_POINTSCALE_B:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_B = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_B) = dwRSVal;
            break;

        case D3DRS_POINTSCALE_C:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_C = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_C) = dwRSVal;
            break;
           
#endif // DX8_POINTSPRITES

#if DX8_VERTEXSHADERS
        case D3DRS_SOFTWAREVERTEXPROCESSING:
            DISPDBG((DBGLVL, "SET D3DRS_SOFTWAREVERTEXPROCESSING = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
#endif // DX8_VERTEXSHADERS                

#if DX8_DDI
        case D3DRS_COLORWRITEENABLE:
            {
                DWORD dwColMask = 0x0;
                
                DISPDBG((DBGLVL, "SET D3DRS_COLORWRITEENABLE = 0x%x",dwRSVal));

                if (dwRSVal & D3DCOLORWRITEENABLE_RED)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwRBitMask;
                }

                if (dwRSVal & D3DCOLORWRITEENABLE_GREEN)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwGBitMask;      
                }       

                if (dwRSVal & D3DCOLORWRITEENABLE_BLUE)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwBBitMask;        
                }    

                if (dwRSVal & D3DCOLORWRITEENABLE_ALPHA)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwRGBAlphaBitMask;        
                }   

                // Replicate mask into higher word for P3 in 16 bpp mode
                if (pContext->pSurfRenderInt->dwPixelSize == __GLINT_16BITPIXEL)
                {
                    dwColMask |= (dwColMask << 16);
                    pContext->dwColorWriteSWMask = dwColMask;
                }
                else
                {
                    pContext->dwColorWriteSWMask = 0xFFFFFFFF;
                }
                        
                pContext->dwColorWriteHWMask = dwColMask;

                SEND_P3_DATA(FBHardwareWriteMask, pContext->dwColorWriteHWMask);
                DISPDBG((DBGLVL,"dwColMask = 0x%08x",dwColMask));
                SEND_P3_DATA(FBSoftwareWriteMask, pContext->dwColorWriteSWMask);                
            }
            
            break;        
#endif // DX8_DDI

        //----------------------------------------------------------------------        
        //----------------------------------------------------------------------
        // The following are retired renderstates from DX8 but which we need to
        // process correctly in order to run apps which use legacy interfaces 
        // These apps might send down the pipeline these renderstates and expect
        // correct driver behavior !
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

        case D3DRENDERSTATE_TEXTUREHANDLE:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREHANDLE = 0x%x",dwRSVal));
            if (dwRSVal != pdwTextureStageState_0[D3DTSS_TEXTUREMAP])
            {
                pdwTextureStageState_0[D3DTSS_TEXTUREMAP] = dwRSVal;
                DIRTY_TEXTURE(pContext);
            }
            break;

#if DX7_ANTIALIAS
        // DX7 uses D3DRENDERSTATE_ANTIALIAS.
        case D3DRENDERSTATE_ANTIALIAS:
            bDX7_Antialiasing = TRUE;
            if (dwRSVal && pContext->pSurfRenderInt)
            {
                // Always reallocate alias buffer for DX7
                // P3 driver supports only 2x2 (4) multi sample antialiasing

#if DX8_MULTISAMPLING
                pContext->pSurfRenderInt->dwSampling = 4;
#endif // DX8_MULTISAMPLING
                if (! _D3D_ST_CanRenderAntialiased(pContext, TRUE))
                {
#if DX8_MULTISAMPLING                
                    // Reset dwSampling in case of failure
                    pContext->pSurfRenderInt->dwSampling = 0;
#endif // DX8_MULTISAMPLING                    
                    P3_DMA_COMMIT_BUFFER();
                    return DDERR_OUTOFMEMORY;
                }
            }
            // then fall through...
#endif // DX7_ANTIALIAS

#if DX8_MULTISAMPLING
        // DX8 uses D3DRS_MULTISAMPLEANTIALIAS
        case D3DRS_MULTISAMPLEANTIALIAS:
#endif // DX8_MULTISAMPLING

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            DISPDBG((DBGLVL, "ChangeState: AntiAlias 0x%x",dwRSVal));
            P3_DMA_COMMIT_BUFFER();
            if (dwRSVal 
#if DX8_MULTISAMPLING
                && pContext->pSurfRenderInt->dwSampling
#endif // DX8_MULTISAMPLING
               )
            {
                pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_ENABLE;
                *pFlags |= SURFACE_ANTIALIAS;
            }
            else
            {
                pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_DISABLE;
                *pFlags &= ~SURFACE_ANTIALIAS;
            }
            P3_DMA_GET_BUFFER_ENTRIES( 4 );
            DIRTY_RENDER_OFFSETS(pContext);
            break;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

        case D3DRENDERSTATE_TEXTUREPERSPECTIVE:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREPERSPECTIVE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                *pFlags |= SURFACE_PERSPCORRECT;
                pSoftP3RX->P3RX_P3DeltaControl.ForceQ = 0;
            }
            else
            {   
                *pFlags &= ~SURFACE_PERSPCORRECT;
                pSoftP3RX->P3RX_P3DeltaControl.ForceQ = 1;
            }

            COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
            break;
            
        case D3DRENDERSTATE_TEXTUREMAPBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMAPBLEND = 0x%x", dwRSVal));               
            *pFlags &= ~SURFACE_MODULATE;
            switch(dwRSVal)
            {
                case D3DTBLEND_DECALMASK: // unsupported - do decal as fallback.
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );
                    // fall through
                case D3DTBLEND_DECAL:
                case D3DTBLEND_COPY:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_MODULATEMASK: // unsupported - do modulate as fallback.
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );
                    // fall through
                case D3DTBLEND_MODULATE:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    // In the changetexture* code we modify the below value,
                    // dependent on the SURFACE_MODULATE flag...
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    *pFlags |= SURFACE_MODULATE;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_ADD:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_ADD;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown texture blend!"));
                    // This needs to be flagged here, because we don't know
                    // what effect it is meant to have on the TSS stuff.
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREMAG:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMAG = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DFILTER_NEAREST:
                case D3DFILTER_MIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                    break;
                case D3DFILTER_LINEAR:
                case D3DFILTER_LINEARMIPLINEAR:
                case D3DFILTER_MIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAG filter!"));
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREMIN:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMIN = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DFILTER_NEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                    break;
                case D3DFILTER_MIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                    break;
                case D3DFILTER_LINEARMIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                    break;
                case D3DFILTER_LINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                    break;
                case D3DFILTER_MIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                    break;
                case D3DFILTER_LINEARMIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MIN filter!"));
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_WRAPU:
            // map legacy WRAPU state through to controls for tex coord 0        
            DISPDBG((DBGLVL, "SET D3DRS_WRAPU = 0x%x",dwRSVal));        
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] |= ((dwRSVal) ? D3DWRAP_U : 0);
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_WRAPV:
            // map legacy WRAPV state through to controls for tex coord 0    
            DISPDBG((DBGLVL, "SET D3DRS_WRAPV = 0x%x",dwRSVal));             
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] |= ((dwRSVal) ? D3DWRAP_V : 0);
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_TEXTUREADDRESS:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESS = 0x%x",dwRSVal));  
            pdwTextureStageState_0[D3DTSS_ADDRESS] =           
            pdwTextureStageState_0[D3DTSS_ADDRESSU] =
            pdwTextureStageState_0[D3DTSS_ADDRESSV] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREADDRESSU:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESSU = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_ADDRESSU] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_TEXTUREADDRESSV:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESSV = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_ADDRESSV] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_MIPMAPLODBIAS:
            DISPDBG((DBGLVL, "SET D3DRS_MIPMAPLODBIAS = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_MIPMAPLODBIAS] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;
        case D3DRENDERSTATE_BORDERCOLOR:
            DISPDBG((DBGLVL, "SET D3DRS_BORDERCOLOR = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_BORDERCOLOR] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_STIPPLEPATTERN00:
        case D3DRENDERSTATE_STIPPLEPATTERN01:
        case D3DRENDERSTATE_STIPPLEPATTERN02:
        case D3DRENDERSTATE_STIPPLEPATTERN03:
        case D3DRENDERSTATE_STIPPLEPATTERN04:
        case D3DRENDERSTATE_STIPPLEPATTERN05:   
        case D3DRENDERSTATE_STIPPLEPATTERN06:
        case D3DRENDERSTATE_STIPPLEPATTERN07:
        case D3DRENDERSTATE_STIPPLEPATTERN08:
        case D3DRENDERSTATE_STIPPLEPATTERN09:
        case D3DRENDERSTATE_STIPPLEPATTERN10:
        case D3DRENDERSTATE_STIPPLEPATTERN11: 
        case D3DRENDERSTATE_STIPPLEPATTERN12:
        case D3DRENDERSTATE_STIPPLEPATTERN13:
        case D3DRENDERSTATE_STIPPLEPATTERN14:
        case D3DRENDERSTATE_STIPPLEPATTERN15:
        case D3DRENDERSTATE_STIPPLEPATTERN16:
        case D3DRENDERSTATE_STIPPLEPATTERN17: 
        case D3DRENDERSTATE_STIPPLEPATTERN18:
        case D3DRENDERSTATE_STIPPLEPATTERN19:
        case D3DRENDERSTATE_STIPPLEPATTERN20:
        case D3DRENDERSTATE_STIPPLEPATTERN21:
        case D3DRENDERSTATE_STIPPLEPATTERN22:
        case D3DRENDERSTATE_STIPPLEPATTERN23: 
        case D3DRENDERSTATE_STIPPLEPATTERN24:
        case D3DRENDERSTATE_STIPPLEPATTERN25:
        case D3DRENDERSTATE_STIPPLEPATTERN26:
        case D3DRENDERSTATE_STIPPLEPATTERN27:
        case D3DRENDERSTATE_STIPPLEPATTERN28:
        case D3DRENDERSTATE_STIPPLEPATTERN29:   
        case D3DRENDERSTATE_STIPPLEPATTERN30:
        case D3DRENDERSTATE_STIPPLEPATTERN31:     
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEPATTERN 2%d = 0x%x",
                        dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00, 
                        dwRSVal));
                        
            pContext->CurrentStipple
                       [(dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00)] = dwRSVal;
                       
            if (!(*pFlags & SURFACE_ALPHASTIPPLE))
            {
                // Flat-Stippled Alpha is not on, so use the current stipple pattern
                SEND_P3_DATA_OFFSET(AreaStipplePattern0,
                        (DWORD)dwRSVal, dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00);
            }

            break;

        case D3DRENDERSTATE_ROP2:
            DISPDBG((DBGLVL, "SET D3DRS_ROP2 = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_PLANEMASK:
            DISPDBG((DBGLVL, "SET D3DRS_PLANEMASK = 0x%x",dwRSVal));
            SEND_P3_DATA(FBHardwareWriteMask, (DWORD)dwRSVal);
            break;
            
        case D3DRENDERSTATE_MONOENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_MONOENABLE = 0x%x", dwRSVal));
            if (dwRSVal)
            {
                *pFlags |= SURFACE_MONO;
            }
            else
            {
                *pFlags &= ~SURFACE_MONO;
            }
            break;
            
        case D3DRENDERSTATE_SUBPIXEL:
            DISPDBG((DBGLVL, "SET D3DRS_SUBPIXEL = 0x%x", dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_SUBPIXELX:
            DISPDBG((DBGLVL, "SET D3DRS_SUBPIXELX = 0x%x", dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_STIPPLEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEENABLE = 0x%x", dwRSVal));
            if (dwRSVal)
            {
                if (!(*pFlags & SURFACE_ALPHASTIPPLE))
                {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                }
                pContext->bKeptStipple = TRUE;
            }
            else
            {
                RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                pContext->bKeptStipple = FALSE;
            }
            break;

        case D3DRENDERSTATE_COLORKEYENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_COLORKEYENABLE = 0x%x",dwRSVal));
            DIRTY_TEXTURE(pContext);
            DIRTY_ALPHATEST(pContext);
            DIRTY_PIPELINEORDER(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;       
            
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The default case handles any other unknown renderstate
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

        default:
            // There are a few states that we just don't understand.
            DISPDBG((WRNLVL, "_D3D_ST_ProcessOneRenderState"
                             " Unhandled opcode = %d", dwRSType));
            //SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
            break;
    }

    // Commit DMA Buffer
    P3_DMA_COMMIT_BUFFER();

    DBG_EXIT(_D3D_ST_ProcessOneRenderState,0); 

    return DD_OK;
    
} // _D3D_ST_ProcessOneRenderState 


//-----------------------------------------------------------------------------
//
// _D3D_ST_ProcessRenderStates
//
// Updates the context's renderstates processing an array of D3DSTATE 
// structures with dwStateCount elements in it. bDoOverride indicates
// if legacy state overrides are to be taken into account.
//-----------------------------------------------------------------------------

DWORD 
_D3D_ST_ProcessRenderStates(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStateCount, 
    D3DSTATE *pState, 
    BOOL bDoOverride)
{
    DWORD dwCurrState;

    DBG_ENTRY(_D3D_ST_ProcessRenderStates); 

    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                     "Valid Context =%08lx, dwStateCount=%d",
                     pContext, dwStateCount));

    for (dwCurrState = 0; dwCurrState < dwStateCount; dwCurrState++, pState++)
    {
        DWORD dwRSType = (DWORD) pState->drstRenderStateType;
        DWORD dwRSVal = pState->dwArg[0];

        // Override states for legacy API apps
        if (bDoOverride)
        {
            // Make sure the override is within the valid range
            if (dwRSType >= (D3DSTATE_OVERRIDE_BIAS + MAX_STATE))
            {
                continue;
            }

            if (IS_OVERRIDE(dwRSType)) 
            {
                DWORD override = GET_OVERRIDE(dwRSType);
                if (dwRSVal) 
                {
                    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                     "setting override for state %d", 
                                     override));
                    STATESET_SET(pContext->overrides, override);
                }
                else 
                {
                    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                     "clearing override for state %d", 
                                     override));
                    STATESET_CLEAR(pContext->overrides, override);
                }
                continue;
            }

            if (STATESET_ISSET(pContext->overrides, dwRSType)) 
            {
                DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                 "state %d is overridden, ignoring", 
                                 dwRSType));
                continue;
            }
        }

        // Make sure the render state is within the valid range
        if (dwRSType >= MAX_STATE)
        {
            continue;
        }

#if DX7_D3DSTATEBLOCKS
        if (pContext->bStateRecMode)
        {
            // Record this render state into the 
            // current state set being recorded
            _D3D_SB_RecordStateSetRS(pContext, dwRSType, dwRSVal);        
        }
        else
#endif //DX7_D3DSTATEBLOCKS        
        {
            // Process the next render state
            _D3D_ST_ProcessOneRenderState(pContext, dwRSType, dwRSVal);
        }

    }

    DBG_EXIT(_D3D_ST_ProcessRenderStates,0); 

    return DD_OK;
    
} // _D3D_ST_ProcessRenderStates 

//-----------------------------------------------------------------------------
//
// _D3D_ST_RealizeHWStateChanges
//
// Verifies if there are pending hardware render state changes to set up, 
// before proceeding to rasterize/render primitives. This might be convenient
// if the combined setting of some renderstates allows us to optimize the
// hardware setup in some way.
//
//-----------------------------------------------------------------------------
BOOL 
_D3D_ST_RealizeHWStateChanges( 
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay;

    DBG_ENTRY(_D3D_ST_RealizeHWStateChanges);     

    pThisDisplay = pContext->pThisDisplay;

    // Check if a flip or a mode change have happened. If so, we will 
    // need to setup the render target registers before doing any 
    // new rendering
    if (pContext->ModeChangeCount != pThisDisplay->ModeChangeCount) 
    {
        pContext->ModeChangeCount = pThisDisplay->ModeChangeCount;
        pThisDisplay->bFlippedSurface = TRUE;
    }

    if (pThisDisplay->bFlippedSurface) 
    {
        DIRTY_RENDER_OFFSETS(pContext);
    }

    // If there are any pending renderstates to process, do so
    if ( pContext->dwDirtyFlags )
    {
        // Now setup any pending hardware state necessary to correctly 
        // render our primitives
        __ST_HandleDirtyP3State( pThisDisplay, pContext);      

        // Mark the context as up to date
        pContext->dwDirtyFlags = 0;

        // Verify that the working set textures are valid so we may proceed
        // with rendering. Otherwise we will abort the attempt to render
        // anything
        if (!pContext->bTextureValid)
        {
            DISPDBG((ERRLVL,"ERROR: _D3D_ST_RealizeHWStateChanges:"
                            "Invalid Texture Handle, not rendering"));

            // re-dirty the texture setup so that we may try again later
            pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;

            DBG_EXIT(_D3D_ST_RealizeHWStateChanges,1);   
            return FALSE;
        }
    }

    DBG_EXIT(_D3D_ST_RealizeHWStateChanges,0);   

    return TRUE;
} // _D3D_ST_RealizeHWStateChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsset.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsset.h
*
* Content: State set (block) management macros and structures
*
* Copyright (c) 1999-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#if DX7_D3DSTATEBLOCKS
//-----------------------------------------------------------------------------
//                     State sets structure definitions
//-----------------------------------------------------------------------------

// How big is a FLAG field and how many bits can it accomodate
#define FLAG DWORD
#define FLAG_SIZE (8*sizeof(DWORD))

// How many RS and TS stages are there (on this hw we only store 2 TSS)
#define SB_MAX_STATE D3DSTATE_OVERRIDE_BIAS
#define SB_MAX_STAGES 2
// This value may change with the version of DX
#define SB_MAX_TSS D3DTSS_MAX

// FLAGS to indicate which state has been changed

#define SB_VIEWPORT_CHANGED         1
#define SB_ZRANGE_CHANGED           2
#define SB_CUR_VS_CHANGED           4
#define SB_INDICES_CHANGED          8

#define SB_STREAMSRC_CHANGED        (1 << 15)

#define SB_TNL_MATERIAL_CHANGED     1
#define SB_TNL_MATRIX_CHANGED       2

#define SB_TNL_CUR_PS_CHANGED       (1 << 31)

// We store state blocks in two different formats: uncompressed and compressed.
// The uncompressd format is much better while we're recording the state
// block whereas the compressed format is much more compact and suitable for
// state block execution. When a state block is ended (it's done recording)
// the driver performs this transformation. Out records are defined as unions
// in order to make the code easier to implement. The bCompressed field
// indicates the current format used in the block.
//
// In between STATESETBEGIN and STATESETEND, no shader\light will be created\
// destroyed.
//
// The compressed format will contain pointers to the commands to be executed,
// so that no extra command parsing cost is involved.
//

typedef struct _UnCompStateSet {

    // Size of uncompressed state set
    DWORD dwSize;

    // Stored state block info (uncompressed)
    // Flags tell us which fields have been set
    DWORD RenderStates[SB_MAX_STATE];
    DWORD TssStates[SB_MAX_STAGES][SB_MAX_TSS];

    FLAG bStoredRS[(SB_MAX_STATE + FLAG_SIZE)/ FLAG_SIZE];
    FLAG bStoredTSS[SB_MAX_STAGES][(SB_MAX_TSS + FLAG_SIZE) / FLAG_SIZE]; 

    // Flag to indicate what information has been changed
    // Upper 16 bits are used for stream sources
    DWORD dwFlags;

    // Information for viewport
    D3DHAL_DP2VIEWPORTINFO viewport;

    // Information for z-range;
    D3DHAL_DP2ZRANGE zRange;

#if DX8_DDI
    // Information for indices
    D3DHAL_DP2SETINDICES vertexIndex;

    // Information for stream source, only 1 for Permedia3
    D3DHAL_DP2SETSTREAMSOURCE streamSource[D3DVS_INPUTREG_MAX_V1_1];
#endif //DX8_DDI

#if DX7_SB_TNL
    // The least significant bit is used for material, others are used for matrices
    FLAG dwTnLFlags;
    
    // Information related to lights, size depends on the number of lights at 
    // D3DHAL_STATESETBEGIN time
    DWORD dwNumLights; 
    DWORD* pdwLightStateChanged;
    DWORD* pdwLightState;
    D3DLIGHT7* pLightData;
    
    // Information related to clip planes, size depends on the number of clip
    // planes at D3DHAL_STATESETBEGIN time
    DWORD dwNumClipPlanes;
    DWORD* pdwPlaneChanged;
    D3DVALUE* pPlaneCoff[4];

    // Information related to material
    D3DMATERIAL7 material;

    // Information related to transformation
    D3DMATRIX transMatrices[D3DTRANSFORMSTATE_TEXTURE7 + 1];
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // Number of vertex/pixel shaders, captured at D3DHAL_STATESETBEGIN time
    WORD wNumVertexShader;
    WORD wNumPixelShader;

    // Information for vertex/pixel shader constants 
    FLAG* pdwVSConstChanged;
    D3DVALUE* pdvVSConsts[4];

    FLAG* pdwPSConstChanged;
    D3DVALUE* pdvPSConsts[4];

    // Offset from the beginning of uc to the shader info blocks
    // (flags + constant register values)
    DWORD dwOffsetVSInfo;
    DWORD dwOffsetPSInfo;

    // Information for current pixel shader
    DWORD dwCurPixelShader;
#endif // DX8_SB_SHADERS

#if DX8_DDI
    // Information for current vertex shader
    DWORD dwCurVertexShader;
#endif // DX8_DDI
    
} UnCompStateSet, *PUnCompStateSet;

typedef struct _OffsetsCompSS {
            
    // Offset from the beginning of this structure    
    DWORD dwOffDP2RenderState;
    DWORD dwOffDP2TextureStageState;
    DWORD dwOffDP2Viewport;           // Single
    DWORD dwOffDP2ZRange;             // Single
#if DX8_DDI
    DWORD dwOffDP2SetIndices;         // Single
    DWORD dwOffDP2SetStreamSources;
#endif // DX8_DDI

#if DX7_SB_TNL
    DWORD dwOffDP2SetLights;
    DWORD dwOffDP2SetClipPlanes;
    DWORD dwOffDP2SetMaterial;        // Single
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // Number of vertex/pixel shader constant commands
    WORD wNumVSConstCmdPair;         
    WORD wNumPSConstCmdPair;
    // Double indirection to the set current shader/set shader constant pairs
    DWORD *pdwOffDP2VSConstCmd;
    DWORD *pdwOffDP2PSConstCmd;

    DWORD dwOffDP2SetPixelShader;
#endif // DX8_SB_SHADERS

#if DX8_DDI
    DWORD dwOffDP2SetVertexShader;
#endif // DX8_DDI
} OffsetsCompSS;


// After this fixed memory block, there is a size variable DP2 command stream
// Correponding DP2 command pointer is not NULL, if that command is in the 
// state set. ppDP2{VS|PS}ConstCmd has to be double indirection, DP2 command
// pointer pairs in it point to set current {V|P} shader and set {V|P} shader
// constants DP2 command.
typedef struct _CompressedStateSet {
        
    D3DHAL_DP2COMMAND* pDP2RenderState;
    D3DHAL_DP2COMMAND* pDP2TextureStageState;
    D3DHAL_DP2COMMAND* pDP2Viewport;           // Single
    D3DHAL_DP2COMMAND* pDP2ZRange;             // Single
#if DX8_DDI
    D3DHAL_DP2COMMAND* pDP2SetIndices;         // Single
    D3DHAL_DP2COMMAND* pDP2SetStreamSources;
#endif // DX8_DDI

#if DX7_SB_TNL
    D3DHAL_DP2COMMAND* pDP2SetLights;
    D3DHAL_DP2COMMAND* pDP2SetClipPlanes;
    D3DHAL_DP2COMMAND* pDP2SetMaterial;        // Single
    D3DHAL_DP2COMMAND* pDP2SetTransform;
#endif // DX7_SB_TNL
    
#if DX8_SB_SHADERS
    // Number of vertex/pixel shader constant commands
    WORD wNumVSConstCmdPair;         
    WORD wNumPSConstCmdPair;
    
    // Pairs of set vertex shader and set VS constants            
    D3DHAL_DP2COMMAND** ppDP2VSConstCmd;
    // Pairs of set pixel shader and set PS constants
    D3DHAL_DP2COMMAND** ppDP2PSConstCmd;

    // These 2 command must be after the above 2 set shader const commands
    D3DHAL_DP2COMMAND* pDP2SetPixelShader;            
#endif // DX8_SB_SHADERS

#if DX8_DDI
    D3DHAL_DP2COMMAND* pDP2SetVertexShader;
#endif DX8_DDI

} CompressedStateSet, *PCompressedStateSet;

// The state set is compressed
#define SB_COMPRESSED   0x1

// Values in the state set were changed by the capturing
#define SB_VAL_CAPTURED 0x2

typedef struct _P3StateSetRec {
    DWORD                   dwHandle;
    DWORD                   dwSSFlags;

    union {

        UnCompStateSet uc;
        CompressedStateSet cc;
    };

} P3StateSetRec , *PP3StateSetRec;


// How many pointers can we store in a 4K page. Pools of pointers are allocated 
// in this chunks in order to optimize kernel pool usage (we use 4000 vs 4096
// for any extra data the kernel allocator might put up along with the pool)
#define SSPTRS_PERPAGE (4000/sizeof(P3StateSetRec *))

#define FLAG_SET(flag, number)     \
    flag[ (number) / FLAG_SIZE ] |= (1 << ((number) % FLAG_SIZE))

#define IS_FLAG_SET(flag, number)  \
    (flag[ (number) / FLAG_SIZE ] & (1 << ((number) % FLAG_SIZE) ))

#endif //DX7_D3DSTATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsurf.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsurf.h
*
* Content: Surface management macros and structures
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __D3DSURF_H
#define __D3DSURF_H

#define SURF_MAGIC_NO 0xd3d10100

#define CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(ptr)   \
    (((ptr) != NULL) && ((ptr)->MagicNo == SURF_MAGIC_NO))

typedef enum tagSurfaceLocation
{
    VideoMemory = 0,
    SystemMemory,
    AGPMemory
} SurfaceLocation;

//********************************************************
// INFORMATION STORED FOR EACH D3D/DD SURFACE MIPMAP LEVEL
//********************************************************
typedef struct tagMIPTEXTURE {

    int wWidth;
    int wHeight;
    int logWidth;            
    int logHeight;                 // Widths and heights for this mip level

    DWORD dwOffsetFromMemoryBase;  // Offset(bytes) to the start of the texture
    FLATPTR fpVidMem;       
    DWORD lPitch;

    struct TextureMapWidth P3RXTextureMapWidth;  // Texture layout info
                                                 // for this mip level
#if DX7_TEXMANAGEMENT
    FLATPTR fpVidMemTM;            // Address of TM vidmem surface
#endif // DX7_TEXMANAGEMENT  

} MIPTEXTURE;

//*******************************************
// INFORMATION STORED FOR EACH D3D/DD SURFACE
//*******************************************
typedef struct _p3_SURF_INTERNAL {

    ULONG MagicNo ;          // Magic number to verify validity of pointer

    P3_SURF_FORMAT* pFormatSurface;    // A pointer to the surface format
    SurfaceLocation Location;// Is Texture in Vidmem?
    DWORD dwLUTOffset;       // The offset to the LUT in the Local Buffer 
                             // for this texture (if it's palletized).
    DWORD dwGARTDevLast;     // The last GART Dev base address that this 
                             // texture was used from

    DWORD wWidth;            // Width and Height of surface
    DWORD wHeight;           // (stored as DWORDS for IA64 compatibility)

    int logWidth;            // Logs of the width and height
    int logHeight;    
    float fArea;             // Area in floating point of the surface

    DDSCAPS ddsCapsInt;      // Store PDD_SURFACE_LOCAL data that we    
    DWORD dwFlagsInt;        //    we'll need later for hw setup
    DWORD dwCKLow, dwCKHigh; //    With the exception of D3DCreateSurfaceEx
    DDPIXELFORMAT pixFmt;    //    we can't/shouldn't at any other time
    DWORD dwPixelSize;       //    look inside these structures as they
    DWORD dwPixelPitch;      //    are DX RT property and may be destroyed
    DWORD dwPatchMode;       //    at any time without notifying the
    DWORD lPitch;            //    driver   
    DWORD dwBitDepth;        //
    ULONG lOffsetFromMemoryBase; 
    FLATPTR fpVidMem;        // Pointer to the surface memory

    BOOL bMipMap;            // Do we have mipmaps in this texture?   
    int iMipLevels;          // The # of mipmap levels stored    
    MIPTEXTURE MipLevels[P3_LOD_LEVELS];     // Mipmaps setting info

#if DX8_3DTEXTURES
    BOOL  b3DTexture;        // Is this a 3D texture ?   
    WORD  wDepth;            // depth of the 3D texture
    int   logDepth;          // log of the depth
    DWORD dwSlice;           // size of each 2D slice
    DWORD dwSliceInTexel;    // size of each 2D slice in Texel
    
#endif // DX8_3DTEXTURES

#if DX8_MULTISAMPLING
    DWORD dwSampling;        // Number of pixels for sampling.
#endif // DX8_MULTISAMPLING
  
#if DX7_TEXMANAGEMENT
    DWORD  dwCaps2;
    DWORD  m_dwBytes;
    DWORD  m_dwPriority;
    DWORD  m_dwTicks;
    DWORD  m_dwHeapIndex;
    BOOL   m_bTMNeedUpdate;
    DWORD  m_dwTexLOD;         // Level of detail we're required to load
#endif // DX7_TEXMANAGEMENT

#if DX7_PALETTETEXTURE       // Saved when D3DDP2OP_SETPALETTE is received
    DWORD dwPaletteHandle;   // Palette handle associated to this texture
    DWORD dwPaletteFlags;    // Palette flags regarding the assoc palette
#endif
   
} P3_SURF_INTERNAL;

#endif // __D3DSURF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsurf.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsurf.c
*
* Content: Surface management callbacks for D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"

//@@BEGIN_DDKSPLIT

#if DBG

// Whistler bug 281090 detection func, print warning msg only, remove later
void 
vDetectMixedMIPLevels(
    LPDDRAWI_DDRAWSURFACE_LCL pTopLevel)
{
    LPDDRAWI_DDRAWSURFACE_LCL pCurLevel;
    DWORD dwMIPCaps;

    // Check whether this is a MIP texture
    dwMIPCaps = DDSCAPS_COMPLEX | DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
    if ((pTopLevel->ddsCaps.dwCaps & dwMIPCaps) != dwMIPCaps)
    {
        return;
    }

    // Check whether all the levels have the same cap bits
    pCurLevel = pTopLevel;
    do 
    {        
        if (pCurLevel->ddsCaps.dwCaps != pTopLevel->ddsCaps.dwCaps) 
        {
            DISPDBG((ERRLVL, 
                     "BUG281090 : MIP levels of mixed type (0x%x : 0x%x, 0x%x)",
                     pTopLevel->lpSurfMore->dwSurfaceHandle,
                     pCurLevel->ddsCaps.dwCaps, pTopLevel->ddsCaps.dwCaps));
        }

        if (pCurLevel->lpAttachList)
        {
            pCurLevel = pCurLevel->lpAttachList->lpAttached;
        }
        else
        {
            break;
        }
    } while ((pCurLevel != NULL) && (pCurLevel != pTopLevel));
}

#endif

//@@END_DDKSPLIT

//-----------------------------Public Routine----------------------------------
//
// D3DCreateSurfaceEx
//
// D3dCreateSurfaceEx creates a Direct3D surface from a DirectDraw surface and 
// associates a requested handle value to it.
//
// All Direct3D drivers must support D3dCreateSurfaceEx.
//
// D3dCreateSurfaceEx creates an association between a DirectDraw surface and 
// a small integer surface handle. By creating these associations between a
// handle and a DirectDraw surface, D3dCreateSurfaceEx allows a surface handle
// to be imbedded in the Direct3D command stream. For example when the
// D3DDP2OP_TEXBLT command token is sent to D3dDrawPrimitives2 to load a texture
// map, it uses a source handle and destination handle which were associated
//  with a DirectDraw surface through D3dCreateSurfaceEx.
//
// For every DirectDraw surface created under the local DirectDraw object, the
// runtime generates a valid handle that uniquely identifies the surface and
// places it in pcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle. This handle value
// is also used with the D3DRENDERSTATE_TEXTUREHANDLE render state to enable
// texturing, and with the D3DDP2OP_SETRENDERTARGET and D3DDP2OP_CLEAR commands
// to set and/or clear new rendering and depth buffers. The driver should fail
// the call and return DDHAL_DRIVER_HANDLE if it cannot create the Direct3D
// surface. 
//
// As appropriate, the driver should also store any surface-related information
// that it will subsequently need when using the surface. The driver must create
// a new surface table for each new lpDDLcl and implicitly grow the table when
// necessary to accommodate more surfaces. Typically this is done with an
// exponential growth algorithm so that you don't have to grow the table too
// often. Direct3D calls D3dCreateSurfaceEx after the surface is created by
// DirectDraw by request of the Direct3D runtime or the application.
//
// Parameters
//
//      lpcsxd
//           pointer to CreateSurfaceEx structure that contains the information
//           required for the driver to create the surface (described below). 
//
//           dwFlags
//                   Currently unused
//           lpDDLcl
//                   Handle to the DirectDraw object created by the application.
//                   This is the scope within which the lpDDSLcl handles exist.
//                   A DD_DIRECTDRAW_LOCAL structure describes the driver.
//           lpDDSLcl
//                   Handle to the DirectDraw surface we are being asked to
//                   create for Direct3D. These handles are unique within each
//                   different DD_DIRECTDRAW_LOCAL. A DD_SURFACE_LOCAL structure
//                   represents the created surface object.
//           ddRVal
//                   Specifies the location in which the driver writes the return
//                   value of the D3dCreateSurfaceEx callback. A return code of
//                   DD_OK indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLE
//      DDHAL_DRIVER_NOTHANDLE
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
D3DCreateSurfaceEx(
    LPDDHAL_CREATESURFACEEXDATA lpcsxd )
{
    P3_THUNKEDDATA *pThisDisplay;
    PointerArray* pSurfaceArray;
    GET_THUNKEDDATA(pThisDisplay, lpcsxd->lpDDLcl->lpGbl);

    DBG_CB_ENTRY(D3DCreateSurfaceEx);

    DISPDBG((DBGLVL,"D3DCreateSurfaceEx surface %d @ %x caps = %x",
                    (DWORD)lpcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle,
                    lpcsxd->lpDDSLcl->lpGbl->fpVidMem,
                    lpcsxd->lpDDSLcl->ddsCaps.dwCaps));               

    // Get a pointer to an array of DWORD's containing surfaces
    pSurfaceArray = (PointerArray*)HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                               (ULONG_PTR)lpcsxd->lpDDLcl);

    // If there isn't a handle set for this directdraw object, create one.
    if (!pSurfaceArray)
    {
        DISPDBG((DBGLVL,"Creating new pointer array for PDDLcl 0x%x", 
                        lpcsxd->lpDDLcl));

        pSurfaceArray = PA_CreateArray();

        if (pSurfaceArray)
        {
            PA_SetDataDestroyCallback(pSurfaceArray, 
                                      _D3D_SU_SurfaceArrayDestroyCallback);

            if(!HT_AddEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                            (ULONG_PTR)lpcsxd->lpDDLcl, 
                            pSurfaceArray))
            {
                // failed to add entry, noe cleanup and exit
                // We ran out of memory. Cleanup before we leave  
                PA_DestroyArray(pSurfaceArray, pThisDisplay);
                DISPDBG((ERRLVL,"ERROR: Couldn't allocate "
                                "surface internal data mem for pSurfaceArray"));
                lpcsxd->ddRVal = DDERR_OUTOFMEMORY;
                DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
                return DDHAL_DRIVER_HANDLED;                   
            }
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate "
                            "surface internal data mem"));
            lpcsxd->ddRVal = DDERR_OUTOFMEMORY;
            DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
            return DDHAL_DRIVER_HANDLED;       
        }
    }

    // Recursively record the surface(s)

    lpcsxd->ddRVal = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                          pSurfaceArray,
                                                          lpcsxd->lpDDLcl,
                                                          lpcsxd->lpDDSLcl,
                                                          lpcsxd->lpDDSLcl);

//@@BEGIN_DDKSPLIT

#if DBG

    // Whistler bug 281090 detection code, print warning msg only, remove later
    vDetectMixedMIPLevels(lpcsxd->lpDDSLcl);

#endif

//@@END_DDKSPLIT

    DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DCreateSurfaceEx

//-----------------------------Public Routine----------------------------------
//
// D3DDestroyDDLocal
//
// D3dDestroyDDLocal destroys all the Direct3D surfaces previously created by
// D3DCreateSurfaceEx that belong to the same given local DirectDraw object.
//
// All Direct3D drivers must support D3dDestroyDDLocal.
// Direct3D calls D3dDestroyDDLocal when the application indicates that the
// Direct3D context is no longer required and it will be destroyed along with
// all surfaces associated to it. The association comes through the pointer to
// the local DirectDraw object. The driver must free any memory that the
// driver's D3dCreateSurfaceExDDK_D3dCreateSurfaceEx_GG callback allocated for
// each surface if necessary. The driver should not destroy the DirectDraw
// surfaces associated with these Direct3D surfaces; this is the application's
// responsibility.
//
// Parameters
//
//      lpdddd
//            Pointer to the DestroyLocalDD structure that contains the
//            information required for the driver to destroy the surfaces.
//
//            dwFlags
//                  Currently unused
//            pDDLcl
//                  Pointer to the local Direct Draw object which serves as a
//                  reference for all the D3D surfaces that have to be 
//                  destroyed.
//            ddRVal
//                  Specifies the location in which the driver writes the 
//                  return value of D3dDestroyDDLocal. A return code of DD_OK
//                  indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK
D3DDestroyDDLocal(
    LPDDHAL_DESTROYDDLOCALDATA pddl)
{
    P3_THUNKEDDATA *pThisDisplay;
    GET_THUNKEDDATA(pThisDisplay, pddl->pDDLcl->lpGbl);

    DBG_CB_ENTRY(D3DDestroyDDLocal);
    
    // Removing this entry from the hash table will cause the data destroy 
    // callback to be called, which will in turn free all of the texture 
    // structures that were allocated for this LCL
    HT_RemoveEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                   (ULONG_PTR)pddl->pDDLcl,
                   pThisDisplay);

    pddl->ddRVal = DD_OK;
    
    DBG_CB_EXIT(D3DDestroyDDLocal, DDHAL_DRIVER_HANDLED);    
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDestroyDDLocal


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

HRESULT 
_D3D_SU_SurfInternalSetDataRecursive(
    P3_THUNKEDDATA* pThisDisplay, 
    PointerArray* pSurfaceArray,
    LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
    LPDDRAWI_DDRAWSURFACE_LCL pRootDDSurfLcl,
    LPDDRAWI_DDRAWSURFACE_LCL pCurDDSurfLcl)
{
    P3_SURF_INTERNAL* pSurfInternal;
    DWORD dwSurfaceHandle;
    LPATTACHLIST pCurAttachList;
    HRESULT hRes;

    DBG_CB_ENTRY(_D3D_SU_SurfInternalSetDataRecursive);

    dwSurfaceHandle = (DWORD)pCurDDSurfLcl->lpSurfMore->dwSurfaceHandle;
                    
#if DBG
    DISPDBG((DBGLVL, "D3DCreateSuraceEx Handle = %d fpVidMem = 0x%x (%s)",
                     dwSurfaceHandle, 
                     pCurDDSurfLcl->lpGbl->fpVidMem,
                     pcSimpleCapsString(pCurDDSurfLcl->ddsCaps.dwCaps)));
#endif                         
                
    DBGDUMP_DDRAWSURFACE_LCL(10, pCurDDSurfLcl);

    // If this surface doesn't have a handle, return safely
    if (! dwSurfaceHandle)
    {
        return (DD_OK);
    }

    DISPDBG((DBGLVL,"Surface has a valid handle.  Setting it up"));

    // Get the texture from within the surface array
    pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

    // If we didn't find the texture, create one
    if (! pSurfInternal)
    {
        DISPDBG((DBGLVL,"Creating new internal surface for handle: 0x%x", 
                        dwSurfaceHandle));

        // Allocate the texture data space, because it hasn't 
        // been done already
        pSurfInternal = (P3_SURF_INTERNAL*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                                      sizeof(P3_SURF_INTERNAL),
                                                      ALLOC_TAG_DX(A));
        if (pSurfInternal == NULL)
        {
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate surface "
                            "internal data mem"));
            
            DBG_CB_EXIT(_D3D_SU_SurfInternalSetDataRecursive, 
                        DDERR_OUTOFMEMORY);
            return (DDERR_OUTOFMEMORY);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"Surface handle re-used: 0x%x", 
                        dwSurfaceHandle));
    }

    // Add this texture to the surface list
    if (! PA_SetEntry(pSurfaceArray, dwSurfaceHandle, pSurfInternal))
    {
        return (DDERR_OUTOFMEMORY);
    }

    // Setup the surface structure
    _D3D_SU_SurfInternalSetData(pThisDisplay, 
                                pSurfInternal,
                                pCurDDSurfLcl,
                                dwSurfaceHandle);

    // Keep a pointer to the DD_DIRECTDRAW_LOCAL in order to 
    // update colorkeying in DDSetColorKey possible. Notice
    // this is stored in DD_SURFACE_LOCAL.dwReserved1 as
    // DD_SURFACE_GLOBAL.dwReserved1 is being used for other
    // purpouses
    pCurDDSurfLcl->dwReserved1 = (ULONG_PTR)pDDLcl;
  
    // Don't need a seperate handle for mipmaps 
    // or cubemaps as they are atomic in DX7.
    if ((pCurDDSurfLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) || 
        (pCurDDSurfLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP))
    {
        return (DD_OK);
    }

    pCurAttachList = pCurDDSurfLcl->lpAttachList;
    // Simple surface, mission accomplished
    if (! pCurAttachList)
    {
        return (DD_OK);
    }

    // This recursion is usually needed for complex flipping chains
    pCurDDSurfLcl = pCurAttachList->lpAttached;
    if (pCurDDSurfLcl && (pCurDDSurfLcl != pRootDDSurfLcl)) 
    {
        hRes = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                    pSurfaceArray,
                                                    pDDLcl,
                                                    pRootDDSurfLcl,
                                                    pCurDDSurfLcl);
        if (FAILED(hRes)) 
        {
            return (hRes);
        }
    }
    
    // This part will normally be enterned when stereo mode is on
    if (pCurAttachList->lpLink) 
    {
        pCurDDSurfLcl = pCurAttachList->lpLink->lpAttached;
        if (pCurDDSurfLcl && (pCurDDSurfLcl != pRootDDSurfLcl)) 
        {
            hRes = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                        pSurfaceArray,
                                                        pDDLcl,
                                                        pRootDDSurfLcl,
                                                        pCurDDSurfLcl);
            if (FAILED(hRes)) 
            {
                return (hRes);
            }
        }
    }

    return (DD_OK);
}

//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfInternalSetMipMapLevelData
//
// Records the a LOD level and all associated information so that the chip 
// can use it later.
//
// Notice that ONLY while the D3DCreateSurfaceEx call is being made is the 
// LPDDRAWI_DDRAWSURFACE_LCL/PDD_LOCAL_SURFACE structure valid (Win9x/Win2K)
// so we cannot just cache a pointer to it for later use.
//
//-----------------------------------------------------------------------------
void 
_D3D_SU_SurfInternalSetMipMapLevelData(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_SURF_INTERNAL* pTexture, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
    int LOD)
{
    ASSERTDD(pSurf != NULL, "ERROR: NULL surface!");

    DISPDBG((6,"Storing LOD: %d, Pitch: %d, Width: %d", 
                LOD, pSurf->lpGbl->lPitch, pSurf->lpGbl->wWidth));

    // Get the byte offset to the texture map from the base of video
    // memory or as a physical mem address (for AGP surfaces). This
    // cases will be taken care of by DDSurf_SurfaceOffsetFromMemoryBase.
    pTexture->MipLevels[LOD].dwOffsetFromMemoryBase = 
                    DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSurf);

    // Store the DD surface's fpVidMem ptr
    pTexture->MipLevels[LOD].fpVidMem = pSurf->lpGbl->fpVidMem;

    // The TextureMapWidth hardware register holds width, layout, border and 
    // AGP settings, and we will create an instance for each miplevel we'll use

    // Store the layout for this texture map 
    // (linear layout is always used in this driver, we don't use patched surfs)
    pTexture->MipLevels[LOD].P3RXTextureMapWidth.Layout = P3RX_LAYOUT_LINEAR;

    // Store the pitch for this texture map level                               
    pTexture->MipLevels[LOD].P3RXTextureMapWidth.Width = 
                                DDSurf_GetPixelPitch(pSurf);

    // Store the DD surface's lPitch
    pTexture->MipLevels[LOD].lPitch = pSurf->lpGbl->lPitch;   
                                
    // Store AGP settings for this texture map    
    if( pSurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM )
        pTexture->MipLevels[LOD].P3RXTextureMapWidth.HostTexture = 1;
    else
        pTexture->MipLevels[LOD].P3RXTextureMapWidth.HostTexture = 0;

    // Store mip level size
    pTexture->MipLevels[LOD].wWidth =  (int)pSurf->lpGbl->wWidth;
    pTexture->MipLevels[LOD].wHeight = (int)pSurf->lpGbl->wHeight;    
    pTexture->MipLevels[LOD].logWidth = log2((int)pSurf->lpGbl->wWidth);
    pTexture->MipLevels[LOD].logHeight = log2((int)pSurf->lpGbl->wHeight);
    
} // _D3D_SU_SurfInternalSetMipMapLevelData


//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfInternalSetData
//
// Sets up all the necessary data for an internal surface structure.
//
//-----------------------------------------------------------------------------
BOOL 
_D3D_SU_SurfInternalSetData(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_SURF_INTERNAL *pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    DWORD dwSurfaceHandle)
{
    DBG_ENTRY(_D3D_SU_SurfInternalSetData);

    // Store the pointer to the texture in the structure
    pSurface->pFormatSurface = _DD_SUR_GetSurfaceFormat(pDDSLcl);
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pDDSLcl); 

    // Initially no LUT
    pSurface->dwLUTOffset = 0;

    // Need to remember the sizes and the log of the sizes of the maps
    pSurface->wWidth = (WORD)(pDDSLcl->lpGbl->wWidth);
    pSurface->wHeight = (WORD)(pDDSLcl->lpGbl->wHeight);
    pSurface->fArea = (float)pSurface->wWidth * (float)pSurface->wHeight;
    pSurface->logWidth = log2((int)pDDSLcl->lpGbl->wWidth);
    pSurface->logHeight = log2((int)pDDSLcl->lpGbl->wHeight);

    // Store the pointer to surface memory
    pSurface->fpVidMem = pDDSLcl->lpGbl->fpVidMem;

    // Magic number for validity check
    pSurface->MagicNo = SURF_MAGIC_NO;

    // This value is used if the texture turns out to be agp
    pSurface->dwGARTDevLast = pThisDisplay->dwGARTDev;

    // For AGP and correct rendering we need to know where the surface is stored
    if(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
    {
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            DISPDBG((DBGLVL,"  Surface %d is in AGP Memory",dwSurfaceHandle));
            pSurface->Location = AGPMemory;
        }
        else
        {
            DISPDBG((DBGLVL,"  Surface %d is in Video Memory",dwSurfaceHandle));
            pSurface->Location = VideoMemory;
        }
    }
    else
    {
        DISPDBG((DBGLVL,"  Surface %d is in system memory - "
                        "disabling use for rendering", dwSurfaceHandle));
        pSurface->Location = SystemMemory;
    }

    // Store caps & other DD fields for later
    pSurface->ddsCapsInt = pDDSLcl->ddsCaps;
    pSurface->dwFlagsInt = pDDSLcl->dwFlags;
    pSurface->dwCKLow = pDDSLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
    pSurface->dwCKHigh = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    pSurface->pixFmt = *DDSurf_GetPixelFormat(pDDSLcl);
    pSurface->dwPixelSize = DDSurf_GetChipPixelSize(pDDSLcl);
    pSurface->dwPixelPitch = DDSurf_GetPixelPitch(pDDSLcl);
    pSurface->dwPatchMode = P3RX_LAYOUT_LINEAR;
    pSurface->lOffsetFromMemoryBase = DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDDSLcl);
    pSurface->lPitch = pDDSLcl->lpGbl->lPitch;
    pSurface->dwBitDepth = DDSurf_BitDepth(pDDSLcl);

#if DX7_TEXMANAGEMENT  
    _D3D_TM_InitSurfData(pSurface, pDDSLcl);
#endif
    
#if DX8_MULTISAMPLING
    pSurface->dwSampling =
       (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK );
#endif // DX8_MULTISAMPLING

    // Additional surface setup if it is a texture
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf;
        int iLOD;
        
        lpNextSurf = pDDSLcl;
        iLOD = 0;

#if DX8_3DTEXTURES
        if ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (pSurface->dwBitDepth != 0))
        { 
            // Mark this texture as 3D texture.
            pSurface->b3DTexture     = TRUE;
            pSurface->wDepth         = LOWORD(pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4);
            pSurface->logDepth       = log2((int)pSurface->wDepth);
            pSurface->dwSlice        = pDDSLcl->lpGbl->dwBlockSizeY;
            pSurface->dwSliceInTexel = pDDSLcl->lpGbl->dwBlockSizeY /
                                   (DDSurf_BitDepth(pDDSLcl) / 8);
        }
        else
        {
            // Not a 3D texture
            pSurface->b3DTexture     = FALSE;
            pSurface->wDepth         = 0;
            pSurface->logDepth       = 0;
            pSurface->dwSlice        = 0;
            pSurface->dwSliceInTexel = 0;
        }
#endif // DX8_3DTEXTURES

        // For Permedia the texture offset is in pixels.
        // Store the offsets for each of the mipmap levels
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            BOOL bMoreSurfaces = TRUE;

            pSurface->bMipMap = TRUE;

            // Walk the chain of surfaces and find all of the mipmap levels

            do
            {
                DISPDBG((DBGLVL, "Loading texture iLOD:%d, Ptr:0x%x", 
                                 iLOD, lpNextSurf->lpGbl->fpVidMem));

                _D3D_SU_SurfInternalSetMipMapLevelData(pThisDisplay, 
                                                       pSurface, 
                                                       lpNextSurf, 
                                                       iLOD);

                // Is there another surface in the chain?

                if (lpNextSurf->lpAttachList)
                    lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                else
                    bMoreSurfaces = FALSE;

                iLOD++;
            }
            while( bMoreSurfaces );

            // This isn't really a MipMap if iLOD is 1

            if (iLOD == 1) 
            {
                DISPDBG((DBGLVL, "Texture was not a mipmap - only 1 level"));
                pSurface->bMipMap = FALSE;
            }           

            pSurface->iMipLevels = iLOD;
        }
        else // NOT A MIPMAP, simply store away the offset
        {
            pSurface->bMipMap = FALSE;
            pSurface->iMipLevels = 1;
            _D3D_SU_SurfInternalSetMipMapLevelData(pThisDisplay, 
                                                   pSurface, 
                                                   lpNextSurf, 
                                                   iLOD);
        }
    } // if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )

#if DX7_PALETTETEXTURE
    // Initialize the palette handle and flags
    pSurface->dwPaletteHandle = 0;
    pSurface->dwPaletteFlags = 0;            
#endif

    DBG_EXIT(_D3D_SU_SurfInternalSetData, TRUE);
    return TRUE;
    
} // _D3D_SU_SurfInternalSetData 

//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfaceArrayDestroyCallback
//
// Called when a surface is removed from the pointer array associated with a
// DirectDraw local.  Simply frees the memory
//-----------------------------------------------------------------------------
void 
_D3D_SU_SurfaceArrayDestroyCallback(
    PointerArray* pArray, 
    void* pData,
    void* pExtra)
{
    P3_SURF_INTERNAL* pTexture = (P3_SURF_INTERNAL*)pData;
    P3_THUNKEDDATA *pThisDisplay =  (P3_THUNKEDDATA*)pExtra;
    
    DBG_ENTRY(_D3D_SU_SurfaceArrayDestroyCallback);

#if DX7_TEXMANAGEMENT
    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        _D3D_TM_RemoveTexture(pThisDisplay, pTexture);
    }
#endif

    // Simply free the data
    HEAP_FREE(pData);

    DBG_EXIT(_D3D_SU_SurfaceArrayDestroyCallback, TRUE);    
    
} // _D3D_SU_SurfaceArrayDestroyCallback


//-----------------------------------------------------------------------------
//
// _D3D_SU_DirectDrawLocalDestroyCallback
//
// Called when a directdraw local is removed from the hash table.
// We use the pointer associated with it to free the pointer array that 
// was created.
//
//-----------------------------------------------------------------------------

void 
_D3D_SU_DirectDrawLocalDestroyCallback(
    HashTable* pTable, 
    void* pData,
    void* pExtra)
{
    PointerArray* pPointerArray = (PointerArray*)pData;

    DBG_ENTRY(_D3D_SU_DirectDrawLocalDestroyCallback);    

    if (pPointerArray)
    {

        DISPDBG((DBGLVL, "Destroying an array of surface pointers for this "
                         "LCL ddraw object"));
        // The data hanging off the local object is a pointerarray.
        // Calling destory will cause it to free the data items through the
        // callback if one is registered.
        PA_DestroyArray(pPointerArray, pExtra);
    }
    
    DBG_EXIT(_D3D_SU_DirectDrawLocalDestroyCallback, TRUE);  
    
} // _D3D_SU_DirectDrawLocalDestroyCallback


#if DX7_PALETTETEXTURE
//-----------------------------------------------------------------------------
//
// _D3D_SU_PaletteArrayDestroyCallback
//
// Called when a palette is removed from the pointer array.
// Simply frees the memory
//-----------------------------------------------------------------------------
void
_D3D_SU_PaletteArrayDestroyCallback(
    PointerArray* pArray,
    void* pData,
    void* pExtra)
{
    DBG_ENTRY(_D3D_SU_PaletteArrayDestroyCallback);

    // Simply free the data
    HEAP_FREE(pData);

    DBG_EXIT(_D3D_SU_PaletteArrayDestroyCallback, TRUE);

} // _D3D_SU_PaletteArrayDestroyCallback
#endif // DX7_PALETTESURFACE

//-----------------------------------------------------------------------------
//
// _D3D_SU_DumpSurfInternal
//
// Dumps into the debugger the drivers private data structure for the surface
//
//-----------------------------------------------------------------------------

void 
_D3D_SU_DumpSurfInternal(
    DWORD lvl,
    char *psHeader,
    P3_SURF_INTERNAL *pSurface)
{
    int i;
    
    DISPDBG((lvl,"Dumping %s surface @ %x",psHeader,pSurface));
    
    DISPDBG((lvl,"    MagicNo = 0x%x",pSurface->MagicNo));
    DISPDBG((lvl,"    pFormatSurface = 0x%x",pSurface->pFormatSurface)); // P3_SURF_FORMAT* pFormatSurface; 
    DISPDBG((lvl,"    Location = %d",pSurface->Location));
    DISPDBG((lvl,"    dwLUTOffset = 0x%x",pSurface->dwLUTOffset));
    DISPDBG((lvl,"    dwGARTDevLast = 0x%x",pSurface->dwGARTDevLast));
    DISPDBG((lvl,"    wWidth = %d",(LONG)pSurface->wWidth));
    DISPDBG((lvl,"    wHeight = %d",(LONG)pSurface->wHeight));
    DISPDBG((lvl,"    logWidth = %d",pSurface->logWidth));
    DISPDBG((lvl,"    logHeight = %d",pSurface->logHeight));
    DISPDBG((lvl,"    fArea = 0x%x",*(DWORD *)&pSurface->fArea));
    // DDSCAPS ddsCapsInt;  
    DISPDBG((lvl,"    dwFlagsInt = 0x%x",pSurface->dwFlagsInt));
    DISPDBG((lvl,"    dwCKLow = 0x%x",pSurface->dwCKLow));
    DISPDBG((lvl,"    dwCKHigh = 0x%x",pSurface->dwCKHigh));
    // DDPIXELFORMAT pixFmt;    
    DISPDBG((lvl,"    dwPixelSize = 0x%x",pSurface->dwPixelSize));   
    DISPDBG((lvl,"    dwPixelPitch = 0x%x",pSurface->dwPixelPitch));    
    DISPDBG((lvl,"    dwPatchMode = 0x%x",pSurface->dwPatchMode));   
    DISPDBG((lvl,"    lPitch = 0x%x",pSurface->lPitch)); 
    DISPDBG((lvl,"    fpVidMem = 0x%x",pSurface->fpVidMem)); 
#if DX8_3DTEXTURES
    DISPDBG((lvl,"    b3DTexture = 0x%x",pSurface->b3DTexture)); 
    DISPDBG((lvl,"    wDepth = %d",(LONG)pSurface->wDepth)); 
#endif // DX8_3DTEXTURES
    DISPDBG((lvl,"    bMipMap = 0x%x",pSurface->bMipMap)); 
    DISPDBG((lvl,"    iMipLevels = %d",pSurface->iMipLevels));     

    for (i = 0; i < pSurface->iMipLevels; i++)
    {
        DISPDBG((lvl,"    MipLevels[%d].logWidth = 0x%x",
                            i,pSurface->MipLevels[i].logWidth)); 
        DISPDBG((lvl,"    MipLevels[%d].logHeight = 0x%x",
                            i,pSurface->MipLevels[i].logHeight));         
        DISPDBG((lvl,"    MipLevels[%d].dwOffsetFromMemoryBase = 0x%x",
                            i,pSurface->MipLevels[i].dwOffsetFromMemoryBase));         
        DISPDBG((lvl,"    MipLevels[%d].fpVidMem = 0x%x",
                            i,pSurface->MipLevels[i].fpVidMem));     
        DISPDBG((lvl,"    MipLevels[%d].lPitch = 0x%x",
                            i,pSurface->MipLevels[i].lPitch));                             
        DISPDBG((lvl,"    MipLevels[%d].P3RXTextureMapWidth = 0x%x",
                            i,*(DWORD*)(&pSurface->MipLevels[i].P3RXTextureMapWidth)));          
    }


} // _D3D_SU_DumpSurfInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstrct.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstrct.c
*
* Content: Internal D3D structure management.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"
#include "d3dstrct.h"

//----------------------------------------------------------------------------
// This file provides a centralized place where we manage ans use internal
// data structures for the driver. This way, we can change the data structure
// or its management without affecting the rest of the code.
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//********************** A R R A Y     S T R U C T U R E *********************
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// PA_CreateArray
//
// Creates an array of pointers.
//
//-----------------------------------------------------------------------------
PointerArray* 
PA_CreateArray()
{
    PointerArray* pNewArray;
    
    pNewArray = HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                           sizeof(PointerArray),
                           ALLOC_TAG_DX(5));

    if (!pNewArray)
    {
        DISPDBG((ERRLVL,"ERROR: PointerArray allocation failed"));
        return NULL;
    }

    // Explicit initialization
    pNewArray->pPointers          = NULL;
    pNewArray->dwNumPointers      = 0;
    pNewArray->pfnDestroyCallback = NULL;
    
    return pNewArray;
} // PA_CreateArray

//-----------------------------------------------------------------------------
//
// PA_SetDataDestroyCallback
//
// Records the data pointer destroy callback.
//
//-----------------------------------------------------------------------------
void 
PA_SetDataDestroyCallback(
    PointerArray* pArray, 
    PA_DestroyCB DestroyCallback)
{
    pArray->pfnDestroyCallback = DestroyCallback;
    
} // PA_SetDataDestroyCallback

//-----------------------------------------------------------------------------
//
// PA_DestroyArray
//
// Destroys all the pointers in the array.  Optionally calls a callback with 
// each pointer to allow clients to free objects associated with the pointer
//-----------------------------------------------------------------------------
BOOL 
PA_DestroyArray(PointerArray* pArray, VOID *pExtra)
{
    if (pArray != NULL)
    {
        if (pArray->pPointers != NULL)
        {
            DWORD dwCount;
            
            // If there is a registered destroy callback, call it for every
            // non-null data pointer
            if (pArray->pfnDestroyCallback != NULL) 
            {
                for (dwCount = 0; dwCount < pArray->dwNumPointers; dwCount++)
                {
                    if (pArray->pPointers[dwCount] != 0)
                    {
                        // Call the data destroy callback
                        pArray->pfnDestroyCallback(
                                        pArray, 
                                        (void*)pArray->pPointers[dwCount],
                                        pExtra);
                    }
                }
            }

            // Free the Array of Pointers
            HEAP_FREE(pArray->pPointers);
            pArray->pPointers = NULL;
        }

        // Free the pointer array
        HEAP_FREE(pArray);
    }

    return TRUE;
} // PA_DestroyArray

//-----------------------------------------------------------------------------
//
// PA_GetEntry
//
// Look up the Pointer in the array an return it
//
//-----------------------------------------------------------------------------
void* 
PA_GetEntry(PointerArray* pArray, DWORD dwNum)
{
    ASSERTDD((pArray != NULL), "ERROR: Bad Pointer array!");

    if ((pArray->dwNumPointers == 0)         || 
        (dwNum > (pArray->dwNumPointers - 1))  )
    {
        // We will be getting called frequently by D3DCreateSurfaceEx for
        // handles which might not be initialized so this will be hit often
        DISPDBG((DBGLVL,"PA_GetEntry: Ptr outside of range (usually OK)"));
        return NULL;
    }

    return (void*)pArray->pPointers[dwNum]; 
} // PA_GetEntry

//-----------------------------------------------------------------------------
//
// PA_SetEntry
//
// Sets an entry in the array of pointers.  If the entry is larger than
// the array, the array is grown to accomodate it. Returns FALSE if we
// fail to set the data for any reason (mainly out of memory).
//
//-----------------------------------------------------------------------------
BOOL 
PA_SetEntry(
    PointerArray* pArray, 
    DWORD dwNum, 
    void* pData)
{   
    ASSERTDD(pArray != NULL, "Bad pointer array");

    if ( (dwNum + 1 ) > pArray->dwNumPointers )
    {
        ULONG_PTR* pNewArray;
        DWORD dwNewArrayLength, dwNewArraySize;
        
        //
        // The array either already exists and has to be grown in size
        // or doesnt exist at all
        //
        
        DISPDBG((DBGLVL, "Expanding/creating pointer array"));
        
        dwNewArrayLength = (dwNum * 2) + 1; // Tunable heuristic
                                            // ask for double of the space
                                            // needed for the new element
        dwNewArraySize = dwNewArrayLength * sizeof(ULONG_PTR);
        pNewArray = (ULONG_PTR*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           dwNewArraySize,
                                           ALLOC_TAG_DX(7));
        if (pNewArray == NULL)
        {
            DISPDBG((DBGLVL,"ERROR: Failed to allocate new Pointer array!!"));
            return FALSE;
        }

        if (pArray->pPointers != NULL)
        {
            // We had an old valid array before this, so we need to transfer 
            // old array elements into the new array and destroy the old array
            memcpy( pNewArray, 
                    pArray->pPointers,
                    (pArray->dwNumPointers * sizeof(ULONG_PTR)) );
                    
            HEAP_FREE(pArray->pPointers);

        }

        // Update our pointer to the array and its size info
        pArray->pPointers = pNewArray;
        pArray->dwNumPointers = dwNewArrayLength;
    }

    pArray->pPointers[dwNum] = (ULONG_PTR)pData;

    return TRUE;
    
} // PA_SetEntry

//----------------------------------------------------------------------------
//********************** H A S H       S T R U C T U R E *********************
//----------------------------------------------------------------------------

// Manages a hash table
// Each slot contains front and back pointers, a handle, and an app-specific 
// data pointer. Entries are the things that the clients add/remove
// Slots are the internal data chunks that are managed as part of the hash table

//-----------------------------------------------------------------------------
//
// HT_CreateHashTable
//
//-----------------------------------------------------------------------------
HashTable* 
HT_CreateHashTable()
{
    HashTable* pHashTable;

    DISPDBG((DBGLVL,"In HT_CreateHashTable"));

    pHashTable = (HashTable*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                        sizeof(HashTable),
                                        ALLOC_TAG_DX(8));
    if (pHashTable == NULL)
    {
        DISPDBG((DBGLVL,"Hash table alloc failed!"));
        return NULL;
    }   

    return pHashTable;
} // HT_CreateHashTable


//-----------------------------------------------------------------------------
//
// HT_SetDataDestroyCallback
//
//-----------------------------------------------------------------------------
void 
HT_SetDataDestroyCallback(
    HashTable* pHashTable, 
    DataDestroyCB DestroyCallback)
{
    DISPDBG((DBGLVL,"In HT_SetDataDestroyCallback"));
    ASSERTDD(pHashTable != NULL,"ERROR: HashTable passed in is not valid!");

    pHashTable->pfnDestroyCallback = DestroyCallback;
} // HT_SetDataDestroyCallback

//-----------------------------------------------------------------------------
//
// HT_ClearEntriesHashTable
//
//-----------------------------------------------------------------------------
void 
HT_ClearEntriesHashTable(HashTable* pHashTable, VOID* pExtra)
{
    int i;
    HashSlot* pHashSlot = NULL;

    DISPDBG((DBGLVL,"In HT_ClearEntriesHashTable"));
    
    ASSERTDD(pHashTable != NULL,"ERROR: HashTable passed in is not valid!");

    for (i = 0; i < HASH_SIZE; i++)
    {
        while (pHashSlot = pHashTable->Slots[i])
        {
            HT_RemoveEntry(pHashTable, pHashSlot->dwHandle, pExtra);
        }

        pHashTable->Slots[i] = NULL;
    }

} // HT_ClearEntriesHashTable

//-----------------------------------------------------------------------------
//
// HT_DestroyHashTable
//
//-----------------------------------------------------------------------------
void 
HT_DestroyHashTable(HashTable* pHashTable, VOID* pExtra)
{

    HT_ClearEntriesHashTable(pHashTable, pExtra);

    HEAP_FREE(pHashTable);

} // HT_DestroyHashTable


//-----------------------------------------------------------------------------
//
// vBOOL HT_AddEntry
//
//-----------------------------------------------------------------------------
BOOL HT_AddEntry(HashTable* pTable, ULONG_PTR dwHandle, void* pData)
{
    HashSlot* pHashSlot = NULL;
    
    DISPDBG((DBGLVL,"In HT_AddEntry"));
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pHashSlot = HEAP_ALLOC(HEAP_ZERO_MEMORY,
                           sizeof(HashSlot),
                           ALLOC_TAG_DX(9));
    
    if (pHashSlot == NULL)
    {
        DISPDBG((ERRLVL,"Hash entry alloc failed!"));
        return FALSE;
    }
    
    // Sew this new entry into the hash table
    if (pTable->Slots[HT_HASH_OF(dwHandle)])
    {
        pTable->Slots[HT_HASH_OF(dwHandle)]->pPrev = pHashSlot;
    }
           
    // Carry on a next pointer
    pHashSlot->pNext = pTable->Slots[HT_HASH_OF(dwHandle)];    
    pHashSlot->pPrev = NULL;      

    // Remember the app-supplied data and the handle
    pHashSlot->pData = pData;
    pHashSlot->dwHandle = dwHandle;

    // hash table refers to this one now.
    pTable->Slots[HT_HASH_OF(dwHandle)] = pHashSlot; 

    return TRUE;
} // HT_AddEntry

//-----------------------------------------------------------------------------
//
// BOOL HT_RemoveEntry
//
//-----------------------------------------------------------------------------
BOOL HT_RemoveEntry(HashTable* pTable, ULONG_PTR dwHandle, VOID *pExtra)
{
    HashSlot* pSlot = HT_GetSlotFromHandle(pTable, dwHandle);

    DISPDBG((DBGLVL,"In HT_RemoveEntry"));
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    if (pSlot == NULL)
    {
        DISPDBG((WRNLVL,"WARNING: Hash entry does not exist"));
        return FALSE;
    }

    // Mark the entry as gone from the hash table if it is at the front
    if (pTable->Slots[HT_HASH_OF(dwHandle)]->dwHandle == pSlot->dwHandle) 
    {
        pTable->Slots[HT_HASH_OF(dwHandle)] = 
                        pTable->Slots[HT_HASH_OF(dwHandle)]->pNext;
    }

    // and sew the list back together.
    if (pSlot->pPrev)
    {
        pSlot->pPrev->pNext = pSlot->pNext;
    }

    if (pSlot->pNext)
    {
        pSlot->pNext->pPrev = pSlot->pPrev;
    }

    // If the destroy data callback is setup, call it.
    if ((pSlot->pData != NULL) && (pTable->pfnDestroyCallback))
    {
        DISPDBG((WRNLVL,"Calling DestroyCallback for undestroyed data"));
        pTable->pfnDestroyCallback(pTable, pSlot->pData, pExtra);
    }

    // Free the memory associated with the slot
    HEAP_FREE(pSlot);

    return TRUE;
} // HT_RemoveEntry

//-----------------------------------------------------------------------------
//
// BOOL HT_SwapEntries
//
//-----------------------------------------------------------------------------
BOOL HT_SwapEntries(HashTable* pTable, DWORD dwHandle1, DWORD dwHandle2)
{
    HashSlot* pEntry1;
    HashSlot* pEntry2;
    void* pDataTemp;

    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pEntry1 = HT_GetSlotFromHandle(pTable, dwHandle1);
    pEntry2 = HT_GetSlotFromHandle(pTable, dwHandle2);

    // The handle remains the same, the pointers to the actual data are swapped
    if (pEntry1 && pEntry2)
    {
        pDataTemp = pEntry1->pData;
        pEntry1->pData = pEntry2->pData;
        pEntry2->pData = pDataTemp;

        return TRUE;
    }

    DISPDBG((ERRLVL,"ERROR: Swapped entries are invalid!"));
    
    return FALSE;
} // HT_SwapEntries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dcontext.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: dcontext.h
*
* Content: D3D context definition and other useful macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DCONTEXT_H
#define __DCONTEXT_H

#ifndef __SOFTCOPY
#include "softcopy.h"
#endif

#include "d3dsurf.h"
#include "d3dsset.h"

//-----------------------------------------------------------------------------
// Definitions for state overrides 
//-----------------------------------------------------------------------------
#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE       D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS      32
#define DWORD_SHIFT     5

typedef struct _D3DStateSet {
    DWORD               bits[MAX_STATE >> DWORD_SHIFT];
} D3DStateSet;

#define STATESET_MASK(set, state)       \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//-----------------------------------------------------------------------------
// Rendering flags , used to set/test the P3_D3DCONTEXT.Flags field
//
// SURFACE_ALPHASTIPPLE - Use alpha value to calculate a stipple pattern
// SURFACE_ENDPOINTENABLE - Enable last point on lines
// SURFACE_ALPHACHROMA - Is the alpha blending a chromakeying operation?
// SURFACE_MIPMAPPING - Is the filter mode setup for MipMapping?
// SURFACE_MODULATE - Are we emulating MODULATE (as apposed to MODULATEALPHA)?
// SURFACE_ANTIALIAS -  Are we antialiasing
//-----------------------------------------------------------------------------
#define SURFACE_GOURAUD         (1 << 0)
#define SURFACE_ZENABLE         (1 << 1)
#define SURFACE_SPECULAR        (1 << 2)
#define SURFACE_FOGENABLE       (1 << 3)
#define SURFACE_PERSPCORRECT    (1 << 4)
#define SURFACE_TEXTURING       (1 << 5)
#define SURFACE_ALPHAENABLE     (1 << 6)
#define SURFACE_MONO            (1 << 7)
#define SURFACE_ALPHASTIPPLE    (1 << 10)
#define SURFACE_ZWRITEENABLE    (1 << 11)
#define SURFACE_ENDPOINTENABLE  (1 << 12)
#define SURFACE_ALPHACHROMA     (1 << 13)
#define SURFACE_MIPMAPPING      (1 << 14)
#define SURFACE_MODULATE        (1 << 15)
#define SURFACE_ANTIALIAS       (1 << 16)

//-----------------------------------------------------------------------------
// Field values for P3_D3DCONTEXT.MagicNo field to signal its validity
#define RC_MAGIC_DISABLE 0xd3d00000
#define RC_MAGIC_NO 0xd3d00100

#define CHECK_D3DCONTEXT_VALIDITY(ptr)          \
    ( ((ptr) != NULL) && ((ptr)->MagicNo == RC_MAGIC_NO) )

//-----------------------------------------------------------------------------
// Renderer dirty flags definitions. 
//
// They help us keep track what state needs to be refreshed in the hw
//-----------------------------------------------------------------------------
#define CONTEXT_DIRTY_ALPHABLEND        (1 << 1)
#define CONTEXT_DIRTY_ZBUFFER           (1 << 2)
#define CONTEXT_DIRTY_TEXTURE           (1 << 3)
#define CONTEXT_DIRTY_RENDER_OFFSETS    (1 << 4)
#define CONTEXT_DIRTY_TEXTURESTAGEBLEND (1 << 5)
#define CONTEXT_DIRTY_ALPHATEST         (1 << 6)
#define CONTEXT_DIRTY_FOG               (1 << 7)
#define CONTEXT_DIRTY_STENCIL           (1 << 8)
#define CONTEXT_DIRTY_WBUFFER           (1 << 9)
#define CONTEXT_DIRTY_VIEWPORT          (1 << 10)
#define CONTEXT_DIRTY_PIPELINEORDER     (1 << 11)
#define CONTEXT_DIRTY_OPTIMIZE_ALPHA    (1 << 12)
#define CONTEXT_DIRTY_GAMMA             (1 << 31)
#define CONTEXT_DIRTY_EVERYTHING        (0xffffffff)

// Gamma state flags go into the dwDirtyGammaFlags field
#define CONTEXT_DIRTY_GAMMA_STATE               (1 << 0)
#define CONTEXT_DIRTY_GAMMA_MODELVIEW_MATRIX    (1 << 1)
#define CONTEXT_DIRTY_GAMMA_PROJECTION_MATRIX   (1 << 2)
#define CONTEXT_DIRTY_GAMMA_MATERIAL            (1 << 3)
// * Bits 16 + are for light dirty bits *
#define CONTEXT_DIRTY_GAMMA_EVERYTHING          (0xffffffff)


#define DIRTY_ALPHABLEND(pContext)                              \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHABLEND
    
#define DIRTY_ALPHATEST(pContext)                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHATEST

#define DIRTY_OPTIMIZE_ALPHA(pContext)                          \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_OPTIMIZE_ALPHA |    \
                                CONTEXT_DIRTY_ALPHATEST;        \
} while(0)

#define DIRTY_PIPELINEORDER(pContext)                           \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_PIPELINEORDER;      \
} while(0)

#define DIRTY_TEXTURE(pContext)                                 \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;            \
    pContext->pCurrentTexture[TEXSTAGE_0] = NULL;               \
    pContext->pCurrentTexture[TEXSTAGE_1] = NULL;               \
} while (0)

#define DIRTY_ZBUFFER(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ZBUFFER

#define DIRTY_RENDER_OFFSETS(pContext)                          \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_RENDER_OFFSETS;     \
} while (0)

#define DIRTY_VIEWPORT(pContext)                                \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_VIEWPORT;           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;              \
} while(0)

#define DIRTY_TEXTURESTAGEBLEND(pContext)                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURESTAGEBLEND
    
#define DIRTY_FOG(pContext)                                     \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_FOG
    
#define DIRTY_STENCIL(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_STENCIL
    
#define DIRTY_WBUFFER(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_WBUFFER

#define DIRTY_GAMMA_STATE                                               \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_STATE;           \
} while(0)

#define DIRTY_MODELVIEW                                                     \
do                                                                          \
{                                                                           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                          \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_MODELVIEW_MATRIX;    \
} while(0)

#define DIRTY_PROJECTION                                                    \
do                                                                          \
{                                                                           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                          \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_PROJECTION_MATRIX;   \
} while(0)

#define DIRTY_MATERIAL                                                  \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_MATERIAL;        \
} while(0)

#define DIRTY_LIGHT(pContext, a)                                        \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= (1 << (16 + (a)));                   \
} while(0)

#define DIRTY_EVERYTHING(pContext)                                      \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags = CONTEXT_DIRTY_EVERYTHING;                  \
} while(0)

//-----------------------------------------------------------------------------
//
// Texture Stage helper definitions
//
//-----------------------------------------------------------------------------
typedef struct tagTexStageState
{
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX];  // state array (float)
    };
} TexStageState;

typedef enum
{
    TEXSTAGE_0 = 0,
    TEXSTAGE_1 = 1,
    TEXSTAGE_2 = 2,
    TEXSTAGE_3 = 3,
    TEXSTAGE_4 = 4,
    TEXSTAGE_5 = 5,
    TEXSTAGE_6 = 6,
    TEXSTAGE_7 = 7,
    TEXSTAGE_8 = 8,
    TEXSTAGE_9 = 9
};

//-----------------------------------------------------------------------------
#define LUT_ENTRIES 256

//-----------------------------------------------------------------------------
// Possible ValidateDevice-type errors. Some of these match possible VD()
// returns, others don't (yet). Some of these are also non-fatal, and can
// be approximated. The behaviour of these depends on the current display
// mode of the driver.

// This flag is set if the error is fatal, and no sensible alternative
// could be done. If this flag is not set, the rendering can be done
// with a fair degree of fidelity, but not exactly what was requested.
//-----------------------------------------------------------------------------
#define BLEND_STATUS_FATAL_FLAG 0x10000

// These are ordered in rough severity order, most severe last.
typedef enum
{
    BS_OK = 0,

    // Non-fatal errors.
    BS_INVALID_FILTER,                      // Filter can't be done in this mode (e.g. trilinear with dual-texture).
    BS_PHONG_SHADING,                       // We can do gouraud instead.

    // Fatal errors.
    BSF_BASE = BLEND_STATUS_FATAL_FLAG,     // Not actually a real error value.

    BSF_UNSUPPORTED_FILTER,                 // Filter not supported at all (e.g. cubic)
    BSF_TEXTURE_NOT_POW2,                   // Using tile or wrap mode with a non-power-of-two texture dimension.
    BSF_TOO_MANY_PALETTES,                  // More than one palette used at a time.
    BSF_CANT_USE_ALPHA_ARG_HERE,            // Some units can do this, but not in this stage.
    BSF_CANT_USE_ALPHA_OP_HERE,             // Some units can do this, but not in this stage.
    BSF_CANT_USE_COLOR_ARG_HERE,            // Some units can do this, but not in this stage.
    BSF_CANT_USE_COLOR_OP_HERE,             // Some units can do this, but not in this stage.
    BSF_INVALID_TEXTURE,                    // Invalid or NULL texture.
    BSF_UNSUPPORTED_ALPHA_ARG,
    BSF_UNSUPPORTED_ALPHA_OP,
    BSF_UNSUPPORTED_COLOR_ARG,
    BSF_UNSUPPORTED_COLOR_OP,
    BSF_UNSUPPORTED_ALPHA_BLEND,
    BSF_UNSUPPORTED_STATE,                  // A render state value that we know, but don't support (and not one of the specific ones above).
    BSF_TOO_MANY_TEXTURES,
    BSF_TOO_MANY_BLEND_STAGES,
    BSF_UNDEFINED_FILTER,
    BSF_UNDEFINED_ALPHA_ARG,
    BSF_UNDEFINED_ALPHA_OP,
    BSF_UNDEFINED_COLOR_ARG,
    BSF_UNDEFINED_COLOR_OP,
    BSF_UNDEFINED_ALPHA_BLEND,
    BSF_UNDEFINED_STATE,                    // A render state value that we've never heard of (can happen via extensions that we don't support).

    // Always last.
    BSF_UNINITIALISED                       // Haven't done any validation setup yet!

} D3D_BLEND_STATUS;

// Useful macro for setting errors.
#if DBG
#define SET_BLEND_ERROR(pContext,errnum)                                                                     \
do                                                          \
{                                                           \
    if ( pContext->eChipBlendStatus < (errnum) )            \
    {                                                       \
        pContext->eChipBlendStatus = (errnum);              \
    }                                                       \
    DISPDBG(( WRNLVL, "azn SET_BLEND_ERROR: Error" #errnum ));   \
} while (FALSE)
#else
#define SET_BLEND_ERROR(pContext,errnum)                          \
            if ( pContext->eChipBlendStatus < (errnum) ) \
                pContext->eChipBlendStatus = (errnum)

#endif // DBG

#define RESET_BLEND_ERROR(pContext) pContext->eChipBlendStatus = BS_OK
#define GET_BLEND_ERROR(pContext) (pContext->eChipBlendStatus)


//-----------------------------------------------------------------------------
// FVF (Flexible Vertex Format) Support declarations
//-----------------------------------------------------------------------------
typedef struct _FVFOFFSETS
{      
    DWORD dwColOffset;
    DWORD dwSpcOffset;
    DWORD dwTexOffset[D3DHAL_TSS_MAXSTAGES];      //offset for current texture#i
    DWORD dwTexCoordOffset[D3DHAL_TSS_MAXSTAGES]; //offset into each tex coord
    DWORD dwNormalOffset;
    DWORD dwNonTexStride;
    DWORD dwStride;
    DWORD dwStrideHostInline;
    DWORD dwVertexValid;
    DWORD dwVertexValidHostInline;
    DWORD vFmat;
    DWORD vFmatHostInline;
    DWORD dwTexCount;
#if DX8_POINTSPRITES
    DWORD dwPntSizeOffset;
#endif // DX8_POINTSPRITES    

} FVFOFFSETS , *LPFVFOFFSETS;

#if DX8_POINTSPRITES

#define P3_MAX_POINTSPRITE_SIZE 64.0f

// Macro to determine if poinsprites are in order or just normal points
#define IS_POINTSPRITE_ACTIVE(pContext)   \
 ( (pContext->PntSprite.bEnabled)    ||  \
   (pContext->PntSprite.fSize != 1.0f)     ||  \
   (pContext->FVFData.dwPntSizeOffset) )

#endif // DX8_POINTSPRITES    

typedef struct _FVFTEXCOORDS{
    D3DVALUE tu;
    D3DVALUE tv;
#if DX8_3DTEXTURES
    D3DVALUE tw;
#endif // DX8_3DTEXTURES
} FVFTEXCOORDS, *LPFVFTEXCOORDS;

typedef struct _FVFCOLOR {
    D3DCOLOR color;
} FVFCOLOR, *LPFVFCOLOR;

typedef struct _FVFSPECULAR {
    D3DCOLOR specular;
} FVFSPECULAR, *LPFVFSPECULAR;

typedef struct _FVFXYZ {
    float x;
    float y;
    float z;
    float rhw;
} FVFXYZRHW, *LPFVFXYZRHW;

typedef struct _FVFNORMAL {
    float nx;
    float ny;
    float nz;
} FVFNORMAL, *LPFVFNORMAL;

typedef struct _FVFPSIZE{
    D3DVALUE psize;
} FVFPSIZE, *LPFVFPSIZE;

extern const FVFCOLOR gc_FVFColorDefault;
extern const FVFSPECULAR gc_FVFSpecDefault;
extern const FVFTEXCOORDS gc_FVFTexCoordDefault;

#define OFFSET_OFF(type, mem) ((DWORD)((char*)&((type *)0)->mem - (char*)(type*)0))

//  If we are asked to pick a texture coordinate (indexed by 
//  D3DTSS_TEXCOORDINDEX in the TSS) which the incoming vertex data doesn't 
//  have, then we should assume 0,0 as default values for it.
#define FVFTEX(lpVtx, num)                                  \
        (pContext->FVFData.dwTexOffset[(num)]?              \
          ((LPFVFTEXCOORDS)((LPBYTE)(lpVtx) +               \
                pContext->FVFData.dwTexOffset[(num)]))      \
          :&gc_FVFTexCoordDefault )

// Make sure FVFCOLOR and FVFSPEC pick up default values if 
// the components are not present in the FVF vertex data
#define FVFCOLOR(lpVtx)                                                     \
         (pContext->FVFData.dwColOffset?                                    \
            ((LPFVFCOLOR)((LPBYTE)(lpVtx) + pContext->FVFData.dwColOffset)) \
            :&gc_FVFColorDefault)
#define FVFSPEC(lpVtx)                                                          \
       (pContext->FVFData.dwSpcOffset?                                          \
             ((LPFVFSPECULAR)((LPBYTE)(lpVtx) + pContext->FVFData.dwSpcOffset)) \
            :&gc_FVFSpecDefault )
            
#define FVFXYZRHW(lpVtx)   ((LPFVFXYZRHW)((LPBYTE)(lpVtx)))
#define FVFNORMAL(lpVtx)   ((LPFVFNORMAL)((LPBYTE)(lpVtx) + pContext->FVFData.dwNormalOffset))

#if DX8_POINTSPRITES
#define FVFPSIZE( lpVtx)   ((LPFVFPSIZE)((LPBYTE)(lpVtx) + pContext->FVFData.dwPntSizeOffset))
#endif // DX8_POINTSPRITES


#if DX7_TEXMANAGEMENT
// Declaration for compiling purpouses
typedef struct _TextureCacheManager *PTextureCacheManager;
#endif // DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
//
// Basic renderers defined in d3dprim.c . 
// We have a function pointer to them in P3_D3DCONTEXT
//
//-----------------------------------------------------------------------------
typedef struct _p3_d3dcontext P3_D3DCONTEXT; 

typedef int PROC_1_VERT( P3_D3DCONTEXT *pContext, 
                         D3DTLVERTEX *pv[], 
                         int vtx );
                         
typedef int PROC_3_VERTS( P3_D3DCONTEXT *pContext, 
                          D3DTLVERTEX *pv[],
                          int edgeflags );

//-----------------------------------------------------------------------------
//
// Definition of the P3_D3DCONTEXT structure .
//
//-----------------------------------------------------------------------------

typedef struct _p3_d3dcontext 
{
    //***********************
    // Structure "header"
    //***********************

    unsigned long MagicNo ;    // Magic number to verify validity of pointer

    P3_D3DCONTEXT* pSelf;     // Ptr to self (useful if we do some realignment)

    DWORD dwContextHandle;    // The handle passed back to D3D

    ULONG_PTR dwDXInterface;  // Which DX interface (DX8,DX7,DX6,DX5,DX3) is
                              // creating this context.

    //******************************************************************
    // Global DD and driver context in which this D3D context is running
    //******************************************************************
    P3_THUNKEDDATA*     pThisDisplay;     // The card we are running on.

    LPDDRAWI_DIRECTDRAW_LCL pDDLcl;    // D3D Surfaces (created through    
                                       // D3DCreateSurfaceEx) will be
                                       // associated through this pDDLcl
    LPDDRAWI_DIRECTDRAW_GBL pDDGbl;    // A pointer to the DirectDraw global
                                       // object associated with this context
                                       
    //***********************************************
    // Stored render target and z buffer surface info
    //***********************************************    

    P3_SURF_INTERNAL*   pSurfRenderInt;   // render target
    P3_SURF_INTERNAL*   pSurfZBufferInt;  // depth buffer
    DWORD PixelOffset;       // Offset in videomemory in pixels to start 
    DWORD ZPixelOffset;      // of buffers

    DWORD ModeChangeCount;   // Keeps track of rendertarget flips

    //************************
    // For debugging purpouses
    //************************
    DWORD OwningProcess;    // Process Id
    BOOL bTexDisabled;      // Is texturing enabled ?
    DWORD BPP;              // Bytes per pixel of primary

#if DX7_PALETTETEXTURE
    //**********************************************
    // Palette array associated to this D3D context
    //**********************************************    
    PointerArray* pPalettePointerArray;     // An array of palette pointers 
                                            // for use in this context
#endif

    //**********************************************
    // Surfaces array associated to this D3D context
    //**********************************************    
    PointerArray* pTexturePointerArray;     // An array of texture pointers 
                                            // for use in this context

    //**************************************************************
    // Hardware setup and transport information for this D3D context
    //**************************************************************

    P3_SOFTWARECOPY SoftCopyGlint;  // Software copy of registers for Permedia3    
    BOOL                b3D_FIFOS;  // This context using FIFO's?

    DWORD dwDirtyFlags;       // Hw state which stills needs update from D3D RS
    DWORD dwDirtyGammaFlags;  //  idem for TnL  

    DWORD RenderCommand;      // Rendering command to be issued to hw

    float XBias;              // For biasing coordinates
    float YBias;

    //************************************************
    // Triangle hw rendering function pointers
    //************************************************
    PROC_1_VERT  *pRendTri_1V;
    PROC_3_VERTS *pRendTri_3V;

    //************************************************
    // Context stored D3D states (render,TSS,TnL,etc.)
    //************************************************
    union
    {
        DWORD RenderStates[D3DHAL_MAX_RSTATES];
        float fRenderStates[D3DHAL_MAX_RSTATES];
    };
    
    TexStageState TextureStageState[D3DHAL_TSS_MAXSTAGES];    

    D3DStateSet overrides;     // To overide renderstates in legacy DX3 apps

    D3DHAL_DP2VIEWPORTINFO ViewportInfo; // Structures to store the viewport                                             
    D3DHAL_DP2ZRANGE ZRange;             // settings. They come into the HAL 
                                         // in two seperate OP codes.
    D3DHAL_DP2WINFO WBufferInfo;         // Structure to store w-buffering setup
    D3DMATERIAL7 Material;

    //********************************************
    // Command and Vertex buffer related state 
    // (including DX8 multistreaming data)
    //********************************************
    LPDWORD   lpVertices;
    DWORD     dwVertexType;

#if DX8_DDI
    LPDWORD lpIndices;
    DWORD   dwIndicesStride;
    DWORD   dwVerticesStride;
    DWORD   dwNumVertices;
    DWORD   dwVBSizeInBytes;
#endif // DX8_DDI    

    FVFOFFSETS FVFData;

    //*****************************************************
    // Internal context state for primitives rendering
    //*****************************************************

    ULONG Flags;

    DWORD dwP3HostinTriLookup;      // Store mix of states to select an 
                                    // appropriate rendering function
    DWORD dwProvokingVertex;    // Simplifies the Delta renderers 
                                // to have this be global
    D3DTLVERTEX *pProvokingVertex;

    DWORD   CullAndMask;
    DWORD   CullXorMask;  

    //*****************************************************
    // Internal context state kept TSS texturing
    //       (Chip <-> D3D texture stage management)
    //*****************************************************
    
    // Pointer to the current texture for MipMapping
    P3_SURF_INTERNAL* pCurrentTexture[D3DHAL_TSS_MAXSTAGES];     

    D3D_BLEND_STATUS eChipBlendStatus;    // Is the current D3D blend valid?
    
    BOOL bTextureValid;     // Are textures valid for rendering?
    BOOL bTex0Valid;
    BOOL bTex1Valid;    
    BOOL bCanChromaKey;

    int iChipStage[4];   // iChipStage[n] = x means that stage n on the chip
                         // (0,1 = texcomp0,1, 2=texapp, 3=placeholder) is 
                         // in D3D stage x.

    // iTexStage[n] = x means that texture n on the chip is "defined"
    // in D3D stage x, i.e. filter mode, FVF coord set number, etc.
    // A single texture may be used in multiple D3D stages, so x may
    // not be the only valid value. However, all instances of the texture
    // must be the same of course. The assignment code checks that they are.
    // A value of -1 means the texture is unused.
    int iTexStage[D3DHAL_TSS_MAXSTAGES];

    // iStageTex[n] = x means that the texture used by D3D stage n is
    // chip texture x. It therefore follows that iStageTex[iTexStage[n]] == n.
    // The reverse (iTexStage[iStageTex[n]] == n) need NOT be true, because
    // of course each chip texture can be used by multiple D3D stages.
    // -1 means that the stage does not use a texture (NULL handle or 
    // invalid texture).
    int iStageTex[D3DTSS_MAX];


    BOOL bBumpmapEnabled;     // TRUE if the current alpha in chipstage1 
                              // should be the bumpmap, instead of the 
                              // diffuse (normal default).

    BOOL bBumpmapInverted;     // TRUE if the bumpmapping is the inverse 
                               // of the normal a0-a1+0.5, i.e. a1-a0+0.5

    BOOL bStage0DotProduct;    // TRUE if chip stage 0 is using DOTPRODUCT 
                               // (can't use DOTPROD in stage 1).
                               
    BOOL bAlphaBlendMustDoubleSourceColour;  // TRUE if the source colour 
                                             // needs to be *2 in the 
                                             // alpha-blend unit.

    //*****************************************************
    // Internal context state kept for various D3D features
    //*****************************************************

    BOOL bKeptStipple;          // D3DRENDERSTATE_STIPPLEDALPHA
    DWORD CurrentStipple[32];
    float MipMapLODBias[2];     // D3DTSS_MIPMAPLODBIAS

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    // For antialiasing
    DWORD dwAliasPixelOffset;
    DWORD dwAliasBackBuffer;
    DWORD dwAliasZPixelOffset;
    DWORD dwAliasZBuffer;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

#if DX7_D3DSTATEBLOCKS
    BOOL bStateRecMode;            // Toggle for executing or recording states
    P3StateSetRec   *pCurrSS;      // Ptr to SS currently being recorded
    P3StateSetRec   **pIndexTableSS; // Pointer to table of indexes
    DWORD           dwMaxSSIndex;    // size of table of indexes

    DWORD           dwVBHandle;     // Stream 0 handle
    DWORD           dwIndexHandle;  // Index handle
#endif
    
#if DX8_POINTSPRITES               // Point sprite support
    struct
    {
        BOOL bEnabled;
        D3DVALUE fSize;    

        BOOL bScaleEnabled;    
        D3DVALUE fScale_A;
        D3DVALUE fScale_B;
        D3DVALUE fScale_C;    
        D3DVALUE fSizeMin;      
        D3DVALUE fSizeMax;
        
    } PntSprite;
#endif // DX8_POINTSPRITES

#if DX8_DDI
    DWORD dwColorWriteHWMask;    // For the new DX8 D3DRS_COLORWRITEENABLE
    DWORD dwColorWriteSWMask; 
#endif //DX8_DDI

#if DX7_TEXMANAGEMENT
    //*****************
    // Texture Management
    //*****************
    PTextureCacheManager   pTextureManager;
#endif // DX7_TEXMANAGEMENT    

    //*****************
    // Other
    //*****************

    // Track adjustments to texture coordinates that invalidate vertex sharing
    // (They force us to send the next triangle as 3 vtx's even if only the
    //  coords of 1 have changed since we adjusted the tc's in order to fit
    //  hw limitations)
    union
    {
        struct
        {
            BYTE flushWrap_tu1; // The s1 texture coordinate was wrapped
            BYTE flushWrap_tv1; // The t1 texture coordinate was wrapped
            BYTE flushWrap_tu2; // The s2 texture coordinate was wrapped
            BYTE flushWrap_tv2; // The t2 texture coordinate was wrapped
        };
            
        DWORD R3flushDueToTexCoordAdjust;
    };
    

       
} P3_D3DCONTEXT ;


//-----------------------------------------------------------------------------
//
// Triangle culling macros and definitions
//
//-----------------------------------------------------------------------------
#define SET_CULLING_TO_NONE(pCtxt)   \
            pCtxt->CullAndMask = 0;  \
            pCtxt->CullXorMask = 0;  

#define SET_CULLING_TO_CCW(pCtxt)            \
            pCtxt->CullAndMask = 1UL << 31;  \
            pCtxt->CullXorMask = 0;  

#define SET_CULLING_TO_CW(pCtxt)             \
            pCtxt->CullAndMask = 1UL << 31;  \
            pCtxt->CullXorMask = 1UL << 31; 

#define FLIP_CCW_CW_CULLING(pCtxt)           \
            pCtxt->CullXorMask ^= 1UL << 31;

#define SAVE_CULLING_STATE(pCtxt)                   \
        DWORD oldCullAndMask = pCtxt->CullAndMask;  \
        DWORD oldCullXorMask = pCtxt->CullXorMask;

#define RESTORE_CULLING_STATE(pCtxt)                \
        pCtxt->CullAndMask = oldCullAndMask;        \
        pCtxt->CullXorMask = oldCullXorMask;

#define _CULL_CALC(pCtxt,PixelArea)                 \
    ((*(DWORD *)&PixelArea) ^ pCtxt->CullXorMask) 

#if 1
#define CULLED(pCtxt,PixelArea) \
    ((signed long)(_CULL_CALC(pCtxt,PixelArea) & pCtxt->CullAndMask) < 0) ? 1 : \
    ( ((_CULL_CALC(pCtxt,PixelArea)& ~pCtxt->CullAndMask) ==  0.0f) ? 1 : 0 )
#else
static __inline int CULLED(P3_D3DCONTEXT *pCtxt, float PixelArea)
{
    int cull;
    
    cull = (*(DWORD *)&PixelArea) ^ pCtxt->CullXorMask;

    if ((signed long)(cull & pContext->CullAndMask) < 0)
    {
        return 1;         // True back face rejection...
    }
    
    if ((cull & ~pCtxt->CullAndMask) == 0.0f)
    {
        return 1;
    }

    return 0;
}
#endif
//-----------------------------------------------------------------------------
//
// GetSurfaceFromHandle
// Get internal surface structure pointer from handle
//
//-----------------------------------------------------------------------------
static __inline P3_SURF_INTERNAL* 
GetSurfaceFromHandle(
    P3_D3DCONTEXT* pContext, 
    DWORD dwHandle)
{
    P3_SURF_INTERNAL* pTexture;
    {
        // There may never have been any texture arrays allocated...
        ASSERTDD(pContext->pTexturePointerArray, 
                 "ERROR: Texture pointer array is not set!");

        pTexture = PA_GetEntry(pContext->pTexturePointerArray, dwHandle);
    }
    DISPDBG((DBGLVL, "Texture pointer: 0x%x", pTexture));
    return pTexture;
}

//-----------------------------------------------------------------------------
//
// GetPaletteFromHandle
// Get internal palette structure pointer from handle
//
//-----------------------------------------------------------------------------
#if DX7_PALETTETEXTURE
static __inline D3DHAL_DP2UPDATEPALETTE* 
GetPaletteFromHandle(
    P3_D3DCONTEXT* pContext, 
    DWORD dwHandle)
{
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    {
        // There may never have been any palette arrays allocated...
        ASSERTDD(pContext->pPalettePointerArray, 
                 "ERROR: Palette pointer array is not set!");

        pPalette = PA_GetEntry(pContext->pPalettePointerArray, dwHandle);
    }
    DISPDBG((DBGLVL, "Palette pointer: 0x%x", pPalette));
    return pPalette;
}
#endif


//-----------------------------------------------------------------------------
//
// Determine what level API is the app using which created this context
//
//-----------------------------------------------------------------------------

#define IS_DX7_APP(pContext)             ((pContext)->dwDXInterface == 3)
#define IS_DX7_OR_EARLIER_APP(pContext)  ((pContext)->dwDXInterface <= 3)


#endif // __DCONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxt.c
*
*  Content: D3D texture setup
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "chroma.h"
#include "tag.h"

//-----------------------------------------------------------------------------

// Some variables shared through this module (not globals)
// These are set up in _D3DChangeTextureP3RX.

// P3 has 16 texture map base address slots, numbered 0 to 15 hence ...
#define P3_TEX_MAP_MAX_LEVEL    15

typedef struct
{
    DWORD dwTex0MipBase;
    DWORD dwTex0MipMax;
    DWORD dwTex0ActMaxLevel; // Controlled by D3DTSS_MAXMIPLEVEL, default 0
    DWORD dwTex1MipBase;
    DWORD dwTex1MipMax;
    DWORD dwTex1ActMaxLevel; // Same for Texture 1
} P3_MIP_BASES;

#define TSSTATE(stageno,argno)        \
                        ( pContext->TextureStageState[stageno].m_dwVal[argno] )
#define TSSTATESELECT(stageno,argno)  \
                            ( TSSTATE(stageno,argno) & D3DTA_SELECTMASK )
#define TSSTATEINVMASK(stageno,argno) \
                            ( TSSTATE(stageno,argno) & ~D3DTA_COMPLEMENT )
#define TSSTATEALPHA(stageno,argno)   \
                            ( TSSTATE(stageno,argno)  & ~D3DTA_ALPHAREPLICATE )

#define IS_ALPHA_ARG 1
#define IS_COLOR_ARG 0


#if DX8_DDI
//-----------------------------------------------------------------------------
//
// __TXT_MapDX8toDX6TexFilter
//
// map DX8 enums into DX6(&7) texture filtering enums 
//
//-----------------------------------------------------------------------------
DWORD
__TXT_MapDX8toDX6TexFilter( DWORD dwStageState, DWORD dwValue )
{
    switch (dwStageState)
    {
    case D3DTSS_MAGFILTER:
        switch (dwValue)
        {
        case D3DTEXF_POINT            : return D3DTFG_POINT;
        case D3DTEXF_LINEAR           : return D3DTFG_LINEAR;
        case D3DTEXF_FLATCUBIC        : return D3DTFG_FLATCUBIC;
        case D3DTEXF_GAUSSIANCUBIC    : return D3DTFG_GAUSSIANCUBIC;
        case D3DTEXF_ANISOTROPIC      : return D3DTFG_ANISOTROPIC;
        }
        break;
    case D3DTSS_MINFILTER:
        switch (dwValue)
        {
        case D3DTEXF_POINT            : return D3DTFN_POINT;
        case D3DTEXF_LINEAR           : return D3DTFN_LINEAR;
        case D3DTEXF_FLATCUBIC        : return D3DTFN_ANISOTROPIC;
        }
        break;
    case D3DTSS_MIPFILTER:
        switch (dwValue)
        {
        case D3DTEXF_NONE             : return D3DTFP_NONE;
        case D3DTEXF_POINT            : return D3DTFP_POINT;
        case D3DTEXF_LINEAR           : return D3DTFP_LINEAR;
        }
        break;
    }
    return 0x0;
} // __TXT_MapDX8toDX6TexFilter
#endif // DX8_DDI

//-----------------------------------------------------------------------------
//
// _D3D_TXT_ParseTextureStageStates
//
// Parse the texture state stages command token and update our context state
//
// Note : bTranslateDX8FilterValueToDX6 will only be FALSE when it is called
//        from _D3D_SB_ExecuteStateSet if that state set's value has been 
//        changes by _D3D_SB_CaptureStateSet (Basically DX6 filter values are
//        stored in the state set directly, thus no need to translate them.)
//
//-----------------------------------------------------------------------------
void 
_D3D_TXT_ParseTextureStageStates(
    P3_D3DCONTEXT* pContext, 
    D3DHAL_DP2TEXTURESTAGESTATE *pState, 
    DWORD dwCount,
    BOOL bTranslateDX8FilterValueToDX6)
{
    DWORD i;
    DWORD dwStage, dwState, dwValue;
    
    DISPDBG((DBGLVL,"*** In _D3D_TXT_ParseTextureStageStates"));

    for (i = 0; i < dwCount; i++, pState++)
    {
        dwStage = pState->wStage;
        dwState = pState->TSState;
        dwValue = pState->dwValue;
      
        // check for range before continuing
        if ( (dwStage < D3DHAL_TSS_MAXSTAGES) &&
             (dwState < D3DTSS_MAX))
        {

#if DX7_D3DSTATEBLOCKS 
            if (pContext->bStateRecMode)
            {
                // Record this texture stage state into the 
                //current state set being recorded 
                _D3D_SB_RecordStateSetTSS(pContext, dwStage, dwState, dwValue);

                // skip any further processing and go to the next TSS
                continue;
            }
#endif //DX7_D3DSTATEBLOCKS       

#if DX7_TEXMANAGEMENT
            if ((D3DTSS_TEXTUREMAP == dwState) && (0 != dwValue))
            {
                P3_SURF_INTERNAL* pTexture;

                pTexture = GetSurfaceFromHandle(pContext, dwValue);

                // If this is a valid managed texture
                if (CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(pTexture) &&
                    (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) 
                {
                    // Update stats
                    _D3D_TM_STAT_Inc_NumTexturesUsed(pContext);
                    _D3D_TM_STAT_Inc_NumUsedTexInVid(pContext, pTexture);
                }
            }
#endif // DX7_TEXMANAGEMENT  

            DISPDBG((DBGLVL,"  Stage = %d, State = 0x%x, Value = 0x%x", 
                               dwStage, dwState, dwValue));

            // Special case a texture handle change and the address update
            switch ( dwState )
            {
            case D3DTSS_TEXTUREMAP:
                DISPDBG((DBGLVL,"  D3DTSS_TEXTUREMAP: Handle=0x%x", dwValue));

                if (pContext->TextureStageState[dwStage].m_dwVal[dwState] != 
                                                                       dwValue)
                {
                    pContext->TextureStageState[dwStage].m_dwVal[dwState] = 
                                                                        dwValue;
                    DIRTY_TEXTURE(pContext);
                }
                break;

            case D3DTSS_ADDRESS:
                DISPDBG((DBGLVL,"  D3DTSS_ADDRESS"));
                // map single set ADDRESS to both U and V controls
                pContext->TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = 
                pContext->TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = 
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;

                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_COLOROP:
            case D3DTSS_ALPHAOP:
            case D3DTSS_COLORARG1:
            case D3DTSS_COLORARG2:
            case D3DTSS_ALPHAARG1:
            case D3DTSS_ALPHAARG2:
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                pContext->Flags &= ~SURFACE_MODULATE;
                DIRTY_TEXTURESTAGEBLEND(pContext);
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_TEXCOORDINDEX:
                DISPDBG((DBGLVL,"  D3DTSS_TEXCOORDINDEX: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                
                // Update the offsets to the texture coordinates                                         
                // NOTE: The texture coordinate index can contain various flags
                // in addition to the actual value. These flags are:
                //     D3DTSS_TCI_PASSTHRU (default - resolves to zero)
                //     D3DTSS_TCI_CAMERASPACENORMAL 
                //     D3DTSS_TCI_CAMERASPACEPOSITION 
                //     D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR 
                // and are used for texture coordinate generation.
                //
                // These flags are not relevant when considering the offset of
                // texture coordinates in the vertex stream. These flags appear
                // in the high word of the index value DWORD. Only the low word
                // contains actual index data. Therefore, we will mask of the
                // low word when looking up the offset table for this texture
                // coordinate index.
                pContext->FVFData.dwTexOffset[dwStage] = 
                    pContext->FVFData.dwTexCoordOffset[dwValue & 0x0000FFFFul];
                    
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_MIPMAPLODBIAS:
                DISPDBG((DBGLVL,"  D3DTSS_MIPMAPLODBIAS: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_MAGFILTER:        
            case D3DTSS_MINFILTER:
            case D3DTSS_MIPFILTER:
#if DX8_DDI        
                if((!IS_DX7_OR_EARLIER_APP(pContext)) && 
                   bTranslateDX8FilterValueToDX6)
                {
                    // filtering values are somewhat different in DX8 
                    // so translate them before using them.
                    dwValue = __TXT_MapDX8toDX6TexFilter(dwState, dwValue);
                }
#endif DX8_DDI            
                
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);        
                break;
                
            case D3DTSS_MAXMIPLEVEL:
                DISPDBG((DBGLVL,"  D3DTSS_MAXMIPLEVEL: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;     
                
            default:
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;
            } // switch
        } 
        else
        {
            DISPDBG((WRNLVL,"Out of range stage/state %d %d",dwStage,dwState));
        }// if
    } // for
} // _D3D_TXT_ParseTextureStageStates



//-----------------------------------------------------------------------------
//
// SETARG
//
// dwArg = the argument.
// num = argument number (1 or 2).
// bIsAlpha = TRUE if this is the alpha channel, 
//            FALSE if this is the colour channel.
// iD3DStage = D3D stage number.
// iChipStageNo = chip stage number (should only be 0 or 1 on P3)
//
//-----------------------------------------------------------------------------
void
SETARG(
    P3_D3DCONTEXT *pContext, 
    struct TextureCompositeRGBAMode *pMode,
    DWORD dwArg, 
    DWORD num,
    BOOL bIsAlpha,    
    DWORD iD3DStage, 
    DWORD iChipStageNo)    
{                       
    BOOL bSetArgToggleInvert;
    DWORD dwArgValue, dwInvertArgValue;
    BOOL bArgValueAssigned = FALSE,
         bInvertArgValueAssigned;

    bSetArgToggleInvert = FALSE;                            
    switch (dwArg & D3DTA_SELECTMASK)                       
    {                                                       
        case D3DTA_TEXTURE:                                 
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = ( pContext->iStageTex[iD3DStage] == 0 ) ?   
                                                         P3RX_TEXCOMP_T0A :   
                                                         P3RX_TEXCOMP_T1A;  
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  Tex%dA", pContext->iStageTex[iD3DStage] ));     
            }                                                   
            else                                                
            {                                                   
                dwArgValue = ( pContext->iStageTex[iD3DStage] == 0 ) ?   
                                                         P3RX_TEXCOMP_T0C :   
                                                         P3RX_TEXCOMP_T1C; 
                bArgValueAssigned = TRUE;                                                         
                DISPDBG((DBGLVL,"  Tex%dC", pContext->iStageTex[iD3DStage] ));   
            }                                                   
            break;                
            
        case D3DTA_DIFFUSE:                                     
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = P3RX_TEXCOMP_CA;      
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  DiffA" ));                        
            }                                                   
            else                                                
            {                                                   
                dwArgValue = P3RX_TEXCOMP_CC;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  DiffC" ));                        
            }                                                   
            break;        
            
        case D3DTA_CURRENT:                                     
            // Cope with a "current" argument in texcomp0 
            if ( iChipStageNo == 0 )                            
            {                                                                           
                // This is texcomp0
                if ( pContext->bBumpmapEnabled )                                        
                {                                                                       
                    // Emboss bumpmapping is on
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))                   
                    {                                                                   
                        // This is the alpha-channel, where the D3D stages 0 & 1
                        // should have put the heightfield info.
                        dwArgValue = P3RX_TEXCOMP_HEIGHTA;                         
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  BumpA" ));                                        
                        // And cope with inverted bumpmaps.
                        bSetArgToggleInvert = pContext->bBumpmapInverted;               
                    }                                                                   
                    else                                                                
                    {                                                                   
                        // Colour channel - this will hold the diffuse colour.
                        dwArgValue = P3RX_TEXCOMP_CC;                              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffC" ));                                        
                    }                                                                   
                }                                                                       
                else                                                    
                {                                                       
                    // Embossing is off - default to diffuse.
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_CA;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffA" ));                        
                    }                                                   
                    else                                                
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_CC;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffC" ));                        
                    }                                                   
                }                                                       
            }                                                           
            else                                                        
            {                                                           
                // texcomp stage 1
                if ( pContext->bStage0DotProduct )                      
                {                                                       
                    // Need to take the dotproduct sum result,
                    // even in the alpha channel, according to the docs.
                    dwArgValue = P3RX_TEXCOMP_SUM;                 
                    bArgValueAssigned = TRUE;
                }                                                       
                else                                                    
                {                                                       
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_OA;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  CurrA" ));                        
                    }                                                   
                    else                                                
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_OC;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  CurrC" ));                        
                    }                                                   
                }                                                       
            }                                                           
            break;      
            
        case D3DTA_TFACTOR:                                     
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = P3RX_TEXCOMP_FA;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                   
            else                                                
            {                                                   
                dwArgValue = P3RX_TEXCOMP_FC;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  TfactC" ));                       
            }                                                   
            break;                                              
            
        default:                                                
            if ( bIsAlpha )                                     
            {                                                   
                DISPDBG((ERRLVL,"ERROR: Invalid AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );
            }
            else
            {
                DISPDBG((ERRLVL,"ERROR: Invalid ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );
            }
            break;
    } // switch
    
    if ( ( (dwArg & D3DTA_COMPLEMENT) == 0 ) == bSetArgToggleInvert )
    {                                                           
        dwInvertArgValue= __PERMEDIA_ENABLE;   
        bInvertArgValueAssigned = TRUE;
        DISPDBG((DBGLVL,"    inverted" ));                           
    }                                                           
    else                                                        
    {                                                           
        dwInvertArgValue = __PERMEDIA_DISABLE;   
        bInvertArgValueAssigned = TRUE;        
    }                                                           
                                                                
    // Set up the I input for MODULATExxx_ADDxxx modes.
    if ( num == 1 )                                             
    {                                                           
        switch (dwArg & D3DTA_SELECTMASK)                       
        {                                                       
            case D3DTA_TEXTURE:                                 
                pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ?  
                                                P3RX_TEXCOMP_I_T0A :  
                                                P3RX_TEXCOMP_I_T1A;   
                DISPDBG((DBGLVL,"  I: Tex%dA", pContext->iStageTex[iD3DStage] ));    
                break;    
                
            case D3DTA_DIFFUSE:                                     
                pMode->I = P3RX_TEXCOMP_I_CA;                       
                DISPDBG((DBGLVL,"  I: DiffA" ));                         
                break;                                              
                
            case D3DTA_CURRENT:                                     
                if ( iChipStageNo == 0 )                            
                {                                                   
                    if ( pContext->bBumpmapEnabled )                
                    {                                               
                        // Bumpmapping mode. 
                        pMode->I = P3RX_TEXCOMP_I_HA;               
                        DISPDBG((DBGLVL,"  I: BumpA" ));                 
                    }                                               
                    else                                            
                    {                                               
                        pMode->I = P3RX_TEXCOMP_I_CA;               
                        DISPDBG((DBGLVL,"  I: DiffA" ));                 
                    }                                               
                }                                                   
                else                                                
                {                                                   
                    pMode->I = P3RX_TEXCOMP_I_OA;                   
                    DISPDBG((DBGLVL,"  I: CurrA" ));                     
                }                                                   
                break;                                              
                
            case D3DTA_TFACTOR:                                     
                pMode->I = P3RX_TEXCOMP_I_FA;                       
                DISPDBG((DBGLVL,"  I: TfactA" ));                        
                break;                                              
                
            default:                                                
                if ( bIsAlpha )                                     
                {                                                   
                    DISPDBG((ERRLVL,"ERROR: Invalid AlphaArgument"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );    
                }                                                   
                else                                                
                {                                                   
                    DISPDBG((ERRLVL,"ERROR: Invalid ColorArgument"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );    
                }                                                   
                break;                                              
        } // switch
        
        if ( ( (dwArg & D3DTA_COMPLEMENT) == 0 ) == bSetArgToggleInvert )
        {                                                           
            pMode->InvertI = __PERMEDIA_ENABLE;                        
        }                                                           
        else                                                        
        {                                                           
            pMode->InvertI = __PERMEDIA_DISABLE;                       
        }                                                           
    } // if ( num == 1 )          

    if (bArgValueAssigned)
    {
        if (num == 1)
        {
            pMode->Arg1 = dwArgValue;
        }
        else
        {
            pMode->Arg2 = dwArgValue;        
        }
    }

    if (bInvertArgValueAssigned)
    {
        if (num == 1)
        {
            pMode->InvertArg1 = dwInvertArgValue;
        }
        else
        {
            pMode->InvertArg2 = dwInvertArgValue;        
        }
    }    
} // SETARG

//-----------------------------------------------------------------------------
//
// SETTAARG_ALPHA
//
// TexApp blend mode for the alpha channel.
//
//-----------------------------------------------------------------------------
void
SETTAARG_ALPHA(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode *pMode,
    DWORD dwArg, 
    DWORD num) 
{                                                          
    switch (dwArg & D3DTA_SELECTMASK)                               
    {                                                               
        case D3DTA_TEXTURE:                                         
            DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );    
            break;                                                  
        case D3DTA_DIFFUSE:                                         
            if ( (num) == 1 )                                       
            {                                                       
                pMode->AlphaA = P3RX_TEXAPP_A_CA;          
                DISPDBG((DBGLVL,"  DiffA" ));                        
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_CURRENT:                                         
            if ( (num) == 2 )                                       
            {                                                       
                pMode->AlphaB = P3RX_TEXAPP_B_TA;          
                DISPDBG((DBGLVL,"  CurrA" ));                        
            }                                                       
            else                                                    
            {                                                       
                // Can't do
                DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_TFACTOR:                                         
            if ( (num) == 1 )                                       
            {                                                       
                pMode->AlphaA = P3RX_TEXAPP_A_KA;          
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                       
            else                                                    
            {                        
                if ( (num) != 2)
                {
                    DISPDBG((ERRLVL," ** SETTAARG: num must be 1 or 2"));
                }
                pMode->AlphaB = P3RX_TEXAPP_B_KA;          
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                       
            break;                                                  
        default:                                                    
            DISPDBG((ERRLVL,"ERROR: Unknown TA AlphaArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );        
            break;                                                  
    }         
    
    if ( (dwArg & D3DTA_COMPLEMENT) != 0 )                          
    {                                                               
        // Can't do COMPLEMENT on the args.
        DISPDBG((ERRLVL,"ERROR: Can't do COMPLEMENT in TA unit"));
        SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );            
    }                                                               
} // SETTAARG_ALPHA

//-----------------------------------------------------------------------------
//
// SETTAARG_COLOR
//
// TexApp blend mode for the color channel.
//
//-----------------------------------------------------------------------------
void 
SETTAARG_COLOR(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode *pMode,
    DWORD dwArg, 
    DWORD num) 
{                                                                   
    switch (dwArg & D3DTA_SELECTMASK)                               
    {                                                               
            DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );    
            break;                                                  
        case D3DTA_DIFFUSE:                                         
            if ( (num) == 1 )                                       
            {                                                       
                if ( (dwArg & D3DTA_ALPHAREPLICATE) != 0 )      
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_CA;      
                    DISPDBG((DBGLVL,"  DiffA" ));                    
                }                                               
                else                                            
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_CC;      
                    DISPDBG((DBGLVL,"  DiffC" ));                    
                }                                               
                // Set up the I input for MODULATExxx_ADDxxx modes
                pMode->ColorI = P3RX_TEXAPP_I_CA;          
                DISPDBG((DBGLVL,"  I: DiffA" ));                     
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_CURRENT:                                         
            if ( (num) == 2 )                                       
            {                                                       
                if (dwArg & D3DTA_ALPHAREPLICATE)   
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_TA;          
                    DISPDBG((DBGLVL,"  CurrA" ));                        
                }                                                   
                else                                                
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_TC;          
                    DISPDBG((DBGLVL,"  CurrC" ));                        
                }                                                   
            }                                                       
            else                                                    
            {                                                       
                // Can't do.
                DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_TFACTOR:                                         
            if ( (num) == 1 )                                       
            {                                                       
                if ( (dwArg & D3DTA_ALPHAREPLICATE) != 0 )      
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_KA;      
                    DISPDBG((DBGLVL,"  TfactA" ));                   
                }                                               
                else                                            
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_KC;      
                    DISPDBG((DBGLVL,"  TfactC" ));                   
                }                                               
                // Set up the I input for MODULATExxx_ADDxxx modes. 
                pMode->ColorI = P3RX_TEXAPP_I_KA;          
                DISPDBG((DBGLVL,"  I: TfactA" ));                    
            }                                                       
            else                                                    
            {                           
                if ( (num) != 2)
                {
                    DISPDBG((ERRLVL," ** SETTAARG: num must be 1 or 2"));    
                }
                
                if (dwArg & D3DTA_ALPHAREPLICATE)   
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_KA;          
                    DISPDBG((DBGLVL,"  TfactA" ));                       
                }                                                   
                else                                                
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_KC;          
                    DISPDBG((DBGLVL,"  TfactC" ));                       
                }                                                   
            }                                                       
            break;                                                  
        default:                                                    
            DISPDBG((ERRLVL,"ERROR: Unknown TA ColorArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );        
            break;                                                  
    }                                                               
    if ( (dwArg & D3DTA_COMPLEMENT) != 0 )                          
    {                                                               
        // Can't do COMPLEMENT on the args.
        DISPDBG((ERRLVL,"ERROR: Can't do COMPLEMENT in TA unit"));
        SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );            
    }                                                               
} // SETTAARG_COLOR

//-----------------------------------------------------------------------------
//
// SETOP
//
// Note - SETOP must be done after SETARG for DISABLE to work.
//
//-----------------------------------------------------------------------------
void 
SETOP(
    P3_D3DCONTEXT *pContext, 
    struct TextureCompositeRGBAMode* pMode, 
    DWORD dwOperation, 
    DWORD iD3DStage, 
    DWORD iChipStageNo, 
    BOOL bIsAlpha)
{                                                                   
    pMode->Enable = __PERMEDIA_ENABLE;                                 
    pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;                
    pMode->InvertI = __PERMEDIA_DISABLE;                               
    pMode->A = P3RX_TEXCOMP_ARG1;                                   
    pMode->B = P3RX_TEXCOMP_ARG2;                                   
    switch (dwOperation)                                            
    {                                                               
        case D3DTOP_DISABLE:                                        
            if ( bIsAlpha )                                         
            {                                                       
                // Just pass through "current"
                pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;   
                if ( iChipStageNo == 0 )                            
                {                                                   
                    if ( pContext->bBumpmapEnabled )                
                    {                                               
                        // Embossing is on.
                        pMode->Arg1 = P3RX_TEXCOMP_HEIGHTA;    
                    }                                               
                    else                                            
                    {                                               
                        // Current = diffuse in stage0.
                        pMode->Arg1 = P3RX_TEXCOMP_CA;         
                    }                                               
                }                                                   
                else                                                
                {                                                   
                    if ( pContext->bStage0DotProduct )              
                    {                                               
                        pMode->Arg1 = P3RX_TEXCOMP_SUM;        
                    }                                               
                    else                                            
                    {                                               
                        pMode->Arg1 = P3RX_TEXCOMP_OA;         
                    }                                               
                }                                                   
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"SETOP: Colour op was DISABLE"
                                     " - should never have got here."));
            }                                                       
            break;                                                  
            
        case D3DTOP_SELECTARG1:                                     
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG1"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;       
            break;                                                  
            
        case D3DTOP_SELECTARG2:                                     
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG2"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A; // No Pass B  
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            break;                                                  
            
        case D3DTOP_MODULATE:                                       
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE"));                       
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            break;                                                  
            
        case D3DTOP_MODULATE2X:                                     
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE2X"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_TWO;        
            break;                                                  
            
        case D3DTOP_MODULATE4X:                                     
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE4X"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_FOUR;       
            break;                                                  
            
        case D3DTOP_ADD:                                            
            DISPDBG((DBGLVL,"  D3DTOP_ADD"));                            
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADD_AB;       
            break;                                                  
            
        case D3DTOP_ADDSIGNED:                                      
            DISPDBG((DBGLVL,"  D3DTOP_ADDSIGNED"));                      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB; 
            break;                                                  
            
        case D3DTOP_ADDSIGNED2X:                                    
            DISPDBG((DBGLVL,"  D3DTOP_ADDSIGNED2X"));                    
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB; 
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_TWO;        
            break;                                                  
            
        case D3DTOP_SUBTRACT:                                       
            DISPDBG((DBGLVL,"  D3DTOP_SUBTRACT"));                       
            pMode->Operation = P3RX_TEXCOMP_OPERATION_SUBTRACT_AB;  
            break;                                                  
            
        case D3DTOP_ADDSMOOTH:                                      
            DISPDBG((DBGLVL,"  D3DTOP_ADDSMOOTH"));                      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADD_AB_SUB_MODULATE_AB;
            break;                                                  
            
        case D3DTOP_BLENDDIFFUSEALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDDIFFUSEALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_CA;                           
            break;                                                  
            
        case D3DTOP_BLENDTEXTUREALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDTEXTUREALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                        P3RX_TEXCOMP_I_T0A : 
                                                        P3RX_TEXCOMP_I_T1A; 
            DISPDBG((DBGLVL,"    alpha: Tex%dA", pContext->iStageTex[iD3DStage] ));  
            break;                                                  
            
        case D3DTOP_BLENDFACTORALPHA:                               
            DISPDBG((DBGLVL,"  D3DTOP_BLENDFACTORALPHA"));               
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_FA;                           
            break;                                                  
            
        case D3DTOP_BLENDCURRENTALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDCURRENTALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_OA;                           
            break;                                                  
            
        case D3DTOP_BLENDTEXTUREALPHAPM:                            
            DISPDBG((DBGLVL,"  D3DTOP_BLENDTEXTUREALPHAPM"));            
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;    
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                           P3RX_TEXCOMP_I_T0A : 
                                                           P3RX_TEXCOMP_I_T1A; 
            DISPDBG((DBGLVL,"    alpha: Tex%dA", pContext->iStageTex[iD3DStage] ));  
            pMode->InvertI = __PERMEDIA_ENABLE;                        
            break;                                                  
            
        case D3DTOP_PREMODULATE:                                                                            
            DISPDBG((DBGLVL,"  D3DTOP_PREMODULATE"));                                                            
            // result = current_tex * next_stage_tex - ignore arguments.
            if ( ( pContext->iStageTex[iD3DStage] != -1 ) && 
                 ( pContext->iStageTex[iD3DStage+1] != -1 ) )                       
            {                                                                                               
                pMode->Arg1 = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                            P3RX_TEXCOMP_T0C : 
                                                            P3RX_TEXCOMP_T1C;            
                DISPDBG((DBGLVL,"    Arg1: Tex%d", pContext->iStageTex[iD3DStage] ));                                        
                pMode->Arg2 = ( pContext->iStageTex[iD3DStage+1] == 0 ) ? 
                                                            P3RX_TEXCOMP_T0C : 
                                                            P3RX_TEXCOMP_T1C;      
                DISPDBG((DBGLVL,"    Arg2: Tex%d", pContext->iStageTex[iD3DStage+1] ));                                  
            }                                                                                               
            else                                                                                            
            {                                                                                               
                // Not enough textures
                DISPDBG((ERRLVL,"** SETOP: PREMODULATE didn't have two "
                                     "textures to play with."));
                if ( bIsAlpha )                                                                             
                {                                                                                           
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE );                                         
                }                                                                                           
                else                                                                                        
                {                                                                                           
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );                                         
                }                                                                                           
                pMode->Arg1 = P3RX_TEXCOMP_CC;                                                              
                pMode->Arg2 = P3RX_TEXCOMP_CC;                                                              
            }                                                                                               
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;                                          
            pMode->A = P3RX_TEXCOMP_ARG2;                                                                   
            pMode->B = P3RX_TEXCOMP_ARG1;                                                                   
            break;                                                                                          
            
        case D3DTOP_MODULATEALPHA_ADDCOLOR:                         
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEALPHA_ADDCOLOR"));         
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_MODULATECOLOR_ADDALPHA:                         
            DISPDBG((DBGLVL,"  D3DTOP_MODULATECOLOR_ADDALPHA"));         
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:                      
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVALPHA_ADDCOLOR"));      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            pMode->InvertI = 1 - pMode->InvertI;                    
            break;                                                  
            
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:                      
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVCOLOR_ADDALPHA"));      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->InvertArg1 = 1 - pMode->InvertArg1;              
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_DOTPRODUCT3:                                    
            DISPDBG((DBGLVL,"  D3DTOP_DOTPRODUCT3"));                    
            if ( iChipStageNo == 0 )                                
            {                                                       
                pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_SIGNED_AB;   
                // Signal that the special input to stage 1 is needed.
                pContext->bStage0DotProduct = TRUE;                         
            }                                                       
            else                                                    
            {                                                       
                // Can't do stage 1 dotproduct. Fail.
                DISPDBG((ERRLVL,"** SETOP: Can't do DOTPRODUCT3 in second stage."));
                if ( bIsAlpha )                                     
                {                                                   
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE ); 
                }                                                   
                else                                                
                {                                                   
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE ); 
                }                                                   
                pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;   
            }                                                       
            break;                                                  
            
        case D3DTOP_BUMPENVMAP:                                     
        case D3DTOP_BUMPENVMAPLUMINANCE:                            
            DISPDBG((ERRLVL,"** SETOP: Unsupported operation.")); 
            if ( bIsAlpha )                                         
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_OP );       
            }                                                       
            else                                                    
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );       
            }                                                       
            break;                                                  
            
        default:                                                    
            DISPDBG((ERRLVL,"** SETOP: Unknown operation."));
            if ( bIsAlpha )                                         
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_OP );         
            }                                                       
            else                                                    
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_OP );         
            }                                                       
            break;                                                  
    } // switch                                                              
} // SETOP

//-----------------------------------------------------------------------------
//
// SETTAOP
//
// Must be done after SETTAARG to set up DISABLE properly.
//
//-----------------------------------------------------------------------------
void 
SETTAOP(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode* pMode, 
    DWORD dwOperand, 
    BOOL bIsAlpha,    
    DWORD iD3DStage, 
    DWORD iChipStageNo)
{                     
    DWORD dwInvertI, dwOperation, dwI = 0, dwA = 0;
    BOOL bOperation = FALSE,
         bI         = FALSE,
         bA         = FALSE;

    pMode->Enable = __PERMEDIA_ENABLE;                                         
    dwInvertI = __PERMEDIA_DISABLE;                             
    switch (dwOperand)                                                    
    {                                                                       
        case D3DTOP_DISABLE:                                                
            if ( bIsAlpha )                                                 
            {                                                               
                // Just pass through "current"
                dwOperation = P3RX_TEXAPP_OPERATION_PASS_A;  
                bOperation = TRUE;
                dwA = P3RX_TEXAPP_A_CA;                
                bA = TRUE;
            }                                                               
            else                                                            
            {                                                               
                DISPDBG((ERRLVL,"SETTAOP: Colour op was DISABLE "      
                             " should never have got here."));
            }                                                               
            break;                                                          
        case D3DTOP_SELECTARG1:                                             
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG1"));                             
            dwOperation = P3RX_TEXAPP_OPERATION_PASS_A;   
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_SELECTARG2:                                             
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG2"));                             
            dwOperation = P3RX_TEXAPP_OPERATION_PASS_B;   
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_MODULATE:                                               
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE"));                               
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_AB; 
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_ADD:                                                    
            DISPDBG((DBGLVL,"  D3DTOP_ADD"));                                    
            dwOperation = P3RX_TEXAPP_OPERATION_ADD_AB;    
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_BLENDDIFFUSEALPHA:                                      
            DISPDBG((DBGLVL,"  D3DTOP_BLENDDIFFUSEALPHA"));                      
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI;   
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;    
            dwI = P3RX_TEXAPP_I_CA;    
            bI = TRUE;
            break;                                                          
        case D3DTOP_BLENDFACTORALPHA:                                       
            DISPDBG((DBGLVL,"  D3DTOP_BLENDFACTORALPHA"));                       
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI; 
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;  
            dwI = P3RX_TEXAPP_I_KA;             
            bI = TRUE;
            break;                                                          
        case D3DTOP_BLENDCURRENTALPHA:                                      
            DISPDBG((DBGLVL,"  D3DTOP_BLENDCURRENTALPHA"));                      
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI;   
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;    
            dwI = P3RX_TEXAPP_I_TA;         
            bI = TRUE;
            break;                                                          
        case D3DTOP_MODULATEALPHA_ADDCOLOR:                                 
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEALPHA_ADDCOLOR"));                 
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A; 
            bOperation = TRUE;
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA;         
            break;                                                          
        case D3DTOP_MODULATECOLOR_ADDALPHA:                                 
            DISPDBG((DBGLVL,"  D3DTOP_MODULATECOLOR_ADDALPHA"));                 
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_AB_ADD_I; 
            bOperation = TRUE;
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA; 
            break;                                                          
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:                              
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVALPHA_ADDCOLOR"));              
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A; 
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;   
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA;
            break;                                                          
        case D3DTOP_MODULATE2X:                                             
        case D3DTOP_MODULATE4X:                                             
        case D3DTOP_ADDSIGNED:                                              
        case D3DTOP_ADDSIGNED2X:                                            
        case D3DTOP_SUBTRACT:                                               
        case D3DTOP_ADDSMOOTH:                                              
        case D3DTOP_BLENDTEXTUREALPHA:                                      
        case D3DTOP_BLENDTEXTUREALPHAPM:                                    
        case D3DTOP_PREMODULATE:                                            
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:                              
        case D3DTOP_DOTPRODUCT3:                                            
            DISPDBG((ERRLVL,"** SETTAOP: Unsupported operation in TA unit."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE );             
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );             
            }                                                               
            break;                                                          
        case D3DTOP_BUMPENVMAP:                                             
        case D3DTOP_BUMPENVMAPLUMINANCE:                                    
            DISPDBG((ERRLVL,"** SETTAOP: Unsupported operation."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_OP );               
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );               
            }                                                               
            break;                                                          
        default:                                                            
            // What is this?. //azn
            DISPDBG((ERRLVL,"** SETTAOP: Unknown operation."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_OP );                 
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_OP );                 
            }                                                               
            break;                                                          
    }       

    if(bIsAlpha)
    {
        pMode->AlphaInvertI = dwInvertI;
        if (bOperation)
        {
            pMode->AlphaOperation = dwOperation;    
        }

        if (bI)
        {
            pMode->AlphaI = dwI;      
        }

        if (bA)
        {
            pMode->AlphaA = dwA;          
        }
    }
    else
    {
        pMode->ColorInvertI = dwInvertI;
        
        if (bOperation)
        {
            pMode->ColorOperation = dwOperation;    
        }

        if (bI)
        {
            pMode->ColorI = dwI;  
        }
        
        if (bA)
        {
            pMode->ColorA = dwA;          
        }
    }
} // SETTAOP

//-----------------------------------------------------------------------------
//
// _D3DDisplayWholeTSSPipe
//
// Dumps the whole TSS pipe state out to the debug stream.
// Also dumps fog, specular and alpha-blend state out.
//
//-----------------------------------------------------------------------------
void _D3DDisplayWholeTSSPipe ( P3_D3DCONTEXT* pContext, int iDebugNumber )
{
#if DBG
    int i;
    char *pszTemp, *pszTempPre, *pszTempPost;
    char *pszOp;
    char *pszArg1Pre, *pszArg1, *pszArg1Post;
    char *pszArg2Pre, *pszArg2, *pszArg2Post;
    char *pszSrc, *pszDest;
    P3_SURF_INTERNAL* pTexture;
    P3_SURF_FORMAT* pFormatSurface;

    DISPDBG((iDebugNumber,"TSS dump:"));

    #define SWITCH_ARG(prefix,opname) \
            case prefix##_##opname##: pszTemp = #opname; break

    i = 0;
    while ( ( i < 8 ) && ( TSSTATE ( i, D3DTSS_COLOROP ) != D3DTOP_DISABLE ) )
    {

        switch ( TSSTATE ( i, D3DTSS_COLOROP ) )
        {
            SWITCH_ARG ( D3DTOP,DISABLE );
            SWITCH_ARG ( D3DTOP,SELECTARG1 );
            SWITCH_ARG ( D3DTOP,SELECTARG2 );
            SWITCH_ARG ( D3DTOP,MODULATE );
            SWITCH_ARG ( D3DTOP,MODULATE2X );
            SWITCH_ARG ( D3DTOP,MODULATE4X );
            SWITCH_ARG ( D3DTOP,ADD );
            SWITCH_ARG ( D3DTOP,ADDSIGNED );
            SWITCH_ARG ( D3DTOP,ADDSIGNED2X );
            SWITCH_ARG ( D3DTOP,SUBTRACT );
            SWITCH_ARG ( D3DTOP,ADDSMOOTH );
            SWITCH_ARG ( D3DTOP,BLENDDIFFUSEALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHA );
            SWITCH_ARG ( D3DTOP,BLENDFACTORALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHAPM );
            SWITCH_ARG ( D3DTOP,BLENDCURRENTALPHA );
            SWITCH_ARG ( D3DTOP,PREMODULATE );
            SWITCH_ARG ( D3DTOP,MODULATEALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATECOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,MODULATEINVALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATEINVCOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,BUMPENVMAP );
            SWITCH_ARG ( D3DTOP,BUMPENVMAPLUMINANCE );
            SWITCH_ARG ( D3DTOP,DOTPRODUCT3 );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszOp = pszTemp;

        switch ( TSSTATESELECT ( i, D3DTSS_COLORARG1 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG1 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".A";
        }
        else
        {
            pszTempPost = ".C";
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG1 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg1Pre = pszTempPre;
        pszArg1Post = pszTempPost;
        pszArg1 = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_COLORARG2 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG2 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".A";
        }
        else
        {
            pszTempPost = ".C";
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG2 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg2Pre = pszTempPre;
        pszArg2Post = pszTempPost;
        pszArg2 = pszTemp;


        DISPDBG((iDebugNumber," C%i: %s: %s%s%s, %s%s%s",
                 i, pszOp, pszArg1Pre, pszArg1, pszArg1Post, 
                 pszArg2Pre, pszArg2, pszArg2Post ));


        switch ( TSSTATE ( i, D3DTSS_ALPHAOP ) )
        {
            SWITCH_ARG ( D3DTOP,DISABLE );
            SWITCH_ARG ( D3DTOP,SELECTARG1 );
            SWITCH_ARG ( D3DTOP,SELECTARG2 );
            SWITCH_ARG ( D3DTOP,MODULATE );
            SWITCH_ARG ( D3DTOP,MODULATE2X );
            SWITCH_ARG ( D3DTOP,MODULATE4X );
            SWITCH_ARG ( D3DTOP,ADD );
            SWITCH_ARG ( D3DTOP,ADDSIGNED );
            SWITCH_ARG ( D3DTOP,ADDSIGNED2X );
            SWITCH_ARG ( D3DTOP,SUBTRACT );
            SWITCH_ARG ( D3DTOP,ADDSMOOTH );
            SWITCH_ARG ( D3DTOP,BLENDDIFFUSEALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHA );
            SWITCH_ARG ( D3DTOP,BLENDFACTORALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHAPM );
            SWITCH_ARG ( D3DTOP,BLENDCURRENTALPHA );
            SWITCH_ARG ( D3DTOP,PREMODULATE );
            SWITCH_ARG ( D3DTOP,MODULATEALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATECOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,MODULATEINVALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATEINVCOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,BUMPENVMAP );
            SWITCH_ARG ( D3DTOP,BUMPENVMAPLUMINANCE );
            SWITCH_ARG ( D3DTOP,DOTPRODUCT3 );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszOp = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_ALPHAARG1 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG1 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            // Alpharep doesn't mean much in the alpha channel.
            pszTempPost = ".AR???";
        }
        else
        {
            pszTempPost = ".A";
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG1 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg1Pre = pszTempPre;
        pszArg1Post = pszTempPost;
        pszArg1 = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_ALPHAARG2 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG2 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".AR???";
        }
        else
        {
            pszTempPost = ".A";
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG2 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg2Pre = pszTempPre;
        pszArg2Post = pszTempPost;
        pszArg2 = pszTemp;

        DISPDBG((iDebugNumber," A%i: %s: %s%s%s, %s%s%s", 
                    i, pszOp, pszArg1Pre, pszArg1, pszArg1Post, 
                       pszArg2Pre, pszArg2, pszArg2Post ));


        if ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) != 0 )
        {
            char szTemp[4];
            // Setup texture 0.
            pTexture = GetSurfaceFromHandle(pContext, 
                                            TSSTATE(i, D3DTSS_TEXTUREMAP));
            if ( pTexture == NULL )
            {
                DISPDBG((iDebugNumber," Tex%i: 0x%x, TCI: %i, INVALID TEXTURE",
                         i, TSSTATE ( i, D3DTSS_TEXTUREMAP ), 
                            TSSTATE ( i, D3DTSS_TEXCOORDINDEX ) ));
            }
            else
            {
                pFormatSurface = pTexture->pFormatSurface;
                ASSERTDD ( pFormatSurface != NULL, 
                           "** _D3DDisplayWholeTSSPipe: "
                           "Surface had NULL format!" );

                // Find the filtering mode.
                szTemp[3] = '\0';
                switch ( TSSTATE ( i, D3DTSS_MINFILTER ) )
                {
                    case D3DTFN_POINT:
                        szTemp[0] = 'P';
                        break;
                    case D3DTFN_LINEAR:
                        szTemp[0] = 'L';
                        break;
                    case D3DTFN_ANISOTROPIC:
                        szTemp[0] = 'A';
                        break;
                    default:
                        szTemp[0] = '?';
                        break;
                }
                switch ( TSSTATE ( i, D3DTSS_MIPFILTER ) )
                {
                    case D3DTFP_NONE:
                        szTemp[1] = 'x';
                        break;
                    case D3DTFP_POINT:
                        szTemp[1] = 'P';
                        break;
                    case D3DTFP_LINEAR:
                        szTemp[1] = 'L';
                        break;
                    default:
                        szTemp[1] = '?';
                        break;
                }
                switch ( TSSTATE ( i, D3DTSS_MAGFILTER ) )
                {
                    case D3DTFG_POINT:
                        szTemp[2] = 'P';
                        break;
                    case D3DTFG_LINEAR:
                        szTemp[2] = 'L';
                        break;
                    case D3DTFG_FLATCUBIC:
                        szTemp[2] = 'F';
                        break;
                    case D3DTFG_GAUSSIANCUBIC:
                        szTemp[2] = 'G';
                        break;
                    case D3DTFG_ANISOTROPIC:
                        szTemp[2] = 'A';
                        break;
                    default:
                        szTemp[2] = '?';
                        break;
                }
                
                DISPDBG((iDebugNumber," Tex%i: 0x%x, TCI: %i, %s:%dx%d %s", 
                         i, TSSTATE ( i, D3DTSS_TEXTUREMAP ), 
                            TSSTATE ( i, D3DTSS_TEXCOORDINDEX ), 
                            pFormatSurface->pszStringFormat, 
                            pTexture->wWidth, 
                            pTexture->wHeight, szTemp ));
            }
        }
        else
        {
            DISPDBG((iDebugNumber," Tex%i: NULL, TCI: %i", 
                     i, TSSTATE ( i, D3DTSS_TEXCOORDINDEX ) ));
        }
        

        i++;
    }

    // Alpha-test.
    if ( pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE] != 0 )
    {
        switch ( pContext->RenderStates[D3DRENDERSTATE_ALPHAFUNC] )
        {
            SWITCH_ARG ( D3DCMP,NEVER );
            SWITCH_ARG ( D3DCMP,LESS );
            SWITCH_ARG ( D3DCMP,EQUAL );
            SWITCH_ARG ( D3DCMP,LESSEQUAL );
            SWITCH_ARG ( D3DCMP,GREATER );
            SWITCH_ARG ( D3DCMP,NOTEQUAL );
            SWITCH_ARG ( D3DCMP,GREATEREQUAL );
            SWITCH_ARG ( D3DCMP,ALWAYS );
            default:
                pszTemp = "Unknown";
                break;
        }
        DISPDBG((iDebugNumber,"Alpha-test: %s:0x%x.", 
                 pszTemp, pContext->RenderStates[D3DRENDERSTATE_ALPHAREF] ));
    }
    else
    {
        DISPDBG((iDebugNumber,"No alpha-test."));
    }


    // Alpha-blend.
    if ( pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE] != 0 )
    {
        switch ( pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] )
        {
            SWITCH_ARG ( D3DBLEND,ZERO );
            SWITCH_ARG ( D3DBLEND,ONE );
            SWITCH_ARG ( D3DBLEND,SRCCOLOR );
            SWITCH_ARG ( D3DBLEND,INVSRCCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHA );
            SWITCH_ARG ( D3DBLEND,INVSRCALPHA );
            SWITCH_ARG ( D3DBLEND,DESTALPHA );
            SWITCH_ARG ( D3DBLEND,INVDESTALPHA );
            SWITCH_ARG ( D3DBLEND,DESTCOLOR );
            SWITCH_ARG ( D3DBLEND,INVDESTCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHASAT );
            SWITCH_ARG ( D3DBLEND,BOTHSRCALPHA );
            SWITCH_ARG ( D3DBLEND,BOTHINVSRCALPHA );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszSrc = pszTemp;

        switch ( pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] )
        {
            SWITCH_ARG ( D3DBLEND,ZERO );
            SWITCH_ARG ( D3DBLEND,ONE );
            SWITCH_ARG ( D3DBLEND,SRCCOLOR );
            SWITCH_ARG ( D3DBLEND,INVSRCCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHA );
            SWITCH_ARG ( D3DBLEND,INVSRCALPHA );
            SWITCH_ARG ( D3DBLEND,DESTALPHA );
            SWITCH_ARG ( D3DBLEND,INVDESTALPHA );
            SWITCH_ARG ( D3DBLEND,DESTCOLOR );
            SWITCH_ARG ( D3DBLEND,INVDESTCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHASAT );
            SWITCH_ARG ( D3DBLEND,BOTHSRCALPHA );
            SWITCH_ARG ( D3DBLEND,BOTHINVSRCALPHA );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszDest = pszTemp;
        DISPDBG((iDebugNumber,"Blend %s:%s", pszSrc, pszDest));
    }
    else
    {
        DISPDBG((iDebugNumber,"No alpha-blend."));
    }

    #undef SWITCH_ARG

#endif //DBG
} // _D3DDisplayWholeTSSPipe

//-----------------------------------------------------------------------------
//
// __TXT_TranslateToChipBlendMode
//
// Translates the blend mode from D3D into what the chip understands
//
//-----------------------------------------------------------------------------
void 
__TXT_TranslateToChipBlendMode( 
    P3_D3DCONTEXT *pContext, 
    TexStageState* pState,
    P3_SOFTWARECOPY* pSoftP3RX, 
    int iTSStage, 
    int iChipStageNo )
{
    struct TextureCompositeRGBAMode* pColorMode;
    struct TextureCompositeRGBAMode* pAlphaMode;
    struct TextureApplicationMode* pTAMode;

    switch(iChipStageNo)
    {
        default:
            DISPDBG((ERRLVL,"ERROR: Invalid texture stage!"));
            // Fall through and treat as #0 in order not to AV anything
        case 0:
            pColorMode = &pSoftP3RX->P3RXTextureCompositeColorMode0;
            pAlphaMode = &pSoftP3RX->P3RXTextureCompositeAlphaMode0;
            pTAMode = NULL;
            break;
        case 1:
            pColorMode = &pSoftP3RX->P3RXTextureCompositeColorMode1;
            pAlphaMode = &pSoftP3RX->P3RXTextureCompositeAlphaMode1;
            pTAMode = NULL;
            break;
        case 2:
            pColorMode = NULL;
            pAlphaMode = NULL;
            pTAMode = &pSoftP3RX->P3RXTextureApplicationMode;
            break;

    }

    DISPDBG((DBGLVL,"*** In __TXT_TranslateToChipBlendMode: "
               "Chip Stage %d, D3D TSS Stage %d", 
               iChipStageNo, iTSStage ));

    // Setup the arguments
    if ( ( iChipStageNo == 0 ) || ( iChipStageNo == 1 ) )
    {
        // Texture composite unit.
        DISPDBG((DBGLVL,"TexComp%d:", iChipStageNo ));
        DISPDBG((DBGLVL,"Arg1:" ));
        
        SETARG(pContext,
               pColorMode, 
               pState->m_dwVal[D3DTSS_COLORARG1], 
               1, 
               IS_COLOR_ARG, 
               iTSStage, 
               iChipStageNo);
               
        SETARG(pContext,
               pAlphaMode, 
               pState->m_dwVal[D3DTSS_ALPHAARG1], 
               1, 
               IS_ALPHA_ARG, 
               iTSStage, 
               iChipStageNo);

        DISPDBG((DBGLVL,"Arg2:" ));
        
        SETARG(pContext,
               pColorMode, 
               pState->m_dwVal[D3DTSS_COLORARG2], 
               2, 
               IS_COLOR_ARG, 
               iTSStage, 
               iChipStageNo);
               
        SETARG(pContext,
               pAlphaMode, 
               pState->m_dwVal[D3DTSS_ALPHAARG2], 
               2, 
               IS_ALPHA_ARG, 
               iTSStage, 
               iChipStageNo);

        DISPDBG((DBGLVL,"Op:" ));
        SETOP(pContext, 
              pColorMode, 
              pState->m_dwVal[D3DTSS_COLOROP], 
              iTSStage, 
              iChipStageNo, 
              IS_COLOR_ARG);
              
        SETOP(pContext, 
              pAlphaMode, 
              pState->m_dwVal[D3DTSS_ALPHAOP], 
              iTSStage, 
              iChipStageNo, 
              IS_ALPHA_ARG);
    }
    else if ( iChipStageNo == 2 ) 
    {
        DISPDBG((DBGLVL,"TexApp:" ));
        DISPDBG((DBGLVL,"Arg1:" ));
        
        SETTAARG_COLOR(pContext, 
                       pTAMode, 
                       pState->m_dwVal[D3DTSS_COLORARG1], 
                       1 );
                 
        if ( ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_DISABLE ) && 
             ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2 ) )
        {
            SETTAARG_ALPHA(pContext,
                           pTAMode, 
                           pState->m_dwVal[D3DTSS_ALPHAARG1], 1
                           );
        }

        DISPDBG((DBGLVL,"Arg2:" ));
        SETTAARG_COLOR(pContext, 
                       pTAMode, 
                       pState->m_dwVal[D3DTSS_COLORARG2], 
                       2 );

        if ( ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_DISABLE ) && 
             ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1 ) )
        {
            SETTAARG_ALPHA(pContext, 
                           pTAMode, 
                           pState->m_dwVal[D3DTSS_ALPHAARG2], 
                           2);
        }

        DISPDBG((DBGLVL,"Op:" ));
        SETTAOP(pContext,
                pTAMode, 
                pState->m_dwVal[D3DTSS_COLOROP], 
                IS_COLOR_ARG, 
                iTSStage, 
                iChipStageNo);
                
        SETTAOP(pContext,
                pTAMode, 
                pState->m_dwVal[D3DTSS_ALPHAOP], 
                IS_ALPHA_ARG, 
                iTSStage, 
                iChipStageNo);
    } 
    else
    {
        DISPDBG(( ERRLVL,"** __TXT_TranslateToChipBlendMode: "
                         "iChipStage must be 0 to 2" ));    
    }
} // __TXT_TranslateToChipBlendMode

//-----------------------------------------------------------------------------
//
// __TXT_ValidateTextureUnitStage
//
// Validate the texture which we're trying to set up in stage iChipStage of
// the hardware, iTSStage of the D3D TSS.
//
//-----------------------------------------------------------------------------
BOOL
__TXT_ValidateTextureUnitStage(
    P3_D3DCONTEXT* pContext,
    int iChipStage, 
    int iTSStage,
    P3_SURF_INTERNAL* pTexture)
{
    DWORD dwTexHandle = 
            pContext->TextureStageState[iTSStage].m_dwVal[D3DTSS_TEXTUREMAP];
            
    if( CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(pTexture) &&
        (pTexture->Location != SystemMemory)                 &&  
        (dwTexHandle != 0)                                     )
    {
        // Texture is valid. Mark pCurrentTexturep[iChipStage] to point
        // to its P3_SURF_INTERNAL structure.
        pContext->pCurrentTexture[iChipStage] = pTexture;

        DISPDBG((DBGLVL, "__TXT_ValidateTextureUnitStage: valid texture %x "
                         "(handle %d) for iChipStage= %d iTSStage= %d",
                         pTexture, dwTexHandle, iChipStage, iTSStage));                                                                                    
    }
    else
    {
        // Set texture as invalid & force texturing off
        pContext->bTextureValid = FALSE;
        pContext->pCurrentTexture[iChipStage] = NULL;
        pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;

        // Setup error if we're asked to validate the TSS setup
        SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );

        DISPDBG((WRNLVL, "__TXT_ValidateTextureUnitStage: INVALID texture %x "
                         "(handle %d) for iChipStage= %d iTSStage= %d "
                         "Location=%d",
                         pTexture, dwTexHandle, iChipStage, iTSStage,
                         (pTexture !=NULL)?pTexture->Location:0));      
    }

    return ( (BOOL)pContext->bTextureValid );
    
} // __TXT_ValidateTextureUnitStage

//-----------------------------------------------------------------------------
//
// __TXT_ConsiderSrcChromaKey
//
// Setup chromakeying for a certain texture bound to a certain stage.
// Note - "stage" is the chip stage, not the D3D stage.
//-----------------------------------------------------------------------------
static void
__TXT_ConsiderSrcChromaKey(
    P3_D3DCONTEXT *pContext, 
    P3_SURF_INTERNAL* pTexture, 
    int stage )
{
    P3_THUNKEDDATA * pThisDisplay = pContext->pThisDisplay;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    if ((pTexture->dwFlagsInt & DDRAWISURF_HASCKEYSRCBLT) &&
        pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])
    {
        DWORD LowerBound = 0x00000000;
        DWORD UpperBound = 0xFFFFFFFF;
        DWORD* pPalEntries = NULL;
        DWORD dwPalFlags = 0;

        DISPDBG((DBGLVL,"    Can Chroma Key texture stage %d", stage));

        pContext->bCanChromaKey = TRUE;

#if DX7_PALETTETEXTURE
        // Get the palette entries
        if (pTexture->pixFmt.dwFlags & DDPF_PALETTEINDEXED8)
        {
            D3DHAL_DP2UPDATEPALETTE *pPalette = NULL;
        
            pPalette = GetPaletteFromHandle(pContext,
                                            pTexture->dwPaletteHandle);
            if (pPalette)
            {
                pPalEntries = (LPDWORD)(pPalette + 1);
            }
            else
            {
                SET_BLEND_ERROR(pContext, BSF_INVALID_TEXTURE);
            }

            dwPalFlags = pTexture->dwPaletteFlags;
        }
#endif        

        // Get the correct chroma value for the texture map to send to the chip.
        Get8888ScaledChroma(pThisDisplay, 
                            pTexture->dwFlagsInt, 
                            &pTexture->pixFmt,
                            pTexture->dwCKLow,
                            pTexture->dwCKHigh,
                            &LowerBound, 
                            &UpperBound, 
                            pPalEntries,
                            dwPalFlags & DDRAWIPAL_ALPHA, 
                            FALSE);

        P3_DMA_GET_BUFFER_ENTRIES( 8);

        // Send the upper and lower bounds for the alpha-map filtering
        if( stage == 0 )
        {
            SEND_P3_DATA(TextureChromaLower0, LowerBound );
            SEND_P3_DATA(TextureChromaUpper0, UpperBound );
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = 
                                                            __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense0 = 
                                                    P3RX_ALPHAMAPSENSE_INRANGE;
        }
        else
        {
            ASSERTDD ( stage == 1, 
                       "** __TXT_ConsiderSrcChromaKey: stage must be 0 or 1" );
        }

        // If we are mipmapping, we need to set up texture1's chromakey as well.
        // If not, then this will be overridden when this gets called for tex1.
        SEND_P3_DATA(TextureChromaLower1, LowerBound );
        SEND_P3_DATA(TextureChromaUpper1, UpperBound );
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense1 = 
                                                    P3RX_ALPHAMAPSENSE_INRANGE;

        P3_DMA_COMMIT_BUFFER();

        pSoftP3RX->P3RXTextureFilterMode.AlphaMapFiltering = __PERMEDIA_ENABLE;
    }
    else
    {
        DISPDBG((DBGLVL,"    Can't Chroma Key texture stage %d", stage));

        if( stage == 0 )
        {
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = 
                                                            __PERMEDIA_DISABLE;
        }
        else
        {
            ASSERTDD ( stage == 1, 
                       "** __TXT_ConsiderSrcChromaKey: stage must be 0 or 1" );
        }
        
        // If we are mipmapping, we need to set up texture1's chromakey (or 
        // lack of it) as well. If not, then this will be overridden when 
        // this gets called for tex1.
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapFiltering = __PERMEDIA_DISABLE;
    }
} // __TXT_ConsiderSrcChromaKey


//-----------------------------------------------------------------------------
//
// __TXT_SetupTexture
//
// This is the new all-singing all-dancing texture setup code.
// Return is TRUE if setup succeeded, FALSE if it failed (for ValidateDevice)
// This sets up either texture 0 or texture 1, taking its wrapping, etc,
// info from iTSStage.
//
//-----------------------------------------------------------------------------
BOOL __TXT_SetupTexture (
        P3_THUNKEDDATA * pThisDisplay,
        int iTexNo,
        int iTSStage,
        P3_D3DCONTEXT* pContext,
        P3_SURF_INTERNAL* pTexture,
        P3_SOFTWARECOPY* pSoftP3RX,
        BOOL bBothTexturesValid,
        P3_MIP_BASES *pMipBases)
{
    P3_SURF_FORMAT* pFormatSurface;
    int iT0MaxLevel, iT1MaxLevel;
 
    P3_DMA_DEFS();

    ASSERTDD ( ( iTexNo >= 0 ) && ( iTexNo <= 1 ), 
               "**__TXT_SetupTexture: we only have two texture units!" );

    if ( pTexture != NULL )
    {
        pFormatSurface = pTexture->pFormatSurface;
    }
    else
    {
        // Suceeded, but should never have got here!
        DISPDBG((ERRLVL,"**__TXT_SetupTexture: should never "
                             "be called with handle of NULL"));
        return ( TRUE );
    }

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Set up the texture-relevant things.

    switch ( iTexNo )
    {
        case 0:
        {
            // Set both bits in case we are mipmapping

            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne0 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne1 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;

            // D3D UV Wrapping
            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] 
                                                            & D3DWRAP_U)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS = 0;
            }

            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] 
                                                            & D3DWRAP_V)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT = 0;
            }

            // U Wrapping
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSU ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSU!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            // V Wrapping
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSV ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSV!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

#if DX8_3DTEXTURES
            if (pTexture->b3DTexture)
            {
                // W Wrapping
                switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSW ))
                {
                    case D3DTADDRESS_CLAMP:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                        break;
                    
                    case D3DTADDRESS_WRAP:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                        break;
                    
                    case D3DTADDRESS_MIRROR:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                        break;
                    
                    default:
                        DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSW!"));
                        SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                        break;
                }
            }
#endif // DX8_3DTEXTURES

            if(( TSSTATE( iTSStage, D3DTSS_ADDRESSU ) == D3DTADDRESS_CLAMP ) ||
               ( TSSTATE( iTSStage, D3DTSS_ADDRESSV ) == D3DTADDRESS_CLAMP ))
            {
                if( (TSSTATE( iTSStage, D3DTSS_ADDRESSU ) != D3DTADDRESS_CLAMP) ||
                    (TSSTATE( iTSStage, D3DTSS_ADDRESSV ) != D3DTADDRESS_CLAMP))
                {
                    DISPDBG((ERRLVL,"Warning: One texture coord clamped, but not "
                                "the other - can't appply TextureShift"));
                } 

                pSoftP3RX->P4DeltaFormatControl.TextureShift = 
                                                        __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.TextureShift = 
                                                        __PERMEDIA_ENABLE;
            }

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            switch (pFormatSurface->DeviceFormat)
            {
                case SURF_CI8:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED;
                    break;
                    
                case SURF_YUV422:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU;
                    break;
                    
                default:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
                    break;
            }
            
            // MAG Filter
            switch(TSSTATE ( iTSStage, D3DTSS_MAGFILTER ))
            {
                case D3DTFG_POINT:
                    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = 
                                    __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFG_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = 
                                    __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFG_FLATCUBIC:
                case D3DTFG_GAUSSIANCUBIC:
                case D3DTFG_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
            {
                case D3DTFN_POINT:
                    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFN_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFN_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MIPFILTER ))
            {
                case D3DTFP_NONE:
                    // No need to set the minification filter, it was done above
                    break;
                    
                case D3DTFP_POINT:
                    switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                    {
                        case D3DTFN_POINT:
                            // Point Min, Point Mip
                            pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                        __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                            break;
                        case D3DTFN_LINEAR:
                            // Linear Min, Point Mip
                            pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                     __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                            break;
                    }
                    break;
                    
                case D3DTFP_LINEAR:
                    if( bBothTexturesValid )
                    {
                        // We can only do per-poly mipmapping while 
                        // multi-texturing, so don't enable inter-map filtering.

                        // Non-fatal error - drop back to nearest 
                        // mipmap filtering.
                        SET_BLEND_ERROR ( pContext,  BS_INVALID_FILTER );

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                // Linear Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                                break;
                        }
                    }
                    else
                    {
                        // Single texture - do inter-map filtering

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Linear Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_NEARMIPLINEAR;
                                break;
                            case D3DTFN_LINEAR:
                                // Linear Min, Linear Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_LINEARMIPLINEAR;
                                break;
                        }
                    }
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MIPFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            // MipMapping
            if( (TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) != D3DTFP_NONE) && 
                (pTexture->bMipMap))
            {
                int iLOD;
                INT iTexLOD;

                DISPDBG(( DBGLVL, "Multiple texture levels" ));

                // Load the mipmap levels for texture 0
                // Mip level from pMipBases->dwTex0ActMaxLevel to 
                // pTexture->iMipLevels will be mapped to base address slot
                // from pMipBases->dwTex0Mipbase to dwTex0MipMax
                ASSERTDD ( pMipBases->dwTex0MipBase == 0, 
                          "** __TXT_SetupTexture: "
                          "Texture 0 mipmap base is not 0" );
                          
                iLOD = pMipBases->dwTex0MipBase;
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT0MaxLevel = iTexLOD;

                while(( iTexLOD < pTexture->iMipLevels ) && 
                      ( iLOD <= (int)pMipBases->dwTex0MipMax ))
                {
                    DISPDBG((DBGLVL, "  Setting Texture Base Address %d to 0x%x", 
                                iLOD, pTexture->MipLevels[iLOD].dwOffsetFromMemoryBase));
                                
                    pSoftP3RX->P3RXTextureMapWidth[iLOD] = 
                                pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            iLOD);
                    }
                    else
#endif
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                            iLOD);
                    }

                    iLOD++;
                    iTexLOD++;
                }

                // If both textures are enabled we can't do per-pixel 
                // mipmapping because that uses both sets of texcoord 
                // DDAs to generate the LOD level. So we must do per-poly 
                // mipmapping. Per-poly mipmapping can only be done in 
                // hardware on P4 - we use a Delta renderer on P3 when 
                // mipmapping with both textures enabled.

                if( bBothTexturesValid )
                {
                    DISPDBG(( DBGLVL, "Both textures valid" ));

                    // Do per-poly mipmapping in the P4 DeltaFormat unit

                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_ENABLE;

                    {
                        DWORD d;

                        *(float *)&d = 
                                pContext->MipMapLODBias[TEXSTAGE_0] *
                                pTexture->dwPixelPitch *
                                pTexture->wHeight;

                        SEND_P3_DATA(TextureLODScale, d);                       
                    }
                }
                else
                {
                    DISPDBG(( DBGLVL, "Single texture only" ));

                    // Do per-pixel mipmapping

                
                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_ENABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_ENABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_DISABLE;

//@@BEGIN_DDKSPLIT
#if 0
// azn this would disable "automatic" mip mapping and we would be using the
// values supplied by writing into LOD and LOD1 (d3dprim.c) - don't forget!
                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_ENABLE;
                    SEND_P3_DATA(TextureLODScale, 0);
#endif
//@@END_DDKSPLIT
                    {
                        float bias;
                        DWORD b;

                        bias = pContext->TextureStageState[TEXSTAGE_0].m_fVal[D3DTSS_MIPMAPLODBIAS];

                        // Convert LOD bias from float to 6.8

                        myFtoi( &b, bias * 256.0f );

                        SEND_P3_DATA(TextureLODBiasS, b);
                        SEND_P3_DATA(TextureLODBiasT, b);
                    }
                }

                pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = 
                                                            __PERMEDIA_ENABLE;
            }
            else
            {
                int iTexLOD;

                // No mipmapping.
                DISPDBG(( DBGLVL, "Single texture level" ));

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = 
                                                            __PERMEDIA_DISABLE;

                ASSERTDD ( pMipBases->dwTex0MipBase == 0, 
                          "** __TXT_SetupTexture: "
                          "Texture 0 mipmap base is not 0" );
                          
                // Use the maximum level indicated by D3DTSS_MAXMIPLEVEL
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT0MaxLevel = iTexLOD;

#if DX7_TEXMANAGEMENT
                // If this is a driver managed texture surface, we need 
                // to use our privately allocated mem ptr
                if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                {                        
                    SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                        (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                        0);
                }
                else
#endif                
                {
                    SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                        pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                        0);
                }

                // No mipmapping, but could be combining the caches.
                pSoftP3RX->P3RXTextureMapWidth[0] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
                pSoftP3RX->P3RXTextureMapWidth[1] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
            }

//@@BEGIN_DDKSPLIT
            // There is only one TextureCoordMode, it is possible that it is
            // not used at all
//@@END_DDKSPLIT
            // Set maximum dimension of the texture
            pSoftP3RX->P3RXTextureCoordMode.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureCoordMode.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;
#if DX7_PALETTETEXTURE
            // If it is a palette indexed texture, we simply follow the chain
            // down from the surface to its palette and pull out the LUT values
            // from the PALETTEENTRY's in the palette.
            ASSERTDD ( pFormatSurface != NULL, "** SetupTextureUnitStage: logic error: pFormatSurace is NULL" );
            if (pFormatSurface->DeviceFormat == SURF_CI8)
            {
                WAIT_FIFO(8);

                pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXLUTMode.InColorOrder = __PERMEDIA_ENABLE;        
                SEND_P3_DATA(LUTAddress, 0);
                SEND_P3_DATA(LUTTransfer, 0);
                SEND_P3_DATA(LUTIndex, 0);
                COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

                // In this case simply download the 256 entries each time the 
                // texture handle changes.
                {
                    DWORD dwCount1, dwCount2;
                    D3DHAL_DP2UPDATEPALETTE *pPalette;  // associated palette
                    LPDWORD lpColorTable;           // array of palette entries
        
                    pPalette = GetPaletteFromHandle(pContext, 
                                                    pTexture->dwPaletteHandle);
                    if (pPalette) // If palette can be found
                    {
                        lpColorTable = (LPDWORD)(pPalette + 1);
                        
                        if (pTexture->dwPaletteFlags & DDRAWIPAL_ALPHA)
                        {
                            for (dwCount1 = 0; dwCount1 < 16; dwCount1++)
                            {
                                P3_ENSURE_DX_SPACE(17);
                                WAIT_FIFO(17);
                                P3RX_HOLD_CMD(LUTData, 16);
                                for (dwCount2 = 0; dwCount2 < 16; dwCount2++)
                                {
                                    *dmaPtr++ = *lpColorTable++;
                                    CHECK_FIFO(1);
                                }
                            }
                        }
                        else
                        {
                            for (dwCount1 = 0; dwCount1 < 16; dwCount1++)
                            {
                                P3_ENSURE_DX_SPACE(17);
                                WAIT_FIFO(17);
                                P3RX_HOLD_CMD(LUTData, 16);
                                for (dwCount2 = 0; dwCount2 < 16; dwCount2++)
                                {
                                    *dmaPtr++ = CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable++);
                                    CHECK_FIFO(1);
                                }
                            }
                        }
                    }
                    else
                    {
                        DISPDBG((ERRLVL,"Palette handle is missing for CI8 surf!"));
                    }
                }

                // Make sure there is room left over for the rest of the routine
                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);
                SEND_P3_DATA(LUTIndex, 0);

            }
            else
#endif // DX7_PALETTETEXTURE
            {
                // No LUT.
                P3_ENSURE_DX_SPACE(4);
                WAIT_FIFO(4);
                
                pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
                SEND_P3_DATA(LUTTransfer, __PERMEDIA_DISABLE);
                COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode)
            }

#if DX8_3DTEXTURES
            P3_ENSURE_DX_SPACE(4);
            WAIT_FIFO(4);

            if (pTexture->b3DTexture)
            {
                //
                // Set size of each 2D texture slice in texel size to TextureMapSize.
                //
                SEND_P3_DATA(TextureMapSize, pTexture->dwSliceInTexel);
            }
            else
            {
                SEND_P3_DATA(TextureMapSize, 0);
            }
#endif // DX8_3DTEXTURES

            P3_DMA_COMMIT_BUFFER();
            __TXT_ConsiderSrcChromaKey( pContext, pTexture, 0 );
            P3_DMA_GET_BUFFER();

            // Setup TextureReadMode
            pSoftP3RX->P3RXTextureReadMode0.MapBaseLevel = 
                                                    pMipBases->dwTex0MipBase;
            pSoftP3RX->P3RXTextureReadMode0.MapMaxLevel = 
                                                    pMipBases->dwTex0MipMax;
            pSoftP3RX->P3RXTextureReadMode0.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureReadMode0.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;
            pSoftP3RX->P3RXTextureReadMode0.TexelSize = pTexture->dwPixelSize;

            pSoftP3RX->P3RXTextureReadMode0.LogicalTexture = 
                                                            __PERMEDIA_DISABLE;

            // Enable stage 0
            pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_ENABLE;

            // Never set CombineCaches - chip bug
            pSoftP3RX->P3RXTextureReadMode0.CombineCaches = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureFilterMode.CombineCaches = __PERMEDIA_DISABLE;

            // Always copy TRM0 to TRM1 in case we are combining the caches
            pSoftP3RX->P3RXTextureReadMode1 = pSoftP3RX->P3RXTextureReadMode0;

            // Enable the texture index unit 
            // (this is a bit like the the texture read)
            pSoftP3RX->P3RXTextureIndexMode0.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureIndexMode0.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;

            // Set both formats to be equal for texture 0 - this will be correct 
            // for single-texture per-pixel mipmap or non-mipmapped with a 
            // combined cache. If the second texture is valid it's setup below 
            // will set Format1 appropriately.

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );

            pSoftP3RX->P3RXTextureFilterMode.Format0 = 
                                                pFormatSurface->FilterFormat;
            pSoftP3RX->P3RXTextureFilterMode.Format1 = 
                                                pFormatSurface->FilterFormat;

#if DX8_3DTEXTURES
            if (pTexture->b3DTexture)
            {
                //
                // Enable 3D Texture registers.
                //
                pSoftP3RX->P3RX_P3DeltaMode.Texture3DEnable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = 
                                                            __PERMEDIA_ENABLE;

                //
                // ReadMode1 and IndexMode1 should have same data as 0.
                //
                pSoftP3RX->P3RXTextureReadMode1 = pSoftP3RX->P3RXTextureReadMode0;
                pSoftP3RX->P3RXTextureIndexMode1 = pSoftP3RX->P3RXTextureIndexMode0;

                //
                // And put logDepth into IndexMode1.Width. 
                //
                pSoftP3RX->P3RXTextureIndexMode1.Width = pTexture->logDepth;
            }
            else
            {
                pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = 
                                                            __PERMEDIA_DISABLE;
            }
#endif // DX8_3DTEXTURES
            break;
        }

        // Texture Stage 1
        case 1:
        {
            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne1 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;

            // D3D UV Wrapping
            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] & 
                                                                    D3DWRAP_U)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS1 = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS1 = 0;
            }

            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] & 
                                                                    D3DWRAP_V)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT1 = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT1 = 0;
            }

            // U Addressing
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSU ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                    
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                    
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSU!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            // V Addressing
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSV ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                    
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                    
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSV!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            if(( TSSTATE( iTSStage, D3DTSS_ADDRESSU ) == D3DTADDRESS_CLAMP ) ||
               ( TSSTATE( iTSStage, D3DTSS_ADDRESSV ) == D3DTADDRESS_CLAMP ))
            {
                if ((TSSTATE( iTSStage, D3DTSS_ADDRESSU ) != D3DTADDRESS_CLAMP) ||
                    (TSSTATE( iTSStage, D3DTSS_ADDRESSV ) != D3DTADDRESS_CLAMP))
                {
                    DISPDBG((ERRLVL,"Warning: One texture coord clamped, but not "
                                "the other - can't appply TextureShift"));
                }
                 
                pSoftP3RX->P4DeltaFormatControl.TextureShift1 = 
                                                            __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.TextureShift1 = 
                                                            __PERMEDIA_ENABLE;
            }

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            switch (pFormatSurface->DeviceFormat)
            {
                case SURF_CI8:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED;
                    break;
                    
                case SURF_YUV422:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU;
                    break;
                    
                default:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
                    break;
            }
            
            // MAG Filter
            switch(TSSTATE ( iTSStage, D3DTSS_MAGFILTER ))
            {
                case D3DTFG_POINT:
                    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFG_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFG_FLATCUBIC:
                case D3DTFG_GAUSSIANCUBIC:
                case D3DTFG_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
            {
                case D3DTFN_POINT:
                    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MIPFILTER ))
            {
                case D3DTFP_NONE:
                    // No need to set the minification filter
                    // it was done above
                    break;
                    
                case D3DTFP_LINEAR:
                case D3DTFP_POINT:
                    if( bBothTexturesValid )
                    {
                        if ( TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) == 
                                                                D3DTFP_LINEAR )
                        {
                            // Can't do trilinear with both textures 
                            // - fall back to per-poly.
                            SET_BLEND_ERROR ( pContext,  BS_INVALID_FILTER );
                        }

                        // We can only do per-poly mipmapping while 
                        // multi-texturing, so don't enable 
                        //inter-map filtering.

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter =
                                                                        __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                                break;
                                
                            case D3DTFN_LINEAR:
                                // Linear Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter =
                                                                        __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                                break;
                        }
                    }
                    else
                    {
                        DISPDBG((ERRLVL,"** Setting up the second stage, but "
                                     "only one texture is valid"));
                    }
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Invalid Mip filter!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            // MipMapping
            // If the app chooses to have two mip-mapped textures or a 
            // single mip-mapped texture in stage 1 they only get 
            // per-poly mipmapping.
            if( (TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) != D3DTFP_NONE) && 
                 pTexture->bMipMap )
            {
                int iLOD, iTexLOD;

                // Load the mipmap levels for texture 1
                // Mip level from pMipBases->dwTex1ActMaxLevel to
                // pTexture->iMipLevels will be mapped to base address slot
                // from pMipBases->dwTex1Mipbase to dwTex1MipMax
                iLOD = pMipBases->dwTex1MipBase;
                iTexLOD = pMipBases->dwTex1ActMaxLevel;
                iT1MaxLevel = iTexLOD;
 
                P3_ENSURE_DX_SPACE(32);
                WAIT_FIFO(32);

                while(( iTexLOD < pTexture->iMipLevels ) && 
                      ( iLOD <= (int)pMipBases->dwTex1MipMax ))
                {
                    DISPDBG((DBGLVL, "  Setting Texture Base Address %d to 0x%x", 
                                iLOD, 
                                pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase));
                                
                    pSoftP3RX->P3RXTextureMapWidth[iLOD] = 
                                pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            iLOD);            
                    }
                    else
#endif   
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                            iLOD);
                    }   
                    
                    iLOD++;
                    iTexLOD++;
                }

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap1 = 
                                                            __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = 
                                                            __PERMEDIA_ENABLE;

                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);
                {
                    DWORD d;

                    *(float *)&d = 
                            pContext->MipMapLODBias[TEXSTAGE_1] *
                            pTexture->dwPixelPitch *
                            pTexture->wHeight;

                    SEND_P3_DATA(TextureLODScale1, d);
                }
            }
            else
            {
                int iTexLOD;

                // Use the maximum level indicated by D3DTSS_MAXMIPLEVEL
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT1MaxLevel = iTexLOD;

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap1 = 
                                                            __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = 
                                                            __PERMEDIA_DISABLE;

                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            pMipBases->dwTex1MipBase);            
                    }
                    else
#endif
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase,
                                            pMipBases->dwTex1MipBase);
                    }
                    
                // No mipmapping.
                pSoftP3RX->P3RXTextureMapWidth[pMipBases->dwTex1MipBase] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
            }


            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
                       
            if (pFormatSurface->DeviceFormat == SURF_CI8)
            {
                // In the future, this will work as long as texture 0 isn't
                // palettised, or if they share the palette.
                // But that needs some restructuring - the whole LUT setup 
                // should be in a single bit of code in _D3DChangeTextureP3RX, 
                // since it is a shared resource.
                DISPDBG((ERRLVL,"** SetupTextureUnitStage: allow second texture "
                             "to use LUTs"));
                              
                // For now, fail.
                SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_PALETTES );
            }

            P3_DMA_COMMIT_BUFFER();
            __TXT_ConsiderSrcChromaKey( pContext, pTexture, 1 );
            P3_DMA_GET_BUFFER();

            // Setup TextureReadMode
            pSoftP3RX->P3RXTextureReadMode1.MapBaseLevel = 
                                                    pMipBases->dwTex1MipBase;
            pSoftP3RX->P3RXTextureReadMode1.MapMaxLevel = 
                                                    pMipBases->dwTex1MipMax;
            pSoftP3RX->P3RXTextureReadMode1.Width = pTexture->MipLevels[iT1MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureReadMode1.Height = pTexture->MipLevels[iT1MaxLevel].logHeight;
            pSoftP3RX->P3RXTextureReadMode1.TexelSize = pTexture->dwPixelSize;

            pSoftP3RX->P3RXTextureReadMode1.LogicalTexture = 
                                                            __PERMEDIA_DISABLE;
            
            // Enable the texture index unit (this is a bit like the 
            // the texture read)
            pSoftP3RX->P3RXTextureIndexMode1.Width = pTexture->MipLevels[iT1MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureIndexMode1.Height = pTexture->MipLevels[iT1MaxLevel].logHeight;
            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            pSoftP3RX->P3RXTextureFilterMode.Format1 = 
                                                pFormatSurface->FilterFormat;

            // Enable stage 1
            pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_ENABLE;

#if DX7_PALETTETEXTURE
#if 0
            // D3DValidateDeviceP3() will return error code for this case
            ASSERTDD((pFormatSurface->DeviceFormat != SURF_CI8 && 
                      pFormatSurface->DeviceFormat != SURF_CI4),
                     "Texture surface can't be palettized when using a "
                     "second map!");
#endif
#endif

            break;
        }
    }

    P3_DMA_COMMIT_BUFFER();

    return TRUE;
} // __TXT_SetupTexture

//-----------------------------------------------------------------------------
//
// __bD3DTexturesMatch
//
//
// A function to compare the two textures in two D3D stages, and determine
// if they could be satisfied by the same on-chip texture.
//
// int iStage1              D3D stage number of first texture.
// int iStage2              D3D stage number of second texture.
// *pContext                The context.
//
// result:                  TRUE if the textures match, FALSE if they don't.
//
// An ASSERT is triggered if either stage is not using a texture. In the 
// release build, the result will be TRUE, meaning that we could pack both 
// textures stages requirements into one texture (because one or both do 
// not use a texture).
//
//-----------------------------------------------------------------------------
BOOL 
__bD3DTexturesMatch ( 
    int iStage1, 
    int iStage2, 
    P3_D3DCONTEXT* pContext )
{
    ASSERTDD ( iStage1 != iStage2, 
               "** __bD3DTexturesMatch: both stages are the same "
               "- pointless comparison!" );
               
    if ( TSSTATE ( iStage1, D3DTSS_TEXTUREMAP ) == 0 )
    {
        DISPDBG((ERRLVL,"** __bD3DTexturesMatch: first considered stage's "
                     "texture is NULL"));
                      
        return ( TRUE );
    }
    else if ( TSSTATE ( iStage2, D3DTSS_TEXTUREMAP ) == 0 )
    {
        DISPDBG((ERRLVL,"** __bD3DTexturesMatch: second considered stage's "
                      "texture is NULL"));
        return ( TRUE );
    }
    else
    {
        #define CHECK_EQUALITY(name) ( TSSTATE ( iStage1, name ) == TSSTATE ( iStage2, name ) )
        if (CHECK_EQUALITY ( D3DTSS_TEXTUREMAP ) &&
            CHECK_EQUALITY ( D3DTSS_TEXCOORDINDEX ) )
        {
            // Yes, the textures have the same handle and coord set. Do 
            // some further checks.

            // If the pointers are different, or the texcoord sets are 
            // different (for bumpmapping), this is a common occurrance, 
            // and need not be flagged. However, if they are the same, 
            // but a filter mode or something like that is different,
            // it is likely to be an app bug, so flag it.

            if (
                // Should not need to check ADDRESS 
                // - should have been mirrored to ADDRESS[UV].
                CHECK_EQUALITY ( D3DTSS_ADDRESSU ) &&
                CHECK_EQUALITY ( D3DTSS_ADDRESSV ) &&
                CHECK_EQUALITY ( D3DTSS_MAGFILTER ) &&
                CHECK_EQUALITY ( D3DTSS_MINFILTER ) &&
                CHECK_EQUALITY ( D3DTSS_MIPFILTER ) )
                // I should also check all the other variables like 
                // MIPMAPLODBIAS, but they rely on mipmapping being 
                // enabled, etc, so it's more of a hassle. If an app 
                // really does manage to be this perverse, it's doing well!
            {
                // Looks good.
                return ( TRUE );
            }
            else
            {
                // Well, the texcoords agree and the handle agree, but the 
                // others don't. I bet this is an app bug - you are unlikely 
                // to do this deliberately.
                _D3DDisplayWholeTSSPipe ( pContext, WRNLVL );
                DISPDBG((ERRLVL,"** __bD3DTexturesMatch: textures agree in "
                              "handle and texcoord, but not other things - "
                              "likely app bug."));
                return ( FALSE );
            }
        }
        else
        {
            // No, different textures.
            return ( FALSE );
        }
        #undef CHECK_EQUALITY
    }
    return TRUE;
} // __bD3DTexturesMatch  

//-----------------------------------------------------------------------------
//
// _D3DChangeTextureP3RX
//
// This function does whole setup of necessary texturing state  according to
// the current renderestates and texture stage states. Disables texturing
// accordingly if this is needed.
//
//-----------------------------------------------------------------------------

void 
_D3DChangeTextureP3RX(
    P3_D3DCONTEXT* pContext)
{
    P3_SURF_INTERNAL* pTexture0 = NULL;
    P3_SURF_INTERNAL* pTexture1 = NULL;
    P3_THUNKEDDATA * pThisDisplay = pContext->pThisDisplay;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_MIP_BASES mipBases;
    DWORD* pFlags = &pContext->Flags;   
    INT i, iLastChipStage;
    DWORD dwT0MipLevels, 
          dwT1MipLevels,
          dwTexAppTfactor, 
          dwTexComp0Tfactor, 
          dwTexComp1Tfactor;
    BOOL bBothTexturesValid,
         bProcessChipStage0, 
         bProcessChipStage1, 
         bProcessChipStage2,
         bAlphaBlendDouble;

    P3_DMA_DEFS();

    DBG_ENTRY(_D3DChangeTextureP3RX);  

    pContext->iTexStage[0] = -1;
    pContext->iTexStage[1] = -1;
    // This is checked against the current state at the end of the routine.
    bAlphaBlendDouble = FALSE;

    // Verify if texturing should be disabled
    if ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) ||
         ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) == 0 ) &&
           ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) &&
           ( ( ( TSSTATESELECT ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) &&
               ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ) ||
             ( ( TSSTATESELECT ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) &&
               ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ) )
         ) )
    {
        // Stage 0 is disabled, so they just want the diffuse colour.
        // Or, the texture handle is 0 , stage 1 is D3DTOP_DISABLE and in stage 
        // 0 we are selecting an arg that is not a D3DTA_TEXTURE
       
        DISPDBG((DBGLVL, "All composite units disabled - setting diffuse colour"));
        
        P3_DMA_GET_BUFFER_ENTRIES(20);

        // Turn off texture address generation
        pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    
        // Turn off texture reads
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
        COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);
        COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

        // Turn off the texture filter mode unit
        pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);
        
        // Turn off texture color mode unit
        pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureApplicationMode, 
                     pSoftP3RX->P3RXTextureApplicationMode);

        // Not compositing
        SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE);

        *pFlags &= ~SURFACE_TEXTURING;

        pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

        // Specular texture can be enabled without texturing on
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();
    
        // Turn off texturing in the render command
        RENDER_TEXTURE_DISABLE(pContext->RenderCommand);

        pContext->bTextureValid = TRUE;
        pContext->pCurrentTexture[0] = NULL;
        pContext->pCurrentTexture[1] = NULL;

        // Track just for debugging purpouses
        pContext->bTexDisabled = TRUE;

        bAlphaBlendDouble = FALSE;
        if ( bAlphaBlendDouble != pContext->bAlphaBlendMustDoubleSourceColour )
        {
            pContext->bAlphaBlendMustDoubleSourceColour = bAlphaBlendDouble;
            DIRTY_ALPHABLEND(pContext);
        }

        DBG_EXIT(_D3DChangeTextureP3RX,1);  
        return;
    }

    if ( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) == 0 )
    if ( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TFACTOR ) &&
           ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) ) ||
         ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_TFACTOR ) &&
           ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2 ) ) )
    {
        // This is an unusual way to set up the diffuse color : take
        // it from the the D3DTA_TFACTOR. But some apps use it.
        // we need to treat it separately for the Perm3 setup because
        // it might not be binded with any texture

        DISPDBG((DBGLVL, "Diffuse color comes from D3DTA_TFACTOR"));

        P3_DMA_GET_BUFFER_ENTRIES(30);

        // Turn off texture address generation
        pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    
        // Turn off texture reads
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
        COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);
        COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

        // Turn off the texture filter mode unit
        pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

        // Setup texture color mode unit            
        pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureApplicationMode.ColorA = P3RX_TEXAPP_A_KC;
        pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_A; 
        pSoftP3RX->P3RXTextureApplicationMode.AlphaA = P3RX_TEXAPP_A_KA;                   
        pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_A; 
                
        COPY_P3_DATA(TextureApplicationMode, 
                     pSoftP3RX->P3RXTextureApplicationMode);

        // Setup compositing

        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_FA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE; 
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;  
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;          
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;          
        COPY_P3_DATA(TextureCompositeAlphaMode0, 
                     pSoftP3RX->P3RXTextureCompositeAlphaMode0);

        pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_FC;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE; 
        pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;  
        pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;          
        pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;          
        COPY_P3_DATA(TextureCompositeColorMode0, 
                     pSoftP3RX->P3RXTextureCompositeColorMode0);
                     
        pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_DISABLE;                
        COPY_P3_DATA(TextureCompositeAlphaMode1, 
                     pSoftP3RX->P3RXTextureCompositeAlphaMode1);

        pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_DISABLE;                
        COPY_P3_DATA(TextureCompositeColorMode1, 
                     pSoftP3RX->P3RXTextureCompositeColorMode1);
                     
        SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_ENABLE);

        *pFlags &= ~SURFACE_TEXTURING;

        pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

        // Specular texture can be enabled without texturing on
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();

    
    
        // Turn off texturing in the render command
        // RENDER_TEXTURE_DISABLE(pContext->RenderCommand);
        RENDER_TEXTURE_ENABLE(pContext->RenderCommand);

        pContext->bTextureValid = TRUE;
        pContext->pCurrentTexture[0] = NULL;
        pContext->pCurrentTexture[1] = NULL;

        // Track just for debugging purpouses
        pContext->bTexDisabled = FALSE;

        
        DBG_EXIT(_D3DChangeTextureP3RX,1);  
        return;
    }

    // Track just for debugging purpouses
    pContext->bTexDisabled = FALSE;

    // Dump to the debugger our current TSS setup
    _D3DDisplayWholeTSSPipe(pContext, DBGLVL);

    // Deal with the textures.

    // Find the texture mappings. If D3D stage 0 uses a texture, it must 
    // always be chip texture 0 to keep the bumpmap working. Fortunately, 
    // this is the only non-orthogonal case, so everything else can cope 
    // with this restriction.
    
    for ( i = TEXSTAGE_0; i < D3DTSS_MAX; i++ )
    {
        if ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_DISABLE )
        {
            // Finished processing.
            break;
        }

        // This code could be slightly optimised - if a texture is set up, 
        // but none of the relevant arguments are TEXTURE (with additional 
        // flags), then of course we don't need to set the texture up at all.
        // Normally, both arguments are "relevant", but with SELECTARG1 and 
        // SELECTARG2, one of them is not. Also, watch out for PREMODULATE - 
        // it is an implicit reference to a stage's texture.

        if (
            ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) == 0 ) ||
            ( (
                ( ( TSSTATESELECT ( i, D3DTSS_COLORARG1 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_COLORARG2 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_ALPHAARG1 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_ALPHAARG2 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1     ) )
              ) &&
              ( TSSTATE ( i, D3DTSS_COLOROP ) != D3DTOP_PREMODULATE ) &&
              ( TSSTATE ( i-1, D3DTSS_COLOROP ) != D3DTOP_PREMODULATE )
            ) )
        {
            // This D3D stage doesn't use a texture.
            pContext->iStageTex[i] = -1;
        }
        else
        {
            // Note that the below code should be put into a little loop
            // for any future devices that have more than 2 textures, otherwise
            // the code will get big, nested and crufty. But for only 2, it's
            // manageable, and slightly faster this way.

            // A texture is used - is texture 0 free?
            if ( pContext->iTexStage[0] == -1 )
            {
                // Texture 0 is free - make it this stage.
                ASSERTDD ( pContext->iTexStage[1] == -1, 
                           "** _D3DChangeTextureP3RX: pContext->iTexStage[1] "
                           "should be -1 if pContext->iTexStage[0] is" );
                pContext->iTexStage[0] = i;
                pContext->iStageTex[i] = 0;
            }
            else
            {
                // Texture 0 is assigned - see if this is the same as it.
                if ( __bD3DTexturesMatch ( i, 
                                           pContext->iTexStage[0], 
                                           pContext ) )
                {
                    // Yes, they match - no need to use texture 1.
                    pContext->iStageTex[i] = 0;
                }
                else
                {
                    // No, they don't match. Is texture 1 free?
                    if ( pContext->iTexStage[1] == -1 )
                    {
                        // Texture 1 is free - make it this stage.
                        ASSERTDD ( pContext->iTexStage[0] != -1, 
                                   "** _D3DChangeTextureP3RX: "
                                   "pContext->iTexStage[0] should not be "
                                   "-1 if pContext->iTexStage[1] is not." );
                        pContext->iTexStage[1] = i;
                        pContext->iStageTex[i] = 1;
                    }
                    else
                    {
                        // Texture 1 is assigned - see if this is the same 
                        // as it.
                        if ( __bD3DTexturesMatch ( i, 
                                                   pContext->iTexStage[1], 
                                                   pContext ) )
                        {
                            // Yes, they match - mark it.
                            pContext->iStageTex[i] = 1;
                        }
                        else
                        {
                            // No, they don't match, and both chip textures 
                            // have been assigned. Fail a ValidateDevice().
                            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: app tried "
                                         "to use more than two textures."));
                            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_TEXTURES );
                            pContext->iStageTex[i] = -1;
                        }
                    }
                }
            }
        }

        // A quick sanity check.
#if DBG
        if ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) == 0 )
        {
            // That's fine, then.
            ASSERTDD ( pContext->iStageTex[i] == -1, 
                       "** _D3DChangeTextureP3RX: something failed with the "
                       "texture-assignment logic" );
        }
        else if ( pContext->iStageTex[i] == -1 )
        {
            // That's fine - texture may have been set up but not referenced.
        }
        else if ( pContext->iTexStage[pContext->iStageTex[i]] == -1 )
        {
            // Oops.
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: something failed with "
                          "the texture-assignment logic"));
        }
        else if ( pContext->iTexStage[pContext->iStageTex[i]] == i )
        {
            // That's fine, then.
        }
        else if ( __bD3DTexturesMatch ( i, 
                                        pContext->iTexStage[pContext->iStageTex[i]], 
                                        pContext ) )
        {
            // That's fine, then.
        }
        else
        {
            // Oops.
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: something failed with "
                          "the texture-assignment logic"));
        }
#endif // DBG
    }
    
    // And a few more gratuitous sanity checks at the end of the loop.
    ASSERTDD ( ( pContext->iTexStage[0] == -1 ) || 
               ( pContext->iStageTex[pContext->iTexStage[0]] == 0 ), 
               "** _D3DChangeTextureP3RX: something failed with the "
               "texture-assignment logic" );
               
    ASSERTDD ( ( pContext->iTexStage[1] == -1 ) || 
               ( pContext->iStageTex[pContext->iTexStage[1]] == 1 ), 
               "** _D3DChangeTextureP3RX: something failed with the "
               "texture-assignment logic" );

#if DBG
    if ( pContext->iTexStage[0] != -1 )
    {
        DISPDBG((DBGLVL, "Setting new texture0 data, Handle: 0x%x", 
                    TSSTATE ( pContext->iTexStage[0], D3DTSS_TEXTUREMAP )));
    }
    else
    {
        DISPDBG((DBGLVL, "Texture0 not used" ));
    }
    
    if ( pContext->iTexStage[1] != -1 )
    {
        DISPDBG((DBGLVL, "Setting new texture1 data, Handle: 0x%x", 
                    TSSTATE ( pContext->iTexStage[1], D3DTSS_TEXTUREMAP )));
    }
    else
    {
        DISPDBG((DBGLVL, "Texture1 not used" ));
    }
#endif //DBG
    
    // Set the texture valid flag to true.  
    // If anything resets it then the texture state is invalid.
    pContext->bTextureValid = TRUE;
    pContext->bCanChromaKey = FALSE;
    pContext->bTex0Valid = FALSE;
    pContext->bTex1Valid = FALSE;
    pContext->bStage0DotProduct = FALSE;

    // Set up the textures.
    if ( pContext->iTexStage[0] != -1 )
    {
        // Setup texture 0.
        pTexture0 = GetSurfaceFromHandle(pContext, 
                                         TSSTATE(pContext->iTexStage[0], 
                                                 D3DTSS_TEXTUREMAP) );
        if (NULL == pTexture0)
        {
            DISPDBG((ERRLVL, "ERROR: Texture Surface (0) is NULL"));
            DBG_EXIT(_D3DChangeTextureP3RX,1);  
            return;            
        }
        
#if DX7_TEXMANAGEMENT  
        if (pTexture0->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pTexture0))
            {
                return; // something bad happened !!!
            }

            _D3D_TM_TimeStampTexture(pContext->pTextureManager,
                                     pTexture0);        
        }
#endif // DX7_TEXMANAGEMENT                                                 

        pContext->bTex0Valid = 
                    __TXT_ValidateTextureUnitStage(pContext, 
                                                   0, 
                                                   pContext->iTexStage[0],
                                                   pTexture0 );
        if ( !pContext->bTex0Valid )
        {
            SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );
            // Pretend that no texture was set.
            pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
            pContext->bTex0Valid = FALSE;
            pTexture0 = NULL;
        }
    }
    else
    {
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pContext->bTex0Valid = FALSE;
        pTexture0 = NULL;
    }

    if ( pContext->iTexStage[1] != -1 )
    {
        // Setup texture 1.
        if ( pContext->iTexStage[0] == -1 )
        {
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Should not be "
                          "using tex1 if tex0 not used."));
            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
        }
        
        pTexture1 = GetSurfaceFromHandle(pContext, 
                                         TSSTATE ( pContext->iTexStage[1],
                                                   D3DTSS_TEXTUREMAP ) );
        if (NULL == pTexture1)
        {
            DISPDBG((ERRLVL, "ERROR: Texture Surface (1) is NULL"));
            DBG_EXIT(_D3DChangeTextureP3RX,1);  
            return;            
        }
                                                   

#if DX7_TEXMANAGEMENT  
        if (pTexture1->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pTexture1))
            {
                return; // something bad happened !!!
            }

            _D3D_TM_TimeStampTexture(pContext->pTextureManager,
                                     pTexture1);        
        }
#endif // DX7_TEXMANAGEMENT                                                     

        pContext->bTex1Valid = 
                    __TXT_ValidateTextureUnitStage(pContext, 
                                                   1, 
                                                   pContext->iTexStage[1], 
                                                   pTexture1 );
        if ( !pContext->bTex1Valid )
        {
            SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );
            // Pretend that no texture was set.
            pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
            pContext->bTex1Valid = FALSE;
            pTexture1 = NULL;
        }
    }
    else
    {
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        pContext->bTex1Valid = FALSE;
        pTexture1 = NULL;
    }

    bBothTexturesValid = pContext->bTex0Valid && pContext->bTex1Valid;

    if( pContext->bTex0Valid )
    {
        dwT0MipLevels = pContext->TextureStageState[0].m_dwVal[D3DTSS_MAXMIPLEVEL];
#if DX7_TEXMANAGEMENT        
        if ( dwT0MipLevels < pTexture0->m_dwTexLOD)
        {
            dwT0MipLevels = pTexture0->m_dwTexLOD;
        }
#endif // DX7_TEXMANAGEMENT
        if (dwT0MipLevels > ((DWORD)(pTexture0->iMipLevels - 1))) 
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex0ActMaxLevel = pTexture0->iMipLevels - 1;

            dwT0MipLevels = 1;
        }
        else
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex0ActMaxLevel = dwT0MipLevels;

            dwT0MipLevels = pTexture0->iMipLevels - dwT0MipLevels;
        }
    }

    if( pContext->bTex1Valid )
    {
        ASSERTDD ( pContext->bTex0Valid, 
                   "** _D3DChangeTextureP3RX: tex1 should not be used "
                   "unless tex0 is used as well" );

        dwT1MipLevels = pContext->TextureStageState[1].m_dwVal[D3DTSS_MAXMIPLEVEL];
#if DX7_TEXMANAGEMENT        
        if ( dwT1MipLevels < pTexture1->m_dwTexLOD)
        {
            dwT1MipLevels = pTexture1->m_dwTexLOD;
        }
#endif // DX7_TEXMANAGEMENT        
        if (dwT1MipLevels > ((DWORD)(pTexture1->iMipLevels - 1))) 
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex1ActMaxLevel = pTexture1->iMipLevels - 1;

            dwT1MipLevels = 1;
        }
        else
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex1ActMaxLevel = dwT1MipLevels;

            dwT1MipLevels = pTexture1->iMipLevels - dwT1MipLevels;
        }

        // Enable generation of the second set of texture coordinates.
        // Strictly, we should check whether texture 0 is being used, and
        // if not move the second texture to the first (thus enabling 
        // mipmapping, etc) but that's for later.
        pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareQ = 1;
    }
    else
    {
        // Turn off generation of the second set of texture coordinates
        pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareQ = 0;
    }

    if( bBothTexturesValid )
    {
        float totBases, baseRatio;
        DWORD t0Count, res;

        totBases = (float)dwT0MipLevels + dwT1MipLevels;

        // Adjust mip levels to fit in N - 2 slots as each texture
        // needs at least one slot.

        baseRatio = ( P3_TEX_MAP_MAX_LEVEL - 1 ) / totBases;

        // Calculate number of slots for texture 0, texture 1 then
        // gets the remainder.

        myFtoi( &res, dwT0MipLevels * baseRatio );
        t0Count = 1 + res;

        ASSERTDD( t0Count > 0, "No slots for texture 0" );
        ASSERTDD( t0Count <= P3_TEX_MAP_MAX_LEVEL, "No slots for texture 1" );

#define FIXED_ALLOC 0
#if FIXED_ALLOC
        mipBases.dwTex0MipBase = 0;
        mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, 7 );
        mipBases.dwTex1MipBase = 8;
        mipBases.dwTex1MipMax  = 8 + min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL - 8 );
#else
        mipBases.dwTex0MipBase = 0;
        mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, t0Count - 1 );
        mipBases.dwTex1MipBase = t0Count;
        mipBases.dwTex1MipMax  = t0Count + min( dwT1MipLevels - 1, 
                                                P3_TEX_MAP_MAX_LEVEL - t0Count );
#endif
    }
    else
    {
        if( pContext->bTex0Valid )
        {
            mipBases.dwTex0MipBase = 0;
            mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
            mipBases.dwTex1MipBase = 0;
            mipBases.dwTex1MipMax  = min( dwT0MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
        }

        if( pContext->bTex1Valid )
        {
            mipBases.dwTex0MipBase = 0;
            mipBases.dwTex0MipMax  = min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
            mipBases.dwTex1MipBase = 0;
            mipBases.dwTex1MipMax  = min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
        }
    }

    DISPDBG(( DBGLVL, "tex0 base %d", mipBases.dwTex0MipBase ));
    DISPDBG(( DBGLVL, "tex0 max  %d", mipBases.dwTex0MipMax ));
    DISPDBG(( DBGLVL, "tex1 base %d", mipBases.dwTex1MipBase ));
    DISPDBG(( DBGLVL, "tex1 max  %d", mipBases.dwTex1MipMax ));

    // Recalculate the LOD biases for per-poly mipmapping
    pContext->MipMapLODBias[TEXSTAGE_0] =
             pow4( pContext->TextureStageState[TEXSTAGE_0].
                                                m_fVal[D3DTSS_MIPMAPLODBIAS] );

    pContext->MipMapLODBias[TEXSTAGE_1] = 
             pow4( pContext->TextureStageState[TEXSTAGE_1].
                                                m_fVal[D3DTSS_MIPMAPLODBIAS] );

    if ( pTexture0 != NULL )
    {
        __TXT_SetupTexture ( pThisDisplay, 
                             0, 
                             pContext->iTexStage[0], 
                             pContext, 
                             pTexture0, 
                             pSoftP3RX, 
                             bBothTexturesValid, 
                             &mipBases);
    }
    
    if ( pTexture1 != NULL )
    {
        __TXT_SetupTexture ( pThisDisplay, 
                             1, 
                             pContext->iTexStage[1], 
                             pContext, 
                             pTexture1, 
                             pSoftP3RX, 
                             bBothTexturesValid, 
                             &mipBases);

#if DX7_PALETTETEXTURE
        if (GET_BLEND_ERROR(pContext) == BSF_TOO_MANY_PALETTES)
        {
            if (pTexture0 && 
                (pTexture0->dwPaletteHandle == pTexture1->dwPaletteHandle)) 
            {
                RESET_BLEND_ERROR(pContext);
            }
        }
#endif
    }

    // Fix up the D3DRENDERSTATE_MODULATE case.
    if( pTexture0 != NULL )
    {
        if( pContext->Flags & SURFACE_MODULATE )
        {
            // If SURFACE_MODULATE is set then we must have seen a 
            // DX5-style texture blend
            // Note : bAlpha is true for CI8 and CI4 textures

            BOOL bSelectArg1 = pTexture0->pFormatSurface->bAlpha;

#if DX7_PALETTETEXTURE
            if( pTexture0->pixFmt.dwFlags & DDPF_PALETTEINDEXED8 )
            {
                bSelectArg1 = pTexture0->dwPaletteFlags & DDRAWIPAL_ALPHA;
            }
#endif            

            if( bSelectArg1 )
            {
                TSSTATE( pContext->iChipStage[0], D3DTSS_ALPHAOP ) = 
                                                            D3DTOP_SELECTARG1;
            }
            else
            {
                TSSTATE( pContext->iChipStage[0], D3DTSS_ALPHAOP ) = 
                                                            D3DTOP_SELECTARG2;
            }
        }
    }

    P3_DMA_GET_BUFFER();

    // Textures set up - now do the blending.

    // These might be overidden later for special blends.
    dwTexAppTfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];
    dwTexComp0Tfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];
    dwTexComp1Tfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];

    // Detect the stage 0 & 1 bumpmap setup code.
    if (( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) != 0 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_TEXTUREMAP ) != 0 ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) != D3DTOP_DISABLE ) )
    {
        // Looking good for a bumpmap. Now find various special cases.
        // First of all, do they want anything in the stage 2 current colour?
        if (
            ( ( ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG1 ) != D3DTA_CURRENT ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG2 ) != D3DTA_CURRENT ) ) ||
              ( ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG1 ) != D3DTA_CURRENT ) ) ||
              ( ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2 ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG2 ) != D3DTA_CURRENT ) ) ) &&

              ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_DOTPRODUCT3 ) &&
              ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) != D3DTOP_DOTPRODUCT3 ) )
        {
            // Nope - they don't care what the current colour channel is, and
            // no dotproducts are used in stages 0 and 1 (they affect the alpha 
            // channel) so ignore what is in the colour channel - this is a 
            // bumpmap so far.

            // Now see if they want a bumpmap or an inverted bumpmap. People 
            // are so fussy.
            
            // Check first stage.
            if (( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) ) ||
                  ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) ) ) &&
                ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) )
            {
                // First stage fine and not inverted. Check second stage.
                if (( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) )
                {
                    // Fine, not inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = FALSE;
                }
                else if (
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) ) )
                {
                    // Fine, inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = TRUE;
                }
                else
                {
                    // Nope, second stage is no good.
                    pContext->bBumpmapEnabled = FALSE;
                    pContext->bBumpmapInverted = FALSE;
                }
            }
            else if (
                ( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) ) ||
                  ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) ) ) &&
                ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) )
            {
                // First stage fine and inverted. Check second stage.
                if (( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) )
                {
                    // Fine, inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = TRUE;
                }
                else if (
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) ) )
                {
                    // Fine, not inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = FALSE;
                }
                else
                {
                    // Nope, second stage is no good.
                    pContext->bBumpmapEnabled = FALSE;
                    pContext->bBumpmapInverted = FALSE;
                }
            }
            else
            {
                // Nope, first stage is no good.
                pContext->bBumpmapEnabled = FALSE;
                pContext->bBumpmapInverted = FALSE;
            }
        }
        else
        {
            // Could do some more checking, e.g. is all they want in the current colour
            // channel easily available from a single input, e.g. tex0.c, in which case
            // that's fine. A non-bumpmap variant also needs to sense that the first
            // stage is simply a selectarg1/2 and thus can ignore the first stage as
            // a texcomp stage.
            // But that's for later.
            pContext->bBumpmapEnabled = FALSE;
            pContext->bBumpmapInverted = FALSE;
        }

    }
    else
    {
        pContext->bBumpmapEnabled = FALSE;
        pContext->bBumpmapInverted = FALSE;
    }

    if ( pContext->bBumpmapEnabled )
    {
        DISPDBG((DBGLVL,"Enabling emboss bumpmapping"));
        // Remap stages 1 & 2 out of existence.
        pContext->iChipStage[0] = TEXSTAGE_2;
        pContext->iChipStage[1] = TEXSTAGE_3;
        pContext->iChipStage[2] = TEXSTAGE_4;
        pContext->iChipStage[3] = TEXSTAGE_5;
    }
    else
    {
        // Normal mapping.
        pContext->iChipStage[0] = TEXSTAGE_0;
        pContext->iChipStage[1] = TEXSTAGE_1;
        pContext->iChipStage[2] = TEXSTAGE_2;
        pContext->iChipStage[3] = TEXSTAGE_3;
    }

    iLastChipStage = 0;
    // Set these flags to FALSE as the stages are processed.
    bProcessChipStage0 = TRUE;
    bProcessChipStage1 = TRUE;
    bProcessChipStage2 = TRUE;

    // Turn on the basic enables.
    pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
//  pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKd = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.MotionCompEnable = __PERMEDIA_DISABLE;


    // Handle chip stage 0.

    // Detect the very special-case glossmap+bumpmap code. There is no easy way
    // to generalise it, so the whole chunk gets checked here.
    if ( bProcessChipStage0 && bProcessChipStage1 && bProcessChipStage2 && pContext->bTex0Valid && pContext->bTex1Valid &&
        // Colour channel of stage 0 can be whatever you want.
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_MODULATEALPHA_ADDCOLOR ) &&  // Early-out test - nothing uses this!
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_DIFFUSE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
        ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLOROP ) == D3DTOP_MODULATE2X ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLORARG2 ) == (D3DTA_CURRENT | D3DTA_ALPHAREPLICATE) ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_ALPHAARG1 ) == D3DTA_TFACTOR ) &&
        ( TSSTATE ( TEXSTAGE_4, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) &&
        ( pContext->iStageTex[0] == 0 ) &&
        ( pContext->iStageTex[1] == 1 ) &&
        ( pContext->iStageTex[2] == 0 )
        )
    {
        int iMode;
        // OK, looks good. Check which way round the bumpmapping is being done.
        if (( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
            ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == (D3DTA_CURRENT | D3DTA_COMPLEMENT) ) )
        {
            // Standard emboss.
            iMode = 0;
        }
        else if (( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) &&
                 ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) )
        {
            // Inverted emboss.
            iMode = 1;
        }
        else
        {
            // No good - can't do it.
            iMode = -1;
        }

        if ( iMode == -1 )
        {
            // Nope.
            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
            iLastChipStage = 3;
        }
        else
        {
            // Set up the colour channel of tc0.
            // Alpha channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[0], 
                                           pSoftP3RX, 
                                           0, 
                                           0);

            // Pass through bump.a, maybe inverted.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
            if ( iMode )
            {
                // Inverted bumpmap.
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
            }
            else
            {
                // Non-inverted bumpmap.
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            }
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;

            // Do tex1.c * diff.a + current.c
            pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Arg1 = P3RX_TEXCOMP_T1C;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_OC;
            pSoftP3RX->P3RXTextureCompositeColorMode1.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeColorMode1.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeColorMode1.B = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertI = __PERMEDIA_DISABLE;

            // Pass through bump.a again.
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg1 = P3RX_TEXCOMP_OA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.B = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertI = __PERMEDIA_DISABLE;

            // Do current.c * current.a, by doing B*I+A. A=black, B=current.c, I=current.a
            pSoftP3RX->P3RXTextureApplicationMode.ColorA = P3RX_TEXAPP_A_KC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorI = P3RX_TEXAPP_I_TA;
            pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A;
            // Set the colour channel to black (allow the alpha channel to be preserved).
            dwTexAppTfactor &= 0xff000000;

            // Alpha channel selects the constant color.
            pSoftP3RX->P3RXTextureApplicationMode.AlphaA = P3RX_TEXAPP_A_KA;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_KA;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            
            // Do *2 in alpha-blend unit.
            bAlphaBlendDouble = TRUE;

            // We don't actually need the remap (and it doesn't mean much),
            // but it stops erroneous errors being flagged.
            pContext->iChipStage[0] = TEXSTAGE_0;
            pContext->iChipStage[1] = TEXSTAGE_1;
            pContext->iChipStage[2] = TEXSTAGE_3;
            pContext->iChipStage[3] = TEXSTAGE_4;

            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
            iLastChipStage = 3;
        }
    }



    // Detect the special-case 3-blend-unit bumpmapping mode.
    // Third stage will be set up by the standard routines - only the first
    // two are special-cased and shoehorned into TexComp0.
    if ( bProcessChipStage0 && !pContext->bBumpmapEnabled && pContext->bTex0Valid && pContext->bTex1Valid &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_MODULATE ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_DIFFUSE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&

        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        // ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == D3DTA_DIFFUSE ) dont care && 

        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
        (
          ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
            ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
          ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
            ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) )
        ) )
    {
        // Yep, looks good. Set it up.
        ASSERTDD ( pContext->iTexStage[0] == 0, "** _D3DChangeTextureP3RX: textures not correct for special bumpmapping" );
        ASSERTDD ( pContext->iTexStage[1] == 1, "** _D3DChangeTextureP3RX: textures not correct for special bumpmapping" );

        pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_T0C;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_CC;
        pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_CA;
        pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
        pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;

        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;

        if ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
             ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) )
        {
            // Inverted bumpmap.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
        }
        else
        {
            // Normal bumpmap.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
        }

        // Done chip stage 0, TSS stage 0 & 1. Move chip stage 1 on a notch.
        pContext->iChipStage[0] = TEXSTAGE_0;
        pContext->iChipStage[1] = TEXSTAGE_2;
        pContext->iChipStage[2] = TEXSTAGE_3;
        pContext->iChipStage[3] = TEXSTAGE_4;
        iLastChipStage = 1;
        bProcessChipStage0 = FALSE;
    }

    // Detect a chipstage 0 MODULATE+ADD concatenation. Used by lightmaps.
    // This compresses two stages into texcomp0. The alpha channel has
    // two modes - either one of the two stages just does a selectarg1 (current),
    // and the other gets set up as normal, or (for specular stuff) they
    // both do ADDSIGNED (cur, cur), in which case it's special-cased.
    if ( bProcessChipStage0 && pContext->bBumpmapEnabled &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) == D3DTOP_MODULATE ) &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLORARG1 ) == ( D3DTA_CURRENT | D3DTA_ALPHAREPLICATE ) ) &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLORARG2 ) == D3DTA_DIFFUSE ) &&
        ( ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_ADD ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) ) ||
          ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) ) ) )
    {
        // Colour channel is correct and can be squashed down to one stage.
        // Check that the alpha channel is OK.
        int bOK;
        if (( ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
              ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) ||
            ( ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
              ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) )
        {
            // Stage 0 is set to pass-through - set up texcomp0 as stage 1.
            // Colour channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[pContext->iChipStage[1]], 
                                           pSoftP3RX, 
                                           pContext->iChipStage[1], 
                                           0);
            bOK = TRUE;
        }
        else if (( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                   ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) ||
                 ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                   ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) )
        {
            // Stage 1 is set to pass-through - set up texcomp0 as stage 0.
            // Colour channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[pContext->iChipStage[0]], 
                                           pSoftP3RX, 
                                           pContext->iChipStage[0], 
                                           0);
            bOK = TRUE;
        }
        else if (( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
                 ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) )
        {
            // Set up to do ( 4 * cur.a - 1.5 ), or rather 4 * ( cur.a - 0.375 )
            dwTexComp0Tfactor = 0x60606060;     // All channels set to (0.375)
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_SUBTRACT_AB;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_FOUR;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_FA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
            if ( pContext->bBumpmapInverted )
            {
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            }
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;
            bOK = TRUE;
        }
        else
        {
            bOK = FALSE;
        }

        if ( bOK )
        {
            // OK, the alpha channel is fine - set up the colour channel now.
            pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
            if ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_ADD )
            {
                // Yes, this is the ((diff.c*cur.a)+tex.c) case.
                pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_CC;
                if ( pContext->iStageTex[pContext->iChipStage[1]] == 0 )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_T0C;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_T1C;
                }
                pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_HA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
                pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
                if ( pContext->bBumpmapInverted )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_ENABLE;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;
                }
            }
            else
            {
                // Yes, this is just the (diff.c*cur.a) case.
                pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_CC;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_HEIGHTA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_OA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
                pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
                if ( pContext->bBumpmapInverted )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_ENABLE;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;
                }
            }

            // Done chip stage 0, TSS stage 0 & 1. Move chip stage 1 on a notch.
            pContext->iChipStage[1]++;
            pContext->iChipStage[2]++;
            pContext->iChipStage[3]++;
            iLastChipStage = 1;
            bProcessChipStage0 = FALSE;
        }
    }


    if ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage0 = FALSE;
        bProcessChipStage1 = FALSE;
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[0]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
        }
    }

    if ( bProcessChipStage0 )
    {
        // Set up stage 0
        DISPDBG((DBGLVL,"Texture Stage 0 is valid - setting it up"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[0]], 
                                       pSoftP3RX, 
                                       pContext->iChipStage[0], 
                                       0);
        iLastChipStage = 1;
        bProcessChipStage0 = FALSE;
    }


    // Handle chip stage 1.


    if ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage1 = FALSE;
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[1]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
        }
    }


    if ( bProcessChipStage1 )
    {
        // Set up stage 1
        DISPDBG((DBGLVL,"Texture Stage 1 is valid - setting it up"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[1]],
                                       pSoftP3RX, 
                                       pContext->iChipStage[1], 
                                       1);

        iLastChipStage = 2;
        bProcessChipStage1 = FALSE;
    }



    // Handle chip stage 2.


    if ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[2]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage2 = FALSE;
        }
    }

    if ( bProcessChipStage2 )
    {
        // Set up chip stage 2 - texapp.
        DISPDBG((DBGLVL,"Texture Stage 2 is valid - setting it up"));
        DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Cool - an app is using the "
                     "TexApp unit - tell someone!"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[2]],
                                       pSoftP3RX, 
                                       pContext->iChipStage[2], 
                                       2);
        iLastChipStage = 3;
        bProcessChipStage2 = FALSE;
    }

    // This must be last.
    if ( TSSTATE ( pContext->iChipStage[3], D3DTSS_COLOROP ) != D3DTOP_DISABLE )
    {
        // Oops - ran out of stages to set up.
        SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
        iLastChipStage = 3;
    }

    switch ( iLastChipStage )
    {
        case 0:
            DISPDBG((DBGLVL,"Texture Composite 0 is disabled"));
            // This should have been caught ages ago.
            pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_CC;
            pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
            
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            // fall through
        case 1:
            DISPDBG((DBGLVL,"Texture Composite 1 is disabled"));
            // Make sure the second stage passes the texel that the first stage generated
            if ( pContext->bStage0DotProduct )
            {
                // First stage was a dot-product - do the summing (even in the alpha channel).
                pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_SUM;
                pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_SUM;
            }
            else
            {
                pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_OC;
                pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_OA;
            }
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_ENABLE;
            
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_ENABLE;
            // fall through
        case 2:
            // Texapp to passthrough.
            DISPDBG((DBGLVL,"Texture Application is disabled"));
            pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = __PERMEDIA_DISABLE;

            pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = __PERMEDIA_DISABLE;
            // fall through
        case 3:
            // Nothing else in the pipeline to disable.
            // fall through
            break;
        default:
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: iLastChipStage was > 3 - oops."));
            break;
    }


    // Set up the alpha-map filtering to reflect the single/multi/mip-mapped texturing status
    // All the other colour-key stuff has already been set up.
    if( pContext->bCanChromaKey )
    {
        ASSERTDD ( pTexture0 != NULL, "** _D3DChangeTextureP3RX: pTexture was NULL" );
        if( pTexture0->bMipMap )
        {
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 4;
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 4;
            if ( pContext->bTex0Valid )
            {
                // Filter mode is irrelevant - this just works!
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit01 = 7;
            }
            else
            {
                DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Trying to mipmap without a valid texture."));
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit01 = 8;
            }
            ASSERTDD ( !pContext->bTex1Valid, "** _D3DChangeTextureP3RX: Trying to mipmap with too many textures." );
        }
        else
        {
            // No mipmapping.
            if ( pContext->bTex0Valid )
            {
                // Don't care about filter mode - this just works.
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 7;
            }
            else
            {
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 4;
            }
            if ( pContext->bTex1Valid )
            {
                // Don't care about filter mode - this just works.
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 7;
            }
            else
            {
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 4;
            }
        }
    }

    // Enable Texture Address calculation
    pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_ENABLE;

    // Enable filtering
    pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_ENABLE;

//  // Enable Texel color generation
//  pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;

    // Do we need to share the texture coordinates ?
    if ( pContext->bTex0Valid && pContext->bTex1Valid &&
        ( TSSTATE ( pContext->iTexStage[0], D3DTSS_TEXCOORDINDEX ) ==
          TSSTATE ( pContext->iTexStage[1], D3DTSS_TEXCOORDINDEX ) ) )
    {
        pSoftP3RX->P3RX_P3DeltaControl.ShareS = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareT = __PERMEDIA_ENABLE;
    }
    else
    {
        pSoftP3RX->P3RX_P3DeltaControl.ShareS = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareT = __PERMEDIA_DISABLE;
    }

    P3_ENSURE_DX_SPACE((P3_LOD_LEVELS*2));
    WAIT_FIFO((P3_LOD_LEVELS*2));
    for (i = 0; i < P3_LOD_LEVELS; i++)
    {
        COPY_P3_DATA_OFFSET(TextureMapWidth0, pSoftP3RX->P3RXTextureMapWidth[i], i);
    }

    if ( ( GET_BLEND_ERROR(pContext) & BLEND_STATUS_FATAL_FLAG ) != 0 )
    {
        // Got a fatal blend error - signal it to the user.

        DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: invalid blend mode"));
        
        _D3DDisplayWholeTSSPipe ( pContext, WRNLVL );

        // And make sure this is re-evaluated next time we render,
        // so that this (probably very munged) invalid setup doesn't cripple
        // any subsequent valid renderstates.
        DIRTY_EVERYTHING(pContext);
    }


    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_ENABLE);
    COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

    COPY_P3_DATA(TextureApplicationMode, pSoftP3RX->P3RXTextureApplicationMode);
    COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);

    // Copy the current TFACTOR values.
    SEND_P3_DATA ( TextureEnvColor, FORMAT_8888_32BIT_BGR(dwTexAppTfactor) );
    SEND_P3_DATA ( TextureCompositeFactor0, FORMAT_8888_32BIT_BGR(dwTexComp0Tfactor) );
    SEND_P3_DATA ( TextureCompositeFactor1, FORMAT_8888_32BIT_BGR(dwTexComp1Tfactor) );
    DISPDBG((DBGLVL,"Current TFACTOR values. %x %x %x",
                    dwTexAppTfactor,
                    dwTexComp0Tfactor,
                    dwTexComp1Tfactor));

    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    COPY_P3_DATA(TextureCompositeColorMode0, pSoftP3RX->P3RXTextureCompositeColorMode0);
    COPY_P3_DATA(TextureCompositeColorMode1, pSoftP3RX->P3RXTextureCompositeColorMode1);
    COPY_P3_DATA(TextureCompositeAlphaMode0, pSoftP3RX->P3RXTextureCompositeAlphaMode0);
    COPY_P3_DATA(TextureCompositeAlphaMode1, pSoftP3RX->P3RXTextureCompositeAlphaMode1);

    COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
    COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

    COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
    COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);

    // Make sure the texture cache is invalidated
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_DISABLE);
    
    SEND_P3_DATA(LOD, 0);
    SEND_P3_DATA(LOD1, 0);

    {
        struct LodRange range;

        // Clear down whole register

        *(DWORD *)&range = 0;

        // Each of the Min and Max LODs are in 4.8 format. We only deal 
        // with integer LODs in the range (0, N) so we just compute the 
        // upper value N and shift it up 8 bits.

        range.Min = 0;
        range.Max = ( mipBases.dwTex0MipMax - mipBases.dwTex0MipBase ) << 8;
        COPY_P3_DATA( LodRange0, range );

        range.Min = 0;
        range.Max = ( mipBases.dwTex1MipMax - mipBases.dwTex1MipBase ) << 8;
        COPY_P3_DATA( LodRange1, range );
    }

    *pFlags |= SURFACE_TEXTURING;

    // Turn texturing on in the render command
    RENDER_TEXTURE_ENABLE(pContext->RenderCommand);
 
    P3_DMA_COMMIT_BUFFER();

    // See if the alpha-blend unit needs to be updated.
    if ( bAlphaBlendDouble != pContext->bAlphaBlendMustDoubleSourceColour )
    {
        pContext->bAlphaBlendMustDoubleSourceColour = bAlphaBlendDouble;
        DIRTY_ALPHABLEND(pContext);
    }

    DBG_EXIT(_D3DChangeTextureP3RX,0);  
    
} // _D3DChangeTextureP3RX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstrct.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstrct.h
*
* Content: Internal D3D structure management headers and macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __D3DSTRCT_H
#define __D3DSTRCT_H

//-----------------------------------------------------------------------------
//
// Array functions and structures
//
//-----------------------------------------------------------------------------

typedef void (*PA_DestroyCB)(struct tagPointerArray* pTable, 
                             void* pData, 
                             void* pExtra);

typedef struct tagPointerArray
{
    ULONG_PTR* pPointers;
    DWORD dwNumPointers;
    PA_DestroyCB pfnDestroyCallback;
} PointerArray;

PointerArray* PA_CreateArray();
BOOL PA_DestroyArray(PointerArray* pArray, VOID* pExtra);
void* PA_GetEntry(PointerArray* pArray, DWORD dwNum);
BOOL PA_SetEntry(PointerArray* pArray, DWORD dwNum, void* pData);
void PA_SetDataDestroyCallback(PointerArray* pArray,
                               PA_DestroyCB DestroyCallback);

//-----------------------------------------------------------------------------
//
// Hashing functions and structures
//
//-----------------------------------------------------------------------------

#define HASH_SIZE 4096      // this many entries in the hash table

#define HT_HASH_OF(i)    ((i) & 0xFFF)

typedef struct tagHashSlot
{
    void* pData;
    ULONG_PTR dwHandle;

    struct tagHashSlot* pNext;
    struct tagHashSlot* pPrev;

} HashSlot;

typedef void (*DataDestroyCB)(struct tagHashTable* pTable, 
                              void* pData, 
                              void*pExtra);

typedef struct tagHashTable
{
    HashSlot* Slots[HASH_SIZE];
    DataDestroyCB pfnDestroyCallback;
} HashTable;

// Helper functions
static __inline HashSlot* HT_GetSlotFromHandle(HashTable* pTable, 
                                               ULONG_PTR dwHandle)
{
    HashSlot* pBase = NULL; 
    
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pBase = pTable->Slots[HT_HASH_OF(dwHandle)];

    while (pBase != NULL)
    {
        if (pBase->dwHandle == dwHandle)
            return pBase;
        pBase = pBase->pNext;
    }

    return NULL;
} // HT_GetSlotFromHandle

static __inline void* HT_GetEntry(HashTable* pTable, ULONG_PTR dwHandle)
{
    HashSlot* pEntry = HT_GetSlotFromHandle(pTable, dwHandle);

    if (pEntry)
    {
        return pEntry->pData;
    }
    return NULL;
} /// HT_GetEntry


// Public interfaces
HashTable* HT_CreateHashTable();
void HT_ClearEntriesHashTable(HashTable* pHashTable, VOID* pExtra);
void HT_DestroyHashTable(HashTable* pHashTable, VOID* pExtra);
void HT_SetDataDestroyCallback(HashTable* pTable, 
                               DataDestroyCB DestroyCallback);
BOOL HT_SwapEntries(HashTable* pTable, DWORD dwHandle1, DWORD dwHandle2);
BOOL HT_AddEntry(HashTable* pTable, ULONG_PTR dwHandle, void* pData);
BOOL HT_RemoveEntry(HashTable* pTable, ULONG_PTR dwHandle, VOID* pExtra);

#endif // __D3DSTRCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxman.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.c
*
* Content:  D3D Texture cache manager
*
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#include "glint.h"
#include "dma.h"

#if DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
// The driver can optionally manage textures which have been marked as 
// manageable. These DirectDraw surfaces are marked as manageable with the 
// DDSCAPS2_TEXTUREMANAGE flag in the dwCaps2 field of the structure refered to 
// by lpSurfMore->ddCapsEx.
//
// The driver makes explicit its support for driver-managed textures by setting 
// DDCAPS2_CANMANAGETEXTURE in the dwCaps2 field of the DD_HALINFO structure. 
// DD_HALINFO is returned in response to the initialization of the DirectDraw 
// component of the driver, DrvGetDirectDrawInfo.
//
// The driver can then create the necessary surfaces in video or non-local 
// memory in a lazy fashion. That is, the driver leaves them in system memory 
// until it requires them, which is just before rasterizing a primitive that 
// makes use of the texture.
//
// Surfaces should be evicted primarily by their priority assignment. The driver 
// should respond to the D3DDP2OP_SETPRIORITY token in the D3dDrawPrimitives2 
// command stream, which sets the priority for a given surface. As a secondary 
// measure, it is expected that the driver will use a least recently used (LRU) 
// scheme. This scheme should be used as a tie breaker, whenever the priority of 
// two or more textures is identical in a particular scenario. Logically, any 
// surface that is in use shouldn't be evicted at all.
//
// The driver must be cautious of honoring DdBlt calls and DdLock calls when 
// managing textures. This is because any change to the system memory image of 
// the surface must be propagated into the video memory copy of it before the 
// texture is used again. The driver should determine if it is better to update 
// just a portion of the surface or all of it.
// 
// The driver is allowed to perform texture management in order to perform 
// optimization transformations on the textures or to decide for itself where 
// and when to transfer textures in memory.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Porting to your hardware/driver
//
// The following structures/functions/symbols are specific to this 
// implementation. You should supply your own if needed:
//
//     P3_SURF_INTERNAL
//     P3_D3DCONTEXT
//     DISPDBG
//     HEAP_ALLOC ALLOC_TAG_DX
//     _D3D_TM_HW_FreeVidmemSurface
//     _D3D_TM_HW_AllocVidmemSurface
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Global texture management object and ref count
//-----------------------------------------------------------------------------
DWORD g_TMCount = 0;
TextureCacheManager g_TextureManager;

//-----------------------------------------------------------------------------
// Macros and definitions
//-----------------------------------------------------------------------------
// Number of pointers to DX surfaces for first allocated heap
#define TM_INIT_HEAP_SIZE  1024
// Subsequent increments
#define TM_GROW_HEAP_SIZE(n)  ((n)*2)

// Access to binary-tree structure in the heap. The heap is really just a
// linear array of pointers (to P3_SURF_INTERNAL structures) which is
// accessed as if it were a binary tree: m_data_p[1] is the root of the tree
// and the its immediate children are [2] and [3]. The children/parents of 
// element are uniquely defined by the below macros.
#define parent(k) ((k) / 2)
#define lchild(k) ((k) * 2)
#define rchild(k) ((k) * 2 + 1)

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapFindSlot
//
// Starting at element k in the TM heap, search the heap (towards the root node)
// for an element whose parent is cheaper than llCost. Return the value of it.
//
// An important difference between __TM_TextureHeapFindSlot and
// __TM_TextureHeapHeapify is that the former searches upwards in the tree
// whereas the latter searches downwards through the tree.
//
//-----------------------------------------------------------------------------
DWORD
__TM_TextureHeapFindSlot(
    PTextureHeap pTextureHeap, 
    ULONGLONG llCost,
    DWORD k)
{
    // Starting with element k, traverse the (binary-tree) heap upwards until 
    // you find an element whose parent is less expensive (cost-wise) 
    // than llCost . (Short circuited && expression below!)
    while( (k > 1) &&
           (llCost < TextureCost(pTextureHeap->m_data_p[parent(k)])) )
    {
        // Slot k is assumed to be empty. So since we are looking for
        // slot where to put things, we need to move downwards the
        // parent slot before we go on in order for the new k to be 
        // available
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k; // update surf reference
        k = parent(k);                                // look now at parent
    }

    return k;
} // __TM_TextureHeapFindSlot

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapHeapify
//
// Starting at element k in the TM heap, make sure the heap is well-ordered
// (parents are always lower cost than their children). This algorithm assumes
// the heap is well ordered with the possible exception of element k
//
//-----------------------------------------------------------------------------
void 
__TM_TextureHeapHeapify(
    PTextureHeap pTextureHeap, 
    DWORD k)
{
    while(TRUE) 
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);

        // Figure out who has the smallest TextureCost, either k,l or r.
        if(l < pTextureHeap->m_next)
        {
            if(TextureCost(pTextureHeap->m_data_p[l]) <
               TextureCost(pTextureHeap->m_data_p[k]))
            {
                smallest = l;
            }
            else
            {
                smallest = k;
            }
        }
        else
        {
            smallest = k;
        }
        
        if(r < pTextureHeap->m_next)
        {
            if(TextureCost(pTextureHeap->m_data_p[r]) <
               TextureCost(pTextureHeap->m_data_p[smallest]))
            {
                smallest = r;
            }
        }
        
        if(smallest != k) 
        {
            // it wasn't k. So now swap k with the smallest of the three
            // and repeat the loop in order with the new position of k 
            // in order to keep the order right (parents are always lower 
            // cost than children)
            P3_SURF_INTERNAL* ptempD3DSurf = pTextureHeap->m_data_p[k];
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[smallest];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            pTextureHeap->m_data_p[smallest] = ptempD3DSurf;
            ptempD3DSurf->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
        {
            // it was k, so the order is now all right, leave here
            break;
        }
    }
} // __TM_TextureHeapHeapify

//-----------------------------------------------------------------------------
//
// BOOL __TM_TextureHeapAddSurface
//
// Add a DX surface to a texture management heap. 
// Returns success or failure status
//
//-----------------------------------------------------------------------------
BOOL 
__TM_TextureHeapAddSurface(
    PTextureHeap pTextureHeap, 
    P3_SURF_INTERNAL* pD3DSurf)
{
    P3_SURF_INTERNAL* *ppD3DSurf;
    ULONGLONG llCost;
    DWORD k;

    if(pTextureHeap->m_next == pTextureHeap->m_size) 
    {   
        // Heap is full, we must grow it
        DWORD dwNewSize = TM_GROW_HEAP_SIZE(pTextureHeap->m_size);

        ppD3DSurf = (P3_SURF_INTERNAL* *)
                          HEAP_ALLOC( FL_ZERO_MEMORY, 
                                       sizeof(P3_SURF_INTERNAL*) * dwNewSize,
                                       ALLOC_TAG_DX(B));
        if(ppD3DSurf == 0)
        {
            DISPDBG((ERRLVL,"Failed to allocate memory to grow heap."));
            return FALSE;
        }

        // Transfer data 
        memcpy(ppD3DSurf + 1, pTextureHeap->m_data_p + 1, 
            sizeof(P3_SURF_INTERNAL*) * (pTextureHeap->m_next - 1));

        // Free previous heap
        HEAP_FREE( pTextureHeap->m_data_p);
        
        // Update texture heap structure    
        pTextureHeap->m_size = dwNewSize;
        pTextureHeap->m_data_p = ppD3DSurf;
    }

    // Get the cost of the surface we are about to add
    llCost = TextureCost(pD3DSurf);

    // Starting at the last element in the heap (where we can theoretically
    // place our new element) search upwards for an appropriate place to put 
    // it in. This will also maintain our tree/heap balanced 
    k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, pTextureHeap->m_next);

    // Add the new surface to the heap in the [k] place
    pTextureHeap->m_data_p[k] = pD3DSurf;
    ++pTextureHeap->m_next;    

    //Update the surface's reference to its place on the heap
    pD3DSurf->m_dwHeapIndex = k;
    
    return TRUE;
    
} // __TM_TextureHeapAddSurface

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapDelSurface
//
// Delete the k element from the TM heap
//
//-----------------------------------------------------------------------------
void __TM_TextureHeapDelSurface(PTextureHeap pTextureHeap, DWORD k)
{
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[k];
    ULONGLONG llCost;

    // (virtually) delete the heaps last element and get its cost
    --pTextureHeap->m_next;
    llCost = TextureCost(pTextureHeap->m_data_p[pTextureHeap->m_next]);
    
    if(llCost < TextureCost(pD3DSurf))
    {
        // If the cost of the last element is less than that of the surface
        // we are really trying to delete (k), look for a new place where
        // to put the m_next element based on its cost.
    
        // Starting at the k element in the heap (where we can theoretically
        // place our new element) search upwards for an appropriate place to 
        // put it in
        k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, k);

        // Overwrite the data of k with the data of the last element
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        // If the cost of the last element is greather than that of the surface
        // we are really trying to delete (k), replace (k) by (m_next)
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;

        // Now make sure we keep the heap correctly ordered        
        __TM_TextureHeapHeapify(pTextureHeap,k);
    }
    
    pD3DSurf->m_dwHeapIndex = 0;
    
} // __TM_TextureHeapDelSurface


//-----------------------------------------------------------------------------
//
// P3_SURF_INTERNAL* __TM_TextureHeapExtractMin
//
// Extract
//
//-----------------------------------------------------------------------------
P3_SURF_INTERNAL* 
__TM_TextureHeapExtractMin(
    PTextureHeap pTextureHeap)
{
    // Obtaint pointer to surface we are extracting from the heap
    // (the root node, which is the least expensive element of the
    // whole heap because of the way we build the heap).
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[1];

    // Update heap internal counter and move last 
    // element now to first position.
    --pTextureHeap->m_next;
    pTextureHeap->m_data_p[1] = pTextureHeap->m_data_p[pTextureHeap->m_next];
    pTextureHeap->m_data_p[1]->m_dwHeapIndex = 1;

    // Now make sure we keep the heap correctly ordered
    __TM_TextureHeapHeapify(pTextureHeap,1);

    // Clear the deleted surface's reference to its place on the heap (deleted)
    pD3DSurf->m_dwHeapIndex = 0;
    
    return pD3DSurf;
    
} // __TM_TextureHeapExtractMin

//-----------------------------------------------------------------------------
//
// P3_SURF_INTERNAL* __TM_TextureHeapExtractMax
//
//-----------------------------------------------------------------------------
P3_SURF_INTERNAL* 
__TM_TextureHeapExtractMax(
    PTextureHeap pTextureHeap)
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper. 
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = pTextureHeap->m_next - 1;
    ULONGLONG llMaxCost = 0;
    ULONGLONG llCost;
    unsigned i;
    P3_SURF_INTERNAL* pD3DSurf;

    // Search all the terminal nodes of the binary-tree (heap)
    // for the most expensive element and store its index in max
    for(i = max; lchild(i) >= pTextureHeap->m_next; --i)
    {
        llCost = TextureCost(pTextureHeap->m_data_p[i]);
        if(llMaxCost < llCost)
        {
            llMaxCost = llCost;
            max = i;
        }
    }

    // Return the surface associated to this maximum cost heap element 
    pD3DSurf = pTextureHeap->m_data_p[max];

    // Delete it from the heap ( will automatically maintain heap ordered)
    __TM_TextureHeapDelSurface(pTextureHeap, max);
    
    return pD3DSurf;
    
} // __TM_TextureHeapExtractMax

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapUpdate
//
// Updates the priority & number of of ticks of surface # k in the heap
//
//-----------------------------------------------------------------------------
void 
__TM_TextureHeapUpdate(
    PTextureHeap pTextureHeap, 
    DWORD k,
    DWORD dwPriority, 
    DWORD dwTicks) 
{
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[k];
    ULONGLONG llCost = 0;
#ifdef _X86_
    _asm
    {
        mov     edx, 0;
        shl     edx, 31;
        mov     eax, dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR llCost + 4, edx;
        shl     ecx, 31;
        mov     eax, dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR llCost, eax;
    }
#else
    llCost = ((ULONGLONG)dwPriority << 31) + ((ULONGLONG)(dwTicks >> 1));
#endif
    if(llCost < TextureCost(pD3DSurf))
    {
        // Starting at the k element in the heap (where we can theoretically
        // place our new element) search upwards for an appropriate place 
        // to move it to in order to keep the tree well ordered.
        k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, k);
        
        pD3DSurf->m_dwPriority = dwPriority;
        pD3DSurf->m_dwTicks = dwTicks;
        pD3DSurf->m_dwHeapIndex = k;
        pTextureHeap->m_data_p[k] = pD3DSurf;
    }
    else
    {
        pD3DSurf->m_dwPriority = dwPriority;
        pD3DSurf->m_dwTicks = dwTicks;

        // Now make sure we keep the heap correctly ordered        
        __TM_TextureHeapHeapify(pTextureHeap,k);
    }
}

//-----------------------------------------------------------------------------
//
// BOOL __TM_FreeTextures
//
// Free the LRU texture 
//
//-----------------------------------------------------------------------------
BOOL 
__TM_FreeTextures(
    P3_D3DCONTEXT* pContext,
    DWORD dwBytes)
{
    P3_SURF_INTERNAL* pD3DSurf;
    DWORD k;

    PTextureCacheManager pTextureCacheManager =  pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;    
    
    // No textures left to be freed
    if(pTextureCacheManager->m_heap.m_next <= 1)
        return FALSE;

    // Keep remove textures until we accunulate dwBytes of removed stuff
    // or we have no more surfaces left to be removed.
    for(k = 0; 
        (pTextureCacheManager->m_heap.m_next > 1) && (k < dwBytes); 
        k += pD3DSurf->m_dwBytes)
    {
        // Find the LRU texture (the one with lowest cost) and remove it.
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);

#if DX7_TEXMANAGEMENT_STATS
        // Update stats
        pTextureCacheManager->m_stats.dwLastPri = pD3DSurf->m_dwPriority;
        ++pTextureCacheManager->m_stats.dwNumEvicts;
#endif        
        
        DISPDBG((WRNLVL, "Removed texture with timestamp %u,%u (current = %u).", 
                          pD3DSurf->m_dwPriority, 
                          pD3DSurf->m_dwTicks, 
                          pTextureCacheManager->tcm_ticks));
    }
    
    return TRUE;
    
} // __TM_FreeTextures

//-----------------------------------------------------------------------------
//
// HRESULT __TM_TextureHeapInitialize
//
// Allocate the heap and initialize
//
//-----------------------------------------------------------------------------
HRESULT 
__TM_TextureHeapInitialize(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->m_heap.m_next = 1;
    pTextureCacheManager->m_heap.m_size = TM_INIT_HEAP_SIZE;
    pTextureCacheManager->m_heap.m_data_p = (P3_SURF_INTERNAL* *)
        HEAP_ALLOC( FL_ZERO_MEMORY, 
                     sizeof(P3_SURF_INTERNAL*) * 
                        pTextureCacheManager->m_heap.m_size,
                     ALLOC_TAG_DX(C));
            
    if(pTextureCacheManager->m_heap.m_data_p == 0)
    {
        DISPDBG((ERRLVL,"Failed to allocate texture heap."));
        return E_OUTOFMEMORY;
    }
    
    memset(pTextureCacheManager->m_heap.m_data_p, 
           0, 
           sizeof(P3_SURF_INTERNAL*) * pTextureCacheManager->m_heap.m_size);
        
    return DD_OK;
    
} // __TM_TextureHeapInitialize


//-----------------------------------------------------------------------------
//
// HRESULT _D3D_TM_Ctx_Initialize
//
// Initialize texture management for this context
// Should be called when the context is being created
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_TM_Ctx_Initialize(
    P3_D3DCONTEXT* pContext)
{

    HRESULT hr = DD_OK;
    
    if (0 == g_TMCount)
    {
        // first use - must initialize
        hr = __TM_TextureHeapInitialize(&g_TextureManager);

        // init ticks count for LRU policy
        g_TextureManager.tcm_ticks = 0;
    }

    if (SUCCEEDED(hr))
    {   
        // Initialization succesful or uneccesary.
        // Increment the reference count and make the context 
        // remember where the texture management object is.
        g_TMCount++;
        pContext->pTextureManager = &g_TextureManager;
    }

    return hr;
    
} //  _D3D_TM_Ctx_Initialize

//-----------------------------------------------------------------------------
//
// void _D3D_TM_Ctx_Destroy
//
// Clean up texture management for this context 
// Should be called when the context is being destroyed
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_Ctx_Destroy(    
    P3_D3DCONTEXT* pContext)
{
    // clean up texture manager stuff if it 
    // is already allocated for this context
    if (pContext->pTextureManager)
    {
        // Decrement reference count for the 
        // driver global texture manager object
        g_TMCount--;

        // If necessary, deallocate the texture manager heap;
        if (0 == g_TMCount)
        {
            if (0 != g_TextureManager.m_heap.m_data_p)
            {
                _D3D_TM_EvictAllManagedTextures(pContext);
                HEAP_FREE(g_TextureManager.m_heap.m_data_p);
                g_TextureManager.m_heap.m_data_p = NULL;
            }
        }

        pContext->pTextureManager = NULL;        
    }
} // _D3D_TM_Ctx_Destroy

//-----------------------------------------------------------------------------
//
// HRESULT _D3D_TM_AllocTexture
//
// add a new HW handle and create a surface (for a managed texture) in vidmem
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_TM_AllocTexture(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pTexture)
{
    DWORD trycount = 0, bytecount = pTexture->m_dwBytes;
    PTextureCacheManager pTextureCacheManager = pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;      
    INT iLOD;

    // Decide the largest level to allocate video memory based on what
    // is specified through D3DDP2OP_SETTEXLOD token
    iLOD = pTexture->m_dwTexLOD;
    if (iLOD > (pTexture->iMipLevels - 1))
    {
        iLOD = pTexture->iMipLevels - 1;
    }        

    // Attempt to allocate a texture. (do until the texture is in vidmem)
    while((FLATPTR)NULL == pTexture->MipLevels[iLOD].fpVidMemTM)
    {  
        _D3D_TM_HW_AllocVidmemSurface(pContext, pTexture);
        ++trycount;
                              
        DISPDBG((DBGLVL,"Got fpVidMemTM = %08lx",
                        pTexture->MipLevels[0].fpVidMemTM));

        // We were able to allocate the vidmem surface
        if ((FLATPTR)NULL != pTexture->MipLevels[iLOD].fpVidMemTM)
        {
            // No problem, there is enough memory. 
            pTexture->m_dwTicks = pTextureCacheManager->tcm_ticks;

            // Add texture to manager's heap to track it
            if(!__TM_TextureHeapAddSurface(&pTextureCacheManager->m_heap,
                                           pTexture))
            {          
                // Failed - undo vidmem allocation
                // This call will set all MipLevels[i].fpVidMemTM to NULL
                _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pTexture);                                           
                
                DISPDBG((ERRLVL,"Out of memory"));
                return DDERR_OUTOFMEMORY;
            }

            // Mark surface as needing update from sysmem before use
            pTexture->m_bTMNeedUpdate = TRUE;
            break;
        }
        else
        {
            // we weren't able to allocate the vidmem surface
            // we will now try to free some managed surfaces to make space
            if (!__TM_FreeTextures(pContext, bytecount))
            {
                DISPDBG((ERRLVL,"all Freed no further video memory available"));
                return DDERR_OUTOFVIDEOMEMORY; //nothing left
            }
            
            bytecount <<= 1;
        }
    }

    if(trycount > 1)
    {
        DISPDBG((DBGLVL, "Allocated texture after %u tries.", trycount));
    }
    
    __TM_STAT_Inc_TotSz(pTextureCacheManager, pTexture);
    __TM_STAT_Inc_WrkSet(pTextureCacheManager, pTexture);

#if DX7_TEXMANAGEMENT_STATS    
    ++pTextureCacheManager->m_stats.dwNumVidCreates;
#endif // DX7_TEXMANAGEMENT_STATS    
    
    return DD_OK;
    
} // _D3D_TM_AllocTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_RemoveTexture
//
// remove all HW handles and release the managed surface 
// (usually done for every surface in vidmem when D3DDestroyDDLocal is called)
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_RemoveTexture(
    P3_THUNKEDDATA *pThisDisplay,
    P3_SURF_INTERNAL* pTexture)
{    
//@@BEGIN_DDKSPLIT
// azn - we should attach the g_TextureManager ptr to pThisDisplay, 
//       NOT to pContext !!!
//@@END_DDKSPLIT
    PTextureCacheManager pTextureCacheManager =  &g_TextureManager; 
    int i;
 
    // Check if surface is currently in video memory
    for (i = 0; i < pTexture->iMipLevels; i++)
    {
        if (pTexture->MipLevels[i].fpVidMemTM != (FLATPTR)NULL)
        {
            // Free (deallocate) the surface from video memory
            // and mark the texture as not longer in vidmem
            _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pTexture);

            // Update statistics
            __TM_STAT_Dec_TotSz(pTextureCacheManager, pTexture);
            __TM_STAT_Dec_WrkSet(pTextureCacheManager, pTexture);        

            // The job is done
            break;
        }
    }

    // Remove heap references to this surface
    if (pTexture->m_dwHeapIndex && pTextureCacheManager->m_heap.m_data_p)
    {
        __TM_TextureHeapDelSurface(&pTextureCacheManager->m_heap,
                                   pTexture->m_dwHeapIndex); 
    }
    
} // _D3D_TM_RemoveTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_RemoveDDSurface
//
// remove all HW handles and release the managed surface 
// (usually done for every surface in vidmem when D3DDestroyDDLocal is called)
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_RemoveDDSurface(
    P3_THUNKEDDATA *pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    // We don't know which D3D context this is so we have to do a search 
    // through them (if there are any at all)
    if (pThisDisplay->pDirectDrawLocalsHashTable != NULL)
    {
        DWORD dwSurfaceHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;
       
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        pDDSLcl->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! remove it
                _D3D_TM_RemoveTexture(pThisDisplay, pSurfInternal);
            }
        }                                        
    } 


} // _D3D_TM_RemoveDDSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_EvictAllManagedTextures
//
// Remove all managed surfaces from video memory
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_EvictAllManagedTextures(
    P3_D3DCONTEXT* pContext)
{
    PTextureCacheManager pTextureCacheManager = pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;    
    P3_SURF_INTERNAL* pD3DSurf;
    
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);
    }
    
    pTextureCacheManager->tcm_ticks = 0;
    
} // _D3D_TM_EvictAllManagedTextures

//-----------------------------------------------------------------------------
//
// void _DD_TM_EvictAllManagedTextures
//
// Remove all managed surfaces from video memory
//
//-----------------------------------------------------------------------------
void 
_DD_TM_EvictAllManagedTextures(
    P3_THUNKEDDATA* pThisDisplay)
{
    PTextureCacheManager pTextureCacheManager = &g_TextureManager;
    P3_SURF_INTERNAL* pD3DSurf;
    
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);
    }
    
    pTextureCacheManager->tcm_ticks = 0;
    
} // _D3D_TM_EvictAllManagedTextures

//-----------------------------------------------------------------------------
//
// void _D3D_TM_TimeStampTexture
//
//-----------------------------------------------------------------------------
void
_D3D_TM_TimeStampTexture(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    __TM_TextureHeapUpdate(&pTextureCacheManager->m_heap,
                           pD3DSurf->m_dwHeapIndex, 
                           pD3DSurf->m_dwPriority, 
                           pTextureCacheManager->tcm_ticks);
                           
    pTextureCacheManager->tcm_ticks += 2;
    
} // _D3D_TM_TimeStampTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_HW_FreeVidmemSurface
//
// This is a hw/driver dependent function which takes care of evicting a
// managed texture that's living in videomemory out of it.
// After this all mipmaps fpVidMemTM should be NULL.
//
//-----------------------------------------------------------------------------
void
_D3D_TM_HW_FreeVidmemSurface(
    P3_THUNKEDDATA* pThisDisplay,
    P3_SURF_INTERNAL* pD3DSurf)
{
    INT i, iLimit;

    if (pD3DSurf->bMipMap)
    {
        iLimit = pD3DSurf->iMipLevels;
    }
    else
    {
        iLimit = 1;
    }

    for(i = 0; i < iLimit; i++)
    {
        if (pD3DSurf->MipLevels[i].fpVidMemTM != (FLATPTR)NULL)
        {
           // NOTE: if we weren't managing our own vidmem we would need to
           //       get the address of the VidMemFree callback using 
           //       EngFindImageProcAddress and use this callback into Ddraw to 
           //       do the video memory management. The declaration of 
           //       VidMemFree is
           //
           //       void VidMemFree(LPVMEMHEAP pvmh, FLATPTR ptr);  
           //
           //       You can find more information on this callback in the 
           //       Graphics Drivers DDK documentation           
           
            _DX_LIN_FreeLinearMemory(
                    &pThisDisplay->LocalVideoHeap0Info, 
                    (DWORD)(pD3DSurf->MipLevels[i].fpVidMemTM));

            pD3DSurf->MipLevels[i].fpVidMemTM = (FLATPTR)NULL;                    
        }    
    }
    
} // _D3D_TM_HW_FreeVidmemSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_HW_AllocVidmemSurface
//
// This is a hw/driver dependent function which takes care of allocating a
// managed texture that's living only in system memory into videomemory.
// After this fpVidMemTM should not be NULL. This is also the way to
// check if the call failed or was succesful (notice we don't return a
// function result)
//
//-----------------------------------------------------------------------------
void
_D3D_TM_HW_AllocVidmemSurface(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pD3DSurf)
{
    INT i, iLimit, iStart;
    P3_THUNKEDDATA* pThisDisplay;
    
    pThisDisplay = pContext->pThisDisplay;    

    if (pD3DSurf->bMipMap)
    {
        // Load only the necessary levels given any D3DDP2OP_SETTEXLOD command
        iStart = pD3DSurf->m_dwTexLOD;
        if (iStart > (pD3DSurf->iMipLevels - 1))
        {
            // we should at least load the smallest mipmap if we're loading 
            // the texture into vidmem (and make sure we never try to use any
            // other than these levels), otherwise we won't be able to render            
            iStart = pD3DSurf->iMipLevels - 1;
        }        
    
        iLimit = pD3DSurf->iMipLevels;
    }
    else
    {
        iStart = 0;
        iLimit = 1;
    }

    for(i = iStart; i < iLimit; i++)
    {
        if (pD3DSurf->MipLevels[i].fpVidMemTM == (FLATPTR)NULL)
        {        
           // NOTE: if we weren't managing our own vidmem we would need to
           //       get the address of the HeapVidMemAllocAligned callback 
           //       using EngFindImageProcAddress and use this callback into 
           //       Ddraw to do the video off-screen allocation. The 
           //       declaration of HeapVidMemAllocAligned is
           //
           //       FLATPTR HeapVidMemAllocAligned(LPVIDMEM lpVidMem, 
           //                                      DWORD    dwWidth,
           //                                      DWORD    dwHeight,
           //                                      LPSURFACEALIGNEMENT lpAlign,
           //                                      LPLONG   lpNewPitch);
           //
           //       You can find more information on this callback in the 
           //       Graphics Drivers DDK documentation
           
            P3_MEMREQUEST mmrq;
            DWORD dwResult;
            
            memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
            mmrq.dwSize = sizeof(P3_MEMREQUEST);
            mmrq.dwBytes = pD3DSurf->MipLevels[i].lPitch * 
                           pD3DSurf->MipLevels[i].wHeight;
            mmrq.dwAlign = 8;
            mmrq.dwFlags = MEM3DL_FIRST_FIT;
            mmrq.dwFlags |= MEM3DL_FRONT;

            dwResult = _DX_LIN_AllocateLinearMemory(
                            &pThisDisplay->LocalVideoHeap0Info,
                            &mmrq);        

            if (dwResult == GLDD_SUCCESS)
            {
                // Record the new vidmem addr for this managed mip level
                pD3DSurf->MipLevels[i].fpVidMemTM = mmrq.pMem;
            }
            else
            {
                // Failure, we'll need to deallocate any mipmap
                // allocated up to this point.
                _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pD3DSurf);
                
                break; // don't do the loop anymore
            }
        }    
    }

} // _D3D_TM_HW_AllocVidmemSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_Preload_Tex_IntoVidMem
//
// Transfer a texture from system memory into videomemory. If the texture
// still hasn't been allocated videomemory we try to do so (even evicting
// uneeded textures if necessary!).
//
//-----------------------------------------------------------------------------
BOOL
_D3D_TM_Preload_Tex_IntoVidMem(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pD3DSurf)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;  
    INT iLOD;

    // Decide the largest level to load based on what
    // is specified through D3DDP2OP_SETTEXLOD token
    iLOD = pD3DSurf->m_dwTexLOD;
    if (iLOD > (pD3DSurf->iMipLevels - 1))
    {
        iLOD = pD3DSurf->iMipLevels - 1;
    }
    
    if (!(pD3DSurf->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
    {
        DISPDBG((ERRLVL,"Must be a managed texture to do texture preload"));
        return FALSE; // INVALIDPARAMS
    }

    // Check if the largest required mipmap level has been allocated vidmem
    // (only required mipmap levels are ever allocated vidmem)
    if ((FLATPTR)NULL == pD3DSurf->MipLevels[iLOD].fpVidMemTM)
    {
        // add a new HW handle and create a surface 
        // (for a managed texture) in vidmem        
        if ((FAILED(_D3D_TM_AllocTexture(pContext, pD3DSurf))) ||  
            ((FLATPTR)NULL == pD3DSurf->MipLevels[iLOD].fpVidMemTM))
        {
            DISPDBG((ERRLVL,"_D3D_OP_TextureBlt unable to "
                            "allocate memory from heap"));
            return FALSE; // OUTOFVIDEOMEMORY
        }
        
        pD3DSurf->m_bTMNeedUpdate = TRUE;
    }
    
    if (pD3DSurf->m_bTMNeedUpdate)
    {
        // texture download   
        DWORD   iLimit, iCurrLOD;

        if (pD3DSurf->bMipMap)
        {
            iLimit = pD3DSurf->iMipLevels;
        }
        else
        {
            iLimit = 1;
        }

        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Blt managed texture's required mipmap levels into vid mem
        for (iCurrLOD = iLOD; iCurrLOD < iLimit ; iCurrLOD++)
        {
            RECTL   rect;
            rect.left=rect.top = 0;
            rect.right = pD3DSurf->MipLevels[iCurrLOD].wWidth;
            rect.bottom = pD3DSurf->MipLevels[iCurrLOD].wHeight;
        
            _DD_P3Download(pThisDisplay,
                           pD3DSurf->MipLevels[iCurrLOD].fpVidMem,
                           pD3DSurf->MipLevels[iCurrLOD].fpVidMemTM,
                           pD3DSurf->dwPatchMode,
                           pD3DSurf->dwPatchMode,
                           pD3DSurf->MipLevels[iCurrLOD].lPitch,
                           pD3DSurf->MipLevels[iCurrLOD].lPitch,                                                             
                           pD3DSurf->MipLevels[iCurrLOD].P3RXTextureMapWidth.Width,
                           pD3DSurf->dwPixelSize,
                           &rect,
                           &rect);   
                           
            DISPDBG((DBGLVL, "Copy from %08lx to %08lx"
                             " w=%08lx h=%08lx p=%08lx",
                             pD3DSurf->MipLevels[iCurrLOD].fpVidMem,
                             pD3DSurf->MipLevels[iCurrLOD].fpVidMemTM,
                             pD3DSurf->MipLevels[iCurrLOD].wWidth,
                             pD3DSurf->MipLevels[iCurrLOD].wHeight,
                             pD3DSurf->MipLevels[iCurrLOD].lPitch));                           
        }

        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);
        
        // Texture updated in vidmem
        pD3DSurf->m_bTMNeedUpdate = FALSE;                                  
    }

    return TRUE;

} // _D3D_TM_Preload_Tex_IntoVidMem

//-----------------------------------------------------------------------------
//
// void _D3D_TM_MarkDDSurfaceAsDirty
//
// Help mark a DD surface as dirty given that we need to search for it
// based on its lpSurfMore->dwSurfaceHandle and the lpDDLcl.
//
//-----------------------------------------------------------------------------
void
_D3D_TM_MarkDDSurfaceAsDirty(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, 
    BOOL bDirty)
{

    // We don't know which D3D context this is so we have to do a search 
    // through them (if there are any at all)
    if (pThisDisplay->pDirectDrawLocalsHashTable != NULL)
    {
        DWORD dwSurfaceHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;
       
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        pDDSLcl->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! Now update dirty TM value
                pSurfInternal->m_bTMNeedUpdate = bDirty;
            }
        }                                        
    } 

} // _D3D_TM_MarkDDSurfaceAsDirty

#endif // DX7_TEXMANAGEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxman.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.h
*
* Content:  D3D Texture cache manager definitions and macros.
*
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#ifndef __D3DTEXMAN
#define __D3DTEXMAN

#if DX7_TEXMANAGEMENT

__inline ULONGLONG TextureCost(P3_SURF_INTERNAL* pTexture)
{
#ifdef _X86_
    ULONGLONG retval = 0;
    _asm
    {
        mov     ebx, pTexture;
        mov     eax, [ebx]P3_SURF_INTERNAL.m_dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        mov     DWORD PTR retval + 4, eax;
        shl     ecx, 31;
        mov     eax, [ebx]P3_SURF_INTERNAL.m_dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR retval, eax;
    }
    return retval;
#else
    return ((ULONGLONG)pTexture->m_dwPriority << 31) + 
            ((ULONGLONG)(pTexture->m_dwTicks >> 1));
#endif
}

typedef struct _TextureHeap 
{
    DWORD   m_next;
    DWORD   m_size;
    P3_SURF_INTERNAL **m_data_p;
} TextureHeap, *PTextureHeap;

typedef struct _TextureCacheManager 
{    
    TextureHeap m_heap;
    unsigned int tcm_ticks;
#if DX7_TEXMANAGEMENT_STATS    
    D3DDEVINFO_TEXTUREMANAGER m_stats;  
#endif

}TextureCacheManager, *PTextureCacheManager;

//
// Texture Management function declarations
//

void __TM_TextureHeapHeapify(PTextureHeap,DWORD);
BOOL __TM_TextureHeapAddSurface(PTextureHeap,P3_SURF_INTERNAL *);
P3_SURF_INTERNAL* __TM_TextureHeapExtractMin(PTextureHeap);
P3_SURF_INTERNAL* __TM_TextureHeapExtractMax(PTextureHeap);
void __TM_TextureHeapDelSurface(PTextureHeap,DWORD);
void __TM_TextureHeapUpdate(PTextureHeap,DWORD,DWORD,DWORD); 
BOOL __TM_FreeTextures(P3_D3DCONTEXT* , DWORD);

HRESULT _D3D_TM_Ctx_Initialize(P3_D3DCONTEXT* pContext);
void _D3D_TM_Ctx_Destroy(P3_D3DCONTEXT* pContext);
void _D3D_TM_RemoveTexture(P3_THUNKEDDATA* pThisDisplay, P3_SURF_INTERNAL*);      
void _D3D_TM_RemoveDDSurface(P3_THUNKEDDATA* , LPDDRAWI_DDRAWSURFACE_LCL);
HRESULT _D3D_TM_AllocTexture(P3_D3DCONTEXT*,P3_SURF_INTERNAL*);
void _D3D_TM_EvictAllManagedTextures(P3_D3DCONTEXT*);
void _DD_TM_EvictAllManagedTextures(P3_THUNKEDDATA* pThisDisplay);
void _D3D_TM_TimeStampTexture(PTextureCacheManager,P3_SURF_INTERNAL*);
BOOL _D3D_TM_Preload_Tex_IntoVidMem(P3_D3DCONTEXT*, P3_SURF_INTERNAL*);
void _D3D_TM_MarkDDSurfaceAsDirty(P3_THUNKEDDATA*,LPDDRAWI_DDRAWSURFACE_LCL, BOOL);

void _D3D_TM_HW_FreeVidmemSurface(P3_THUNKEDDATA*,P3_SURF_INTERNAL*);
void _D3D_TM_HW_AllocVidmemSurface(P3_D3DCONTEXT*,P3_SURF_INTERNAL*);

//
// Macros to get surface offset and pointer
//

#if WNT_DDRAW

#define DDSURF_GETPOINTER(pSurfGbl, pThisDisplay)                       \
    (pSurfGbl->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DMIPLVL_GETPOINTER(pMipLevel, pThisDisplay)                   \
    (pMipLevel->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DSURF_GETPOINTER(pSurfInt, pThisDisplay)                      \
    (pSurfInt->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DTMMIPLVL_GETOFFSET(mipLevel, pThisDisplay)                   \
    (mipLevel.fpVidMemTM)

#else

#define DDSURF_GETPOINTER(pSurfGbl, pThisDisplay)                       \
    (pSurfGbl->fpVidMem)
#define D3DMIPLVL_GETPOINTER(pMipLevel, pThisDisplay)                   \
    (pMipLevel->fpVidMem)
#define D3DSURF_GETPOINTER(pSurfInt, pThisDisplay)                      \
    (pSurfInt->fpVidMem)
#define D3DTMMIPLVL_GETOFFSET(mipLevel, pThisDisplay)                   \
    (mipLevel.fpVidMemTM - pThisDisplay->dwScreenFlatAddr)

#endif // WNT_DDRAW


//
// Inline function definitions
//

__inline void _D3D_TM_InitSurfData(P3_SURF_INTERNAL* pD3DSurf,
                                   LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl) 
{
    pD3DSurf->m_dwBytes = pD3DSurf->wHeight * pD3DSurf->lPitch;
    pD3DSurf->m_bTMNeedUpdate = TRUE;
    pD3DSurf->dwCaps2= pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2;    
    pD3DSurf->m_dwTexLOD = 0;
}


#if DX7_TEXMANAGEMENT_STATS
__inline void __TM_STAT_Inc_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    ++pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes += pD3DSurf->m_dwBytes;
}

__inline void __TM_STAT_Inc_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    ++pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes += pD3DSurf->m_dwBytes;
}    

__inline void __TM_STAT_Dec_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    --pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes -= pD3DSurf->m_dwBytes;
}

__inline void __TM_STAT_Dec_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    --pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes -= pD3DSurf->m_dwBytes;
}

__inline void _D3D_TM_STAT_Inc_NumUsedTexInVid(P3_D3DCONTEXT *pContext,
                                               P3_SURF_INTERNAL* pD3DSurf)
{   
    if (pD3DSurf->m_dwHeapIndex)
    {
        ++pContext->pTextureManager->m_stats.dwNumUsedTexInVid;
    }
}

__inline void _D3D_TM_STAT_Inc_NumTexturesUsed(P3_D3DCONTEXT *pContext)
{
    ++pContext->pTextureManager->m_stats.dwNumTexturesUsed;
}

__inline void _D3D_TM_STAT_ResetCounters(P3_D3DCONTEXT *pContext)
{
    pContext->pTextureManager->m_stats.bThrashing = 0;
    pContext->pTextureManager->m_stats.dwNumEvicts = 0;
    pContext->pTextureManager->m_stats.dwNumVidCreates = 0;
    pContext->pTextureManager->m_stats.dwNumUsedTexInVid = 0;
    pContext->pTextureManager->m_stats.dwNumTexturesUsed = 0;
}

__inline void _D3D_TM_STAT_GetStats(P3_D3DCONTEXT *pContext,
                                    D3DDEVINFO_TEXTUREMANAGER* stats)
{
    memcpy(stats, 
           &pContext->pTextureManager->m_stats, 
           sizeof(D3DDEVINFO_TEXTUREMANAGER));
}
#else
// since we won't collect any stats, we just don't do anything
// inside these inlined functions
__inline void __TM_STAT_Inc_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void __TM_STAT_Inc_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}    

__inline void __TM_STAT_Dec_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void __TM_STAT_Dec_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void _D3D_TM_STAT_Inc_NumUsedTexInVid(P3_D3DCONTEXT *pContext,
                                               P3_SURF_INTERNAL* pD3DSurf)
{   
    NULL;
}

__inline void _D3D_TM_STAT_Inc_NumTexturesUsed(P3_D3DCONTEXT *pContext)
{
    NULL;
}

__inline void _D3D_TM_STAT_ResetCounters(P3_D3DCONTEXT *pContext)
{
    NULL;
}

#endif // DX7_TEXMANAGEMENT_STATS


#endif // DX7_TEXMANAGEMENT

#endif // __D3DTEXMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddblt.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddblt.c
*
* Content: DirectDraw Blt callback implementation for blts and clears
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "tag.h"
#include "dma.h"

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_P3Clear(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer,
    FLATPTR pDestfpVidMem,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth
    )
{
    DWORD   renderData, pixelSize, pixelScale; 
    BOOL    bFastFillOperation = TRUE;
    DWORD   dwOperation;
    P3_DMA_DEFS();
    
    P3_DMA_GET_BUFFER_ENTRIES(18);

    if(bDisableFastFill)
    {
        bFastFillOperation = FALSE;
    }
    
    switch(dwDestBitDepth)
    {
    case 16:
        ClearValue &= 0xFFFF;
        ClearValue |= ClearValue << 16;
        pixelSize = 1;
        pixelScale = 1;
        break;

    case 8:
        ClearValue &= 0xFF;
        ClearValue |= ClearValue << 8;
        ClearValue |= ClearValue << 16;
        pixelSize = 2;
        pixelScale = 1;
        break;

    case 32:
        if( bFastFillOperation )
        {
            // Do the operation as 16 bit due to FBWrite bug

            pixelSize = 1;
            pixelScale = 2;
        }
        else
        {
            pixelSize = 0;
            pixelScale = 1;
        }
        break;

    default:
        DISPDBG((ERRLVL,"ERROR: Invalid depth for surface during clear!"));
        // Treat as a  16bpp just as fallback though this should never happen
        ClearValue &= 0xFFFF;
        ClearValue |= ClearValue << 16;
        pixelSize = 1;
        pixelScale = 1;        
        break;
    }
    
    SEND_P3_DATA(PixelSize, pixelSize );

    SEND_P3_DATA(FBWriteBufferAddr0, 
                    (DWORD)(pDestfpVidMem - 
                            pThisDisplay->dwScreenFlatAddr) );
                            
    SEND_P3_DATA(FBWriteBufferWidth0, 
                    pixelScale * dwDestPixelPitch );
                    
    SEND_P3_DATA(FBWriteBufferOffset0, 
                    (rDest->top << 16) | pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(FBDestReadBufferAddr0, 
                    (DWORD)(pDestfpVidMem - 
                            pThisDisplay->dwScreenFlatAddr) );
                            
    SEND_P3_DATA(FBDestReadBufferWidth0, 
                    pixelScale * dwDestPixelPitch );
                    
    SEND_P3_DATA(FBDestReadBufferOffset0, 
                    (rDest->top << 16) | pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(RectanglePosition, 0);

    dwOperation = P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_NORMAL );

    SEND_P3_DATA(FBWriteMode, 
                 P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                 P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(18);

    if( bFastFillOperation )
    {
        DWORD shift = 0;

        SEND_P3_DATA(FBBlockColor, ClearValue);
        
        renderData =  P3RX_RENDER2D_WIDTH( pixelScale * (( rDest->right - rDest->left ) & 0xfff ))
                    | P3RX_RENDER2D_HEIGHT((( rDest->bottom - rDest->top ) & 0xfff ) >> shift )
                    | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                    | dwOperation;
                    
        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        SEND_P3_DATA(ConstantColor, ClearValue);
        SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE);

        SEND_P3_DATA(ColorDDAMode, 
                     P3RX_COLORDDA_ENABLE(__PERMEDIA_ENABLE) |
                     P3RX_COLORDDA_SHADING(P3RX_COLORDDA_FLATSHADE));

        renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                | P3RX_RENDER2D_HEIGHT(0)
                | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        
        SEND_P3_DATA(Render2D, renderData);
        
        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);

        SEND_P3_DATA(ColorDDAMode, __PERMEDIA_DISABLE);
    }

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3Clear

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3ClearDD
//
// Does a DDraw surface clear
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_P3ClearDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer
    )
{
    _DD_BLT_P3Clear(pThisDisplay,
                    rDest,
                    ClearValue,
                    bDisableFastFill,
                    bIsZBuffer,
                    pDest->lpGbl->fpVidMem,
                    P3RX_LAYOUT_LINEAR,
                    DDSurf_GetPixelPitch(pDest),
                    DDSurf_BitDepth(pDest)
                    );

} // _DD_BLT_P3ClearDD

#if DX7_TEXMANAGEMENT
//-----------------------------------------------------------------------------
//
// _DD_BLT_P3ClearManagedSurf
//
// Does a clear of a managed surface. Supports all color depths
//
// PixelSize-----surface color depth
// rDest---------rectangle for colorfill in dest. surface 
// fpVidMem------pointer to fill
// lPitch--------Surface Pitch
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
_DD_BLT_P3ClearManagedSurf(DWORD   PixelSize,
                  RECTL     *rDest, 
                  FLATPTR   fpVidMem, 
                  LONG      lPitch,
                  DWORD     dwColor)
{
    BYTE* pDestStart;
    LONG i;
    LONG lByteWidth = rDest->right - rDest->left;
    LONG lHeight = rDest->bottom - rDest->top;

    // Calculate the start pointer for the dest
    pDestStart   = (BYTE*)(fpVidMem + (rDest->top * lPitch));

    // Clear depending on depth
    switch (PixelSize) 
    {
            
        case __GLINT_8BITPIXEL:
            pDestStart += rDest->left;
            while (--lHeight >= 0) 
            {
                for (i = 0; i < lByteWidth ; i++)
                    pDestStart[i] = (BYTE)dwColor;
                pDestStart += lPitch;
            }
            break;
            
        case __GLINT_16BITPIXEL:
            pDestStart += rDest->left*2;
            while (--lHeight >= 0) 
            {
                LPWORD  lpWord=(LPWORD)pDestStart;
                for (i = 0; i < lByteWidth ; i++)
                    lpWord[i] = (WORD)dwColor;
                pDestStart += lPitch;
            }
            break;

        case __GLINT_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
            
        default: // 32 bits!
            pDestStart += rDest->left*4;
            while (--lHeight >= 0) 
            {
                LPDWORD lpDWord = (LPDWORD)pDestStart;
                for (i = 0; i < lByteWidth; i++)
                    lpDWord[i] = (WORD)dwColor;
                pDestStart += lPitch;
            }
            break;
    }
} // _DD_BLT_P3ClearManagedSurf
#endif // DX7_TEXMANAGEMENT

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear_AA
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3Clear_AA(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth,
    DDSCAPS DestDdsCaps)
{
    DWORD   renderData, pixelSize, pixelScale; 
    BOOL    bFastFillOperation = TRUE;
    P3_DMA_DEFS();
    
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);

    WAIT_FIFO(32); 

    if (bDisableFastFill)
    {
        bFastFillOperation = FALSE;
    }

    switch(dwDestBitDepth)
    {
        case 16:
            ClearValue &= 0xFFFF;
            ClearValue |= ClearValue << 16;
            pixelSize = 1;
            pixelScale = 1;
            break;

        case 8:
            ClearValue &= 0xFF;
            ClearValue |= ClearValue << 8;
            ClearValue |= ClearValue << 16;
            pixelSize = 2;
            pixelScale = 1;
            break;

       case 32:
            // 32 bit Z-buffer can be used for 16 bit antialiased render buffer
            if( bFastFillOperation )
            {
                // Do the operation as 16 bit due to FBWrite bug

                pixelSize = 1;
                pixelScale = 2;
            }
            else
            {
                pixelSize = 0;
                pixelScale = 1;
            }
            break;
        default:
            DISPDBG((ERRLVL,"ERROR: Invalid depth for surface during clear!"));
            // Treat as a  16bpp just as fallback            
            ClearValue &= 0xFFFF;
            ClearValue |= ClearValue << 16;
            pixelSize = 1;
            pixelScale = 1;
            break;
    }

    SEND_P3_DATA(PixelSize, pixelSize);

    SEND_P3_DATA(FBWriteBufferAddr0, dwSurfaceOffset);
    SEND_P3_DATA(FBWriteBufferWidth0, pixelScale * (dwDestPixelPitch * 2));
    SEND_P3_DATA(FBWriteBufferOffset0, (rDest->top << 16) | 
                                       pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(FBDestReadBufferAddr0, dwSurfaceOffset );
    SEND_P3_DATA(FBDestReadBufferWidth0, pixelScale * dwDestPixelPitch );
    SEND_P3_DATA(FBDestReadBufferOffset0, (rDest->top << 16) | 
                                          pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(RectanglePosition, 0);

    SEND_P3_DATA(FBWriteMode, P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));

    if( bFastFillOperation )
    {
        SEND_P3_DATA(FBBlockColor, ClearValue);

        renderData =  P3RX_RENDER2D_WIDTH( pixelScale * (( rDest->right - rDest->left ) & 0xfff ))
                    | P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );

        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        SEND_P3_DATA(ConstantColor, ClearValue);
        SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE);

        SEND_P3_DATA(ColorDDAMode, P3RX_COLORDDA_ENABLE(__PERMEDIA_ENABLE) |
                                    P3RX_COLORDDA_SHADING(P3RX_COLORDDA_FLATSHADE));

        renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                        | P3RX_RENDER2D_HEIGHT(0)
                        | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                        | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                        | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
            
        SEND_P3_DATA(Render2D, renderData);
        
        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);

        SEND_P3_DATA(ColorDDAMode, __PERMEDIA_DISABLE);
    }

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3Clear_AA

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear_AA_DD
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3Clear_AA_DD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill)
{
    _DD_BLT_P3Clear_AA(pThisDisplay,
                       rDest,
                       dwSurfaceOffset,
                       ClearValue,
                       bDisableFastFill,
                       P3RX_LAYOUT_LINEAR,
                       DDSurf_GetPixelPitch(pDest),
                       DDSurf_BitDepth(pDest),
                       pDest->ddsCaps
                       );
                       
} // _DD_BLT_P3Clear_AA_DD
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

#if DX7_TEXMANAGEMENT
//-----------------------------------------------------------------------------
//
// _DD_BLT_SysMemToSysMemCopy
//
// Does a copy from System memory to System memory (either from or to an
// AGP surface, or any other system memory surface)
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_SysMemToSysMemCopy(FLATPTR     fpSrcVidMem,
                           LONG        lSrcPitch,
                           DWORD       dwSrcBitCount,
                           FLATPTR     fpDstVidMem,
                           LONG        lDstPitch, 
                           DWORD       dwDstBitCount,
                           RECTL*      rSource,
                           RECTL*      rDest)
{
    BYTE* pSourceStart;
    BYTE* pDestStart;
    BYTE  pixSource;
    BYTE* pNewDest;
    BYTE* pNewSource;

    // Computing these from the smaller of Dest and Src as it is safer 
    // (we might touch invalid memory if for any weird reason we're 
    // asked to do a stretch blt here!)
    LONG lByteWidth = min(rDest->right - rDest->left,
                          rSource->right - rSource->left);
    LONG lHeight = min(rDest->bottom - rDest->top,
                       rSource->bottom - rSource->top);
    
    if (0 == fpSrcVidMem || 0 == fpDstVidMem)
    {
        DISPDBG((WRNLVL, "DDraw:_DD_BLT_SysMemToSysMemCopy "
                         "unexpected 0 fpVidMem"));
        return;
    }
    // Calculate the start pointer for the source and the dest
    pSourceStart = (BYTE*)(fpSrcVidMem + (rSource->top * lSrcPitch));
    pDestStart   = (BYTE*)(fpDstVidMem + (rDest->top * lDstPitch));

    // The simple 8, 16 or 32 bit copy
    pSourceStart += rSource->left * (dwSrcBitCount >> 3);
    pDestStart += rDest->left * (dwDstBitCount >> 3);
    lByteWidth *= (dwSrcBitCount >> 3);

    while (--lHeight >= 0) 
    {
        memcpy(pDestStart, pSourceStart, lByteWidth);
        pDestStart += lDstPitch;
        pSourceStart += lSrcPitch;
    };

} // _DD_BLT_SysMemToSysMemCopy 

#endif // DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
//
// _DD_BLT_FixRectlOrigin
//
// Fix blt coords in case some are negative. If the area is completly NULL 
// (coordinate-wise) then return FALSE, signaling there is nothing to be
// blitted.
//
//-----------------------------------------------------------------------------
BOOL _DD_BLT_FixRectlOrigin(char *pszPlace, RECTL *rSrc, RECTL *rDest)
{
    if ((rSrc->top < 0 && rSrc->bottom < 0) || 
        (rSrc->left < 0 && rSrc->right < 0))
    {
        // There is nothing to be blitted
        return FALSE;
    }

    if (rSrc->top   < 0 || 
        rSrc->left  < 0 || 
        rDest->top  < 0 || 
        rDest->left < 0) 
    {
        DISPDBG((DBGLVL, "Dodgy blt coords:"));
        DISPDBG((DBGLVL, "  src([%d, %d], [%d, %d]", 
                         rSrc->left, rSrc->top, 
                         rSrc->right, rSrc->bottom));
        DISPDBG((DBGLVL, "  dst([%d, %d], [%d, %d]", 
                         rDest->left, rDest->top, 
                         rDest->right, rDest->bottom));
    }

    if (rSrc->top < 0) 
    {
        rDest->top -= rSrc->top;
        rSrc->top = 0;
    }
    
    if (rSrc->left < 0) 
    {
        rDest->left -= rSrc->left;
        rSrc->left = 0;
    }

    DISPDBG((DBGLVL, "%s from (%d, %d) to (%d,%d) (%d, %d)", 
                     pszPlace,
                     rSrc->left, rSrc->top,
                     rDest->left, rDest->top, 
                     rDest->right, rDest->bottom));

    return TRUE; // Blt is valid
                     
} // _DD_BLT_FixRectlOrigin

//-----------------------------------------------------------------------------
//
// _DD_BLT_GetBltDirection
//
// Determine the direction of the blt
//  ==1 => increasing-x && increasing-y
//  ==0 => decreasing-x && decreasing-y
//
// Also, the boolean pbBlocking determines if there is a potential clash 
// because of common scan lines.
//
//-----------------------------------------------------------------------------
DWORD
_DD_BLT_GetBltDirection(    
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    RECTL *rSrc,
    RECTL *rDest,
    BOOL  *pbBlocking)
{    
    DWORD dwRenderDirection;

    *pbBlocking = FALSE;
    
    if( pDestfpVidMem != pSrcfpVidMem )
    {
        // Not the same surface, so always render downwards.
        dwRenderDirection = 1;
    }
    else
    {
        // Same surface - must choose render direction.
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else // y1 == y2
        {
            if(rSrc->left < rDest->left)
            {
                dwRenderDirection = 0;
            }
            else
            {
                dwRenderDirection = 1;
            }

            // It was found that this condition doesn't guarantee clean blits             
            // therefore we need to do a blocking 2D blit 
            *pbBlocking = TRUE;
        }
    }

    return dwRenderDirection;
    
} // _DD_BLT_GetBltDirection

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3CopyBlt
//
// Perform a Copy blt between the specified surfaces.
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3CopyBlt(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,
    DWORD dwSrcPitch,
    DWORD dwDestPitch,
    DWORD dwSrcOffset,
    DWORD dwDestOffset,
    DWORD dwDestPixelSize,
    RECTL *rSrc,
    RECTL *rDest)
{
    DWORD   renderData;
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    DWORD   dwSourceOffset;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;

    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if (!_DD_BLT_FixRectlOrigin("_DD_BLT_P3CopyBlt", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }

    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSrcfpVidMem, 
                                                 pDestfpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(40);

    WAIT_FIFO(20); 

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteBufferAddr0, dwDestOffset);
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);
    
    SEND_P3_DATA(FBSourceReadBufferAddr, dwSrcOffset);
    SEND_P3_DATA(FBSourceReadBufferWidth, dwSrcPitch);
    
    dwSourceOffset = (( rSrc->top - rDest->top ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);
    
    SEND_P3_DATA(FBDestReadMode, 
                            P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE));

    SEND_P3_DATA(FBSourceReadMode, 
                            P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                            P3RX_FBSOURCEREAD_LAYOUT(dwSrcChipPatchMode) |
                            P3RX_FBSOURCEREAD_BLOCKING( bBlocking ));

    SEND_P3_DATA(FBWriteMode, 
                            P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                            P3RX_FBWRITEMODE_LAYOUT0(dwDestChipPatchMode));

    WAIT_FIFO(20); 

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_Y(rDest->top) |
                                    P3RX_RECTANGLEPOSITION_X(rDest->left));

    renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                | P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE(__PERMEDIA_ENABLE)
                | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )
                | P3RX_RENDER2D_INCREASINGX( dwRenderDirection )
                | P3RX_RENDER2D_INCREASINGY( dwRenderDirection );
                
    SEND_P3_DATA(Render2D, renderData);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3CopyBlt


//-----------------------------------------------------------------------------
//
// _DD_BLT_P3CopyBltDD
//
// Perform a Copy blt between the specified Ddraw surfaces.
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3CopyBltDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rSrc,
    RECTL *rDest)
{
    _DD_BLT_P3CopyBlt(pThisDisplay,
                      pSource->lpGbl->fpVidMem,
                      pDest->lpGbl->fpVidMem,
                      P3RX_LAYOUT_LINEAR, // src
                      P3RX_LAYOUT_LINEAR, // dst
                      DDSurf_GetPixelPitch(pSource),
                      DDSurf_GetPixelPitch(pDest),
                      DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource),
                      DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest),
                      DDSurf_GetChipPixelSize(pDest),
                      rSrc,
                      rDest);

} // _DD_BLT_P3CopyBltDD
 
//-----------------------------------------------------------------------------
//
// DdBlt
//
// Performs a bit-block transfer.
//
// DdBlt can be optionally implemented in DirectDraw drivers.
//
// Before performing the bit block transfer, the driver should ensure that a 
// flip involving the destination surface is not in progress. If the destination 
// surface is involved in a flip, the driver should set ddRVal to 
// DDERR_WASSTILLDRAWING and return DDHAL_DRIVER_HANDLED.
//
// The driver should check dwFlags to determine the type of blt operation to 
// perform. The driver should not check for flags that are undocumented.
//
// Parameters
//
//      lpBlt 
//          Points to the DD_BLTDATA structure that contains the information 
//          required for the driver to perform the blt. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that describes the 
//              DirectDraw object. 
//          .lpDDDestSurface 
//              Points to the DD_SURFACE_LOCAL structure that describes the 
//              surface on which to blt. 
//          .rDest 
//              Points to a RECTL structure that specifies the upper left and 
//              lower right points of a rectangle on the destination surface. 
//              These points define the area in which the blt should occur and 
//              its position on the destination surface
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that describes the 
//              source surface. 
//          .rSrc 
//              Points to a RECTL structure that specifies the upper left and 
//              lower right points of a rectangle on the source surface. These 
//              points define the area of the source blt data and its position 
//              on the source surface. 
//          .dwFlags 
//              Specify the type of blt operation to perform and which 
//              associated structure members have valid data that the driver 
//              should use. This member is a bit-wise OR of any of the following 
//              flags: 
//
//              DDBLT_AFLAGS 
//                  This flag is not yet used as of DirectX 7.0. Indicates to 
//                  the driver that the dwAFlags and ddrgbaScaleFactors members 
//                  in this structure are valid. This flag is always set if the 
//                  DD_BLTDATA structure is passed to the driver from the 
//                  DdAlphaBlt callback. Otherwise this flag is zero. If this 
//                  flag is set, the DDBLT_ROTATIONANGLE and DDBLT_ROP flags 
//                  will be zero. 
//              DDBLT_ASYNC 
//                  Do this blt asynchronously through the FIFO in the order 
//                  received. If no room exists in the hardware FIFO, the driver 
//                  should fail the call and return immediately. 
//              DDBLT_COLORFILL 
//                  Use the dwFillColor member in the DDBLTFX structure as the 
//                  RGB color with which to fill the destination rectangle on 
//                  the destination surface. 
//              DDBLT_DDFX 
//                  Use the dwDDFX member in the DDBLTFX structure to determine 
//                  the effects to use for the blt. 
//              DDBLT_DDROPS 
//                  This is reserved for system use and should be ignored by the 
//                  driver. The driver should also ignore the dwDDROPS member of 
//                  the DDBLTFX structure. 
//              DDBLT_KEYDESTOVERRIDE 
//                  Use the dckDestColorkey member in the DDBLTFX structure as 
//                  the color key for the destination surface. If an override 
//                  is not being set, then dckDestColorkey does not contain the 
//                  color key. The driver should test the surface itself. 
//              DDBLT_KEYSRCOVERRIDE 
//                  Use the dckSrcColorkey member in the DDBLTFX structure as 
//                  the color key for the source surface. If an override is 
//                  not being set, then dckDestColorkey does not contain the 
//                  color key. The driver should test the surface itself. 
//              DDBLT_ROP 
//                  Use the dwROP member in the DDBLTFX structure for the 
//                  raster operation for this blt. Currently, the only ROP 
//                  passed to the driver is SRCCOPY. This ROP is the same as 
//                  defined in the Win32 API. See the Platform SDK for details.
//              DDBLT_ROTATIONANGLE 
//                  This is not supported on Windows 2000 and should be ignored 
//                  by the driver. 
//
//          .dwROPFlags 
//              This is unused on Windows 2000 and should be ignored by the 
//              driver. 
//          .bltFX 
//              Specifies a DDBLTFX structure that contains override 
//              information for more complex blt operations. For example, the 
//              dwFillColor field is used for solid color fills, and the 
//              ddckSrcColorKey and ddckDestColorKey fields are used for 
//              color key blts. The driver can determine which members of 
//              bltFX contain valid data by looking at the dwFlags member of 
//              the DD_BLTDATA structure. Note that the DDBLTFX_NOTEARING, 
//              DDBLTFX_MIRRORLEFTRIGHT, and DDBLTFX_MIRRORUPDOWN flags are 
//              unsupported on Windows 2000 and will never be passed to the 
//              driver. See the Platform SDK for DDBLTFX documentation. 
//          .ddRVal 
//              This is the location in which the driver writes the return 
//              value of the DdBlt callback. A return code of DD_OK indicates 
//              success. 
//          .Blt 
//              This is unused on Windows 2000. 
//          .IsClipped 
//              Indicates whether this is a clipped blt. On Windows 2000, 
//              this member is always FALSE, indicating that the blt is 
//              unclipped. 
//          .rOrigDest 
//              This member is unused for Windows 2000. Specifies a RECTL 
//              structure that defines the unclipped destination rectangle. 
//              This member is valid only if IsClipped is TRUE. 
//          .rOrigSrc 
//              This member is unused for Windows 2000. Specifies a RECTL 
//              structure that defines the unclipped source rectangle. This 
//              member is valid only if IsClipped is TRUE. 
//          .dwRectCnt 
//              This member is unused for Windows 2000. Specifies the number 
//              of destination rectangles to which prDestRects points. This 
//              member is valid only if IsClipped is TRUE. 
//          .prDestRects 
//              This member is unused for Windows 2000. Points to an array of 
//              RECTL structures that describe of destination rectangles. This 
//              member is valid only if IsClipped is TRUE. 
//          .dwAFlags 
//              This member is only valid if the DDBLT_AFLAGS flag is set in 
//              the dwFlags member of this structure. This member specifies 
//              operation flags used only by the DdAlphaBlt callback (which 
//              is not yet implemented as of DirectX 7.0). This member is a 
//              bit-wise OR of any of the following flags: 
//
//              DDABLT_BILINEARFLITER 
//                  Enable bilinear filtering of the source pixels during a 
//                  stretch blit. By default, no filtering is performed. 
//                  Instead, a nearest neighbor source pixel is copied to a 
//                  destination pixel 
//              DDABLT_NOBLEND 
//                  Write the source pixel values to the destination surface 
//                  without blending. The pixels are converted from the source 
//                  pixel format to the destination format, but no color 
//                  keying, alpha blending, or RGBA scaling is performed. In 
//                  the case of a fill operation (where the lpDDSrcSurface 
//                  member is NULL), the lpDDRGBAScaleFactors member of this 
//                  structure points to the source alpha and color components 
//                  that are to be converted to the destination pixel format 
//                  and are used to fill the destination. A blit operation is 
//                  performed if a valid source surface is specified, but in 
//                  this case, lpDDRGBAScaleFactors must be NULL or the call 
//                  will fail. This flag cannot be used in conjunction with 
//                  the DDBLT_KEYSRC and DDBLT_KEYDEST flags. 
//              DDABLT_SRCOVERDEST 
//                  If set, this flag indicates that the operation originated 
//                  from the application's AlphaBlt method. If the call was 
//                  originated by the application's Blt method, this flag is 
//                  not set. Drivers that have a unified DdBlt and DdAlphaBlt 
//                  callback can use this flag to distinguish between the two 
//                  application method calls. 
//
//          .ddrgbaScaleFactors 
//              This member is only valid if the DDBLT_AFLAGS flag is set in 
//              the dwFlags member of this structure. DDARGB structure that 
//              contains the RGBA-scaling factors used to scale the color and 
//              alpha components of each source pixel before it is composited 
//              to the destination surface. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdBlt( 
    LPDDHAL_BLTDATA lpBlt )
{
    RECTL   rSrc;
    RECTL   rDest;
    DWORD   dwFlags;
    BYTE    rop;
    LPDDRAWI_DDRAWSURFACE_LCL  pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL  pDestLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pSrcGbl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDestGbl;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    P3_THUNKEDDATA* pThisDisplay;
    HRESULT ddrval = DD_OK;
    BOOL bOverlapStretch = FALSE;

    DBG_CB_ENTRY(DdBlt);

    pDestLcl = lpBlt->lpDDDestSurface;
    pSrcLcl = lpBlt->lpDDSrcSurface;
        
    GET_THUNKEDDATA(pThisDisplay, lpBlt->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    pDestGbl = pDestLcl->lpGbl;
    pFormatDest = _DD_SUR_GetSurfaceFormat(pDestLcl);

    DISPDBG((DBGLVL, "Dest Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pDestLcl);

    dwFlags = lpBlt->dwFlags;

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    ddrval = _DX_QueryFlipStatus(pThisDisplay, pDestGbl->fpVidMem, TRUE);
    if( FAILED( ddrval ) )
    {
        lpBlt->ddRVal = ddrval;
        START_SOFTWARE_CURSOR(pThisDisplay);
        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);        
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // If async, then only work if bltter isn't busy
    //
    if( dwFlags & DDBLT_ASYNC )
    {
        if(DRAW_ENGINE_BUSY(pThisDisplay))
        {
            DISPDBG((WRNLVL, "ASYNC Blit Failed" ));
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_HANDLED;
        }
#if DBG
        else
        {
            DISPDBG((DBGLVL, "ASYNC Blit Succeeded!"));
        }
#endif
        
    }

    //
    // copy src/dest rects
    //
    rSrc = lpBlt->rSrc;
    rDest = lpBlt->rDest;
    
    rop = (BYTE) (lpBlt->bltFX.dwROP >> 16);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    if (dwFlags & DDBLT_ROP)
    {
        if (rop == (SRCCOPY >> 16))
        {

            DISPDBG((DBGLVL,"DDBLT_ROP:  SRCCOPY"));
            if (pSrcLcl != NULL) 
            {
                pSrcGbl = pSrcLcl->lpGbl;
                pFormatSource = _DD_SUR_GetSurfaceFormat(pSrcLcl);

                DISPDBG((DBGLVL, "Source Surface:"));
                DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pSrcLcl);
            }
            else 
            {
                START_SOFTWARE_CURSOR(pThisDisplay);
                DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                
                return DDHAL_DRIVER_NOTHANDLED;
            }

#if DX7_TEXMANAGEMENT
            if ((pSrcLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                    DDSCAPS2_TEXTUREMANAGE) ||
                (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                    DDSCAPS2_TEXTUREMANAGE) )
            {
                // Managed source surface cases 
                // (Including managed destination surfaces case)
                if (pSrcLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                            DDSCAPS2_TEXTUREMANAGE)
                {
                    if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ||
                        (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                            DDSCAPS2_TEXTUREMANAGE)         )
                    {
                        //-------------------------------------------------
                        // Do the Managed surf -> sysmem | managed surf blt
                        //-------------------------------------------------    

                        // make sure we'll reload the vidmem copy of the dest surf
                        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                                DDSCAPS2_TEXTUREMANAGE)         
                        {
                            _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                         pDestLcl, 
                                                         TRUE);                        
                        }

                        _DD_BLT_SysMemToSysMemCopy(
                                    pSrcGbl->fpVidMem,
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),  
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,  
                                    DDSurf_BitDepth(pDestLcl),  
                                    &rSrc,
                                    &rDest);
                                    
                    }
                    else if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM))
                    {
                        //-------------------------------------------------
                        // Do the Managed surf -> vidmem surf blt
                        //-------------------------------------------------                  

                        // This might be optimized by doing a vidmem->vidmem 
                        // when the source managed texture has a vidmem copy

                        _DD_P3Download(pThisDisplay,
                                       pSrcGbl->fpVidMem,
                                       pDestGbl->fpVidMem,
                                       P3RX_LAYOUT_LINEAR,
                                       P3RX_LAYOUT_LINEAR,
                                       pSrcGbl->lPitch,
                                       pDestGbl->lPitch,                                                             
                                       DDSurf_GetPixelPitch(pDestLcl),
                                       DDSurf_GetChipPixelSize(pDestLcl),
                                       &rSrc,
                                       &rDest);                                                                                 
                    }
                    
                    else            
                    {
                        DISPDBG((ERRLVL,"Src-managed Tex DdBlt"
                                        " variation unimplemented!"));
                    }                   
                    
                    goto Blt32Done;                    
                }
            
                // Managed destination surface cases
                if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                            DDSCAPS2_TEXTUREMANAGE)
                {                
                    if (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        //-------------------------------------------------
                        // Do the sysmem surf -> managed surf blt
                        //-------------------------------------------------    

                        // make sure we'll reload the vidmem copy of the dest surf
                        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                     pDestLcl, 
                                                     TRUE);

                        _DD_BLT_SysMemToSysMemCopy(
                                    pSrcGbl->fpVidMem,
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,
                                    DDSurf_BitDepth(pDestLcl),
                                    &rSrc, 
                                    &rDest);

                        goto Blt32Done;
                    }
                    else if (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)             
                    {
                        //-------------------------------------------------
                        // Do the vidmem surf -> Managed surf blt
                        //-------------------------------------------------                                  

                        // make sure we'll reload the 
                        // vidmem copy of the dest surf
                        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                     pDestLcl, 
                                                     TRUE);

                        // Do slow mem mapped framebuffer blt into sysmem
                        // The source surface lives in video mem so we need to get a
                        // "real" sysmem address for it:                    
                        _DD_BLT_SysMemToSysMemCopy(
                                    DDSURF_GETPOINTER(pSrcGbl, pThisDisplay),
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),  
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,  
                                    DDSurf_BitDepth(pDestLcl), 
                                    &rSrc,
                                    &rDest);
                    }                    
                    else            
                    {
                        DISPDBG((ERRLVL,"Dest-managed Tex DdBlt"
                                        " variation unimplemented!"));
                    }                                    

                    
                }
                
                goto Blt32Done;

            }
#endif // DX7_TEXMANAGEMENT

            // Invalid cases...
            if ((pFormatSource->DeviceFormat == SURF_YUV422) && 
                (pFormatDest->DeviceFormat == SURF_CI8))
            {
                DISPDBG((ERRLVL,"Can't do this blit!"));
                START_SOFTWARE_CURSOR(pThisDisplay);
                lpBlt->ddRVal = DDERR_UNSUPPORTED;
                DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                
                return DDHAL_DRIVER_NOTHANDLED;
            }

            // Operation is System -> Video memory blit, as a texture 
            // download or an image download.
            if (!(dwFlags & DDBLT_KEYDESTOVERRIDE) &&
                (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && 
                (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
            {
                DISPDBG((DBGLVL,"Being Asked to do SYSMEM->VIDMEM Blit"));

                if (rop != (SRCCOPY >> 16)) 
                {
                    DISPDBG((DBGLVL,"Being asked for non-copy ROP, refusing"));
                    lpBlt->ddRVal = DDERR_NORASTEROPHW;

                    START_SOFTWARE_CURSOR(pThisDisplay);
                    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                    
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                DISPDBG((DBGLVL,"Doing image download"));

                _DD_P3DownloadDD(pThisDisplay, 
                           pSrcLcl, 
                           pDestLcl, 
                           pFormatSource, 
                           pFormatDest, 
                           &rSrc, 
                           &rDest);
                           
                goto Blt32Done;
            } 

            // Check for overlapping stretch blits.
            // Are the surfaces the same?
            if (pDestLcl->lpGbl->fpVidMem == pSrcLcl->lpGbl->fpVidMem)
            {
                // Do they overlap?
                if ((!((rSrc.bottom < rDest.top) || (rSrc.top > rDest.bottom))) &&
                    (!((rSrc.right < rDest.left) || (rSrc.left > rDest.right)))   )
                {
                    // Are they of different source and dest sizes?
                    if ( ((rSrc.right - rSrc.left) != (rDest.right - rDest.left)) || 
                         ((rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top)) )
                    {
                        bOverlapStretch = TRUE;
                    }
                }
            }

            // Is it a transparent blit?
            if ( ( dwFlags & DDBLT_KEYSRCOVERRIDE  ) || 
                 ( dwFlags & DDBLT_KEYDESTOVERRIDE ) )
            {
                DISPDBG((DBGLVL,"DDBLT_KEYSRCOVERRIDE"));

                if (rop != (SRCCOPY >> 16)) 
                {
                    lpBlt->ddRVal = DDERR_NORASTEROPHW;
                    START_SOFTWARE_CURSOR(pThisDisplay);
                    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                    
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                // If the surface sizes don't match, then we are stretching.
                // If the surfaces are flipped then do it this was for now...
                if (((rSrc.right - rSrc.left) != (rDest.right - rDest.left) || 
                     (rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top) ) ||
                    ((dwFlags & DDBLT_DDFX) && 
                     ((lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) ||
                      (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)) ) )
                {
                    if (!bOverlapStretch)
                    {
                        // Use generic rout.
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // Stretched overlapped blits (DCT case)
                        _DD_P3BltStretchSrcChDstChOverlap(pThisDisplay, 
                                                          pSrcLcl, 
                                                          pDestLcl, 
                                                          pFormatSource,
                                                          pFormatDest, 
                                                          lpBlt, 
                                                          &rSrc, 
                                                          &rDest);
                    }
                }
                else if ( dwFlags & DDBLT_KEYDESTOVERRIDE )
                {
                    if ((pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
                    {
                        DISPDBG((DBGLVL,"Being Asked to do SYSMEM->VIDMEM "
                                   "Blit with DestKey"));

                        if (rop != (SRCCOPY >> 16)) 
                        {   
                            DISPDBG((DBGLVL,"Being asked for non-copy "
                                       "ROP, refusing"));
                            lpBlt->ddRVal = DDERR_NORASTEROPHW;

                            START_SOFTWARE_CURSOR(pThisDisplay);
                            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                            
                            return DDHAL_DRIVER_NOTHANDLED;
                        }

                        // A download routine that does destination colorkey.
                        _DD_P3DownloadDstCh(pThisDisplay, 
                                        pSrcLcl, 
                                        pDestLcl, 
                                        pFormatSource, 
                                        pFormatDest, 
                                        lpBlt, 
                                        &rSrc, 
                                        &rDest);
                    }
                    else
                    {
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                }
                else
                {
                    if (DDSurf_IsAGP(pSrcLcl))
                    {
                        // Need this rout if we are in 
                        // AGP memory because this textures
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // Only source keying, and no stretching.
                        _DD_P3BltSourceChroma(pThisDisplay, 
                                              pSrcLcl, 
                                              pDestLcl, 
                                              pFormatSource, 
                                              pFormatDest, 
                                              lpBlt, 
                                              &rSrc, 
                                              &rDest);
                    }
                }
                goto Blt32Done;
            }
            else
            { 
                // If the surface sizes don't match, then we are stretching.
                // If the surfaces are flipped then do it this was for now...
                if (((rSrc.right - rSrc.left) != (rDest.right - rDest.left) || 
                    (rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top)) ||
                      ((lpBlt->dwFlags & DDBLT_DDFX) && 
                      ((lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)         || 
                       (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT))))
                {
                    // Is a stretch blit
                    DISPDBG((DBGLVL,"DDBLT_ROP: STRETCHCOPYBLT OR "
                                    "MIRROR OR BOTH"));
                            
                    // Can't rop during a stretch blit.
                    if (rop != (SRCCOPY >> 16)) 
                    {
                        lpBlt->ddRVal = DDERR_NORASTEROPHW;
                        START_SOFTWARE_CURSOR(pThisDisplay);
                        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                        
                        return DDHAL_DRIVER_NOTHANDLED;
                    }

                    // Do the stretch
                    if (!bOverlapStretch)
                    {
                        // Use the generic rout ATM.
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // DCT case - Stretched overlapped blits
                        _DD_P3BltStretchSrcChDstChOverlap(pThisDisplay, 
                                                          pSrcLcl, 
                                                          pDestLcl, 
                                                          pFormatSource, 
                                                          pFormatDest, 
                                                          lpBlt, 
                                                          &rSrc, 
                                                          &rDest);
                    }
                }
                else    // ! Stretching
                {
                    // Must be a standard blit.
                    DISPDBG((DBGLVL,"DDBLT_ROP:  COPYBLT"));
                    DISPDBG((DBGLVL,"Standard Copy Blit"));

                    // If the source is in AGP, use a texturing blitter.

                    if ((DDSurf_IsAGP(pSrcLcl)) || 
                        ((pFormatSource->DeviceFormat == SURF_YUV422) &&
                         (pFormatDest->DeviceFormat != SURF_YUV422)))
                    {
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // A standard, boring blit.
                        // Call the correct CopyBlt Function.

                        _DD_BLT_P3CopyBltDD(pThisDisplay, 
                                            pSrcLcl, 
                                            pDestLcl, 
                                            pFormatSource, 
                                            pFormatDest, 
                                            &rSrc, 
                                            &rDest);
                    }
                }
                goto Blt32Done;
            }
        }
        else if ((rop == (BLACKNESS >> 16)) || (rop == (WHITENESS >> 16)))
        {
            DWORD color;

            DISPDBG((DBGLVL,"DDBLT_ROP:  BLACKNESS or WHITENESS"));
            
            if (rop == (BLACKNESS >> 16))
            {
                color = 0;
            }
            else
            {
                color = 0xffffffff;
            }
            
            _DD_BLT_P3ClearDD(pThisDisplay, 
                        pDestLcl, 
                        pFormatDest, 
                        &rDest, 
                        color, 
                        FALSE, 
                        FALSE);
        }
        else if ((rop & 7) != ((rop >> 4) & 7))
        {
            lpBlt->ddRVal = DDERR_NORASTEROPHW;

            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_NOTHANDLED;
        }
        else
        {
            DISPDBG((WRNLVL,"P3 BLT case not found!"));

            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }
    else if (dwFlags & DDBLT_COLORFILL)
    {
        DISPDBG((DBGLVL,"DDBLT_COLORFILL(P3): Color=0x%x", 
                        lpBlt->bltFX.dwFillColor));
#if DX7_TEXMANAGEMENT                        
        // If clearing a driver managed texture, clear just the sysmem copy
        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            _DD_BLT_P3ClearManagedSurf(DDSurf_GetChipPixelSize(pDestLcl),
                                       &rDest, 
                                       pDestGbl->fpVidMem, 
                                       pDestGbl->lPitch,
                                       lpBlt->bltFX.dwFillColor);

            _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                         pDestLcl, 
                                         TRUE);
        }
        else
#endif // DX7_TEXMANAGEMENT          
        {
            _DD_BLT_P3ClearDD(pThisDisplay, 
                        pDestLcl, 
                        pFormatDest, 
                        &rDest, 
                        lpBlt->bltFX.dwFillColor, 
                        FALSE, 
                        FALSE);
        }
    }
    else if (dwFlags & DDBLT_DEPTHFILL || 
             ((dwFlags & DDBLT_COLORFILL) && 
              (pDestLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)))
    {
        DISPDBG((DBGLVL,"DDBLT_DEPTHFILL(P3):  Value=0x%x", 
                        lpBlt->bltFX.dwFillColor));

        _DD_BLT_P3ClearDD(pThisDisplay, 
                    pDestLcl, 
                    pFormatDest, 
                    &rDest, 
                    lpBlt->bltFX.dwFillColor, 
                    TRUE, 
                    TRUE);
    }
    else
    {
        START_SOFTWARE_CURSOR(pThisDisplay);
        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);        
        return DDHAL_DRIVER_NOTHANDLED;
    }


Blt32Done:

    if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) ||
        (pDestLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER))
    {
        P3_DMA_DEFS();
        DISPDBG((DBGLVL,"Flushing DMA due to primary target in DDRAW"));
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    lpBlt->ddRVal = DD_OK;
    
    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);    
    
    return DDHAL_DRIVER_HANDLED;

} // DdBlt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dddownld.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dddownld.c
*
* Content: DirectDraw Blt implementation for sysmem-vidmem blts and clears
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

#define UNROLL_COUNT    8   // Number of iterations of transfer in an unrolled loop
#define P3_BLOCK_SIZE      (UNROLL_COUNT * 8)  // # of unrolled loops .
#define GAMMA_BLOCK_SIZE   (UNROLL_COUNT * 2)  // # of unrolled loops .
#define BLOCK_SIZE         (DWORD)((TLCHIP_GAMMA)?GAMMA_BLOCK_SIZE:P3_BLOCK_SIZE)

#define TAGGED_SIZE ((BLOCK_SIZE - 1) << 16)


#define UNROLLED()                  \
    dmaPtr[0] = pCurrentLine[0];    \
    dmaPtr[1] = pCurrentLine[1];    \
    dmaPtr[2] = pCurrentLine[2];    \
    dmaPtr[3] = pCurrentLine[3];    \
    dmaPtr[4] = pCurrentLine[4];    \
    dmaPtr[5] = pCurrentLine[5];    \
    dmaPtr[6] = pCurrentLine[6];    \
    dmaPtr[7] = pCurrentLine[7];    \
    dmaPtr += UNROLL_COUNT;         \
    CHECK_FIFO(UNROLL_COUNT);       \
    pCurrentLine += UNROLL_COUNT;


//-----------------------------------------------------------------------------
//
// _DD_P3Download
//
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3Download(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,    
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,  
    DWORD dwSrcPitch,
    DWORD dwDestPitch,   
    DWORD dwDestPixelPitch,  
    DWORD dwDestPixelSize,
    RECTL* rSrc,
    RECTL* rDest)
{
    // Work out pixel offset into the framestore of the rendered surface
    ULONG LineWidth;
    DWORD cDWORDS;
    DWORD SrcOffset; 
    DWORD DstOffset; 
    ULONG ImageLines;
    ULONG count;
    ULONG renderData;
    DWORD dwDownloadTag;
    int rDestleft, rDesttop, rSrcleft, rSrctop;
    RECTL rNewDest;
    P3_DMA_DEFS();
               
    // Because of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3Download", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
       
    SrcOffset = (DWORD)(rSrc->left << dwDestPixelSize) + 
                                    (rSrc->top * dwSrcPitch);
    DstOffset = (DWORD)(rDest->left << dwDestPixelSize) + 
                                    (rDest->top * dwDestPitch);

    LineWidth = rDest->right - rDest->left;
    ImageLines = rDest->bottom - rDest->top;

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(16);
    WAIT_FIFO(16);

    SEND_P3_DATA(FBWriteBufferAddr0, 
                        (DWORD)(pDestfpVidMem - 
                                   pThisDisplay->dwScreenFlatAddr) );
                                
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPixelPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 
                                        (rDest->top << 16) | 
                                        (rDest->left & 0xFFFF));

    SEND_P3_DATA(LogicalOpMode, 7);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));
                    
    SEND_P3_DATA(FBDestReadMode, 
                    P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) |
                    P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));

    dwDownloadTag = Color_Tag;

    rNewDest = *rDest;

    DISPDBG((DBGLVL, "Image download %dx%d", LineWidth, ImageLines));

    if (dwDestPixelSize != __GLINT_32BITPIXEL) 
    {
        if (dwDestPixelSize == __GLINT_8BITPIXEL) 
        {
            LineWidth = (LineWidth + 3) >> 2;
            
            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (LineWidth << 2);
            }
        }
        else 
        {
            LineWidth = (LineWidth + 1) >> 1;

            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (LineWidth << 1);
            }
        }
    }

    P3_ENSURE_DX_SPACE(20);
    WAIT_FIFO(20);        

    SEND_P3_DATA(FBSourceReadMode, 
                      P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE) |
                      P3RX_FBSOURCEREAD_LAYOUT(dwSrcChipPatchMode));

    SEND_P3_DATA(RectanglePosition, 0);

    if (dwDownloadTag == Color_Tag)
    {
        renderData =  P3RX_RENDER2D_WIDTH((rNewDest.right - rNewDest.left) & 0xfff )
                    | P3RX_RENDER2D_HEIGHT((rNewDest.bottom - rNewDest.top ) & 0xfff )
                    | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                    | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        // Don't use spans for the unpacking scheme, but use the 2D Setup
        // unit to do the work of setting up the destination
        SEND_P3_DATA(ScissorMinXY, 0);
        SEND_P3_DATA(ScissorMaxXY, P3RX_SCISSOR_X_Y(rDest->right, rDest->bottom));
        SEND_P3_DATA(ScissorMode, P3RX_SCISSORMODE_USER(__PERMEDIA_ENABLE));
        
        renderData =  P3RX_RENDER2D_WIDTH( (rNewDest.right - rNewDest.left) & 0xfff )
                    | P3RX_RENDER2D_HEIGHT( 0 )
                    | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        SEND_P3_DATA(Render2D, renderData);

        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_HOST_DATA);
    }

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    {
        BYTE *pSurfaceData = (BYTE *)pSrcfpVidMem + SrcOffset;
        UNALIGNED DWORD *pCurrentLine = (DWORD *)pSurfaceData;
        
        while (ImageLines-- > 0)
        {
        
            DISPDBG((DBGLVL, "Image download lines %d", ImageLines));

            cDWORDS = LineWidth;
            // Send the texels in DWORDS
            while (cDWORDS >= BLOCK_SIZE)
            {
                P3_ENSURE_DX_SPACE(BLOCK_SIZE + 1);
                WAIT_FIFO(BLOCK_SIZE + 1);
                ADD_FUNNY_DWORD(TAGGED_SIZE | dwDownloadTag);

                for (count = BLOCK_SIZE / UNROLL_COUNT; count; count--)
                {
                    DISPDBG((DBGLVL, "Image download count %d", count));
                    UNROLLED();
                }
                cDWORDS -= BLOCK_SIZE;
            }

            // Finish off the rest
            if (cDWORDS) {
                P3_ENSURE_DX_SPACE(cDWORDS + 1);
                WAIT_FIFO(cDWORDS + 1);
                ADD_FUNNY_DWORD(((cDWORDS - 1) << 16) | dwDownloadTag)
                for (count = 0; count < cDWORDS; count++, pCurrentLine++) 
                    ADD_FUNNY_DWORD(*pCurrentLine);
            }

            pSurfaceData += dwSrcPitch;
            pCurrentLine = (DWORD*)pSurfaceData;
        }
    }

    P3_ENSURE_DX_SPACE(4);
    WAIT_FIFO(4);

    SEND_P3_DATA(WaitForCompletion, 0);
    SEND_P3_DATA(ScissorMode, __PERMEDIA_DISABLE);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();

}  // _DD_P3Download 

//-----------------------------------------------------------------------------
//
// _DD_P3DownloadDD
//
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3DownloadDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL* rSrc,
    RECTL* rDest)
{
    _DD_P3Download(pThisDisplay,
                   pSource->lpGbl->fpVidMem,
                   pDest->lpGbl->fpVidMem,
                   P3RX_LAYOUT_LINEAR, // src
                   P3RX_LAYOUT_LINEAR, // dst,
                   pSource->lpGbl->lPitch,
                   pDest->lpGbl->lPitch,                   
                   DDSurf_GetPixelPitch(pDest),
                   DDSurf_GetChipPixelSize(pDest),
                   rSrc,
                   rDest);
                     
} // _DD_P3DownloadDD

//-----------------------------------------------------------------------------
//
// _DD_P3DownloadDstCh
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3DownloadDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL* rSrc,
    RECTL* rDest)
{
    // Work out pixel offset into the framestore of the rendered surface
    ULONG LineWidth;
    DWORD cDWORDS;
    DWORD SrcOffset; 
    ULONG ImageLines;
    ULONG count;
    ULONG renderData;
    DWORD dwDownloadTag;
    int rDestleft, rDesttop, rSrcleft, rSrctop;
    RECTL rNewDest;
    BOOL bDstKey = FALSE;
    P3_DMA_DEFS();
                
    // Because of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3DownloadDstCh", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
       
    SrcOffset = (DWORD)(rSrc->left << DDSurf_GetChipPixelSize(pDest)) + (rSrc->top * pSource->lpGbl->lPitch);

    LineWidth = rDest->right - rDest->left;
    ImageLines = rDest->bottom - rDest->top;

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(FBWriteBufferAddr0, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, (rDest->top << 16) | (rDest->left & 0xFFFF));

    SEND_P3_DATA(LogicalOpMode, 7);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    if (lpBlt->dwFlags & DDBLT_KEYDESTOVERRIDE)
    {
        bDstKey = TRUE;

        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                                        );

        SEND_P3_DATA(ChromaLower, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
        SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pDest));
        SEND_P3_DATA(FBSourceReadBufferOffset, (rDest->top << 16) | (rDest->left & 0xFFFF));
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));
    }
    else
    {
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));
    }

    SEND_P3_DATA(FBWriteMode, P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                                P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));
    SEND_P3_DATA(FBDestReadMode, P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) |
                                    P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));


    // This dest-colorkey download always needs to send unpacked color data
    // because it can't use spans.
    SEND_P3_DATA(DownloadTarget, Color_Tag);
    switch (DDSurf_GetChipPixelSize(pDest))
    {
        case __GLINT_8BITPIXEL:
            dwDownloadTag = Packed8Pixels_Tag;
            break;
        case __GLINT_16BITPIXEL:
            dwDownloadTag = Packed16Pixels_Tag;
            break;
        default:
            dwDownloadTag = Color_Tag;
            break;
    }
    
    rNewDest = *rDest;

    DISPDBG((DBGLVL, "Image download %dx%d", LineWidth, ImageLines));

    if (DDSurf_GetChipPixelSize(pDest) != __GLINT_32BITPIXEL) 
    {
        if (DDSurf_GetChipPixelSize(pDest) == __GLINT_8BITPIXEL) 
        {
            LineWidth = (LineWidth + 3) >> 2;
            
            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (LineWidth << 2);
            }
        }
        else 
        {
            LineWidth = (LineWidth + 1) >> 1;

            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (LineWidth << 1);
            }
        }
    }

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(RectanglePosition, 0);


    // Don't use spans for the unpacking scheme, but use the 2D Setup
    // unit to do the work of setting up the destination
    SEND_P3_DATA(ScissorMinXY, 0 )
    SEND_P3_DATA(ScissorMaxXY,P3RX_SCISSOR_X_Y(rDest->right - rDest->left ,
                                               rDest->bottom - rDest->top ));
    SEND_P3_DATA(ScissorMode, P3RX_SCISSORMODE_USER(__PERMEDIA_ENABLE));
    
    renderData =  P3RX_RENDER2D_WIDTH( (rNewDest.right - rNewDest.left) & 0xfff )
                | P3RX_RENDER2D_HEIGHT( 0 )
                | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_FBREADSOURCEENABLE((bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE));
    SEND_P3_DATA(Render2D, renderData);
    SEND_P3_DATA(Count, rNewDest.bottom - rNewDest.top );
    SEND_P3_DATA(Render, P3RX_RENDER_PRIMITIVETYPE(P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID) |
                         P3RX_RENDER_SYNCONHOSTDATA(__PERMEDIA_ENABLE) |
                         P3RX_RENDER_FBSOURCEREADENABLE((bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE)));
    
    {
        BYTE *pSurfaceData = (BYTE *)pSource->lpGbl->fpVidMem + SrcOffset;
        DWORD *pCurrentLine = (DWORD *)pSurfaceData;
        
        while (ImageLines-- > 0)
        {
            DISPDBG((DBGLVL, "Image download lines %d", ImageLines));

            cDWORDS = LineWidth;
            // Send the texels in DWORDS
            while (cDWORDS >= BLOCK_SIZE)
            {
                P3_ENSURE_DX_SPACE(BLOCK_SIZE + 1);
                WAIT_FIFO(BLOCK_SIZE + 1);
                ADD_FUNNY_DWORD(TAGGED_SIZE | dwDownloadTag);

                for (count = BLOCK_SIZE / UNROLL_COUNT; count; count--)
                {
                    DISPDBG((DBGLVL, "Image download count %d", count));
                    UNROLLED();
                }
                cDWORDS -= BLOCK_SIZE;
            }

            // Finish off the rest
            if (cDWORDS) {
                P3_ENSURE_DX_SPACE(cDWORDS + 1);
                WAIT_FIFO(cDWORDS + 1);
                ADD_FUNNY_DWORD(((cDWORDS - 1) << 16) | dwDownloadTag)
                for (count = 0; count < cDWORDS; count++, pCurrentLine++) 
                    ADD_FUNNY_DWORD(*pCurrentLine);
            }

            pSurfaceData += pSource->lpGbl->lPitch;
            pCurrentLine = (DWORD*)pSurfaceData;
        }
    }

    P3_ENSURE_DX_SPACE(6);
    WAIT_FIFO(6);

    SEND_P3_DATA(WaitForCompletion, 0);
    SEND_P3_DATA(ScissorMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();

}  //_DD_P3DownloadDstCh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddbltfx.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddbltfx.c
*
* Content: DirectDraw Blt implementation for stretching blts
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "glintdef.h"
#include "dma.h"
#include "tag.h"
#include "chroma.h"

// A magic number to make it all work.
// This must be 11 or less, according to the P3 spec.
#define MAGIC_NUMBER_2D 11

//-----------------------------------------------------------------------------
//
// _DD_P3BltSourceChroma
//
// Do a blt with no stretching, but with source chroma keying
//
//-----------------------------------------------------------------------------
void 
_DD_P3BltSourceChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt, 
    RECTL *rSrc,
    RECTL *rDest)
{
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    BOOL    b8to8blit;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;
    DWORD   dwSourceOffset;
    DWORD   dwLowerSrcBound, dwUpperSrcBound;
    
    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes 
    // have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3BltSourceChroma", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && 
         ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, since no LUT translation is involved.
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    } 
    
    DISPDBG((DBGLVL, "P3 Chroma (before): Upper = 0x%08x, Lower = 0x%08x", 
                     lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                     lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue));

    // Prepare data to be used as color keying limits
    if ( b8to8blit )
    {
        // No conversion, just use the index value in the R channel.
        dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue & 0x000000ff;
        dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue | 0xffffff00;
    }     
    else
    {
        dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
        if ( pFormatSource->DeviceFormat == SURF_8888 )       
        {
            //
            // Mask off alpha channel when a single source color key is used
//@@BEGIN_DDKSPLIT        
            // IZ : This can be a problem when a color key range is used.
//@@END_DDKSPLIT
            //

            dwUpperSrcBound |= 0xFF000000;
            dwLowerSrcBound &= 0x00FFFFFF;
        }
    }
    
    DISPDBG((DBGLVL, "P3 Chroma (after): Upper = 0x%08x, Lower = 0x%08x",
                     dwUpperSrcBound, dwLowerSrcBound));


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);
   
    P3_DMA_GET_BUFFER_ENTRIES(32);

    // Even though the AlphaBlend is disabled, the chromakeying uses
    // the ColorFormat, ColorOrder and ColorConversion fields.

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    // Setup the hw chromakeying registers
    SEND_P3_DATA(ChromaTestMode, 
              P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) 
            | P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) 
            | P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) 
            | P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
            );

    SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
    SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);  

    SEND_P3_DATA(LogicalOpMode, GLINT_ENABLED_LOGICALOP( __GLINT_LOGICOP_NOOP ));

    SEND_P3_DATA(FBWriteBufferAddr0, 
                 DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
                 
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(FBSourceReadBufferAddr, 
                 DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource));
                 
    SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pSource));

    dwSourceOffset = (( rSrc->top - rDest->top   ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);

    SEND_P3_DATA(FBDestReadMode, 
              P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) 
            | P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));
            
    SEND_P3_DATA(FBWriteMode, 
              P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) 
            | P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));

    SEND_P3_DATA(FBSourceReadMode, 
              P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) 
            | P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR) 
            | P3RX_FBSOURCEREAD_BLOCKING(bBlocking));
            
    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    // Can't use 2D setup because we aren't rendering with spans.
    if (dwRenderDirection == 0)
    {
        // right to left, bottom to top
        SEND_P3_DATA(StartXDom, (rDest->right << 16));
        SEND_P3_DATA(StartXSub, (rDest->left << 16));
        SEND_P3_DATA(StartY,    ((rDest->bottom - 1) << 16));
        SEND_P3_DATA(dY,        (DWORD)((-1) << 16));
    }
    else
    {
        // left to right, top to bottom
        SEND_P3_DATA(StartXDom, (rDest->left << 16));
        SEND_P3_DATA(StartXSub, (rDest->right << 16));
        SEND_P3_DATA(StartY,    (rDest->top << 16));
        SEND_P3_DATA(dY,        (1 << 16));
    }
    SEND_P3_DATA(Count, rDest->bottom - rDest->top );

    // Do the blt
    SEND_P3_DATA(Render, 
              P3RX_RENDER_PRIMITIVETYPE(P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID) 
            | P3RX_RENDER_FBSOURCEREADENABLE(__PERMEDIA_ENABLE));

    // Disable all the units that were switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );

    // Put back the values if we changed them.

    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
    
} // _DD_P3BltSourceChroma

//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstCh
//
//
// Does a blit through the texture unit to allow stretching.  Also
// handle mirroring if the stretched image requires it and doth dest and
// source chromakeying.  Can also YUV->RGB convert
//
// This is the generic rout - others will be optimisations of this
// (if necessary).
//
//
//-----------------------------------------------------------------------------
VOID 
_DD_P3BltStretchSrcChDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR fpSrcVidMem,
    P3_SURF_FORMAT* pFormatSource,    
    DWORD dwSrcPixelSize,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight,
    DWORD dwSrcPixelPitch,
    DWORD dwSrcPatchMode,    
    ULONG ulSrcOffsetFromMemBase,    
    DWORD dwSrcFlags,
    DDPIXELFORMAT*  pSrcDDPF,
    BOOL bIsSourceAGP,
    FLATPTR fpDestVidMem,   
    P3_SURF_FORMAT* pFormatDest,    
    DWORD dwDestPixelSize,
    DWORD dwDestWidth,
    DWORD dwDestHeight,
    DWORD dwDestPixelPitch,
    DWORD dwDestPatchMode,
    ULONG ulDestOffsetFromMemBase,
    DWORD dwBltFlags,
    DWORD dwBltDDFX,
    DDCOLORKEY BltSrcColorKey,
    DDCOLORKEY BltDestColorKey,
    RECTL *rSrc,
    RECTL *rDest)
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iXScale, iYScale;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   texSStart, texTStart;
    DWORD   dwRenderDirection;
    BOOL    bXMirror, bYMirror;
    BOOL    bFiltering;
    BOOL    bSrcKey, bDstKey;
    BOOL    bDisableLUT;
    int     iTemp;
    BOOL    b8to8blit;
    BOOL    bYUVMode;
    BOOL    bBlocking;
    DWORD   TR0;
    int     iTextureType;
    int     iPixelSize;
    int     iTextureFilterModeColorOrder;
    SurfFilterDeviceFormat  sfdfTextureFilterModeFormat;

    P3_DMA_DEFS();

    // Make local copies that we can mangle.
    rMySrc = *rSrc;
    rMyDest = *rDest;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3BltStretchSrcChDstCh", 
                               &rMySrc, &rMyDest))
    {
        // Nothing to be blitted
        return;
    }    
    
    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    bDisableLUT = FALSE;

    if (pFormatSource->DeviceFormat == SURF_YUV422)
    {
        bYUVMode = TRUE;
        // Always use ABGR for YUV;
        iTextureFilterModeColorOrder = 0;
    }
    else
    {
        bYUVMode = FALSE;
        iTextureFilterModeColorOrder = COLOR_MODE;
    }

    sfdfTextureFilterModeFormat = pFormatSource->FilterFormat;

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && 
         ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, 
        // since no LUT translation is involved.
        // Fake this up in a wacky way to stop the LUT
        // getting it's hands on it.
        sfdfTextureFilterModeFormat = SURF_FILTER_L8;
        bDisableLUT = TRUE;
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    }

    // Let's see if anyone uses this flag - might be good to get it working
    // now that we know what it means (use bilinear filtering instead of point).
    ASSERTDD ( ( dwBltFlags & DDBLTFX_ARITHSTRETCHY ) == 0,
                 "** _DD_P3BltStretchSrcChDstCh: DDBLTFX_ARITHSTRETCHY used");

    // Is this a stretch blit?
    if (((iSrcWidth != iDstWidth) || 
        (iSrcHeight != iDstHeight)) &&
        ((pFormatSource->DeviceFormat == SURF_YUV422)) )
    {
        bFiltering = TRUE;
    }
    else
    {
        bFiltering = FALSE;
    }

    if ( ( dwBltFlags & DDBLT_KEYSRCOVERRIDE ) != 0 )
    {
        bSrcKey = TRUE;
    }
    else
    {
        bSrcKey = FALSE;
    }

    if ( ( dwBltFlags & DDBLT_KEYDESTOVERRIDE ) != 0 )
    {
        bDstKey = TRUE;
    }
    else
    {
        bDstKey = FALSE;
    }


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(fpSrcVidMem, 
                                                 fpDestVidMem,
                                                 &rMySrc,
                                                 &rMyDest,
                                                 &bBlocking);

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwRenderDirection)
    {
        if(dwBltFlags & DDBLT_DDFX)
        {
            if(dwBltDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = dwSrcHeight - rMySrc.top;
                    rMySrc.top = dwSrcHeight - iTemp;
                }
                bYMirror = TRUE;
            }
            else
            { 
                bYMirror = FALSE;
            }
        
            if(dwBltDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = dwSrcWidth - rMySrc.left;
                    rMySrc.left = dwSrcWidth - iTemp;
                }
                bXMirror = TRUE;
            }
            else
            {
                bXMirror = FALSE;
            }
        }
        else
        {
            bXMirror = FALSE;
            bYMirror = FALSE;
        }
    }
    else
    {
        if(dwBltFlags & DDBLT_DDFX)
        {
            if(dwBltDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = dwSrcHeight - rMySrc.top;
                    rMySrc.top = dwSrcHeight - iTemp;
                }
                bYMirror = FALSE;
            }
            else
            {
                bYMirror = TRUE;
            }
        
            if(dwBltDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = dwSrcWidth - rMySrc.left;
                    rMySrc.left = dwSrcWidth - iTemp;
                }
                bXMirror = FALSE;
            }
            else
            {
                bXMirror = TRUE;
            }
        }
        else
        {
            // Not mirroring, but need to render from the other side.
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), 
               "_DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), 
               "_DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( ( iSrcWidth > 0 ) && ( iSrcHeight > 0 ) && 
               ( iDstWidth > 0 ) && ( iDstHeight > 0 ),
               "_DD_P3BltStretchSrcChDstCh: width or height negative" );
    if ( bFiltering )
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( ( (unsigned)iSrcWidth  ) << (32-MAGIC_NUMBER_2D) ) / 
                                                    (unsigned)( iDstWidth  ) );
        iYScale = ( ( ( (unsigned)iSrcHeight ) << (32-MAGIC_NUMBER_2D) ) / 
                                                    (unsigned)( iDstHeight ) );
    }
    else
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( (unsigned)iSrcWidth  << (32-MAGIC_NUMBER_2D)) / 
                                                    (unsigned)( iDstWidth ) );
        iYScale = ( ( (unsigned)iSrcHeight << (32-MAGIC_NUMBER_2D)) / 
                                                    (unsigned)( iDstHeight) );
    }


    if (bXMirror)       
    {
        texSStart = ( rMySrc.right - 1 ) << (32-MAGIC_NUMBER_2D);
        iXScale = -iXScale;
    }
    else
    {
        texSStart = rMySrc.left << (32-MAGIC_NUMBER_2D);
    }

    if (bYMirror)       
    {
        texTStart = ( rMySrc.bottom - 1 ) << (32-MAGIC_NUMBER_2D);
        iYScale = -iYScale;
    }
    else
    {
        texTStart = rMySrc.top << (32-MAGIC_NUMBER_2D);
    }

    // Move pixel centres to 0.5, 0.5.
    if ( bFiltering )
    {
        texSStart -= 1 << (31-MAGIC_NUMBER_2D);
        texTStart -= 1 << (31-MAGIC_NUMBER_2D);
    }

    DISPDBG((DBGLVL, "Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    P3_DMA_GET_BUFFER_ENTRIES(24);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize ));

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // The write buffer is the destination for the pixels
    SEND_P3_DATA(FBWriteBufferAddr0, ulDestOffsetFromMemBase);
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPixelPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_X( rMyDest.left )
                                    | P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.
    ASSERTDD ( pFormatDest->DitherFormat >= 0, 
               "_DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    // The colour format, order and conversion fields are used by the 
    // chroma keying, even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(26);

    // If there is only one chromakey needed, use the proper chromakey
    // This is mainly because the alphamap version doesn't work yet.
    if ( bDstKey )
    {
        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, 
                        P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                        );

        SEND_P3_DATA(ChromaLower, BltDestColorKey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, BltDestColorKey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, ulDestOffsetFromMemBase);
        SEND_P3_DATA(FBSourceReadBufferWidth, dwDestPixelPitch);
        SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBSOURCEREAD_LAYOUT(dwDestPatchMode)
                        );
    }
    else
    {
        // Don't need source reads - the source data comes from the texturemap
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));

        if ( bSrcKey )
        {
            DWORD   dwLowerSrcBound;
            DWORD   dwUpperSrcBound;

            // Source keying, no dest keying.
            // The conventional chroma test is set up to key off the source.
            // Note we are keying off the input from the texture here, so we use the INPUTCOLOR as the chroma test
            // source
            SEND_P3_DATA(ChromaTestMode, 
                          P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                          P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR) |
                          P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) |
                          P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
                          );

            if ( b8to8blit )
            {
                // No conversion, just use the index value in the R channel.
                dwLowerSrcBound = BltSrcColorKey.dwColorSpaceLowValue & 0x000000ff;
                dwUpperSrcBound = BltSrcColorKey.dwColorSpaceHighValue | 0xffffff00;
            }
            else
            {
                // Don't scale, do a shift instead.
                Get8888ScaledChroma(pThisDisplay,
                            dwSrcFlags,
                            pSrcDDPF,
                            BltSrcColorKey.dwColorSpaceLowValue,
                            BltSrcColorKey.dwColorSpaceHighValue,
                            &dwLowerSrcBound,
                            &dwUpperSrcBound,
                            NULL,                   // NULL palette
                            FALSE, 
                            TRUE);
            }

            DISPDBG((DBGLVL,"P3 Src Chroma: Upper = 0x%08x, Lower = 0x%08x", 
                            BltSrcColorKey.dwColorSpaceLowValue,
                            BltSrcColorKey.dwColorSpaceHighValue));

            DISPDBG((DBGLVL,"P3 Src Chroma(after): "
                            "Upper = 0x%08x, Lower = 0x%08x",
                            dwUpperSrcBound,
                            dwLowerSrcBound));

            SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
            SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);
        }
        else if ( !bSrcKey && !bDstKey )
        {
            // No chroma keying at all.
            SEND_P3_DATA(ChromaTestMode,
                            P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
        }
    }

    if ( bDstKey && bSrcKey )
    {
        DWORD   dwLowerSrcBound;
        DWORD   dwUpperSrcBound;

        if ( b8to8blit )
        {
            DISPDBG((ERRLVL,"Er... don't know what to do in this situation."));
        }

        // Enable source reads to get the colorkey color during dest colorkeys
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBSOURCEREAD_LAYOUT(dwDestPatchMode)
                     );

        // Don't scale, do a shift instead.
        Get8888ZeroExtendedChroma(pThisDisplay,
                        dwSrcFlags,
                        pSrcDDPF,
                        BltSrcColorKey.dwColorSpaceLowValue,
                        BltSrcColorKey.dwColorSpaceHighValue,
                        &dwLowerSrcBound,
                        &dwUpperSrcBound);

        // If both colourkeys are needed, the source keying is done by counting
        // chroma test fails in the texture filter unit.
        SEND_P3_DATA(TextureChromaLower0, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper0, dwUpperSrcBound);

        SEND_P3_DATA(TextureChromaLower1, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper1, dwUpperSrcBound);

        SEND_P3_DATA(TextureFilterMode, 
                  P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH ( P3RX_ALPHAMAPSENSE_INRANGE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0 ( bFiltering ? 3 : 0 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1 ( 4 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01 ( 8 )
                );
    }
    else
    {
        SEND_P3_DATA(TextureFilterMode, 
                  P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( iTextureFilterModeColorOrder )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                );
        // And now the alpha test (alpha test unit)
        SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(18);

    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, 
              P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH ( log2 ( dwDestWidth ) )
            | P3RX_TEXCOORDMODE_HEIGHT ( log2 ( dwDestHeight ) )
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    SEND_P3_DATA(SStart,        texSStart);
    SEND_P3_DATA(TStart,        texTStart);
    SEND_P3_DATA(dSdx,          iXScale);
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       iYScale);

    SEND_P3_DATA(TextureBaseAddr0, ulSrcOffsetFromMemBase);

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(32);

    if ( bYUVMode )
    {
        // Set up the YUV unit.
        SEND_P3_DATA ( YUVMode, P3RX_YUVMODE_ENABLE ( __PERMEDIA_ENABLE ) );
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_VYUY422;
        iPixelSize = P3RX_TEXREADMODE_TEXELSIZE_16;

        // The idea here is to do ((colorcomp - 16) * 1.14), but in YUV space
        // because the YUV unit comes after the texture composite unit.  

        SEND_P3_DATA(TextureCompositeMode, 
                        P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_ENABLE ));
            
        SEND_P3_DATA(TextureCompositeColorMode0, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0C)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        SEND_P3_DATA(TextureCompositeAlphaMode0, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0A)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        // This subtracts 16 from Y
        SEND_P3_DATA(TextureCompositeFactor0, ((0 << 24)  | 
                                               (0x0 << 16)| 
                                               (0x0 << 8) | 
                                               (0x10)       ));

        // This multiplies the channels by 0.57.
        SEND_P3_DATA(TextureCompositeFactor1, ((0x80 << 24) | 
                                               (0x80 << 16) | 
                                               (0x80 << 8)  | 
                                               (0x91)       ));

        SEND_P3_DATA(TextureCompositeColorMode1, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

        SEND_P3_DATA(TextureCompositeAlphaMode1, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));    
    }
    else
    {
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
        iPixelSize = dwSrcPixelSize;

        // Disable the composite units.
        SEND_P3_DATA(TextureCompositeMode, 
                        P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, 
          P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
        | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
        | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
        | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
        | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
        );


    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE ( iPixelSize )
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( 0 )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( iTextureType )
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;
    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, 
                    P3RX_TEXMAPWIDTH_WIDTH(dwSrcPixelPitch) |
                    P3RX_TEXMAPWIDTH_LAYOUT(dwSrcPatchMode) |
                    P3RX_TEXMAPWIDTH_HOSTTEXTURE(bIsSourceAGP));

    SEND_P3_DATA(TextureCacheReplacementMode,
              P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    if ( bDisableLUT )
    {
        SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    if ( bFiltering )
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }
    else
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }

    ASSERTDD ( pFormatDest->DitherFormat >= 0, 
               "_DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(10);
               
    if ( bFiltering )
    {
        // Filtering, so dither.
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }
    else
    {
        // No filter, no dither (though it doesn't actually matter).
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode)
                 );

    WAIT_FIFO(22);
    P3_ENSURE_DX_SPACE(22);
    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( (bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE))
            );

    // Disable all the things I switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );

    P3_ENSURE_DX_SPACE(20);
    WAIT_FIFO(20);
    
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeColorMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeColorMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // _DD_P3BltStretchSrcChDstCh

//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstCh_DD
//
// Stretch blit with source and destination chroma keying
// This version takes as parameters DDraw objects
//
//-----------------------------------------------------------------------------
VOID 
_DD_P3BltStretchSrcChDstCh_DD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest)
{
    _DD_P3BltStretchSrcChDstCh(pThisDisplay,
                               // pSource data elements
                               pSource->lpGbl->fpVidMem,
                               pFormatSource,                               
                               DDSurf_GetChipPixelSize(pSource),
                               (int)pSource->lpGbl->wWidth,
                               (int)pSource->lpGbl->wHeight,
                               DDSurf_GetPixelPitch(pSource),
                               P3RX_LAYOUT_LINEAR,
                               DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource),                                                              
                               pSource->dwFlags,
                               &pSource->lpGbl->ddpfSurface,    
                               DDSurf_IsAGP(pSource),
                               // pDest data elements
                               pDest->lpGbl->fpVidMem,
                               pFormatDest,                               
                               DDSurf_GetChipPixelSize(pDest),
                               (int)pDest->lpGbl->wWidth,
                               (int)pDest->lpGbl->wHeight,
                               DDSurf_GetPixelPitch(pDest),
                               P3RX_LAYOUT_LINEAR,
                               DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest),
                               // Others
                               lpBlt->dwFlags,
                               lpBlt->bltFX.dwDDFX,
                               lpBlt->bltFX.ddckSrcColorkey,
                               lpBlt->bltFX.ddckDestColorkey,
                               rSrc,
                               rDest);    
} // _DD_P3BltStretchSrcChDstCh_DD

//-----------------------------------------------------------------------------
//
// __P3BltDestOveride
//
//-----------------------------------------------------------------------------
VOID 
__P3BltDestOveride(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rSrc,
    RECTL *rDest,
    DWORD logicop, 
    DWORD dwDestPointer)
{
    DWORD   renderData;
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    DWORD   dwSourceOffset;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;
    DWORD   dwDestPatchMode, dwSourcePatchMode;

    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("__P3BltDestOveride", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(30);
    WAIT_FIFO(30); 

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(FBWriteBufferAddr0, dwDestPointer);
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);
    
    SEND_P3_DATA(FBSourceReadBufferAddr, 
                DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource));
    SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pSource));
    
    dwSourceOffset = (( rSrc->top - rDest->top ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);

    dwDestPatchMode = P3RX_LAYOUT_LINEAR;
    dwSourcePatchMode = P3RX_LAYOUT_LINEAR;
    
    SEND_P3_DATA(FBDestReadMode, 
                    P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE));

    SEND_P3_DATA(FBSourceReadMode, 
                    P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBSOURCEREAD_LAYOUT(dwSourcePatchMode) |
                    P3RX_FBSOURCEREAD_BLOCKING( bBlocking ));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));


    P3_ENSURE_DX_SPACE(16);
    WAIT_FIFO(16); 
    
    SEND_P3_DATA(RectanglePosition, 
                    P3RX_RECTANGLEPOSITION_Y(rDest->top) |
                    P3RX_RECTANGLEPOSITION_X(rDest->left));

    renderData =  
        P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )  |
        P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff ) |
        P3RX_RENDER2D_FBREADSOURCEENABLE(__PERMEDIA_ENABLE)           |
        P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )    |
        P3RX_RENDER2D_INCREASINGX( dwRenderDirection )                |
        P3RX_RENDER2D_INCREASINGY( dwRenderDirection );
                
    SEND_P3_DATA(Render2D, renderData);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
    
} // __P3BltDestOveride

//-----------------------------------------------------------------------------
//
// __P3BltStretchSrcChDstChSourceOveride
//
//-----------------------------------------------------------------------------
VOID
__P3BltStretchSrcChDstChSourceOveride(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest,
    DWORD dwNewSource
    )
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iXScale, iYScale;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   texSStart, texTStart;
    DWORD   dwRenderDirection;
    BOOL    bXMirror, bYMirror;
    BOOL    bFiltering;
    BOOL    bSrcKey, bDstKey;
    BOOL    bDisableLUT;
    BOOL    bBlocking;
    int     iTemp;
    BOOL    b8to8blit;
    BOOL    bYUVMode;
    DWORD   TR0;
    int     iTextureType;
    int     iPixelSize;
    int     iTextureFilterModeColorOrder;
        
    SurfFilterDeviceFormat  sfdfTextureFilterModeFormat;
    P3_DMA_DEFS();

    bDisableLUT = FALSE;

    // Make local copies that we can mangle.
    rMySrc = *rSrc;
    rMyDest = *rDest;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("__P3BltStretchSrcChDstChSourceOveride", 
                               &rMySrc, &rMyDest))
    {
        // Nothing to be blitted
        return;
    }    

    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    if (pFormatSource->DeviceFormat == SURF_YUV422)
    {
        bYUVMode = TRUE;
        // Always use ABGR for YUV;
        iTextureFilterModeColorOrder = 0;
    }
    else
    {
        bYUVMode = FALSE;
        iTextureFilterModeColorOrder = COLOR_MODE;
    }

    sfdfTextureFilterModeFormat = pFormatSource->FilterFormat;

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, since no LUT translation is involved.
        // Fake this up in a wacky way to stop the LUT
        // getting it's hands on it.
        sfdfTextureFilterModeFormat = SURF_FILTER_L8;
        bDisableLUT = TRUE;
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    }

    // Let's see if anyone uses this flag - might be good to get it working
    // now that we know what it means (use bilinear filtering instead of point).
    ASSERTDD ( ( lpBlt->dwFlags & DDBLTFX_ARITHSTRETCHY ) == 0, "** _DD_P3BltStretchSrcChDstCh: DDBLTFX_ARITHSTRETCHY used - please tell TomF" );

    // Is this a stretch blit?
    if (((iSrcWidth != iDstWidth) || 
        (iSrcHeight != iDstHeight)) &&
        ((pFormatSource->DeviceFormat == SURF_YUV422)))
    {
        bFiltering = TRUE;
    }
    else
    {
        bFiltering = FALSE;
    }

    if ( ( lpBlt->dwFlags & DDBLT_KEYSRCOVERRIDE ) != 0 )
    {
        bSrcKey = TRUE;
    }
    else
    {
        bSrcKey = FALSE;
    }

    if ( ( lpBlt->dwFlags & DDBLT_KEYDESTOVERRIDE ) != 0 )
    {
        bDstKey = TRUE;
    }
    else
    {
        bDstKey = FALSE;
    }


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 &rMySrc,
                                                 &rMyDest,
                                                 &bBlocking);

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwRenderDirection)
    {
        if(lpBlt->dwFlags & DDBLT_DDFX)
        {
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = pSource->lpGbl->wHeight - rMySrc.top;
                    rMySrc.top = pSource->lpGbl->wHeight - iTemp;
                }
                bYMirror = TRUE;
            }
            else
            { 
                bYMirror = FALSE;
            }
        
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = pSource->lpGbl->wWidth - rMySrc.left;
                    rMySrc.left = pSource->lpGbl->wWidth - iTemp;
                }
                bXMirror = TRUE;
            }
            else
            {
                bXMirror = FALSE;
            }
        }
        else
        {
            bXMirror = FALSE;
            bYMirror = FALSE;
        }
    }
    else
    {
        if(lpBlt->dwFlags & DDBLT_DDFX)
        {
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = pSource->lpGbl->wHeight - rMySrc.top;
                    rMySrc.top = pSource->lpGbl->wHeight - iTemp;
                }
                bYMirror = FALSE;
            }
            else
            {
                bYMirror = TRUE;
            }
        
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = pSource->lpGbl->wWidth - rMySrc.left;
                    rMySrc.left = pSource->lpGbl->wWidth - iTemp;
                }
                bXMirror = FALSE;
            }
            else
            {
                bXMirror = TRUE;
            }
        }
        else
        {
            // Not mirroring, but need to render from the other side.
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), "** _DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), "** _DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( ( iSrcWidth > 0 ) && ( iSrcHeight > 0 ) && ( iDstWidth > 0 ) && ( iDstHeight > 0 ), "** _DD_P3BltStretchSrcChDstCh: width or height negative" );
    if ( bFiltering )
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( ( (unsigned)iSrcWidth  ) << (32-MAGIC_NUMBER_2D) ) / (unsigned)( iDstWidth  ) );
        iYScale = ( ( ( (unsigned)iSrcHeight ) << (32-MAGIC_NUMBER_2D) ) / (unsigned)( iDstHeight ) );
    }
    else
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( (unsigned)iSrcWidth  << (32-MAGIC_NUMBER_2D)) / (unsigned)( iDstWidth ) );
        iYScale = ( ( (unsigned)iSrcHeight << (32-MAGIC_NUMBER_2D)) / (unsigned)( iDstHeight) );
    }


    if (bXMirror)       
    {
        texSStart = ( rMySrc.right - 1 ) << (32-MAGIC_NUMBER_2D);
        iXScale = -iXScale;
    }
    else
    {
        texSStart = rMySrc.left << (32-MAGIC_NUMBER_2D);
    }

    if (bYMirror)       
    {
        texTStart = ( rMySrc.bottom - 1 ) << (32-MAGIC_NUMBER_2D);
        iYScale = -iYScale;
    }
    else
    {
        texTStart = rMySrc.top << (32-MAGIC_NUMBER_2D);
    }

    // Move pixel centres to 0.5, 0.5.
    if ( bFiltering )
    {
        texSStart -= 1 << (31-MAGIC_NUMBER_2D);
        texTStart -= 1 << (31-MAGIC_NUMBER_2D);
    }

    DISPDBG((DBGLVL, "Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    P3_DMA_GET_BUFFER_ENTRIES(24);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // The write buffer is the destination for the pixels
    SEND_P3_DATA(FBWriteBufferAddr0, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_X( rMyDest.left )
                                    | P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.
    ASSERTDD ( pFormatDest->DitherFormat >= 0, "** _DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    // The colour format, order and conversion fields are used by the chroma keying,
    // even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
    SEND_P3_DATA(AlphaBlendAlphaMode,   P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    // If there is only one chromakey needed, use the proper chromakey
    // This is mainly because the alphamap version doesn't work yet.
    if ( bDstKey )
    {
        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                                        );

        SEND_P3_DATA(ChromaLower, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
        SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pDest));
        SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));
    }
    else
    {
        // Don't need source reads - the source data comes from the texturemap
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));

        if ( bSrcKey )
        {
            DWORD   dwLowerSrcBound = 0;
            DWORD   dwUpperSrcBound = 0;

            // Source keying, no dest keying.
            // The conventional chroma test is set up to key off the source.
            // Note we are keying off the input from the texture here, so we use the INPUTCOLOR as the chroma test
            // source
            SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR) |
                                            P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) |
                                            P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
                                            );

            if ( b8to8blit )
            {
                // No conversion, just use the index value in the R channel.
                dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue & 0x000000ff;
                dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue | 0xffffff00;
            }
            else
            {
                // Don't scale, do a shift instead.
                Get8888ScaledChroma(pThisDisplay,
                            pSource->dwFlags,
                            &pSource->lpGbl->ddpfSurface,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                            &dwLowerSrcBound,
                            &dwUpperSrcBound,
                            NULL,                   // NULL palette
                            FALSE, 
                            TRUE);
            }

            DISPDBG((DBGLVL,"P3 Src Chroma: Upper = 0x%08x, Lower = 0x%08x", 
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue));

            DISPDBG((DBGLVL,"P3 Src Chroma(after): "
                            "Upper = 0x%08x, Lower = 0x%08x",
                            dwUpperSrcBound,
                            dwLowerSrcBound));

            SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
            SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);
        }
        else if ( !bSrcKey && !bDstKey )
        {
            // No chroma keying at all.
            SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
        }
    }

    if ( bDstKey && bSrcKey )
    {
        DWORD   dwLowerSrcBound;
        DWORD   dwUpperSrcBound;

        if ( b8to8blit )
        {
            DISPDBG((ERRLVL,"Er... don't know what to do in this situation."));
        }

        // Enable source reads to get the colorkey color during dest colorkeys
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));

        // Don't scale, do a shift instead.
        Get8888ZeroExtendedChroma(pThisDisplay,
                        pSource->dwFlags,
                        &pSource->lpGbl->ddpfSurface,
                        lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                        lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                        &dwLowerSrcBound,
                        &dwUpperSrcBound);

        // If both colourkeys are needed, the source keying is done by counting
        // chroma test fails in the texture filter unit.
        SEND_P3_DATA(TextureChromaLower0, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper0, dwUpperSrcBound);

        SEND_P3_DATA(TextureChromaLower1, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper1, dwUpperSrcBound);

        SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH ( P3RX_ALPHAMAPSENSE_INRANGE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0 ( bFiltering ? 3 : 0 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1 ( 4 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01 ( 8 )
                );
    }
    else
    {
        SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( iTextureFilterModeColorOrder )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                );
        // And now the alpha test (alpha test unit)
        SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH ( log2 ( (int)pDest->lpGbl->wWidth ) )
            | P3RX_TEXCOORDMODE_HEIGHT ( log2 ( (int)pDest->lpGbl->wHeight ) )
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    SEND_P3_DATA(SStart,        texSStart);
    SEND_P3_DATA(TStart,        texTStart);
    SEND_P3_DATA(dSdx,          iXScale);
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       iYScale);

    SEND_P3_DATA(TextureBaseAddr0, dwNewSource);
    if ( bYUVMode )
    {
        // Set up the YUV unit.
        SEND_P3_DATA ( YUVMode, P3RX_YUVMODE_ENABLE ( __PERMEDIA_ENABLE ) );
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_VYUY422;
        iPixelSize = P3RX_TEXREADMODE_TEXELSIZE_16;

        // The idea here is to do ((colorcomp - 16) * 1.14), but in YUV space because the
        // YUV unit comes after the texture composite unit.  The reason for this change is
        // to make our YUV conversion more like the ATI conversion.  It isn't more correct this way, 
        // just different, but the WHQL tests were probably written on the ATI card and our colors
        // aren't close enough to match what they do so we fail the test
        SEND_P3_DATA(TextureCompositeMode, P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_ENABLE ));
            
        SEND_P3_DATA(TextureCompositeColorMode0, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0C)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        SEND_P3_DATA(TextureCompositeAlphaMode0, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0A)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        // This subtracts 16 from Y
        SEND_P3_DATA(TextureCompositeFactor0, ((0 << 24) | (0x0 << 16) | (0x0 << 8) | 0x10));

        // This multiplies the channels by 0.57.
        SEND_P3_DATA(TextureCompositeFactor1, ((0x80 << 24) | (0x80 << 16) | (0x80 << 8) | 0x91));

        SEND_P3_DATA(TextureCompositeColorMode1, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

        SEND_P3_DATA(TextureCompositeAlphaMode1, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

    
    }
    else
    {
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
        iPixelSize = DDSurf_GetChipPixelSize(pSource);

        // Disable the composite units.
        SEND_P3_DATA(TextureCompositeMode, P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(24);

    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
        | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
        | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
        | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
        | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
        );


    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE ( iPixelSize )
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( iTextureType )
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;
    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, P3RX_TEXMAPWIDTH_WIDTH(DDSurf_GetPixelPitch(pSource)) |
                                    P3RX_TEXMAPWIDTH_LAYOUT(P3RX_LAYOUT_LINEAR) |
                                    P3RX_TEXMAPWIDTH_HOSTTEXTURE(DDSurf_IsAGP(pSource)));

    SEND_P3_DATA(TextureCacheReplacementMode,
            P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    if ( bDisableLUT )
    {
        SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    if ( bFiltering )
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }
    else
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }

    ASSERTDD ( pFormatDest->DitherFormat >= 0, "** _DD_P3BltStretchSrcChDstCh: Destination format illegal" );
    if ( bFiltering )
    {
        // Filtering, so dither.
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }
    else
    {
        // No filter, no dither (though it doesn't actually matter).
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));

    WAIT_FIFO(32);
    P3_ENSURE_DX_SPACE(32);
    
    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( (bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE))
            );

    // Disable all the things I switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );

    WAIT_FIFO(20);
    P3_ENSURE_DX_SPACE(20);
    
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeColorMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeColorMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // __P3BltStretchSrcChDstChSourceOveride


//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstChOverlap
//
//-----------------------------------------------------------------------------
void 
_DD_P3BltStretchSrcChDstChOverlap(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest)
{
    P3_MEMREQUEST mmrq;
    DWORD dwResult;
    
    ZeroMemory(&mmrq, sizeof(P3_MEMREQUEST));
    mmrq.dwSize = sizeof(P3_MEMREQUEST);
    mmrq.dwBytes = DDSurf_Pitch(pSource) * DDSurf_Height(pSource);
    mmrq.dwAlign = 16;
    mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;

    dwResult = _DX_LIN_AllocateLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                            &mmrq);
    if (dwResult != GLDD_SUCCESS)
    {
        // Couldn't get the memory, so try anyway.  It probably won't look 
        // right but it is our best shot...
        DISPDBG((WRNLVL,"Overlapped stretch blit unlikely to look correct!"));
        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                      pSource, 
                                      pDest, 
                                      pFormatSource, 
                                      pFormatDest, 
                                      lpBlt, 
                                      rSrc, 
                                      rDest);
        return;
    }

    // Copy the source buffer to a temporary place.
    __P3BltDestOveride(pThisDisplay, 
                       pSource, 
                       pSource, 
                       pFormatSource, 
                       pFormatSource, 
                       rSrc, 
                       rSrc, 
                       __GLINT_LOGICOP_COPY, 
                       (long)mmrq.pMem - (long)pThisDisplay->dwScreenFlatAddr);

    // Do the blit, stretching to our temporary buffer
    __P3BltStretchSrcChDstChSourceOveride(pThisDisplay, 
                                          pSource, 
                                          pDest, 
                                          pFormatSource, 
                                          pFormatDest, 
                                          lpBlt, 
                                          rSrc, 
                                          rDest, 
                                          (long)mmrq.pMem - 
                                                (long)pThisDisplay->dwScreenFlatAddr);

    // Free the allocated source buffer.
    _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                             mmrq.pMem);
                             
} // _DD_P3BltStretchSrcChDstChOverlap

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// Function: P3RX_AA_Shrink
//
// Does a 2x2 to 1x1 blit through the texture unit to shrink an AA buffer
//
//-----------------------------------------------------------------------------
VOID P3RX_AA_Shrink(P3_D3DCONTEXT* pContext)
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   TR0;
    int     iSourcePixelSize;
        
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    P3_SURF_INTERNAL* pSurf = pContext->pSurfRenderInt;

    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest = pSurf->pFormatSurface;

    P3_DMA_DEFS();

    rMySrc.top = 0;
    rMySrc.bottom = pSurf->wHeight * 2;
    rMySrc.left = 0;
    rMySrc.right = pSurf->wWidth * 2;

    rMyDest.top = 0;
    rMyDest.left = 0;
    rMyDest.right = pSurf->wWidth;
    rMyDest.bottom = pSurf->wHeight;

    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), 
               "P3RX_AA_Shrink: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), 
               "P3RX_AA_Shrink: MAGIC_NUMBER_2D is too small" );
    
    DISPDBG((DBGLVL, "Glint Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    iSourcePixelSize = pSurf->dwPixelSize;
    pFormatSource = pFormatDest;

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // Source read is same as write.
    SEND_P3_DATA(FBSourceReadBufferAddr, pSurf->lOffsetFromMemoryBase );
    SEND_P3_DATA(FBSourceReadBufferWidth, pSurf->dwPixelPitch);
    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(pSurf->dwPatchMode));

    // No offset - we read the dest pixels so that we can chroma-key off them.
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, pSurf->dwPixelSize);
    SEND_P3_DATA(RectanglePosition, 
                        P3RX_RECTANGLEPOSITION_X( rMyDest.left ) |
                        P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_NORMAL )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_DISABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_AREASTIPPLEENABLE( __PERMEDIA_DISABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.

    // The colour format, order and conversion fields are used by the 
    // chroma keying, even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE ) 
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // No chroma keying at all.
    SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
    
    SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXFILTERMODE_FORMATBOTH ( pFormatSource->FilterFormat )
            | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
            | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
            | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_DISABLE )
            );

    // And now the alpha test (alpha test unit)
    SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, 
              P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH (0)       // Only used for mipmapping 
            | P3RX_TEXCOORDMODE_HEIGHT (0)
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    SEND_P3_DATA(SStart,        (1 << (31-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(TStart,        (1 << (31-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(dSdx,          (2 << (32-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       (2 << (32-MAGIC_NUMBER_2D)));

    SEND_P3_DATA(LBWriteMode, 0);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(TextureBaseAddr0, 
                    pContext->dwAliasBackBuffer - 
                            pThisDisplay->dwScreenFlatAddr );

    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE (iSourcePixelSize)
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( P3RX_TEXREADMODE_TEXTURETYPE_NORMAL)
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;

    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, 
                        P3RX_TEXMAPWIDTH_WIDTH(pSurf->dwPixelPitch * 2) |
                        P3RX_TEXMAPWIDTH_LAYOUT(pSurf->dwPatchMode));

    SEND_P3_DATA(TextureCacheReplacementMode,
              P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture index unit
    SEND_P3_DATA(TextureIndexMode0, 
              P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
            | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
            | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
            | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
            | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
            | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
            | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
            | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
            | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
            | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
            );

    // Disable the composite units.
    SEND_P3_DATA(TextureCompositeMode, 
                    P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    
    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, 
              P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
            | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
            | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
            | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
            | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
            );

    // Filtering, so dither.
    SEND_P3_DATA(DitherMode, 
              P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
            | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_DITHERMODE_XOFFSET ( 0 )
            | P3RX_DITHERMODE_YOFFSET ( 0 )
            | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
            | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
            | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(FBWriteBufferAddr0, pSurf->lOffsetFromMemoryBase );
    SEND_P3_DATA(FBWriteBufferWidth0, pSurf->dwPixelPitch);

    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( __PERMEDIA_DISABLE)
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    // Disable all the units that were switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // P3RX_AA_Shrink
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddsurf.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddsurf.c
*
* Content: DirectDraw surfaces creation/destructions callbacks
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
// This file needs the surface format table
#include "glint.h"
#include "dma.h"

// This enum is used to lookup the correct entry in the table
// for all the surface types the HAL cares about
typedef enum tagDeviceFormatNum
{
    HAL_8888_ALPHA = 0,
    HAL_8888_NOALPHA = 1,
    HAL_5551_ALPHA = 2,
    HAL_5551_NOALPHA = 3,
    HAL_4444 = 4,
    HAL_332 = 10,
    HAL_2321 = 18,
    HAL_CI8 = 28,
    HAL_CI4 = 29,
    HAL_565 = 30,
    HAL_YUV444 = 34,
    HAL_YUV422 = 35,
    HAL_L8 = 36,
    HAL_A8L8 = 37,
    HAL_A4L4 = 38,
    HAL_A8 = 39,
    HAL_MVCA = 40,
    HAL_MVSU = 41,
    HAL_MVSB = 42,
    HAL_UNKNOWN = 255,
} DeviceFormatNum;

static P3_SURF_FORMAT SurfaceFormats[MAX_SURFACE_FORMATS] =
{
    // If there are multiple formats, the one with the alpha is listed first.
    // Format 0 (32 bit 8888)            // Always 3 components for 888(8) textures.            Red     Green   Blue   Alpha       bAlpha, P3RX Filter format
    /* 0 */ {SURF_8888, 32, __GLINT_32BITPIXEL, RGBA_COMPONENTS, LOG_2_32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_8888, "R8G8B8A8" },
    /* 1 */ {SURF_8888, 32, __GLINT_32BITPIXEL, RGBA_COMPONENTS, LOG_2_32, 0xFF0000, 0xFF00, 0xFF, 0x00000000, FALSE, SURF_FILTER_888, SURF_DITHER_8888, "R8G8B8x8" },

    // Format 1 (16 bit 5551)
    /* 2 */ {SURF_5551_FRONT, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0x7C00, 0x03E0, 0x001F, 0x8000, TRUE, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5A1" },
    /* 3 */ {SURF_5551_FRONT, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0x7C00, 0x03E0, 0x001F, 0x0, FALSE, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5x1" },

    // Format 2 (16 bit 4444)
    /* 4 */ {SURF_4444, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0xF00, 0xF0, 0xF, 0xF000, TRUE, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 5 */ {SURF_4444, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0xF00, 0xF0, 0xF, 0xF000, TRUE, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 3 (16 bit 4444 Front)
    /* 6 */ {SURF_4444_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 7 */ {SURF_4444_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 4 (16 bit 4444 Back)
    /* 8 */ {SURF_4444_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 9 */ {SURF_4444_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 5 (8 bit 332 Front)
    /* 10 */ {SURF_332_FRONT, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0xE0, 0x1C, 0x3, 0, FALSE, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    /* 11 */ {SURF_332_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },

    // Format 6 (8 bit 332 back)
    /* 12 */ {SURF_332_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    /* 13 */ {SURF_332_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    
    // Format 7 (4 bit 121 front)
    /* 14 */ {SURF_121_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },
    /* 15 */ {SURF_121_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },

    // Format 8 (4 bit 121 back)
    /* 16 */ {SURF_121_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },
    /* 17 */ {SURF_121_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },

    // Format 9 (8 bit 2321 front)
    /* 18 */ {SURF_2321_FRONT, 8, __GLINT_8BITPIXEL, RGBA_COMPONENTS, LOG_2_8, 0xC0, 0x38, 0x6, 0x1, TRUE, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2A1" },
    /* 19 */ {SURF_2321_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 10 (8 bit 2321 back)
    /* 20 */ {SURF_2321_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2A1" },
    /* 21 */ {SURF_2321_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 11 (8 bit 232 front off)
    /* 22 */ {SURF_232_FRONTOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },
    /* 23 */ {SURF_232_FRONTOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 12 (8 bit 232 back off)
    /* 24 */ {SURF_232_BACKOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },
    /* 25 */ {SURF_232_BACKOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 13 (5551 back)
    /* 26 */ {SURF_5551_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5A1" },
    /* 27 */ {SURF_5551_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5x1" },

    // Format 14 (CI8)
    /* 28 */ {SURF_CI8, 8, __GLINT_8BITPIXEL, RGBA_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_I8, "I8" },
    
    // Format 15 (CI4)
    /* 29 */ {SURF_CI4, 4, __GLINT_4BITPIXEL, RGBA_COMPONENTS, LOG_2_4, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "I4" },
    
    // Format 16 (565 front)
    /* 30 */ {SURF_565_FRONT, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0xF800, 0x07E0, 0x001F, 0, FALSE, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },
    /* 31 */ {SURF_565_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },

    // Format 17 (565 back)
    /* 32 */ {SURF_565_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },
    /* 33 */ {SURF_565_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },

    // Format 18 (YUV 444)
    /* 34 */ {SURF_YUV444, 32, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "YUV444" },
    
    // Format 19 (YUV 422)
    /* 35 */ {SURF_YUV422, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, FALSE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "YUV422" },

    // Format 100 (L8)
    /* 36 */ {SURF_L8, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, FALSE, SURF_FILTER_L8, SURF_DITHER_INVALID, "L8" },

    // Format 101 (A8L8)
    /* 37 */ {SURF_A8L8, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0, 0, 0, 0, TRUE, SURF_FILTER_A8L8, SURF_DITHER_INVALID, "A8L8" },

    // Format 102 (A4L4)
    /* 38 */ {SURF_A4L4, 16, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_A4L4, SURF_DITHER_INVALID, "A4L4" },

    // Format 103 (A8)
    /* 39 */ {SURF_A8, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_A8, SURF_DITHER_INVALID, "A8" },

    // Format 104 (A8) MVCA
    /* 40 */ {SURF_MVCA, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVCA" },

    // Format 105 (A8) MVSU
    /* 41 */ {SURF_MVSU, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVSU" },

    // Format 106 (A8) MVSB
    /* 42 */ {SURF_MVSB, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVSB" }

};

#define MAKE_DWORD_ALIGNED(n)   ( ((n) % 4) ? ((n) + 4 - ((n) % 4)) : (n) )
#define MAKE_QWORD_ALIGNED(n)   ( ((n) % 8) ? ((n) + 8 - ((n) % 8)) : (n) )

//-----------------------------------------------------------------------------
//
// _DD_SUR_GetSurfaceFormat
//
//-----------------------------------------------------------------------------
P3_SURF_FORMAT* 
_DD_SUR_GetSurfaceFormat(
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    DeviceFormatNum HALDeviceFormat = HAL_UNKNOWN; // The default

    if (pLcl)
    {
        DDPIXELFORMAT* pPixFormat = DDSurf_GetPixelFormat(pLcl);
        if (pPixFormat->dwFlags & DDPF_FOURCC)
        {
            switch( pPixFormat->dwFourCC)
            {
            case FOURCC_MVCA:
                HALDeviceFormat = HAL_MVCA;
                break;
                
            case FOURCC_MVSU:
                HALDeviceFormat = HAL_MVSU;
                break;
                
            case FOURCC_MVSB:
                HALDeviceFormat = HAL_MVSB;
                break;
                
            case FOURCC_YUV422:
                HALDeviceFormat = HAL_YUV422;
                break;
                
            case FOURCC_YUV411:
                HALDeviceFormat = HAL_YUV444;
                break;
            } //switch
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4)
        {
            HALDeviceFormat = HAL_CI4;  
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
        {
            HALDeviceFormat = HAL_CI8;  
        }
        else if (pPixFormat->dwFlags & DDPF_LUMINANCE)
        {
            switch(pPixFormat->dwRGBBitCount)
            {
            case 8:
                if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
                {
                    HALDeviceFormat = HAL_A4L4;
                }
                else
                {
                    HALDeviceFormat = HAL_L8;
                }
                break;
                
            case 16:
                HALDeviceFormat = HAL_A8L8;
                break;
                
            default:
                HALDeviceFormat = HAL_UNKNOWN;
                break;
            } // switch
        }
        else if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            // Alpha only format
            switch(pPixFormat->dwAlphaBitDepth)
            {
            case 8:
                HALDeviceFormat = HAL_A8;
                break;
                
            default:
                HALDeviceFormat = HAL_UNKNOWN;
                break;
            }
        }
        else
        {
            switch(pPixFormat->dwRGBBitCount)
            {
            case 32:
            case 24:
                if (pPixFormat->dwRGBAlphaBitMask != 0)
                {
                    HALDeviceFormat = HAL_8888_ALPHA;   
                }
                else
                {
                    HALDeviceFormat = HAL_8888_NOALPHA; 
                }
                break;
                
            case 16:
                switch (pPixFormat->dwRBitMask)
                {
                case 0xf00:
                    HALDeviceFormat = HAL_4444;
                    break;
                    
                case 0x7c00:
                    if (pPixFormat->dwRGBAlphaBitMask != 0)
                    {
                        HALDeviceFormat = HAL_5551_ALPHA;
                    }
                    else
                    {
                        HALDeviceFormat = HAL_5551_NOALPHA;
                    }
                    break;
                    
                default:
                    HALDeviceFormat = HAL_565;
                    break;
                    
                }
                break;
                
            case 8:
                if (pPixFormat->dwRBitMask != 0xE0)
                {
                    HALDeviceFormat = HAL_2321;
                }
                else
                {
                    HALDeviceFormat = HAL_332;
                }
                break;
                
            case 0:
                HALDeviceFormat = HAL_CI8;
                break;
            default:
                DISPDBG((ERRLVL,"_DD_SUR_GetSurfaceFormat: "
                            "Invalid Surface Format"));
                break;
            } // switch
        } // if
    }

#if DBG
    if (HALDeviceFormat == HAL_UNKNOWN)
    {
        DISPDBG((ERRLVL,"ERROR: Failed to pick a valid surface format!"));
    }

    if(SurfaceFormats[HALDeviceFormat].dwBitsPerPixel == 0)
    {
        DISPDBG((ERRLVL,"ERROR: Chosen surface format that isn't defined "
                    "in the table!"));
    }
#endif // DBG

    if (HALDeviceFormat == HAL_UNKNOWN)
    {
        // Don't know what it is - return a valid type.
        return &SurfaceFormats[0];
    }
    else
    {
        // Return a pointer to the correct line in the table
        return &SurfaceFormats[HALDeviceFormat];
    }
} // _DD_SUR_GetSurfaceFormat

//---------------------------------------------------------------------------
// BOOL __SUR_bComparePixelFormat
//
// Function used to compare 2 pixels formats for equality. This is a 
// helper function to __SUR_bCheckTextureFormat. A return value of TRUE 
// indicates equality
//
//---------------------------------------------------------------------------
BOOL 
__SUR_bComparePixelFormat(
    LPDDPIXELFORMAT lpddpf1, 
    LPDDPIXELFORMAT lpddpf2)
{
    if (lpddpf1->dwFlags != lpddpf2->dwFlags)
    {
        return FALSE;
    }

    // same bitcount for non-YUV surfaces?
    if (!(lpddpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)))
    {
        if (lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
        {
            return FALSE;
        }
    }

    // same RGB properties?
    if (lpddpf1->dwFlags & DDPF_RGB)
    {
        if ((lpddpf1->dwRBitMask != lpddpf2->dwRBitMask) ||
            (lpddpf1->dwGBitMask != lpddpf2->dwGBitMask) ||
            (lpddpf1->dwBBitMask != lpddpf2->dwBBitMask) ||
            (lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask))
        { 
             return FALSE;
        }
    }
    
    // same YUV properties?
    if (lpddpf1->dwFlags & DDPF_YUV)	
    {
        if ((lpddpf1->dwFourCC != lpddpf2->dwFourCC) ||
            (lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount) ||
            (lpddpf1->dwYBitMask != lpddpf2->dwYBitMask) ||
            (lpddpf1->dwUBitMask != lpddpf2->dwUBitMask) ||
            (lpddpf1->dwVBitMask != lpddpf2->dwVBitMask) ||
            (lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask))
        {
             return FALSE;
        }
    }
    else if (lpddpf1->dwFlags & DDPF_FOURCC)
    {
        if (lpddpf1->dwFourCC != lpddpf2->dwFourCC)
        {
            return FALSE;
        }
    }

    // If Interleaved Z then check Z bit masks are the same
    if (lpddpf1->dwFlags & DDPF_ZPIXELS)
    {
        if (lpddpf1->dwRGBZBitMask != lpddpf2->dwRGBZBitMask)
        {
            return FALSE;
        }
    }

    return TRUE;
} // __SUR_bComparePixelFormat

//---------------------------------------------------------------------------
//
// BOOL __SUR_bCheckTextureFormat
//
// Function used to determine if a texture format is supported. It traverses 
// the deviceTextureFormats list. We use this in DdCanCreateSurface. A
// return value of TRUE indicates that we do support the requested texture 
// format.
//
//---------------------------------------------------------------------------

BOOL 
__SUR_bCheckTextureFormat(
    P3_THUNKEDDATA *pThisDisplay, 
    LPDDPIXELFORMAT lpddpf)
{
    DWORD i;

    // Run the list for a matching format , we already built the list (when
    // the driver was loaded) and stored it in pThisDisplay with 
    // __D3D_BuildTextureFormatsP3 in  _D3DHALCreateDriver (d3d.c)

    // Notice the special handling for paletted textures as described in
    // __D3D_BuildTextureFormatsP3 (thats why we loop until <= , not just
    // until < ).
    
    for (i=0; i <= pThisDisplay->dwNumTextureFormats; i++)
    {
        if (__SUR_bComparePixelFormat(
                    lpddpf, 
                    &pThisDisplay->TextureFormats[i].ddpfPixelFormat))
        {
            return TRUE;
        }   
    }

    return FALSE;
} // __SUR_bCheckTextureFormat

//---------------------------------------------------------------------------
//
// DWORD __SUR_bSurfPlacement
//
// Function used to determine if a surface should be placed at the front or
// at the back of our video memory heap. 
// Returns the MEM3DL_FRONT and MEM3DL_BACK values.
//
//---------------------------------------------------------------------------
DWORD
__SUR_bSurfPlacement(
    LPDDRAWI_DDRAWSURFACE_LCL psurf,
    DDSURFACEDESC *lpDDSurfaceDesc)
{
    static BOOL  bBufferToggle = TRUE;
    DWORD dwResult;
    
    if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        DWORD dwTexturePlacement;

        // They might have passed a DDSD2 in a DDSD1 structure.
        if (lpDDSurfaceDesc && (lpDDSurfaceDesc->dwSize == 
            sizeof(DDSURFACEDESC2)))
        {
            DDSURFACEDESC2* pDesc2 = 
                                (DDSURFACEDESC2*)lpDDSurfaceDesc;
            
            // Check for the application hint on texture stage placement
            if (!(pDesc2->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
            {
                if (pDesc2->dwFlags & DDSD_TEXTURESTAGE)
                {
                    dwTexturePlacement = pDesc2->dwTextureStage;

                    // Put it somewhere sensible if it 
                    // is in a large stage number
                    if (dwTexturePlacement > 1)
                    {
                        // Toggle all entries above 1 so that they 
                        // jump between banks.
                        dwTexturePlacement = 
                                        (dwTexturePlacement ^ 1) & 0x1;
                    }
                }
                else
                {
                    // No stage hint.  PingPong
                    dwTexturePlacement = bBufferToggle;
                    bBufferToggle = !bBufferToggle;
                }
            }
            else
            {
                // No stage hint.  PingPong
                dwTexturePlacement = bBufferToggle;
                bBufferToggle = !bBufferToggle;
            }
        }
        else
        {
            // No DDSD2, PingPong
            dwTexturePlacement = bBufferToggle;
            bBufferToggle = !bBufferToggle;
        }

        // Jump up and down in the one heap
        if (dwTexturePlacement == 0)
        {
            dwResult = MEM3DL_FRONT;
        }
        else
        {
            dwResult = MEM3DL_BACK;
        }
    }
    // Not a texture
    else
    {
        dwResult = MEM3DL_FRONT;
    }

    return dwResult;
    
} // __SUR_bSurfPlacement
//-----------------------------Public Routine----------------------------------
//
// DdCanCreateSurface
//
// Indicates whether the driver can create a surface of the specified 
// surface description
//
// DdCanCreateSurface should check the surface description to which 
// lpDDSurfaceDesc points to determine if the driver can support the format and
// capabilities of the requested surface for the mode that the driver is 
// currently in. The driver should return DD_OK in ddRVal if it supports the 
// surface; otherwise, it should return the DDERR_Xxx error code that best 
// describes why it does not support the surface.
//
// The bIsDifferentPixelFormat member is unreliable for z-buffers. Drivers 
// should use bIsDifferentPixelFormat only when they have first checked that 
// the specified surface is not a z-buffer. Drivers can perform this check by
// determining whether the DDSCAPS_ZBUFFER flag is set in lpDDSurfaceDesc
// ddsCaps.dwCaps.
//
// Parameters
//
//      pccsd
//          Points to the DD_CANCREATESURFACEDATA structure containing the 
//          information required for the driver to determine whether a surface 
//          can be created. 
//  
//          .lpDD 
//               Points to the DD_DIRECTDRAW_GLOBAL structure representing the
//               DirectDraw object. 
//          .lpDDSurfaceDesc 
//               Points to a DDSURFACEDESC structure that contains a 
//               description of the surface to be created. 
//          .bIsDifferentPixelFormat 
//               Indicates whether the pixel format of the surface to be 
//               created differs from the primary surface. 
//          .ddRVal 
//               Specifies the location in which the driver writes the return 
//               value of the DdCanCreateSurface callback. A return code of 
//               DD_OK indicates success. 
//          .CanCreateSurface 
//               This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdCanCreateSurface( 
    LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdCanCreateSurface);
    
    GET_THUNKEDDATA(pThisDisplay, pccsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    // ************************* Z BUFFERS *******************************
    // We support 15,16,24 and 32 bits Z-buffers 
    // (wo accounting for stencil bits) on PERMEDIA3
    if ((pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) &&
        (pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {  
        DWORD dwZBitDepth;

        // Check out the case of a z buffer with a pixel format

        // Complex surfaces aren't allowed to have stencil bits.  In 
        // this case we take the pixel z depth from the old place - the 
        // surface desc.
        if ((pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) ||
            (pccsd->lpDDSurfaceDesc->dwFlags & DDSD_ZBUFFERBITDEPTH) )
        {
            dwZBitDepth = pccsd->lpDDSurfaceDesc->dwZBufferBitDepth;
        }
        else
        {
            // On DX 6 the Z Bit depth is stored in the Pixel Format.
            dwZBitDepth = 
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwZBufferBitDepth;
        }

        // Notice we have to check for a dwZBitDepth of 16 or 32 even if a 
        // stencil buffer is present. dwZBufferBitDepth in this case will be 
        // the sum of the z buffer and the stencil buffer bit depth.
        if ((dwZBitDepth == 16) || (dwZBitDepth == 32))
        {
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                            "Depth buffer not 16 or 32 Bits! (%d)", 
                            dwZBitDepth));

            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;    
    }

    // *********************** 3D RENDER TARGETS ***************************
    if (pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_3DDEVICE)
    {
        // We are going to use this surface as a rendering target

        // Notice that this will also cover the case when we're
        // trying to create a vidmem texture that will also be used
        // as a rendertarget (as we go thorugh this path before 
        // DDSCAPS_TEXTURE-cap surfaces are processed)
        if (!pccsd->bIsDifferentPixelFormat)        
        {
            // we have the same format as the primary . If this is true,
            // on DX7 we won't have the ddpfPixelFormat fielded at all.
            // But we do support rendertargets and textures of the same
            // format as our possible primaries so we return DD_OK
            DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                             "Same as primary format for "
                             "rendertarget surface" ));
            pccsd->ddRVal = DD_OK;            
        }
        else if( pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB )
        {
            DDPIXELFORMAT *pPixFmt = 
                        &pccsd->lpDDSurfaceDesc->ddpfPixelFormat;
        
             // Only 32 and 16 (565) RGB modes allowed.
            switch (pPixFmt->dwRGBBitCount)
            {
            case 32:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "32-bit RGB format for "
                                 "rendertarget surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 16:
                if ((pPixFmt->dwRBitMask == 0xF800) &&
                    (pPixFmt->dwGBitMask == 0x07E0) &&        
                    (pPixFmt->dwBBitMask == 0x001F))
                {                                
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     "16-bit 565 RGB format for "
                                     "rendertarget surface" ));
                    pccsd->ddRVal = DD_OK;
                }
                else
                {
                    DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                     "NOT 16-bit 565 RGB format for "
                                     "16BPP rendertarget surface" ));             
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                }
                break;                            
                
            default:
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "RGB rendertarget not 16 (565) "
                                 "or 32 bit - wrong pixel format" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;           
                break;
            }            
        }
        else
        {
            DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                             "Rendertarget not an RGB Surface"
                             " - wrong pixel format" ));
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;                            
    }

    // *************************** TEXTURES **************************
    if(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        // Notice that the case when we're trying to create a vidmem 
        // texture that will also be used as a rendertarget has already
        // been taken care of when processing the 3D rendertargets case
        // as their valid formats are a subset of the valid texture formats

        if (!pccsd->bIsDifferentPixelFormat)        
        {
            // we have the same format as the primary . If this is true,
            // on DX7 we won't have the ddpfPixelFormat fielded at all.
            // but all primary formats are valid for this driver as
            // texture formats as well, so succeed this call
            DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                             "Same as primary format for "
                             "texture surface" ));
            pccsd->ddRVal = DD_OK;            
        }    
        // if the surface is going to be a texture verify it matches one
        // of the supported texture formats (already stored in pThisDisplay)
        else if (__SUR_bCheckTextureFormat(
                                pThisDisplay,
                                &pccsd->lpDDSurfaceDesc->ddpfPixelFormat))
        {
            // texture surface is in one or our supported texture formats           
            DISPDBG((DBGLVL, "  Texture Surface - OK" ));
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            // we don't support this kind of texture format
            DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                             "Texture Surface format not supported" ));
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;
        
    }        

    // ***********************************************************************
    // * OTHER OFFSCREEN SURFACES THAT ARE DIFFERENT FROM THE PRIMARY FORMAT *
    // ***********************************************************************
    if (pccsd->bIsDifferentPixelFormat)
    {
        DISPDBG((DBGLVL,"Pixel Format is different to primary"));
        if(pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
        {
            DISPDBG((DBGLVL, "    FourCC requested (%4.4hs, 0x%08lx)", 
                     (LPSTR) &pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC,
                        pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ));

            switch (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC)
            {
            case FOURCC_YUV422:
                DISPDBG((WRNLVL,"DdCanCreateSurface OK: "
                                "Surface requested is YUV422"));
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                pccsd->ddRVal = DD_OK;
                break;
                
                // Disabled for now.
            case FOURCC_YUV411:
                DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                                "Surface requested is YUV411 - Disabled"));
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 32;
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                break;
                
            default:
                DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                                "Invalid FOURCC requested, refusing"));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                break;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);            
            return DDHAL_DRIVER_HANDLED;
        }
//@@BEGIN_DDKSPLIT        
        // azn check if the following variations are now still needed
//@@END_DDKSPLIT        
        // Luminance texture support
        else if( (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags 
                                                        & DDPF_LUMINANCE) &&
                 !(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
        {
            DDPIXELFORMAT *pddpfCur;
            // Only 16 and 8-bit modes allowed.
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);

            if (pddpfCur->dwLuminanceBitCount == 8) 
            {
                // Check for L8
                if (!(pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                            DDPF_ALPHAPIXELS))
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     " 8 Bit Luminance surface"));
                    pccsd->ddRVal = DD_OK;
                }
                // Must be A4:L4
                else
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     "4 Bit Luma + 4 Bit Alpha surface"));
                    pccsd->ddRVal = DD_OK;
                }
            }
            // Check for A8L8
            else if (pddpfCur->dwLuminanceBitCount == 16) 
            {
                if (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                            DDPF_ALPHAPIXELS)
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     " 16 Bit Luminance + Alpha Surface"));
                    pccsd->ddRVal = DD_OK;
                }
                else
                {
                    DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                     "Bad A8L8 format" ));                 
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                }
                
            }
            else
            {
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "Unknown luminance texture" ));              
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }
        else if( (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                                DDPF_ALPHA) &&
                 !(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
            DDPIXELFORMAT *pddpfCur;
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);

            if (pddpfCur->dwAlphaBitDepth == 8)
            {
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "8 Bit Alpha surface"));
                pccsd->ddRVal = DD_OK;
            }
            else
            {
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "pddpfCur->dwAlphaBitDepth != 8" ));             
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }
        else if( pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB )
        {
            DDPIXELFORMAT *pddpfCur;
            // Only 32, 16 and 8-bit modes allowed.
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);
            switch ( pddpfCur->dwRGBBitCount )
            {
            case 32:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 32-bit surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 16:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 16-bit surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 8:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 8-bit Surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                               
            default:
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "RGB Surface - wrong pixel format" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;           
                break;
            }
            
            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }

        // Since its a different from the primary surface and doesn't fall
        // into any of the previous cases, we fail it
        DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                         "Different from the primary surface but unknown" ));        
        pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;
    }

    // Same format as the primary, we succeed it anyway
    DISPDBG((DBGLVL, "DdCanCreateSurface OK: (Def) Same format as primary" ));
    pccsd->ddRVal = DD_OK;
    DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
    return DDHAL_DRIVER_HANDLED;

} // DdCanCreateSurface 

//-----------------------------Public Routine----------------------------------
//
// DdCreateSurface
//
// Creates a DirectDraw surface.
//
// The driver can allocate the surface memory itself or can request that 
// DirectDraw perform the memory management. If the driver performs the 
//allocation, it must do the following: 
//
// Perform the allocation and write a valid pointer to the memory in the 
// fpVidMem member of the DD_SURFACE_GLOBAL structure. 
// If the surface has a FourCC format, write the pitch in the lPitch member of 
// the DD_SURFACE_GLOBAL and DDSURFACEDESC structures, and update the flags 
// accordingly. 
//
// Otherwise, the driver can have DirectDraw allocate the surface by returning 
// one of the following values in fpVidMem: 
//
//      DDHAL_PLEASEALLOC_BLOCKSIZE requests that DirectDraw allocate the 
//                                  surface memory from offscreen memory. 
//      DDHAL_PLEASEALLOC_USERMEM   requests that DirectDraw allocate the 
//                                  surface memory from user memory. The 
//                                  driver must also return the size in 
//                                  bytes of the memory region in dwUserMemSize.
//
// For DirectDraw to perform the allocation of a surface with a FourCC format,
// the driver must also return the pitch and x- and y-block sizes in lPitch, 
// dwBlockSizeX, and dwBlockSizeY, respectively. The pitch must be returned in 
// the lPitch member of both the DD_SURFACE_GLOBAL and DDSURFACEDESC structures. 
// For linear memory, the driver should set dwBlockSizeX to be the size in bytes
// of the memory region and set dwBlockSizeY to 1. 
//
// By default, the driver is not notified when a primary surface is created on 
// Windows 2000. However, if the driver supports GUID_NTPrivateDriverCaps and 
// the DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION flag is set, then the driver will 
// be notified.
//
// Parameters
//
//      pcsd 
//          Points to a DD_CREATESURFACEDATA structure that contains the 
//          information required to create a surface. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure representing the 
//              driver. 
//          .lpDDSurfaceDesc 
//              Points to the DDSURFACEDESC structure describing the surface 
//              that the driver should create. 
//          .lplpSList 
//              Points to a list of DD_SURFACE_LOCAL structures describing 
//              the surface objects created by the driver. On Windows 2000, 
//              there is usually only one entry in this array. However, if 
//              the driver supports the Windows 95/98-style surface creation 
//              techniques using DdGetDriverInfo with GUID_NTPrivateDriverCaps,
//              and the driver sets the DDHAL_PRIVATECAP_ATOMICSURFACECREATION 
//              flag, the member will contain a list of surfaces (usually more 
//              than one). 
//          .dwSCnt 
//              Specifies the number of surfaces in the list to which lplpSList
//              points. This value is usually 1 on Windows 2000. However, if 
//              you support the Windows 95/Windows98-style surface creation 
//              techniques using DdGetDriverInfo with GUID_NTPrivateDriverCaps, 
//              the member will contain the actual number of surfaces in the 
//              list (usually more than one). 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdCreateSurface callback. A return code of DD_OK 
//              indicates success. 
//          .CreateSurface 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCreateSurface( 
    LPDDHAL_CREATESURFACEDATA pcsd )
{
    int                         i;
    DWORD                       BitDepth;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_MORE  psurf_more;
    BOOL                        bHandled = TRUE;
    BOOL                        bResize = FALSE;
    P3_THUNKEDDATA*             pThisDisplay;
    DWORD                       dwExtraBytes;

    DBG_CB_ENTRY(DdCreateSurface);
    
    GET_THUNKEDDATA(pThisDisplay, pcsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay); 

    for( i=0; i<(int)pcsd->dwSCnt; i++ )
    {
        DDPIXELFORMAT* pPixFormat = NULL;
        psurf = pcsd->lplpSList[i];
        psurf_gbl = psurf->lpGbl;
        psurf_more = psurf->lpSurfMore;

        // Dump debug info about the surface to be created
        DISPDBG((DBGLVL, "\nLooking at Surface %d of %d", i + 1, pcsd->dwSCnt));
        DISPDBG((DBGLVL,"Surf dimensions: %d x %d", psurf_gbl->wWidth, 
                        psurf_gbl->wHeight ));          
        DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, psurf);     

        DISPDBG((DBGLVL, "DdCreateSurface setting NULL"));
        psurf_gbl->fpVidMem = 0;
                    
        // Get the bitdepth of the surface
        BitDepth = DDSurf_BitDepth(psurf);

        // All Z buffers need adjusting, and setting the correct bit depth
        if (DDSurf_HasPixelFormat(psurf->dwFlags))
        { 
            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER)
            {
                DISPDBG((DBGLVL,"Surface is Z Buffer"));
                BitDepth = psurf_gbl->ddpfSurface.dwZBufferBitDepth;

                // Force the pitch to the correct value - the DX runtime
                // sometimes sends us a duff value.

                psurf_gbl->lPitch = psurf_gbl->wWidth << ( BitDepth >> 4 );

                // Ddraw surfaces in IA64 have to be DWORD aligned in their
                // pitch in order for emulation code to work correctly
                // And on X86 we declared surfaces will be DWORD aligned in 
                // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
                psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);
            }
        }

        // Determine if we need to resize the surface to make it fit.
        bResize = FALSE;

        // The surface is a YUV format surface
        if (DDSurf_HasPixelFormat(psurf->dwFlags))
        {
            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                bResize = TRUE;
                switch( psurf_gbl->ddpfSurface.dwFourCC )
                {
                    case FOURCC_YUV422:
                        DISPDBG((DBGLVL,"Surface is YUV422"));
                        psurf_gbl->ddpfSurface.dwYUVBitCount = 16;
                        BitDepth = 16;
                        break;
                        
                    case FOURCC_YUV411:
                        DISPDBG((DBGLVL,"Surface is YUV411"));
                        psurf_gbl->ddpfSurface.dwYUVBitCount = 32;
                        BitDepth = 32;
                        break;
                        
                    default:
                        // We should never get here, as CanCreateSurface will
                        // validate the YUV format for us.
                        DISPDBG((ERRLVL,"Trying to create an invalid YUV surface!"));
                        break;
                }
            }
        }

        DISPDBG((DBGLVL,"Surface Pitch is: 0x%x",  psurf_gbl->lPitch));

        // This flag is set if the surface needs resizing.  
        if (bResize)
        {
            DWORD dwNewWidth = psurf_gbl->wWidth;
            DWORD dwNewHeight = psurf_gbl->wHeight;
            DWORD dwHeightAlignment = 1;
            DWORD dwWidthAlignment = 1;

            DISPDBG((DBGLVL, "Resizing surface"));

            while ((dwNewWidth % dwWidthAlignment) != 0) dwNewWidth++;
            while ((dwNewHeight % dwHeightAlignment) != 0) dwNewHeight++;

            DISPDBG((DBGLVL,"Surface original = %d x %d, Surface new = %d x %d",
                            psurf_gbl->wWidth, psurf_gbl->wHeight, 
                            dwNewWidth, dwNewHeight));

            psurf_gbl->fpVidMem = (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE;
            psurf_gbl->lPitch = (DWORD)(dwNewWidth * (BitDepth / 8));

            // Ddraw surfaces in IA64 have to be DWORD aligned in their
            // pitch in order for emulation code to work correctly
            // And on X86 we declared surfaces will be DWORD aligned in 
            // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
            psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);          
            
            psurf_gbl->dwBlockSizeX = (DWORD)((DWORD)dwNewHeight * 
                                                    (DWORD)psurf_gbl->lPitch );
            psurf_gbl->dwBlockSizeY = 1;
        }
        else
        {
            psurf_gbl->lPitch = (DWORD)(psurf_gbl->wWidth * (BitDepth / 8));
            
            // Ddraw surfaces in IA64 have to be DWORD aligned in their
            // pitch in order for emulation code to work correctly
            // And on X86 we declared surfaces will be DWORD aligned in 
            // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
            psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);          
            
#if DX8_3DTEXTURES
            if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // Put slice pitch into dwBlockSizeY.
                psurf_gbl->dwBlockSizeY = psurf_gbl->lPitch * 
                                                            psurf_gbl->wHeight;
            }
#endif // DX8_3DTEXTURES
        }

#if DX7_TEXMANAGEMENT

        // If this is going to be a driver managed texture we'll request DX to 
        // allocate it in a private area in system user memory for us.
        if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {    
            pcsd->lpDDSurfaceDesc->lPitch   = psurf_gbl->lPitch;
            pcsd->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
        
            if (pcsd->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
            {
                pcsd->lpDDSurfaceDesc->lPitch = 
                psurf_gbl->lPitch             =
                           ((pcsd->lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount*
                             psurf_gbl->wWidth+31)/32)*4;  //make it DWORD aligned

                // Ddraw surfaces in IA64 have to be DWORD aligned in their
                // pitch in order for emulation code to work correctly
                // And on X86 we declared surfaces will be DWORD aligned in 
                // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
                pcsd->lpDDSurfaceDesc->lPitch = 
                psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);
            }
    
#if WNT_DDRAW
            psurf_gbl->dwUserMemSize = psurf_gbl->lPitch *
                                            (DWORD)(psurf_gbl->wHeight);
                                            
            psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
            
            pcsd->ddRVal = DD_OK;
            DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);          
            return DDHAL_DRIVER_NOTHANDLED;        
#else
            // Assume all the memory allocation will succeed
            if (i == 0) 
            {
                bHandled = TRUE;
            }
            
            psurf_gbl->fpVidMem = (FLATPTR)HEAP_ALLOC(FL_ZERO_MEMORY,
                                                      psurf_gbl->lPitch*psurf_gbl->wHeight,
                                                      ALLOC_TAG_DX(M));
            if (psurf_gbl->fpVidMem)
            {
                // Move on to the next MIP level, skip calling VRAM allocator
                continue; 
            }
            else
            {
                pcsd->ddRVal = DDERR_OUTOFMEMORY;
    
                DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);
                return DDHAL_DRIVER_HANDLED;
            }
#endif
        }

#endif // DX7_TEXMANAGEMENT
    

        // If its not to be created in AGP memory and its not the primary
        // then we allocate the memory using our videomemory allocator
        if ((!(psurf->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)) &&
            (!(psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)))
        {
            P3_MEMREQUEST mmrq;
            DWORD dwResult;
            memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
            mmrq.dwSize = sizeof(P3_MEMREQUEST);

            // Compute what size should be requested for the surface allocation
#if DX8_3DTEXTURES
            if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                if (bResize)
                {
                    DISPDBG((ERRLVL,"No volume with block size alloc"));
                }
                else
                {
                    // the depth of volume texture is given in
                    // ddsCapsEx.dwCaps4.
                    mmrq.dwBytes = (DWORD)psurf_gbl->lPitch *
                                   (DWORD)psurf_gbl->wHeight *
                                   (DWORD)psurf_more->ddsCapsEx.dwCaps4;
                }
            }
            else
#endif // DX8_3DTEXTURES            
            {
                if (bResize)
                {
                    mmrq.dwBytes = psurf_gbl->dwBlockSizeX * 
                                                    psurf_gbl->dwBlockSizeY;
                }
                else
                {
                    mmrq.dwBytes = (DWORD)psurf_gbl->lPitch * 
                                                    (DWORD)psurf_gbl->wHeight;
                }
            }

            // 16 Byte alignment will work for everything
            mmrq.dwAlign = 16;  

            // Figure out where in the video mem to place it
            mmrq.dwFlags = MEM3DL_FIRST_FIT;
           
            if(__SUR_bSurfPlacement(psurf, 
                                    pcsd->lpDDSurfaceDesc) == MEM3DL_FRONT)
            {
                mmrq.dwFlags |= MEM3DL_FRONT;
            }
            else
            {
                mmrq.dwFlags |= MEM3DL_BACK;            
            }

            DISPDBG((DBGLVL,"DdCreateSurface allocating vidmem for handle #%d",
                            psurf->lpSurfMore->dwSurfaceHandle));     
                        
            // Try allocating it in our video memory
            dwResult = _DX_LIN_AllocateLinearMemory(
                                    &pThisDisplay->LocalVideoHeap0Info, 
                                    &mmrq);

            // Did we got the memory we asked for?
            if (dwResult != GLDD_SUCCESS)
            {
                // If we have an AGP heap and it is a texture request,
                // don't give up - ask DDRAW to allocate it for us.
                if ((pThisDisplay->bCanAGP) &&
                    ((psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE       ) ||
                     (psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)   ))
                {
                    DISPDBG((WRNLVL,"No texture VideoMemory left, "
                                    "going for AGP"));
                                    
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
                    psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                    
                }
                else
                {
                    psurf_gbl->fpVidMem = 0;
                    DISPDBG((ERRLVL, "DdCreateSurface: failed, "
                                     "returning NULL"));
                    pcsd->ddRVal = DDERR_OUTOFVIDEOMEMORY;

                    START_SOFTWARE_CURSOR(pThisDisplay);

                    DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);
                    return DDHAL_DRIVER_HANDLED;
                }
            }
            else
            {
                // We succeeded. Now update the fpVidMem of the surface
                
                psurf_gbl->fpVidMem = mmrq.pMem;
            }
        }

#if WNT_DDRAW
        // NT requires us to set some things up differently
        pcsd->lpDDSurfaceDesc->lPitch = psurf_gbl->lPitch;
        pcsd->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
#endif

        // Mark the surface with the correct video memory type
        if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) 
        {
            DISPDBG((DBGLVL,"Surface is in AGP memory"));
            
            ASSERTDD(pThisDisplay->bCanAGP, 
                     "** DdCreateSurface: Somehow managed to create an AGP "
                     "texture when AGP disabled" );
                     
            psurf->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
            psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
            
            // let DDraw manage AGP memory (return DDHAL_DRIVER_NOTHANDLED)
            // THIS IS ABSOLUTELY NECESSARY IF WE WANT DDRAW TO ALLOCTE THIS!
            bHandled = FALSE;         
        }
        else
        {
            DISPDBG((DBGLVL,"Surface in Local Video Memory"));
            psurf->ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
            psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
        }

        DISPDBG((DBGLVL, "DdCreateSurface: Surface=0x%08x, vidMem=0x%08x", 
                         psurf, psurf_gbl->fpVidMem));
    } // for i

    START_SOFTWARE_CURSOR(pThisDisplay);

    //
    // If we allocated the memory successfully then we return OK and 
    // say that we handled it. Otherwise we should return DDHAL_DRIVER_NOTHANDLED
    //
    if(bHandled)
    {
        pcsd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);        
        return DDHAL_DRIVER_HANDLED;
    }
    else
    {
        // if we return handled, then it is assumed that we did SOMETHING
        // with the surface structures to indicate either what size of block
        // or a new pitch or some modification; or we are returning an error.
        DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);   
        return DDHAL_DRIVER_NOTHANDLED;
    }

} // DdCreateSurface 

//-----------------------------Public Routine----------------------------------
//
// DdDestroySurface
//
// Destroys a DirectDraw surface.
//
// If DirectDraw did the memory allocation at surface creation time, 
// DdDestroySurface should return DDHAL_DRIVER_NOTHANDLED.
//
// If the driver is performing the surface memory management itself, 
// DdDestroySurface should free the surface memory and perform any other 
// cleanup, such as freeing private data stored in the dwReserved1 members 
// of the DD_SURFACE_GLOBAL and DD_SURFACE_LOCAL structures.
//
// Parameters
//
//      psdd 
//          Points to a DD_DESTROYSURFACEDATA structure that contains the 
//          information needed to destroy a surface. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpDDSurface 
//              Points to the DD_SURFACE_LOCAL structure representing the 
//              surface object to be destroyed. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdDestroySurface callback. A return code of 
//              DD_OK indicates success. 
//          .DestroySurface 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdDestroySurface( 
    LPDDHAL_DESTROYSURFACEDATA psdd )
{
    P3_THUNKEDDATA* pThisDisplay; 

    DBG_CB_ENTRY(DdDestroySurface);

    GET_THUNKEDDATA(pThisDisplay, psdd->lpDD);

    // make sure the DMA buffer is flushed and 
    // complete before we destroy any surface
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    {
    P3_DMA_DEFS();   
    DDRAW_OPERATION(pContext, pThisDisplay);
    P3_DMA_GET_BUFFER();
    P3_DMA_FLUSH_BUFFER();
    WAIT_DMA_COMPLETE;
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DISPDBG((DBGLVL,"DdDestroySurface handle # %d",
                    psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle));
    
    // If we are destroying a videomemory surface which isn't the primary,
    // we'll need to free ourselves the memory as the driver is managing
    // its own local video memory (though non-local/AGP memory is being
    // managed by DirectDraw)
    if ((!(psdd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)) &&
        (!(psdd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)))
    {
#if DX7_TEXMANAGEMENT
        // If this is a driver managed texture surface, we need to make sure 
        // it is deallocated from video memory before proceeding.
        if (psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                            DDSCAPS2_TEXTUREMANAGE)
        {
            if (psdd->lpDDSurface->dwFlags & DDRAWISURF_INVALID)
            {
                // This is not a surface destruction, 
                // but a managed surface eviction
#if W95_DDRAW
                // On Win2k, managed textures are evicted from video memory by
                // _DD_TM_EvictAllManagedTextures() when mode change happens.
                _D3D_TM_RemoveDDSurface(pThisDisplay, psdd->lpDDSurface);
#endif
                psdd->ddRVal=  DD_OK;
                DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);
                return DDHAL_DRIVER_HANDLED;
            }
            else
            {
                // Normal destruction of managed surface               
                _D3D_TM_RemoveDDSurface(pThisDisplay, psdd->lpDDSurface); 
#if W95_DDRAW
                // On Win2k, runtime will free the system memory for drivers.
                if (psdd->lpDDSurface->lpGbl->fpVidMem)
                {
                    HEAP_FREE((LPVOID)psdd->lpDDSurface->lpGbl->fpVidMem);
                }
#endif
            }
        }
        else
#endif
        {
            // Have no memory to free in error recovery case
            if (psdd->lpDDSurface->lpGbl->fpVidMem)
            {
                _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                         (DWORD)(psdd->lpDDSurface->lpGbl->fpVidMem));
            }
        }
        
        // Must reset the surface pointer to NULL
        DISPDBG((DBGLVL, "DdDestroySurface: setting ptr to NULL"));
        psdd->lpDDSurface->lpGbl->fpVidMem = 0;

        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;

        psdd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);
        return DDHAL_DRIVER_HANDLED;

    }
    else
    {
        DISPDBG((WRNLVL, "DdDestroySurface: **NOT** setting ptr to NULL"));

        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;

        psdd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);        
        return DDHAL_DRIVER_NOTHANDLED;
    }
} // DdDestroySurface 

//-----------------------------Public Routine----------------------------------
//
// DdSetColorKey
//
// Sets the color key value for the specified surface. 
//
// DdSetColorKey sets the source or destination color key for the specified 
// surface. Typically, this callback is implemented only for drivers that 
// support overlays with color key capabilities.
//
// Parameters
//
//      psckd
//          Points to a DD_SETCOLORKEYDATA structure that contains the 
//          information required to set the color key for the specified surface.
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpDDSurface 
//              Points to the DD_SURFACE_LOCAL structure that describes the 
//              surface with which the color key is to be associated. 
//          .dwFlags 
//              Specifies which color key is being requested. This member is 
//              a bit-wise OR of any of the following values: 
//
//              DDCKEY_COLORSPACE 
//                      The DDCOLORKEY structure contains a color space. If 
//                      this bit is not set, the structure contains a single 
//                      color key. 
//              DDCKEY_DESTBLT 
//                      The DDCOLORKEY structure specifies a color key or color
//                      space to be used as a destination color key for blit 
//                      operations. 
//              DDCKEY_DESTOVERLAY 
//                      The DDCOLORKEY structure specifies a color key or color
//                      space to be used as a destination color key for overlay 
//                      operations. 
//              DDCKEY_SRCBLT 
//                      The DDCOLORKEY structure specifies a color key or color 
//                      space to be used as a source color key for blit 
//                      operations. 
//              DDCKEY_SRCOVERLAY 
//                      The DDCOLORKEY structure specifies a color key or color 
//                      space to be used as a source color key for overlay 
//                      operations. 
//          .ckNew 
//              Specifies a DDCOLORKEY structure that specifies the new color 
//              key values for the DirectDrawSurface object. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdSetColorKey callback. A return code of DD_OK 
//              indicates success. 
//          .SetColorKey 
//              This is not used on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetColorKey(
    LPDDHAL_SETCOLORKEYDATA psckd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdSetColorKey);
    
    GET_THUNKEDDATA(pThisDisplay, psckd->lpDD);
    
//@@BEGIN_DDKSPLIT
#if 0
    // Also, see if this colour key is the one used by the overlay.
    // Yes, we should check that various surfaces agree and so on,
    // but can we assume apps are not going to set these flags if there is
    // no overlay active/appropriate?
    if ( psckd->dwFlags & DDCKEY_DESTOVERLAY )
    {
        pThisDisplay->OverlayDstColourKey = psckd->ckNew.dwColorSpaceLowValue;
    }
#endif
//@@END_DDKSPLIT


    // We have to keep track of colorkey changes for D3D videomemory textures
    // associated with (some) D3D context. We don't know however from this call
    // which D3D context this is so we have to do a search through them (if
    // there are any at all)
    if ((DDSCAPS_TEXTURE & psckd->lpDDSurface->ddsCaps.dwCaps) &&
        (DDSCAPS_VIDEOMEMORY & psckd->lpDDSurface->ddsCaps.dwCaps) &&
        (pThisDisplay->pDirectDrawLocalsHashTable != NULL))
    {
        DWORD dwSurfaceHandle = psckd->lpDDSurface->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;

        // For now we'll assume failure unless proven otherwise
        psckd->ddRVal = DDERR_INVALIDPARAMS;
        
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        psckd->lpDDSurface->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! Now update the color key setting(s)
                pSurfInternal->dwFlagsInt |= DDRAWISURF_HASCKEYSRCBLT;
                pSurfInternal->dwCKLow = psckd->ckNew.dwColorSpaceLowValue;
                pSurfInternal->dwCKHigh = psckd->ckNew.dwColorSpaceHighValue;     

                // Report success!
                psckd->ddRVal = DD_OK;
            }
        }                                        
    } 
    else    
    {   
        // No D3D colorkey tracking necessary
        psckd->ddRVal = DD_OK;
    }

    DBG_CB_EXIT(DdSetColorKey, psckd->ddRVal);    
    return DDHAL_DRIVER_HANDLED;
} // DdSetColorKey

//-----------------------------Public Routine----------------------------------
//
// DdGetAvailDriverMemory
//
// DdGetAvailDriverMemory queries the amount of free memory in the driver
// managed memory heap. This function does not need to be implemented if the 
// memory will be managed by DirectDraw.
//
// DdGetAvailDriverMemory determines how much free memory is in the driver's 
// private heaps for the specified surface type. The driver should check the 
// surface capabilities specified in DDSCaps against the heaps that it is 
// maintaining internally to determine which heap size to query. For example, 
// if DDSCAPS_NONLOCALVIDMEM is set, the driver should return only 
// contributions from the AGP heaps.
//
// The driver indicates its support of DdGetAvailDriverMemory by implementing a
// response to GUID_MiscellaneousCallbacks in DdGetDriverInfo.
//
// Parameters
//
//      pgadmd 
//          Points to a DD_GETAVAILDRIVERMEMORYDATA structure that contains the
//          information required to perform the query. 
//
//          lpDD 
//                  Points to the DD_DIRECTDRAW_GLOBAL structure that describes
//                  the driver. 
//          DDSCaps 
//                  Points to a DDSCAPS structure that describes the type of 
//                  surface for which memory availability is being queried. 
//                  The DDSCAPS structure is defined in ddraw.h. 
//          dwTotal 
//                  Specifies the location in which the driver returns the
//                  number of bytes of driver-managed memory that can be used
//                  for surfaces of the type described by DDSCaps. 
//          dwFree 
//                  Specifies the location in which the driver returns the
//                  amount of free memory, in bytes, for the surface type
//                  described by DDSCaps. 
//          ddRVal 
//                  Specifies the location in which the driver writes the
//                  return value of the DdGetAvailDriverMemory callback. A
//                  return code of DD_OK indicates success. 
//          GetAvailDriverMemory
//                  This is unused on Windows 2000. 
//
// Return Value
//      DdGetAvailDriverMemory returns one of the following callback codes:
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//
//      DdGetAvailDriverMemory determines how much free memory is in the 
//      driver's private heaps for the specified surface type. The driver 
//      should check the surface capabilities specified in DDSCaps against 
//      the heaps that it is maintaining internally to determine which heap 
//      size to query. For example, if DDSCAPS_NONLOCALVIDMEM is set, the 
//      driver should return only contributions from the AGP heaps.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetAvailDriverMemory(
    LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdGetAvailDriverMemory);
    
    GET_THUNKEDDATA(pThisDisplay, pgadmd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DISPDBG((DBGLVL, "Heap0:  dwMemStart:0x%x, dwMemEnd:0x%x",
                    pThisDisplay->LocalVideoHeap0Info.dwMemStart, 
                    pThisDisplay->LocalVideoHeap0Info.dwMemEnd));

    pgadmd->ddRVal = DD_OK;
    if (pgadmd->DDSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        DISPDBG((DBGLVL,"  Not returning AGP heap free memory "
                        "(we don't manage it)"));
        DBG_CB_EXIT(DdGetAvailDriverMemory, pgadmd->ddRVal);                        
        return DDHAL_DRIVER_NOTHANDLED;
    }
    else
    {
        pgadmd->dwTotal = pThisDisplay->LocalVideoHeap0Info.dwMaxChunks *
                             pThisDisplay->LocalVideoHeap0Info.dwMemPerChunk;

        pgadmd->dwFree = 
               _DX_LIN_GetFreeMemInHeap(&pThisDisplay->LocalVideoHeap0Info);
    }

    DISPDBG((DBGLVL,"  Returning %d TotalMem, of which %d free", 
                pgadmd->dwTotal, pgadmd->dwFree));

    DBG_CB_EXIT(DdGetAvailDriverMemory, pgadmd->ddRVal); 
    return DDHAL_DRIVER_HANDLED;
} // DdGetAvailDriverMemory


#if W95_DDRAW
//-----------------------------------------------------------------------------
//
// __FindAGPHeap
//
//-----------------------------------------------------------------------------
static void
__FindAGPHeap( 
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DIRECTDRAW_GBL lpDD )
{
    VIDMEMINFO MemInfo = lpDD->vmiData;
    LPVIDMEM pStartHeap;
    LPVIDMEM pCurrentHeap = NULL;
    BOOL bFoundAGPHeap = FALSE;

    if ((pThisDisplay->bCanAGP) && 
        (pThisDisplay->dwGARTDev != 0) &&
        (MemInfo.dwNumHeaps) &&
        (MemInfo.pvmList))
    {
        int i;

        // Look around for a good AGP heap
        pStartHeap = MemInfo.pvmList;
        for (i = 0; i < (int)MemInfo.dwNumHeaps; i++)
        {
            pCurrentHeap = pStartHeap + i;
            if (pCurrentHeap->dwFlags & VIDMEM_ISNONLOCAL)
            {
                bFoundAGPHeap = TRUE;
                break;
            }               
        }
    } else {
        DISPDBG((ERRLVL,"Unable to allocate AGP memory (AllocatePrivAGPMem)"));
    }

    if(!bFoundAGPHeap)
    {
        DISPDBG((ERRLVL,"Unable to locate AGP heap (AllocatePrivAGPMem)"));
    }

    pThisDisplay->pAGPHeap = pCurrentHeap;
    
} // __FindAGPHeap

//-----------------------------Public Routine----------------------------------
// DdUpdateNonLocalHeap
//
// Received the address of the AGP Heap and updates the chip.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateNonLocalHeap(
    LPDDHAL_UPDATENONLOCALHEAPDATA plhd)
{
    P3_THUNKEDDATA* pThisDisplay;
    GET_THUNKEDDATA(pThisDisplay, plhd->lpDD);

    DISPDBG((DBGLVL,"** In DdUpdateNonLocalHeap - for Heap 0x%x", 
                    plhd->dwHeap));

    // Fill in the base pointers
    pThisDisplay->dwGARTDevBase = (DWORD)plhd->fpGARTDev;
    pThisDisplay->dwGARTLinBase = (DWORD)plhd->fpGARTLin;
    
    // Fill in the changeable base pointers.
    pThisDisplay->dwGARTDev = pThisDisplay->dwGARTDevBase;
    pThisDisplay->dwGARTLin = pThisDisplay->dwGARTLinBase;

    __FindAGPHeap( pThisDisplay, plhd->lpDD );

    DISPDBG((DBGLVL,"GartLin: 0x%x, GartDev: 0x%x", 
               plhd->fpGARTLin, plhd->fpGARTDev));

    plhd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdUpdateNonLocalHeap()

//-----------------------------Public Routine----------------------------------
//
// DdGetHeapAlignment
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetHeapAlignment(
    LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData)
{
    P3_THUNKEDDATA* pThisDisplay;

    DISPDBG(( DBGLVL,"DdGetHeapAlignment: Heap %d", lpGhaData->dwHeap ));
    
    if (lpGhaData->dwInstance)
        pThisDisplay = (P3_THUNKEDDATA*)lpGhaData->dwInstance;
    else
        pThisDisplay = (P3_THUNKEDDATA*)g_pDriverData;

    if( lpGhaData->dwHeap <= 2 )
    {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = 16;

        lpGhaData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
    else
    {
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_NOTHANDLED;
    }   
} // DdGetHeapAlignment

#endif  //  W95_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dd.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.c
*
* Content: Main DirectDraw callbacks
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define INITGUID

#include "glint.h"

#if W95_DDRAW
#include "ddkmmini.h"
#include <mmsystem.h>
#endif

#include "dma.h"
#include "tag.h"

void __GetDDHALInfo(P3_THUNKEDDATA* pThisDisplay, DDHALINFO* pHALInfo);

#if W95_DDRAW

// These variables MUST be initialised, therby forcing them into DATA. 
// This segment is shared.
P3_THUNKEDDATA* g_pDriverData = NULL;

//-----------------------------------------------------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DllMain
//
// DLL Entry point.
//
//-----------------------------------------------------------------------------
BOOL WINAPI 
DllMain(
    HINSTANCE hModule, 
    DWORD dwReason, 
    LPVOID lpvReserved)
{
    // The 16 bit side requires an HINSTANCE
    g_DXGlobals.hInstance = hModule;

    switch( dwReason ) 
    {
        case DLL_PROCESS_ATTACH:
            // We don't care about thread attach messages.
            DisableThreadLibraryCalls( hModule );
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return TRUE;

} // DllMain

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DdDestroyDriver
//
// Destroys a DirectDraw driver. 
//
// Parameters
//      pddd 
//              Address of a DDHAL_DESTROYDRIVERDATA structure that contains
//              information necessary to destroy the driver.
//          Members
//
//          LPDDRAWI_DIRECTDRAW_GBL
//          lpDD
//                      Address of the DirectDraw structure representing
//                      the DirectDraw object. 
//          HRESULT                    
//          ddRVal
//                      Passes the DirectDraw return values. 
//          LPDDHAL_DESTROYDRIVER      
//          DestroyDriver 
//                      This member is used by the DirectDraw API and should
//                      not be filled in by the driver. 
//
// Return Value
//      Returns one of the following values: 
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//-----------------------------------------------------------------------------

//
// (!!!) Temp patch, move to Win9x header later, this CB is currently not used.
//

#define DIRECTX_DESTROYDRIVER_ESCAPE  0xbadbadee

DWORD CALLBACK 
DdDestroyDriver(
    LPDDHAL_DESTROYDRIVERDATA pddd)
{
    HDC hDC;
    P3_THUNKEDDATA* pThisDisplay;
    LPGLINTINFO pGLInfo;

    DISPDBG((DBGLVL,"*** In DdDestroyDriver"));

    GET_THUNKEDDATA(pThisDisplay, pddd->lpDD);
    
    pGLInfo = pThisDisplay->pGLInfo;

    // Destroy the hash table
    HT_DestroyHashTable(pThisDisplay->pDirectDrawLocalsHashTable, pThisDisplay);

    DISPDBG((DBGLVL,"Calling Display Driver's DestroyDriver16"));
    
    hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
    
    if ( hDC != NULL )
    {
        DISPDBG((DBGLVL,"HDC: 0x%x", hDC));
        
        ExtEscape ( hDC, 
                    DIRECTX_DESTROYDRIVER_ESCAPE, 
                    sizeof(DDHAL_DESTROYDRIVERDATA), 
                    (LPCSTR)pddd, 
                    0, 
                    NULL );
                    
        DELETE_DRIVER_DC ( hDC );
    }

    pddd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdDestroyDriver

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DriverInit
//
// The entry point called by DirectDraw to initialize the 32-bit driver. 
//
// DriverInit is called after the control function receives QUERYESCAPESUPPORT
// with DDGET32BITDRIVERNAME escapes and returns the entry point (szEntryPoint).
// DriverInit is only called once during driver initialization; it is not
// called on mode changes. 
//
// The dwDriverData parameter points to a region of shared data between the
// 16- and 32-bit address space. It must be aliased through MapSLFix (a
// standard Windows driver routine), which converts it to a 32-bit pointer,
// g_pDriverData. MapSLFix creates a 16-bit selector for a 32-bit pointer, so
// you can use what it returns from the 16-bit side. A 16:16 pointer is created
// to point to the needed 32-bit objects, so a 64K piece of memory is shared
// between 16- and 32-bit sides. Since only 64K of linear address space is
// accessible with a 16:16 pointer, any objects larger than 64K will require
// two 16:16 pointers tiled together (most objects should be smaller than 64K).
// The pointer is used to set the fReset flag to TRUE because the display
// parameters are being reset. The buildDDHALInfo32 function is called from
// this function to fill out all of the 32-bit function names and driver
// information.
//
// Returns 1.
//
// Parameters
//      DWORD
//      dwDriverData 
//              Doubleword pointer that points to a shared memory region
//              between 16- and 32-bit address space. 
//-----------------------------------------------------------------------------
DWORD CALLBACK
DriverInit( 
    DWORD dwDriverData )
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD DataPointer = 0;
    HANDLE hDevice = NULL;
    DWORD InPtr = dwDriverData;
    DWORD dwSizeRet;
    DWORD bResult;

    // The g_pThisTemp may have been hosed, so we must reset
    // it to continue
#if DBG
    g_pThisTemp = NULL;
#endif
    //extern LPVOID _stdcall MapSL( DWORD );   // 16:16 -> 0:32
    //DataPointer = (DWORD)MapSL(dwDriverData);

    //!! Don't laugh at this... I tried calling the MapSL function
    //to fix up the pointer, but couldn't get it to work all of the time
    //(When the display was running the second instance of itself).
    hDevice = CreateFile("\\\\.\\perm3mvd", 
                         GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         (LPSECURITY_ATTRIBUTES) NULL, 
                         OPEN_EXISTING, 
                         FILE_ATTRIBUTE_NORMAL, 
                         (HANDLE) NULL); 

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) 
    { 
        DISPDBG((ERRLVL, "ERROR: Invalid Handle"));
        return 0; 
    }
    else 
    { 
        DISPDBG((DBGLVL, "Got handle"));
        
        bResult = DeviceIoControl(hDevice, 
                                  GLINT_16TO32_POINTER, 
                                  &InPtr, 
                                  sizeof(DWORD), 
                                  &DataPointer, 
                                  sizeof(DWORD), 
                                  &dwSizeRet, 
                                  0);
                                  
        if (!bResult || (DataPointer == 0))
        {
            DISPDBG((ERRLVL,"ERROR: Pointer conversion failed!"));
            CloseHandle(hDevice); 
            return 0;
        }
    }
    CloseHandle(hDevice);

#if DBG
    g_pThisTemp = (P3_THUNKEDDATA*)DataPointer;
#endif

    //
    // Sanity check
    //

    if (! (((P3_THUNKEDDATA*)DataPointer)->pGLInfo)) {
        return 0;
    }

    if (((P3_THUNKEDDATA*)DataPointer)->pGLInfo->dwDeviceHandle == 1)
    {
        g_pDriverData = (P3_THUNKEDDATA*)DataPointer;
        DISPDBG((ERRLVL, "Device is the Primary, Setting sData: 0x%x", 
                         g_pDriverData));
    }
    else
    {
        DISPDBG((ERRLVL, "Device NOT Primary Display, "
                         "Setting dwReturn: 0x%x", 
                         DataPointer));
    }

    pThisDisplay = (P3_THUNKEDDATA*)DataPointer;
    if (pThisDisplay->dwSetupThisDisplay == 0)
    {
        // Pass the current pointer to the init function
        if (! _DD_InitDDHAL32Bit((P3_THUNKEDDATA*)DataPointer)) 
        {
            DISPDBG((ERRLVL,"ERROR: DriverInit Failed!"));
            return 0;
        }
        else
        {
            //
            // Initialize the heap manager data structure
            //

            _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);

            if (!_DX_LIN_InitialiseHeapManager(
                     &pThisDisplay->LocalVideoHeap0Info,
                     pThisDisplay->LocalVideoHeap0Info.dwMemStart,
                     pThisDisplay->LocalVideoHeap0Info.dwMemEnd))
            {
                DISPDBG((ERRLVL, "ERROR: Heap0 initialization failed!"));
            }

            DISPDBG((ERRLVL,"Returned g_pDriverData"));
        }

    }
    
    // Increase the reference count on the display object.
    pThisDisplay->dwSetupThisDisplay++;

    // Set up the size of the ddCaps
    pThisDisplay->ddhi32.ddCaps.dwSize = sizeof(DDCORECAPS);

    // Set the flag that says we have to handle a mode change.
    // This will cause the chip to be initialised properly at the 
    // right time (whilst in a Win16Lock)
    ((P3_THUNKEDDATA*)DataPointer)->bResetMode = TRUE;
    ((P3_THUNKEDDATA*)DataPointer)->bStartOfDay = TRUE;
    ((P3_THUNKEDDATA*)DataPointer)->pGLInfo->dwDirectXState = 
                                                DIRECTX_LASTOP_UNKNOWN;
                                                

    return (DWORD)DataPointer;

} // DriverInit

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DdControlColor
//
// Controls the luminance and brightness controls of an overlay surface
// or a primary surface. This callback is optional. 
//
// Parameters
//      lpColorControl 
//                  Points to a DD_COLORCONTROLDATA structure that contains
//                  the color control information for a specified overlay
//                  surface.
//
//          Members
//
//              PDD_DIRECTDRAW_GLOBAL
//              lpDD 
//                          Points to a DD_DIRECTDRAW_GLOBAL structure that
//                          describes the driver. 
//              PDD_SURFACE_LOCAL
//              lpDDSurface 
//                          Points to the DD_SURFACE_LOCAL structure
//                          representing the overlay surface. 
//              DDCOLORCONTROL
//              ColorData 
//                          Is a DDCOLORCONTROL structure. See dwFlags to
//                          determine how to use this member. The
//                          DDCOLORCONTROL structure is defined in ddraw.h.
//              DWORD
//              dwFlags 
//                          Is the color control flags. This member can be
//                          one of the following values: 
//
//                  DDRAWI_GETCOLOR     The driver should return the color
//                                      controls it supports for the
//                                      specified overlay in ColorData.
//                                      The driver should set the appropriate
//                                      flags in the dwFlags member of the
//                                      DDCOLORCONTROL structure to indicate
//                                      which other members the driver has
//                                      returned valid data in. 
//                  DDRAWI_SETCOLOR 
//                                      The driver should set the current color
//                                      controls for the specified overlay
//                                      using the values specified in ColorData.
//              HRESULT
//              ddRVal 
//                          Is the location in which the driver writes the
//                          return value of the DdControlColor callback. A
//                          return code of DD_OK indicates success. 
//              VOID*
//              ColorControl 
//                          Is unused on Windows 2000. 
//
// Return Value
//          DdControlColor returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
// Comments
//
//      DdControlColor can be optionally implemented in a DirectDraw driver.
//-----------------------------------------------------------------------------

// Set this to 1 to support gamma correction, or zero to disable.
#define COLCON_SUPPORTS_GAMMA 1

DWORD CALLBACK 
DdControlColor( 
    LPDDHAL_COLORCONTROLDATA lpColConData )
{
    P3_THUNKEDDATA* pThisDisplay;
    P3_SURF_FORMAT* pFormatSurface;

    GET_THUNKEDDATA(pThisDisplay, lpColConData->lpDD);

    DISPDBG((DBGLVL,"DdControlColor"));

    //
    // What the DDCOLORCONTROL structure looks like:
    //  {
    //      DWORD   dwSize;
    //      DWORD   dwFlags;
    //      LONG    lBrightness;
    //      LONG    lContrast;
    //      LONG    lHue;
    //      LONG    lSaturation;
    //      LONG    lSharpness;
    //      LONG    lGamma;
    //      LONG    lColorEnable;
    //      DWORD   dwReserved1;
    //  } DDCOLORCONTROL;
    //

    pFormatSurface = _DD_SUR_GetSurfaceFormat(lpColConData->lpDDSurface);
    if ( pFormatSurface->dwBitsPerPixel <= 8 )
    {
        // Can't do colour control on this format screen.
        // Only works on true-colour screens (and we don't 
        // support 332 as a primary).
        lpColConData->lpColorData->dwFlags = 0;
        lpColConData->ddRVal = DD_OK;
        return ( DDHAL_DRIVER_HANDLED );
    }

    // See what they want.
    if ( lpColConData->dwFlags == DDRAWI_GETCOLOR )
    {
        // Get the colour info.
        lpColConData->lpColorData->lBrightness  = 
                                pThisDisplay->ColConBrightness;
        lpColConData->lpColorData->lContrast    = 
                                pThisDisplay->ColConContrast;
                                
#if COLCON_SUPPORTS_GAMMA
        lpColConData->lpColorData->lGamma  = 
                            pThisDisplay->ColConGamma;
        lpColConData->lpColorData->dwFlags = 
                            DDCOLOR_BRIGHTNESS | 
                            DDCOLOR_CONTRAST   | 
                            DDCOLOR_GAMMA;
#else
        // We don't support gamma values.
        lpColConData->lpColorData->lGamma = 0;
        lpColConData->lpColorData->dwFlags =
                            DDCOLOR_BRIGHTNESS | 
                            DDCOLOR_CONTRAST;
#endif
        
    }
    else if ( lpColConData->dwFlags == DDRAWI_SETCOLOR )
    {
        WORD wRamp[256*3];
        WORD *pwRampR, *pwRampG, *pwRampB;
        BOOL bRes;
        HDC hDC;
        float fCol1, fCol2, fCol3, fCol4;
        float fBrightGrad, fBrightBase;
        float fContGrad1, fContBase1;
        float fContGrad2, fContBase2;
        float fContGrad3, fContBase3;
        float fContCutoff12, fContCutoff23;
        float fGammaGrad1, fGammaBase1;
        float fGammaGrad2, fGammaBase2;
        float fGammaCutoff12;
        float fTemp;
        int iTemp, iCount;

        // Set some new colour info.
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS ) != 0 )
        {
            pThisDisplay->ColConBrightness  = 
                        lpColConData->lpColorData->lBrightness;
        }
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_CONTRAST ) != 0 )
        {
            pThisDisplay->ColConContrast    = 
                        lpColConData->lpColorData->lContrast;
        }
#if COLCON_SUPPORTS_GAMMA
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_GAMMA ) != 0 )
        {
            pThisDisplay->ColConGamma = 
                    lpColConData->lpColorData->lGamma;
        }
#endif


        // Set up the constants.

        // Brightness.
        // 0->10000 maps to 0.0->1.0. Default is 0
        fCol1 = (float)(pThisDisplay->ColConBrightness) / 10000.0f;
        fBrightGrad = 1.0f - fCol1;
        fBrightBase = fCol1;

        // Contrast
        // 0->20000 maps to 0.0->1.0. Default 10000 maps to 0.5
        fCol1 = (float)(pThisDisplay->ColConContrast) / 20000.0f;
        fContCutoff12 = fCol1 / 2.0f;
        fContCutoff23 = 1.0f - ( fCol1 / 2.0f );
        fContGrad1 = ( 1.0f - fCol1 ) / fCol1;
        fContBase1 = 0.0f;
        fContGrad2 = fCol1 / ( 1.0f - fCol1 );
        fContBase2 = ( 0.5f - fCol1 ) / ( 1.0f - fCol1 );
        fContGrad3 = ( 1.0f - fCol1 ) / fCol1;
        fContBase3 = ( ( 2.0f * fCol1 ) - 1.0f ) / fCol1;

        // Gamma
        // 1->500 maps to 0.01->5.0, default of 100 maps to 1.0
        // But then map to 0.0->0.5->1.0 non-linearly.
        if ( pThisDisplay->ColConGamma <= 2 )
        {
            // App is probably using the old docs that forgot to point 
            // out the *100
            ASSERTDD ( FALSE, "** Colorcontrol32: App set gamma value of 2"
                              " or less - probably using old DX docs" );
            fTemp = (float)(pThisDisplay->ColConGamma);
        }
        else
        {
            fTemp = (float)(pThisDisplay->ColConGamma) / 100.0f;
        }

        fTemp = 1.0f - ( 1.0f / ( 1.0f + fTemp ) );
        fGammaCutoff12 = 1.0f - fTemp;
        fGammaGrad1 = fTemp / ( 1.0f - fTemp );
        fGammaBase1 = 0.0f;
        fGammaGrad2 = ( 1.0f - fTemp ) / fTemp;
        fGammaBase2 = ( 2.0f * fTemp - 1.0f ) / fTemp;

        // Now set up the table.
        fCol1 = 0.0f;
        pwRampR = &(wRamp[0]);
        pwRampG = &(wRamp[256]);
        pwRampB = &(wRamp[512]);
        for ( iCount = 256; iCount > 0; iCount-- )
        {
            fCol1 += 1.0f / 256.0f;

            // Apply linear approximation gamma.
            if ( fCol1 < fGammaCutoff12 )
            {
                fCol2 = fGammaBase1 + fGammaGrad1 * fCol1;
            }
            else
            {
                fCol2 = fGammaBase2 + fGammaGrad2 * fCol1;
            }

            // Apply contrast
            if ( fCol2 < fContCutoff12 )
            {
                fCol3 = fContBase1 + fContGrad1 * fCol2;
            }
            else if ( fCol2 < fContCutoff23 )
            {
                fCol3 = fContBase2 + fContGrad2 * fCol2;
            }
            else
            {
                fCol3 = fContBase3 + fContGrad3 * fCol2;
            }

            // Apply brightness
            fCol4 = fBrightBase + fBrightGrad * fCol3;

            // Convert 0.0->1.0 to 0->65535
            fTemp = ( fCol4 * 65536.0f );
            myFtoi ( &iTemp, fTemp );
            if ( iTemp < 0 )
            {
                iTemp = 0;
            }
            else if ( iTemp > 65535 )
            {
                iTemp = 65535;
            }

            *pwRampR = (WORD)iTemp;
            *pwRampG = (WORD)iTemp;
            *pwRampB = (WORD)iTemp;

            pwRampR++;
            pwRampG++;
            pwRampB++;
        }

        // And do the hardware itself.

        hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
        if ( hDC != NULL )
        {
            bRes = SetDeviceGammaRamp ( hDC, wRamp );
            DELETE_DRIVER_DC ( hDC );
            ASSERTDD ( bRes, "DdControlColor - SetDeviceGammaRamp failed" );
        }
        else
        {
            ASSERTDD ( FALSE, "DdControlColor - CREATE_DRIVER_DC failed" );
        }
    }
    else
    {
        // Don't know what they want to do. Panic.
        ASSERTDD ( FALSE, "DdControlColor - don't know what to do." );
        lpColConData->ddRVal = DDERR_INVALIDPARAMS;
        return ( DDHAL_DRIVER_HANDLED );
    }

    lpColConData->ddRVal = DD_OK;
    return ( DDHAL_DRIVER_HANDLED );

} // DdControlColor

#endif // W95_DDRAW

DirectXGlobals  g_DXGlobals = { 0 };

#if WNT_DDRAW
//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DdMapMemory
//
// Maps application-modifiable portions of the frame buffer into the 
// user-mode address space of the specified process, or unmaps memory.
//
// DdMapMemory is called to perform memory mapping before the first call to 
// DdLock. The handle returned by the driver in fpProcess will be passed to 
// every DdLock call made on the driver. 
//
// DdMapMemory is also called to unmap memory after the last DdUnLock call is 
// made.
//
// To prevent driver crashes, the driver must not map any portion of the frame
// buffer that must not be modified by an application.
//
// Parameters
//      lpMapMemory 
//          Points to a DD_MAPMEMORYDATA structure that contains details for 
//          the memory mapping or unmapping operation. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that represents 
//              the driver. 
//          .bMap 
//              Specifies the memory operation that the driver should perform. 
//              A value of TRUE indicates that the driver should map memory; 
//              FALSE means that the driver should unmap memory. 
//          .hProcess 
//              Specifies a handle to the process whose address space is 
//              affected. 
//          .fpProcess 
//              Specifies the location in which the driver should return the 
//              base address of the process's memory mapped space when bMap 
//              is TRUE. When bMap is FALSE, fpProcess contains the base 
//              address of the memory to be unmapped by the driver.
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdMapMemory callback. A return code of DD_OK 
//              indicates success. 
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdMapMemory(
    PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DBG_CB_ENTRY(DdMapMemory);

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                       &ShareMemory,
                       sizeof(VIDEO_SHARE_MEMORY),
                       &ShareMemoryInformation,
                       sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                       &ReturnedDataLength))
        {
            DISPDBG((ERRLVL, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
     
            DISPDBG((ERRLVL, "DdMapMemory: Exit GEN, DDHAL_DRIVER_HANDLED"));
            
            DBG_CB_EXIT(DdMapMemory, DDERR_GENERIC);
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess = 
                            (FLATPTR) ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                       &ShareMemory,
                       sizeof(VIDEO_SHARE_MEMORY),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;

    DBG_CB_EXIT(DdMapMemory, DD_OK);
    return(DDHAL_DRIVER_HANDLED);
} // DdMapMemory

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// BOOL DrvGetDirectDrawInfo
//
// Function called by DirectDraw to returns the capabilities of the graphics
// hardware
//
// Parameters:
//
// dhpdev-------Is a handle to the PDEV returned by the driver's DrvEnablePDEV
//              routine.
// pHalInfo-----Points to a DD_HALINFO structure in which the driver should
//              return the hardware capabilities that it supports. 
// pdwNumHeaps--Points to the location in which the driver should return the
//              number of VIDEOMEMORY structures pointed to by pvmList. 
// pvmList------Points to an array of VIDEOMEMORY structures in which the
//              driver should return information about each video memory chunk
//              that it controls. The driver should ignore this parameter when
//              it is NULL. 
// pdwNumFourCC-Points to the location in which the driver should return the
//              number of DWORDs pointed to by pdwFourCC. 
// pdwFourCC----Points to an array of DWORDs in which the driver should return
//              information about each FOURCC that it supports. The driver
//              should ignore this parameter when it is NULL.
//
// Return:
//  Returns TRUE if it succeeds; otherwise, it returns FALSE
//
// Note:
//  This function will be called twice before DrvEnableDirectDraw is called.
//
// Comments
//  The driver's DrvGetDirectDrawInfo routine should do the following: 
//  1)When pvmList and pdwFourCC are NULL: 
//  Reserve off-screen video memory for DirectDraw use. Write the number of
//  driver video memory heaps and supported FOURCCs in pdwNumHeaps and
//  pdwNumFourCC, respectively. 
//
//  2)When pvmList and pdwFourCC are not NULL: 
//  Write the number of driver video memory heaps and supported FOURCCs in
//  pdwNumHeaps and pdwNumFourCC, respectively.
//  Get ptr to reserved offscreen mem? 
//  For each VIDEOMEMORY structure in the list to which pvmList points, fill in
//  the appropriate members to describe a particular chunk of display memory.
//  The list of structures provides DirectDraw with a complete description of
//  the driver's off-screen memory. 
//
//  3)Initialize the members of the DD_HALINFO structure with driver-specific
//  information as follows: 
//  Initialize the appropriate members of the VIDEOMEMORYINFO structure to
//  describe the general characteristics of the display's memory. 
//  Initialize the appropriate members of the DDNTCORECAPS structure to
//  describe the capabilities of the hardware. 
//  If the driver implements a DdGetDriverInfo function, set GetDriverInfo to
//  point to it and set dwFlags to DDHALINFO_GETDRIVERINFOSET
//
//-----------------------------------------------------------------------------
BOOL 
DrvGetDirectDrawInfo(
    DHPDEV dhpdev,
    DD_HALINFO*     pHalInfo,
    DWORD*          pdwNumHeaps,
    VIDEOMEMORY*    pvmList,            // Will be NULL on first call
    DWORD*          pdwNumFourCC,
    DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    DWORD Unused = 0;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwChipConfig;
    DWORD cHeaps;
    static DWORD fourCC[] =  { FOURCC_YUV422 };  // The FourCC's we support
    

    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    DBG_CB_ENTRY(DrvGetDirectDrawInfo);

    *pdwNumFourCC = 0;

    // We may not support DirectDraw on this card:

    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
    {
        DISPDBG((ERRLVL, "DrvGetDirectDrawInfo: exit, not enabled"));
        DBG_CB_EXIT(DrvGetDirectDrawInfo,FALSE);
        return(FALSE);
    }

    // Need a pointer to the registers to read config info
    pThisDisplay->pGLInfo->pRegs = (ULONG_PTR) ppdev->pulCtrlBase[0];

//@@BEGIN_DDKSPLIT
    //azn - loss of bits 64->32
//@@END_DDKSPLIT
   
    pThisDisplay->control = (FLATPTR)pThisDisplay->pGLInfo->pRegs;
    pThisDisplay->pGlint = (FPGLREG)pThisDisplay->control;

#if DBG
    // We can only initialise g_pThisTemp after 
    // the registers have been mapped in.
    g_pThisTemp = pThisDisplay;
#endif

    // Decide if we can use AGP or not
    dwChipConfig = 
        (DWORD)((PREGISTERS)pThisDisplay->pGLInfo->pRegs)->Glint.ChipConfig;

    // Make the AGP decision (NT Only!)
    if ( ((dwChipConfig & PM_CHIPCONFIG_AGP1XCAPABLE) ||
          (dwChipConfig & PM_CHIPCONFIG_AGP2XCAPABLE) ||
          (dwChipConfig & PM_CHIPCONFIG_AGP4XCAPABLE))    )
    {
        DISPDBG((WRNLVL,"AGP Permedia3 Board detected!"));
        pThisDisplay->bCanAGP = TRUE;        
    }
    else
    {
        DISPDBG((WRNLVL,"Permedia3 Board is NOT AGP"));    
        pThisDisplay->bCanAGP = FALSE;
    }

    // Fill in the DDHAL Informational caps that Win95 has setup.
    __GetDDHALInfo(pThisDisplay, pHalInfo);

    // On Win2K we need to return the D3D callbacks
    DISPDBG((DBGLVL ,"Creating Direct3D info"));
    _D3DHALCreateDriver(pThisDisplay);

    // Record the pointers that were created.  Note that the above call 
    // may not have recreated a previous set of data.
    pHalInfo->lpD3DGlobalDriverData = (void*)pThisDisplay->lpD3DGlobalDriverData;
    pHalInfo->lpD3DHALCallbacks = (void*)pThisDisplay->lpD3DHALCallbacks;
    pHalInfo->lpD3DBufCallbacks = (void *)pThisDisplay->lpD3DBufCallbacks;
    if ( (pHalInfo->lpD3DBufCallbacks) && 
         (pHalInfo->lpD3DBufCallbacks->dwSize != 0))
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
    }

    // Fill in any DDHAL caps that are specific to Windows NT.
     // Current primary surface attributes:
    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = 0;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize        = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags       = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cjPelSize * 8;
    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:
    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

//@@BEGIN_DDKSPLIT
    // Free up as much off-screen memory as possible:
    //TMM ?? bMoveAllDfbsFromOffscreenToDibs(ppdev);
//@@END_DDKSPLIT

    // We have to tell DirectDraw our preferred off-screen alignment, even
    // if we're doing our own off-screen memory management:
    pHalInfo->vmiData.dwOffscreenAlign = 4;

    pHalInfo->vmiData.dwZBufferAlign = 4;
    pHalInfo->vmiData.dwTextureAlign = 4;
    pHalInfo->vmiData.dwOverlayAlign = 4;

    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    pHalInfo->ddCaps.dwVidMemTotal = 
                ppdev->heap.cxMax * ppdev->heap.cyMax * ppdev->cjPelSize;

    // If we are on Permedia, then setup the YUV modes for Video playback 
    // acceleration. We can do YUV conversions at any depth except 8 bits...
    // On Win95 this information is setup in the Mini Display Driver.
    if (ppdev->iBitmapFormat != BMF_8BPP) 
    {
        *pdwNumFourCC = sizeof( fourCC ) / sizeof( fourCC[0] );
        if (pdwFourCC)
        {
            memcpy(pdwFourCC, fourCC, sizeof(fourCC));
        }
    }

    cHeaps = 0;

    if(pThisDisplay->bCanAGP)
    {
        ++cHeaps; // agp memory heap
    }

    // Report the heaps we want DD to manage. 
    // Currently this is needed in this sample for the AGP heap.
    if(pvmList)
    {
        VIDEOMEMORY *pVm = pvmList;
        
        // If we support AGP , then define the AGP heap               
        if(pThisDisplay->bCanAGP)
        {
            DWORD dwAGPMemBytes;

//@@BEGIN_DDKSPLIT                
            // azn This business of hard-allocating 32MB is not right. 
            // We need to fix it and verify with JeffN what's the best 
            // policy to show in the sample

            // Request a suitably sized AGP heap, don't ask for a heap 
            // larger than the available memory 
            // This is taken care of by the W2000 runtime policy, so I don't 
            // think we need to do this for W2k.  CTM.
//@@END_DDKSPLIT                

            // Default to 32Mb of AGP memory
            dwAGPMemBytes = 32*1024*1024;

            // Report the AGP heap
            // fpStart---Points to the starting address of a memory range in the
            // heap. 
            // fpEnd-----Points to the ending address of a memory range if the heap
            // is linear. This address is inclusive, that is, it specifies the last
            // valid address in the range. Thus, the number of bytes specified by
            // fpStart and fpEnd is (fpEnd-fpStart+1).          
                
            // DDraw ignores our start address so just set to zero
            pVm->fpStart = 0;

            // Fetch the last byte of AGP memory
            pVm->fpEnd = dwAGPMemBytes - 1;
            
            pVm->dwFlags = VIDMEM_ISNONLOCAL | 
                           VIDMEM_ISLINEAR   | 
                           VIDMEM_ISWC;
            
            // Only use AGP memory for texture surfaces
            pVm->ddsCaps.dwCaps = DDSCAPS_OVERLAY        | 
                                  DDSCAPS_OFFSCREENPLAIN |
                                  DDSCAPS_FRONTBUFFER    |
                                  DDSCAPS_BACKBUFFER     | 
                                  DDSCAPS_ZBUFFER        | 
                                  DDSCAPS_3DDEVICE;

            pVm->ddsCapsAlt.dwCaps = DDSCAPS_OVERLAY        | 
                                     DDSCAPS_OFFSCREENPLAIN |
                                     DDSCAPS_FRONTBUFFER    |
                                     DDSCAPS_BACKBUFFER     | 
                                     DDSCAPS_ZBUFFER        | 
                                     DDSCAPS_3DDEVICE;

            DISPDBG((DBGLVL, "Initialised AGP Heap for P2, Start:0x%x, End:0x%x", 
                        pVm->fpStart, pVm->fpEnd));

            ++pVm;
        }
        else
        {
            DISPDBG((WRNLVL, "NOT reporting AGP heap"));
        }
    }
    else
    {
        DISPDBG((DBGLVL, "Heap info NOT requested"));
    }

    // Report the number of heaps we support
    if (pdwNumHeaps)
    {
        *pdwNumHeaps = cHeaps;
    }

    DBG_CB_EXIT(DrvGetDirectDrawInfo,TRUE);
    
    return(TRUE);
} // DrvGetDirectDrawInfo


#endif  // WNT_DDRAW

#if USE_FLIP_BACKOFF
//-----------------------------------------------------------------------------
//
// __WaitTimeDelay 
//
//-----------------------------------------------------------------------------
#define WAIT_TIME_DELAY 2
void __WaitTimeDelay(void)
{
    static DWORD dwLastTime; // Doesn't matter what the 
                             // start value is (honest!)
    DWORD dwCurTime, iTimeDiff;

    // Make sure that we don't start hammering on the chip.
    // If someone uses the WAIT flag, or they do a loop
    // themselves, we will constantly be reading the chip,
    // which will disrupt the DMA stream. Therefore,
    // make sure we don't start reading it too often.
    // This #define will need tweaking, of course.  
    
    do
    {
        dwCurTime = timeGetTime();
        // Be careful about wraparound conditions.
        iTimeDiff = (signed int)( dwCurTime - dwLastTime );
    } while ( ( iTimeDiff > 0 ) && ( iTimeDiff < WAIT_TIME_DELAY ) );
    
    // And store the new "last" time.
    dwLastTime = dwCurTime;
    
} // __WaitTimeDelay
#endif //#if USE_FLIP_BACKOFF

//-----------------------------------------------------------------------------
//
// __QueryRenderIDStatus 
//
// Checks to see if the given two RenderIDs have been finished yet.
//
// If there is a problem, the pipeline will be flushed and the
// RenderIDs set to the newest ID.
//
// If bAllowDMAFlush is TRUE, then if either RenderID is still in the
// pipe, the current DMA buffer is flushed. Otherwise there is a 
// fairly good chance that the command with that RenderID may simply
// sit in the DMA buffer and never be executed. To disable this,
// pass in FALSE. This may be needed because the routine has already
// grabbed the DMA buffer, etc. and in that case it needs to do the flush
// itself when it gets DDERR_WASSTILLDRAWING.
//
// The return value is either DD_OK (both RenderIDs have been finished),
// or DDERR_WASSTILLDRAWING.
//
//-----------------------------------------------------------------------------
HRESULT 
__QueryRenderIDStatus( 
    P3_THUNKEDDATA* pThisDisplay,  
    BOOL bAllowDMAFlush )
{
    P3_DMA_DEFS();

    ASSERTDD ( CHIP_RENDER_ID_IS_VALID(), 
               "** __QueryRenderIDStatus:Chip RenderID was invalid - fix it!");
               
    if ( RENDER_ID_HAS_COMPLETED ( pThisDisplay->dwLastFlipRenderID ))
    {
        // OK, the RenderID has cleared the pipe, so we can carry on.
        return ( DD_OK );
    }
    else
    {
        // Can't flip yet - one surface is still pending.
        if (!NEED_TO_RESYNC_CHIP_AND_SURFACE (pThisDisplay->dwLastFlipRenderID))
        {
            // No error - we just need to wait. We'll flush the buffer and 
            // return DDERR_WASSTILLDRAWING

            if ( bAllowDMAFlush )
            {
                DDRAW_OPERATION(pContext, pThisDisplay);
                P3_DMA_GET_BUFFER();
                P3_DMA_FLUSH_BUFFER();
            }

#if USE_FLIP_BACKOFF
            __WaitTimeDelay();
#endif 

            return ( DDERR_WASSTILLDRAWING );
        }
        else
        {
            // Something went wrong - need to do a safety-net resync.
            
            DISPDBG((ERRLVL,"__QueryRenderIDStatus: "
                            "RenderID failure - need a resync"));
            SYNC_WITH_GLINT;
            pThisDisplay->dwLastFlipRenderID = GET_HOST_RENDER_ID();

            // And continue with the operation.
            return ( DD_OK );
        }
    }
} // __QueryRenderIDStatus

//-----------------------------------------------------------------------------
//
// _DX_QueryFlipStatus
//
// Checks and sees if the most recent flip has occurred. If so returns DD_OK.
//
//-----------------------------------------------------------------------------
HRESULT 
_DX_QueryFlipStatus( 
    P3_THUNKEDDATA* pThisDisplay, 
    FLATPTR fpVidMem, 
    BOOL bAllowDMAFlush )
{       
    // If fpVidMem == 0, the Query is asking for the 'general flip status'.
    // The question is "Am I safe to add another flip, independent of surfaces".
    // If fpVidmem != 0, the Query is asking if it is safe to 'use' the current 
    // fpvidmem surface. It will only be safe to use unconditionally if that 
    // surface has been succesfully flipped away from, OR it was not the last 
    // surface flipped away from.
    
    // The answers will be yes, iff the RenderID of the flip travelling down 
    // the core has been sent to the MemoryController and put in the scratch ID, 
    // and iff the bypass pending bit has been cleared. These two checks 
    // effectively guarantee that the previously queue'd flip has taken place.

    // The fpFlipFrom is a record of the last surface that was flipped away from
    if((fpVidMem == 0) || (fpVidMem == pThisDisplay->flipRecord.fpFlipFrom))
    {
        DWORD dwVidControl;
        HRESULT hres;

        // Check if the pThisDisplay->dwLastFlipRenderID has completed
        hres = __QueryRenderIDStatus ( pThisDisplay, bAllowDMAFlush );

        if ( SUCCEEDED(hres) )
        {
            BOOL bFlipHasFinished;
            // OK, the previous flip has got to the end of the pipe,
            // but it may not actually have happened yet.
            // Read the Bypass pending bit.  If it's clear then 
            // we proceed.
#if W95_DDRAW
            if ( ( ( pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY ) != 0 ) &&
                 ( ( pThisDisplay->pGLInfo->dwScreenWidth != 
                      pThisDisplay->pGLInfo->dwVideoWidth     ) ||
                   ( pThisDisplay->pGLInfo->dwScreenHeight != 
                      pThisDisplay->pGLInfo->dwVideoHeight    )  ) )
            {
                // Display driver is using the overlay on a DFP, so we need to
                // check the overlay pending bit, not the screen pending bit.
                if ( ( ( READ_GLINT_CTRL_REG(VideoOverlayUpdate) ) & 0x1 ) == 0 )
                {
                    bFlipHasFinished = TRUE;
                }
                else
                {
                    bFlipHasFinished = FALSE;
                }
            }
            else
#endif // W95_DDRAW
            {
                dwVidControl = READ_GLINT_CTRL_REG(VideoControl);
                if (dwVidControl & (0x1 << 7))
                {
                    bFlipHasFinished = FALSE;
                }
                else
                {
                    bFlipHasFinished = TRUE;
                }
            }
            
            if ( bFlipHasFinished )
            {
                // This flip has actually completed.
                return ( DD_OK );            
            }
            else
            {
#if USE_FLIP_BACKOFF
                __WaitTimeDelay();
#endif //#if USE_FLIP_BACKOFF

                return ( DDERR_WASSTILLDRAWING );
            }
        }
        else
        {
            // No, still waiting for the flip command to exit the pipe.
            return ( DDERR_WASSTILLDRAWING );
        }
    }
    else
    {
        return ( DD_OK );
    }
} // _DX_QueryFlipStatus 

//-----------------------------Public Routine----------------------------------
//
// DdFlip
//
// Causes the surface memory associated with the target surface to become 
// the primary surface, and the current surface to become the nonprimary 
// surface.
//
// DdFlip allows a display driver to perform multi-buffering. DirectDraw drivers 
// must implement this function.
//
// The driver should update its surface pointers so that the next frame will be 
// written to the surface to which lpSurfTarg points. If a previous flip request 
// is still pending, the driver should fail the call and return 
// DDERR_WASSTILLDRAWING. The driver should ensure that the scan line is not in 
// the vertical blank before performing the flip. DdFlip does not affect the 
// actual display of the video data.
//
// If the driver's hardware supports overlays or textures, DdFlip should make 
// any necessary checks based on the surface type before performing the flip.
//
// Parameters
//
//      lpFlipData
//          Points to a DD_FLIPDATA structure that contains the information 
//          required to perform the flip. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpSurfCurr 
//              Points to the DD_SURFACE_LOCAL structure describing the 
//              current surface. 
//          .lpSurfTarg 
//              Points to the DD_SURFACE_LOCAL structure describing the 
//              target surface; that is, the surface to which the driver 
//              should flip. 
//          .dwFlags 
//              This is a set of flags that provide the driver with details 
//              for the flip. This member can be a bit-wise OR of the 
//              following flags: 
//
//              DDFLIP_EVEN 
//                  The surface to which lpSurfTarg points contains only 
//                  the even field of video data. This flag is valid only when 
//                  the surface is an overlay, and is mutually exclusive of 
//                  DDFLIP_ODD. 
//              DDFLIP_ODD 
//                  The surface to which lpSurfTarg points contains only the 
//                  odd field of video data. This flag is valid only when the
//                  surface is an overlay, and is mutually exclusive of 
//                  DDFLIP_EVEN. 
//              DDFLIP_NOVSYNC 
//                  The driver should perform the flip and return immediately. 
//                  Typically, the now current back buffer (which used to be 
//                  the front buffer) is still visible until the next vertical 
//                  retrace. Subsequent operations involving the surfaces 
//                  to which lpSurfCurr and lpSurfTarg point will not check 
//                  to see if the physical flip has finished. This allows an 
//                  application to perform flips at a higher frequency than 
//                  the monitor refresh rate, although it might introduce 
//                  visible artifacts. 
//              DDFLIP_INTERVAL2 
//                  The driver should perform the flip on every other vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  second vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL3 and DDFLIP_INTERVAL4. 
//              DDFLIP_INTERVAL3 
//                  The driver should perform the flip on every third vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  third vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL2 and DDFLIP_INTERVAL4. 
//              DDFLIP_INTERVAL4 
//                  The driver should perform the flip on every fourth vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  fourth vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL2 and DDFLIP_INTERVAL3. 
//
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdFlip callback. A return code of DD_OK indicates 
//              success. 
//          .Flip 
//              This is unused on Windows 2000. 
//          .lpSurfCurrLeft 
//              Points to the DD_SURFACE_LOCAL structure describing the current 
//              left surface. 
//          .lpSurfTargLeft 
//              Points to the DD_SURFACE_LOCAL structure describing the left 
//              target surface to flip to. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdFlip( 
    LPDDHAL_FLIPDATA lpFlipData)
{
    DWORD       dwDDSurfaceOffset;
    P3_THUNKEDDATA* pThisDisplay;
    HRESULT ddrval;
    GET_THUNKEDDATA(pThisDisplay, lpFlipData->lpDD);
    
    DBG_CB_ENTRY(DdFlip);
    
    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Is the previous Flip already done? Check if the current surface is
    // already displayed and don't allow a new flip (unless the DDFLIP_NOVSYNC
    // is set) to queue if the old one isn't finished.
    ddrval = _DX_QueryFlipStatus(pThisDisplay, 0, TRUE);
    if((FAILED(ddrval)) && 
       !(lpFlipData->dwFlags & DDFLIP_NOVSYNC))
    {
        lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;

        START_SOFTWARE_CURSOR(pThisDisplay);

        DBG_CB_EXIT(DdFlip,DDERR_WASSTILLDRAWING);  
        return DDHAL_DRIVER_HANDLED;
    }

    // Set the flipped flag so that the D3D side does any necessary 
    // setup updates before starting to render the next frame 
    pThisDisplay->bFlippedSurface = TRUE;


    // Do the flip
    {
        P3_DMA_DEFS();
        DWORD dwNewRenderID;

        DDRAW_OPERATION(pContext, pThisDisplay);

        P3_DMA_GET_BUFFER_ENTRIES(12);

        // Make sure all the rendering is finished
        SYNC_WITH_GLINT;

        // Check the surface type (overlay or not overlay)
        
        // Update the overlay
        if ((((pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY) != 0) &&
             ((pThisDisplay->pGLInfo->dwScreenWidth != 
                    pThisDisplay->pGLInfo->dwVideoWidth) ||
              (pThisDisplay->pGLInfo->dwScreenHeight != 
                    pThisDisplay->pGLInfo->dwVideoHeight))) ||
              (lpFlipData->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
            DWORD dwVideoOverlayUpdate;

            do
            {
                dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
            } while ((dwVideoOverlayUpdate & 0x1) != 0);

            // Just let the overlay routine do the hard work.
            // Tell it that this is a screen emulation.
            _DD_OV_UpdateSource(pThisDisplay, 
                                lpFlipData->lpSurfTarg);

            UPDATE_OVERLAY(pThisDisplay, 
                           !(lpFlipData->dwFlags & DDFLIP_NOVSYNC),
                           FALSE);
        }
        else // Normal mode - flip the screen address.
        {                        
            ULONG ulVControl;

#if W95_DDRAW
            // Apps should use the DDFLIP_NOVSYNC to take advantage of
            // the new capability of the Perm3
            if (! (lpFlipData->dwFlags & DDFLIP_NOVSYNC))
            {
                if (READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE)  
                {
                    LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET); 
                    while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);
                }
            }
#endif

#if DX7_STEREO
            if (lpFlipData->dwFlags & DDFLIP_STEREO )   // will be stereo
            {
                if (lpFlipData->lpSurfTargLeft)
                {
                    dwDDSurfaceOffset = 
                        (DWORD)(lpFlipData->lpSurfTargLeft->lpGbl->fpVidMem -
                                pThisDisplay->dwScreenFlatAddr);
                    
                    // Update the screenbase address using the DownloadAddress 
                    // & Data mechanism (therefore through the core)
                    SEND_P3_DATA(VTGAddress, 
                                 VTG_VIDEO_ADDRESS(VID_SCREENBASERIGHT));
                    SEND_P3_DATA(VTGData, (dwDDSurfaceOffset >> 4) );
                }
        
                ulVControl = READ_GLINT_CTRL_REG(VideoControl);
                LOAD_GLINT_CTRL_REG(VideoControl, 
                                    ulVControl | __VIDEO_STEREOENABLE);
            }
            else
            {
                ulVControl = READ_GLINT_CTRL_REG(VideoControl);
                LOAD_GLINT_CTRL_REG(VideoControl, 
                                    ulVControl & (~__VIDEO_STEREOENABLE));
            }
#endif
            // Get the surface offset from the start of memory
            dwDDSurfaceOffset = 
                (DWORD)(lpFlipData->lpSurfTarg->lpGbl->fpVidMem - 
                        pThisDisplay->dwScreenFlatAddr);

            // Update the screenbase address using the DownloadAddress/data 
            // mechanism (therefore through the core)
            // Setup so that DownloadData will update the ScreenBase Address.
            SEND_P3_DATA(VTGAddress, VTG_VIDEO_ADDRESS(VID_SCREENBASE));
            SEND_P3_DATA(VTGData, (dwDDSurfaceOffset >> 4) );
        }

        // Send a new RenderID to the chip.
        dwNewRenderID = GET_NEW_HOST_RENDER_ID();
        SEND_HOST_RENDER_ID ( dwNewRenderID );
        pThisDisplay->dwLastFlipRenderID = dwNewRenderID;

        // Flush the P3 Data
        P3_DMA_COMMIT_BUFFER();
        P3_DMA_FLUSH_BUFFER();

    }

    // Remember where we flipped from
    pThisDisplay->flipRecord.fpFlipFrom = 
                            lpFlipData->lpSurfCurr->lpGbl->fpVidMem;

    lpFlipData->ddRVal = DD_OK;

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdFlip,DD_OK);        
    
    return DDHAL_DRIVER_HANDLED;

} // DdFlip 

//-----------------------------Public Routine----------------------------------
//
// DdWaitForVerticalBlank
//
// Returns the vertical blank status of the device.
//
// Parameters
//
//      lpWaitForVerticalBlank 
//          Points to a DD_WAITFORVERTICALBLANKDATA structure that
//          contains the information required to obtain the vertical
//          blank status.
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                  Points to the DirectDraw structure representing
//                  the DirectDraw object.
//          DWORD
//          dwFlags
//                  Specifies how the driver should wait for the vertical blank.
//                  This member can be one of the following values: 
//
//              DDWAITVB_I_TESTVB           The driver should determine whether
//                                          a vertical blank is currently
//                                          occurring and return the status in
//                                          bIsInVB. 
//              DDWAITVB_BLOCKBEGIN         The driver should return when it
//                                          detects the beginning of the vertical
//                                          blank interval. 
//              DDWAITVB_BLOCKBEGINEVENT    Is currently unsupported on Windows
//                                          2000 and should be ignored by the
//                                          driver. 
//              DDWAITVB_BLOCKEND           The driver should return when it
//                                          detects the end of the vertical
//                                          blank interval and display begins.
//          DWORD
//          bIsInVB 
//                  Indicates the status of the vertical blank. A value of
//                  TRUE indicates that the device is in a vertical blank;
//                  FALSE means that it is not. The driver should return the
//                  current vertical blanking status in this member when
//                  dwFlags is DDWAITVB_I_TESTVB. 
//          DWORD
//          hEvent 
//                  Is currently unsupported on Windows 2000 and should be ignored
//                  by the driver. 
//          HRESULT
//          ddRVal 
//                  Is the location in which the driver writes the return value of
//                  the DdWaitForVerticalBlank callback. A return code of DD_OK
//                  indicates success. 
//          VOID*
//          WaitForVerticalBlank 
//                  Is unused on Windows 2000.
//
// Return Value
//      DdWaitForVerticalBlank returns one of the following callback codes:
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//      Depending on the value of dwFlags, the driver should do the following:
//
//      If dwFlags is DDWAITVB_I_TESTVB, the driver should query the current
//      vertical blanking status. The driver should set bIsInVB to TRUE if the
//      monitor is currently in a vertical blank; otherwise it should set it
//      to FALSE.
//
//      If dwFlags is DDWAITVB_BLOCKBEGIN, the driver should block and wait
//      until a vertical blank begins. If a vertical blank is in progress when
//      the driver begins the block, the driver should wait until the next
//      vertical blank begins before returning.
//
//      If dwFlags is DDWAITVB_BLOCKEND, the driver should block and wait
//      until a vertical blank ends.
//
//      When the driver successfully handles the action specified in dwFlags,
//      it should set DD_OK in ddRVal and return DDHAL_DRIVER_HANDLED. The
//      driver should return DDHAL_DRIVER_NOTHANDLED for those flags that it
//      is incapable of handling.
//
//      DdWaitForVerticalBlank allows an application to synchronize itself
//      with the vertical blanking interval (VBI).
//
//-----------------------------------------------------------------------------
// bit in VideoControl Register
#define __GP_VIDEO_ENABLE               0x0001

DWORD CALLBACK 
DdWaitForVerticalBlank(
    LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    static BOOL bBlankReturn = TRUE;
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpWaitForVerticalBlank->lpDD);

    DBG_CB_ENTRY(DdWaitForVerticalBlank);

    switch(lpWaitForVerticalBlank->dwFlags)
    {
        case DDWAITVB_I_TESTVB:

            //
            // just toggle the return bit when monitor is powered off
            //

            if( ! ( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) )
            {
                lpWaitForVerticalBlank->bIsInVB = bBlankReturn;
                bBlankReturn = !bBlankReturn;
            }
            else
            {
                // Just a request for current VBLANK status
                lpWaitForVerticalBlank->bIsInVB = IN_VBLANK;
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;

        case DDWAITVB_BLOCKBEGIN:

            //
            // only wait when the monitor is on
            //

            if( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) 
            {
                // if blockbegin is requested we wait until the vertical 
                // retrace is over, and then wait for the display period to end.
                while(IN_VBLANK)
                    NULL;
                
                while(!IN_VBLANK)
                    NULL;
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;

        case DDWAITVB_BLOCKEND:

            //
            // only wait when the monitor is on
            //

            if( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) 
            {
                // if blockend is requested we wait for the vblank interval to end.
                if( IN_VBLANK )
                {
                    while( IN_VBLANK )
                        NULL;
                }
                else
                {
                    while(IN_DISPLAY)
                        NULL;
                    
                    while(IN_VBLANK)
                        NULL;
                }
            }
            
            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;
    }

    DBG_CB_EXIT(DdWaitForVerticalBlank,0);   
    return DDHAL_DRIVER_NOTHANDLED;

} // DdWaitForVerticalBlank

//-----------------------------Public Routine----------------------------------
//
// DdLock
//
// Locks a specified area of surface memory and provides a valid pointer to a
// block of memory associated with a surface.
//
// Parameters
//      lpLock 
//              Points to a DD_LOCKDATA structure that contains the information
//              required to perform the lockdown.
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD
//                  Points to a DD_DIRECTDRAW_GLOBAL structure that
//                  describes the driver.
//          PDD_SURFACE_LOCAL
//          lpDDSurface
//                  Points to a DD_SURFACE_LOCAL structure that describes the
//                  surface associated with the memory region to be locked down.
//          DWORD
//          bHasRect
//                  Specifies whether the area in rArea is valid.
//          RECTL
//          rArea
//                  Is a RECTL structure that defines the area on the
//                  surface to lock down.
//          LPVOID
//          lpSurfData 
//                  Is the location in which the driver can return a pointer
//                  to the memory region that it locked down.
//          HRESULT
//          ddRVal
//                  Is the location in which the driver writes the return value
//                  of the DdLock callback. A return code of DD_OK
//                  indicates success.
//          VOID*
//          Lock
//                  Is unused on Windows 2000. 
//          DWORD
//          dwFlags 
//                  Is a bitmask that tells the driver how to perform the
//                  memory lockdown. This member is a bitwise-OR of any
//                  of the following values:
//
//              DDLOCK_SURFACEMEMORYPTR     The driver should return a valid
//                                          memory pointer to the top of the
//                                          rectangle specified in rArea. If
//                                          no rectangle is specified, the
//                                          driver should return a pointer to
//                                          the top of the surface. 
//              DDLOCK_WAIT                 This flag is reserved for system
//                                          use and should be ignored by the
//                                          driver. Otherwise performance may
//                                          be adversely hurt.
//              DDLOCK_READONLY             The surface being locked will only
//                                          be read from. On Windows 2000,
//                                          this flag is currently never set.
//              DDLOCK_WRITEONLY            The surface being locked will only
//                                          be written to. On Windows 2000,
//                                          this flag is currently never set.
//              DDLOCK_EVENT                This flag is reserved for system
//                                          use and should be ignored by the
//                                          driver. 
//          FLATPTR
//          fpProcess
//                  Is a pointer to a user-mode mapping of the driver's memory.
//                  The driver performs this mapping in DdMapMemory. 
//  Return Value
//          DdLock returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//  Comments
//
//      DdLock should set ddRVal to DDERR_WASSTILLDRAWING and return
//      DDHAL_DRIVER_HANDLED if a blt or flip is in progress.
//
//      Unless otherwise specified by dwFlags, the driver can return a memory
//      pointer to the top of the surface in lpSurfData. If the driver needs
//      to calculate its own address for the surface, it can rely on the
//      pointer passed in fpProcess as being a per-process pointer to the
//      user-mode mapping of its DirectDraw-accessible frame buffer.
//
//      A lock does not provide exclusive access to the requested memory block;
//      that is, multiple threads can lock the same surface at the same time.
//      It is the application's responsibility to synchronize access to the 
//      memory block whose pointer is being obtained.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdLock( 
    LPDDHAL_LOCKDATA lpLockData )
{ 
    HRESULT     ddrval;
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpLockData->lpDD);

    DBG_CB_ENTRY(DdLock);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, lpLockData->lpDDSurface);   

    //  This call is invoked to lock a DirectDraw Videomemory surface. To make
    //  sure there are no pending drawing operations on the surface, flush all
    //  drawing operations and wait for a flip if it is still pending.
   
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Check to see if any pending physical flip has occurred.  
    ddrval = _DX_QueryFlipStatus(pThisDisplay, 
                             lpLockData->lpDDSurface->lpGbl->fpVidMem, 
                             TRUE);    
    if( FAILED(ddrval) )
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        START_SOFTWARE_CURSOR(pThisDisplay);        
        
        DBG_CB_EXIT(DdLock,DDERR_WASSTILLDRAWING);        
        return DDHAL_DRIVER_HANDLED;
    }
    
    // don't allow a lock if a blt is in progress    
    if(DRAW_ENGINE_BUSY(pThisDisplay))
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        START_SOFTWARE_CURSOR(pThisDisplay);        
        
        DBG_CB_EXIT(DdLock, lpLockData->ddRVal);           
        return DDHAL_DRIVER_HANDLED;
    }

#if DX7_TEXMANAGEMENT
    //
    //  If the user attempts to lock a driver managed surface, 
    //  mark it as dirty  and return. This way next time we attempt
    //  to use the surface we will reload it from the sysmem copy
    //
    if (lpLockData->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
        DDSCAPS2_TEXTUREMANAGE)
    {
        DISPDBG((DBGLVL, "DDraw:Lock %08lx %08lx",
                         lpLockData->lpDDSurface->lpSurfMore->dwSurfaceHandle, 
                         lpLockData->lpDDSurface->lpGbl->fpVidMem));

        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                     lpLockData->lpDDSurface, 
                                     TRUE);

        if (lpLockData->bHasRect)  
        {
#if DX8_3DTEXTURES        
            if (lpLockData->dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT)
            {
                DWORD left, right, front, back;            
                // Sub Volume Lock suppport (DX8.1 feature)
                // Check if we are able to lock just a subvolume instead of 
                // the whole volume texture and therefore potentially increase 
                // performance.     

                // left and .right subfields of the rArea field have to be 
                // reinterpreted as also containing respectively the Front and 
                // Back coordinates of the locked volume in their higher 16 bits
                front = lpLockData->rArea.left  >> 16;
                back  = lpLockData->rArea.right >> 16;   
                left  = lpLockData->rArea.left  && 0xFFFF;
                right = lpLockData->rArea.right && 0xFFFF;     

                lpLockData->lpSurfData = (LPVOID)
                    (lpLockData->lpDDSurface->lpGbl->fpVidMem +
                    (front * lpLockData->lpDDSurface->lpGbl->dwBlockSizeY ) +
                    (lpLockData->lpDDSurface->lpGbl->lPitch * 
                                                lpLockData->rArea.top) +    
                    (lpLockData->rArea.left << 
                            DDSurf_GetPixelShift(lpLockData->lpDDSurface)));                
            }
            else
#endif // DX8_3DTEXTURES            
            {           
                lpLockData->lpSurfData = (LPVOID)
                    (lpLockData->lpDDSurface->lpGbl->fpVidMem +
                    (lpLockData->lpDDSurface->lpGbl->lPitch * 
                                                lpLockData->rArea.top) +    
                    (lpLockData->rArea.left << 
                            DDSurf_GetPixelShift(lpLockData->lpDDSurface)));
            }
        }
        else
        {
            lpLockData->lpSurfData = (LPVOID)
                                     (lpLockData->lpDDSurface->lpGbl->fpVidMem);
        }
                                
        lpLockData->ddRVal = DD_OK;

        START_SOFTWARE_CURSOR(pThisDisplay);        

        DBG_CB_EXIT(DdLock, lpLockData->ddRVal);        
        
        return DDHAL_DRIVER_HANDLED;
    }
#endif // DX7_TEXMANAGEMENT  

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // send a flush and wait for outstanding operations
    // before allowing surfaces to be locked.    
    {P3_DMA_DEFS();
     P3_DMA_GET_BUFFER();
     P3_DMA_FLUSH_BUFFER();
    }

    // Wait for outstanding operations before allowing surfaces to be locked
    SYNC_WITH_GLINT;

    // Since all our surfaces are linear we don't need to do 
    // a patch->unpatch conversion here.

    START_SOFTWARE_CURSOR(pThisDisplay);

    lpLockData->ddRVal = DD_OK;
    DBG_CB_EXIT(DdLock,lpLockData->ddRVal);      

    // Because we correctly set fpVidMem to be the offset into our frame
    // buffer when we created the surface, DirectDraw will automatically take
    // care of adding in the user-mode frame buffer address if we return
    // DDHAL_DRIVER_NOTHANDLED
    
    return(DDHAL_DRIVER_NOTHANDLED);
    
} // DdLock

//-----------------------------Public Routine----------------------------------
//
// DdUnlock
//
// Releases the lock held on the specified surface.
//
// Parameters
//
//      lpUnlock 
//                      Points to a DD_UNLOCKDATA structure that contains the
//                      information required to perform the lock release.
//
// Members
//
//      PDD_DIRECTDRAW_GLOBAL
//      lpDD 
//                  Points to a DD_DIRECTDRAW_GLOBAL structure that
//                  describes the driver.
//      PDD_SURFACE_LOCAL
//      lpDDSurface
//                  Points to a DD_SURFACE_LOCAL structure that describes the
//                  surface to be unlocked. 
//      HRESULT
//      ddRVal
//                  Is the location in which the driver writes the return value
//                  of the DdUnlock callback. A return code of DD_OK indicates
//                  success. 
//      VOID*
//      Unlock
//                  Is unused on Windows 2000. 
//
//  Return Value
//      DdUnlock returns one of the following callback codes: 
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//
//  Comments
//          The driver does not need to verify that the memory was previously
//          locked down by DdLock, because DirectDraw does parameter validation
//          before calling this routine. 
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdUnlock( 
    LPDDHAL_UNLOCKDATA lpUnlockData )
{ 
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdUnlock);

    lpUnlockData->ddRVal = DD_OK;

    DBG_CB_EXIT(DdUnlock,lpUnlockData->ddRVal);
    
    return ( DDHAL_DRIVER_HANDLED );

} // DdUnlock


//-----------------------------Public Routine----------------------------------
// DdGetScanLine
//
// Returns the number of the current physical scan line.
//
// Parameters
//      pGetScanLine 
//                      Points to a DD_GETSCANLINEDATA structure in which the
//                      driver returns the number of the current scan line. 
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                      Points to a DD_DIRECTDRAW_GLOBAL structure that
//                      represents the driver. 
//          DWORD
//          dwScanLine 
//                      Is the location in which the driver returns the number
//                      of the current scan line. 
//          HRESULT
//          ddRVal 
//                      Is the location in which the driver writes the return
//                      value of the DdGetScanLine callback. A return code of
//                      DD_OK indicates success. 
//          VOID *
//          GetScanLine 
//                      Is unused on Windows 2000. 
// Return Value
//          DdGetScanLine returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//          If the monitor is not in vertical blank, the driver should write
//          the scan line value in dwScanLine. The number must be between zero
//          and n, where scan line 0 is the first visible scan line and n is
//          the last visible scan line on the screen. The driver should then
//          set DD_OK in ddRVal and return DDHAL_DRIVER_HANDLED.
//
//          The scan line is indeterminate if a vertical blank is in progress.
//          In this situation, the driver should set ddRVal to
//          DDERR_VERTICALBLANKINPROGRESS and return DDHAL_DRIVER_HANDLED.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdGetScanLine(
    LPDDHAL_GETSCANLINEDATA lpGetScanLine)
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetScanLine->lpDD);

    DBG_CB_ENTRY(DdGetScanLine);    

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    //
    // If a vertical blank is in progress the scan line is in
    // indeterminant. If the scan line is indeterminant we return
    // the error code DDERR_VERTICALBLANKINPROGRESS.
    // Otherwise we return the scan line and a success code
    //
    if( IN_VBLANK )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        lpGetScanLine->dwScanLine = 0;
    }
    else
    {
        LONG lVBEnd = READ_GLINT_CTRL_REG(VbEnd);
        LONG lScanline = READ_GLINT_CTRL_REG(LineCount);

        // Need to return a number from 0 -> (ScreenHeight + VBlank Size)
        lScanline = lScanline - lVBEnd;
        if (lScanline < 0)
        {
            lScanline = pThisDisplay->dwScreenHeight + (lVBEnd + lScanline);
        }

        // Modes less than 400 high are line-doubled.
        if (pThisDisplay->dwScreenHeight < 400)
        {
            lScanline >>= 1;
        }

        DISPDBG((DBGLVL,"Scanline: %d", lScanline));

        lpGetScanLine->dwScanLine = (DWORD)lScanline;
        lpGetScanLine->ddRVal = DD_OK;
    }

    DBG_CB_EXIT(DdGetScanLine,lpGetScanLine->ddRVal);  
    
    return DDHAL_DRIVER_HANDLED;

} // DdGetScanLine

//-----------------------------Public Routine----------------------------------
// DdGetBltStatus
//
// Queries the blt status of the specified surface.
//
// Parameters
//      lpGetBltStatus 
//                  Points to a DD_GETBLTSTATUSDATA structure that contains the
//                  information required to perform the blt status query. 
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                              Points to a DD_DIRECTDRAW_GLOBAL structure that
//                              describes the driver. 
//          PDD_SURFACE_LOCAL
//          lpDDSurface 
//                              Points to a DD_SURFACE_LOCAL structure
//                              representing the surface whose blt status is
//                              being queried. 
//          DWORD
//          dwFlags 
//                              Specifies the blt status being requested. This
//                              member can be one of the following values which
//                              are defined in ddraw.h: 
//
//                  DDGBS_CANBLT        Queries whether the driver 
//                                      can currently perform a blit.
//                  DDGBS_ISBLTDONE     Queries whether the driver
//                                      has completed the last blit. 
//          HRESULT
//          ddRVal 
//                              Is the location in which the driver writes the
//                              return value of the DdGetBltStatus callback.
//                              A return code of DD_OK indicates success.
//          VOID*
//          GetBltStatus
//                              Is unused on Windows 2000. 
// Return Value
//          DdGetBltStatus returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//          The blt status that the driver returns is based on the dwFlags
//          member of the structure that lpGetBltStatus points to as follows: 
//
//          If the flag is DDGBS_CANBLT, the driver should determine whether
//          the surface is currently involved in a flip. If a flip is not in
//          progress and if the hardware is otherwise capable of currently
//          accepting a blt request, the driver should return DD_OK in ddRVal.
//          If a flip is in progress or if the hardware cannot currently
//          accept another blt request, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING. 
//
//          If the flag is DDGBS_ISBLTDONE, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING if a blt is currently in progress; otherwise
//          it should return DD_OK.
//
//
//-----------------------------------------------------------------------------
DWORD CALLBACK DdGetBltStatus(
    LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetBltStatus->lpDD);

    DBG_CB_ENTRY(DdGetBltStatus);    

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Notice that your implementation could be optimized to check for the
    // particular surface specified. Here we are just querying the general
    // blt status of the engine.

    // Driver is being queried whether it can add a blt
    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT )
    {
        // Must explicitely wait for the flip 
        lpGetBltStatus->ddRVal = 
            _DX_QueryFlipStatus(pThisDisplay, 
                                lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem, 
                                TRUE);
                                
        if( SUCCEEDED( lpGetBltStatus->ddRVal ) )
        {
            // so there was no flip going on, is the engine idle to add a blt?
            if( DRAW_ENGINE_BUSY(pThisDisplay) )
            {
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else
            {
                lpGetBltStatus->ddRVal = DD_OK;
            }
        }
    }
    else if ( lpGetBltStatus->dwFlags == DDGBS_ISBLTDONE )
    {
        if ( DRAW_ENGINE_BUSY(pThisDisplay) )
        {
            lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
        else
        {
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdGetBltStatus, lpGetBltStatus->ddRVal);   
    
    return DDHAL_DRIVER_HANDLED;

} // DdGetBltStatus

//-----------------------------Public Routine----------------------------------
//
// DdGetFlipStatus
//
// Determines whether the most recently requested flip
// on a surface has occurred.
//
// Parameters
//      lpGetFlipStatus 
//                  Points to a DD_GETFLIPSTATUSDATA structure that contains
//                  the information required to perform the flip status query.
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                          Points to a DD_DIRECTDRAW_GLOBAL structure
//                          representing the driver. 
//          PDD_SURFACE_LOCAL
//          lpDDSurface 
//                          Points to a DD_SURFACE_LOCAL structure that
//                          describes the surface whose flip status is
//                          being queried.
//          DWORD
//          dwFlags 
//                          Specifies the flip status being requested. This
//                          member can be one of the following values which
//                          are defined in ddraw.h: 
//
//                  DDGFS_CANFLIP       Queries whether the driver can
//                                      currently perform a flip. 
//                  DDGFS_ISFLIPDONE    Queries whether the driver has
//                                      finished the last flip. 
//          HRESULT
//          ddRVal 
//                          Is the location in which the driver writes the
//                          return value of the DdGetFlipStatus callback.
//                          A return code of DD_OK indicates success. 
//          VOID*
//          GetFlipStatus 
//                          Is unused on Windows 2000.
//
// Return Value
//          DdGetFlipStatus returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//
//          The driver should report its flip status based on the flag set in
//          the dwFlags member of the structure that lpGetFlipStatus points
//          to as follows: 
//
//          If the flag is DDGFS_CANFLIP, the driver should determine whether
//          the surface is currently involved in a flip. If a flip or a blt is
//          not in progress and if the hardware is otherwise capable of
//          currently accepting a flip request, the driver should return DD_OK
//          in ddRVal. If a flip is in progress or if the hardware cannot
//          currently accept a flip request, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING.
//
//          If the flag is DDGFS_ISFLIPDONE, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING if a flip is currently in progress; otherwise
//          it should return DD_OK. 
//
// Notes:
//
// If the display has went through one refresh cycle since the flip
// occurred we return DD_OK.  If it has not went through one refresh
// cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
// is still busy "drawing" the flipped page.   We also return
// DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
// to know if they could flip yet
// 
// On the Permedia, flips are done using SuspendUntilFrameBlank,
// so no syncs ever need to be done in software, so this always
// returns DD_OK.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdGetFlipStatus(
    LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetFlipStatus->lpDD);

    DBG_CB_ENTRY(DdGetFlipStatus);     

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    //
    // don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem
    //
    lpGetFlipStatus->ddRVal = _DX_QueryFlipStatus(pThisDisplay, 0, TRUE);

    //
    // check if the bltter busy if someone wants to know if they can flip
    //
    if( lpGetFlipStatus->dwFlags == DDGFS_CANFLIP )
    {
        if( ( SUCCEEDED( lpGetFlipStatus->ddRVal ) ) && 
            ( DRAW_ENGINE_BUSY(pThisDisplay) )     )
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdGetFlipStatus,lpGetFlipStatus->ddRVal);   
    
    return DDHAL_DRIVER_HANDLED;
    

} // DdGetFlipStatus


//-----------------------------------------------------------------------------
// __SetupRops
//
// Build array for supported ROPS
//-----------------------------------------------------------------------------
static void 
__SetupRops( 
    LPBYTE proplist, 
    LPDWORD proptable, 
    int cnt )
{
    int         i;
    DWORD       idx;
    DWORD       bit;
    DWORD       rop;

    for(i=0; i<cnt; i++)
    {
        rop = proplist[i];
        idx = rop / 32; 
        bit = 1L << ((DWORD)(rop % 32));
        proptable[idx] |= bit;
    }

} // __SetupRops 


//-----------------------------------------------------------------------------
//
// ChangeDDHAL32Mode
//
// CALLED PER MODE CHANGE - NEVER AT START OF DAY (NO LOCK)
// Sets up Chip registers for this mode.
//
//-----------------------------------------------------------------------------
void 
ChangeDDHAL32Mode(
    P3_THUNKEDDATA* pThisDisplay)
{

    DISPDBG((DBGLVL,"New Screen Width: %d",pThisDisplay->dwScreenWidth));

//@@BEGIN_DDKSPLIT            
#if AZN  
    // If the driver has just started, reset the DMA Buffers to a known state.
    if (pThisDisplay->bStartOfDay)
    {
#if 0
        unsigned long i;

        for (i = 0; i < pThisDisplay->pGLInfo->NumberOfSubBuffers; i++)
        {
            pThisDisplay->pGLInfo->DMAPartition[i].bStampedDMA = TRUE;
            pThisDisplay->pGLInfo->DMAPartition[i].Locked = FALSE;
          
//azn - this is hard to say in 64 bits!
            memset((void*)pThisDisplay->pGLInfo->DMAPartition[i].VirtAddr, 
                   0x4D,
                   (pThisDisplay->pGLInfo->DMAPartition[i].MaxAddress - 
                            pThisDisplay->pGLInfo->DMAPartition[i].VirtAddr));

        }
#endif
        // We don't need start of day setup anymore
        pThisDisplay->bStartOfDay = FALSE;
    }
#endif
//@@END_DDKSPLIT    

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Set up video Control
#if WNT_DDRAW 
    {
        ULONG vidCon;
        
        vidCon = READ_GLINT_CTRL_REG(VideoControl);
        vidCon &= ~(3 << 9);
        vidCon |= (0 << 9);     // P3/P2 Limit to frame rate

        LOAD_GLINT_CTRL_REG(VideoControl, vidCon);
    }
#endif // WNT_DDRAW 

    // We have handled the display mode change
    pThisDisplay->bResetMode = 0;
    pThisDisplay->ModeChangeCount++;

    START_SOFTWARE_CURSOR(pThisDisplay);

}  // ChangeDDHAL32Mode


//-----------------------------------------------------------------------------
//
// Function: __GetDDHALInfo
//
// Returns: void
//
// Description:
//
// Takes a pointer to a partially or fully filled in pThisDisplay and a pointer
// to an empty DDHALINFO and fills in the DDHALINFO.  This eases porting to NT
// and means that caps changes are done in only one place.  The pThisDisplay
// may not be fully constructed here, so you should only:
// a) Query the registry
// b) DISPDBG
// If you need to add anything to pThisDisplay for NT, you should fill it in 
// during the DrvGetDirectDraw call.
//
// The problem here is when the code is run on NT.  If there was any other way...
//
// The following caps have been found to cause NT to bail....
// DDCAPS_GDI, DDFXCAPS_BLTMIRRORUPDOWN, DDFXCAPS_BLTMIRRORLEFTRIGHT
//
//
//-----------------------------------------------------------------------------

//
// use bits to indicate which ROPs you support.
//
// DWORD 0, bit 0 == ROP 0
// DWORD 8, bit 31 == ROP 255
//

static DWORD ropsAGP[DD_ROP_SPACE] = { 0 }; 

void 
__GetDDHALInfo(
    P3_THUNKEDDATA* pThisDisplay, 
    DDHALINFO* pHALInfo)
{
    DWORD dwResult;
    BOOL bRet;
    int i;

    static BYTE ropList95[] =
    {
        SRCCOPY >> 16,
        WHITENESS >> 16,
        BLACKNESS >> 16
    };

    static BYTE ropListNT[] =
    {
        SRCCOPY >> 16
    };

    static BYTE ropListAGP[] = 
    {
        SRCCOPY >> 16,
        WHITENESS >> 16,
        BLACKNESS >> 16
    };    

    static DWORD rops[DD_ROP_SPACE] = { 0 };  
      
    // Setup the HAL driver caps.
    memset( pHALInfo, 0, sizeof(DDHALINFO) );
    pHALInfo->dwSize = sizeof(DDHALINFO);


    // Setup the ROPS we do.
#ifdef WNT_DDRAW
    __SetupRops( ropListNT, 
                 rops, 
                 sizeof(ropListNT)/sizeof(ropListNT[0]));
#else
    __SetupRops( ropList95, 
                 rops, 
                 sizeof(ropList95)/sizeof(ropList95[0]));
#endif

    __SetupRops( ropListAGP, 
                 ropsAGP, 
                 sizeof(ropListAGP)/sizeof(ropListAGP[0]));

    // The most basic DirectDraw functionality
    pHALInfo->ddCaps.dwCaps =   DDCAPS_BLT          |
                                DDCAPS_BLTQUEUE     |
                                DDCAPS_BLTCOLORFILL |
                                DDCAPS_READSCANLINE;

    pHALInfo->ddCaps.ddsCaps.dwCaps =   DDSCAPS_OFFSCREENPLAIN |
                                        DDSCAPS_PRIMARYSURFACE |
                                        DDSCAPS_FLIP;

    // More caps on Win95 than on NT (mainly for D3D)
#ifdef WNT_DDRAW
    pHALInfo->ddCaps.dwCaps |= DDCAPS_3D           | 
                               DDCAPS_BLTDEPTHFILL;
                               
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE | 
                                       DDSCAPS_ZBUFFER | 
                                       DDSCAPS_ALPHA;
    pHALInfo->ddCaps.dwCaps2 = 0;
#else
    pHALInfo->ddCaps.dwCaps |=  DDCAPS_3D          |
                                DDCAPS_GDI         |
                                DDCAPS_ALPHA       |
                                DDCAPS_BLTDEPTHFILL;

    pHALInfo->ddCaps.ddsCaps.dwCaps |=  DDSCAPS_ALPHA    |
                                        DDSCAPS_3DDEVICE |
                                        DDSCAPS_ZBUFFER;
    
    pHALInfo->ddCaps.dwCaps2 = DDCAPS2_NOPAGELOCKREQUIRED | DDCAPS2_FLIPNOVSYNC;

#endif // WNT_DDRAW

#if DX7_TEXMANAGEMENT
    // We need to set this bit up in order to be able to do
    // out own texture management
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;
#if DX8_DDI
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGERESOURCE;
#endif
#endif

#if DX8_DDI
    // We need to flag we can run in windowed mode, otherwise we
    // might get restricted by apps to run in fullscreen only
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;  
#endif    

    pHALInfo->ddCaps.dwFXCaps = 0;
 
    // P3RX can do:
    // 1. Stretching/Shrinking
    // 2. YUV->RGB conversion
    // 3. Mirroring in X and Y
    // 4. ColorKeying from a source color and a source color space
    pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH   |
                               DDCAPS_BLTFOURCC    |
                               DDCAPS_COLORKEY     |
                               DDCAPS_CANBLTSYSMEM;

    // Special effects caps
    pHALInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTSTRETCHY  |
                                DDFXCAPS_BLTSTRETCHX  |
                                DDFXCAPS_BLTSTRETCHYN |
                                DDFXCAPS_BLTSTRETCHXN |
                                DDFXCAPS_BLTSHRINKY   |
                                DDFXCAPS_BLTSHRINKX   |
                                DDFXCAPS_BLTSHRINKYN  |
                                DDFXCAPS_BLTSHRINKXN;

    // ColorKey caps
    pHALInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT         |  
                                  DDCKEYCAPS_SRCBLTCLRSPACE |
                                  DDCKEYCAPS_DESTBLT        | 
                                  DDCKEYCAPS_DESTBLTCLRSPACE;

    pHALInfo->ddCaps.dwSVBCaps = DDCAPS_BLT;

    // We can do a texture from sysmem to video mem.
    pHALInfo->ddCaps.dwSVBCKeyCaps = DDCKEYCAPS_DESTBLT         | 
                                     DDCKEYCAPS_DESTBLTCLRSPACE;
    pHALInfo->ddCaps.dwSVBFXCaps = 0;

    // Fill in the sysmem->vidmem rops (only can copy);
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSVBRops[i] = rops[i];
    }

    pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTMIRRORUPDOWN  |
                                DDFXCAPS_BLTMIRRORLEFTRIGHT;

    pHALInfo->ddCaps.dwCKeyCaps |=  DDCKEYCAPS_SRCBLTCLRSPACEYUV;

    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

#if DX7_STEREO
    // Report the stereo capability back to runtime
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_STEREO;
    pHALInfo->ddCaps.dwSVCaps = DDSVCAPS_STEREOSEQUENTIAL;
#endif

    // Z Buffer is only 16 Bits
    pHALInfo->ddCaps.dwZBufferBitDepths = DDBD_16;
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

    if (pThisDisplay->bCanAGP && (pThisDisplay->dwDXVersion > DX5_RUNTIME))
    {
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM   | 
                                           DDSCAPS_NONLOCALVIDMEM;
            
        // We support the hybrid AGP model.  This means we have 
        // specific things we can do from AGP->Video  memory, but 
        // we can also texture directly from AGP memory
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEMCAPS;
    }
    else
    {
        DISPDBG((WRNLVL,"P3 Board is NOT AGP"));
    }
    
    // If we are a P3 we can do videoports 
    if (RENDERCHIP_PERMEDIAP3)
    {
#ifdef SUPPORT_VIDEOPORT
        // We support 1 video port.  Must set CurrVideoPorts to 0
        // We can't do interleaved bobbing yet - maybe in the future.
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_VIDEOPORT            | 
                                    DDCAPS2_CANBOBNONINTERLEAVED;

        pHALInfo->ddCaps.dwMaxVideoPorts = 1;
        pHALInfo->ddCaps.dwCurrVideoPorts = 0;

#if W95_DDRAW
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_VIDEOPORT;
#endif // W95_DDRAW

#endif // SUPPORT_VIDEOPORT


        if ( ( ( pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY ) != 0 ) &&
             ( ( pThisDisplay->pGLInfo->dwScreenWidth != 
                 pThisDisplay->pGLInfo->dwVideoWidth ) ||
               ( pThisDisplay->pGLInfo->dwScreenHeight != 
                 pThisDisplay->pGLInfo->dwVideoHeight ) ) )
        {
            // Display driver is using the overlay to show the 
            // picture - disable the overlay.
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 0;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;
        }
#if WNT_DDRAW
        else if (pThisDisplay->ppdev->flCaps & CAPS_DISABLE_OVERLAY)
#else
        else if (pThisDisplay->pGLInfo->dwFlags & GMVF_DISABLE_OVERLAY)
#endif
        {
            // Overlays not supported in hw
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 0;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;            
        }

        else        
        {
            // Overlay is free to use.
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 1;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;

            pHALInfo->ddCaps.dwCaps |=  DDCAPS_OVERLAY          |
                                        DDCAPS_OVERLAYFOURCC    |
                                        DDCAPS_OVERLAYSTRETCH   | 
                                        DDCAPS_COLORKEYHWASSIST |
                                        DDCAPS_OVERLAYCANTCLIP;

            pHALInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_SRCOVERLAY           |
                                           DDCKEYCAPS_SRCOVERLAYONEACTIVE  |
                                           DDCKEYCAPS_SRCOVERLAYYUV        |
                                           DDCKEYCAPS_DESTOVERLAY          |
                                           DDCKEYCAPS_DESTOVERLAYONEACTIVE |
                                           DDCKEYCAPS_DESTOVERLAYYUV;

            pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY;

            pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSHRINKX   |
                                         DDFXCAPS_OVERLAYSHRINKXN  |
                                         DDFXCAPS_OVERLAYSHRINKY   |
                                         DDFXCAPS_OVERLAYSHRINKYN  |
                                         DDFXCAPS_OVERLAYSTRETCHX  |
                                         DDFXCAPS_OVERLAYSTRETCHXN |
                                         DDFXCAPS_OVERLAYSTRETCHY  |
                                         DDFXCAPS_OVERLAYSTRETCHYN;

            // Indicates that Perm3 has no stretch ratio limitation
            pHALInfo->ddCaps.dwMinOverlayStretch = 1;
            pHALInfo->ddCaps.dwMaxOverlayStretch = 32000;
        }
    }

#ifdef W95_DDRAW
    // Enable colour control asc brightness, contrast, gamma.
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_COLORCONTROLPRIMARY;    
#endif    

    // Also permit surfaces wider than the display buffer.
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_WIDESURFACES;

    // Enable copy blts betweemn Four CC formats for DShow acceleration
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_COPYFOURCC;
    
    // Won't do Video-Sys mem Blits. 
    pHALInfo->ddCaps.dwVSBCaps = 0;
    pHALInfo->ddCaps.dwVSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwVSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwVSBRops[i] = 0;
    }

    // Won't do Sys-Sys mem Blits
    pHALInfo->ddCaps.dwSSBCaps = 0;
    pHALInfo->ddCaps.dwSSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSSBRops[i] = 0;
    }

    //
    // bit depths supported for alpha and Z
    //

    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 | 
                                                DDBD_4 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 | 
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 | 
                                                  DDBD_2 | 
                                                  DDBD_4 | 
                                                  DDBD_8;
                                                  
    // No alpha blending for overlays, so I'm not sure what these should be.
    // Because we support 32bpp overlays, it's just that you can't use the
    // alpha bits for blending. Pass.
    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 | 
                                                DDBD_4 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 | 
                                                  DDBD_2 | 
                                                  DDBD_4 | 
                                                  DDBD_8;

    //
    // ROPS supported
    //
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwRops[i] = rops[i];
    }

#if W95_DDRAW
    // Reset to NULL for debugging
    pThisDisplay->lpD3DGlobalDriverData = 0;
    ZeroMemory(&pThisDisplay->DDExeBufCallbacks, 
               sizeof(DDHAL_DDEXEBUFCALLBACKS));
    
    // Note that the NT code does this elsewhere
    _D3DHALCreateDriver(
            pThisDisplay);
            // (LPD3DHAL_GLOBALDRIVERDATA*)&pThisDisplay->lpD3DGlobalDriverData,
            // (LPD3DHAL_CALLBACKS*) &pThisDisplay->lpD3DHALCallbacks,
            // &pThisDisplay->DDExeBufCallbacks);

    // If we filled in the execute buffer callbacks, set the cap bit
    if (pThisDisplay->DDExeBufCallbacks.dwSize != 0)
    {
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
    }
#endif

    // For DX5 and beyond we support this new informational callback.
    pHALInfo->GetDriverInfo = DdGetDriverInfo;
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

#if DX8_DDI
    // Flag our support for a new class of GUIDs that may come through
    // GetDriverInfo for DX8 drivers. (This support will be compulsory)
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFO2;
#endif DX8_DDI    


} // __GetDDHALInfo

static HashTable* g_pDirectDrawLocalsHashTable = NULL; // azn

//-----------------------------------------------------------------------------
//
// _DD_InitDDHAL32Bit
//
// CALLED ONCE AT START OF DAY
// No Chip register setup is done here - it is all handled in the mode
// change code.  DO NOT DO IT HERE - THERE IS NO WIN16LOCK AT THIS TIME!!!
//
//-----------------------------------------------------------------------------
BOOL 
_DD_InitDDHAL32Bit(
    P3_THUNKEDDATA* pThisDisplay)
{
    BOOL bRet;
    DWORD Result;
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD(pGLInfo != NULL, "ERROR: pGLInfo not valid!");

    // Note: Can't use P3_DMA_DEFS macro here, as pGlint isn't initialised yet.

    DISPDBG((DBGLVL, "** In _DD_InitDDHAL32Bit, pGlint 0x%x", 
                     pThisDisplay->control));
    DISPDBG((DBGLVL, "Sizeof DDHALINFO: %d", (int) sizeof(DDHALINFO)));

    // Force D3D to setup surface offsets as if a flip had happened 
    pThisDisplay->bFlippedSurface = TRUE;
   
    // A flag to say that the driver is essentially at the start of day. This 
    // is set to let later calls in the driver know that they have work to do.
    pThisDisplay->bStartOfDay = TRUE;
    
#if W95_DDRAW
    // At start of day the videoport is dead to the world
    pThisDisplay->VidPort.bActive = FALSE;
#endif  //      W95_DDRAW

    // Reset the GART copies.
    pThisDisplay->dwGARTLin = 0;
    pThisDisplay->dwGARTDev = 0;
    pThisDisplay->dwGARTLinBase = 0;
    pThisDisplay->dwGARTDevBase = 0;

    pThisDisplay->pGlint = (FPGLREG)pThisDisplay->control;

    // Set up the global overlay data
    pThisDisplay->bOverlayVisible                   = (DWORD)FALSE;
    pThisDisplay->OverlayDstRectL                   = 0;
    pThisDisplay->OverlayDstRectR                   = 0;
    pThisDisplay->OverlayDstRectT                   = 0;
    pThisDisplay->OverlayDstRectB                   = 0;
    pThisDisplay->OverlaySrcRectL                   = 0;
    pThisDisplay->OverlaySrcRectR                   = 0;
    pThisDisplay->OverlaySrcRectT                   = 0;
    pThisDisplay->OverlaySrcRectB                   = 0;
    pThisDisplay->OverlayDstSurfLcl                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlaySrcSurfLcl                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlayDstColourKey               = CLR_INVALID;
    pThisDisplay->OverlaySrcColourKey               = CLR_INVALID;
    pThisDisplay->OverlayClipRgnMem                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlayClipRgnMemSize             = 0;
    pThisDisplay->OverlayUpdateCountdown    = 0;
    pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;
    pThisDisplay->OverlayTempSurf.VidMem    = (ULONG_PTR)NULL;
    pThisDisplay->OverlayTempSurf.Pitch             = (DWORD)0;

#if W95_DDRAW
    // Set up colour control data.
    pThisDisplay->ColConBrightness = 0;
    pThisDisplay->ColConContrast = 10000;
    pThisDisplay->ColConGamma = 100;
#endif // W95_DDRAW

#if DX7_VIDMEM_VB
    // Set up DrawPrim temporary index buffer.
    pThisDisplay->DrawPrimIndexBufferMem            = (ULONG_PTR)NULL;
    pThisDisplay->DrawPrimIndexBufferMemSize        = 0;
    pThisDisplay->DrawPrimVertexBufferMem           = (ULONG_PTR)NULL;
    pThisDisplay->DrawPrimVertexBufferMemSize       = 0;
#endif // DX7_VIDMEM_VB

    // Set up current RenderID to be as far away from a "sensible"
    // value as possible. Hopefully, if the context switch fails and
    // someone starts using it for something else, these values and 
    // the ones they use will be very different, and various asserts 
    // will scream immediately.
    
    // Also, say that the RenderID is invalid, because we have not actually
    // set up the chip. The context switch should set up & flush the
    // chip, and then it will set bRenderIDValid to TRUE.
    // Loads of asserts throughout the code will scream if something
    // doesn't do the setup & flush for some reason.
    pThisDisplay->dwRenderID            = 0x8eaddead | RENDER_ID_KNACKERED_BITS;
    pThisDisplay->dwLastFlipRenderID    = 0x8eaddead | RENDER_ID_KNACKERED_BITS;
    pThisDisplay->bRenderIDValid = (DWORD)FALSE;

#if W95_DDRAW

    // Create a shared heap
    if (g_DXGlobals.hHeap32 == 0)
        g_DXGlobals.hHeap32 = (DWORD)HeapCreate( HEAP_SHARED, 2500, 0);

#endif // W95_DDRAW
    
    // Make sure we're running the right chip. If not, STOP.
    ASSERTDD((RENDERCHIP_P3RXFAMILY),"ERROR: Invalid RENDERFAMILY!!");

    // Dump some debugging information 
    DISPDBG((DBGLVL, "************* _DD_InitDDHAL32Bit *************************************" ));
    DISPDBG((DBGLVL, "    dwScreenFlatAddr=%08lx", pThisDisplay->dwScreenFlatAddr ));
    DISPDBG((DBGLVL, "    dwScreenStart =%08lx", pThisDisplay->dwScreenStart));
    DISPDBG((DBGLVL, "    dwLocalBuffer=%08lx", pThisDisplay->dwLocalBuffer ));
    DISPDBG((DBGLVL, "    dwScreenWidth=%08lx", pThisDisplay->dwScreenWidth ));
    DISPDBG((DBGLVL, "    dwScreenHeight=%08lx", pThisDisplay->dwScreenHeight ));
    DISPDBG((DBGLVL, "    bReset=%08lx", pThisDisplay->bResetMode ));
    DISPDBG((DBGLVL, "    dwRGBBitCount=%ld", pThisDisplay->ddpfDisplay.dwRGBBitCount ));
    DISPDBG((DBGLVL, "    pGLInfo=%08lp", pGLInfo ));
    DISPDBG((DBGLVL, "    Render:  0x%x, Rev:0x%x", pGLInfo->dwRenderChipID,  pGLInfo->dwRenderChipRev));
#if W95_DDRAW
    DISPDBG((DBGLVL, "    Support: 0x%x, Rev:0x%x", pGLInfo->dwSupportChipID, pGLInfo->dwSupportChipRev));
    DISPDBG((DBGLVL, "    Board:   0x%x, Rev:0x%x", pGLInfo->dwBoardID, pGLInfo->dwBoardRev));
    // DISPDBG((DBGLVL, "    BF Size: 0x%x, LB Depth:0x%x", pGLInfo->cBlockFillSize, pGLInfo->cLBDepth));
#endif  //      W95_DDRAW
    DISPDBG((DBGLVL, "    FB Size: 0x%x", pGLInfo->ddFBSize));
    DISPDBG((DBGLVL, "    RMask:   0x%x", pThisDisplay->ddpfDisplay.dwRBitMask ));
    DISPDBG((DBGLVL, "    GMask:   0x%x", pThisDisplay->ddpfDisplay.dwGBitMask ));
    DISPDBG((DBGLVL, "    BMask:   0x%x", pThisDisplay->ddpfDisplay.dwBBitMask ));
    DISPDBG((DBGLVL, "******************************************************************" ));

    // Allocate a DMA buffer for the DX driver
    HWC_AllocDMABuffer(pThisDisplay);

#define SURFCB pThisDisplay->DDSurfCallbacks
#define HALCB pThisDisplay->DDHALCallbacks

    // Fill in the HAL Callback pointers    
    memset(&HALCB, 0, sizeof(DDHAL_DDCALLBACKS));
    HALCB.dwSize = sizeof(DDHAL_DDCALLBACKS);

    // Field the HAL DDraw callbacks we support
    HALCB.CanCreateSurface = DdCanCreateSurface;
    HALCB.CreateSurface = DdCreateSurface;
    HALCB.WaitForVerticalBlank = DdWaitForVerticalBlank;
    HALCB.GetScanLine = DdGetScanLine;
    
#if WNT_DDRAW
    HALCB.MapMemory = DdMapMemory;
#else    
    HALCB.DestroyDriver = DdDestroyDriver;   // Only on Win95.
#endif // WNT_DDRAW
    
    HALCB.dwFlags = DDHAL_CB32_WAITFORVERTICALBLANK |
#if WNT_DDRAW
                    DDHAL_CB32_MAPMEMORY            |
#else  // WNT_DDRAW
                    DDHAL_CB32_DESTROYDRIVER        |
#endif
                    DDHAL_CB32_GETSCANLINE          | 
                    DDHAL_CB32_CANCREATESURFACE     |
                    DDHAL_CB32_CREATESURFACE;

    // Fill in the Surface Callback pointers
    memset(&SURFCB, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    SURFCB.dwSize = sizeof(DDHAL_DDSURFACECALLBACKS);

    // Field the Ddraw Surface callbacks we support    
    SURFCB.DestroySurface = DdDestroySurface;
    SURFCB.Lock = DdLock;
    SURFCB.Unlock = DdUnlock;
    SURFCB.GetBltStatus = DdGetBltStatus;
    SURFCB.GetFlipStatus = DdGetFlipStatus;
    SURFCB.SetColorKey = DdSetColorKey;
    SURFCB.Flip = DdFlip;
    SURFCB.Blt = DdBlt;

    SURFCB.dwFlags = DDHAL_SURFCB32_DESTROYSURFACE     |
                     DDHAL_SURFCB32_FLIP               |
                     DDHAL_SURFCB32_LOCK               |
                     DDHAL_SURFCB32_BLT                |
                     DDHAL_SURFCB32_GETBLTSTATUS       |
                     DDHAL_SURFCB32_GETFLIPSTATUS      |
                     DDHAL_SURFCB32_SETCOLORKEY        |
                     DDHAL_SURFCB32_UNLOCK;            

    pThisDisplay->hInstance = g_DXGlobals.hInstance;

#if WNT_DDRAW
    if (0 == (pThisDisplay->ppdev->flCaps & CAPS_DISABLE_OVERLAY))
#else
    if (0 == (pThisDisplay->pGLInfo->dwFlags & GMVF_DISABLE_OVERLAY))
#endif
    {
        SURFCB.UpdateOverlay = DdUpdateOverlay;   // Now supporting overlays.
        SURFCB.SetOverlayPosition = DdSetOverlayPosition;
        SURFCB.dwFlags |=
                         DDHAL_SURFCB32_UPDATEOVERLAY      | // Now supporting 
                         DDHAL_SURFCB32_SETOVERLAYPOSITION ; // overlays. 
    }
    
    

    // Fill in the DDHAL Informational caps
    __GetDDHALInfo(pThisDisplay, &pThisDisplay->ddhi32);

    // Create/get DD locals hash table to store our DX surface handles
//@@BEGIN_DDKSPLIT
    // azn
    // We need to move this creation/destruction of g_pDirectDrawLocalsHashTable
    // into DrvEnableDriver and DrvDisableDriver and maybe maintain a Ref count
    // as we might be running on a multi-Perm3 machine.
//@@END_DDKSPLIT
    if (g_pDirectDrawLocalsHashTable == NULL) 
    {
        DISPDBG((DBGLVL,"pDirectDrawLocalsHashTable CREATED"));    
        g_pDirectDrawLocalsHashTable = 
        pThisDisplay->pDirectDrawLocalsHashTable = HT_CreateHashTable();    
    }
    else
    {
        DISPDBG((DBGLVL,"Hash table for DirectDraw locals already exists"));
        pThisDisplay->pDirectDrawLocalsHashTable = 
                                                g_pDirectDrawLocalsHashTable;
    }       

    if (pThisDisplay->pDirectDrawLocalsHashTable == NULL)
    {
        return (FALSE);
    }

    HT_SetDataDestroyCallback(pThisDisplay->pDirectDrawLocalsHashTable, 
                              _D3D_SU_DirectDrawLocalDestroyCallback);

#if W95_DDRAW
    if ( g_DXGlobals.hHeap32 == 0 )
    {
        return ( FALSE );
    }
    else
    {
        return ( TRUE );
    }
#endif

    return (TRUE);
    
} // _DD_InitDDHAL32Bit 


#if DX7_STEREO
//-----------------------------------------------------------------------------
//
//  _DD_bIsStereoMode
//
//  Decide if mode can be displayed as stereo mode. Here we limit stereo
//  modes so that two front and two backbuffers can be created for rendering.
//
//-----------------------------------------------------------------------------

BOOL 
_DD_bIsStereoMode(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBpp)
{
    DWORD dwLines;

    // we need to check dwBpp for a valid value as PDD_STEREOMODE.dwBpp is a
    // parameter passed on from the user mode API call and which is expected
    // to have the values 8,16,24,32 (though we don't really support 24bpp)
    if ((dwWidth >= 320) && (dwHeight >= 240) &&
        ((dwBpp == 8) || (dwBpp == 16) || (dwBpp == 24) || (dwBpp ==32) ) )
    {
        // This the total number of "lines" that fit in our available vidmem
        // at the given width and pixel format
        dwLines = pThisDisplay->pGLInfo->ddFBSize / (dwWidth*dwBpp/8);

        // Here we limit stereo modes so that two front and two backbuffers 
        // can be created for rendering.
        if (dwLines > (dwHeight*4))
        {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // DX7_STEREO


#ifdef WNT_DDRAW
typedef DD_NONLOCALVIDMEMCAPS DDNONLOCALVIDMEMCAPS;
#else
#define DD_MISCELLANEOUSCALLBACKS DDHAL_DDMISCELLANEOUSCALLBACKS
#endif

//-----------------------------Public Routine----------------------------------
//
// DdGetDriverInfo
//
// Queries the driver for additional information about itself.
//
// Parameters
//      lpGetDriverInfo 
//              Points to a DD_GETDRIVERINFODATA structure that contains the
//              information required to perform the query. 
//
//      Members
//
//          VOID *
//          dphdev 
//                      Is a handle to the driver's PDEV. 
//          DWORD
//          dwSize 
//                      Specifies the size in bytes of this
//                      DD_GETDRIVERINFODATA structure.
//          DWORD
//          dwFlags 
//                      Is currently unused and is set to zero. 
//          GUID
//          guidInfo 
//                      Specifies the GUID of the DirectX support for which the
//                      driver is being queried. In a Windows 2000 DirectDraw
//                      driver, this member can be one of the following values
//                      (in alphabetic order):
//
//              GUID_ColorControlCallbacks  Queries whether the driver supports
//                                          DdControlColor. If the driver does
//                                          support it, the driver should
//                                          initialize and return a
//                                          DD_COLORCONTROLCALLBACKS structure
//                                          in the buffer to which lpvData
//                                          points.
//              GUID_D3DCallbacks           Queries whether the driver supports
//                                          any of the functionality specified
//                                          through the D3DNTHAL_CALLBACKS
//                                          structure. If the driver does not
//                                          provide any of this support, it
//                                          should initialize and return a
//                                          D3DNTHAL_CALLBACKS structure in
//                                          the buffer to which lpvData points 
//              GUID_D3DCallbacks2          Obsolete. 
//              GUID_D3DCallbacks3          Queries whether the driver supports
//                                          any of the functionality specified
//                                          through the D3DNTHAL_CALLBACKS3
//                                          structure. If the driver does provide
//                                          any of this support, it should
//                                          initialize and return a
//                                          D3DNTHAL_CALLBACKS3 structure in
//                                          the buffer to which lpvData points.
//              GUID_D3DCaps                Obsolete.
//              GUID_D3DExtendedCaps        Queries whether the driver supports
//                                          any of the Direct3D functionality
//                                          specified through the
//                                          D3DNTHAL_D3DEXTENDEDCAPS structure.
//                                          If the driver does provide any of
//                                          this support, it should initialize
//                                          and return a
//                                          D3DNTHAL_D3DEXTENDEDCAPS structure
//                                          in the buffer to which lpvData
//                                          points. 
//              GUID_D3DParseUnknownCommandCallback     Provides the Direct3D
//                                          portion of the driver with the
//                                          Direct3D runtime's
//                                          D3dParseUnknownCommandCallback.
//                                          The driver's D3dDrawPrimitives2
//                                          callback calls
//                                          D3dParseUnknownCommandCallback
//                                          to parse commands from the
//                                          command buffer that the driver
//                                          doesn't understand. 
//                                          DirectDraw passes a pointer to this 
//                                          function in the buffer to which 
//                                          lpvData points. If the driver 
//                                          supports this aspect of Direct3D, 
//                                          it should store the pointer. 
//              GUID_GetHeapAlignment       Queries whether the driver supports 
//                                          surface alignment requirements on a 
//                                          per-heap basis. If the driver does 
//                                          provide this support, it should 
//                                          initialize and return a 
//                                          DD_GETHEAPALIGNMENTDATA structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_KernelCallbacks        Queries whether the driver supports 
//                                          any of the functionality specified 
//                                          through the DD_KERNELCALLBACKS 
//                                          structure. If the driver does 
//                                          provide any of this support, it 
//                                          should initialize and return a 
//                                          DD_KERNELCALLBACKS structure in the 
//                                          buffer to which lpvData points. 
//              GUID_KernelCaps             Queries whether the driver supports 
//                                          any of the kernel-mode capabilities 
//                                          specified through the DDKERNELCAPS 
//                                          structure. If the driver does 
//                                          provide any of this support, it 
//                                          should initialize and return a 
//                                          DDKERNELCAPS structure in the buffer 
//                                          to which lpvData points. 
//              GUID_MiscellaneousCallbacks Queries whether the driver supports 
//                                          DdGetAvailDriverMemory. If the 
//                                          driver does support it, the driver 
//                                          should initialize and return a 
//                                          DD_MISCELLANEOUSCALLBACKS structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_Miscellaneous2Callbacks   Queries whether the driver 
//                                          supports the additional miscellaneous 
//                                          functionality specified in the 
//                                          DD_MISCELLANEOUS2CALLBACKS structure. 
//                                          If the driver does support any of 
//                                          this support, the driver should 
//                                          initialize and return a 
//                                          DD_MISCELLANEOUS2CALLBACKS structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_MotionCompCallbacks    Queries whether the driver supports 
//                                          the motion compensation 
//                                          functionality specified through the 
//                                          DD_MOTIONCOMPCALLBACKS structure. 
//                                          If the driver does provide any of 
//                                          this support, is should initialize 
//                                          and return a DD_MOTIONCOMPCALLBACKS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NonLocalVidMemCaps     Queries whether the driver supports 
//                                          any of the nonlocal display memory 
//                                          capabilities specified through the 
//                                          DD_NONLOCALVIDMEMCAPS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NONLOCALVIDMEMCAPS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NTCallbacks            Queries whether the driver supports 
//                                          any of the functionality specified 
//                                          through the DD_NTCALLBACKS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NTCALLBACKS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NTPrivateDriverCaps    Queries whether the driver supports 
//                                          the Windows 95/ Windows 98-style 
//                                          surface creation techniques 
//                                          specified through the 
//                                          DD_NTPRIVATEDRIVERCAPS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NTPRIVATEDRIVERCAPS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_UpdateNonLocalHeap     Queries whether the driver supports 
//                                          retrieval of the base addresses of 
//                                          each nonlocal heap in turn. If the 
//                                          driver does provide this support, 
//                                          it should initialize and return a 
//                                          DD_UPDATENONLOCALHEAPDATA structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_VideoPortCallbacks     Queries whether the driver supports 
//                                          the video port extensions (VPE). If 
//                                          the driver does support VPE, it 
//                                          should initialize and return a 
//                                          DD_VIDEOPORTCALLBACKS structure in 
//                                          the buffer to which lpvData points. 
//              GUID_VideoPortCaps          Queries whether the driver supports 
//                                          any of the VPE object capabilities 
//                                          specified through the DDVIDEOPORTCAPS 
//                                          structure. If the driver does provide 
//                                          any of this support, it should 
//                                          initialize and return a 
//                                          DDVIDEOPORTCAPS structure in the 
//                                          buffer to which lpvData points. 
//              GUID_ZPixelFormats          Queries the pixel formats supported 
//                                          by the depth buffer. If the driver 
//                                          supports Direct3D, it should allocate 
//                                          and initialize the appropriate 
//                                          members of a DDPIXELFORMAT structure 
//                                          for every z-buffer format that it 
//                                          supports and return these in the 
//                                          buffer to which lpvData points. 
//
//      DWORD
//      dwExpectedSize 
//                  Specifies the number of bytes of data that DirectDraw
//                  expects the driver to pass back in the buffer to which
//                  lpvData points. 
//      PVOID
//      lpvData 
//                  Points to a DirectDraw-allocated buffer into which the
//                  driver copies the requested data. This buffer is
//                  typically dwExpectedSize bytes in size. The driver must
//                  not write more than dwExpectedSize bytes of data in it. 
//      DWORD
//      dwActualSize 
//                  Is the location in which the driver returns the number
//                  of bytes of data it writes in lpvData. 
//      HRESULT
//      ddRVal 
//                  Specifies the driver's return value. 
//
// Return Value
//      DdGetDriverInfo must return DDHAL_DRIVER_HANDLED.
//
// Comments
//
//      Drivers must implement DdGetDriverInfo to expose driver-supported
//      DirectDraw functionality that is not returnable through
//      DrvEnableDirectDraw.
//
//      The driver's DrvGetDirectDrawInfo function returns a pointer to
//      DdGetDriverInfo in the GetDriverInfo member of the DD_HALINFO structure.
//
//      To inform DirectDraw that the DdGetDriverInfo member has been set
//      correctly, the driver must also set the DDHALINFO_GETDRIVERINFOSET bit
//      of dwFlags in the DD_HALINFO structure. 
//
//      DdGetDriverInfo should determine whether the driver and its hardware
//      support the callbacks or capabilities requested by the specified GUID.
//      For all GUIDs except GUID_D3DParseUnknownCommandCallback, if the driver
//      does provide the requested support, it should set the following members
//      of the DD_GETDRIVERINFODATA structure: 
//
//      Set dwActualSize to be the size in bytes of the callback or capability
//      structure being returned by the driver.
//
//      In the memory that lpvData points to, initialize the members of the
//      callback or capability structure that corresponds with the requested
//      feature as follows: 
//
//      Set the dwSize member to be the size in bytes of the structure. 
//
//      For callbacks, set the function pointers to point to those callbacks
//      implemented by the driver, and set the bits in the dwFlags member to
//      indicate which functions the driver supports. 
//
//      For capabilities, set the appropriate members of the capability
//      structure with values supported by the driver/device. 
//
//  Return DD_OK in ddRVal. 
//      If the driver does not support the feature, it should set ddRVal
//      to DDERR_CURRENTLYNOTAVAIL and return.
//
//      DirectDraw informs the driver of the expected amount of data in the
//      dwExpectedSize member of the DD_GETDRIVERINFODATA structure. The
//      driver must not fill in more data than dwExpectedSize bytes.
//
//  To avoid problems using DdGetDriverInfo: 
//
//  Do not implement dependencies based on the order in which DdGetDriverInfo 
//  is called. For example, avoid hooking driver initialization steps into 
//  DdGetDriverInfo. 
//
//  Do not try to ascertain the DirectDraw version based on the calls to 
//  DdGetDriverInfo. 
//
//  Do not assume anything about the number of times DirectDraw will call the 
//  driver, or the number of times DirectDraw will query a given GUID. It is 
//  possible that DirectDraw will probe the driver repeatedly with the same 
//  GUID. Implementing assumptions about this in the driver hampers its 
//  compatibility with future runtimes. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;
    P3_THUNKEDDATA* pThisDisplay;

#if WNT_DDRAW
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV)(lpData->dhpdev))->thunkData);
#else    
    pThisDisplay = (P3_THUNKEDDATA*)lpData->dwContext;
    if (! pThisDisplay) 
    {
        pThisDisplay = g_pDriverData;
    }
#endif
    
    DBG_CB_ENTRY(DdGetDriverInfo);

    // Default to 'not supported'
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    //------------------------------------
    // Process any D3D related GUIDs here
    //------------------------------------
    _D3DGetDriverInfo(lpData);


    //------------------------------------
    // any other GUIDS are handled here
    //------------------------------------
    if (MATCH_GUID((lpData->guidInfo), GUID_MiscellaneousCallbacks) )
    {        
        DD_MISCELLANEOUSCALLBACKS MISC_CB;
        
        DISPDBG((DBGLVL,"  GUID_MiscellaneousCallbacks"));

        memset(&MISC_CB, 0, sizeof(DD_MISCELLANEOUSCALLBACKS));
        MISC_CB.dwSize = sizeof(DD_MISCELLANEOUSCALLBACKS);

#if W95_DDRAW
        MISC_CB.GetHeapAlignment = DdGetHeapAlignment;
        MISC_CB.dwFlags = DDHAL_MISCCB32_GETHEAPALIGNMENT;

        // Setup the AGP callback if running on an AGP board.
        if ((pThisDisplay->dwDXVersion > DX5_RUNTIME) && 
             pThisDisplay->bCanAGP)
        {
            MISC_CB.dwFlags |= DDHAL_MISCCB32_UPDATENONLOCALHEAP;
            MISC_CB.UpdateNonLocalHeap = DdUpdateNonLocalHeap;
        }
#endif // W95_DDRAW
        
        MISC_CB.dwFlags |= DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
        MISC_CB.GetAvailDriverMemory = DdGetAvailDriverMemory;
    
        // Copy the filled in structure into the  passed data area
        dwSize = min(lpData->dwExpectedSize , sizeof(MISC_CB));
        lpData->dwActualSize = sizeof(MISC_CB);
        memcpy(lpData->lpvData, &MISC_CB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#if WNT_DDRAW
    if (MATCH_GUID((lpData->guidInfo), GUID_UpdateNonLocalHeap))
    {
        // On NT kernels the AGP heap details are passed into the driver 
        // here, rather than through a seperate callback.
        if (pThisDisplay->bCanAGP)
        {
            DDHAL_UPDATENONLOCALHEAPDATA* plhd;
        
            DISPDBG((DBGLVL, "  GUID_UpdateNonLocalHeap"));

            plhd = (DDHAL_UPDATENONLOCALHEAPDATA*)lpData->lpvData;

            // Fill in the base pointers
            pThisDisplay->dwGARTDevBase = (DWORD)plhd->fpGARTDev;
            pThisDisplay->dwGARTLinBase = (DWORD)plhd->fpGARTLin;
        
            // Fill in the changeable base pointers.
            pThisDisplay->dwGARTDev = pThisDisplay->dwGARTDevBase;
            pThisDisplay->dwGARTLin = pThisDisplay->dwGARTLinBase;

            lpData->ddRVal = DD_OK;
        }
    }
#endif // WNT_DDRAW

    if (MATCH_GUID((lpData->guidInfo), GUID_NonLocalVidMemCaps) &&
        (pThisDisplay->bCanAGP))
    {
        int i;

        DDNONLOCALVIDMEMCAPS NLVCAPS;

        DISPDBG((DBGLVL,"  GUID_NonLocalVidMemCaps"));

        if (lpData->dwExpectedSize != sizeof(DDNONLOCALVIDMEMCAPS) ) 
        {
            DISPDBG((ERRLVL,"ERROR: NON-Local vidmem caps size incorrect!"));
            DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );            
            return DDHAL_DRIVER_HANDLED;
        }

        // The flag D3DDEVCAPS_TEXTURENONLOCALVIDMEM in the D3D caps 
        // indicates that although we are exposing DMA-Model AGP, we
        // can still texture directly from AGP memory.
        memset(&NLVCAPS, 0, sizeof(DDNONLOCALVIDMEMCAPS));
        NLVCAPS.dwSize = sizeof(DDNONLOCALVIDMEMCAPS);
        
        NLVCAPS.dwNLVBCaps = DDCAPS_BLT        | 
                             DDCAPS_ALPHA      |
                             DDCAPS_BLTSTRETCH |
                             DDCAPS_BLTQUEUE   |
                             DDCAPS_BLTFOURCC  |
                             DDCAPS_COLORKEY   |
                             DDCAPS_CANBLTSYSMEM;
                             
        NLVCAPS.dwNLVBCaps2 = DDCAPS2_WIDESURFACES;
        
        NLVCAPS.dwNLVBCKeyCaps = DDCKEYCAPS_SRCBLT         | 
                                 DDCKEYCAPS_SRCBLTCLRSPACE |
                                 DDCKEYCAPS_DESTBLT        | 
                                 DDCKEYCAPS_DESTBLTCLRSPACE;
                                 
        NLVCAPS.dwNLVBFXCaps = DDFXCAPS_BLTSTRETCHY  |
                               DDFXCAPS_BLTSTRETCHX  |
                               DDFXCAPS_BLTSTRETCHYN |
                               DDFXCAPS_BLTSTRETCHXN |
                               DDFXCAPS_BLTSHRINKY   |
                               DDFXCAPS_BLTSHRINKX   |
                               DDFXCAPS_BLTSHRINKYN  |
                               DDFXCAPS_BLTSHRINKXN;

        for( i=0;i<DD_ROP_SPACE;i++ )
        {
            NLVCAPS.dwNLVBRops[i] = ropsAGP[i];
        }

        // Copy the filled in structure into the passed data area
        dwSize = min( lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpData->dwActualSize = sizeof(DDNONLOCALVIDMEMCAPS);       
        memcpy(lpData->lpvData, &NLVCAPS, dwSize );        
        lpData->ddRVal = DD_OK;
    }

//@@BEGIN_DDKSPLIT
#ifdef SUPPORT_VIDEOPORT
#if W95_DDRAW
    // Fill in the VideoPort callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_VideoPortCallbacks) )
    {
        DDHAL_DDVIDEOPORTCALLBACKS VIDCB;

        DISPDBG((DBGLVL,"  GUID_VideoPortCallbacks"));

        memset(&VIDCB, 0, sizeof(DDHAL_DDVIDEOPORTCALLBACKS));
        VIDCB.dwSize = sizeof(DDHAL_DDVIDEOPORTCALLBACKS);
        VIDCB.CanCreateVideoPort = DdCanCreateVideoPort;
        VIDCB.CreateVideoPort = DdCreateVideoPort;
        VIDCB.FlipVideoPort = DdFlipVideoPort;
        VIDCB.GetVideoPortBandwidth = DdGetVideoPortBandwidth;
        VIDCB.GetVideoPortInputFormats = DdGetVideoPortInputFormats;
        VIDCB.GetVideoPortOutputFormats = DdGetVideoPortOutputFormats;
        VIDCB.GetVideoPortField = DdGetVideoPortField;
        VIDCB.GetVideoPortLine = DdGetVideoPortLine;
        VIDCB.GetVideoPortConnectInfo = DDGetVideoPortConnectInfo;
        VIDCB.DestroyVideoPort = DdDestroyVideoPort;
        VIDCB.GetVideoPortFlipStatus = DdGetVideoPortFlipStatus;
        VIDCB.UpdateVideoPort = DdUpdateVideoPort;
        VIDCB.WaitForVideoPortSync = DdWaitForVideoPortSync;
        VIDCB.GetVideoSignalStatus = DdGetVideoSignalStatus;

        VIDCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                        DDHAL_VPORT32_CREATEVIDEOPORT    |
                        DDHAL_VPORT32_DESTROY            |
                        DDHAL_VPORT32_FLIP               |
                        DDHAL_VPORT32_GETBANDWIDTH       |
                        DDHAL_VPORT32_GETINPUTFORMATS    |
                        DDHAL_VPORT32_GETOUTPUTFORMATS   | 
                        DDHAL_VPORT32_GETFIELD           |
                        DDHAL_VPORT32_GETLINE            |
                        DDHAL_VPORT32_GETFLIPSTATUS      |
                        DDHAL_VPORT32_UPDATE             |
                        DDHAL_VPORT32_WAITFORSYNC        |
                        DDHAL_VPORT32_GETCONNECT         |
                        DDHAL_VPORT32_GETSIGNALSTATUS;
        
        // Copy the filled in structure into the 
        // passed data area
        dwSize = lpData->dwExpectedSize;
        if ( sizeof(VIDCB) < dwSize )
        {
            dwSize = sizeof(VIDCB);
        }
        lpData->dwActualSize = sizeof(VIDCB);
        memcpy(lpData->lpvData, &VIDCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the VideoPortCaps
    if (MATCH_GUID((lpData->guidInfo), GUID_VideoPortCaps) )
    {
        DDVIDEOPORTCAPS VIDCAPS;

        DISPDBG((DBGLVL,"  GUID_VideoPortCaps"));

        if (lpData->dwExpectedSize != sizeof(VIDCAPS) )
        {
            DISPDBG((ERRLVL,"ERROR: VIDCAPS size incorrect"));
            DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );              
            return DDHAL_DRIVER_HANDLED;
        }

        // Now fill in the videoport description (it's easier if it's on
        // the 32 bit side..)
        VIDCAPS.dwSize = sizeof(DDVIDEOPORTCAPS);
        VIDCAPS.dwFlags = DDVPD_ALIGN    | 
                          DDVPD_AUTOFLIP | 
                          DDVPD_WIDTH    |  
                          DDVPD_HEIGHT   | 
                          DDVPD_FX       | 
                          DDVPD_CAPS;
        VIDCAPS.dwMaxWidth = 2048;
        VIDCAPS.dwMaxVBIWidth = 2048;
        VIDCAPS.dwMaxHeight = 2048;
        VIDCAPS.dwVideoPortID = 0;

        VIDCAPS.dwCaps = DDVPCAPS_AUTOFLIP       | 
                         DDVPCAPS_NONINTERLACED  | 
                         DDVPCAPS_INTERLACED     | 
                         DDVPCAPS_READBACKFIELD  |
                         DDVPCAPS_READBACKLINE   | 
                         DDVPCAPS_SKIPEVENFIELDS | 
                         DDVPCAPS_SKIPODDFIELDS  | 
                         DDVPCAPS_VBISURFACE     | 
                         DDVPCAPS_OVERSAMPLEDVBI; 
        
        VIDCAPS.dwFX = DDVPFX_CROPX           |   
                       DDVPFX_CROPY           | 
                       DDVPFX_INTERLEAVE      | 
                       DDVPFX_MIRRORLEFTRIGHT |
                       DDVPFX_MIRRORUPDOWN    | 
                       DDVPFX_PRESHRINKXB     | 
                       DDVPFX_VBICONVERT      | 
                       DDVPFX_VBINOSCALE      | 
                       DDVPFX_PRESHRINKYB     | 
                       DDVPFX_IGNOREVBIXCROP;
        
        VIDCAPS.dwNumAutoFlipSurfaces = 2;
        VIDCAPS.dwAlignVideoPortBoundary = 4;
        VIDCAPS.dwAlignVideoPortPrescaleWidth = 4;
        VIDCAPS.dwAlignVideoPortCropBoundary = 4;
        VIDCAPS.dwAlignVideoPortCropWidth = 4;
        VIDCAPS.dwPreshrinkXStep = 1;
        VIDCAPS.dwPreshrinkYStep = 1;

        lpData->dwActualSize = sizeof(VIDCAPS);
        memcpy(lpData->lpvData, &VIDCAPS, sizeof(VIDCAPS) );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the kernel Callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_KernelCallbacks) )
    {
        DDHAL_DDKERNELCALLBACKS KERNCB;

        DISPDBG((DBGLVL,"  GUID_KernelCallbacks"));

        memset(&KERNCB, 0, sizeof(DDHAL_DDKERNELCALLBACKS));

        KERNCB.dwSize = sizeof(KERNCB);
        KERNCB.SyncSurfaceData = DdSyncSurfaceData;
        KERNCB.SyncVideoPortData = DdSyncVideoPortData;
        
        KERNCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA |
                         DDHAL_KERNEL_SYNCVIDEOPORTDATA;

        dwSize = lpData->dwExpectedSize;
        if ( sizeof(KERNCB) < dwSize )
        {
            dwSize = sizeof(KERNCB);
        }
        lpData->dwActualSize = sizeof(KERNCB);
        memcpy(lpData->lpvData, &KERNCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the kernel caps
    if (MATCH_GUID((lpData->guidInfo), GUID_KernelCaps) )
    {
        DDKERNELCAPS KERNCAPS;

        DISPDBG((DBGLVL,"  GUID_KernelCaps"));

        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS) ) 
        {
            DISPDBG((ERRLVL,"ERROR: Kernel caps structure invalid size!"));
            return DDHAL_DRIVER_HANDLED;
        }

        ZeroMemory(&KERNCAPS, sizeof(KERNCAPS));
        KERNCAPS.dwSize = sizeof(KERNCAPS);
        KERNCAPS.dwCaps = DDKERNELCAPS_LOCK        | 
                          DDKERNELCAPS_FLIPOVERLAY | 
                          DDKERNELCAPS_SETSTATE;
    
        if (!(pThisDisplay->pGLInfo->dwFlags & GMVF_NOIRQ))
        {
            KERNCAPS.dwCaps |= DDKERNELCAPS_CAPTURE_SYSMEM | 
                               DDKERNELCAPS_FIELDPOLARITY  | 
                               DDKERNELCAPS_SKIPFIELDS     | 
                               DDKERNELCAPS_FLIPVIDEOPORT  | 
                               DDKERNELCAPS_AUTOFLIP;

            KERNCAPS.dwIRQCaps = DDIRQ_VPORT0_VSYNC  | 
                                 DDIRQ_DISPLAY_VSYNC | 
                                 DDIRQ_BUSMASTER;
        }
                            
        lpData->dwActualSize = sizeof(DDKERNELCAPS);
        memcpy(lpData->lpvData, &KERNCAPS, sizeof(DDKERNELCAPS) );
        lpData->ddRVal = DD_OK;
    }

#endif // W95_DDRAW
#endif // SUPPORT_VIDEOPORT
//@@END_DDKSPLIT

#ifdef W95_DDRAW
#ifdef USE_DD_CONTROL_COLOR
    // Fill in the colour control callbacks.
    if (MATCH_GUID((lpData->guidInfo), GUID_ColorControlCallbacks) )
    {
        DDHAL_DDCOLORCONTROLCALLBACKS ColConCB;

        DISPDBG((DBGLVL,"  GUID_ColorControlCallbacks"));

        memset(&ColConCB, 0, sizeof(ColConCB));
        ColConCB.dwSize = sizeof(ColConCB);
        ColConCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ColConCB.ColorControl = DdControlColor;

        dwSize = min( lpData->dwExpectedSize, sizeof(ColConCB));
        lpData->dwActualSize = sizeof(ColConCB);
        memcpy(lpData->lpvData, &ColConCB, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif
#endif

#if !defined(_WIN64) && WNT_DDRAW
    // Fill in the NT specific callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_NTCallbacks) )
    {
        DD_NTCALLBACKS NtCallbacks;

        memset(&NtCallbacks, 0, sizeof(NtCallbacks));

        dwSize = min(lpData->dwExpectedSize, sizeof(DD_NTCALLBACKS));

        NtCallbacks.dwSize           = dwSize;
        NtCallbacks.dwFlags          = DDHAL_NTCB32_FREEDRIVERMEMORY |
                                       DDHAL_NTCB32_SETEXCLUSIVEMODE |
                                       DDHAL_NTCB32_FLIPTOGDISURFACE;

        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;
        NtCallbacks.SetExclusiveMode = DdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = DdFlipToGDISurface;

        memcpy(lpData->lpvData, &NtCallbacks, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif

#if DX7_STEREO
    if (MATCH_GUID((lpData->guidInfo), GUID_DDMoreSurfaceCaps) )
    {
#if WNT_DDRAW
        DD_MORESURFACECAPS DDMoreSurfaceCaps;
#else
        DDMORESURFACECAPS DDMoreSurfaceCaps;
#endif
        DDSCAPSEX   ddsCapsEx, ddsCapsExAlt;
        ULONG ulCopyPointer;

        DISPDBG((DBGLVL,"  GUID_DDMoreSurfaceCaps"));

        // fill in everything until expectedsize...
        memset(&DDMoreSurfaceCaps, 0, sizeof(DDMoreSurfaceCaps));

        // Caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        DDMoreSurfaceCaps.dwSize=lpData->dwExpectedSize;

        if (_DD_bIsStereoMode(pThisDisplay,
                              pThisDisplay->dwScreenWidth,
                              pThisDisplay->dwScreenHeight,
                              pThisDisplay->ddpfDisplay.dwRGBBitCount))
        {
            DDMoreSurfaceCaps.ddsCapsMore.dwCaps2 =
                DDSCAPS2_STEREOSURFACELEFT;
        }
        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(DDMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreSurfaceCaps, dwSize);

        // Now fill in ddsCapsEx and ddsCapsExAlt heaps
        // Hardware with different restrictions for different heaps
        // should prepare ddsCapsEx and ddsCapsExAlt carefully and
        // fill them into lpvData in proper order
        while (dwSize < lpData->dwExpectedSize)
        {
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsEx,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsExAlt,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }
#endif // DX7_STEREO

    // We always handled it.
    DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );      
    return DDHAL_DRIVER_HANDLED;
    
} // DdGetDriverInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddover.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddover.c
*
* Content: DirectDraw Overlays implementation
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "ddover.h"

#define P3R3DX_VIDEO 1
#include "ramdac.h"


#if WNT_DDRAW

    #define ENABLE_OVERLAY(pThisDisplay, flag) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->bOverlayEnabled, flag )

    #define SET_OVERLAY_HEIGHT(pThisDisplay, height) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->VBLANKUpdateOverlayHeight, height )
    #define SET_OVERLAY_WIDTH(pThisDisplay, width) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->VBLANKUpdateOverlayWidth, width )
#else
    
    #define ENABLE_OVERLAY(pThisDisplay, flag) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->bOverlayEnabled, flag )

    #define SET_OVERLAY_HEIGHT(pThisDisplay, height) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->VBLANKUpdateOverlayHeight, height )
    #define SET_OVERLAY_WIDTH(pThisDisplay, width) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->VBLANKUpdateOverlayWidth, width )
#endif // WNT_DDRAW

// Flags used in the dwOverlayFiltering entry.
#define OVERLAY_FILTERING_X 0x1
#define OVERLAY_FILTERING_Y 0x2



// The table that says whether the overlay will actually work at
// This res, dot clock, etc.
typedef struct OverlayWorksEntry_tag
{
    int     iMemBandwidth;          // Actually just memory clock in kHz (well, 1024Hz units actually).
    int     iDotBandwidth;          // In kbytes/sec, i.e. dotclock * pixel depth / 2^10
    int     iSourceWidth;           // In bytes, i.e. pixels*depth.
    int     iWidthCoverage;         // Fraction of screen covered by overlay horizontally * 0x10000
} OverlayWorksEntry;

// This table lists areas that the overlay works in. If there is more memory
// bandwidth, and less of the other factors than given on any single line,
// then the overlay will work. If no single line covers the current mode,
// then the overlay will fail.
// Having more memory bandwidth is fine, and having less for all the others
// is fine - the overlay will still work.

#define SIZE_OF_OVERLAY_WORKS_TABLE 18

// DVD size is 1440 wide (720 YUYV pixels).
static OverlayWorksEntry OverlayWorksTable[SIZE_OF_OVERLAY_WORKS_TABLE] =
{
    {  68359, 210937,  928, 0x10000 },  // Max source width at 70MHz, 1152x864x16,75Hz
    {  68359, 210937, 1024, 0x06000 },  // Max coverage of 1024 width at 70MHz, 1152x864x16,75Hz
    {  68359, 210937, 2048, 0x04000 },  // Max coverage of 2048 width at 70MHz, 1152x864x16,75Hz
    {  68359, 421875,  864, 0x10000 },  // Max source width at 70MHz, 1152x864x32,75Hz
    {  68359, 421875, 1024, 0x04400 },  // Max coverage of 1024 width at 70MHz, 1152x864x32,75Hz
    {  68359, 421875, 2048, 0x03800 },  // Max coverage of 2048 width at 70MHz, 1152x864x32,75Hz

    {  87890, 210937, 1440, 0x10000 },  // Max source width at 90MHz, 1152x864x16,75Hz
    {  87890, 210937, 2048, 0x07000 },  // Max coverage of 2048 width at 90MHz, 1152x864x16,75Hz
    {  87890, 421875, 1152, 0x10000 },  // Max source width at 90MHz, 1152x864x32,75Hz
    {  87890, 421875, 1440, 0x09000 },  // Max DVD size at 90MHz, 1152x864x32,75Hz
    {  87890, 421875, 2048, 0x05500 },  // Max coverage of 2048 width at 90MHz, 1152x864x32,75Hz

    {  87890, 685546,  834, 0x10000 },  // Max source width at 90MHz, 1600x1200x32,64Hz
    {  87890, 685546, 2048, 0x03000 },  // Max coverage of 2048 width at 90MHz, 1600x1200x32,64Hz

// Shipping clock is 110, so measure at 105 just to be on the safe side.
    { 102559, 210937, 2048, 0x07155 },  // Max coverage of 2048 width at 105MHz, 1152x864x16,75Hz
    { 102559, 306640, 1440, 0x10000 },  // Max resoloution for fulscreen DVD at 105MHz: 1024x768x32,75Hz
    { 102559, 421875, 1440, 0x09e38 },  // Max DVD size at 105MHz, 1152x864x32,75Hz
    { 102559, 421875, 2048, 0x0551c },  // Max coverage of 2048 width at 105MHz, 1152x864x32,75Hz

// ...and one that only just works at 109MHz!
    { 106445, 421875, 1440, 0x10000 }   // Max DVD size at 109MHz, 1152x864x32,75Hz

};

//-----------------------------------------------------------------------------
//
// __OV_Compute_Best_Fit_Delta
//
// Function to calculate a 12.12 delta value to provide scaling from
// a src_dimension to the target dest_dimension.
// The dest_dimension is not adjustable, but the src_dimension may be adjusted
// slightly, so that the delta yields a more accurate value for dest.
// filter_adj should be set to 1 if linear filtering is going to be anabled
// during scaling, and 0 otherwise.
// int_bits indicates the number of bits in the scaled delta format
//
//-----------------------------------------------------------------------------
int 
__OV_Compute_Best_Fit_Delta(
    unsigned long *src_dimension,
    unsigned long  dest_dimension,
    unsigned long filter_adj,
    unsigned long int_bits,
    unsigned long *best_delta) 
{
  int result = 0;
  float fp_delta;
  float delta;
  unsigned long delta_mid;
  unsigned long delta_down;
  unsigned long delta_up;
  float mid_src_dim;
  float down_src_dim;
  float up_src_dim;
  float mid_err;
  float mid_frac;
  int   mid_ok;
  float down_err;
  float down_frac;
  int   down_ok;
  float up_err;
  float up_frac;
  int   up_ok;
  int   itemp;

  // The value at which a scaled delta value is deemed too large
  const unsigned int max_scaled_int = (1 << (12+int_bits));

  // Calculate an exact floating point delta
  fp_delta = (float)(*src_dimension - filter_adj) / dest_dimension;

  // Calculate the scaled representation of the delta
  delta = (fp_delta * (1<<12));

  // Truncate to max_int
  if (delta >= max_scaled_int) 
  {
    delta = (float)(max_scaled_int - 1); // Just below the overflow value
  }

  // Calculate the scaled approximation to the delta
  myFtoi(&delta_mid, delta);

  // Calculate the scaled approximation to the delta, less a 'bit'
  // But don't let it go out of range
  myFtoi(&delta_down, delta);
  if (delta_down != 0) 
  {
    delta_down --;
  }

  // Calculate the scaled approximation to the delta, plus a 'bit'
  // But don't let it go out of range
  myFtoi(&delta_up, delta);
  if ((delta_up + 1) < max_scaled_int) 
  {
    delta_up ++;
  }

  // Recompute the source dimensions, based on the dest and deltas
  mid_src_dim =
    (((float)(dest_dimension - 1) * delta_mid) / (1<<12)) + filter_adj;

  down_src_dim =
    (((float)(dest_dimension - 1) * delta_down) / (1<<12)) + filter_adj;

  up_src_dim =
    (((float)(dest_dimension - 1) * delta_up)   / (1<<12)) + filter_adj;

  // Choose the delta which gives final source coordinate closest the target,
  // while giving a fraction 'f' such that (1.0 - f) <= delta

  mid_err  = (float)myFabs(mid_src_dim - *src_dimension);
  myFtoi(&itemp, mid_src_dim);
  mid_frac = mid_src_dim - itemp;
  mid_ok = ((1.0 - mid_frac) <= ((float)(delta_mid) / (1<<12)));

  down_err  = (float)myFabs(down_src_dim - *src_dimension);
  myFtoi(&itemp, down_src_dim);
  down_frac = down_src_dim - itemp;
  down_ok = ((1.0 - down_frac) <= ((float)(delta_down) / (1<<12)));

  up_err  = (float)myFabs(up_src_dim - *src_dimension);
  myFtoi(&itemp, up_src_dim);
  up_frac = (up_src_dim - itemp);
  up_ok = ((1.0 - up_frac) <= ((float)(delta_up) / (1<<12)));

  if (mid_ok && (!down_ok || (mid_err <= down_err)) &&
        (!up_ok   || (mid_err <= up_err))) 
  {
    *best_delta = delta_mid;
    myFtoi(&itemp, (mid_src_dim + ((float)(delta_mid) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);

    result = 1;
  }
  else if (down_ok                            && 
           (!mid_ok || (down_err <= mid_err)) &&
           (!up_ok  || (down_err <= up_err ))  ) 
  {
    *best_delta = delta_down;
    myFtoi(&itemp, (down_src_dim + ((float)(delta_down) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);

    result = 1;
  }
  else if (up_ok                              && 
           (!mid_ok  || (up_err <= mid_err )) && 
           (!down_ok || (up_err <= down_err)) ) 
  {
    *best_delta = delta_up;
    myFtoi(&itemp, (up_src_dim + ((float)(delta_up) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);
    result = 1;
  }
  else 
  {
    result = 0;
    *best_delta = delta_mid;
    myFtoi(&itemp, (mid_src_dim + ((float)(delta_mid) / (1<<12))));
    myFtoi(&itemp, (itemp - filter_adj) + 0.9999f);
    *src_dimension = (unsigned long)itemp;
  }


  return result;
} // __OV_Compute_Best_Fit_Delta


//-----------------------------------------------------------------------------
//
// __OV_Find_Zoom
//
//-----------------------------------------------------------------------------
#define VALID_WIDTH(w)      ((w & 3) == 0)
#define MAKE_VALID_WIDTH(w) ((w) & ~0x3)
#define WIDTH_STEP          4

int 
__OV_Find_Zoom(
    unsigned long  src_width,
    unsigned long* shrink_width,
    unsigned long  dest_width,
    unsigned long* zoom_delta,
    BOOL bFilter) 
{
  int zoom_ok;
  int zx_adj = 0;

  // Find a suitable zoom delta for the given source
  // the source image may be adjusted in width by as much as 8 pixels to
  // acheive a match

  // Find zoom for requested width
  unsigned long trunc_width = MAKE_VALID_WIDTH(*shrink_width);
  zoom_ok = __OV_Compute_Best_Fit_Delta(&trunc_width, 
                                        dest_width, 
                                        zx_adj, 
                                        (bFilter ? 1 : 0),
                                        zoom_delta);

  // If no zoom was matched for the requested width, start searching up and down
  if (!zoom_ok || (!VALID_WIDTH(trunc_width))) 
  {
    unsigned long up_width   = MAKE_VALID_WIDTH(trunc_width) + WIDTH_STEP;
    unsigned long down_width = MAKE_VALID_WIDTH(trunc_width) - WIDTH_STEP;

    int done_up = 0;
    int done_down = 0;
    do 
    {
      // Check upwards
      zoom_ok = 0;
      if (up_width < dest_width) 
      {
        unsigned long new_width = up_width;
        zoom_ok = __OV_Compute_Best_Fit_Delta(&new_width, 
                                              dest_width, 
                                              zx_adj, 
                                              (bFilter ? 1 : 0),
                                              zoom_delta);

        // If the above call somehow adjusts width to invalid,
        // mark the delta invalid
        if (!VALID_WIDTH(new_width)) 
        {
          zoom_ok = 0;
        }

        if (zoom_ok) 
        {
          *shrink_width = new_width;
        }
        else 
        {
          up_width += WIDTH_STEP;
        }
      }
      else
        done_up = 1;

      // Check downwards
      if (!zoom_ok && (down_width >= 4) && (down_width < src_width)) 
      {
        unsigned long new_width = down_width;
        zoom_ok =
          __OV_Compute_Best_Fit_Delta(&new_width, dest_width, zx_adj, (bFilter ? 1 : 0),
                                 zoom_delta);

        // If the above call somehow adjusts width to invalid,
        // mark the delta invalid
        if (!VALID_WIDTH(new_width)) 
        {
          zoom_ok = 0;
        }

        if (zoom_ok) 
        {
          *shrink_width = new_width;
        }
        else 
        {
          down_width -= WIDTH_STEP;
        }
      }
      else
      {
        done_down = 1;
      }
      
    } while (!zoom_ok && (!done_up || !done_down));
  }
  
  return zoom_ok;
} // __OV_Find_Zoom

//-----------------------------------------------------------------------------
//
// __OV_Compute_Params
//
//-----------------------------------------------------------------------------
unsigned long 
__OV_Compute_Params(
    unsigned long  src_width,    
    unsigned long  dest_width,
    unsigned long *ovr_shrinkxd, 
    unsigned long *ovr_zoomxd,
    unsigned long *ovr_w,
    BOOL bFilter)
{
  unsigned long iterations = 0;

  unsigned long sx_adj = 0;

  const unsigned long fixed_one = 0x00001000;

  //
  // Use the source and destination rectangle dimensions to compute
  // delta values
  //

  int zoom_ok;

  unsigned long adj_src_width = src_width + 1; // +1 to account for -- below
  unsigned long exact_shrink_xd;
  unsigned long exact_zoom_xd;

  do 
  {
      unsigned long shrink_width;

    // Step to next source width
    adj_src_width--;

    // Make a stab at the deltas for the current source width

    // Initially, the deltas are assumed to be 1, and the width due to
    // shrinking is therefore equal to src width
    shrink_width = adj_src_width;
    exact_shrink_xd = fixed_one;
    exact_zoom_xd   = fixed_one;

    // Compute the shrink width and delta required
    if (dest_width < adj_src_width) 
    {
      // Shrink
      myFtoi(&exact_shrink_xd, (((float)(adj_src_width - sx_adj) /
                        (float)(dest_width)) * (1<<12)) + 0.999f);

      myFtoi(&shrink_width,(adj_src_width - sx_adj) /
                     ((float)(exact_shrink_xd) / (1<<12)));

    }

    // Truncate shrink to valid width
    if (!VALID_WIDTH(shrink_width) && (shrink_width > 4)) 
    {
      shrink_width = MAKE_VALID_WIDTH(shrink_width);
      
      myFtoi(&exact_shrink_xd,(((float)(adj_src_width - sx_adj) / 
                                (float)(shrink_width)) * (1<<12)) + 0.999f);
    }

    // Compute any zoom delta required
    zoom_ok = 1;
    if (shrink_width < dest_width) 
    {
      // Make an attempt at a zoom delta, and shrink-width for this src width
      zoom_ok = __OV_Find_Zoom(adj_src_width, &shrink_width, dest_width,
                          &exact_zoom_xd, bFilter);

      // Compute shrink delta
      myFtoi(&exact_shrink_xd,(((float)(adj_src_width - sx_adj) /
              (float)(shrink_width)) * (1<<12)) + 0.999f);
    }
  } while (0);

  *ovr_zoomxd       = exact_zoom_xd;
  *ovr_shrinkxd     = exact_shrink_xd;
  *ovr_w            = adj_src_width;

  return iterations;
} // __OV_Compute_Params

//-----------------------------------------------------------------------------
//
// __OV_ClipRectangles
//
// Clip the dest rectangle against the screen and change the source 
// rect appropriately
//
//-----------------------------------------------------------------------------
void 
__OV_ClipRectangles(
    P3_THUNKEDDATA* pThisDisplay, 
    DRVRECT* rcNewSrc, 
    DRVRECT* rcNewDest)
{
    float ScaleX;
    float ScaleY;
    float OffsetX;
    float OffsetY;
    float fTemp;
    DRVRECT rcSrc;
    DRVRECT rcDest;

    // Find the scale and offset from screen rects to overlay rects.
    // This is like a transform to take the dest rect to the source.
    ScaleX = (float)( pThisDisplay->P3Overlay.rcSrc.right - 
                      pThisDisplay->P3Overlay.rcSrc.left    ) / 
             (float)( pThisDisplay->P3Overlay.rcDest.right - 
                      pThisDisplay->P3Overlay.rcDest.left   );
                      
    ScaleY = (float)(pThisDisplay->P3Overlay.rcSrc.bottom   - 
                     pThisDisplay->P3Overlay.rcSrc.top       ) / 
             (float)( pThisDisplay->P3Overlay.rcDest.bottom - 
                      pThisDisplay->P3Overlay.rcDest.top     );
                      
    OffsetX = ((float)pThisDisplay->P3Overlay.rcSrc.left / ScaleX) - 
               (float)pThisDisplay->P3Overlay.rcDest.left;
               
    OffsetY = ((float)pThisDisplay->P3Overlay.rcSrc.top / ScaleY) - 
               (float)pThisDisplay->P3Overlay.rcDest.top;

    // Clip the dest against the screen
    if (pThisDisplay->P3Overlay.rcDest.right > 
        (LONG)pThisDisplay->dwScreenWidth)
    {
        rcDest.right =  (LONG)pThisDisplay->dwScreenWidth;
    }
    else
    {
        rcDest.right = pThisDisplay->P3Overlay.rcDest.right;
    }

    if (pThisDisplay->P3Overlay.rcDest.left < 0)
    {
        rcDest.left =  0;
    }
    else
    {
        rcDest.left = pThisDisplay->P3Overlay.rcDest.left;
    }

    if (pThisDisplay->P3Overlay.rcDest.top < 0)
    {
        rcDest.top =  0;
    }
    else
    {
        rcDest.top = pThisDisplay->P3Overlay.rcDest.top;
    }

    if (pThisDisplay->P3Overlay.rcDest.bottom > 
        (LONG)pThisDisplay->dwScreenHeight)
    {
        rcDest.bottom =  (LONG)pThisDisplay->dwScreenHeight;
    }
    else
    {
        rcDest.bottom = pThisDisplay->P3Overlay.rcDest.bottom;
    }

    // Transform the new dest rect to the new source rect
    fTemp = ( ( (float)rcDest.left + OffsetX ) * ScaleX + 0.499f);
    myFtoi ( (int*)&(rcSrc.left), fTemp );

    fTemp = ( ( (float)rcDest.right + OffsetX ) * ScaleX + 0.499f);
    myFtoi ( (int*)&(rcSrc.right), fTemp );

    fTemp = ( ( (float)rcDest.top + OffsetY ) * ScaleY + 0.499f);
    myFtoi ( (int*)&(rcSrc.top), fTemp );

    fTemp = ( ( (float)rcDest.bottom + OffsetY ) * ScaleY + 0.499f);
    myFtoi ( (int*)&(rcSrc.bottom), fTemp );

    *rcNewSrc = rcSrc;
    *rcNewDest = rcDest;

    DISPDBG((DBGLVL,"rcSrc.left: %d, rcSrc.right: %d", 
                    rcSrc.left, rcSrc.right));
    DISPDBG((DBGLVL,"rcDest.left: %d, rcDest.right: %d", 
                    rcDest.left, rcDest.right));
    return;
} // __OV_ClipRectangles

//-----------------------------------------------------------------------------
//
// _DD_OV_UpdateSource
//
// Update the source DDRAW surface that we are displaying from
// This routine is also used when using the overlay to stretch up for a 
// DFP display, so the DDraw overlay mechnism may be disabled and inactive 
// when this is called. It must allow for this.
//
//-----------------------------------------------------------------------------
void 
_DD_OV_UpdateSource(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwOverlaySourceOffset;

    DISPDBG ((DBGLVL,"** In _DD_OV_UpdateSource"));

    // Update current overlay surface
    pThisDisplay->P3Overlay.pCurrentOverlay = pSurf->lpGbl->fpVidMem;

    // Increase the buffer index
    pThisDisplay->P3Overlay.dwCurrentVideoBuffer++;
    if (pThisDisplay->P3Overlay.dwCurrentVideoBuffer > 2)
    {
        pThisDisplay->P3Overlay.dwCurrentVideoBuffer = 0;
    }

    dwOverlaySourceOffset = (DWORD)(pSurf->lpGbl->fpVidMem - 
                                      pThisDisplay->dwScreenFlatAddr);
                                
    switch (DDSurf_BitDepth(pSurf))
    {
        case 8:
            break;
        case 16:
            dwOverlaySourceOffset >>= 1;
            break;
        case 32:
            dwOverlaySourceOffset >>= 2;
            break;
        default:
            DISPDBG((ERRLVL,"Oops Overlay depth makes no sense"));
            break;
    }

    switch(pThisDisplay->P3Overlay.dwCurrentVideoBuffer)
    {
        case 0:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase0, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 0);
            break;
        case 1:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase1, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 1);
            break;
        case 2:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase2, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 2);
            break;
    }

} // _DD_OV_UpdateSource


//-----------------------------------------------------------------------------
//
// __OV_UpdatePosition
//
// Given the correct starting rectangle, this function clips it against the 
// screen and updates the overlay position registers.
// If *pdwShrinkFactor is NULL, then the overlay is updated, otherwise the
// desired shrink factor is put in *pdwShrinkFactor and the registers are
// NOT updated. This is so the shrink factor can be checked to see if the
// overlay would actually work in this case.
//
//-----------------------------------------------------------------------------
void 
__OV_UpdatePosition(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD *pdwShrinkFactor)
{
    DWORD dwSrcWidth;
    DWORD dwSrcHeight;
    DWORD dwDestHeight;
    DWORD dwDestWidth;
    DWORD dwXDeltaZoom;
    DWORD dwXDeltaShrink;
    DWORD dwYDelta;
    DWORD dwSrcAdjust;
    DRVRECT rcNewSrc;
    DRVRECT rcNewDest;
    P3RDRAMDAC *pP3RDRegs;
    DWORD dwLastShrink;
    DWORD dwLastZoom;
    
    DISPDBG ((DBGLVL,"**In __OV_UpdatePosition"));

    // Get a pointer to the ramdac
    pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg);

    // Get the clipped destination rectangles
    __OV_ClipRectangles(pThisDisplay, &rcNewSrc, &rcNewDest);

    // Get the widths
    dwDestWidth = (DWORD)(rcNewDest.right - rcNewDest.left);
    dwDestHeight = (DWORD)(rcNewDest.bottom - rcNewDest.top);
    dwSrcWidth = (DWORD)(rcNewSrc.right - rcNewSrc.left);
    dwSrcHeight = (DWORD)(rcNewSrc.bottom - rcNewSrc.top);

    if ( pThisDisplay->bOverlayPixelDouble )
    {
        // We need to double the destination width first.
        dwDestWidth <<= 1;
    }

    // Compute the overlay parameters
    __OV_Compute_Params(dwSrcWidth, 
                        dwDestWidth, 
                        &dwXDeltaShrink, 
                        &dwXDeltaZoom, 
                        &dwSrcAdjust, 
                        ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_X ) != 0 ) );
                        
    DISPDBG((DBGLVL,"OVERLAY: XShrink 0x%x", dwXDeltaShrink));
    DISPDBG((DBGLVL,"OVERLAY: XZoom 0x%x", dwXDeltaZoom));

    if ( pdwShrinkFactor != NULL )
    {
        // We just wanted to know the shrink factor.
        *pdwShrinkFactor = dwXDeltaShrink;
        return;
    }

    dwLastZoom = READ_GLINT_CTRL_REG(VideoOverlayZoomXDelta);
    dwLastShrink = READ_GLINT_CTRL_REG(VideoOverlayShrinkXDelta);

    if ( ((dwLastZoom >> 4) != dwXDeltaZoom) || 
         ((dwLastShrink >> 4) != dwXDeltaShrink)  )
    {
        //dwCurrentMode = READ_GLINT_CTRL_REG(VideoOverlayMode);
        //LOAD_GLINT_CTRL_REG(VideoOverlayMode, 0);

        LOAD_GLINT_CTRL_REG(VideoOverlayZoomXDelta, (dwXDeltaZoom << 4));
        LOAD_GLINT_CTRL_REG(VideoOverlayShrinkXDelta, (dwXDeltaShrink << 4));
        
        DISPDBG((DBGLVL,"OVERLAY: VideoOverlayZoomXDelta 0x%x", dwXDeltaZoom << 4));
        DISPDBG((DBGLVL,"OVERLAY: VideoOverlayShrinkXDelta 0x%x", dwXDeltaShrink << 4));

        //LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwCurrentMode);
    }   

    // Load up the Y scaling
    if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
    {
        // Apply filtering.
        dwYDelta = ( ( ( dwSrcHeight - 1 ) << 12 ) + dwDestHeight - 1 ) / dwDestHeight;
        // Make sure this will cause proper termination
        ASSERTDD ( ( dwYDelta * dwDestHeight ) >= ( ( dwSrcHeight - 1 ) << 12 ), "** __OV_UpdatePosition: dwYDelta is not big enough" );
        ASSERTDD ( ( dwYDelta * ( dwDestHeight - 1 ) ) < ( ( dwSrcHeight - 1 ) << 12 ), "** __OV_UpdatePosition: dwYDelta is too big" );
        dwYDelta <<= 4;
    }
    else
    {
        dwYDelta = ( ( dwSrcHeight << 12 ) + dwDestHeight - 1 ) / dwDestHeight;
        // Make sure this will cause proper termination
        ASSERTDD ( ( dwYDelta * dwDestHeight ) >= ( dwSrcHeight << 12 ), "** __OV_UpdatePosition: dwYDelta is not big enough" );
        ASSERTDD ( ( dwYDelta * ( dwDestHeight - 1 ) ) < ( dwSrcHeight << 12 ), "** __OV_UpdatePosition: dwYDelta is too big" );
        dwYDelta <<= 4;
    }
    LOAD_GLINT_CTRL_REG(VideoOverlayYDelta, dwYDelta);

    // Width & Height
    if ( RENDERCHIP_PERMEDIAP3 )
    {
        // These registers are _not_ synched to VBLANK like all the others,
        // so we need to do it manually.

        if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
        {
            SET_OVERLAY_HEIGHT ( pThisDisplay, ( rcNewSrc.bottom - rcNewSrc.top - 1 ) );
        }
        else
        {
            SET_OVERLAY_HEIGHT ( pThisDisplay, rcNewSrc.bottom - rcNewSrc.top );
        }
        SET_OVERLAY_WIDTH ( pThisDisplay, rcNewSrc.right - rcNewSrc.left );
    }
    else
    {
        // These auto-sync on everything else.
        LOAD_GLINT_CTRL_REG(VideoOverlayWidth, rcNewSrc.right - rcNewSrc.left);
        LOAD_GLINT_CTRL_REG(VideoOverlayHeight, rcNewSrc.bottom - rcNewSrc.top);
    }

    // Origin of source
    LOAD_GLINT_CTRL_REG(VideoOverlayOrigin, (rcNewSrc.top << 16) | (rcNewSrc.left & 0xFFFF));

    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayWidth 0x%x", rcNewSrc.right - rcNewSrc.left));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayHeight 0x%x", rcNewSrc.bottom - rcNewSrc.top));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayOrigin 0x%x",  (rcNewSrc.top << 16) | (rcNewSrc.left & 0xFFFF) ));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayYDelta 0x%x",  dwYDelta ));


    // Setup Overlay Dest in RAMDAC Unit.
    // RAMDAC registers are only 8bits wide.
    if ( pThisDisplay->bOverlayPixelDouble )
    {
        // Need to double all these numbers.
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTLOW, ((rcNewDest.left << 1) & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTHIGH, (rcNewDest.left >> 7));

        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDLOW, ((rcNewDest.right << 1 ) & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDHIGH, (rcNewDest.right >> 7));
    }
    else
    {
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTLOW, (rcNewDest.left & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTHIGH, (rcNewDest.left >> 8));

        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDLOW, (rcNewDest.right & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDHIGH, (rcNewDest.right >> 8));
    }

    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YSTARTLOW, (rcNewDest.top & 0xFF));
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YSTARTHIGH, (rcNewDest.top >> 8));
    
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YENDLOW, (rcNewDest.bottom & 0xFF));
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YENDHIGH, (rcNewDest.bottom >> 8));

    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XSTARTLOW   0x%x", (rcNewDest.left & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XSTARTHIGH  0x%x", (rcNewDest.left >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YSTARTLOW   0x%x", (rcNewDest.top & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YSTARTHIGH  0x%x", (rcNewDest.top >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XENDLOW     0x%x", (rcNewDest.right & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XENDHIGH    0x%x", (rcNewDest.right >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YENDLOW     0x%x", (rcNewDest.bottom & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YENDHIGH    0x%x", (rcNewDest.bottom >> 8) ));
} // __OV_UpdatePosition

//-----------------------------------------------------------------------------
//
// DdUpdateOverlay
//
// Repositions or modifies the visual attributes of an overlay surface.
//
// DdUpdateOverlay shows, hides, or repositions an overlay surface on the 
// screen. It also sets attributes of the overlay surface, such as the stretch 
// factor or type of color key to be used.
//
// The driver should determine whether it has the bandwidth to support the 
// overlay update request. The driver should use dwFlags to determine the type 
// of request and how to process it.
//
// The driver/hardware must stretch or shrink the overlay accordingly when the 
// rectangles specified by rDest and rSrc are different sizes.
//
// Note that DdFlip is used for flipping between overlay surfaces, so 
// performance for DdUpdateOverlay is not critical.
//
//
// Parameters
//
//      puod 
//          Points to a DD_UPDATEOVERLAYDATA structure that contains the 
//          information required to update the overlay. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that represents 
//              the DirectDraw object. 
//          .lpDDDestSurface 
//              Points to a DD_SURFACE_LOCAL structure that represents the 
//              DirectDraw surface to be overlaid. This value can be NULL 
//              if DDOVER_HIDE is specified in dwFlags. 
//          .rDest 
//              Specifies a RECTL structure that contains the x, y, width, 
//              and height of the region on the destination surface to be 
//              overlaid. 
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that describes the 
//              overlay surface. 
//          .rSrc 
//              Specifies a RECTL structure that contains the x, y, width, 
//              and height of the region on the source surface to be used 
//              for the overlay. 
//          .dwFlags 
//              Specifies how the driver should handle the overlay. This 
//              member can be a combination of any of the following flags: 
//
//              DDOVER_HIDE 
//                  The driver should hide the overlay; that is, the driver 
//                  should turn this overlay off. 
//              DDOVER_SHOW 
//                  The driver should show the overlay; that is, the driver 
//                  should turn this overlay on. 
//              DDOVER_KEYDEST 
//                  The driver should use the color key associated with the 
//                  destination surface. 
//              DDOVER_KEYDESTOVERRIDE 
//                  The driver should use the dckDestColorKey member of the 
//                  DDOVERLAYFX structure as the destination color key 
//                  instead of the color key associated with the destination 
//                  surface. 
//              DDOVER_KEYSRC 
//                  The driver should use the color key associated with the 
//                  destination surface. 
//              DDOVER_KEYSRCOVERRIDE 
//                  The driver should use the dckSrcColorKey member of the 
//                  DDOVERLAYFX structure as the source color key instead of 
//                  the color key associated with the destination surface. 
//              DDOVER_DDFX 
//                  The driver should show the overlay surface using the 
//                  attributes specified by overlayFX. 
//              DDOVER_ADDDIRTYRECT 
//                  Should be ignored by the driver. 
//              DDOVER_REFRESHDIRTYRECTS 
//                  Should be ignored by the driver. 
//              DDOVER_REFRESHALL 
//                  Should be ignored by the driver. 
//              DDOVER_INTERLEAVED 
//                  The overlay surface is composed of interleaved fields. 
//                  Drivers that support VPE need only check this flag. 
//              DDOVER_AUTOFLIP 
//                  The driver should autoflip the overlay whenever the 
//                  hardware video port autoflips. Drivers that support VPE 
//                  need only check this flag. 
//              DDOVER_BOB 
//                  The driver should display each field of VPE object data 
//                  individually without causing any jittery artifacts. This 
//                  flag pertains to both VPE and decoders that want to do 
//                  their own flipping in kernel mode using the kernel-mode 
//                  video transport functionality. 
//              DDOVER_OVERRIDEBOBWEAVE 
//                  Bob/weave decisions should not be overridden by other 
//                  interfaces. If the overlay mixer sets this flag, DirectDraw 
//                  will not allow a kernel-mode driver to use the kernel-mode 
//                  video transport functionality to switch the hardware 
//                  between bob and weave mode. 
//              DDOVER_BOBHARDWARE 
//                  Indicates that bob will be performed by hardware rather 
//                  than by software or emulation. Drivers that support VPE 
//                  need only check this flag. 
//
//          .overlayFX 
//              Specifies a DDOVERLAYFX structure describing additional effects 
//              that the driver should use to update the overlay. The driver 
//              should use this structure only if one of DDOVER_DDFX, 
//              DDOVER_KEYDESTOVERRIDE, or DDOVER_KEYSRCOVERRIDE are set in 
//              dwFlags. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdUpdateOverlay callback. A return code of DD_OK 
//              indicates success. 
//          .UpdateOverlay 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateOverlay(
    LPDDHAL_UPDATEOVERLAYDATA puod)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwDestColourKey;
    DWORD dwSrcColourKey;

    BOOL bSrcColorKey = FALSE;
    BOOL bDestColorKey = FALSE;
    P3_SURF_FORMAT* pFormatOverlaySrc;
    P3_SURF_FORMAT* pFormatOverlayDest;
    DWORD dwOverlayControl = 0;
    P3RDRAMDAC *pP3RDRegs;
    VideoOverlayModeReg OverlayMode;
    RDVideoOverlayControlReg RDOverlayControl;
    DWORD dwVideoOverlayUpdate;
    int iCurEntry, iCurDotBandwidth, iCurMemBandwidth, 
        iCurSourceWidth, iCurWidthCoverage;
    BOOL bNoFilterInY;

    GET_THUNKEDDATA(pThisDisplay, puod->lpDD);

    // Get a pointer to the ramdac
    pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg);
   
    DISPDBG ((DBGLVL,"**In DdUpdateOverlay dwFlags = %x",puod->dwFlags));

    ZeroMemory(&OverlayMode, sizeof(VideoOverlayModeReg));
    ZeroMemory(&RDOverlayControl, sizeof(RDOverlayControl));

    do
    {
        dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
    } while ((dwVideoOverlayUpdate & 0x1) != 0);

    // Are we hiding the overlay?
    if (puod->dwFlags & DDOVER_HIDE)
    {
        DISPDBG((DBGLVL,"** DdUpdateOverlay - hiding."));

        // Hide the overlay.
        if (pThisDisplay->P3Overlay.dwVisibleOverlays == 0)
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_HIDE - already hidden."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }
        // Hide an overlay which is not shown
        if (pThisDisplay->P3Overlay.pCurrentOverlay !=
            puod->lpDDSrcSurface->lpGbl->fpVidMem)
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - overlay not visible."));
            puod->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        OverlayMode.Enable = __PERMEDIA_DISABLE;
        RDOverlayControl.Enable = __PERMEDIA_DISABLE;
        
        ENABLE_OVERLAY(pThisDisplay, FALSE);
        pThisDisplay->P3Overlay.pCurrentOverlay = (FLATPTR)NULL;
        pThisDisplay->P3Overlay.dwVisibleOverlays = 0;
    }
    // Are we showing the overlay?
    else if ((puod->dwFlags & DDOVER_SHOW) || 
             (pThisDisplay->P3Overlay.dwVisibleOverlays != 0))
    {   
        if (pThisDisplay->P3Overlay.dwVisibleOverlays > 0) 
        {
            // Compare the video memory pointer to decide whether this is the
            // the current overlay surface
            if (pThisDisplay->P3Overlay.pCurrentOverlay != 
                puod->lpDDSrcSurface->lpGbl->fpVidMem)
            {
                // Overlay is already being displayed. Can't have a new one.
                DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_SHOW - already being shown, and it's a new surface."));
                puod->ddRVal = DDERR_OUTOFCAPS;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        if (((pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY) != 0) &&
            ((pThisDisplay->pGLInfo->dwScreenWidth != pThisDisplay->pGLInfo->dwVideoWidth) ||
             (pThisDisplay->pGLInfo->dwScreenHeight != pThisDisplay->pGLInfo->dwVideoHeight)))
        {
            // Display driver is using the overlay on a DFP, so we can't use it.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_SHOW - overlay being used for desktop stretching on DFP."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }


        // See if the screen is currently byte-doubled.
        if ( ( ( READ_GLINT_CTRL_REG(MiscControl) ) & 0x80 ) == 0 )
        {
            pThisDisplay->bOverlayPixelDouble = FALSE;
        }
        else
        {
            pThisDisplay->bOverlayPixelDouble = TRUE;
        }

        // Set up Video Overlay Color Format.
        pFormatOverlaySrc = _DD_SUR_GetSurfaceFormat( puod->lpDDSrcSurface);
        pFormatOverlayDest = _DD_SUR_GetSurfaceFormat( puod->lpDDDestSurface);

        pThisDisplay->P3Overlay.dwCurrentVideoBuffer = 0;

        OverlayMode.Enable = __PERMEDIA_ENABLE;
        RDOverlayControl.Enable = __PERMEDIA_ENABLE;

        ENABLE_OVERLAY(pThisDisplay, TRUE);
        pThisDisplay->P3Overlay.dwVisibleOverlays = 1;

        if (pFormatOverlaySrc->DeviceFormat == SURF_YUV422)
        {
            OverlayMode.YUV = VO_YUV_422;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_BGR;
        }
        else if (pFormatOverlaySrc->DeviceFormat == SURF_YUV444)
        {
            OverlayMode.YUV = VO_YUV_444;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_BGR;
        }
        else
        {
            OverlayMode.YUV = VO_YUV_RGB;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_RGB;
            switch (pFormatOverlaySrc->DitherFormat)
            {
                case P3RX_DITHERMODE_COLORFORMAT_8888:
                    OverlayMode.ColorFormat = VO_CF_RGB8888;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_4444:
                    OverlayMode.ColorFormat = VO_CF_RGB4444;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_5551:
                    OverlayMode.ColorFormat = VO_CF_RGB5551;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_565:
                    OverlayMode.ColorFormat = VO_CF_RGB565;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_332:
                    OverlayMode.ColorFormat = VO_CF_RGB332;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_CI:
                    OverlayMode.ColorFormat = VO_CF_RGBCI8;
                    break;

                default:
                    DISPDBG((ERRLVL,"** DdUpdateOverlay: Unknown overlay pixel type"));
                    puod->ddRVal = DDERR_INVALIDSURFACETYPE;
                    return DDHAL_DRIVER_HANDLED;
                    break;
            }
        }

        // Set up Video Overlay Pixel Size
        switch (pFormatOverlaySrc->dwBitsPerPixel) 
        {
            case 8:
                OverlayMode.PixelSize = VO_PIXEL_SIZE8;
                RDOverlayControl.DirectColor = __PERMEDIA_DISABLE;
                break;

            case 16:
                OverlayMode.PixelSize = VO_PIXEL_SIZE16;
                RDOverlayControl.DirectColor = __PERMEDIA_ENABLE;
                break;

            case 32:
                OverlayMode.PixelSize = VO_PIXEL_SIZE32;
                RDOverlayControl.DirectColor = __PERMEDIA_ENABLE;
                break;

            default:
                break;
        }

        // Keep the rectangles
        pThisDisplay->P3Overlay.rcDest = *(DRVRECT*)&puod->rDest;

        if ( pThisDisplay->P3Overlay.rcDest.left == 1 )
        {
            // Don't use 2 - it will "reveal" the (purple) colourkey colour.
            pThisDisplay->P3Overlay.rcDest.left = 0;
        }
        if ( pThisDisplay->P3Overlay.rcDest.right == 1 )
        {
            // Don't use 0 - it will "reveal" the (purple) colourkey colour.
            pThisDisplay->P3Overlay.rcDest.right = 2;
        }
        pThisDisplay->P3Overlay.rcSrc = *(DRVRECT*)&puod->rSrc;

        pThisDisplay->dwOverlayFiltering = OVERLAY_FILTERING_X | 
                                           OVERLAY_FILTERING_Y;

        // See if this overlay size works by looking it up in the table.
        iCurDotBandwidth = ( pThisDisplay->pGLInfo->PixelClockFrequency << pThisDisplay->pGLInfo->bPixelToBytesShift ) >> 10;
        iCurMemBandwidth = pThisDisplay->pGLInfo->MClkFrequency >> 10;
        iCurSourceWidth = ( puod->rSrc.right - puod->rSrc.left ) * ( pFormatOverlaySrc->dwBitsPerPixel >> 3 );
        iCurWidthCoverage = ( ( puod->rDest.right - puod->rDest.left ) << 16 ) / ( pThisDisplay->pGLInfo->dwScreenWidth );
        DISPDBG (( DBGLVL, "DdUpdateOverlay: Looking up mem=%d, pixel=%d, width=%d, coverage=0x%x", iCurMemBandwidth, iCurDotBandwidth, iCurSourceWidth, iCurWidthCoverage ));

        iCurEntry = 0;
        // Search for a line with lower memory bandwidth and higher everything else.
        while ( iCurEntry < SIZE_OF_OVERLAY_WORKS_TABLE )
        {
            if (( OverlayWorksTable[iCurEntry].iMemBandwidth  <= iCurMemBandwidth  ) &&
                ( OverlayWorksTable[iCurEntry].iDotBandwidth  >= iCurDotBandwidth  ) &&
                ( OverlayWorksTable[iCurEntry].iSourceWidth   >= iCurSourceWidth   ) &&
                ( OverlayWorksTable[iCurEntry].iWidthCoverage >= iCurWidthCoverage ) )
            {
                // Yep - this should be alright then.
                break;
            }
            iCurEntry++;
        }
        if ( iCurEntry == SIZE_OF_OVERLAY_WORKS_TABLE )
        {
            // Oops - this will fall over when filtered.
            DISPDBG((DBGLVL,"** P3RXOU32: overlay wanted mem=%d, pixel=%d, width=%d, coverage=0x%x", iCurMemBandwidth, iCurDotBandwidth, iCurSourceWidth, iCurWidthCoverage ));

            // Normal behaviour.
            bNoFilterInY = TRUE;
        }
        else
        {
            DISPDBG((DBGLVL,"** P3RXOU32: found  mem=%d, pixel=%d, width=%d, coverage=0x%x", OverlayWorksTable[iCurEntry].iMemBandwidth, OverlayWorksTable[iCurEntry].iDotBandwidth, OverlayWorksTable[iCurEntry].iSourceWidth, OverlayWorksTable[iCurEntry].iWidthCoverage ));
            bNoFilterInY = FALSE;
        }

        if ( bNoFilterInY )
        {
            // Turn off Y filtering.
            pThisDisplay->dwOverlayFiltering &= ~OVERLAY_FILTERING_Y;
        }

        // Overlay is fine to show.
        __OV_UpdatePosition(pThisDisplay, NULL);

        _DD_OV_UpdateSource(pThisDisplay, puod->lpDDSrcSurface);

        // Stride of source
        LOAD_GLINT_CTRL_REG(VideoOverlayStride, DDSurf_GetPixelPitch(puod->lpDDSrcSurface));
        LOAD_GLINT_CTRL_REG(VideoOverlayFieldOffset, 0x0);
    
        if ( puod->dwFlags & DDOVER_KEYDEST )
        {
            // Use destination surface's destination colourkey for dst key.
            dwDestColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
            bDestColorKey = TRUE;
        }

        if ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE )
        {
            // Use DDOVERLAYFX dest colour for dst key.
            dwDestColourKey = puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            bDestColorKey = TRUE;
        }
        
        if ( puod->dwFlags & DDOVER_KEYSRC )
        {
            // Use source surface's source colourkey for src key.
            dwSrcColourKey = puod->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
            bSrcColorKey = TRUE;
        }

        if ( puod->dwFlags & DDOVER_KEYSRCOVERRIDE )
        {
            // Use DDOVERLAYFX src colour for src key.
            dwSrcColourKey = puod->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
            bSrcColorKey = TRUE;
        }

        if (bSrcColorKey && bDestColorKey)
        {
            // We can't do both - return an error.
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }

        RDOverlayControl.Mode = VO_MODE_ALWAYS;

        if (bSrcColorKey)
        {
            if (pFormatOverlaySrc->DeviceFormat == SURF_YUV422)
            {
                // Er... this is a very odd pixel format - how do I get a useful number out of it?
                DISPDBG((ERRLVL,"** DdUpdateOverlay: no idea how to get a YUV422 source colour"));
            }
            else if (pFormatOverlaySrc->DeviceFormat == SURF_YUV444)
            {
                // No idea how to get a useful number out of this.
                DISPDBG((ERRLVL,"** DdUpdateOverlay: no idea how to get a YUV444 source colour"));
            }
            else
            {
                switch (pFormatOverlaySrc->DitherFormat)
                {
                    case P3RX_DITHERMODE_COLORFORMAT_CI:
                        // Formatting already done.
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_332:
                        dwSrcColourKey = FORMAT_332_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_5551:
                        dwSrcColourKey = FORMAT_5551_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_4444:
                        dwSrcColourKey = FORMAT_4444_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_565:
                        dwSrcColourKey = FORMAT_565_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_8888:
                        dwSrcColourKey = FORMAT_8888_32BIT_BGR(dwSrcColourKey);
                        break;

                    default:
                        DISPDBG((ERRLVL,"** DdUpdateOverlay: Unknown overlay pixel type"));
                        break;
                }
            }

            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwSrcColourKey & 0xFF));
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwSrcColourKey >> 8) & 0xFF));
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwSrcColourKey >> 16) & 0xFF));

            RDOverlayControl.Mode = VO_MODE_OVERLAYKEY;
        }

        if (bDestColorKey)
        {

            switch (pFormatOverlayDest->dwBitsPerPixel) 
            {
                case 8:
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, (dwDestColourKey & 0xFF));
                    break;

                case 16:
                    if (pFormatOverlayDest->DitherFormat == P3RX_DITHERMODE_COLORFORMAT_5551) 
                    {
                        dwDestColourKey = FORMAT_5551_32BIT_BGR(dwDestColourKey);
                    }
                    else 
                    {
                        dwDestColourKey = FORMAT_565_32BIT_BGR(dwDestColourKey);
                    }
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwDestColourKey >> 8) & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwDestColourKey >> 16) & 0xFF));
                    break;

                case 32:
                    dwDestColourKey = FORMAT_8888_32BIT_BGR(dwDestColourKey);
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwDestColourKey >> 8) & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwDestColourKey >> 16) & 0xFF));
                    break;

                default:
                    break;
            }

            RDOverlayControl.Mode = VO_MODE_MAINKEY;
        }

        // Filtering
        if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_X ) != 0 )
        {
            if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
            {
                // Full filtering.
                OverlayMode.Filter = 1;
            }
            else
            {
                // In X only - no extra bandwidth problems.
                // BUT THIS DOESN'T SEEM TO WORK IN SOME CASES - WE JUST GET NO FILTERING AT ALL!
                OverlayMode.Filter = 2;
            }
        }
        else
        {
            // No filtering at all.
            // (can't do Y filtering with no X filtering, but it never happens anyway).
            OverlayMode.Filter = 0;
        }

        if (puod->dwFlags & DDOVER_ALPHADESTCONSTOVERRIDE)
        {
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_BLEND, puod->overlayFX.dwAlphaDestConst);
            RDOverlayControl.Mode = VO_MODE_BLEND;
        }
    }

    // Load up the overlay mode
    LOAD_GLINT_CTRL_REG(VideoOverlayMode, *(DWORD*)&OverlayMode);

    // Setup the overlay control bits in the RAMDAC
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_CONTROL, *(BYTE*)&RDOverlayControl);

    // Update the settings
    UPDATE_OVERLAY(pThisDisplay, TRUE, TRUE);

    puod->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdUpdateOverlay

//-----------------------------------------------------------------------------
//
// DdSetOverlayPosition
//
// Sets the position for an overlay
//
//  When the overlay is visible, the driver should cause the overlay to be 
//  displayed on the primary surface. The upper left corner of the overlay 
//  should be anchored at (lXPos,lYPos). For example, values of (0,0) indicates 
//  that the upper left corner of the overlay should appear in the upper left 
//  corner of the surface identified by lpDDDestSurface.
//
//  When the overlay is invisible, the driver should set DDHAL_DRIVER_HANDLED in 
//  ddRVal and return.
//
// Parameters
//
//      psopd 
//          Points to a DD_SETOVERLAYPOSITIONDATA structure that contains the 
//          information required to set the overlay position. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that describes the 
//              driver. 
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that represents the 
//              DirectDraw overlay surface. 
//          .lpDDDestSurface 
//              Points to a DD_SURFACE_LOCAL structure representing the surface 
//              that is being overlaid. 
//          .lXPos 
//              Specifies the x coordinate of the upper left corner of the 
//              overlay, in pixels. 
//          .lYPos 
//              Specifies the y coordinate of the upper left corner of the 
//              overlay, in pixels. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdSetOverlayPosition callback. A return code of 
//              DD_OK indicates success. 
//          .SetOverlayPosition 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetOverlayPosition(
    LPDDHAL_SETOVERLAYPOSITIONDATA psopd)
{
    P3_THUNKEDDATA*       pThisDisplay;
    LONG lDestWidth;
    LONG lDestHeight;
    DWORD dwVideoOverlayUpdate;
    GET_THUNKEDDATA(pThisDisplay, psopd->lpDD);

    DISPDBG ((DBGLVL,"**In DdSetOverlayPosition"));

    if (pThisDisplay->P3Overlay.dwVisibleOverlays == 0)
    {
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }
    
    do
    {
        dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
    } while ((dwVideoOverlayUpdate & 0x1) != 0);

    lDestWidth = pThisDisplay->P3Overlay.rcDest.right - pThisDisplay->P3Overlay.rcDest.left;
    lDestHeight = pThisDisplay->P3Overlay.rcDest.bottom - pThisDisplay->P3Overlay.rcDest.top;

    // Keep the new position
    pThisDisplay->P3Overlay.rcDest.left = psopd->lXPos;
    pThisDisplay->P3Overlay.rcDest.right = psopd->lXPos + (LONG)lDestWidth;

    pThisDisplay->P3Overlay.rcDest.top = psopd->lYPos;
    pThisDisplay->P3Overlay.rcDest.bottom = psopd->lYPos + (LONG)lDestHeight;
    
    // Update the overlay position  
    __OV_UpdatePosition(pThisDisplay, NULL);

    // Update the settings
    LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);

    psopd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} // DdSetOverlayPosition
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddenable.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddenable.c
*
* Content: Windows 2000 only DirectDraw/D3D enabling functions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"

#if WNT_DDRAW

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_BuildPixelFormat
//
// generate a pixel format structure based on the mode
// This example works only with RGB surfaces
//
//-----------------------------------------------------------------------------
void 
__DDE_BuildPixelFormat(
    P3_THUNKEDDATA* pThisDisplay,
    LPGLINTINFO pGLInfo,
    LPDDPIXELFORMAT pdpf )
{
    PPDEV ppdev;

    ppdev = pThisDisplay->ppdev;

    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwFourCC = 0;

    pdpf->dwFlags = DDPF_RGB;

    if( pGLInfo->dwBpp == 8 )
    {
        pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
    }
    pdpf->dwRGBBitCount = pGLInfo->dwBpp;

    pdpf->dwRBitMask = ppdev->flRed;
    pdpf->dwGBitMask = ppdev->flGreen;
    pdpf->dwBBitMask = ppdev->flBlue;

    // Calculate the alpha channel as it isn't in the ppdev
    switch (pGLInfo->dwBpp)
    {
        case 8:
            DISPDBG((DBGLVL, "Format is 8 bits"));
            pdpf->dwRGBAlphaBitMask = 0;
            break;
            
        case 16:
            DISPDBG((DBGLVL, "Format is 16 bits"));
            switch(ppdev->flRed)
            {
                case 0x7C00:
                    pdpf->dwRGBAlphaBitMask = 0x8000L;
                    pdpf->dwFlags |= DDPF_ALPHAPIXELS;
                    break;
                default:
                    pdpf->dwRGBAlphaBitMask = 0x0L;
            }
            break;
        case 24:
            DISPDBG((DBGLVL, "Format is 24 bits"));
            pdpf->dwRGBAlphaBitMask = 0x00000000L;
            break;
        case 32:
            DISPDBG((DBGLVL, "Desktop is 32 bits"));
            pdpf->dwRGBAlphaBitMask = 0xff000000L;
            pdpf->dwFlags |= DDPF_ALPHAPIXELS;
            break;
            
    }
} // __DDE_BuildPixelFormat 

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_bSetupDDStructs
//
// This fills in the data that would have been setup on Win9X in the
// 16 bit side
// 
//-----------------------------------------------------------------------------
BOOL 
__DDE_bSetupDDStructs( 
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL reset )
{
    DWORD dwRegistryValue;
    BOOL bSuccess;
    LPGLINTINFO pGLInfo;
    PPDEV ppdev;
    void *fbPtr;            // Framebuffer pointer
    void *lbPtr;            // Localbuffer pointer
    DWORD fbSizeInBytes;    // Size of framebuffer
    DWORD lbSizeInBytes;    // Size of localbuffer
    DWORD fbOffsetInBytes;  // Offset to 1st 'free' byte in framebuffer
    DWORD dwMemStart, dwMemEnd;

    // reset == TRUE if there has been a mode change.
    pThisDisplay->bResetMode = reset;

#if DBG
    if (pThisDisplay->bResetMode)
    {
        DISPDBG((DBGLVL,"Resetting due to mode change"));
    }
    else
    {
        DISPDBG((DBGLVL, "Creating for the first time"));
    }
#endif

    // Setup pThisDisplay->pGLInfo from PPDEV
    pGLInfo = pThisDisplay->pGLInfo;
    ppdev = pThisDisplay->ppdev;

    GetFBLBInfoForDDraw (ppdev, 
                          &fbPtr,               // Framebuffer pointer
                          &lbPtr,               // Localbuffer pointer,
                                                //     (*** This is NULL***)
                          &fbSizeInBytes,       // Size of framebuffer
                          &lbSizeInBytes,       // Size of localbuffer
                          &fbOffsetInBytes,     // Offset to 1st 'free' byte 
                                                //     in framebuffer
                          &pGLInfo->bDRAMBoard);// TRUE if SDRAM vidmem, 
                                                //   FALSE if SGRAM 
                                                //   (i.e. hw writemask) vidmem


    DISPDBG((DBGLVL, "__DDE_bSetupDDStructs: fbPtr 0x%lx, fbOff 0x%x", 
                     fbPtr, fbOffsetInBytes));

    // If VBlankStatusPtr is non-NULL then we know that the NT miniport 
    // will set the VBlankStatusPtr for us.
    if (pThisDisplay->VBlankStatusPtr)
        pGLInfo->dwFlags = GMVF_VBLANK_ENABLED;// Say that we are using VBLANKs
    else
        pGLInfo->dwFlags = 0;

    pGLInfo->bPixelToBytesShift = (unsigned char)ppdev->cPelSize;
    pGLInfo->ddFBSize = fbSizeInBytes;
    pGLInfo->dwScreenBase = 0;
    pGLInfo->dwOffscreenBase = fbOffsetInBytes;

    pGLInfo->dwScreenWidth = ppdev->cxScreen;   // Driver info
    pGLInfo->dwScreenHeight = ppdev->cyScreen;
    pGLInfo->dwVideoWidth = ppdev->cxMemory;
    pGLInfo->dwVideoHeight = ppdev->cyMemory;

    bSuccess = GET_REGISTRY_ULONG_FROM_STRING(
                        "HardwareInformation.CurrentPixelClockSpeed",
                        &dwRegistryValue);
    if(!bSuccess)
    {
        DISPDBG((ERRLVL,"Error - can't determine pixel clock"));
        dwRegistryValue = 0;
    }
    DISPDBG((DBGLVL,"Pixel clock frequency is %dHz", dwRegistryValue));
    pGLInfo->PixelClockFrequency = dwRegistryValue;

    bSuccess = GET_REGISTRY_ULONG_FROM_STRING(
                        "HardwareInformation.CurrentMemClockSpeed", 
                        &dwRegistryValue);
    if(!bSuccess)
    {
        DISPDBG((ERRLVL,"Error - can't determine memory clock"));
        dwRegistryValue = 0;
    }
    
    DISPDBG((DBGLVL,"Memory clock frequency is %dHz", dwRegistryValue));
    pGLInfo->MClkFrequency = dwRegistryValue;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 8 bits"));
        pGLInfo->dwBpp = 8;
    }
    else if (ppdev->iBitmapFormat == BMF_16BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 16 bits"));
        pGLInfo->dwBpp = 16;
    }
    else if (ppdev->iBitmapFormat == BMF_24BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 24 bits"));
        pGLInfo->dwBpp = 24;
    }
    else
    {
        DISPDBG((DBGLVL, "Desktop is 32 bits"));
        pGLInfo->dwBpp = 32;
    }

    pGLInfo->dwScreenWidthBytes = ppdev->lDelta;

    if (pGLInfo->pRegs == 0)
    {
        DISPDBG ((WRNLVL, "__DDE_bSetupDDStructs: NULL register set"));
        return (FALSE);
    }

    // Setup the information that is shared with the 32 bit side
    // Control points to the RAMDAC
    // pGLInfo is a pointer to the DisplayDriver state.
    pThisDisplay->pGLInfo = pGLInfo;
    pThisDisplay->control = (FLATPTR) pGLInfo->pRegs;

    // NT uses offsets for its memory addresses
    pThisDisplay->dwScreenFlatAddr = 0;
    pThisDisplay->dwLocalBuffer = 0;

    __DDE_BuildPixelFormat( pThisDisplay, 
                        (LPGLINTINFO) pThisDisplay->pGLInfo, 
                        &pThisDisplay->ddpfDisplay );

    // Setup the display size information
    // dwScreenWidth, dwScreenHeight = current resolution
    // cxMemory = Pixels across for one scanline 
    //              (not necessarily the same as the screen width)
    // cyMemory = Scanline height of the memory
    // dwScreenStart = First visible line of display
    pThisDisplay->dwScreenWidth = pGLInfo->dwScreenWidth;
    pThisDisplay->dwScreenHeight = pGLInfo->dwScreenHeight;
    pThisDisplay->cxMemory = pGLInfo->dwScreenWidth;

    pThisDisplay->dwScreenStart = pThisDisplay->dwScreenFlatAddr + 
                                                        pGLInfo->dwScreenBase;
    
    // Usefull constants used during blits.
    if (pThisDisplay->ddpfDisplay.dwRGBBitCount == 24)
    {
        // The driver will detect these strange values and handle appropriately
        pThisDisplay->bPixShift = 4;
        pThisDisplay->bBppShift = 4;
        pThisDisplay->dwBppMask = 4;
        
        pThisDisplay->cyMemory = pGLInfo->ddFBSize / 
                                    (pThisDisplay->dwScreenWidth * 3);
    }
    else
    {
        // = 2,1,0 for 32,16,8 depth.  Shifts needed to calculate bytes/pixel
        pThisDisplay->bPixShift = 
                            (BYTE)pThisDisplay->ddpfDisplay.dwRGBBitCount >> 4;
        // = 0,1,2 for 32/16/8.
        pThisDisplay->bBppShift = 2 - pThisDisplay->bPixShift;
        // = 3,1,0 for 8,16,32 bpp
        pThisDisplay->dwBppMask = 3 >> pThisDisplay->bPixShift;

        pThisDisplay->cyMemory = 
                        pGLInfo->ddFBSize / 
                            (pThisDisplay->dwScreenWidth <<  
                                (pThisDisplay->ddpfDisplay.dwRGBBitCount >> 4));
    }

    // On Windows NT, we manage a region of memory starting from 0 
    //(all pointers are offsets from the start of the mapped memory)
    dwMemStart = pGLInfo->dwOffscreenBase;
    dwMemEnd = pGLInfo->ddFBSize - 1;

    // Round up the start pointer and round down the end pointer
    dwMemStart = (dwMemStart + 3) & ~3;
    dwMemEnd = dwMemEnd & ~3;
    
    // Now make the end pointer inclusive
    dwMemEnd -= 1;

    DISPDBG((DBGLVL,"Heap Attributes:"));
    DISPDBG((DBGLVL,"  Start of Heap Memory: 0x%lx", 
                pThisDisplay->LocalVideoHeap0Info.dwMemStart));
    DISPDBG((DBGLVL,"  End of Heap Memory: 0x%lx", 
                pThisDisplay->LocalVideoHeap0Info.dwMemEnd));

    // If we already have a heap setup and the mode has changed
    // we free the Heap manager
    if (pThisDisplay->bDDHeapManager)
    {
        if (pThisDisplay->bResetMode)
        {
            // The mode has been changed.  
            // We need to free the allocator and re-create it
            _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);

            // Start the allocator off again.
            _DX_LIN_InitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info,
                                          dwMemStart,
                                          dwMemEnd);
        }
    }
    else
    {
        // This must be the first instance of a created driver,
        // so create the Heap and remember that it is created.
        _DX_LIN_InitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info,
                                      dwMemStart,
                                      dwMemEnd);
        pThisDisplay->bDDHeapManager = TRUE;
    }

    if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
    {
        // save away the heap info we really need, we won't actually 
        // enable the DX managed heap until we get a 
        // DrvNotify(DN_DRAWING_BEGIN)
        ppdev->heap.pvmLinearHeap = &pThisDisplay->LocalVideoHeap0Info;
        ppdev->heap.cLinearHeaps = 1;
    }

    return TRUE;
} // __DDE_bSetupDDStructs

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_bDestroyDDStructs
//
// Disable the linear allocator.  
//
//-----------------------------------------------------------------------------
BOOL 
__DDE_bDestroyDDStructs ( 
    P3_THUNKEDDATA* pThisDisplay )
{
    // Release the linear allocator
    if (pThisDisplay->bDDHeapManager)
    {
        _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);
    }

    // 3D Heap manager not available.
    pThisDisplay->bDDHeapManager = FALSE;

    // Reset the driver version to 0 so it will be filled in again.
    pThisDisplay->dwDXVersion = 0;

    return TRUE;

} // __DDE_bDestroyDDStructs

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_CreatePPDEV
//
// These functions are called in sync with the creation/destruction of the pDev
//
//-----------------------------------------------------------------------------
BOOL 
_DD_DDE_CreatePPDEV(
    PDEV* ppdev)
{
    P3_THUNKEDDATA* pThisDisplay;

    DISPDBG((DBGLVL,"*** In _DD_DDE_CreatePPDEV"));

    ASSERTDD(ppdev->thunkData == NULL,
             "ERROR: thunkData already created for this pDev??");

    // initialize the DX context which will be used by the display driver 
    // context switcher. We need a reference count because there is a case 
    // when a second, temporary, context would otherwise be created (when 
    // enabling the second adapter in a m-monitor system), first scrubbing 
    // out the old context ID, then invalidating the new one when it is
    // deleted!
    ppdev->DDContextID = -1;
    ppdev->DDContextRefCount = 0;

    // Allocate our ppdev
    ppdev->thunkData = (PVOID)HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                                         sizeof(P3_THUNKEDDATA),
                                         ALLOC_TAG_DX(D));                                          
    if (ppdev->thunkData == NULL)
    {
        DISPDBG((ERRLVL, "_DD_DDE_CreatePPDEV: thunkdata alloc failed"));
        return (FALSE);
    }

    // Our ppdev is called pThisDisplay
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;
    pThisDisplay->ppdev = ppdev;

    pThisDisplay->pGLInfo = (PVOID)HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                                              sizeof(GlintInfo),
                                              ALLOC_TAG_DX(E));
    if (pThisDisplay->pGLInfo == NULL)
    {
        DISPDBG((ERRLVL, "_DD_DDE_CreatePPDEV: pGLInfo alloc failed"));

        EngFreeMem (pThisDisplay);
        ppdev->thunkData = NULL;

        return (FALSE);
    }

//@@BEGIN_DDKSPLIT
    // W9X DX version is setup in the display driver.
//@@END_DDKSPLIT    

    // On Windows W2000 DX is always at least DX7
    pThisDisplay->dwDXVersion = DX7_RUNTIME;

    GetChipInfoForDDraw(ppdev, 
                        &pThisDisplay->pGLInfo->dwRenderChipID, 
                        &pThisDisplay->pGLInfo->dwRenderChipRev, 
                        &pThisDisplay->pGLInfo->dwRenderFamily,
                        &pThisDisplay->pGLInfo->dwGammaRev);

    DISPDBG((DBGLVL,"RenderChip: 0x%x, RenderFamily: 0x%x", 
                    pThisDisplay->pGLInfo->dwRenderChipID, 
                    pThisDisplay->pGLInfo->dwRenderFamily));

    return TRUE;
} // _DD_DDE_CreatePPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_ResetPPDEV
//
//-----------------------------------------------------------------------------
void _DD_DDE_ResetPPDEV(PDEV* ppdevOld, PDEV* ppdevNew)
{
    P3_THUNKEDDATA* pThisDisplayOld = (P3_THUNKEDDATA*)ppdevOld->thunkData;
    P3_THUNKEDDATA* pThisDisplayNew = (P3_THUNKEDDATA*)ppdevNew->thunkData;
    
    DISPDBG((DBGLVL,"_DD_DDE_ResetPPDEV: "
                    "pThisDispayOld: 0x%x, pThisDisplayNew: 0x%x", 
                    pThisDisplayOld, pThisDisplayNew));
               
} // _DD_DDE_ResetPPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_DestroyPPDEV
//
//-----------------------------------------------------------------------------
void _DD_DDE_DestroyPPDEV(PDEV* ppdev)
{
    P3_THUNKEDDATA* pThisDisplay = (P3_THUNKEDDATA*)ppdev->thunkData;

#if DBG
    g_pThisTemp = NULL;
#endif

    if (pThisDisplay)
    {
        // The 32 bit side will have allocated memory for use as global 
        // D3D/DD Driver data. Free it if it is there
        if (pThisDisplay->pD3DHALCallbacks16)
        {
            SHARED_HEAP_FREE(&pThisDisplay->pD3DHALCallbacks16, 
                             &pThisDisplay->pD3DHALCallbacks32,
                             TRUE);
                                
            DISPDBG((DBGLVL,"Freed pThisDisplay->pD3DHALCallbacks32"));
        }

        if (pThisDisplay->pD3DDriverData16)
        {
            SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                             &pThisDisplay->pD3DDriverData32,
                             TRUE);
                    
            DISPDBG((DBGLVL,"Freed pThisDisplay->pD3DDriverData32"));
        }

        pThisDisplay->lpD3DGlobalDriverData = 0;
        pThisDisplay->lpD3DHALCallbacks = 0;

        if (pThisDisplay->pGLInfo)
        {
            EngFreeMem (pThisDisplay->pGLInfo);
            pThisDisplay->pGLInfo = NULL;
            DISPDBG((DBGLVL,"Freed pThisDisplay->pGLInfo"));
        }

        EngFreeMem (pThisDisplay);
        pThisDisplay = NULL;
        DISPDBG((DBGLVL,"Freed pThisDisplay"));
    }

    // Clear the pointer
    ppdev->thunkData = NULL;
    
} // _DD_DDE_DestroyPPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_vAssertModeDirectDraw
//
// This function is called by enable.c when entering or leaving the
// DOS full-screen character mode.
//
//-----------------------------------------------------------------------------
VOID 
_DD_DDE_vAssertModeDirectDraw(
    PDEV*   ppdev,
    BOOL    bEnabled)
{
    P3_THUNKEDDATA* pThisDisplay = (P3_THUNKEDDATA*)ppdev->thunkData;
    
    DISPDBG((DBGLVL, "_DD_DDE_vAssertModeDirectDraw: enter"));

#if DX7_TEXMANAGEMENT
    // Mark all managed surfaces as dirty as we've lost 
    // everything living in the videomemory

   _DD_TM_EvictAllManagedTextures(pThisDisplay);
    
#endif    
    
} // _DD_DDE_vAssertModeDirectDraw

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_bEnableDirectDraw
//
// This function is called by enable.c when the mode is first initialized,
// right after the miniport does the mode-set.
//
//-----------------------------------------------------------------------------
BOOL _DD_DDE_bEnableDirectDraw(
PDEV*   ppdev)
{
    DISPDBG((DBGLVL, "_DD_DDE_bEnableDirectDraw: enter"));

    // DirectDraw is all set to be used on this card:
    ppdev->flStatus |= STAT_DIRECTDRAW;

    return(TRUE);
} // _DD_DDE_bEnableDirectDraw

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_vDisableDirectDraw
//
// This function is called by enable.c when the driver is shutting down.
//
//-----------------------------------------------------------------------------
VOID _DD_DDE_vDisableDirectDraw(
PDEV*   ppdev)
{
     DISPDBG((DBGLVL, "_DD_DDE_vDisableDirectDraw: enter"));
} // _DD_DDE_vDisableDirectDraw

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DrvEnableDirectDraw
//
// Enables hardware for DirectDraw use.
//
// GDI calls DrvEnableDirectDraw to obtain pointers to the DirectDraw callbacks
// that the driver supports. The driver should set the function pointer members 
// of DD_CALLBACKS, DD_SURFACECALLBACKS, and DD_PALETTECALLBACKS to point to 
// those functions that it implements. A driver should also set the 
// corresponding bit fields in the dwFlags members of these structures for all 
// supported callbacks.
//
// A driver's DrvEnableDirectDraw implementation can also dedicate hardware 
// resources such as display memory for use by DirectDraw only.
//
// DrvEnableDirectDraw returns TRUE if it succeeds; otherwise, it returns FALSE
//
//  Parameters
//
//      dhpdev 
//          Handle to the PDEV returned by the driver's DrvEnablePDEV routine.
//      pCallBacks 
//          Points to the DD_CALLBACKS structure to be initialized by the 
//          driver. 
//      pSurfaceCallBacks 
//          Points to the DD_SURFACECALLBACKS structure to be initialized by 
//          the driver. 
//      pPaletteCallBacks 
//          Points to the DD_PALETTECALLBACKS structure to be initialized by 
//          the driver. 
//
//-----------------------------------------------------------------------------

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV* ppdev;
    BOOL bRet;
    DWORD dwResult;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD *theVBlankThing, *bOverlayEnabled;
    DWORD *VBLANKUpdateOverlay;
    DWORD *VBLANKUpdateOverlayWidth;
    DWORD *VBLANKUpdateOverlayHeight;
    DWORD Buffers;
    
    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    if (!bSetupOffscreenForDDraw (FALSE, 
                                  ppdev, 
                                  &theVBlankThing, 
                                  &bOverlayEnabled, 
                                  &VBLANKUpdateOverlay, 
                                  &VBLANKUpdateOverlayWidth, 
                                  &VBLANKUpdateOverlayHeight))
    {
        DISPDBG((ERRLVL, "DrvEnableDirectDraw: "
                         "bSetupOffscreenForDDraw failed, but continuing"));
        //return (FALSE);
    }

    pThisDisplay->VBlankStatusPtr = theVBlankThing;
    pThisDisplay->bOverlayEnabled = bOverlayEnabled;
    pThisDisplay->bVBLANKUpdateOverlay = VBLANKUpdateOverlay;
    pThisDisplay->VBLANKUpdateOverlayWidth = VBLANKUpdateOverlayWidth;
    pThisDisplay->VBLANKUpdateOverlayHeight = VBLANKUpdateOverlayHeight;

#if DBG
    // Read in the registry variable for the debug level
    {
        // Get the Debuglevel for DirectX
        bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.Debug", &dwResult);
        if (bRet == TRUE)
        {
            P3R3DX_DebugLevel = (LONG)dwResult;
        }
        else
        {
            P3R3DX_DebugLevel = 0;
        }

        DISPDBG((WRNLVL,"Setting DebugLevel to 0x%x", P3R3DX_DebugLevel));
    }
#endif

    // Create context with >2 sub-buffers for Interupt driven DMA.
    bRet =GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.SubBuffers", &dwResult);
    if ((dwResult == 0) || (bRet == FALSE))
    {
        // Default
        Buffers = DEFAULT_SUBBUFFERS;
    }
    else 
    {
        if (dwResult > MAX_SUBBUFFERS) 
        {
            Buffers = MAX_SUBBUFFERS;
        }
        else
        {
            Buffers = dwResult;
        }
        
        if (Buffers < 2)
        {
            Buffers = 2;
        }
    }

    pThisDisplay->pGLInfo->dw3DDMABufferSize = 0;
    pThisDisplay->pGLInfo->dw3DDMABufferPhys = 0;
    pThisDisplay->pGLInfo->dw3DDMABufferVirt = 0;

    // Allocate a DMA Buffer on Win2K
    DDGetFreeDMABuffer(&pThisDisplay->pGLInfo->dw3DDMABufferPhys,
                       &pThisDisplay->pGLInfo->dw3DDMABufferVirt,
                       &pThisDisplay->pGLInfo->dw3DDMABufferSize);

    if (pThisDisplay->pGLInfo->dw3DDMABufferSize != 0)
    {
        DISPDBG((DBGLVL,"Allocated DMA Buffer:- "
                        "Phys:0x%x, Virt:0x%x, Size:0x%x",
                        pThisDisplay->pGLInfo->dw3DDMABufferPhys,
                        pThisDisplay->pGLInfo->dw3DDMABufferVirt,
                        pThisDisplay->pGLInfo->dw3DDMABufferSize));
    }
    else
    {
        DISPDBG((WRNLVL,"Failed to allocate DMA Buffer!"));
    }

    if(ppdev->DDContextID == -1)
    {
        // we don't have a DDraw context: create one now
        ppdev->DDContextID = GlintAllocateNewContext(ppdev, 
                                                     NULL, 
                                                     0, 
                                                     Buffers, 
                                                     NULL, 
                                                     ContextType_None);
        if(ppdev->DDContextID != -1)
        {
            ++ppdev->DDContextRefCount;
            
            DISPDBG((DBGLVL, "<%13s, %4d>: DrvEnableDirectDraw: "
                             "Created DDraw context, current DX context "
                             "count = %d for ppdev %p", 
                             __FILE__, __LINE__, 
                             ppdev->DDContextRefCount, ppdev));
        }
    }
    
    if (ppdev->DDContextID < 0) 
    {
        DISPDBG((ERRLVL, "ERROR: failed to allocate DDRAW context"));
        return(FALSE);
    }
    
    DISPDBG((DBGLVL,"  Created DD Register context: 0x%x", 
                    ppdev->DDContextID));

    if (!__DDE_bSetupDDStructs (pThisDisplay, TRUE))
    {
        vGlintFreeContext (ppdev, ppdev->DDContextID);
        DISPDBG((ERRLVL, "ERROR: DrvEnableDirectDraw: "
                         "__DDE_bSetupDDStructs failed"));
        return (FALSE);
    }
    
    if (!_DD_InitDDHAL32Bit (pThisDisplay))
    {
        vGlintFreeContext (ppdev, ppdev->DDContextID);
        DISPDBG((ERRLVL, "ERROR: DrvEnableDirectDraw: "
                         "_DD_InitDDHAL32Bit failed"));
        return (FALSE);
    }
    
    // Set the flag that says we have to handle a mode change.
    // This will cause the chip to be initialised properly at the 
    // right time.
    pThisDisplay->bResetMode = TRUE;
    pThisDisplay->bStartOfDay = TRUE;
    pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_UNKNOWN;

    // Fill in the function pointers at start of day.  We copy these from 
    // the Initialisation done in _DD_InitDDHAL32Bit.  It's OK to do this 
    // because on a Windows NT compile the structures should match
    memcpy(pCallBacks, 
           &pThisDisplay->DDHALCallbacks, 
           sizeof(DD_CALLBACKS));
           
    memcpy(pSurfaceCallBacks, 
           &pThisDisplay->DDSurfCallbacks, 
           sizeof(DD_SURFACECALLBACKS));

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    return(TRUE);
    
} // DrvEnableDirectDraw

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DrvDisableDirectDraw
//
// Disables hardware for DirectDraw use.
//
// GDI calls DrvDisableDirectDraw when the last DirectDraw application has 
// finished running. A driver's DrvDisableDirectDraw implementation should 
// clean up any software resources and reclaim any hardware resources that 
// the driver dedicated to DirectDraw in DrvEnableDirectDraw.
//
// Parameters
//      dhpdev 
//          Handle to the PDEV that was returned by the driver's 
//          DrvEnablePDEV routine. 
//
//-----------------------------------------------------------------------------
VOID 
DrvDisableDirectDraw(
    DHPDEV      dhpdev)
{
    PDEV* ppdev;
    P3_THUNKEDDATA* pThisDisplay;

    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    // Only do all this stuff if we have not already been disabled.
    // Note that when running NT4 without SP3, this function can be called
    // more times than DrvEnableDirectDraw.
    if (pThisDisplay != NULL)
    {
        // Re-enable GDI off-screen bitmaps
        (void) bSetupOffscreenForDDraw (TRUE, 
                                        ppdev, 
                                        NULL, 
                                        NULL, 
                                        NULL, 
                                        NULL, 
                                        NULL);

        // Free all memory
        (void) __DDE_bDestroyDDStructs (pThisDisplay);

        if(ppdev->DDContextRefCount > 0)
        {
            if(--ppdev->DDContextRefCount == 0)
            {
                vGlintFreeContext (ppdev, ppdev->DDContextID);
                DISPDBG((DBGLVL,"Freed DDraw context: 0x%x", 
                                ppdev->DDContextID));
                                
                ppdev->DDContextID = -1;

                DISPDBG((DBGLVL, "<%13s, %4d>: DrvDisableDirectDraw:"
                                 " Deleted DDraw context, current DX context"
                                 " count = %d for ppdev %p", 
                                 __FILE__, __LINE__, 
                                 ppdev->DDContextRefCount, ppdev));
            }
        }

        DDFreeDMABuffer((void*)(ULONG_PTR)pThisDisplay->pGLInfo->dw3DDMABufferPhys);

    }
} // DrvDisableDirectDraw

#endif  //  WNT_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddover.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ddover.h
*
* Content: DirectDraw Overlays implementation macros and definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation
\**************************************************************************/

#ifndef __DDOVER_H
#define __DDOVER_H

// For setting up the VideoPort HAL
#define VIDEOPORT_NUM_CONNECT_INFO       8
#define VIDEOPORT_MAX_FIELD_HEIGHT   0x800
#define VIDEOPORT_MAX_FIELD_WIDTH    0x800
#define VIDEOPORT_MAX_VBI_WIDTH      0x800

#define VIDEOPORT_HREF_ACTIVE_HIGH          1
#define VIDEOPORT_VREF_ACTIVE_HIGH          2


// Defines for VideoOverlay values.
#define VO_ENABLE           1
#define VO_DISABLE          0

#define VO_MIRROR_X         1
#define VO_MIRROR_Y         1

#define VO_COLOR_ORDER_RGB  1
#define VO_COLOR_ORDER_BGR  0

#define VO_YUV_RGB          0
#define VO_YUV_422          1
#define VO_YUV_444          2

#define VO_CF_RGB8888       0
#define VO_CF_RGB4444       1
#define VO_CF_RGB5551       2
#define VO_CF_RGB565        3
#define VO_CF_RGB332        4
#define VO_CF_RGBCI8        5

#define VO_PIXEL_SIZE8      0
#define VO_PIXEL_SIZE16     1
#define VO_PIXEL_SIZE32     2

#define VO_MODE_MAINKEY     0
#define VO_MODE_OVERLAYKEY  1
#define VO_MODE_ALWAYS      2
#define VO_MODE_BLEND       3

#define VO_BLENDSRC_MAIN        0
#define VO_BLENDSRC_REGISTER    1

#define VO_KEY_COLOR            0
#define VO_KEY_ALPHA            1
 
#define VO_MEMTYPE_FRAMEBUFFER  (0 << 30)
#define VO_MEMTYPE_LOCALBUFFER  (1 << 30)

typedef struct tagVideoOverlayModeReg
{
    DWORD Enable                : 1;    // lsb
    DWORD BufferSync            : 3;
    DWORD FieldPolarity         : 1;
    DWORD PixelSize             : 2;
    DWORD ColorFormat           : 3;
    DWORD YUV                   : 2;
    DWORD ColorOrder            : 1;
    DWORD LinearColorExtension  : 1;
    DWORD Filter                : 2;
    DWORD DeInterlace           : 2;
    DWORD PatchMode             : 2;
    DWORD Flip                  : 3;
    DWORD MirrorX               : 1;
    DWORD MirrorY               : 1;
    DWORD Reserved1             : 7;
} VideoOverlayModeReg;

typedef struct tagRDVideoOverlayControlReg
{
    BYTE Enable                 : 1;
    BYTE Mode                   : 2;
    BYTE DirectColor            : 1;
    BYTE BlendSrc               : 1;
    BYTE Key                    : 1;
    BYTE Reserved               : 2;
} RDVideoOverlayControlReg;

#define __GP_VIDEO_ENABLE 0x0001

#if WNT_DDRAW

    #define FORCED_IN_ORDER_WRITE(target,value) *((volatile ULONG *)(target)) = (value)
    
    #define UPDATE_OVERLAY(pThisDisplay, bWaitForVSync, bUpdateOverlaySize)                     \
        do                                                                                      \
        {                                                                                       \
            if (pThisDisplay->pGLInfo->dwFlags & GMVF_VBLANK_ENABLED)                           \
            {                                                                                   \
                FORCED_IN_ORDER_WRITE ( pThisDisplay->bVBLANKUpdateOverlay, TRUE );             \
            }                                                                                   \
            else                                                                                \
            {                                                                                   \
                if (bWaitForVSync)                                                              \
                {                                                                               \
                    if (READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE)                  \
                                                                                                \
                    {                                                                           \
                        /* only wait for vblank if the monitor is on */                         \
                        LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET);                         \
                        while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);       \
                    }                                                                           \
                }                                                                               \
                                                                                                \
                if (bUpdateOverlaySize)                                                                 \
                {                                                                                       \
                    DWORD dwVideoOverlayMode = READ_GLINT_CTRL_REG(VideoOverlayMode);                   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, (dwVideoOverlayMode & 0xfffffffe));           \
                    LOAD_GLINT_CTRL_REG(VideoOverlayWidth,  *pThisDisplay->VBLANKUpdateOverlayWidth);   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayHeight, *pThisDisplay->VBLANKUpdateOverlayHeight);  \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwVideoOverlayMode);                          \
                }                                                                                       \
                                                                                                \
                LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);                             \
            }                                                                                   \
        }                                                                                       \
        while(0)

#else

    static ULONG volatile *vpdwTemp;

    // A macro to help me - I always get the volatile syntax wrong.
    #define FORCED_IN_ORDER_WRITE(target,value) vpdwTemp = &(target); *vpdwTemp = (value)

    #define UPDATE_OVERLAY(pThisDisplay, bWaitForVSync, bUpdateOverlaySize)                     \
        do                                                                                      \
        {                                                                                       \
            if (pThisDisplay->pGLInfo->dwFlags & GMVF_VBLANK_ENABLED)                           \
            {                                                                                   \
                FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->bVBLANKUpdateOverlay, TRUE );    \
            }                                                                                   \
            else                                                                                \
            {                                                                                   \
                if ((READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE) && (bWaitForVSync)) \
                {                                                                               \
                    /* only wait for vblank if the monitor is on */                             \
                    LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET);                             \
                    while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);           \
                }                                                                               \
                                                                                                \
                if (bUpdateOverlaySize)                                                                         \
                {                                                                                               \
                    DWORD dwVideoOverlayMode = READ_GLINT_CTRL_REG(VideoOverlayMode);                           \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, (dwVideoOverlayMode & 0xfffffffe));                   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayWidth, pThisDisplay->pGLInfo->VBLANKUpdateOverlayWidth);    \
                    LOAD_GLINT_CTRL_REG(VideoOverlayHeight, pThisDisplay->pGLInfo->VBLANKUpdateOverlayHeight);  \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwVideoOverlayMode);                                  \
                }                                                                                               \
                                                                                                \
                LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);                             \
            }                                                                                   \
        }                                                                                       \
        while(0)

#endif

#endif // __DDOVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\direct3d.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: direct3d.h
*
* Content: Global direct3d definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef __DIRECT3D_H
#define __DIRECT3D_H

#include "directx.h"

// ************************ Auxiliary D3D declarations ************************

// We define this here because DX7 headers don't have it
#ifndef D3DTSS_MAX
#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)29)
#endif

#ifndef D3DHAL_TSS_MAXSTAGES
#define D3DHAL_TSS_MAXSTAGES 8
#endif

#if DX8_DDI      
// In DX8 D3DTSS_ADDRESS is obsolete, but we need it for DX7 apps that call us
#define D3DTSS_ADDRESS      12
#endif   

// *********************** Helper function declarations ***********************

typedef struct _p3_d3dcontext P3_D3DCONTEXT;
typedef struct _p3_SURF_INTERNAL P3_SURF_INTERNAL;

// Initialization functions
void _D3DHALCreateDriver(struct tagThunkedData* pThisDisplay);
void _D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

// Primitives renderers

extern void _D3D_R3_PickVertexProcessor( P3_D3DCONTEXT *pC );

typedef void R3_DP2_PRIM_TYPE( P3_D3DCONTEXT *, 
                               DWORD, 
                               LPBYTE, 
                               LPD3DTLVERTEX, 
                               DWORD, 
                               BOOL *);

typedef R3_DP2_PRIM_TYPE *PFNP3TRI;                              

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_Points;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_Points_DWCount;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineListImm;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineList2;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFan;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFanImm;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleList2;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleFan;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleStrip;

#if DX8_POINTSPRITES

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleListPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFanPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleStripPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_PointsSprite_DWCount;

#endif //DX8_POINTSPRITES

#if DX8_MULTSTREAMS
typedef void R3_DP2_PRIM_TYPE_MS( P3_D3DCONTEXT *, 
                                  DWORD, 
                                  LPBYTE, 
                                  LPD3DTLVERTEX, 
                                  INT,
                                  DWORD, 
                                  BOOL *);

extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineList_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineStrip_MS_16IND; 
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleList_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleFan_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineList_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineStrip_MS_32IND;   
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleList_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleFan_MS_32IND;
#endif // DX8_MULTSTREAMS

// Texture functions
void _D3DChangeTextureP3RX(P3_D3DCONTEXT* pContext);
                         
void _D3D_TXT_ParseTextureStageStates(struct _p3_d3dcontext* pContext, 
                                 D3DHAL_DP2TEXTURESTAGESTATE* pState, 
                                 DWORD dwCount,
                                 BOOL bTranslateDX8FilterValueToDX6);

void _D3D_SU_SurfInternalSetMipMapLevelData(P3_THUNKEDDATA* pThisDisplay, 
                                            struct _p3_SURF_INTERNAL* pTexture,
                                            LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
                                            int LOD);
                                                 
// D3D Context Functions
VOID _D3D_CTX_HandleInitialization(VOID);
P3_D3DCONTEXT* _D3D_CTX_HandleToPtr(ULONG_PTR hHandle);

// Rendering State Functions                            
DWORD _D3D_ST_ProcessRenderStates(P3_D3DCONTEXT* pContext, 
                                  DWORD dwStateCount, 
                                  D3DSTATE *pState, 
                                  BOOL bDoOverride);

DWORD _D3D_ST_ProcessOneRenderState(P3_D3DCONTEXT* pContext, 
                                    DWORD dwRSType,
                                    DWORD dwRSVal);
                              
BOOL _D3D_ST_RealizeHWStateChanges(P3_D3DCONTEXT* pContext);                              
BOOL _D3D_ST_CanRenderAntialiased(P3_D3DCONTEXT* pContext,
                                  BOOL bNewAliasBuffer);

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
// Functions for handling vertex/execute/command buffers

void _D3D_EB_FlushAllBuffers(P3_THUNKEDDATA* pThisDisplay, BOOL bWait);

void
_D3D_EB_GetAndWaitForBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO** ppVertexBufferInfo,
    P3_VERTEXBUFFERINFO** ppCommandBufferInfo);       
    
void
_D3D_EB_UpdateSwapBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO* pVertexBufferInfo,
    P3_VERTEXBUFFERINFO* pCommandBufferInfo);
#endif //DX7_VERTEXBUFFERS 
//@@END_DDKSPLIT

// D3D Surfaces
HRESULT _D3D_SU_SurfInternalSetDataRecursive(P3_THUNKEDDATA* pThisDisplay,
                                             PointerArray* pSurfaceArray,
                                             LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                                             LPDDRAWI_DDRAWSURFACE_LCL pRootDDSurfLcl,
                                             LPDDRAWI_DDRAWSURFACE_LCL pCurDDSurfLcl);
BOOL _D3D_SU_SurfInternalSetData(P3_THUNKEDDATA* pThisDisplay, 
                                 P3_SURF_INTERNAL *pSurface,
                                 LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                 DWORD dwSurfaceHandle);
void 
_D3D_SU_DumpSurfInternal(DWORD lvl,
                         char *psHeader,
                         P3_SURF_INTERNAL *pSurface);

// State blocks management functions
void _D3D_SB_DeleteAllStateSets(P3_D3DCONTEXT* pContext);
void _D3D_SB_BeginStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_EndStateSet(P3_D3DCONTEXT* pContext);
void _D3D_SB_DeleteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_ExecuteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_CaptureStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_RecordStateSetRS(P3_D3DCONTEXT* pContext, 
                              DWORD dwRSType, 
                              DWORD dwRSVal);
void _D3D_SB_RecordStateSetTSS(P3_D3DCONTEXT* pContext, 
                               DWORD dwTSStage, 
                               DWORD dwTSState,
                               DWORD dwTSVal);
void _D3D_SB_Record_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                                     DWORD dwVtxShaderHandle);
void _D3D_SB_Record_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                                    DWORD dwStream,
                                    DWORD dwVBHandle,
                                    DWORD dwStride);
void _D3D_SB_Record_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                       DWORD dwVBHandle,
                                       DWORD dwStride);
void _D3D_SB_Record_Viewport(P3_D3DCONTEXT* pContext,
                             D3DHAL_DP2VIEWPORTINFO* lpvp);
VOID _D3D_SB_Record_ZRange(P3_D3DCONTEXT* pContext,
                           D3DHAL_DP2ZRANGE* lpzr);                          

// D3D Command Buffer Operations

HRESULT _D3D_OP_SetRenderTarget(P3_D3DCONTEXT* pContext, 
                                P3_SURF_INTERNAL* pRender, 
                                P3_SURF_INTERNAL* pZBuffer,
                                BOOL bNewAliasBuffers);  

VOID _D3D_OP_SceneCapture(P3_D3DCONTEXT *pContext,
                          DWORD dwFlag);                           

VOID _D3D_OP_Viewport(P3_D3DCONTEXT* pContext,
                      D3DHAL_DP2VIEWPORTINFO* lpvp);

VOID _D3D_OP_ZRange(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2ZRANGE* lpzr);

VOID _D3D_OP_Clear2(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2CLEAR* lpcd2,
                    DWORD dwNumRects);

VOID _D3D_OP_TextureBlt(P3_D3DCONTEXT* pContext, 
                        P3_THUNKEDDATA* pThisDisplay,
                        D3DHAL_DP2TEXBLT* pBlt);

HRESULT _D3D_OP_UpdatePalette(P3_D3DCONTEXT* pContext,
                              D3DHAL_DP2UPDATEPALETTE* pUpdatePalette,
                              DWORD* pdwPalEntries);

HRESULT _D3D_OP_SetPalettes(P3_D3DCONTEXT* pContext,
                            D3DHAL_DP2SETPALETTE* pSetPalettes,
                            int iNumSetPalettes);
                        

#if DX7_TEXMANAGEMENT
VOID _D3D_OP_SetTexLod(P3_D3DCONTEXT *pContext,
                       D3DHAL_DP2SETTEXLOD* pSetTexLod);

VOID _D3D_OP_SetPriority(P3_D3DCONTEXT *pContext,
                        D3DHAL_DP2SETPRIORITY* pSetPriority);

#if DX8_DDI
VOID _D3D_OP_AddDirtyRect(P3_D3DCONTEXT *pContext,
                          D3DHAL_DP2ADDDIRTYRECT* pAddDirtyRect);
                          
VOID _D3D_OP_AddDirtyBox(P3_D3DCONTEXT *pContext,
                         D3DHAL_DP2ADDDIRTYBOX* pAddDirtyBox);
#endif
#endif // DX7_TEXMANAGEMENT

#if DX8_3DTEXTURES
VOID _D3D_OP_VolumeBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2VOLUMEBLT* pBlt);
#endif // DX8_3DTEXTURES

#if DX8_DDI   
VOID _D3D_OP_BufferBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2BUFFERBLT* pBlt); 
#endif // DX8_DDI                       

#if DX8_VERTEXSHADERS
HRESULT _D3D_OP_VertexShader_Create(P3_D3DCONTEXT* pContext, 
                                    DWORD dwVtxShaderHandle,
                                    DWORD dwDeclSize, 
                                    DWORD dwCodeSize,
                                    BYTE *pShader);
VOID _D3D_OP_VertexShader_Delete(P3_D3DCONTEXT* pContext, 
                                 DWORD dwVtxShaderHandle);
VOID _D3D_OP_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                              DWORD dwVtxShaderHandle);
VOID _D3D_OP_VertexShader_SetConst(P3_D3DCONTEXT* pContext, 
                                   DWORD dwRegister, 
                                   DWORD dwValue, 
                                   DWORD *pdwValues);
#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS
HRESULT _D3D_OP_PixelShader_Create(P3_D3DCONTEXT* pContext, 
                                   DWORD dwPxlShaderHandle,
                                   DWORD dwCodeSize, 
                                   BYTE *pShader);
VOID _D3D_OP_PixelShader_Delete(P3_D3DCONTEXT* pContext, 
                                DWORD dwPxlShaderHandle);
VOID _D3D_OP_PixelShader_Set(P3_D3DCONTEXT* pContext, 
                             DWORD dwPxlShaderHandle);
VOID _D3D_OP_PixelShader_SetConst(P3_D3DCONTEXT* pContext, 
                                  DWORD dwRegister, 
                                  DWORD dwCount, 
                                  DWORD *pdwValues);
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS
VOID _D3D_OP_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                            DWORD dwStream, 
                            DWORD dwVBHandle, 
                            DWORD dwStride);
VOID _D3D_OP_MStream_SetSrcUM(P3_D3DCONTEXT* pContext, 
                               DWORD dwStream, 
                               DWORD dwStride,
                               LPBYTE pUMVtx,
                               DWORD  dwVBSize);
VOID _D3D_OP_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                DWORD dwVBHandle, 
                                DWORD dwStride);
VOID _D3D_OP_MStream_DrawPrim(P3_D3DCONTEXT* pContext, 
                              D3DPRIMITIVETYPE primType, 
                              DWORD VStart, 
                              DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawIndxP(P3_D3DCONTEXT* pContext, 
                               D3DPRIMITIVETYPE primType, 
                               DWORD BaseVertexIndex, 
                               DWORD MinIndex, 
                               DWORD NumVertices, 
                               DWORD StartIndex,                   
                               DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawPrim2(P3_D3DCONTEXT* pContext, 
                               D3DPRIMITIVETYPE primType, 
                               DWORD FirstVertexOffset, 
                               DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawIndxP2(P3_D3DCONTEXT* pContext, 
                                D3DPRIMITIVETYPE primType, 
                                INT   BaseVertexOffset, 
                                DWORD MinIndex, 
                                DWORD NumVertices, 
                                DWORD StartIndexOffset, 
                                DWORD PrimitiveCount);

VOID _D3D_OP_MStream_ClipTriFan(P3_D3DCONTEXT* pContext, 
                                DWORD FirstVertexOffset, 
                                DWORD dwEdgeFlags, 
                                DWORD PrimitiveCount);

VOID _D3D_OP_MStream_DrawRectSurface(P3_D3DCONTEXT* pContext, 
                                     DWORD Handle,
                                     DWORD Flags,
                                     PVOID lpPrim);
                                     
VOID _D3D_OP_MStream_DrawTriSurface(P3_D3DCONTEXT* pContext, 
                                    DWORD Handle,
                                    DWORD Flags,
                                    PVOID lpPrim);                                                                      
#endif // DX8_MULTSTREAMS


// Other
void _D3DDisplayWholeTSSPipe ( P3_D3DCONTEXT* pContext, int iDebugNumber );

// ************************** D3D HAL Callbacks ********************************


DWORD CALLBACK D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA lpcsxd );
DWORD CALLBACK D3DDestroyDDLocal(LPDDHAL_DESTROYDDLOCALDATA pddl);

DWORD CALLBACK D3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd);
DWORD CALLBACK D3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pccd);

DWORD CALLBACK D3DDrawPrimitives2_P3( LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d );
DWORD CALLBACK D3DValidateDeviceP3( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd);
DWORD CALLBACK D3DGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGS);

DWORD CALLBACK D3DCanCreateD3DBuffer(LPDDHAL_CANCREATESURFACEDATA pccsd);
DWORD CALLBACK D3DCreateD3DBuffer(LPDDHAL_CREATESURFACEDATA pcsd);
DWORD CALLBACK D3DDestroyD3DBuffer(LPDDHAL_DESTROYSURFACEDATA pdd);
DWORD CALLBACK D3DLockD3DBuffer(LPDDHAL_LOCKDATA pld);
DWORD CALLBACK D3DUnlockD3DBuffer(LPDDHAL_UNLOCKDATA puld);

#endif // __DIRECT3D_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddvideo.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddvideo.c
*
* Content: DirectDraw Videoports implementation
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "tag.h"
//#include <mmsystem.h>
#include "dma.h"

//@@BEGIN_DDKSPLIT
#ifdef W95_DDRAW_VIDEO

// Define P3R3DX_VIDEO to allow use of 32bit Macros in ramdac.h
#define P3R3DX_VIDEO 1
#include "ramdac.h"

#include <dvp.h>

extern DWORD CALLBACK __VD_AutoflipOverlay ( void );
extern DWORD CALLBACK __VD_AutoupdateOverlay ( void );

#if 0
#define P2_VIDPORT_WIDTH 768
#define P2_VIDPORT_HEIGHT 288
#endif

// how many DrawOverlay calls to wait after an UpdateOverlay()
// generally 1
#define OVERLAY_UPDATE_WAIT 1
// how many DrawOverlay calls to wait after a SetPosition()
// generally 1
#define OVERLAY_SETPOS_WAIT 1
// how many DrawOverlay calls  between repaints (0=no repaints)
// generally 5-15
#define OVERLAY_CYCLE_WAIT 15
// How many "DrawOverlay calls" a speedy DrawOverlay is worth.
// Generally 1
#define OVERLAY_DRAWOVERLAY_SPEED 1
// How many "DrawOverlay calls" a pretty DrawOverlay is worth.
// Generally the same as OVERLAY_CYCLE_WAIT, or 1 if it is 0.
#define OVERLAY_DRAWOVERLAY_PRETTY 15

// How long in milliseconds to wait for the videoport before timing out.
#define OVERLAY_VIDEO_PORT_TIMEOUT 100


static BOOL g_bFlipVideoPortDoingAutoflip = FALSE;


//-----------------------------------------------------------------------------
//
// __VD_PixelOffsetFromMemoryBase
//
// Calculates the offset from the memory base as the chip sees it.  This is 
// relative to the base address in the chip and is in pixels
//
//-----------------------------------------------------------------------------
long __inline 
__VD_PixelOffsetFromMemoryBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    DWORD lOffset;

    lOffset = DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pLcl);

    // Work out pixel offset into the framestore
    if (DDSurf_BitDepth(pLcl) == 24)
    {
        lOffset = lOffset / 3;
    }
    else
    {
        lOffset = lOffset >> DDSurf_GetPixelShift(pLcl);
    }
    return lOffset;
} // __VD_PixelOffsetFromMemoryBase

// Debug function to dump a video port description
#if DBG
//-----------------------------------------------------------------------------
//
// __VD_FillYUVSurface
//
//-----------------------------------------------------------------------------
static void 
__VD_FillYUVSurface(
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl, 
    DWORD Value)
{
    BYTE* pCurrentLine = (BYTE*)lpLcl->lpGbl->fpVidMem;
    WORD x, y;
    WORD* pSurface;
    WORD CurrentColor = (WORD)(Value & 0xFFFF);
    
    for (y = 0; y < lpLcl->lpGbl->wHeight; y++)
    {
        pSurface = (WORD*)pCurrentLine;
        for (x = 0; x < lpLcl->lpGbl->wWidth; x++)
        {
            // YUV Surface is 16Bits
            *pSurface++ = CurrentColor;
        }
        pCurrentLine += lpLcl->lpGbl->lPitch;
        if ((pCurrentLine - (31 << 1)) <= (BYTE*)pSurface)
        {
            while (pSurface++ < (WORD*)pCurrentLine)
            {
                *pSurface = 0xFFFF;
            }
        }
    }
} // __VD_FillYUVSurface

//-----------------------------------------------------------------------------
//
// __VD_DumpVPDesc
//
//-----------------------------------------------------------------------------
static void 
__VD_DumpVPDesc(
    int Level, 
    DDVIDEOPORTDESC vp)
{
    
#define CONNECT_REPORT(param)                               \
        if (vp.VideoPortType.dwFlags & DDVPCONNECT_##param) \
        {                                                   \
            DISPDBG((Level, "   " #param));                 \
        }


    DISPDBG((Level,"Port Size:  %d x %d", vp.dwFieldWidth, vp.dwFieldHeight));
    DISPDBG((Level,"VBI Width:  %d", vp.dwVBIWidth));
    DISPDBG((Level,"uS/Field:   %d", vp.dwMicrosecondsPerField));
    DISPDBG((Level,"Pixels/Sec: %d", vp.dwMaxPixelsPerSecond));
    DISPDBG((Level,"Port ID:    %d", vp.dwVideoPortID));
    DISPDBG((Level,"Flags: "));

    CONNECT_REPORT(INTERLACED);
    CONNECT_REPORT(VACT);
    CONNECT_REPORT(INVERTPOLARITY);
    CONNECT_REPORT(DOUBLECLOCK);
    CONNECT_REPORT(DISCARDSVREFDATA);
    CONNECT_REPORT(HALFLINE);
    CONNECT_REPORT(SHAREEVEN);
    CONNECT_REPORT(SHAREODD);

    DISPDBG((Level,"Connection GUID:"));
    if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFH))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFH_VREFH"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFL))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFH_VREFL"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFH))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFL_VREFH"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFL))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFL_VREFL"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_CCIR656))
    {
        DISPDBG((Level, "  CCIR656"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_BROOKTREE))
    {
        DISPDBG((Level, "  BROOKTREE"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_PHILIPS))
    {
        DISPDBG((Level, "  PHILIPS"));
    }
    else
    {
        DISPDBG((ERRLVL,"  ERROR: Unknown connection type!"));
    }

} // __VD_DumpVPDesc

#define DUMPVPORT(a, b) __VD_DumpVPDesc(a, b);
#define FILLYUV(a, c) __VD_FillYUVSurface(a, c);

#else

#define DUMPVPORT(a, b)
#define FILLYUV(a, c)

#endif

//-----------------------------------------------------------------------------
//
// __VD_CheckVideoPortStatus
//
// Checks to see if the videoport seems to be OK.  If it is, 
// we return TRUE.  if bWait is set then we hang around and
// try to decide if the Video is OK.
//
//-----------------------------------------------------------------------------
#define ERROR_TIMOUT_VP 470000
#define ERROR_TIMOUT_COUNT 50

BOOL 
__VD_CheckVideoPortStatus(
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL bWait)
{
    DWORD dwMClock;
    DWORD dwCurrentLine;
    DWORD dwCurrentIndex;
    DWORD dwNewLine;
    DWORD dwNewMClock;

    // Is the videoport on?
    if (!pThisDisplay->VidPort.bActive) return FALSE;

    // Read the current MClock
    dwMClock = READ_GLINT_CTRL_REG(MClkCount);

    if (bWait) pThisDisplay->VidPort.bResetStatus = TRUE;

    if (pThisDisplay->VidPort.bResetStatus)
    {
        dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
        dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);

        // At start of day, record the MClock time for the start of the line
        pThisDisplay->VidPort.dwStartLineTime = dwMClock;
        
        // Also record the starting line
        pThisDisplay->VidPort.dwStartLine = dwCurrentLine;
        pThisDisplay->VidPort.dwStartIndex = dwCurrentIndex;

        pThisDisplay->VidPort.bResetStatus = FALSE;
        return TRUE;
    }

    if (bWait)
    {
        do
        {
            // Read the current line
            dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);

            // OK, a line of video should take approx:
            // 1 Second / 50-60 fields/second / 300 lines = 
            // 0.000066 = 66uS.
            // If the MClock is running at, say 70Mhz that is 0.000000014 seconds/clock
            // So a line should take 0.000066 / 0.000000014 MClocks = ~4700 MClocks
            
            // Wait for 100 times longer than it should take to draw a line....
            do
            {
                dwNewMClock = READ_GLINT_CTRL_REG(MClkCount);
            } while (dwNewMClock < (dwMClock + ERROR_TIMOUT_VP));

            dwNewLine = READ_GLINT_CTRL_REG(VSACurrentLine);

            // Has the line count advanced?
            if (dwNewLine == dwCurrentLine)
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (dwCurrentIndex == pThisDisplay->VidPort.dwStartIndex)
                {
                    // Disable the videoport if the error count goes to high
                    pThisDisplay->VidPort.dwErrorCount++;

                    // Reset the status as we need to make sure the timer restarts.
                    pThisDisplay->VidPort.bResetStatus = TRUE;

                    if (pThisDisplay->VidPort.dwErrorCount > ERROR_TIMOUT_COUNT)
                    {
                        DISPDBG((WRNLVL,"StartLine: %d, CurrentLine: %d, StartIndex: %d, CurrentIndex: %d", pThisDisplay->VidPort.dwStartLine,
                                                            dwCurrentLine, pThisDisplay->VidPort.dwStartIndex, dwCurrentIndex));
                        DISPDBG((ERRLVL,"ERROR: VideoStream not working!"));
                        pThisDisplay->VidPort.bActive = FALSE;
                        return FALSE;
                    }
                }
                else
                {
                    pThisDisplay->VidPort.dwErrorCount = 0;
                    pThisDisplay->VidPort.bResetStatus = TRUE;
                }
            }
            // If it has flag a reset and break
            else
            {
                pThisDisplay->VidPort.dwErrorCount = 0;
                pThisDisplay->VidPort.bResetStatus = TRUE;
            }

        } while (pThisDisplay->VidPort.dwErrorCount);
    }
    else
    {
        // Has the line count advanced?
        if (dwMClock > (pThisDisplay->VidPort.dwStartLineTime + ERROR_TIMOUT_VP))
        {
            dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
            if (pThisDisplay->VidPort.dwStartLine == dwCurrentLine)
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (dwCurrentIndex == pThisDisplay->VidPort.dwStartIndex)
                {
                    // Disable the videoport if the error count goes to high
                    pThisDisplay->VidPort.dwErrorCount++;

                    DISPDBG((WRNLVL,"ERROR: Timeout at %d", dwMClock));

                    // Reset the status as we need to make sure the timer restarts.
                    pThisDisplay->VidPort.bResetStatus = TRUE;

                    // Disable the videoport
                    if (pThisDisplay->VidPort.dwErrorCount > ERROR_TIMOUT_COUNT)
                    {
                        DISPDBG((WRNLVL,"StartLine: %d, CurrentLine: %d, StartIndex: %d, CurrentIndex: %d", pThisDisplay->VidPort.dwStartLine,
                                                            dwCurrentLine, pThisDisplay->VidPort.dwStartIndex, dwCurrentIndex));
                        DISPDBG((ERRLVL,"ERROR: VideoStream not working!"));
                        pThisDisplay->VidPort.bActive = FALSE;
                    }
                }
                else
                {
                    pThisDisplay->VidPort.dwErrorCount = 0;
                    pThisDisplay->VidPort.bResetStatus = TRUE;
                }
            }
            else
            {
                // Reset the error status
                pThisDisplay->VidPort.dwErrorCount = 0;
                pThisDisplay->VidPort.bResetStatus = TRUE;
            }
        }
    }

    return pThisDisplay->VidPort.bActive;
    
} // __VD_CheckVideoPortStatus

//-----------------------------------------------------------------------------
//
// DdUpdateVideoPort
//
// This required function sets up the video port
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateVideoPort (
    LPDDHAL_UPDATEVPORTDATA pInput)
{
    DWORD i;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentDisplay;
    DWORD dwLineScale;
    DWORD dwEnable;
    DWORD dwDiscard;
    DWORD XScale = 0;
    DWORD YScale = 0;
    VMIREQUEST In;
    VMIREQUEST Out;
    DWORD dwSrcPixelWidth;
    DWORD dwSrcHeight;
    DWORD dwDstPixelWidth;
    DWORD dwDstHeight;

    StreamsRegister_Settings PortSettings;
    StreamsRegister_VSPartialConfigA VSPartialA;


    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdUpdateVideoPort, dwFlags = %d", pInput->dwFlags));

    DUMPVPORT(DBGLVL ,pInput->lpVideoPort->ddvpDesc);

    pThisDisplay->pGLInfo->dwVSACaughtFrames = 0;
    pThisDisplay->pGLInfo->dwVSADroppedFrames = 0;
    pThisDisplay->pGLInfo->dwVSALastDropped = 0;

    if (pInput->dwFlags == DDRAWI_VPORTSTOP)
    {
        DISPDBG((DBGLVL,"  Stopping VideoPort"));

        // Stop any autoflipping.
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - VPORTSTOP - was autoflipping on bogus event handle."));
            }
            pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
            DISPDBG((DBGLVL,"** DdUpdateVideoPort - VPORTSTOP - autoflipping now disabled."));
        }

        WAIT_GLINT_FIFO(2);

        pThisDisplay->VidPort.bActive = FALSE;
        pThisDisplay->VidPort.bResetStatus = TRUE;
        pThisDisplay->VidPort.dwErrorCount = 0;

        pThisDisplay->VidPort.lpSurf[0] = NULL;
        pThisDisplay->VidPort.lpSurf[1] = NULL;
        pThisDisplay->VidPort.lpSurf[2] = NULL;

        // Disable the interrupt.
        dwEnable = READ_GLINT_CTRL_REG(IntEnable);
        dwEnable &= ~INTR_ENABLE_VIDSTREAM_A;
        LOAD_GLINT_REG(IntEnable, dwEnable);

        // Disable the videoport
        LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);
    }
    else if ((pInput->dwFlags == DDRAWI_VPORTSTART) ||
            (pInput->dwFlags == DDRAWI_VPORTUPDATE))
    {

        DISPDBG((DBGLVL,"  Starting/Updating VideoPort"));

        pThisDisplay->VidPort.lpSurf[0] = NULL;
        pThisDisplay->VidPort.lpSurf[1] = NULL;
        pThisDisplay->VidPort.lpSurf[2] = NULL;

        // Videoport only on P2's, therefore much more fifo room
        WAIT_GLINT_FIFO(100);

        // Disable the videoport so we can setup a new configuration
        LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);
        
        // How many surfaces do we have?
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP)
        {
            if (pInput->dwNumAutoflip == 0) pThisDisplay->VidPort.dwNumSurfaces = 1;
            else pThisDisplay->VidPort.dwNumSurfaces = pInput->dwNumAutoflip;

            DISPDBG((DBGLVL,"Surfaces passed in (AUTOFLIP) = %d", pThisDisplay->VidPort.dwNumSurfaces));

            for(i = 0; i < pThisDisplay->VidPort.dwNumSurfaces; i++)
            {
                LPDDRAWI_DDRAWSURFACE_LCL pLcl = (pInput->lplpDDSurface[i])->lpLcl;

                if (pLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
                {
                    DISPDBG((DBGLVL,"Surface %d is the FRONTBUFFER", i));
                    dwCurrentDisplay = i;
                }

                FILLYUV(pLcl, i * 0x4444);

                // Store away the offset to this surface
                pThisDisplay->VidPort.dwSurfacePointer[i] = pLcl->lpGbl->fpVidMem;
                pThisDisplay->VidPort.lpSurf[i] = pLcl;
            }

            // Start or continue any autoflipping.
#if DBG
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - trying to autoflipping using bogus event handle."));
            }
#endif
            if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL == 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodVideoVBL = OVERLAY_AUTOFLIP_PERIOD;
                pThisDisplay->pGLInfo->dwCountdownVideoVBL = OVERLAY_AUTOFLIP_PERIOD;
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - autoflipping now enabled."));
            }

        }
        else
        {
            LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf = (pInput->lplpDDSurface[0])->lpLcl;
            i = 0;

            // Stop any autoflipping.
            if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
            {
#if DBG
                if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
                {
                    DISPDBG((DBGLVL,"** DdUpdateVideoPort - was trying to autoflip using bogus event handle."));
                }
#endif
                pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
                pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - autoflipping now disabled."));
            }
        
            while (lpNextSurf != NULL)
            {
                if (lpNextSurf->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
                {
                    DISPDBG((DBGLVL,"Surface %d is the FRONTBUFFER", i));
                    dwCurrentDisplay = i;
                }

                // Store away the offset to this surface
                pThisDisplay->VidPort.dwSurfacePointer[i] = lpNextSurf->lpGbl->fpVidMem;
                pThisDisplay->VidPort.lpSurf[i] = lpNextSurf;

                FILLYUV(lpNextSurf, i * 0x4444);

                // Is there another surface in the chain?
                if (lpNextSurf->lpAttachList)
                {
                    lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                    if (lpNextSurf == NULL) break;
                }
                else break;

                // Have we spun around the loop?
                if (lpNextSurf == (pInput->lplpDDSurface[0])->lpLcl) break;

                i++;
            }

            pThisDisplay->VidPort.dwNumSurfaces = i + 1;
            DISPDBG((DBGLVL,"Surfaces passed in (Not AutoFlip) = %d", (i + 1)));
        }

        DISPDBG((DBGLVL,"  Addresses: 0x%x, 0x%x, 0x%x", 
                        pThisDisplay->VidPort.dwSurfacePointer[0], 
                        pThisDisplay->VidPort.dwSurfacePointer[1],
                        pThisDisplay->VidPort.dwSurfacePointer[2]));

                
        // Remember the size of the vertical blanking interval and the size of the frame.
        pThisDisplay->VidPort.dwFieldWidth = pInput->lpVideoPort->ddvpDesc.dwFieldWidth;
        pThisDisplay->VidPort.dwFieldHeight = pInput->lpVideoPort->ddvpDesc.dwFieldHeight;

        // Setup the Host register so that it points to the same surface we will display.
        pThisDisplay->VidPort.dwCurrentHostFrame = dwCurrentDisplay;

        dwSrcPixelWidth = (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) ?
                          (pInput->lpVideoInfo->rCrop.right - pInput->lpVideoInfo->rCrop.left) : 
                          pInput->lpVideoPort->ddvpDesc.dwFieldWidth; 

        dwSrcHeight = (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) ?
                      (pInput->lpVideoInfo->rCrop.bottom - pInput->lpVideoInfo->rCrop.top) :
                      pInput->lpVideoPort->ddvpDesc.dwFieldHeight;

        DISPDBG((DBGLVL,"Source Width: %d", dwSrcPixelWidth));
        DISPDBG((DBGLVL,"Source Height: %d", dwSrcHeight));

        // Do we need to prescale the surface?
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE)
        {
            DISPDBG((DBGLVL,"Prescale Width:%d, Height:%d", 
                            pInput->lpVideoInfo->dwPrescaleWidth,
                            pInput->lpVideoInfo->dwPrescaleHeight));

            if ((pInput->lpVideoInfo->dwPrescaleWidth != 0) &&
                (pInput->lpVideoInfo->dwPrescaleWidth != pInput->lpVideoPort->ddvpDesc.dwFieldWidth))
            {
                XScale =  pInput->lpVideoPort->ddvpDesc.dwFieldWidth / pInput->lpVideoInfo->dwPrescaleWidth;
                switch(XScale)
                {
                    case 2:
                        XScale = 1;
                        break;
                    case 4:
                        XScale = 2;
                        break;
                    case 8:
                        XScale = 3;
                        break;
                    default:
                        XScale = 0;
                        break;
                }
            }

            if ((pInput->lpVideoInfo->dwPrescaleHeight != 0) &&
                (pInput->lpVideoInfo->dwPrescaleHeight != pInput->lpVideoPort->ddvpDesc.dwFieldHeight))
            {   
                YScale = pInput->lpVideoPort->ddvpDesc.dwFieldHeight / pInput->lpVideoInfo->dwPrescaleHeight;
                switch(YScale)
                {
                    case 2:
                        YScale = 1;
                        break;
                    case 4:
                        YScale = 2;
                        break;
                    case 8:
                        YScale = 3;
                        break;
                    default:
                        YScale = 0;
                        break;
                }
            }

            // HACK! HACK!
            dwDstPixelWidth = pInput->lpVideoInfo->dwPrescaleWidth;
            dwDstHeight = pInput->lpVideoInfo->dwPrescaleHeight;
        }
        else
        {
            dwDstPixelWidth = dwSrcPixelWidth;
            dwDstHeight = dwSrcHeight;
        }

        DISPDBG((DBGLVL,"Dest Width: %d", dwDstPixelWidth));
        DISPDBG((DBGLVL,"Dest Height: %d", dwDstHeight));

        // Need to setup the registers differently if we are mirroring top to bottom
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN)
        {
            // Make sure we aren't prescaling...
            if (YScale == 0)
            {
                pThisDisplay->VidPort.dwSurfacePointer[0] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
                pThisDisplay->VidPort.dwSurfacePointer[1] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
                pThisDisplay->VidPort.dwSurfacePointer[2] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
            }
            else
            {
                pThisDisplay->VidPort.dwSurfacePointer[0] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
                pThisDisplay->VidPort.dwSurfacePointer[1] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
                pThisDisplay->VidPort.dwSurfacePointer[2] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
            }
        }

        if (pInput->lpVideoPort->ddvpDesc.VideoPortType.dwPortWidth == 8) dwLineScale = 0;
        else dwLineScale = 1;

        // Setup the configuration of the VideoPort
        // This is done by a call to the VXD as the registers that are touched have bits
        // that are shared with the TV Out and the ROM.
        // ***********************
        // UnitMode:    Typically setup for 8 or 16 bit YUV input port.
        // GPMode:      Not used.
        // HREF_POL_A:  Polarity active of HREF
        // VREF_POL_A:  Polarity active of VREF
        // VActive:     Wether the VACT signal is active high or low (if there is one).
        //              Can be set to the inverse of the HREF as a good guess(?)
        // UseField:    Stream A on or off
        // FieldPolA:   How to treat the field polarity of stream A
        // FieldEdgeA:
        // VActiveVBIA:
        // InterlaceA:  Interlaced data on A?
        // ReverseA:    Should we reverse the YUV data on A
        // ***********************
        
        PortSettings.UnitMode = ((pInput->lpVideoPort->ddvpDesc.VideoPortType.dwPortWidth == 8) ? STREAMS_MODE_STREAMA_STREAMB : STREAMS_MODE_STREAMA_WIDE16);
        In.dwSize = sizeof(VMIREQUEST);
        In.dwRegister = P2_VSSettings;
        In.dwCommand = *((DWORD*)(&PortSettings));
        In.dwDevNode = pThisDisplay->dwDevNode;
        In.dwOperation = GLINT_VMI_WRITE;
        VXDCommand(GLINT_VMI_COMMAND, &In, sizeof(VMIREQUEST), &Out, sizeof(VMIREQUEST));

        VSPartialA.HRefPolarityA = ((pThisDisplay->VidPort.dwStreamAFlags & VIDEOPORT_HREF_ACTIVE_HIGH) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        VSPartialA.VRefPolarityA = ((pThisDisplay->VidPort.dwStreamAFlags & VIDEOPORT_VREF_ACTIVE_HIGH) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        // There is no setting in DirectX for the polarity of the active signal.  Therefore we must assume one value.  This
        // has been chosen based on the setting that gives the correct effect for a Bt827/829
        VSPartialA.VActivePolarityA = __PERMEDIA_ENABLE;
        VSPartialA.UseFieldA = __PERMEDIA_DISABLE;
        VSPartialA.FieldPolarityA = ((pInput->lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        VSPartialA.FieldEdgeA = __PERMEDIA_DISABLE;
        VSPartialA.VActiveVBIA = __PERMEDIA_DISABLE;
        VSPartialA.InterlaceA = __PERMEDIA_ENABLE;
        VSPartialA.ReverseDataA = __PERMEDIA_ENABLE;
        In.dwSize = sizeof(VMIREQUEST);
        In.dwRegister = P2_VSAPartialConfig;
        In.dwCommand = *((DWORD*)(&VSPartialA));
        In.dwDevNode = pThisDisplay->dwDevNode;
        In.dwOperation = GLINT_VMI_WRITE;
        VXDCommand( GLINT_VMI_COMMAND, &In, sizeof(VMIREQUEST), &Out, sizeof(VMIREQUEST));

        // Setup Stream A
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS)
        {
            dwDiscard = PM_VSACONTROL_DISCARD_1;
            DISPDBG((DBGLVL,"Skipping Even Fields"));
        }
        else if(pInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS)
        {
            dwDiscard = PM_VSACONTROL_DISCARD_2;
            DISPDBG((DBGLVL,"Skipping Odd Fields"));
        }
        else dwDiscard = __PERMEDIA_DISABLE;
        
        LOAD_GLINT_REG(VSAControl, PM_VSACONTROL_VIDEO(__PERMEDIA_ENABLE) |
                                    PM_VSACONTROL_VBI(__PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_BUFFER((pThisDisplay->VidPort.dwNumSurfaces == 3) ? 1 : 0) |
                                    PM_VSACONTROL_SCALEX(XScale) | 
                                    PM_VSACONTROL_SCALEY(YScale) |
                                    PM_VSACONTROL_MIRRORY((pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_MIRRORX((pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_DISCARD(dwDiscard) |
                                    PM_VSACONTROL_COMBINE((pInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_LOCKTOB(__PERMEDIA_DISABLE));

        // Point the register at the surface being used
        LOAD_GLINT_REG(VSAVideoAddressHost, pThisDisplay->VidPort.dwCurrentHostFrame);

        // Check on the video stride
        LOAD_GLINT_REG(VSAVideoStride, (((pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch) >> 3));
        
        // Vertical data
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) 
        {
            LOAD_GLINT_REG(VSAVideoStartLine, pInput->lpVideoInfo->rCrop.top);
            LOAD_GLINT_REG(VSAVideoEndLine, pInput->lpVideoInfo->rCrop.top + dwDstHeight);
        }
        else
        {
            LOAD_GLINT_REG(VSAVideoStartLine, 0);
            LOAD_GLINT_REG(VSAVideoEndLine, dwDstHeight);
        }

        // Not using VBI, must disable (P2ST may not start up in a fixed state)
        LOAD_GLINT_REG(VSAVBIAddressHost, 0);
        LOAD_GLINT_REG(VSAVBIAddressIndex, 0);
        LOAD_GLINT_REG(VSAVBIAddress0, 0);
        LOAD_GLINT_REG(VSAVBIAddress1, 0);
        LOAD_GLINT_REG(VSAVBIAddress2, 0);
        LOAD_GLINT_REG(VSAVBIStride, 0);
        LOAD_GLINT_REG(VSAVBIStartLine, 0);
        LOAD_GLINT_REG(VSAVBIEndLine, 0);
        LOAD_GLINT_REG(VSAVBIStartData, 0);
        LOAD_GLINT_REG(VSAVBIEndData, 0);

#define CLOCKS_PER_PIXEL 2

        // Horizontal data
        // If the 
        if (pInput->lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_VACT)
        {
            // Set StartData and EndData to their limits and
            // let VACT tell us when we are getting active data.
            LOAD_GLINT_REG(VSAVideoStartData, 0);
            LOAD_GLINT_REG(VSAVideoEndData, (VIDEOPORT_MAX_FIELD_WIDTH) - 1);
        }
        else
        {
            if (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) 
            {
                LOAD_GLINT_REG(VSAVideoStartData, (pInput->lpVideoInfo->rCrop.left * CLOCKS_PER_PIXEL));
                LOAD_GLINT_REG(VSAVideoEndData, (pInput->lpVideoInfo->rCrop.left * CLOCKS_PER_PIXEL) + 
                                                ((dwDstPixelWidth / 2) * CLOCKS_PER_PIXEL));
            }
            else
            {
                LOAD_GLINT_REG(VSAVideoStartData, 0);
                LOAD_GLINT_REG(VSAVideoEndData, (dwDstPixelWidth * CLOCKS_PER_PIXEL));
            }
        }

        // Point at the surfaces
        LOAD_GLINT_REG(VSAVideoAddress0, ((pThisDisplay->VidPort.dwSurfacePointer[0] - pThisDisplay->dwScreenFlatAddr) >> 3));
        LOAD_GLINT_REG(VSAVideoAddress1, ((pThisDisplay->VidPort.dwSurfacePointer[1] - pThisDisplay->dwScreenFlatAddr) >> 3));
        LOAD_GLINT_REG(VSAVideoAddress2, ((pThisDisplay->VidPort.dwSurfacePointer[2] - pThisDisplay->dwScreenFlatAddr) >> 3));

        // Hook the VSYNC interrupt
        dwEnable = READ_GLINT_CTRL_REG(IntEnable);
        dwEnable |= INTR_ENABLE_VIDSTREAM_A;
        LOAD_GLINT_REG(IntEnable, dwEnable);

        LOAD_GLINT_REG(VSAInterruptLine, 0);
        pThisDisplay->VidPort.bActive = TRUE;
        pThisDisplay->VidPort.bResetStatus = TRUE;
        pThisDisplay->VidPort.dwErrorCount = 0;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdUpdateVideoPort

//-----------------------------------------------------------------------------
//
// DDGetVideoPortConnectInfo
//
// Passes back the connect info to a client.  Can be an array of
// available VideoPort Type
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DDGetVideoPortConnectInfo(
    LPDDHAL_GETVPORTCONNECTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DDGetVideoPortConnectInfo"));

    // P2 has 1 input and 1 output port, but DirectDraw 
    // VPE only understands input ports (for now).
    if (pInput->dwPortId != 0)
    {
        DISPDBG((WRNLVL, "  Invalid port ID: 0x%x", pInput->dwPortId));
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Fill in an array of connect info's.
    if (pInput->lpConnect == NULL)
    {
        DISPDBG((DBGLVL,"  Request for connect number, Port: 0x%x", pInput->dwPortId));
        pInput->dwNumEntries = VIDEOPORT_NUM_CONNECT_INFO;
        pInput->ddRVal = DD_OK;
    }
    else
    {
        DWORD dwNum;
        DDVIDEOPORTCONNECT ConnectInfo;

        DISPDBG((DBGLVL,"  Request for connect info, Port: 0x%x", pInput->dwPortId));

        ZeroMemory(&ConnectInfo, sizeof(DDVIDEOPORTCONNECT));
        ConnectInfo.dwSize = sizeof(DDVIDEOPORTCONNECT);
        ConnectInfo.dwFlags = DDVPCONNECT_VACT | DDVPCONNECT_DISCARDSVREFDATA
                                | DDVPCONNECT_HALFLINE | DDVPCONNECT_INVERTPOLARITY;

        // 4 GUIDs, 2 Port widths (8 and 16 bits)
        for (dwNum = 0; dwNum < VIDEOPORT_NUM_CONNECT_INFO; dwNum++)
        {
            switch(dwNum)
            {
                case 0: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFH;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 1: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFH;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 2: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFL;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 3: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFL;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 4:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFH;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 5:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFH;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 6:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFL;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 7:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFL;
                    ConnectInfo.dwPortWidth = 16;
                    break;
            }
            memcpy((pInput->lpConnect + dwNum), &ConnectInfo, sizeof(DDVIDEOPORTCONNECT));
        }

        pInput->dwNumEntries = VIDEOPORT_NUM_CONNECT_INFO;
        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DDGetVideoPortConnectInfo

//-----------------------------------------------------------------------------
//
// DdCanCreateVideoPort
//
// Can the VideoPort be created?
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCanCreateVideoPort (
    LPDDHAL_CANCREATEVPORTDATA pInput)
{
    DWORD dwFlags = 0;
    LPDDVIDEOPORTDESC    lpVPDesc;
    LPDDVIDEOPORTCONNECT lpVPConn;
    P3_THUNKEDDATA* pThisDisplay;

    lpVPDesc = pInput->lpDDVideoPortDesc;
    lpVPConn = &(pInput->lpDDVideoPortDesc->VideoPortType);
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdCanCreateVideoPort"));

    DUMPVPORT(DBGLVL,*pInput->lpDDVideoPortDesc);

    // Start with DD_OK.  If we are asked for parameters that we don't
    // support, then set the flag to DDERR_INVALIDPARAMS.
    pInput->ddRVal = DD_OK;

    // Check the video port ID
    if (lpVPDesc->dwVideoPortID != 0)
    {
        DISPDBG((DBGLVL, "  Invalid port ID: %d", lpVPDesc->dwVideoPortID));
        pInput->ddRVal = DDERR_INVALIDPARAMS;
    }

    // Check the video field width
    if (lpVPDesc->dwFieldWidth > VIDEOPORT_MAX_FIELD_WIDTH)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid video field width: %d", lpVPDesc->dwFieldWidth));
    }

    // Check the VBI field width
    if (lpVPDesc->dwVBIWidth > VIDEOPORT_MAX_VBI_WIDTH)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid VBI field width: %d", lpVPDesc->dwVBIWidth));
    }

    // Check the field height
    if (lpVPDesc->dwFieldHeight > VIDEOPORT_MAX_FIELD_HEIGHT)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid video field height: %d", lpVPDesc->dwFieldHeight));
    }

    // Check the connection GUID
    if ( MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_CCIR656)   ||
         MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_BROOKTREE) ||
         MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_PHILIPS) )
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid connection GUID"));
    }

    // Check the port width
    if ( !((lpVPConn->dwPortWidth == 8) || (lpVPConn->dwPortWidth == 16)) )
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid port width: %d", lpVPConn->dwPortWidth));
    }

    // All the flags we don't support
    dwFlags = DDVPCONNECT_DOUBLECLOCK | DDVPCONNECT_SHAREEVEN | DDVPCONNECT_SHAREODD;

    // Check the flags
    if (lpVPConn->dwFlags & dwFlags)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid flags: 0x%x", lpVPConn->dwFlags));
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdCanCreateVideoPort

//-----------------------------------------------------------------------------
//
// DdCreateVideoPort
//
// This function is optional
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCreateVideoPort (
    LPDDHAL_CREATEVPORTDATA pInput)
{
    VMIREQUEST vmi_inreq;
    VMIREQUEST vmi_outreq;
    BOOL bRet;

    int SurfaceNum = 0;
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdCreateVideoPort"));

    // Reset the structure for the videoport info
    memset(&pThisDisplay->VidPort, 0, sizeof(pThisDisplay->VidPort));

    ZeroMemory(&vmi_inreq, sizeof(VMIREQUEST));
    ZeroMemory(&vmi_outreq, sizeof(VMIREQUEST));
    vmi_inreq.dwSize = sizeof(VMIREQUEST);
    vmi_inreq.dwDevNode = pThisDisplay->dwDevNode;
    vmi_inreq.dwOperation = GLINT_VMI_GETMUTEX_A;
    vmi_inreq.dwMutex = 0;
    bRet = VXDCommand(GLINT_VMI_COMMAND, &vmi_inreq, sizeof(VMIREQUEST), &vmi_outreq, sizeof(VMIREQUEST));
    if (!bRet || (vmi_outreq.dwMutex == 0))
    {
        DISPDBG((WRNLVL,"WARNING: Couldn't get Mutex for stream A - VFW running?"));
        pInput->ddRVal = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }
    pThisDisplay->VidPort.dwMutexA = vmi_outreq.dwMutex;


    // Ensure the port is marked as not created and not on
    pThisDisplay->VidPort.bCreated = FALSE;
    pThisDisplay->VidPort.bActive = FALSE;

    WAIT_GLINT_FIFO(2);

    // Make sure the port is disabled.
    LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);

    // Keep a copy of the videoport description
    DUMPVPORT(0,*pInput->lpDDVideoPortDesc);

    // Succesfully created the VideoPort.
    pThisDisplay->VidPort.bCreated = TRUE;

    // Depending on the GUID, decide on the Status of the HREF and VREF lines
    if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFH))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_HREF_ACTIVE_HIGH | VIDEOPORT_VREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFL))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_HREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFH))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_VREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFL))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = 0;
    }
    else
    {
        DISPDBG((ERRLVL,"ERROR: Unsupported VideoType GUID!"));
        pThisDisplay->VidPort.dwStreamAFlags = 0;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_NOTHANDLED;
} // DdCreateVideoPort


//-----------------------------------------------------------------------------
//
// DdFlipVideoPort
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdFlipVideoPort (
    LPDDHAL_FLIPVPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwChipIndex;
    DWORD OutCount = 0;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);
    
    DISPDBG((DBGLVL,"** In DdFlipVideoPort"));

    if (pThisDisplay->VidPort.bActive)
    {

#if DBG
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** DdFlipVideoPort: was autoflipping on bogus event handle."));
            }
            if ( !g_bFlipVideoPortDoingAutoflip )
            {
                DISPDBG((DBGLVL,"** DdFlipVideoPort: already autoflipping!"));
            }
        }
#endif

        // Don't allow us to catch up with the video
        do
        {
            dwChipIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        } while (dwChipIndex == pThisDisplay->VidPort.dwCurrentHostFrame);

        pThisDisplay->VidPort.dwCurrentHostFrame++;
        if (pThisDisplay->VidPort.dwCurrentHostFrame >= pThisDisplay->VidPort.dwNumSurfaces)
        {
            pThisDisplay->VidPort.dwCurrentHostFrame = 0;
        }

        // Need to sync to ensure that a blit from the source surface has finished..
        SYNC_WITH_GLINT;
        
        // Advance the count
        LOAD_GLINT_REG(VSAVideoAddressHost, pThisDisplay->VidPort.dwCurrentHostFrame);
    }
    
    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdFlipVideoPort


//-----------------------------------------------------------------------------
//
// DdGetVideoPortBandwidth
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortBandwidth (
    LPDDHAL_GETVPORTBANDWIDTHDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DDVIDEOPORTBANDWIDTH *lpOutput = pInput->lpBandwidth;
    DDVIDEOPORTINFO *pInfo = &(pInput->lpVideoPort->ddvpInfo);
    DDVIDEOPORTDESC *pDesc = &(pInput->lpVideoPort->ddvpDesc);

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortBandwidth"));

    lpOutput->dwSize = sizeof(DDVIDEOPORTBANDWIDTH);    
    lpOutput->dwCaps = DDVPBCAPS_DESTINATION;

    if (!(pInput->dwFlags & DDVPB_TYPE))
    {
        lpOutput->dwOverlay = 20;
        lpOutput->dwColorkey = 20;
        lpOutput->dwYInterpolate = 20;
        lpOutput->dwYInterpAndColorkey = 20;
    }
       
    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortBandwidth


//-----------------------------------------------------------------------------
//
// GetVideoPortInputFormat32
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortInputFormats (
    LPDDHAL_GETVPORTINPUTFORMATDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DDPIXELFORMAT pf[] =
    {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC, FOURCC_YUV422 ,16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
    };

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);


    DISPDBG((DBGLVL,"** In DdGetVideoPortInputFormats"));

    //
    // The HAL is gaurenteed that the buffer in pInput->lpddpfFormat
    // is large enough to hold the information
    //
    pInput->dwNumFormats = 1;
    if (pInput->lpddpfFormat != NULL)
    {
        memcpy (pInput->lpddpfFormat, pf, sizeof (DDPIXELFORMAT));
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // GetVideoPortInputFormat32


//-----------------------------------------------------------------------------
//
// DdGetVideoPortOutputFormats
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortOutputFormats (
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    DDPIXELFORMAT pf[] =
    {
        {sizeof(DDPIXELFORMAT),DDPF_FOURCC, FOURCC_YUV422 ,16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
    };

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortOutputFormats"));

    // This says that if the input format of the videoport is YUV then the output will also be
    // YUV to the surface
    if (pInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC )
    {
        if (pInput->lpddpfInputFormat->dwFourCC == FOURCC_YUV422)
        {
            pInput->dwNumFormats = 1;
            if (pInput->lpddpfOutputFormats != NULL)
            {
                memcpy (pInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT));
            }
        }
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortOutputFormats

//-----------------------------------------------------------------------------
//
// DdGetVideoPortField
//
// This function is only required if readback of the current
// field is supported.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortField (
    LPDDHAL_GETVPORTFIELDDATA pInput)
{
    DWORD i = 0;
    DWORD dwIndex  = 0;
    DWORD dwMask   = 0;
    DWORD dwStatus = 0;

    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortField"));

    //
    // Make sure the video port is ON.  If not, set
    // pInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
    //
    if (pThisDisplay->VidPort.bActive == FALSE)
    {
        pInput->ddRVal = DDERR_VIDEONOTACTIVE;
    }
    else
    {
        DWORD dwCurrentIndex;

        // Read the current index and compare with us.  If the same then
        // we haven't finished drawing.
        do
        {
            dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        } while (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex);

        pInput->bField = (BOOL)((pThisDisplay->pGLInfo->dwVSAPolarity >> pThisDisplay->VidPort.dwCurrentHostFrame) & 0x1);
        //pInput->bField = !pInput->bField;

        DISPDBG((DBGLVL,"Returning Field %d's Polarity "
                        "- %d (dwVSAPolarity = 0x%x)", 
                        pThisDisplay->VidPort.dwCurrentHostFrame, 
                        pInput->bField,
                        pThisDisplay->pGLInfo->dwVSAPolarity));

        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortField


//-----------------------------------------------------------------------------
//
// DdGetVideoPortLine
//
// This function is only required if readback of the current
// video line number (0 relative) is supported.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortLine (
    LPDDHAL_GETVPORTLINEDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentLine;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortLine"));

    if (pThisDisplay->VidPort.bActive == FALSE)
    {
        pInput->ddRVal = DDERR_VIDEONOTACTIVE;
    }
    else
    {
        dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
        pInput->dwLine = dwCurrentLine;
        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoPortLine

//-----------------------------------------------------------------------------
//
// DdDestroyVideoPort
//
// This optional function notifies the HAL when the video port
// has been destroyed.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdDestroyVideoPort (
    LPDDHAL_DESTROYVPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    VMIREQUEST vmi_inreq;
    VMIREQUEST vmi_outreq;
    BOOL bRet;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdDestroyVideoPort"));

    // Ensure the port is off.
    WAIT_GLINT_FIFO(2);

    // Disablet the videoport
    LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);

    // Ensure the port is marked as not created and not on
    pThisDisplay->VidPort.bCreated = FALSE;
    pThisDisplay->VidPort.bActive = FALSE;

    // Release the mutex on Stream A
    if (pThisDisplay->VidPort.dwMutexA != 0)
    {
        DISPDBG((DBGLVL,"  Releasing StreamA Mutex"));
        ZeroMemory(&vmi_inreq, sizeof(VMIREQUEST));
        ZeroMemory(&vmi_outreq, sizeof(VMIREQUEST));
        vmi_inreq.dwSize = sizeof(VMIREQUEST);
        vmi_inreq.dwDevNode = pThisDisplay->dwDevNode;
        vmi_inreq.dwOperation = GLINT_VMI_RELEASEMUTEX_A;
        vmi_inreq.dwMutex = pThisDisplay->VidPort.dwMutexA;
        bRet = VXDCommand(GLINT_VMI_COMMAND, &vmi_inreq, sizeof(VMIREQUEST), &vmi_outreq, sizeof(VMIREQUEST));
        ASSERTDD(bRet,"ERROR: Couldn't release Mutex on Stream A");
    }

    // Reset the structure
    memset(&pThisDisplay->VidPort, 0, sizeof(pThisDisplay->VidPort));

    // Stop any autoflipping.
    if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
        {
            DISPDBG((WRNLVL,"** DdDestroyVideoPort: "
                       "was autoflipping on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
        DISPDBG((DBGLVL,"** DdDestroyVideoPort: autoflipping now disabled."));
    }

    // Make sure the videoport is turned off

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_NOTHANDLED;
    
} // DdDestroyVideoPort

//-----------------------------------------------------------------------------
//
// DdGetVideoSignalStatus
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoSignalStatus(
    LPDDHAL_GETVPORTSIGNALDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentIndex;
    BOOL bOK = FALSE;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);

    // If the host count matches the index count then the video may be stuck
    if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
    {
        bOK = __VD_CheckVideoPortStatus(pThisDisplay, TRUE);
    }
    else
    {
        bOK = TRUE;
    }
    
    if (!bOK)
    {
        pInput->dwStatus = DDVPSQ_NOSIGNAL;
    }
    else
    {
        pInput->dwStatus = DDVPSQ_SIGNALOK;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoSignalStatus

//-----------------------------------------------------------------------------
//
// DdGetVideoPortFlipStatus
//
// This required function allows DDRAW to restrict access to a surface
// until the physical flip has occurred, allowing doubled buffered capture.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortFlipStatus (
    LPDDHAL_GETVPORTFLIPSTATUSDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentIndex;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortFlipStatus"));

    pInput->ddRVal = DD_OK;

    if (pThisDisplay->VidPort.bActive == TRUE)
    {

        // If we are flipping, check the currently rendered frame
        // Read the current index and compare with us.  If the same then
        // we haven't finished drawing.
        dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
        {
            // If the videoport is not stuck return that we are still drawing
            if (__VD_CheckVideoPortStatus(pThisDisplay, FALSE))
            {
                pInput->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else
            {
                pInput->ddRVal = DD_OK;
            }

        }
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoPortFlipStatus

//-----------------------------------------------------------------------------
//
// DdWaitForVideoPortSync
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdWaitForVideoPortSync (
    LPDDHAL_WAITFORVPORTSYNCDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdWaitForVideoPortSync"));

//@@BEGIN_DDKSPLIT
    /*
     * Make sure the video port is ON.  If not, set
     * pInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */
/*
    if (pInput->dwFlags == DDVPEVENT_BEGIN)
    {
        pInput->ddRVal = DD_OK;
    }

    else if (pInput->dwFlags == DDVPEVENT_END)
    {
        pInput->ddRVal = DD_OK;
    }
    */
//@@END_DDKSPLIT

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdWaitForVideoPortSync

//-----------------------------------------------------------------------------
//
// DdSyncSurfaceData
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSyncSurfaceData(
    LPDDHAL_SYNCSURFACEDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdSyncSurfaceData"));

    DBGDUMP_DDRAWSURFACE_LCL(3, pInput->lpDDSurface);
    if (!(pInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
    {
        DISPDBG((DBGLVL, "Surface is not an overlay - not handling"));
        pInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    if (pInput->lpDDSurface->lpGbl->dwGlobalFlags & 
                                    DDRAWISURFGBL_SOFTWAREAUTOFLIP)
    {
        DISPDBG((DBGLVL, "Autoflipping in software"));
    }
    pInput->dwSurfaceOffset = pInput->lpDDSurface->lpGbl->fpVidMem - 
                                        pThisDisplay->dwScreenFlatAddr;
    pInput->dwOverlayOffset = pInput->dwSurfaceOffset;

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdSyncSurfaceData

//-----------------------------------------------------------------------------
//
// DdSyncVideoPortData
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSyncVideoPortData(
    LPDDHAL_SYNCVIDEOPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdSyncVideoPortData"));

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdSyncVideoPortData

//-----------------------------------------------------------------------------
//
// UpdateOverlay32
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
UpdateOverlay32(
    LPDDHAL_UPDATEOVERLAYDATA puod)
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DDRAWSURFACE_LCL   lpSrcSurf;
    HDC                         hDC;
    DWORD                       dwDstColourKey;
    DWORD                       dwSrcColourKey;

    GET_THUNKEDDATA(pThisDisplay, puod->lpDD);


    /*
     * A puod looks like this:
     * 
     * LPDDRAWI_DIRECTDRAW_GBL      lpDD;               // driver struct
     * LPDDRAWI_DDRAWSURFACE_LCL    lpDDDestSurface;    // dest surface
     * RECTL                        rDest;              // dest rect
     * LPDDRAWI_DDRAWSURFACE_LCL    lpDDSrcSurface;     // src surface
     * RECTL                        rSrc;               // src rect
     * DWORD                        dwFlags;            // flags
     * DDOVERLAYFX                  overlayFX;          // overlay FX
     * HRESULT                      ddRVal;             // return value
     * LPDDHALSURFCB_UPDATEOVERLAY  UpdateOverlay;      // PRIVATE: ptr to callback
     */

    DISPDBG ((DBGLVL,"**In UpdateOverlay32"));

    lpSrcSurf = puod->lpDDSrcSurface;

    /*
     * In the LPDDRAWI_DDRAWSURFACE_LCL, we have the following cool data,
     * making life much easier:
     * 
     * HOWEVER! It appears that UpdateOverlay32 is called before any of these
     * values are changed, so use the values passed in instead.
     * 
     * DDCOLORKEY                       ddckCKSrcOverlay;       // color key for source overlay use
     * DDCOLORKEY                       ddckCKDestOverlay;      // color key for destination overlay use
     * LPDDRAWI_DDRAWSURFACE_INT        lpSurfaceOverlaying;    // surface we are overlaying
     * DBLNODE                          dbnOverlayNode;
     * 
     * //
     * //overlay rectangle, used by DDHEL
     * //
     * RECT                             rcOverlaySrc;
     * RECT                             rcOverlayDest;
     * //
     * //the below values are kept here for ddhel. they're set by UpdateOverlay,
     * //they're used whenever the overlays are redrawn.
     * //
     * DWORD                            dwClrXparent;           // the *actual* color key (override, colorkey, or CLR_INVALID)
     * DWORD                            dwAlpha;                // the per surface alpha
     * //
     * //overlay position
     * //
     * LONG                             lOverlayX;              // current x position
     * LONG                             lOverlayY;              // current y position
     */


#if DBG
    // Standard integrity test.
    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl != NULL )
        {
            // If overlay is not visible, the current surface should be NULL.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - vis==0,srcsurf!=NULL"));
        }
    }
    else
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl == NULL )
        {
            // If overlay is visible, the current surface should not be NULL.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - vis!=0,srcsurf==NULL"));
        }
    }

#endif //DBG

    if ( ( puod->dwFlags & DDOVER_HIDE ) != 0 )
    {

        DISPDBG((DBGLVL,"** UpdateOverlay32 - hiding."));

        // Hide the overlay.
        if ( pThisDisplay->bOverlayVisible == 0 )
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - already hidden."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }
        if ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)lpSrcSurf )
        {
            // This overlay isn't being shown.
            DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - not current overlay surface."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }


        // Stop any autoflipping.
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
#if DBG
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoflipping on bogus event handle."));
            }
#endif
            pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoflipping now disabled."));
        }

        if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoupdating on bogus event handle."));
            }
            pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoupdate now disabled."));
        }


//      DISPDBG((DBGLVL,"** UpdateOverlay32 (hiding) destroying rect memory."));
        // Free the rect memory
        if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
        {
            HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
        }
        pThisDisplay->OverlayClipRgnMem     = (ULONG_PTR)NULL;
        pThisDisplay->OverlayClipRgnMemSize = (DWORD)0;
//      DISPDBG((DBGLVL,"** UpdateOverlay32 (hiding) destroyed rect memory."));


        pThisDisplay->bOverlayVisible           = FALSE;
        pThisDisplay->OverlayDstRectL           = (DWORD)0;
        pThisDisplay->OverlayDstRectR           = (DWORD)0;
        pThisDisplay->OverlayDstRectT           = (DWORD)0;
        pThisDisplay->OverlayDstRectB           = (DWORD)0;
        pThisDisplay->OverlaySrcRectL           = (DWORD)0;
        pThisDisplay->OverlaySrcRectR           = (DWORD)0;
        pThisDisplay->OverlaySrcRectT           = (DWORD)0;
        pThisDisplay->OverlaySrcRectB           = (DWORD)0;
        pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)NULL;
        pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)NULL;
        pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlayUpdateCountdown    = 0;
        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;

        pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)FALSE;
        pThisDisplay->pGLInfo->dwOverlayRectL               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectR               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectT               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectB               = (DWORD)0;
        pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
        pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
        pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
        pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

        // Clean up the temporary buffer, if any.
        if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
        {
            FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
            pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
            pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
        }

        // Restart the 2D renderer with non-overlay functions.
        hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
        if ( hDC != NULL )
        {
            ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
            DELETE_DRIVER_DC ( hDC );
        }
        else
        {
            DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
        }

        puod->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    }
    else if ( ( ( puod->dwFlags & DDOVER_SHOW ) != 0 ) || ( pThisDisplay->bOverlayVisible != 0 ) )
    {

        {
            // Catch the dodgy call made by the Demon helper.
            // This is very bad, but it's the only way I can see to
            // get Demon to call these two functions.
            // Remember that the various surfaces and so on are just
            // to get DD to relax and accept life.
            // The first three numbers are just that - magic numbers,
            // and the last one shows which of a range of calls need to be made,
            // as well as being a magic number itself.
            if (
                ( ( puod->dwFlags & DDOVER_SHOW ) != 0 ) &&
                ( ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE ) != 0 ) &&
                ( ( puod->dwFlags & DDOVER_DDFX ) != 0 ) )
            {
                // OK, looks like a valid call from Demon.
                if (
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue  == GLDD_MAGIC_AUTOFLIPOVERLAY_DL ) &&
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceHighValue == GLDD_MAGIC_AUTOFLIPOVERLAY_DH ) )
                {
                    puod->ddRVal = __VD_AutoflipOverlay();
                    // the return value is actually a benign DD error
                    // value, but GLDD_AUTO_RET_* are also aliased to the
                    // right one for useabiliy.
                    return DDHAL_DRIVER_HANDLED;
                }
                else if (
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue  == GLDD_MAGIC_AUTOUPDATEOVERLAY_DL ) &&
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceHighValue == GLDD_MAGIC_AUTOUPDATEOVERLAY_DH ) )
                {
                    puod->ddRVal = __VD_AutoupdateOverlay();
                    // the return value is actually a benign DD error
                    // value, but GLDD_AUTO_RET_* are also aliased to the
                    // right one for useabiliy.
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }


        DISPDBG((DBGLVL,"** UpdateOverlay32 - showing or reshowing."));


        // Either we need to show this, or it is already being shown.

        if ( ( pThisDisplay->bOverlayVisible != 0 ) && ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)lpSrcSurf ) )
        {
            // Overlay being shown and source surfaces don't match.
            // i.e. someone else wants an overlay, but it's already in use.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - overlay already being shown, returning DDERR_OUTOFCAPS"));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }



        // Clean up the temporary buffer, if any.
        if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
        {
            FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
            pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
            pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
        }

        // Store all the data in the display's data block.
        pThisDisplay->bOverlayVisible           = TRUE;
        pThisDisplay->OverlayDstRectL           = (DWORD)puod->rDest.left;
        pThisDisplay->OverlayDstRectR           = (DWORD)puod->rDest.right;
        pThisDisplay->OverlayDstRectT           = (DWORD)puod->rDest.top;
        pThisDisplay->OverlayDstRectB           = (DWORD)puod->rDest.bottom;
        pThisDisplay->OverlaySrcRectL           = (DWORD)puod->rSrc.left;
        pThisDisplay->OverlaySrcRectR           = (DWORD)puod->rSrc.right;
        pThisDisplay->OverlaySrcRectT           = (DWORD)puod->rSrc.top;
        pThisDisplay->OverlaySrcRectB           = (DWORD)puod->rSrc.bottom;
        pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)puod->lpDDDestSurface;
        pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)lpSrcSurf;
        pThisDisplay->OverlayUpdateCountdown    = 0;
        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;
        pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->pGLInfo->bOverlayEnabled  = (DWORD)TRUE;


        // Make sure someone hasn't changed video mode behind our backs.
        // If an overlay is started in a 16-bit mode and then you change to
        // an 8-bit mode, the caps bits are rarely checked again,
        // and certainly not by DirectShow.
        if ( ( pThisDisplay->bPixShift != GLINTDEPTH16 ) &&
             ( pThisDisplay->bPixShift != GLINTDEPTH32 ) )
        {
            DISPDBG((WRNLVL,"** UpdateOverlay32 - overlay asked for in non-16 or non-32 bit mode. Returning DDERR_OUTOFCAPS"));
            goto update_overlay_outofcaps_cleanup;
        }


        #if 1
        // See if there is a clipper or not. If not, this is trying to fly over the
        // desktop instead of being bound in a window, so object nicely.
        if (    ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl) != NULL ) &&
                ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore != NULL ) &&
                ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore->lpDDIClipper != NULL ) )
        {
            // Yep, there's a clipper
        }
        else
        {
            // No clipper. Someone's doing a WHQL test! :-)
            DISPDBG((WRNLVL,"** UpdateOverlay32 - no clipper on dest surface, returning DDERR_OUTOFCAPS"));
            goto update_overlay_outofcaps_cleanup;
        }
        #endif

        
        #if 1
        {
            // Get the cliprect list, and see if it is larger than the
            // target rectangle. That is a pretty good indication of
            // Overfly (and indeed anything else that tries anything similar)
            LPRGNDATA lpRgn;
            int NumRects;
            LPRECT lpCurRect;

            lpRgn = GetOverlayVisibleRects ( pThisDisplay );
            if ( lpRgn != NULL )
            {
                // Got a clip region.
                NumRects = lpRgn->rdh.nCount;
                if ( NumRects > 0 )
                {
                    lpCurRect = (LPRECT)lpRgn->Buffer;
                    while ( NumRects > 0 )
                    {
                        // The +-5 is a fudge factor to cope with Xing's slight insanities.
                        if (    ( lpCurRect->left   < puod->rDest.left - 5 ) ||
                                ( lpCurRect->right  > puod->rDest.right + 5 ) ||
                                ( lpCurRect->top    < puod->rDest.top - 5 ) ||
                                ( lpCurRect->bottom > puod->rDest.bottom + 5 ) )
                        {
                            DISPDBG((WRNLVL,"** UpdateOverlay32 - out of range cliprect(s). Returning DDERR_OUTOFCAPS"));
                            goto update_overlay_outofcaps_cleanup;
                        }
                        // Next rect
                        NumRects--;
                        lpCurRect++;
                    }
                }
            }
        }
        #endif


        dwDstColourKey = CLR_INVALID;
        if ( puod->dwFlags & DDOVER_KEYDEST )
        {
            // Use destination surface's destination colourkey for dst key.
            dwDstColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        }
        if ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE )
        {
            // Use DDOVERLAYFX dest colour for dst key.
            dwDstColourKey = puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
        }


        dwSrcColourKey = CLR_INVALID;
        if ( puod->dwFlags & DDOVER_KEYSRC )
        {
            // Use source surface's source colourkey for src key.
            dwSrcColourKey = puod->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
            DISPDBG((WRNLVL,"UpdateOverlay32:ERROR! Cannot do source colour key on overlays."));
        }
        if ( puod->dwFlags & DDOVER_KEYSRCOVERRIDE )
        {
            // Use DDOVERLAYFX src colour for src key.
            dwSrcColourKey = puod->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
            DISPDBG((WRNLVL,"UpdateOverlay32:ERROR! Cannot do source colour key overrides on overlays."));
        }


        if ( dwDstColourKey != CLR_INVALID )
        {
            DWORD dwChipColourKey;
            DWORD dwFBColourKey;
            DWORD dwFBAlphaSet;

            // Find the chip's colour key for this display mode.
            dwChipColourKey = (DWORD)-1;
            switch ( pThisDisplay->bPixShift )
            {
                case GLINTDEPTH16:
                    if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
                    {
                        // 5551 format, as it should be.
                        dwFBColourKey = ( puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue ) & 0xffff;
                        dwChipColourKey = CHROMA_LOWER_ALPHA(FORMAT_5551_32BIT_BGR(dwFBColourKey));
                        // Replicate in both words.
                        dwFBColourKey |= dwFBColourKey << 16;
                        dwFBAlphaSet = 0x80008000;
                    }
                    else
                    {
                        // 565 format. Oops.
                        DISPDBG((WRNLVL, "** UpdateOverlay32 error: called for a colourkeyed 565 surface."));
                    }
                    break;
                case GLINTDEPTH32:
                    dwFBColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
                    dwChipColourKey = CHROMA_LOWER_ALPHA(FORMAT_8888_32BIT_BGR(dwFBColourKey));
                    dwFBAlphaSet = 0xff000000;
                    break;
                case GLINTDEPTH8:
                case GLINTDEPTH24:
                default:
                    DISPDBG((WRNLVL, "** UpdateOverlay32 error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
                    DISPDBG((ERRLVL,"** UpdateOverlay32 error: see above."));
                    goto update_overlay_outofcaps_cleanup;
                    break;
            }


            if ( dwChipColourKey == (DWORD)-1 )
            {
                DISPDBG((WRNLVL,"UpdateOverlay32:ERROR:Cannot do overlay dest colour keying..."));
                DISPDBG((WRNLVL,"...in anything but 5551 or 8888 mode - returning DDERR_OUTOFCAPS"));
                goto update_overlay_outofcaps_cleanup;
            }

            pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)TRUE;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = dwFBColourKey;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = dwChipColourKey;
            pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)TRUE;
            pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = dwFBAlphaSet;

            // Try to allocate the temporary buffer needed for colourkey stuff.
            pThisDisplay->OverlayTempSurf.VidMem = AllocStretchBuffer (pThisDisplay,
                                                            (pThisDisplay->OverlayDstRectR - pThisDisplay->OverlayDstRectL),    // width
                                                            (pThisDisplay->OverlayDstRectB - pThisDisplay->OverlayDstRectT),    // height
                                                            DDSurf_GetChipPixelSize((LPDDRAWI_DDRAWSURFACE_LCL)(pThisDisplay->OverlayDstSurfLcl)),          // PixelSize
                                                            (ULONG_PTR)((LPDDRAWI_DDRAWSURFACE_LCL)(pThisDisplay->OverlayDstSurfLcl))->ddsCaps.dwCaps,
                                                            (int*)&(pThisDisplay->OverlayTempSurf.Pitch));
            if ( pThisDisplay->OverlayTempSurf.VidMem == (ULONG_PTR)NULL )
            {
                // Not enough space - have to fail the overlay
                DISPDBG((WRNLVL,"UpdateOverlay32:ERROR: not enough memory for buffer - returning DDERR_OUTOFCAPS"));
                pThisDisplay->OverlayTempSurf.Pitch = (DWORD)0;
                goto update_overlay_outofcaps_cleanup;
            }

            // Restart the 2D renderer with overlay functions.
            hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
            if ( hDC != NULL )
            {
                ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
                DELETE_DRIVER_DC ( hDC );
            }
            else
            {
                DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
            }

            // update the alpha channel
            UpdateAlphaOverlay ( pThisDisplay );
            pThisDisplay->OverlayUpdateCountdown = OVERLAY_UPDATE_WAIT;
        }
        else
        {
            // No colour key, just an overlay.
            pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)TRUE;
            pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
            pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

            // Restart the 2D renderer with non-overlay functions.
            hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
            if ( hDC != NULL )
            {
                ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
                DELETE_DRIVER_DC ( hDC );
            }
            else
            {
                DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
            }
        }

        // Safely got any memory required, so we can set these up now.
        pThisDisplay->OverlayDstColourKey = dwDstColourKey;
        pThisDisplay->OverlaySrcColourKey = dwSrcColourKey;

        pThisDisplay->pGLInfo->dwOverlayRectL = pThisDisplay->OverlayDstRectL;
        pThisDisplay->pGLInfo->dwOverlayRectR = pThisDisplay->OverlayDstRectR;
        pThisDisplay->pGLInfo->dwOverlayRectT = pThisDisplay->OverlayDstRectT;
        pThisDisplay->pGLInfo->dwOverlayRectB = pThisDisplay->OverlayDstRectB;


        // Do the update itself.
        P3TestDrawOverlay ( pThisDisplay, lpSrcSurf, FALSE );

        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)TRUE;

        if ( ( puod->dwFlags & DDOVER_AUTOFLIP ) == 0 )
        {
            // Start or continue any autoupdates - this is not autoflipping.
    #if DBG
            if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** UpdateOverlay32 - trying to autoupdate using bogus event handle."));
            }
    #endif
            if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL == 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodMonitorVBL = OVERLAY_AUTOUPDATE_CYCLE_PERIOD;
                pThisDisplay->pGLInfo->dwCountdownMonitorVBL = OVERLAY_AUTOUPDATE_RESET_PERIOD;
                DISPDBG((DBGLVL,"** UpdateOverlay32 - autoupdate now enabled."));
            }
        }
        else
        {
            // This autoflips - stop any autoupdates.
            if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
                pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
                DISPDBG((DBGLVL,"** UpdateOverlay32 - autoupdate now disabled because of autoflipping."));
            }
        }


        // And tell the world about it
        DISPDBG((DBGLVL,"** In UpdateOverlay32"));
        DISPDBG((DBGLVL,"** ...Src rect %d,%d -> %d,%d", pThisDisplay->OverlaySrcRectL, pThisDisplay->OverlaySrcRectT, pThisDisplay->OverlaySrcRectR, pThisDisplay->OverlaySrcRectB ));
        DISPDBG((DBGLVL,"** ...Dst rect %d,%d -> %d,%d", pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectT, pThisDisplay->OverlayDstRectR, pThisDisplay->OverlayDstRectB ));
        DISPDBG((DBGLVL,"** ...Src colour key 0x%08x, dst colour key 0x%08x", pThisDisplay->OverlaySrcColourKey, pThisDisplay->OverlayDstColourKey ));

    }


    puod->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;



update_overlay_outofcaps_cleanup:
    // This cleans up after any partial setup, and returns DDERR_OUTOFCAPS.
    // It's a clean and easy way of failing at any stage.

    DISPDBG((DBGLVL,"** UpdateOverlay32 - cleaning up and returning DDERR_OUTOFCAPS."));

    // Stop any autoflipping.
    if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
        {
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoflipping on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
        DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoflipping now disabled."));
    }

    if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
        {
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoupdating on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
        DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoupdate now disabled."));
    }


    // Free the rect memory
    if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
    {
        HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
    }
    pThisDisplay->OverlayClipRgnMem     = (ULONG_PTR)NULL;
    pThisDisplay->OverlayClipRgnMemSize = (DWORD)0;


    pThisDisplay->bOverlayVisible           = FALSE;
    pThisDisplay->OverlayDstRectL           = (DWORD)0;
    pThisDisplay->OverlayDstRectR           = (DWORD)0;
    pThisDisplay->OverlayDstRectT           = (DWORD)0;
    pThisDisplay->OverlayDstRectB           = (DWORD)0;
    pThisDisplay->OverlaySrcRectL           = (DWORD)0;
    pThisDisplay->OverlaySrcRectR           = (DWORD)0;
    pThisDisplay->OverlaySrcRectT           = (DWORD)0;
    pThisDisplay->OverlaySrcRectB           = (DWORD)0;
    pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)NULL;
    pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)NULL;
    pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
    pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
    pThisDisplay->OverlayUpdateCountdown    = 0;
    pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;

    pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)FALSE;
    pThisDisplay->pGLInfo->dwOverlayRectL               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectR               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectT               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectB               = (DWORD)0;
    pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
    pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
    pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
    pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

    // Clean up the temporary buffer, if any.
    if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
    {
        FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
        pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
        pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
    }

    // Restart the 2D renderer with non-overlay functions.
    hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
    if ( hDC != NULL )
    {
        ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
        DELETE_DRIVER_DC ( hDC );
    }
    else
    {
        DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
    }

    puod->ddRVal = DDERR_OUTOFCAPS;
    return DDHAL_DRIVER_HANDLED;

}

DWORD CALLBACK SetOverlayPosition32(LPDDHAL_SETOVERLAYPOSITIONDATA psopd)
{

    P3_THUNKEDDATA*       pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, psopd->lpDD);

//  /*
//   * A psopd looks like this:
//   * 
//   * LPDDRAWI_DIRECTDRAW_GBL      lpDD;               // driver struct
//   * LPDDRAWI_DDRAWSURFACE_LCL    lpDDSrcSurface;     // src surface
//   * LPDDRAWI_DDRAWSURFACE_LCL    lpDDDestSurface;    // dest surface
//   * LONG                         lXPos;              // x position
//   * LONG                         lYPos;              // y position
//   * HRESULT                      ddRVal;             // return value
//   * LPDDHALSURFCB_SETOVERLAYPOSITION SetOverlayPosition; // PRIVATE: ptr to callback
//   */

#if DBG
    // Standard integrity test.
    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl != NULL )
        {
            // If overlay is not visible, the current surface should be NULL.
            DISPDBG((DBGLVL,"** SetOverlayPosition32 - vis==0,srcsurf!=NULL"));
        }
    }
    else
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl == NULL )
        {
            // If overlay is visible, the current surface should not be NULL.
            DISPDBG((DBGLVL,"** SetOverlayPosition32 - vis!=0,srcsurf==NULL"));
        }
    }
#endif //DBG


    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        // No overlay is visible.
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }
    if ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)psopd->lpDDSrcSurface )
    {
        // This overlay isn't visible.
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }

#if DBG
    if ( pThisDisplay->OverlayDstSurfLcl != (ULONG_PTR)psopd->lpDDDestSurface )
    {
        // Oh dear. The destination surfaces don't agree.
        DISPDBG((DBGLVL,"** SetOverlayPosition32 - dest surfaces don't agree"));
    }
#endif //DBG

    // Move the rect
    pThisDisplay->OverlayDstRectR       += (DWORD)( psopd->lXPos - (LONG)pThisDisplay->OverlayDstRectL );
    pThisDisplay->OverlayDstRectB       += (DWORD)( psopd->lYPos - (LONG)pThisDisplay->OverlayDstRectT );
    pThisDisplay->OverlayDstRectL       = (DWORD)psopd->lXPos;
    pThisDisplay->OverlayDstRectT       = (DWORD)psopd->lYPos;

    pThisDisplay->pGLInfo->dwOverlayRectL = pThisDisplay->OverlayDstRectL;
    pThisDisplay->pGLInfo->dwOverlayRectR = pThisDisplay->OverlayDstRectR;
    pThisDisplay->pGLInfo->dwOverlayRectT = pThisDisplay->OverlayDstRectT;
    pThisDisplay->pGLInfo->dwOverlayRectB = pThisDisplay->OverlayDstRectB;


    if ( pThisDisplay->OverlayDstColourKey != CLR_INVALID )
    {
        // update the alpha channel
        UpdateAlphaOverlay ( pThisDisplay );
        pThisDisplay->OverlayUpdateCountdown = OVERLAY_UPDATE_WAIT;
    }

    // Do the update itself.
    P3TestDrawOverlay ( pThisDisplay, psopd->lpDDSrcSurface, FALSE );

    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)TRUE;


    // And tell the world about it
    DISPDBG((DBGLVL,"** In SetOverlayPosition32"));
    DISPDBG((DBGLVL,"** ...Dst rect %d,%d -> %d,%d", pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectT, pThisDisplay->OverlayDstRectR, pThisDisplay->OverlayDstRectB ));

    psopd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

}




/****************************************************************************
 *
 * LPRGNDATA GetOverlayVisibleRects ( P3_THUNKEDDATA* pThisDisplay );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;     This display's pointer
 * 
 * Out:
 *      LPRGNDATA;                      A pointer to the list of rects.
 * 
 * Notes:
 *      Returns a pointer to a list of rects that shows the visible
 * sections of the currently overlaid surface. This list is clipped by
 * the overlay's intended rectange, so no other bounds checking needs to
 * be done.
 *      Note that the memory returned is private and may only be read by
 * other functions. The actual memory is owned by
 * pThisDisplay->OverlayClipRgnMem, and should only be changed by this
 * function (or freed in selected other places). The memory may change
 * every time this function is called, or when various other overlay
 * functions are called.
 * 
 ***************************************************************************/

LPRGNDATA GetOverlayVisibleRects ( P3_THUNKEDDATA* pThisDisplay )
{

    // Use any clipper available.
    LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
    HRESULT                     hRes;
    int                         ClipSize;
    RECT                        rBound;

    rBound.left     = pThisDisplay->OverlayDstRectL;
    rBound.right    = pThisDisplay->OverlayDstRectR;
    rBound.top      = pThisDisplay->OverlayDstRectT;
    rBound.bottom   = pThisDisplay->OverlayDstRectB;

    // No WinWatch. Try doing an immediate call.
    lpDDIClipper = NULL;
    if ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl) != NULL )
    {
        if ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore != NULL )
        {
            lpDDIClipper = ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore->lpDDIClipper;
        }
    }
    if ( lpDDIClipper != NULL )
    {
#ifdef __cplusplus
        hRes = ((IDirectDrawClipper*)(lpDDIClipper->lpVtbl))->GetClipList (&rBound, NULL, (unsigned long*)&ClipSize );
#else
        hRes = ((IDirectDrawClipperVtbl *)(lpDDIClipper->lpVtbl))->GetClipList ( (IDirectDrawClipper *)lpDDIClipper, &rBound, NULL, &ClipSize );
#endif
        if ( hRes == DD_OK )
        {
            // Reallocate if need be.
            if ( ClipSize > (int)pThisDisplay->OverlayClipRgnMemSize )
            {
                if (pThisDisplay->OverlayClipRgnMem != 0 )
                {
                    HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
                    pThisDisplay->OverlayClipRgnMem = 0;
                }
                pThisDisplay->OverlayClipRgnMem = (ULONG_PTR)HEAP_ALLOC (0, 
                                                                         ClipSize, 
                                                                         ALLOC_TAG_DX(F));
                if ( (void *)pThisDisplay->OverlayClipRgnMem == NULL )
                {
                    DISPDBG((ERRLVL,"ERROR: Flip32: Could not allocate heap memory for clip region"));
                    pThisDisplay->OverlayClipRgnMemSize = 0;
                    return ( NULL );
                }
                else
                {
                    pThisDisplay->OverlayClipRgnMemSize = ClipSize;
                }
            }

            if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
            {
                // OK, got some good memory.
#ifdef __cplusplus
                hRes = ((IDirectDrawClipper*)(lpDDIClipper->lpVtbl))->GetClipList (&rBound, (LPRGNDATA)pThisDisplay->OverlayClipRgnMem, (unsigned long*)&ClipSize );
#else
                hRes = ((IDirectDrawClipperVtbl *)(lpDDIClipper->lpVtbl))->GetClipList ( (IDirectDrawClipper *)lpDDIClipper, &rBound, (LPRGNDATA)pThisDisplay->OverlayClipRgnMem, &ClipSize );
#endif
                if ( hRes != DD_OK )
                {
                    DISPDBG((ERRLVL,"ERROR: Flip32: GetClipList failed."));
                    return ( NULL );
                }
                else
                {
                    LPRECT      lpCurRect;
                    RECT        rBound;
                    int         NumRects;
                    LPRGNDATA   lpRgn;
                    // Adjust their bounding rect so it actually does bound all the
                    // rects.

                    lpRgn = (LPRGNDATA)pThisDisplay->OverlayClipRgnMem;
                    lpCurRect = (LPRECT)lpRgn->Buffer;
                    NumRects = lpRgn->rdh.nCount;
                    if ( NumRects > 0 )
                    {
                        rBound = *lpCurRect;

                        NumRects--;
                        lpCurRect++;

                        while ( NumRects > 0 )
                        {
                            if ( rBound.left > lpCurRect->left )
                            {
                                rBound.left = lpCurRect->left;
                            }
                            if ( rBound.top > lpCurRect->top )
                            {
                                rBound.top = lpCurRect->top;
                            }
                            if ( rBound.right < lpCurRect->right )
                            {
                                rBound.right = lpCurRect->right;
                            }
                            if ( rBound.bottom < lpCurRect->bottom )
                            {
                                rBound.bottom = lpCurRect->bottom;
                            }

                            NumRects--;
                            lpCurRect++;
                        }

                        #if DBG
                        // Were the two bounding rectangles the same?
                        if ( ( rBound.left != lpRgn->rdh.rcBound.left ) ||
                             ( rBound.right != lpRgn->rdh.rcBound.right ) ||
                             ( rBound.top != lpRgn->rdh.rcBound.top ) ||
                             ( rBound.bottom != lpRgn->rdh.rcBound.bottom ) )
                        {
                            DISPDBG((DBGLVL,"GetOverlayVisibleRects: area bounding box does not actually bound!"));
                            DISPDBG((DBGLVL,"My bounding rect %d,%d->%d,%d", rBound.left, rBound.top, rBound.right, rBound.bottom ));
                            DISPDBG((DBGLVL,"Their bounding rect %d,%d->%d,%d", lpRgn->rdh.rcBound.left, lpRgn->rdh.rcBound.top, lpRgn->rdh.rcBound.right, lpRgn->rdh.rcBound.bottom ));
                        }
                        #endif
                        lpRgn->rdh.rcBound = rBound;


                        // Phew - we finally got a clip region.
                        return ( (LPRGNDATA)pThisDisplay->OverlayClipRgnMem );
                    }
                    else
                    {
                        // No cliplist.
                        return ( NULL );
                    }
                }
            }
            else
            {
                return ( NULL );
            }
        }
        else
        {
            return ( NULL );
        }
    }

    return ( NULL );
}




/****************************************************************************
 *
 * DWORD GLDD__Autoflip_Overlay ( void );
 * 
 * In:
 *      None.
 * 
 * Out:
 *      Error code:
 *          GLDD_AUTO_RET_DID_UPDATE        = no error - did update.
 *          GLDD_AUTO_RET_ERR_GENERAL       = general error.
 *          GLDD_AUTO_RET_ERR_NO_OVERLAY    = no autoflipping overlay(s).
 * 
 * Notes:
 *      This is called by the Demon helper program that sits waiting for
 * video-in VBLANKS, then calls this.
 *      This flips the current overlay if it is marked as autoflipping. If
 * there is such an overlay, it returns 0, otherwise it returns 1.
 * 
 ***************************************************************************/

DWORD CALLBACK __VD_AutoflipOverlay ( void )
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL   pCurSurf;
    DDHAL_FLIPVPORTDATA         ddhFVPD;

    // This is hard-coded and doesn't on work multi-monitors.
    // But then nothing does, so...
    pThisDisplay = g_pDriverData;

    DISPDBG((DBGLVL,"**In __VD_AutoflipOverlay"));

    if ( pThisDisplay->VidPort.bActive )
    {
        // Video port is active.


        // Find the buffer to show.
        pCurSurf = pThisDisplay->VidPort.lpSurf [ pThisDisplay->VidPort.dwCurrentHostFrame ];
        if ( pCurSurf == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: pCurSurf is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        if ( pCurSurf->lpGbl == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: lpGbl is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }
        lpDD = pCurSurf->lpGbl->lpDD;
        if ( lpDD == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: lpDD is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }


        DISPDBG((DBGLVL,"__VD_AutoflipOverlay: GetDriverLock succeeded."));


        // Find the current front surface.
        pCurSurf = pThisDisplay->VidPort.lpSurf [ pThisDisplay->VidPort.dwCurrentHostFrame ];

        P3TestDrawOverlay ( pThisDisplay, pCurSurf, TRUE );

        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)TRUE;

        // And then flip.
        // Fake up an LPDDHAL_FLIPVPORTDATA.
        // Only item ever used is lpDD.
        g_bFlipVideoPortDoingAutoflip = TRUE;
        ddhFVPD.lpDD = pCurSurf->lpSurfMore->lpDD_lcl;
        DdFlipVideoPort ( &ddhFVPD );
        g_bFlipVideoPortDoingAutoflip = FALSE;

        return ( GLDD_AUTO_RET_DID_UPDATE );
    }
    else
    {
        DISPDBG((DBGLVL,"ERROR:__VD_AutoflipOverlay: video port not active."));
        return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
    }
}





/****************************************************************************
 *
 * DWORD __VD_AutoupdateOverlay ( void );
 * 
 * In:
 *      None.
 * 
 * Out:
 *      Error code:
 *          GLDD_AUTO_RET_NO_UPDATE         = no need to do update.
 *          GLDD_AUTO_RET_DID_UPDATE        = did update.
 *          GLDD_AUTO_RET_ERR_GENERAL       = general error.
 *          GLDD_AUTO_RET_ERR_NO_OVERLAY    = no standard overlay(s).
 * 
 * Notes:
 *      This is called by the Demon helper program that sits waiting for
 * monitor VBLANKS, then calls this.
 *      This checks any non-autoflipping overlay(s), and if they have not
 * been flipped or updated this VBL, it redraws them. Then it resets the
 * VBL flags.
 * 
 ***************************************************************************/

DWORD CALLBACK __VD_AutoupdateOverlay ( void )
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL   pCurSurf;
    DWORD                       iRet;



    // This is hard-coded and doesn't on work multi-monitors.
    // But then nothing does, so...
    pThisDisplay = g_pDriverData;

    if ( pThisDisplay->VidPort.bActive )
    {
        // Video port is active.
        DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: video port is active."));
        return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
    }
    else
    {
        // Find the buffer to show.
        pCurSurf = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl;
        if ( pCurSurf == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: pCurSurf is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        if ( pCurSurf->lpGbl == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: lpGbl is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        lpDD = pCurSurf->lpGbl->lpDD;
        if ( lpDD == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: lpDD is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }

        // See if the overlay needs showing.
        if ( pThisDisplay->bOverlayFlippedThisVbl || pThisDisplay->bOverlayUpdatedThisVbl )
        {
            // Already done.
            pThisDisplay->bOverlayFlippedThisVbl = FALSE;
            pThisDisplay->bOverlayUpdatedThisVbl = FALSE;
            iRet = GLDD_AUTO_RET_NO_UPDATE;
        }
        else
        {

            // OK, draw this.
            P3TestDrawOverlay ( pThisDisplay, pCurSurf, TRUE );

            // And clear the flags.
            pThisDisplay->bOverlayFlippedThisVbl = FALSE;
            pThisDisplay->bOverlayUpdatedThisVbl = FALSE;
            iRet = GLDD_AUTO_RET_DID_UPDATE;

        }


        return ( iRet );
    }
}






/****************************************************************************
 *
 * void DrawOverlay (   P3_THUNKEDDATA* pThisDisplay,
 *                      LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay,
 *                      BOOL bSpeed );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;                 This display's pointer
 *      LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay;    The overlay surface to draw.
 *      BOOL bSpeed;                                TRUE if this is a speedy call.
 * 
 * Out:
 *      None.
 * 
 * Notes:
 *      Takes the data in pThisDisplay and draws lpSurfOverlay onto
 * its overlayed surface. All the other data comes from lpSurfOverlay.
 * This allows you to call this from Flip32() without kludging the source
 * surface pointer.
 *      This will find the cliprect list of the clipper attached to the
 * overlaid surface, clipped by the overlay rectangle.. If there is no
 * clipper, it just uses the rectangle of the overlay.
 *      The next operation depends on which colour keys are set:
 *      If no colour keys are set, the rects are just blitted on.
 *      If the destination colour key is set, three blits are done.
 * The first stretches the YUV buffer to its final size. The second converts
 * any of the given colour key to set its alpha bits. The third puts
 * the overlay surface onto the screen where the alpha bits have been set,
 * settign the alpha bits as it does so.
 *      If you cross your fingers and wish very very hard, this might
 * actually work. It depends on nothing writing anything but 0 to the
 * alpha bits, and on having alpha bits in the first place.
 *      bSpeed will be TRUE if we are aiming for out-and-out speed,
 * otherwise the aim is to look pretty with as few artefacts as possible.
 * Generally, speed tests are done single-buffered, so a call from
 * Unlock32() will pass TRUE. Pretty tests are done with single-buffering,
 * so Flip32() will pass FALSE. This is only a general guide, and some
 * apps don't know about double-buffering at all. Such is life.
 * 
 ***************************************************************************/

void DrawOverlay ( P3_THUNKEDDATA* pThisDisplay, LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay, BOOL bSpeed )
{

    RECTL                       rOverlay;
    RECTL                       rTemp;
    RECTL                       rFB;
    LPDDRAWI_DDRAWSURFACE_LCL   pOverlayLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pOverlayGbl;
    DDRAWI_DDRAWSURFACE_LCL     TempLcl;
    DDRAWI_DDRAWSURFACE_GBL     TempGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pFBLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pFBGbl;
    P3_SURF_FORMAT*               pFormatOverlay;
    P3_SURF_FORMAT*               pFormatTemp;
    P3_SURF_FORMAT*               pFormatFB;
    DWORD                       localfpVidMem;
    LONG                        localPitch;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    DWORD                       dwColourKeyValue;
    DWORD                       dwAlphaMask;
    DWORD                       windowBaseOverlay;
    DWORD                       windowBaseFB;
    DWORD                       windowBaseTemp;
    float                       OffsetX, OffsetY;
    float                       ScaleX, ScaleY;
    float                       fTemp;
    int                         NumRects;
    LPRECT                      lpCurRect;
    LPRGNDATA                   lpRgn;
    DWORD                       dwCurrentIndex, dwStartTime;
    DWORD                       xScale;
    DWORD                       yScale;
    DWORD                       DestWidth;
    DWORD                       DestHeight;
    DWORD                       SourceWidth;
    DWORD                       SourceHeight;
    DWORD                       LowerBound;
    DWORD                       UpperBound;
    RECT                        TempRect;



    P3_DMA_DEFS();

    // Find the clipping rectangles for the overlay.
    lpRgn = GetOverlayVisibleRects ( pThisDisplay );
    if ( lpRgn != NULL )
    {

        pOverlayLcl             = lpSurfOverlay;
        pFBLcl                  = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl;

        lpDD = lpSurfOverlay->lpGbl->lpDD;

        // Find the scale and offset from screen rects to overlay rects.
        ScaleX = (float)( pThisDisplay->OverlaySrcRectR - pThisDisplay->OverlaySrcRectL ) / (float)( pThisDisplay->OverlayDstRectR - pThisDisplay->OverlayDstRectL );
        ScaleY = (float)( pThisDisplay->OverlaySrcRectB - pThisDisplay->OverlaySrcRectT ) / (float)( pThisDisplay->OverlayDstRectB - pThisDisplay->OverlayDstRectT );
        OffsetX = ( (float)pThisDisplay->OverlaySrcRectL / ScaleX ) - (float)pThisDisplay->OverlayDstRectL;
        OffsetY = ( (float)pThisDisplay->OverlaySrcRectT / ScaleY ) - (float)pThisDisplay->OverlayDstRectT;

        rFB.left    = lpRgn->rdh.rcBound.left;
        rFB.right   = lpRgn->rdh.rcBound.right;
        rFB.top     = lpRgn->rdh.rcBound.top;
        rFB.bottom  = lpRgn->rdh.rcBound.bottom;

        // Find the size of the screen bounding box.
        if ( lpRgn->rdh.rcBound.left != (int)pThisDisplay->OverlayDstRectL )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.left  + OffsetX ) * ScaleX + 0.499f );
            myFtoi ( (int*)&(rOverlay.left), fTemp );
        }
        else
        {
            rOverlay.left = (int)pThisDisplay->OverlaySrcRectL;
        }

        if ( lpRgn->rdh.rcBound.right != (int)pThisDisplay->OverlayDstRectR )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.right + OffsetX ) * ScaleX + 0.499f );
            myFtoi ( (int*)&(rOverlay.right), fTemp );
        }
        else
        {
            rOverlay.right = (int)pThisDisplay->OverlaySrcRectR;
        }

        if ( lpRgn->rdh.rcBound.top != (int)pThisDisplay->OverlayDstRectT )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.top   + OffsetY ) * ScaleY + 0.499f );
            myFtoi ( (int*)&(rOverlay.top), fTemp );
        }
        else
        {
            rOverlay.top = (int)pThisDisplay->OverlaySrcRectT;
        }

        if ( lpRgn->rdh.rcBound.bottom = (int)pThisDisplay->OverlayDstRectB )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.bottom    + OffsetY ) * ScaleY + 0.499f );
            myFtoi ( (int*)&(rOverlay.bottom), fTemp );
        }
        else
        {
            rOverlay.bottom = pThisDisplay->OverlaySrcRectB;
        }


        // Sync with the specific source surface.

        // Videoport playing?
        if ( ( pThisDisplay->VidPort.bActive == TRUE ) &&
             ( ( pOverlayLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) != 0 ) )
        {

            dwStartTime = timeGetTime();
            while ( TRUE )
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
                {
                    // If the videoport is not stuck we are still drawing
                    if (!__VD_CheckVideoPortStatus(pThisDisplay, FALSE))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

                // Have we timed out?
                if ( ( timeGetTime() - dwStartTime ) > OVERLAY_VIDEO_PORT_TIMEOUT )
                {
                    return;
                }
            }
        }
        else
        {
            // Not a videoport blit, so wait for the framebuffer flip
            // status to be good.
//@@BEGIN_DDKSPLIT            
            // Not actually sure if we want this in or not.
//@@END_DDKSPLIT            
            {
                HRESULT ddrval;

                do
                {
                    ddrval = _DX_QueryFlipStatus(pThisDisplay, pFBLcl->lpGbl->fpVidMem, TRUE );
                }
                while ( ddrval != DD_OK );
            }
        }




        if ( pThisDisplay->OverlayDstColourKey != CLR_INVALID )
        {
            // This is destination colourkeyed.
            rTemp.left              = 0;
            rTemp.right             = rFB.right - rFB.left;
            rTemp.top               = 0;
            rTemp.bottom            = rFB.bottom - rFB.top;




            if ( pThisDisplay->OverlayUpdateCountdown != 0 )
            {
                pThisDisplay->OverlayUpdateCountdown -= OVERLAY_DRAWOVERLAY_SPEED;
                if ( !bSpeed )
                {
                    // This is a pretty call, not a fast one.
                    pThisDisplay->OverlayUpdateCountdown -= ( OVERLAY_DRAWOVERLAY_PRETTY - OVERLAY_DRAWOVERLAY_SPEED );
                }

                if ( ( (signed int)pThisDisplay->OverlayUpdateCountdown ) <= 0 )
                {
                    // Update the overlay.
                    UpdateAlphaOverlay ( pThisDisplay );

                    // If you set this to 0, the overlay will never update again
                    // until a SetOverlayPosition() or UpdateOverlay32()
                    // Otherwise, set it to a positive value to update every now
                    // and then.
                    pThisDisplay->OverlayUpdateCountdown = OVERLAY_CYCLE_WAIT;
                }
            }


            VALIDATE_MODE_AND_STATE(pThisDisplay);

            // First stop dual cursor accesses
            // Must be done before switching to DD context.
            STOP_SOFTWARE_CURSOR(pThisDisplay);
            // Switch to DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);


            DISPDBG((DBGLVL,"** In DrawOverlay"));

            pOverlayGbl     = pOverlayLcl->lpGbl;
            pFBGbl          = pFBLcl->lpGbl;

            pFormatOverlay  = _DD_SUR_GetSurfaceFormat(pOverlayLcl);
            pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);
            // Temp buffer will be same format as framebuffer.
            pFormatTemp     = pFormatFB;


            DISPDBG((DBGLVL, "Overlay Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pOverlayLcl);
            DISPDBG((DBGLVL, "FB Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);


            dwColourKeyValue = pThisDisplay->OverlayDstColourKey;
            switch ( pThisDisplay->bPixShift )
            {
                case GLINTDEPTH16:
                    if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
                    {
                        // 5551 format, as it should be.
                        dwAlphaMask = 0x8000;
                    }
                    else
                    {
                        // 565 format. Oops.
                        DISPDBG((WRNLVL, "** DrawOverlay error: called for a 565 surface"));
                        return;
                    }
                    break;
                case GLINTDEPTH32:
                    dwAlphaMask = 0xff000000;
                    break;
                case GLINTDEPTH8:
                case GLINTDEPTH24:
                default:
                    DISPDBG((WRNLVL, "** DrawOverlay error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
                    return;
                    break;
            }
        //  dwColourKeyValue &= ~dwAlphaMask;

            localfpVidMem = pThisDisplay->OverlayTempSurf.VidMem;
            localPitch = pThisDisplay->OverlayTempSurf.Pitch;
            if ( (void *)localfpVidMem == NULL )
            {
                // Nothing has been reserved for us! Panic stations!
                DISPDBG((ERRLVL,"ERROR: DrawOverlay has no temporary surface allocated."));
                return;
            }
            if ( localPitch < ( ( rTemp.right - rTemp.left ) << ( DDSurf_GetChipPixelSize(pFBLcl) ) ) )
            {
                // Reserved pitch is too small! Panic stations!
                DISPDBG((WRNLVL,"DrawOverlay has left,right %d,%d, and overlay has left,right %d,%d", rFB.left, rFB.right, pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectR ));
                DISPDBG((WRNLVL,"ERROR: DrawOverlay has pitch %d and should be at least %d", localPitch, ( ( rTemp.right - rTemp.left ) << ( DDSurf_GetChipPixelSize(pFBLcl) ) ) ));
                DISPDBG((ERRLVL,"ERROR: DrawOverlay has pitch too small to be right."));
                return;
            }

            // Set the surface up.
            TempLcl = *pFBLcl;
            TempGbl = *(pFBLcl->lpGbl);
            TempLcl.lpGbl = &TempGbl;
            TempGbl.fpVidMem = localfpVidMem;
            
            DDSurf_Pitch(&TempLcl) = localPitch;

            // get bpp and pitches for surfaces.
            windowBaseOverlay   = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pOverlayLcl);
            windowBaseFB        = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pFBLcl);
            windowBaseTemp      = __VD_PixelOffsetFromMemoryBase(pThisDisplay, &TempLcl);

            // Do the colourspace conversion and stretch/shrink of the overlay
            {
                DestWidth = rTemp.right - rTemp.left;
                DestHeight = rTemp.bottom - rTemp.top;
                SourceWidth = rOverlay.right - rOverlay.left;
                SourceHeight = rOverlay.bottom - rOverlay.top;

                xScale = (SourceWidth << 20) / DestWidth;
                yScale = (SourceHeight << 20) / DestHeight;
                
                P3_DMA_GET_BUFFER();
                P3_ENSURE_DX_SPACE(80);

                WAIT_FIFO(40);

                SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) |
                                    (SURFFORMAT_FORMAT_BITS(pFormatTemp) << PM_DITHERMODE_COLORFORMAT) |
                                    (SURFFORMAT_FORMATEXTENSION_BITS(pFormatTemp) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                    (1 << PM_DITHERMODE_ENABLE) |
                                    (2 << PM_DITHERMODE_FORCEALPHA) |
                                    (1 << PM_DITHERMODE_DITHERENABLE));

                SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize((&TempLcl)) );

                SEND_P3_DATA(FBWindowBase, windowBaseTemp);

                // set no read of source.
                SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((&TempLcl))));
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseOverlay);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode, PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                     PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );


                SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pOverlayLcl)) | 
                                                (DDSurf_GetChipPixelSize(pOverlayLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    // Turn on the YUV unit
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));
                    SEND_P3_DATA(YUVMode, 0x1);
                }
                else
                {
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));
                    // Shouldn't actually need this - it's the default setting.
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(LogicalOpMode, 0);

                // set offset of source
                SEND_P3_DATA(SStart,      rOverlay.left << 20);
                SEND_P3_DATA(TStart,      rOverlay.top<< 20);
                SEND_P3_DATA(dSdx,        xScale);
                SEND_P3_DATA(dSdyDom,     0);

                WAIT_FIFO(24);
                SEND_P3_DATA(dTdx,        0);
                SEND_P3_DATA(dTdyDom,     yScale);

                /*
                 * Render the rectangle
                 */
                SEND_P3_DATA(StartXDom, rTemp.left << 16);
                SEND_P3_DATA(StartXSub, rTemp.right << 16);
                SEND_P3_DATA(StartY,    rTemp.top << 16);
                SEND_P3_DATA(dY,        1 << 16);
                SEND_P3_DATA(Count,     rTemp.bottom - rTemp.top);
                SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

                SEND_P3_DATA(DitherMode, 0);

                // Turn off the YUV unit
                SEND_P3_DATA(YUVMode, 0x0);

                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_DISABLE));
                SEND_P3_DATA(TextureColorMode, PM_TEXCOLORMODE_ENABLE(__PERMEDIA_DISABLE));

                P3_DMA_COMMIT_BUFFER();
            }




            // Blit the expanded overlay to the framebuffer, colourkeying off the alpha.

            {

                // Select anything with full alpha.
                LowerBound = 0xff000000;
                UpperBound = 0xffffffff;

                P3_DMA_GET_BUFFER();

                P3_ENSURE_DX_SPACE(40);
                WAIT_FIFO(20);

                // don't need to twiddle the source (which is actually the framebuffer).
                SEND_P3_DATA(DitherMode,0);

                // Accept range, disable updates
                SEND_P3_DATA(YUVMode, (0x1 << 1)|0x20);



                // set a read of source.
                // Note - as we are enabling reads, we might have to do a WaitForCompleteion
                // (see the P2 Programmer's Reference Manual about the FBReamMode for more details.
                // but I think we should be OK - we are unlikely to have just written this data.
                SEND_P3_DATA(FBReadMode,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((&TempLcl)))) |
                                    PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE) );
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set FB write point
                SEND_P3_DATA(FBWindowBase, windowBaseFB);

                // set up FBWrite mode. This _must_ be done after setting up FBReadMode.
                SEND_P3_DATA(FBWriteConfig,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((pFBLcl)))));

                // offset the source point (point it at the temp thingie)
                SEND_P3_DATA(FBSourceOffset, windowBaseTemp - windowBaseFB - rFB.left - ( ( rFB.top * DDSurf_GetPixelPitch((&TempLcl)) ) ) );

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseFB);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                        PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );

                SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatFB))  |
                                                PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB)) |
                                                PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));

                SEND_P3_DATA(TextureMapFormat,    ((PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl)))) | 
                                                (DDSurf_GetChipPixelSize(pFBLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                SEND_P3_DATA(ChromaLowerBound, LowerBound);
                SEND_P3_DATA(ChromaUpperBound, UpperBound);


                SEND_P3_DATA(dSdx,      1 << 20);
                SEND_P3_DATA(dSdyDom,   0);
                SEND_P3_DATA(dTdx,      0);
                SEND_P3_DATA(dTdyDom,   1 << 20);
                SEND_P3_DATA(dY,        1 << 16);

                lpCurRect = (LPRECT)lpRgn->Buffer;
                NumRects = lpRgn->rdh.nCount;
                while ( NumRects > 0 )
                {
                    P3_ENSURE_DX_SPACE(14);
                    WAIT_FIFO(7);

                    SEND_P3_DATA(SStart,    lpCurRect->left << 20);
                    SEND_P3_DATA(TStart,    lpCurRect->top << 20);
//                  SEND_P3_DATA(dSdx,      1 << 20);
//                  SEND_P3_DATA(dSdyDom,   0);
//                  SEND_P3_DATA(dTdx,      0);
//                  SEND_P3_DATA(dTdyDom,   1 << 20);

                    SEND_P3_DATA(StartXDom, lpCurRect->left << 16);
                    SEND_P3_DATA(StartXSub, lpCurRect->right << 16);
                    SEND_P3_DATA(StartY,    lpCurRect->top << 16);
//                  SEND_P3_DATA(dY,        1 << 16);
                    SEND_P3_DATA(Count,     lpCurRect->bottom - lpCurRect->top);
                    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

                    // Next rect
                    NumRects--;
                    lpCurRect++;
                }

                P3_ENSURE_DX_SPACE(10);
                WAIT_FIFO(5);

                SEND_P3_DATA(DitherMode, 0);
                SEND_P3_DATA(YUVMode, 0x0);

                SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
                SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

                SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

                P3_DMA_COMMIT_BUFFER();
            }




        #ifdef WANT_DMA
            if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
            {
                // If we have queued up a DMA, we must send it now.
                P3_DMA_DEFS();
                P3_DMA_GET_BUFFER();
            
                // Flush DMA buffer
                P3_DMA_FLUSH_BUFFER();
            }
        #endif


            START_SOFTWARE_CURSOR(pThisDisplay);


        }
        else
        {
            // Not colourkeyed, so just blit directly to the screen.

            DISPDBG((DBGLVL,"** In DrawOverlay"));

            VALIDATE_MODE_AND_STATE(pThisDisplay);

            pOverlayGbl     = pOverlayLcl->lpGbl;
            pFBGbl          = pFBLcl->lpGbl;
            pFormatOverlay  = _DD_SUR_GetSurfaceFormat(pOverlayLcl);
            pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);
            // Temp buffer will be same format as framebuffer.


            DISPDBG((DBGLVL, "Overlay Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pOverlayLcl);
            DISPDBG((DBGLVL, "FB Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);

            // First stop dual cursor accesses
            STOP_SOFTWARE_CURSOR(pThisDisplay);
            // Switch to DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);

            windowBaseOverlay   = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pOverlayLcl);
            windowBaseFB        = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pFBLcl);

            {
                P3_DMA_GET_BUFFER();
                P3_ENSURE_DX_SPACE(70);

                WAIT_FIFO(16);

                SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) |
                                    (SURFFORMAT_FORMAT_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMAT) |
                                    (SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                    (1 << PM_DITHERMODE_ENABLE) |
                                    (1 << PM_DITHERMODE_DITHERENABLE));

                SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize((pFBLcl)) );

                SEND_P3_DATA(FBWindowBase, windowBaseFB);

                // set no read of source.
                SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((pFBLcl))));
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseOverlay);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                        PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );

                SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pOverlayLcl)) | 
                                                (DDSurf_GetChipPixelSize(pOverlayLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    // Turn on the YUV unit
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));
                    SEND_P3_DATA(YUVMode, 0x1);
                }
                else
                {
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));
                    // Shouldn't actually need this - it's the default setting.
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(LogicalOpMode, 0);


                // Constant values in the rectangle loop.
                SEND_P3_DATA(dSdyDom,   0);
                SEND_P3_DATA(dTdx,      0);
                SEND_P3_DATA(dY,        1 << 16);

                lpCurRect = (LPRECT)lpRgn->Buffer;
                NumRects = lpRgn->rdh.nCount;
                while ( NumRects > 0 )
                {
                    // Transform the source rect.
                    fTemp = ( ( (float)lpCurRect->left      + OffsetX ) * ScaleX + 0.499f );
                    myFtoi ( (int*)&(TempRect.left), fTemp );
                    fTemp = ( ( (float)lpCurRect->right + OffsetX ) * ScaleX + 0.499f );
                    myFtoi ( (int*)&(TempRect.right), fTemp );
                    fTemp = ( ( (float)lpCurRect->top       + OffsetY ) * ScaleY + 0.499f );
                    myFtoi ( (int*)&(TempRect.top), fTemp );
                    fTemp = ( ( (float)lpCurRect->bottom    + OffsetY ) * ScaleY + 0.499f );
                    myFtoi ( (int*)&(TempRect.bottom), fTemp );

                    xScale = ( ( TempRect.right - TempRect.left ) << 20) / ( lpCurRect->right - lpCurRect->left );
                    yScale = ( ( TempRect.bottom - TempRect.top ) << 20) / ( lpCurRect->bottom - lpCurRect->top );
                
                    P3_ENSURE_DX_SPACE(18);
                    WAIT_FIFO(9);

                    // set offset of source
                    SEND_P3_DATA(SStart,    TempRect.left << 20);
                    SEND_P3_DATA(TStart,    TempRect.top << 20);
                    SEND_P3_DATA(dSdx,      xScale);
//                  SEND_P3_DATA(dSdyDom,   0);
//                  SEND_P3_DATA(dTdx,      0);
                    SEND_P3_DATA(dTdyDom,   yScale);

                    SEND_P3_DATA(StartXDom, lpCurRect->left << 16);
                    SEND_P3_DATA(StartXSub, lpCurRect->right << 16);
                    SEND_P3_DATA(StartY,    lpCurRect->top << 16);
//                  SEND_P3_DATA(dY,        1 << 16);
                    SEND_P3_DATA(Count,     lpCurRect->bottom - lpCurRect->top);
                    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);


                    // Next rect
                    NumRects--;
                    lpCurRect++;
                }


                P3_ENSURE_DX_SPACE(10);
                WAIT_FIFO(5);

                SEND_P3_DATA(DitherMode, 0);

                // Turn off YUV conversion.
                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
                SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

                SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

                P3_DMA_COMMIT_BUFFER();
            }


            #ifdef WANT_DMA
            if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
            {
                // If we have queued up a DMA, we must send it now.
                P3_DMA_DEFS();
                P3_DMA_GET_BUFFER();
            
                if( (DWORD)dmaPtr != pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].VirtAddr ) 
                {
                    // Flush DMA buffer
                    P3_DMA_FLUSH_BUFFER();
                }
            }
            #endif


            START_SOFTWARE_CURSOR(pThisDisplay);

        }


        // And that's all.
    }




    return;
}





/****************************************************************************
 *
 * void UpdateAlphaOverlay ( P3_THUNKEDDATA* pThisDisplay );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;                 This display's pointer
 * 
 * Out:
 *      None.
 * 
 * Notes:
 *      Takes the data in pThisDisplay and changes everything of the right
 * colourkey to black with a full alpha, ready for calls to DrawOverlay()
 * 
 ***************************************************************************/

void UpdateAlphaOverlay ( P3_THUNKEDDATA* pThisDisplay )
{

    RECTL                       rFB;
    LPDDRAWI_DDRAWSURFACE_LCL   pFBLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pFBGbl;
    P3_SURF_FORMAT*               pFormatFB;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    DWORD                       dwColourKeyValue;
    DWORD                       dwAlphaMask;
    DWORD                       windowBaseFB;
    LONG                        lPixPitchFB;
    DWORD                       LowerBound;
    DWORD                       UpperBound;


    P3_DMA_DEFS();

    REPORTSTAT(pThisDisplay, ST_Blit, 1);

    rFB.left                = (LONG)pThisDisplay->OverlayDstRectL;
    rFB.right               = (LONG)pThisDisplay->OverlayDstRectR;
    rFB.top                 = (LONG)pThisDisplay->OverlayDstRectT;
    rFB.bottom              = (LONG)pThisDisplay->OverlayDstRectB;
    pFBLcl                  = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl;



    DISPDBG((DBGLVL,"** In UpdateAlphaOverlay"));

    VALIDATE_MODE_AND_STATE(pThisDisplay);


    pFBGbl          = pFBLcl->lpGbl;
    pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);


    DISPDBG((DBGLVL, "FB Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(10, pFBLcl);


    dwColourKeyValue = pThisDisplay->OverlayDstColourKey;
    switch ( pThisDisplay->bPixShift )
    {
        case GLINTDEPTH16:
            if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
            {
                // 5551 format, as it should be.
                dwAlphaMask = 0x8000;
            }
            else
            {
                // 565 format. Oops.
                DISPDBG((WRNLVL, "** DrawOverlay error: called for a 565 surface"));
                return;
            }
            break;
        case GLINTDEPTH32:
            dwAlphaMask = 0xff000000;
            break;
        case GLINTDEPTH8:
        case GLINTDEPTH24:
        default:
            DISPDBG((WRNLVL, "** DrawOverlay error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
            return;
            break;
    }
    dwColourKeyValue &= ~dwAlphaMask;


    lpDD = pFBLcl->lpGbl->lpDD;


    // First stop dual cursor accesses
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // get bpp and pitches for surfaces.
    lPixPitchFB = pFBGbl->lPitch;

    windowBaseFB = (pFBGbl->fpVidMem - pThisDisplay->dwScreenFlatAddr) >> DDSurf_GetPixelShift(pFBLcl);
    lPixPitchFB = lPixPitchFB >> DDSurf_GetPixelShift(pFBLcl);

    // Do the colourkey(no alpha) to colourkey+alpha blit.
    DISPDBG((DBGLVL, "Source Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);

    LowerBound = dwColourKeyValue;
    UpperBound = dwColourKeyValue;

    switch (pFormatFB->DeviceFormat)
    {
        case SURF_5551_FRONT:
            LowerBound = FORMAT_5551_32BIT_BGR(LowerBound);
            UpperBound = FORMAT_5551_32BIT_BGR(UpperBound);
            LowerBound = LowerBound & 0x00F8F8F8;   // Account for 'missing bits'
            UpperBound = UpperBound & 0x00FFFFFF;   // and vape any alpha
            UpperBound = UpperBound | 0x00070707;
            break;
        case SURF_8888:
            LowerBound = FORMAT_8888_32BIT_BGR(LowerBound);
            UpperBound = FORMAT_8888_32BIT_BGR(UpperBound);
            LowerBound = LowerBound & 0x00FFFFFF;   // Bin any alpha.
            UpperBound = UpperBound & 0x00FFFFFF;
            break;
        default:
            DISPDBG((WRNLVL,"** DrawOverlay: invalid source pixel format passed (DeviceFormat=%d)",pFormatFB->DeviceFormat));
            break;
    }

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(70);

    WAIT_FIFO(36);

//  if (DDSurf_GetChipPixelSize(pSrcLcl) != __GLINT_8BITPIXEL)
//  {
        SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                                 (SURFFORMAT_FORMAT_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMAT) |
                                 (SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                 (1 << PM_DITHERMODE_ENABLE));
//  }

    SEND_P3_DATA(FBReadPixel, pThisDisplay->bPixShift);

    // Accept range, disable updates
    SEND_P3_DATA(YUVMode, (0x1 << 1)|0x20);

    SEND_P3_DATA(FBWindowBase, windowBaseFB);

    // set the colour to be written (rather than the texture colour)
    // use the colour key with alpha set.
    SEND_P3_DATA(ConstantColor, ( LowerBound | 0xff000000 ) );
    // Enable colour, disable DDAs.
    SEND_P3_DATA(ColorDDAMode, 0x1);

    // Disable reads of FBsource or FBdest - all data comes from the texture unit.
    SEND_P3_DATA(FBReadMode,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl))));
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_P3_DATA(TextureBaseAddress, windowBaseFB);
    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
    
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

    SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                        PM_TEXREADMODE_WIDTH(11) |
                                        PM_TEXREADMODE_HEIGHT(11) );

    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatFB)) |
                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB)) |
                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));

    SEND_P3_DATA(TextureMapFormat,    ((PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl)))) | 
                                    (DDSurf_GetChipPixelSize(pFBLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );


    SEND_P3_DATA(ChromaLowerBound, LowerBound);
    SEND_P3_DATA(ChromaUpperBound, UpperBound);

    /*
     * Render the rectangle
     */
    // set offset of source
    SEND_P3_DATA(SStart,    rFB.left << 20);
    SEND_P3_DATA(TStart,    rFB.top << 20);
    SEND_P3_DATA(dSdx,      1 << 20);
    SEND_P3_DATA(dSdyDom,   0);
    SEND_P3_DATA(dTdx,      0);
    SEND_P3_DATA(dTdyDom,   1 << 20);

    // set destination
    SEND_P3_DATA(StartXDom, rFB.left << 16);
    SEND_P3_DATA(StartXSub, rFB.right << 16);
    SEND_P3_DATA(StartY,    rFB.top << 16);
    SEND_P3_DATA(dY,        1 << 16);
    SEND_P3_DATA(Count,     rFB.bottom - rFB.top);
    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

//  if (DDSurf_GetChipPixelSize(pSrcLcl) != __GLINT_8BITPIXEL)
//  {
        SEND_P3_DATA(DitherMode, 0);
//  }

    // Turn off chroma key and all the other unusual features
    SEND_P3_DATA(YUVMode, 0x0);
    SEND_P3_DATA(ColorDDAMode, 0x0);

    SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    P3_DMA_COMMIT_BUFFER();


#ifdef WANT_DMA
    if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
    {
        // If we have queued up a DMA, we must send it now.
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER();
    
        if( (DWORD)dmaPtr != pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].VirtAddr ) 
        {
            // Flush DMA buffer
            P3_DMA_FLUSH_BUFFER();
        }
    }
#endif


    START_SOFTWARE_CURSOR(pThisDisplay);


    return;
}


#endif  // W95_DDRAW_VIDEO
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT

void PermediaBltYUVRGB(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest, 
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    DDBLTFX* lpBltFX, 
    RECTL *rSrc,
    RECTL *rDest, 
    DWORD windowBase,
    DWORD SourceOffset)
{
    DWORD xScale;
    DWORD yScale;
    DWORD DestWidth = rDest->right - rDest->left;
    DWORD DestHeight = rDest->bottom - rDest->top;
    DWORD SourceWidth = rSrc->right - rSrc->left;
    DWORD SourceHeight = rSrc->bottom - rSrc->top;

    P3_DMA_DEFS();

    ASSERTDD(pDest, "Not valid surface in destination");
    ASSERTDD(pSource, "Not valid surface in source");

    xScale = (SourceWidth << 20) / DestWidth;
    yScale = (SourceHeight << 20) / DestHeight;
    
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(50);

    WAIT_FIFO(17);

    SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize(pDest));

    if (DDSurf_GetChipPixelSize(pSource) != __GLINT_8BITPIXEL)
    {
        SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                                 (SURFFORMAT_FORMAT_BITS(pFormatDest) << PM_DITHERMODE_COLORFORMAT) |
                                 (SURFFORMAT_FORMATEXTENSION_BITS(pFormatDest) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                 (1 << PM_DITHERMODE_ENABLE) |
                                 (1 << PM_DITHERMODE_DITHERENABLE));
    }

    SEND_P3_DATA(FBWindowBase, windowBase);

    // set no read of source.
    SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pDest)));
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_P3_DATA(TextureBaseAddress, SourceOffset);
    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
    
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

    SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                        PM_TEXREADMODE_WIDTH(11) |
                                        PM_TEXREADMODE_HEIGHT(11) );

    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatSource)) |
                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatSource)) |
                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));

    SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pSource)) | 
                                    (DDSurf_GetChipPixelSize(pSource) << PM_TEXMAPFORMAT_TEXELSIZE) );

    // Turn on the YUV unit
    SEND_P3_DATA(YUVMode, 0x1);

    SEND_P3_DATA(LogicalOpMode, 0);


    // set offset of source
    SEND_P3_DATA(SStart,    rSrc->left << 20);
    SEND_P3_DATA(TStart, (rSrc->top<< 20));
    SEND_P3_DATA(dSdx,      xScale);
    SEND_P3_DATA(dSdyDom, 0);

    WAIT_FIFO(14);
    SEND_P3_DATA(dTdx,        0);
    SEND_P3_DATA(dTdyDom, yScale);

    /*
     * Render the rectangle
     */
    SEND_P3_DATA(StartXDom, rDest->left << 16);
    SEND_P3_DATA(StartXSub, rDest->right << 16);
    SEND_P3_DATA(StartY,    rDest->top << 16);
    SEND_P3_DATA(dY,        1 << 16);
    SEND_P3_DATA(Count,     rDest->bottom - rDest->top);
    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

    if (DDSurf_GetChipPixelSize(pSource) != __GLINT_8BITPIXEL)
    {
        SEND_P3_DATA(DitherMode, 0);
    }

    // Turn off the YUV unit
    SEND_P3_DATA(YUVMode, 0x0);

    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_DISABLE));
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_DISABLE));
    SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    P3_DMA_COMMIT_BUFFER();
}

//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\directx.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: directx.h
*
* Content: DirectX macros and definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation
\**************************************************************************/

#ifndef __DIRECTX_H
#define __DIRECTX_H

#ifdef WNT_DDRAW
#include "dx95type.h"
#endif

#ifndef __GLINTDEF
#include "glintdef.h"
#endif

#include "pmdef.h"

#ifndef __P3RXDEF
#include "p3rxdef.h"
#endif

#include "surf_fmt.h"
#include "ddover.h"

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#define VTG_MEMORY_ADDRESS(a) (0x1000F | (((a >> 2) << 4) & 0xFFFF) )
#define VTG_VIDEO_ADDRESS(a) (0x20000 | (((a >> 2) << 4) & 0xFFFF) )
#define MEM_MEMORYSCRATCH 0x10
#define VID_SCREENBASE 0x0
#if DX7_STEREO
#define VID_VIDEOCONTROL        0x58
#define VID_SCREENBASERIGHT     0x80
#define __VIDEO_STEREOENABLE    0x800
#endif 

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#if !DBG
#define STOP_SOFTWARE_CURSOR(pThisDisplay)                           \
            pThisDisplay->pGLInfo->dwFlags |= GMVF_GCOP
#define START_SOFTWARE_CURSOR(pThisDisplay)                          \
            pThisDisplay->pGLInfo->dwFlags &= ~GMVF_GCOP
#else

#define STOP_SOFTWARE_CURSOR(pThisDisplay)                           \
{                                                                    \
    DISPDBG((DBGLVL, "STOP_SW_CURSOR %s %d", __FILE__, __LINE__ ));  \
    if (pThisDisplay->pGLInfo->dwFlags & GMVF_GCOP)                  \
        DISPDBG((WRNLVL,"Stopping Cursor that is already stopped!"));\
    pThisDisplay->pGLInfo->dwFlags |= GMVF_GCOP;                     \
}

#define START_SOFTWARE_CURSOR(pThisDisplay)                          \
{                                                                    \
    DISPDBG((DBGLVL, "START_SW_CURSOR %s, %d", __FILE__, __LINE__ ));\
    if (!(pThisDisplay->pGLInfo->dwFlags & GMVF_GCOP))               \
        DISPDBG((WRNLVL,"Starting Cursor that is already started!"));\
    pThisDisplay->pGLInfo->dwFlags &= ~GMVF_GCOP;                    \
}

#endif // !DBG

//------------------------------------------------------------------
//
//------------------------------------------------------------------
// From MS, undocumented sharing flag
#define HEAP_SHARED     0x04000000      // put heap in shared memory

//------------------------------------------------------------------
// Defines for video flipping, etc.
//------------------------------------------------------------------
#define IN_VBLANK                                                         \
        (pThisDisplay->pGlint->LineCount < pThisDisplay->pGlint->VbEnd)

#define IN_DISPLAY          (!IN_VBLANK)

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#if WNT_DDRAW

#define DXCONTEXT_IMMEDIATE(pThisDisplay)                           \
    vGlintSwitchContext(pThisDisplay->ppdev,                        \
                        pThisDisplay->ppdev->DDContextID);
                        
#define IS_DXCONTEXT_CURRENT(pThisDisplay)                          \
        (((pThisDisplay->ppdev->currentCtxt) !=                     \
          (pThisDisplay->ppdev->DDContextID)) ? FALSE : TRUE)
           
#else   //  WNT_DDRAW

#define DXCONTEXT_IMMEDIATE(pThisDisplay)             \
    ChangeContext(pThisDisplay,                       \
                  pThisDisplay->pGLInfo,              \
                  CONTEXT_DIRECTX_HANDLE); 

#define IS_DXCONTEXT_CURRENT(pThisDisplay)                                   \
    ((pThisDisplay->pGLInfo->dwCurrentContext != CONTEXT_DIRECTX_HANDLE) ?   \
                                                                FALSE : TRUE)
#endif  //  WNT_DDRAW

//------------------------------------------------------------------
// For comparing GUID's
//------------------------------------------------------------------
#ifdef __cplusplus
#define MATCH_GUID(a, b) IsEqualIID((a), (b))
#else
#define MATCH_GUID(a, b) IsEqualIID(&(a), &(b))
#endif



//------------------------------------------------------------------
// Registry
//------------------------------------------------------------------
#ifdef WNT_DDRAW
#define GET_REGISTRY_ULONG_FROM_STRING(a, b)                             \
    bGlintQueryRegistryValueUlong(pThisDisplay->ppdev, L##a, (DWORD*)b)
#define SET_REGISTRY_STRING_FROM_ULONG(a, b)                             \
    bGlintSetRegistryValueString(pThisDisplay->ppdev, L##a, b)
#define GET_REGISTRY_STRING(a, b)                                        \
    bGlintQueryRegistryValueString(pThisDisplay->ppdev, L##a, b, c)
#else
// Win95 calls the same registry call as it always did, 
// NT makes the call with an extra parameter - the ppdev
BOOL bGlintQueryRegistryValueString(LPTSTR valueStr, 
                                    char* pString, 
                                    int StringLen);
BOOL bGlintQueryRegistryValueUlong(LPTSTR valueStr, 
                                   PULONG pData);
BOOL bGlintQueryRegistryValueUlongAsUlong(LPTSTR valueStr, 
                                          PULONG pData);
BOOL bGlintSetRegistryValueString(LPTSTR valueStr, 
                                  ULONG Data);

#define GET_REGISTRY_ULONG_FROM_STRING(a, b)                             \
    bGlintQueryRegistryValueUlong(a, (DWORD*)b)
#define GET_REGISTRY_STRING(a, b)                                        \
    bGlintQueryRegistryValueString(a, b, strlen(a))
#define SET_REGISTRY_STRING_FROM_ULONG(a, b)                             \
    bGlintSetRegistryValueString(a, b)

#endif // WNT_DDRAW

//------------------------------------------------------------------
// Memory Allocation calls 
//------------------------------------------------------------------
#ifdef WNT_DDRAW

#define HEAP_ALLOC(flags, size, tag) ENGALLOCMEM(FL_ZERO_MEMORY, size, tag)
#define HEAP_FREE(ptr)               ENGFREEMEM(ptr)

// Shared memory allocation calls. On NT , the 16 bit ptr is irrelevant and
// the call is resolved as a normal call to HEAP_ALLOC/HEAP_FREE
// The 16 bit ptrs are alwasy defined as DWORD and the 32 bit as ULONG_PTR
__inline void SHARED_HEAP_ALLOC(DWORD *ppData16,
                                ULONG_PTR* ppData32, 
                                DWORD size)
{                                                                
    *ppData32 = (ULONG_PTR) HEAP_ALLOC(FL_ZERO_MEMORY,           
                                       size ,                    
                                       ALLOC_TAG_DX(S));            
    *ppData16 = (DWORD)(*ppData32);                                
}    

__inline void SHARED_HEAP_FREE(DWORD *ppData16,
                               ULONG_PTR * ppData32, 
                               BOOL bZero)   
{                                               
    HEAP_FREE((PVOID)(*ppData32));            

    if (bZero)
    {
        *ppData32 = 0;                              
        *ppData16 = 0;                              
    }
}    

#else

#define FL_ZERO_MEMORY  HEAP_ZERO_MEMORY

#define HEAP_ALLOC(flags, size, tag)                               \
            HeapAlloc((HANDLE)g_DXGlobals.hHeap32, flags, size)
#define HEAP_FREE(ptr)                                             \
            HeapFree((HANDLE)g_DXGlobals.hHeap32, 0, ptr)

BOOL SharedHeapAlloc(DWORD* ppData16, ULONG_PTR* ppData32, DWORD size);
void SharedHeapFree(DWORD ptr16, ULONG_PTR ptr32);

// Shared memory allocation calls. On Win9x , the 16 bit ptr is important.
// We map this calls to some Win9x specific code
#define SHARED_HEAP_ALLOC( ppData16, ppData32, size)             \
            SharedHeapAlloc(ppData16, ppData32, size);

#define SHARED_HEAP_FREE( ppData16, ppData32, bZero)        \
{                                                           \
    SharedHeapFree(*(ppData16), *(ppData32));               \
    if (bZero)                                              \
    {                                                       \
        *ppData32 = 0;                                      \
        *ppData16 = 0;                                      \
    }                                                       \
}

#endif // WNT_DDRAW

//------------------------------------------------------------------
// Display driver's DC
//------------------------------------------------------------------
// Allows us to get the display driver's DC at any point.
// CREATE_DRIVER_DC must be matched by a DELETE_DRIVER_DC.
#define CREATE_DRIVER_DC(pGLInfo) (                                     \
    ( ( (pGLInfo)->szDeviceName[7] == '\0' ) &&                         \
        ( (pGLInfo)->szDeviceName[6] == 'Y' ) &&                        \
        ( (pGLInfo)->szDeviceName[5] == 'A' ) &&                        \
        ( (pGLInfo)->szDeviceName[4] == 'L' ) &&                        \
        ( (pGLInfo)->szDeviceName[3] == 'P' ) &&                        \
        ( (pGLInfo)->szDeviceName[2] == 'S' ) &&                        \
        ( (pGLInfo)->szDeviceName[1] == 'I' ) &&                        \
        ( (pGLInfo)->szDeviceName[0] == 'D' ) ) ?                       \
    /* The Win95 and NT4-compatible version */                          \
    ( CreateDC ( "DISPLAY", NULL, NULL, NULL ) ) :                      \
    /* The Win98 and NT5-compatible multimon version */                 \
    ( CreateDC ( NULL, (pGLInfo)->szDeviceName, NULL, NULL ) )          \
    )

#define DELETE_DRIVER_DC(hDC) DeleteDC(hDC)

//------------------------------------------------------------------
// Macro to define a FOURCC.
// Needed on NT builds.  On Win9x it comes from the DDK.
//------------------------------------------------------------------
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

// For the video
#define FOURCC_YUV422  (MAKEFOURCC('Y','U','Y','2'))
#define FOURCC_YUV411  (MAKEFOURCC('Y','4','1','1'))

// Mediamatics private 4CC's
#define FOURCC_MVCA    (MAKEFOURCC('M','V','C','A'))
#define FOURCC_MVSU    (MAKEFOURCC('M','V','S','U'))
#define FOURCC_MVSB    (MAKEFOURCC('M','V','S','B'))


//------------------------------------------------------------------

//------------------------------------------------------------------
#define PACKED_PP_LOOKUP(a) (pThisDisplay->PPCodes[(a) >> 5] & 0x1FF)
#define PACKED_PP_LOOKUP4(a) (pThisDisplay->PPCodes[(a) >> 5])
#define PP0_LOOKUP(a) (PACKED_PP_LOOKUP(a) & 0x7)
#define PP1_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 3) & 0x7)
#define PP2_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 6) & 0x7)
#define PP3_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 9) & 0x7)

//------------------------------------------------------------------
// Globals that are truly global across multiple displays
//------------------------------------------------------------------
typedef enum tagPixelCenterSetting
{
    PIXELCENTER_ZERO,
    PIXELCENTER_NEARLY_HALF,
    PIXELCENTER_HALF,
    PIXELCENTER_FORCE_DWORD = 0xFFFFFFFF
} PixelCenterSetting;

typedef struct tagDirectXGlobals {
    // State
    HINSTANCE           hInstance;              // Instance handle for this DLL
    DWORD               hHeap32;                // Shared 32 bit heap
} DirectXGlobals;

// There is one global structure in the driver.  This is shared across 
// all applications and all cards.  It holds data such as the current 
// driver settings and a handle to the memory heap that is used within 
// the driver. There is also a global pointer that points at the current 
// primary display

extern DirectXGlobals   g_DXGlobals;

//------------------------------------------------------------------
// Driver thunked data
//------------------------------------------------------------------
#if W95_DDRAW
extern P3_THUNKEDDATA* g_pDriverData;
#endif

extern struct tagThunkedData* g_pThisTemp;


#if WNT_DDRAW

#define GET_THUNKEDDATA(pThisDisplay,a)                                  \
{                                                                        \
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV) ((a)->dhpdev))->thunkData);\
}

#else   //  WNT_DDRAW

#if !DBG

#define GET_THUNKEDDATA(pThisDisplay,a)                          \
{                                                                \
    if ((a)->dwReserved3)                                        \
    {                                                            \
        pThisDisplay = (P3_THUNKEDDATA*)(a)->dwReserved3;        \
    }                                                            \
    else                                                         \
    {                                                            \
        pThisDisplay = g_pDriverData;                            \
    }                                                            \
}

#else

#define GET_THUNKEDDATA(pThisDisplay,a)                            \
{                                                                  \
    if ((a)->dwReserved3)                                          \
    {                                                              \
        pThisDisplay = (P3_THUNKEDDATA*)(a)->dwReserved3;          \
        DISPDBG((DBGLVL,"Secondary Display: DevHandle=0x%x",       \
        pThisDisplay->pGLInfo->dwDeviceHandle));                   \
    }                                                              \
    else                                                           \
    {                                                              \
        pThisDisplay = g_pDriverData;                              \
        DISPDBG((DBGLVL,"Primary Display DevHandle=0x%x",          \
        pThisDisplay->pGLInfo->dwDeviceHandle));                   \
    }                                                              \
}

#endif // !DBG
#endif  //  WNT_DDRAW



//------------------------------------------------------------------
//
//------------------------------------------------------------------
#define PATCH_SELECTIVE 0
#define PATCH_ALWAYS 1
#define PATCH_NEVER 2


//------------------------------------------------------------------
// Color format conversion macros 
//------------------------------------------------------------------
#define FORMAT_565_32BIT(val)           \
( (((val & 0xF800) >> 8) << 16) |       \
  (((val &  0x7E0) >> 3) <<  8) |       \
  (((val &   0x1F) << 3)      )   )

#define FORMAT_565_32BIT_BGR(val)     \
( (((val & 0xF800) >>  8)     ) |     \
  (((val &  0x7E0) >>  3) << 8) |     \
  (((val &   0x1F) << 19)     )    )

#define FORMAT_565_32BIT_ZEROEXTEND(val)  \
( (((val & 0xF800) >> 11)     ) |         \
  (((val &  0x7E0) >>  3) << 6) |         \
  (((val &   0x1F) << 16) )   )

#define FORMAT_5551_32BIT(val)      \
( (((val & 0x8000) >> 8) << 24) |   \
  (((val & 0x7C00) >> 7) << 16) |   \
  (((val &  0x3E0) >> 2) << 8 ) |   \
  (((val &   0x1F) << 3)      ) )

#define FORMAT_5551_32BIT_BGR(val)  \
( (((val & 0x8000) >> 8) << 24) |   \
  (((val & 0x7C00) >> 7)      ) |   \
  (((val &  0x3E0) >> 2) << 8 ) |   \
  (((val &   0x1F) <<19)      )  )

#define FORMAT_5551_32BIT_ZEROEXTEND(val)   \
( (((val & 0x8000) <<  9 )     ) |          \
  (((val & 0x7C00) >> 10 )     ) |          \
  (((val &  0x3E0) >>  2 ) << 5) |          \
  (((val &   0x1F) << 16 )     )    )

#define FORMAT_4444_32BIT(val)        \
( (((val & 0xF000) << 16)      ) |    \
  (((val &  0xF00) >>  4) << 16) |    \
  (((val &   0xF0) <<  8)      ) |    \
  (((val &    0xF) <<  4)      ) )

#define FORMAT_4444_32BIT_BGR(val)  \
( ((val & 0xF000) << 16) |          \
  ((val &  0xF00) >>  4) |          \
  ((val &   0xF0) <<  8) |          \
  ((val &    0xF) << 20) )

#define FORMAT_4444_32BIT_ZEROEXTEND(val)   \
( ((val & 0xF000) << 12) |                  \
  ((val &  0xF00) >>  8) |                  \
  ((val &   0xF0) <<  4) |                  \
  ((val &    0xF) << 16) )

#define FORMAT_332_32BIT(val)     \
( (((val & 0xE0) << 16)     ) |   \
  (((val & 0x1C) <<  3) << 8) |   \
  (((val &  0x3) <<  6)     ) )

#define FORMAT_332_32BIT_BGR(val)   \
( (((val & 0xE0)      )     ) |     \
  (((val & 0x1C) <<  3) << 8) |     \
  (((val &  0x3) << 22)     )   )

#define FORMAT_332_32BIT_ZEROEXTEND(val)    \
( (((val & 0xE0) >>  5)     ) |             \
  (((val & 0x1C) <<  3) << 3) |             \
  (((val &  0x3) << 16))    )

#define FORMAT_2321_32BIT(val)   \
( (((val & 0x80) << 24)     ) |  \
  (((val & 0x60) << 17)     ) |  \
  (((val & 0x1C) <<  3) << 8) |  \
  (((val &  0x3) <<  6)     ) ) 

#define FORMAT_2321_32BIT_BGR(val)  \
( (((val & 0x80) << 24)     ) |     \
  (((val & 0x60) <<  1)     ) |     \
  (((val & 0x1C) <<  3) << 8) |     \
  (((val &  0x3) << 22)     ))

#define FORMAT_2321_32BIT_ZEROEXTEND(val)  \
( (((val & 0x80) << 17)     ) |            \
  (((val & 0x60) >>  5)     ) |            \
  (((val & 0x1C) <<  3) << 3) |            \
  (((val &  0x3) << 16)     ) )

#define FORMAT_8888_32BIT_BGR(val)  \
( ((val & 0xFF00FF00)      ) |      \
  ((val &   0xFF0000) >> 16) |      \
  ((val &       0xFF) << 16) ) 

#define FORMAT_888_32BIT_BGR(val)   \
( ((val & 0xFF00FF00)      ) |      \
  ((val &   0xFF0000) >> 16) |      \
  ((val &       0xFF) << 16) )

#define CHROMA_UPPER_ALPHA(val) \
    (val | 0xFF000000)

#define CHROMA_LOWER_ALPHA(val) \
    (val & 0x00FFFFFF) 

#define CHROMA_332_UPPER(val)   \
    (val | 0x001F1F3F)

#define FORMAT_PALETTE_32BIT(val) \
    ( ((val & 0xFF)      ) |      \
      ((val & 0xFF) <<  8) |      \
      ((val & 0xFF) << 16))

//------------------------------------------------------------------
// Macros for handling Render IDs.
//------------------------------------------------------------------
#if 1
// The real values
#define RENDER_ID_KNACKERED_BITS   0x00000000
#define RENDER_ID_VALID_BITS_UPPER 0x00000000
#define RENDER_ID_VALID_BITS_LOWER 0xffffffff
#define RENDER_ID_VALID_BITS_UPPER_SHIFT 0
#define RENDER_ID_VALID_BITS_SIGN_SHIFT 0
#define RENDER_ID_LOWER_LIMIT -100
#define RENDER_ID_UPPER_LIMIT 65000

#define RENDER_ID_REGISTER_NAME MemScratch

#else

// For soak-testing - should catch wrap errors much more quickly.
// Also tests the mechanism that copes with dodgy bits in the
// register (P2 MinRegion legacy stuff, but it's free to support).
#define RENDER_ID_KNACKERED_BITS 0xfff0fff0
#define RENDER_ID_VALID_BITS_UPPER 0x000f0000
#define RENDER_ID_VALID_BITS_LOWER 0x0000000f
#define RENDER_ID_VALID_BITS_UPPER_SHIFT 12
#define RENDER_ID_VALID_BITS_SIGN_SHIFT 24
#define RENDER_ID_LOWER_LIMIT -20
#define RENDER_ID_UPPER_LIMIT 100

#endif

//------------------------------------------------------------------
// Flipping compile time switches
//------------------------------------------------------------------
    
#if WNT_DDRAW
// Can't use timeGetTime under WinNT
// We should try to backoff using something else instead, but...
#define USE_FLIP_BACKOFF 0
#else
// Set this to 1 to enable the back-off code for flips and locks.
// On some things it's faster, on some things it's slower - tune as desired.
#define USE_FLIP_BACKOFF 1
#endif

// Get a new render ID. Need to do the OR afterwards to make
// sure the +1 gets the bits carried up properly next time.
// No need to do the OR before, because we assume dwRenderID is
// always a "valid" number, with those bits set.
#define GET_NEW_HOST_RENDER_ID() ( pThisDisplay->dwRenderID = ( pThisDisplay->dwRenderID + 1 ) | RENDER_ID_KNACKERED_BITS, pThisDisplay->dwRenderID )
// Get render ID of last operation.
#define GET_HOST_RENDER_ID() ( pThisDisplay->dwRenderID )

// Send this ID to the chip (do just after the render command).
//#define SEND_HOST_RENDER_ID(my_id) SEND_P3_DATA(RENDER_ID_REGISTER_NAME,(my_id))

#define SEND_HOST_RENDER_ID(my_id)                                              \
        SEND_P3_DATA(VTGAddress, VTG_MEMORY_ADDRESS(MEM_MEMORYSCRATCH));        \
        SEND_P3_DATA(VTGData, my_id)

// Read the current ID from the chip.
#define GET_CURRENT_CHIP_RENDER_ID() ( READ_GLINT_CTRL_REG(RENDER_ID_REGISTER_NAME) | RENDER_ID_KNACKERED_BITS )
// Is the RenderID value on the chip valid?
#define CHIP_RENDER_ID_IS_VALID() ( (BOOL)pThisDisplay->bRenderIDValid )

// Do a render ID comparison. RenderIDs wrap, so you have
// to do the subtraction and _then_ test the top bit,
// not do the comparison between the two directly.
// think about a=0xfffffffe and b=0x1, and then
// about a=0x7ffffffe and b=0x80000001.
// If the two are more than 0x80000000 apart, then this
// will give the wrong result, but that's a _lot_ of renders.
// At a render every 1us (1MHz), that's still about 35 minutes.
// Bear in mind, a render is a sequence of polygons, not just one.
// If apps do as we suggest and send about 50 tris per render, and
// if they manage to get 8million tris a second troughput
// they get about 3.7 hours before wrapping.
// If this really is a problem, just extend it to 64 bits using
// MaxRegion as well.
// On P2, we only have 24 useable bits, so the wrap will happen
// sooner - every 52 seconds. However, this should at the very
// worst cause a few more SYNCs than necessary, even if it does
// go wrong. Use the above "debug" settings to do soak-testing -
// they make only 8 bits valid.
#define RENDER_ID_LESS_THAN(a,b) ( (signed)(a-b) < 0 )

// Decide if a render has finished.
#if !DBG
#define RENDER_ID_HAS_COMPLETED(my_id) ( !RENDER_ID_LESS_THAN ( (GET_CURRENT_CHIP_RENDER_ID()), (my_id) ) )
#else
// A version that is rather more paranoid about correct values.
// It's instantiated in gldd32.c
BOOL HWC_bRenderIDHasCompleted ( DWORD dwID, P3_THUNKEDDATA* pThisDisplay );
#define RENDER_ID_HAS_COMPLETED(my_id) ( HWC_bRenderIDHasCompleted ( (my_id), pThisDisplay ) )
#endif // !DBG

// This should be called once RENDER_ID_HAS_COMPLETED has failed,
// just in case a wrap-round bug has occurred. If it's true, the
// chip needs to be synced, and the surface RenderIDs updated with 
// GET_HOST_RENDER_ID(). This is fairly slow,
// but that's OK, since most things that use RENDER_ID_HAS_COMPLETED
// will start spinning when it fails anyway (locks, flips, etc).
// Note that just re-syncing every time the wrap-around
// happens is not enough - we need to bring the surface
// up to date as well, so this is just as efficient
// as always resyncing, and usually faster.
// This should also never happen in real-life, but it's a
// safety net in case it does. The soak-test settings should be
// aggressive enough to force it to happen.
#define NEED_TO_RESYNC_CHIP_AND_SURFACE(my_id) ( RENDER_ID_LESS_THAN ( GET_HOST_RENDER_ID(), (my_id) ) )

// Set/get a surface's read-from/written-to render ID.
#define SET_SIB_RENDER_ID_WRITE(lpSIB,my_id) (lpSIB)->dwRenderIDWrite = (my_id)
#define SET_SIB_RENDER_ID_READ(lpSIB,my_id) (lpSIB)->dwRenderIDRead = (my_id)
#define GET_SIB_RENDER_ID_WRITE(lpSIB) ((lpSIB)->dwRenderIDWrite)
#define GET_SIB_RENDER_ID_READ(lpSIB) ((lpSIB)->dwRenderIDRead)
#define SIB_WRITE_FINISHED(lpSIB) ( RENDER_ID_HAS_COMPLETED ( GET_SIB_RENDER_ID_WRITE ( lpSIB ) ) )
#define SIB_READ_FINISHED(lpSIB) ( RENDER_ID_HAS_COMPLETED ( GET_SIB_RENDER_ID_READ ( lpSIB ) ) )

//------------------------------------------------------------------
// Macros for determining DDraw surface characteristics
//------------------------------------------------------------------
#define DDSurf_Width(lpLcl)  ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_Pitch(lpLcl)  ( (lpLcl)->lpGbl->lPitch)
#define DDSurf_dwCaps(lpLcl) ( (lpLcl)->ddsCaps.dwCaps)

#if WNT_DDRAW

#define DDSurf_IsAGP(lpLcl)                                           \
        ( ((lpLcl)->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) ? 1 : 0 ) 

#define DDSurf_HasPixelFormat(dwFlags)    (1)

#define DDSurf_BitDepth(lpLcl)                                         \
                        ((lpLcl)->lpGbl->ddpfSurface.dwRGBBitCount)
                        
#define DDSurf_AlphaBitDepth(lpLcl)                                    \
                        ((lpLcl)->lpGbl->ddpfSurface.dwAlphaBitDepth)
                        
#define DDSurf_RGBAlphaBitMask(lpLcl)                                  \
                        ((lpLcl)->lpGbl->ddpfSurface.dwRGBAlphaBitMask)
                        
#define DDSurf_GetPixelFormat(lpLcl)                                   \
                        (&(lpLcl)->lpGbl->ddpfSurface)
#else

#define DDSurf_HasPixelFormat(dwFlags)                                  \
        ((dwFlags & DDRAWISURF_HASPIXELFORMAT) ? 1 : 0)
        
#define DDSurf_IsAGP(lpLcl)                                             \
        ( ((lpLcl)->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) ? 1 : 0 ) 

#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)pdds)->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)pdds)->lpLcl)

#define DDSurf_BitDepth(lpLcl)                                  \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?          \
      ((lpLcl)->lpGbl->ddpfSurface.dwRGBBitCount) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )

#define DDSurf_AlphaBitDepth(lpLcl)                               \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?            \
      ((lpLcl)->lpGbl->ddpfSurface.dwAlphaBitDepth) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwAlphaBitDepth) \
    )

#define DDSurf_RGBAlphaBitMask(lpLcl)                               \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?              \
      ((lpLcl)->lpGbl->ddpfSurface.dwRGBAlphaBitMask) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBAlphaBitMask) \
    )

#define DDSurf_GetPixelFormat(lpLcl)                  \
    (((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
     (&(lpLcl)->lpGbl->ddpfSurface) :                 \
     (&(lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay)     \
    )
#endif  

// Function to return the correct entry in the lookup table
P3_SURF_FORMAT* _DD_SUR_GetSurfaceFormat(LPDDRAWI_DDRAWSURFACE_LCL pLcl);

static DWORD ShiftLookup[5] = { 0, 0, 1, 0, 2};
#define DDSurf_GetPixelShift(a)                      \
        (ShiftLookup[(DDSurf_BitDepth(a) >> 3)])

#define DDSurf_GetPixelToDWORDShift(pSurfLcl)                              \
                (2 - DDSurf_GetPixelShift(pSurfLcl))

#define DDSurf_GetPixelPitch(pSurfLcl)                                     \
    ((DDSurf_BitDepth(pSurfLcl) == 24) ?                                   \
            (DDSurf_Pitch(pSurfLcl) / 3) :                                 \
     (DDSurf_BitDepth(pSurfLcl) == 4) ?                                    \
            (DDSurf_Pitch(pSurfLcl) * 2) :                                 \
            (DDSurf_Pitch(pSurfLcl) >> DDSurf_GetPixelShift(pSurfLcl)))

#define DDSurf_GetByteWidth(pSurfLcl)                                      \
    ((DDSurf_BitDepth(pSurfLcl) == 24) ?                                   \
            (DDSurf_Width(pSurfLcl) * 3) :                                 \
     (DDSurf_BitDepth(pSurfLcl) == 4) ?                                    \
            (DDSurf_Width(pSurfLcl) / 2) :                                 \
            (DDSurf_Width(pSurfLcl) << DDSurf_GetPixelShift(pSurfLcl)))

#define DDSurf_FromInt(pSurfInt)                                             \
    ((LPDDRAWI_DDRAWSURFACE_LCL)((LPDDRAWI_DDRAWSURFACE_INT)pSurfInt)->lpLcl)

// 4bpp = 3, 8bpp = 0, 16bpp = 1, 24bpp = 4, 32bpp = 2
static DWORD ChipPixelSize[9] = { 0, 3, 0, 0, 1, 0, 4, 0, 2 };
#define DDSurf_GetChipPixelSize(pSurf)                    \
            (ChipPixelSize[(DDSurf_BitDepth(pSurf) >> 2)])

#define DDSurf_GetBppMask(pSurfLcl)                       \
            (3 >> (DDSurf_GetChipPixelSize(pSurfLcl)))

// Calculates the offset of this agp surface from the base of the agp region
unsigned long __inline 
DDSurf_SurfaceOffsetFromAGPBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    unsigned long ulOffset;

    ASSERTDD(pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM, 
             "ERROR: DDSurf_SurfaceOffsetFromAGPBase passed non AGP surface");

#if WNT_DDRAW
    // The offset into AGP memory can't be more than 4GB! //azn - check this
    ulOffset = (DWORD)(pLcl->lpGbl->fpHeapOffset - 
                       pLcl->lpGbl->lpVidMemHeap->fpStart);
#else
    ulOffset = (SURFACE_PHYSICALVIDMEM(pLcl->lpGbl) - 
                                pThisDisplay->dwGARTDevBase);
#endif

    return ulOffset;
    
} // DDSurf_SurfaceOffsetFromAGPBase

// Calculates the offset of this surface from the base of the memory as 
// the chip sees it.  For AGP this is the currently scrolled window 
// position on P2, and on P3 it is the real physical memory address
long __inline 
DDSurf_SurfaceOffsetFromMemoryBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    long lOffset;

#if WNT_DDRAW
    if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) //azn
    {
        DISPDBG((DBGLVL,"HeapOffset: 0x%x, fpStart: 0x%x", 
                        pLcl->lpGbl->fpHeapOffset, 
                        pLcl->lpGbl->lpVidMemHeap->fpStart));

        if (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
        {
            // Return the offset into the heap, accounting for the adjustment 
            // we might have made to the base
            lOffset = ((long)pLcl->lpGbl->fpHeapOffset      - 
                       (long)pLcl->lpGbl->lpVidMemHeap->fpStart) +
                                 ((long)pThisDisplay->dwGARTDevBase);
        }
        else
        {
            // Return the offset into the heap, accounting for the adjustment 
            // we might have made to the base
            lOffset = ((long)pLcl->lpGbl->fpHeapOffset      - 
                       (long)pLcl->lpGbl->lpVidMemHeap->fpStart) - 
                      ((long)pThisDisplay->dwGARTDev        - 
                       (long)pThisDisplay->dwGARTDevBase );
        }
    }
    else
    {
        lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                   (long)pThisDisplay->dwScreenFlatAddr);
    }
#else
    if (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            lOffset = (long)SURFACE_PHYSICALVIDMEM(pLcl->lpGbl);
        }
        else
        {
            lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                       (long)pThisDisplay->dwScreenFlatAddr);
        }
    }
    else
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            lOffset = ((long)SURFACE_PHYSICALVIDMEM(pLcl->lpGbl) - 
                       (long)pThisDisplay->dwGARTDev);
        }
        else
        {
            lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                       (long)pThisDisplay->dwScreenFlatAddr);
        }
    }
#endif // WNT_DDRAW

    return lOffset;
    
} // DDSurf_SurfaceOffsetFromMemoryBase


//------------------------------------------------------------------
// Function to send a command to the VXD.
//------------------------------------------------------------------
#if W95_DDRAW
BOOL VXDCommand(DWORD dwCommand, 
                void* pIn, 
                DWORD dwInSize, 
                void* pOut, 
                DWORD dwOutSize);
#endif

//------------------------------------------------------------------
// DirectDraw Callbacks
//------------------------------------------------------------------
DWORD CALLBACK DdCanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd );
DWORD CALLBACK DdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd );
DWORD CALLBACK DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd );
DWORD CALLBACK DdBlt( LPDDHAL_BLTDATA lpBlt );
DWORD CALLBACK UpdateOverlay32(LPDDHAL_UPDATEOVERLAYDATA puod);
DWORD CALLBACK DdSetColorKey(LPDDHAL_SETCOLORKEYDATA psckd);
DWORD CALLBACK DdUpdateOverlay(LPDDHAL_UPDATEOVERLAYDATA puod);

void _D3D_SU_DirectDrawLocalDestroyCallback(HashTable* pTable, 
                                            void* pData, 
                                            void* pExtra);
void _D3D_SU_SurfaceArrayDestroyCallback(PointerArray* pArray, 
                                         void* pData, 
                                         void* pExtra);

void _D3D_SU_PaletteArrayDestroyCallback(PointerArray* pArray, 
                                         void* pData, 
                                         void* pExtra);

#if DX7_STEREO
BOOL _DD_bIsStereoMode(P3_THUNKEDDATA* pThisDisplay,
                       DWORD dwWidth,
                       DWORD dwHeight,
                       DWORD dwBpp);
#endif

#if WNT_DDRAW

DWORD CALLBACK DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

// NT specific callbacks in gdi\heap.c
DWORD CALLBACK DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory);
DWORD CALLBACK DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);
DWORD CALLBACK DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);

#else   //  WNT_DDRAW

DWORD CALLBACK DdUpdateNonLocalHeap(LPDDHAL_UPDATENONLOCALHEAPDATA plhd);
DWORD CALLBACK DdGetHeapAlignment(LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData);
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

#endif  //  WNT_DDRAW

DWORD CALLBACK DdGetAvailDriverMemory(LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd);

// Overlay source update
void _DD_OV_UpdateSource(P3_THUNKEDDATA* pThisDisplay, 
                         LPDDRAWI_DDRAWSURFACE_LCL pSurf);

DWORD CALLBACK SetOverlayPosition32(LPDDHAL_SETOVERLAYPOSITIONDATA psopd);
DWORD CALLBACK DdSetOverlayPosition(LPDDHAL_SETOVERLAYPOSITIONDATA psopd);

#if W95_DDRAW

DWORD CALLBACK DDGetVideoPortConnectInfo(LPDDHAL_GETVPORTCONNECTDATA pInput);
DWORD CALLBACK DdCanCreateVideoPort (LPDDHAL_CANCREATEVPORTDATA pInput);
DWORD CALLBACK DdCreateVideoPort (LPDDHAL_CREATEVPORTDATA pInput);
DWORD CALLBACK DdFlipVideoPort (LPDDHAL_FLIPVPORTDATA pInput);
DWORD CALLBACK DdGetVideoPortBandwidth (LPDDHAL_GETVPORTBANDWIDTHDATA pInput);
DWORD CALLBACK DdGetVideoPortInputFormats (LPDDHAL_GETVPORTINPUTFORMATDATA pInput);
DWORD CALLBACK DdGetVideoPortOutputFormats (LPDDHAL_GETVPORTOUTPUTFORMATDATA pInput);
DWORD CALLBACK DdGetVideoPortField (LPDDHAL_GETVPORTFIELDDATA pInput);
DWORD CALLBACK DdGetVideoPortLine (LPDDHAL_GETVPORTLINEDATA pInput);
DWORD CALLBACK DdDestroyVideoPort (LPDDHAL_DESTROYVPORTDATA pInput);
DWORD CALLBACK DdGetVideoPortFlipStatus (LPDDHAL_GETVPORTFLIPSTATUSDATA pInput);
DWORD CALLBACK DdUpdateVideoPort (LPDDHAL_UPDATEVPORTDATA pInput);
DWORD CALLBACK DdWaitForVideoPortSync (LPDDHAL_WAITFORVPORTSYNCDATA pInput);
DWORD CALLBACK DdGetVideoSignalStatus(LPDDHAL_GETVPORTSIGNALDATA pInput);
DWORD CALLBACK DdSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA pInput);
DWORD CALLBACK DdSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA pInput);
#endif  //  W95_DDRAW

//------------------------------------------------------------------
// Permedia3 Blit Functions
//------------------------------------------------------------------
typedef void (P3RXEFFECTSBLT)(struct tagThunkedData*, 
                              LPDDRAWI_DDRAWSURFACE_LCL pSource, 
                              LPDDRAWI_DDRAWSURFACE_LCL pDest, 
                              P3_SURF_FORMAT* pFormatSource, 
                              P3_SURF_FORMAT* pFormatDest, 
                              LPDDHAL_BLTDATA lpBlt, 
                              RECTL *rSrc, 
                              RECTL *rDest);


VOID 
_DD_BLT_P3Clear(                        // Clearing
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer,
    FLATPTR pDestfpVidMem,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth
    );

VOID _DD_BLT_P3Clear_AA(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth,
    DDSCAPS DestDdsCaps);
    

void 
_DD_P3Download(                           // Downloads (sysmem -> video)
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,    
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,  
    DWORD dwSrcPitch,
    DWORD dwDestPitch,   
    DWORD dwDestPixelPitch,  
    DWORD dwDestPixelSize,
    RECTL* rSrc,
    RECTL* rDest);
    
void 
_DD_P3DownloadDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL* rSrc,
    RECTL* rDest);

void _DD_P3DownloadDstCh(
    struct tagThunkedData*,  
    LPDDRAWI_DDRAWSURFACE_LCL pSource, 
    LPDDRAWI_DDRAWSURFACE_LCL pDest, 
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest, 
    LPDDHAL_BLTDATA lpBlt, 
    RECTL* rSrc, 
    RECTL* rDest);

VOID _DD_BLT_P3CopyBlt(                      // Blts
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,
    DWORD dwSrcPitch,
    DWORD dwDestPitch,
    DWORD dwSrcOffset,
    DWORD dwDestOffset,
    DWORD dwDestPixelSize,
    RECTL *rSrc,
    RECTL *rDest);

VOID 
_DD_P3BltStretchSrcChDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR fpSrcVidMem,
    P3_SURF_FORMAT* pFormatSource,    
    DWORD dwSrcPixelSize,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight,
    DWORD dwSrcPixelPitch,
    DWORD dwSrcPatchMode,    
    ULONG ulSrcOffsetFromMemBase,    
    DWORD dwSrcFlags,
    DDPIXELFORMAT*  pSrcDDPF,
    BOOL bIsSourceAGP,
    FLATPTR fpDestVidMem,   
    P3_SURF_FORMAT* pFormatDest,    
    DWORD dwDestPixelSize,
    DWORD dwDestWidth,
    DWORD dwDestHeight,
    DWORD dwDestPixelPitch,
    DWORD dwDestPatchMode,
    ULONG ulDestOffsetFromMemBase,
    DWORD dwBltFlags,
    DWORD dwBltDDFX,
    DDCOLORKEY BltSrcColorKey,
    DDCOLORKEY BltDestColorKey,
    RECTL *rSrc,
    RECTL *rDest);

VOID 
_DD_BLT_SysMemToSysMemCopy(
    FLATPTR     fpSrcVidMem,
    LONG        lSrcPitch,
    DWORD       dwSrcBitCount,
    FLATPTR     fpDstVidMem,
    LONG        lDstPitch, 
    DWORD       dwDstBitCount,
    RECTL*      rSource,
    RECTL*      rDest);
                           
// FX Blits
P3RXEFFECTSBLT _DD_P3BltStretchSrcChDstCh_DD;
P3RXEFFECTSBLT _DD_P3BltStretchSrcChDstChOverlap;
P3RXEFFECTSBLT _DD_P3BltSourceChroma;

void P3RX_AA_Shrink(struct _p3_d3dcontext* pContext);

BOOL _DD_BLT_FixRectlOrigin(char *pszPlace, RECTL *rSrc, RECTL *rDest);

DWORD
_DD_BLT_GetBltDirection(    
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    RECTL *rSrc,
    RECTL *rDest,
    BOOL  *pbBlocking);

//------------------------------------------------------------------
// DX Utility functions.
//------------------------------------------------------------------
// Initialise 32 Bit data
BOOL _DD_InitDDHAL32Bit(struct tagThunkedData* pThisDisplay);

// Query flip status
HRESULT _DX_QueryFlipStatus( struct tagThunkedData* pThisDisplay,  
                             FLATPTR fpVidMem, 
                             BOOL bAllowDMAFlush );
// Change the mode setup
void ChangeDDHAL32Mode(struct tagThunkedData* pThisDisplay);
                         
// Checks that the current mode info is correct
#define VALIDATE_MODE_AND_STATE(pThisDisplay)     \
    if ((pThisDisplay->bResetMode != 0) ||        \
        (pThisDisplay->bStartOfDay))              \
            ChangeDDHAL32Mode(pThisDisplay);

//-----------------------------------------------------------------------------
//
// ****************** Mathematical definitions and macros *********************
//
//-----------------------------------------------------------------------------

#define math_e 2.718281828f

// Usefull maths stuff
extern float pow4( float x );
extern float myPow( float x, float y );

#if WNT_DDRAW

// Might be running on non-Intel processors.
static __inline void myDiv(float *result, float dividend, float divisor) 
{
    *result = dividend/divisor;
} // myDiv()
#else
static __inline void myDiv(float *result, float dividend, float divisor) 
{
    __asm 
    {
        fld dividend
        fdiv    divisor
        mov eax,result
        fstp dword ptr [eax]
    }
} // myDiv()
#endif  //  WNT_DDRAW

__inline void myFtoi(int *result, float f) 
{
    *result = (int)f;
} //myFtoi

static __inline float myFabs(float f)
{
    float* pFloat = &f;
    DWORD dwReturn = *((DWORD*)pFloat);
    dwReturn &= ~0x80000000;
    return (*((float*)&dwReturn));
} //

// Utility functions, used by NT4, NT5 and Win9X
static __inline int log2(int s)
{
    int d = 1, iter = -1;
    do {
         d *= 2;
         iter++;
    } while (d <= s);
    iter += ((s << 1) != d);
    return iter;
}

#ifdef _X86_

//-----------------------------------------------------------------------------
//
// myPow
//
// Compute x^y for arbitrary x and y
//
//-----------------------------------------------------------------------------
__inline float
myPow( float x, float y )
{
    float res = 0.0f;
    int intres;

    __asm
    {
        fld y                           // y
        fld x                           // x    y
        fyl2x                           // y*log2(x)
        fstp res
    }

    // Remove integer part of res as f2xm1 has limited input range

    myFtoi ( &intres, res );
    res -= intres;

    __asm
    {
        fild intres                     // Stash integer part for FSCALE
        fld res
        f2xm1                           // ST = 2^^fracx - 1
        fld1
        fadd                            // ST = 2^^fracx
        fscale                          // ST = 2^^x
        fstp res
        fstp st(0)                      // Clean up stack
    }

    return res;
} // myPow

#elif defined(_AMD64_)

double pow(double, double);

__inline float
myPow( float x, float y )
{
     return (float)pow((double)x, (double)y);
}

#elif defined(_IA64_)

__inline float
myPow( float x, float y )
{
     return powf(x,y);
}

#else

#error "No Target Architecture"

#endif //_X86_

//-----------------------------------------------------------------------------
//
// pow4
//
// Compute 4^x for arbitrary x 
//
//-----------------------------------------------------------------------------
__inline float
pow4( 
    float x )
{	
#if defined(_IA64_)
    return 0.0F;
#else
    return myPow( 4.0F, x );
#endif
} // pow4

#endif // __DIRECTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\debug.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           *     SAMPLE CODE        *
*                           **************************
*
* Module Name: debug.c
*
* Content: Debugging aids
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// Debug routines

#include "glint.h"
#include "dma.h"
#include <windef.h>          
#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

#if DBG

#if DBG_TRACK_CODE
// we don't want to ever do code coverage of the debugging tools 
// (otherwise we might loop forever)
#undef if
#undef while
#endif // DBG_TRACK_CODE


#if DBG_TRACK_FUNCS || DBG_TRACK_CODE
// Common helper functions
//-----------------------------------------------------------------------------
// __ShortFileName
//
// Leave just an 8.3 filename to store rather than a full path name
//
//----------------------------------------------------------------------------- 
char *
__ShortFileName(char *pInStr)
{
    char *pShortFN;

    pShortFN = pInStr;

    if (pInStr != NULL)
    {
        while (*pInStr != '\0')
        {
            if (*pInStr++ == '\\')
            {
                pShortFN = pInStr;
            }
        }
    }

    return (pShortFN);
    
} // __ShortFileName

#endif // DBG_TRACK_FUNCS || DBG_TRACK_CODE

#if DBG_TRACK_FUNCS
//-----------------------------------------------------------------------------
//
// ****************** FUNCTION COVERAGE DEBUGGING SUPPORT ********************
//
//-----------------------------------------------------------------------------
//
// This mechanism enables us to track which functions are called (entered),
// how many times they are called, what values do they return (and if they exit 
// through all expected return points). Support to track maximum, minimum and
// average time per call can also be implemented.
//
// To use it, add the DBG_ENTRY macro at the start of important functions you 
// want to track and before taking any return statement, add a DBG_EXIT macro
// giving a DWORD value representative of the return value of the function.
// Different return values will be tracked independently.
//
//
//  ********** This support should only be enabled for test runs. **********
//  ** IT SHOULD NOT BE SET BY DEFAULT ON NEITHER ON FREE OR CHECKED BUILDS **
//
//-----------------------------------------------------------------------------

// Maximum of functions to be tracked. Code will take care of not exceeding
// this, but it should be adjusted upward if necessary.
#define DEBUG_MAX_FUNC_COUNT 200

// Maximum of different return values to keep track of. Can be independent
// of DEBUG_MAX_FUNC_COUNT, just using a heuristic here instead of a wild guess.
#define DEBUG_MAX_RETVALS    (DEBUG_MAX_FUNC_COUNT * 30)

// global structures that will hold our data
struct { 
    VOID *pFuncAddr;  //
    DWORD dwRetVal;   //
    DWORD dwLine;     //
    DWORD dwCount;    //
} g_DbgFuncRetVal[DEBUG_MAX_RETVALS];

struct {
    VOID    *pFuncAddr;        //
    char    *pszFuncName;      //
    char    *pszFileName;      //
    DWORD    dwLine;           //
    DWORD    dwEntryCount;     //
    DWORD    dwExitCount;      //
    DWORD    dwIndxLastRetVal; //
    // profiling support - not yet implemented //azn
    LONGLONG LastStartTime;    //
    DWORD    MinTime;          //
    DWORD    MaxTime;          //
    DWORD    AvgTime;          //
} g_DbgFuncCoverage[DEBUG_MAX_FUNC_COUNT];

DWORD g_dwRetVal_Cnt = 0;
DWORD g_dwFuncCov_Cnt = 0;
DWORD g_dwFuncCov_Extra = 0;
    
//-----------------------------------------------------------------------------
// __Find
//
// Does a binary search on the g_DbgFuncCoverage array
//
// Since 0 is a valid array element, we return DEBUG_MAX_FUNC_COUNT if we
// fail to find a suitable match.
//
//-----------------------------------------------------------------------------
DWORD 
__Find(
    VOID *pFuncAddr, DWORD *pdwNearFail)
{
    DWORD dwLower ,dwUpper ,dwNewProbe ;

    *pdwNearFail = 0; // default failure value

    if (g_dwFuncCov_Cnt > 0)
    {       
        dwLower = 0;
        dwUpper = g_dwFuncCov_Cnt - 1; // dwUpper points to a valid element
               
        do 
        {       
            dwNewProbe = (dwUpper + dwLower) / 2;
            
            //DISPDBG((0,"%x %d %d %d",pFuncAddr,dwLower,dwUpper,dwNewProbe));
            
            if (g_DbgFuncCoverage[dwNewProbe].pFuncAddr == pFuncAddr)
            {
                // Found!!!    
                return dwNewProbe;
            }

            *pdwNearFail = dwNewProbe; // nearest element where we failed.

            // The new values for dwNewProbe make sure that we don't retest
            // the same value again unless dwUpper == dwLower in which case
            // we're done.
            if (g_DbgFuncCoverage[dwNewProbe].pFuncAddr > pFuncAddr)
            {
                if (dwNewProbe > 0)
                {
                    dwUpper = dwNewProbe - 1;
                }
                else
                {   // all elements in the array are larger than pFuncAdrr
                    // so this is just a way to exit from the loop since
                    // our vars are unsigned
                    dwUpper = 0; 
                    dwLower = 1;
                }
            }
            else
            {
                dwLower = dwNewProbe + 1;
            }
        } while(dwUpper >= dwLower);
    }

    return DEBUG_MAX_FUNC_COUNT;  // return error - element not found
    
} // __Find

//-----------------------------------------------------------------------------
// __FindOrAdd
//
// Does a binary search on the g_DbgFuncCoverage array, but if the element 
// isn't there, it is added.
//
// If we fail to add the element, we return the DEBUG_MAX_FUNC_COUNT value
//
//-----------------------------------------------------------------------------
DWORD 
__FindOrAdd(
    VOID *pFuncAddr,
    char *pszFuncName, 
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD dwNearFail;
    DWORD iEntry;
    DWORD dwNewElem;
    BOOL bNeedToMoveElems;

    // Do the normal search of the element first

    iEntry = __Find(pFuncAddr, &dwNearFail);

    if (iEntry != DEBUG_MAX_FUNC_COUNT)
    {
        return iEntry; //we're done!
    }

    // Now we have to add the new element. Do we have enough space?
    if (g_dwFuncCov_Cnt == DEBUG_MAX_FUNC_COUNT)
    {
        g_dwFuncCov_Extra++;         // Keep count of how many extra 
                                     // entries we really need
        return DEBUG_MAX_FUNC_COUNT; // return error - not enough space left
    }

    // Do we need to move elements to insert the new one ?  
    if ( g_dwFuncCov_Cnt == 0)
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = 0;
    }
    else if ( (dwNearFail == g_dwFuncCov_Cnt - 1) &&
              (g_DbgFuncCoverage[dwNearFail].pFuncAddr < pFuncAddr) )
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = g_dwFuncCov_Cnt;    
    }
    else if (g_DbgFuncCoverage[dwNearFail].pFuncAddr < pFuncAddr)
    {
        bNeedToMoveElems = TRUE;   
        dwNewElem = dwNearFail + 1;
    } 
    else
    {
        bNeedToMoveElems = TRUE;  
        dwNewElem = dwNearFail;        
    }

    // Do the move inside the array if necessary
    if (bNeedToMoveElems)
    {
        // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
        // we use memmove as memcpy doesn't handle overlaps!
        // (remember: first param of memcpy is dst, 2nd is src!)
        memmove(&g_DbgFuncCoverage[dwNewElem+1],
                &g_DbgFuncCoverage[dwNewElem],
                sizeof(g_DbgFuncCoverage[0])*(g_dwFuncCov_Cnt - dwNewElem)); 

        // now cleanup the fields
        memset(&g_DbgFuncCoverage[dwNewElem], 
               0, 
               sizeof(g_DbgFuncCoverage[dwNewElem]));
    }

    // Now init the main fields
    g_DbgFuncCoverage[dwNewElem].pFuncAddr = pFuncAddr;
    g_DbgFuncCoverage[dwNewElem].pszFuncName = pszFuncName;
    g_DbgFuncCoverage[dwNewElem].pszFileName = __ShortFileName(pszFileName);
    g_DbgFuncCoverage[dwNewElem].dwLine = dwLine;

    // Mark the fact that the array has grown by one element
    g_dwFuncCov_Cnt++;
    
    DISPDBG((DBGLVL,"*** DEBUG FUNC COVERAGE New Elem (total now:%d) %x @ %d",
                    g_dwFuncCov_Cnt, pFuncAddr, dwNewElem));
    
    return dwNewElem;
    
} // __FindOrAdd

//-----------------------------------------------------------------------------
// __GetTime
//-----------------------------------------------------------------------------
VOID
__GetTime( LONGLONG *pllTime)
{
    *pllTime = 0; //azn - temporary
} // __GetTime

//-----------------------------------------------------------------------------
// Debug_Func_Entry
//-----------------------------------------------------------------------------
VOID 
Debug_Func_Entry(
    VOID *pFuncAddr,
    char *pszFuncName, 
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD iEntry;
    LONGLONG llTimer;
    
    // Look for a log element for entry to this function. If not found it
    // is added to the current list of covered functions.
    iEntry = __FindOrAdd(pFuncAddr, pszFuncName, dwLine, pszFileName);
    
    // Didn't found one and no more space left in the internal data
    // structures ? Report error and return!
    if (iEntry == DEBUG_MAX_FUNC_COUNT)
    {
        DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE ERROR in Debug_Func_Entry"));
        return;
    }
    
    // Update/Add information for this entry
    if (g_DbgFuncCoverage[iEntry].dwEntryCount != 0)
    {
        // This is an update
        g_DbgFuncCoverage[iEntry].dwEntryCount++;
        __GetTime(&llTimer);
        g_DbgFuncCoverage[iEntry].LastStartTime = llTimer;
    }
    else
    {
        // This is an addition
        g_DbgFuncCoverage[iEntry].dwEntryCount = 1; 
        g_DbgFuncCoverage[iEntry].dwExitCount = 0;
        g_DbgFuncCoverage[iEntry].dwIndxLastRetVal = 0;
        
        __GetTime(&llTimer);
        g_DbgFuncCoverage[iEntry].LastStartTime = llTimer;
        g_DbgFuncCoverage[iEntry].MinTime = 0;        
        g_DbgFuncCoverage[iEntry].MaxTime = 0;
        g_DbgFuncCoverage[iEntry].AvgTime = 0;            
    }

} // Debug_Func_Entry

//-----------------------------------------------------------------------------
// Debug_Func_Exit
//-----------------------------------------------------------------------------                      
VOID 
Debug_Func_Exit(
    VOID *pFuncAddr,
    DWORD dwRetVal,                       
    DWORD dwLine)
{    
    DWORD iEntry; 
    LONGLONG llTimer;
    DWORD dwElapsedTime;
    DWORD dwDummy;
    DWORD iRVEntry;

    __GetTime(&llTimer);

    // Look for a log element for entry to this function
    iEntry = __Find(pFuncAddr, &dwDummy);
    
    // Record and update relevant info in g_DbgFuncCoverage
    if (iEntry != DEBUG_MAX_FUNC_COUNT)
    {
        // keep track of times we've exited this function
        g_DbgFuncCoverage[iEntry].dwExitCount++;   
        
        // Keep track of elapsed times for this function
//@@BEGIN_DDKSPLIT        
        // possibly an evil data conversion - azn
//@@END_DDKSPLIT
        dwElapsedTime = (DWORD)(llTimer - 
                                g_DbgFuncCoverage[iEntry].LastStartTime);

        if (dwElapsedTime > g_DbgFuncCoverage[iEntry].MaxTime)
        {
            g_DbgFuncCoverage[iEntry].MaxTime = dwElapsedTime;
        }

        if (dwElapsedTime < g_DbgFuncCoverage[iEntry].MinTime)
        {
            g_DbgFuncCoverage[iEntry].MinTime = dwElapsedTime;
        }            

        g_DbgFuncCoverage[iEntry].AvgTime =
                        ( (g_DbgFuncCoverage[iEntry].dwExitCount - 1)*
                          g_DbgFuncCoverage[iEntry].AvgTime +
                          dwElapsedTime 
                        ) / g_DbgFuncCoverage[iEntry].dwExitCount;
        
        g_DbgFuncCoverage[iEntry].LastStartTime = 0;    
    } 
    else
    {
        DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE ERROR not found %x",pFuncAddr));
        return; // don't even try adding this to the return value table
    }

    iRVEntry = g_DbgFuncCoverage[iEntry].dwIndxLastRetVal;

    if (iRVEntry != 0)
    {
        // Check if the last time we recorded a return value for this function
        // it was the exact same one. This way will save space recording some
        // duplicate info. The method is not perfect, but it's fast.

        if (( g_DbgFuncRetVal[iRVEntry].pFuncAddr == pFuncAddr) &&
            ( g_DbgFuncRetVal[iRVEntry].dwRetVal  == dwRetVal ) &&
            ( g_DbgFuncRetVal[iRVEntry].dwLine    == dwLine   ) )
        {
            //increment count for this event
            g_DbgFuncRetVal[iRVEntry].dwCount += 1;
            
            return; // we won't store a new record for this event
        }
    }

    // We couldn't save space, so we add info about the return value
    if (g_dwRetVal_Cnt < DEBUG_MAX_RETVALS)
    {
        g_DbgFuncCoverage[iEntry].dwIndxLastRetVal = g_dwRetVal_Cnt;
        
        g_DbgFuncRetVal[g_dwRetVal_Cnt].pFuncAddr = pFuncAddr;
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwRetVal  = dwRetVal;
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwLine    = dwLine;    
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwCount   = 1;                  
        
        g_dwRetVal_Cnt++;        
    }
  
} // Debug_Func_Exit

//-----------------------------------------------------------------------------
//
// Debug_Func_Report_And_Reset
//
// Report the accumulated stats and then reset them.
//
// This should be called through the DrvEscape mechanism(Win2K) or through some
// easily controllable code path which we can use to trigger it.
//
//-----------------------------------------------------------------------------  
VOID
Debug_Func_Report_And_Reset(void)
{
    DWORD i,j,k; // counters
    DWORD dwCount;

    DISPDBG((ERRLVL,"********* DEBUG FUNC COVERAGE (Debug_Func_Report) *********"));
    
    // Report if we have overflowed in any of our internal structures 
    // which would invalidate much of our results.
    if (g_dwFuncCov_Cnt >= DEBUG_MAX_FUNC_COUNT)
    {
       DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE: g_DbgFuncCoverage exceeded "
                      "%d entries by %d ***",
                      DEBUG_MAX_FUNC_COUNT, 
                      g_dwFuncCov_Extra));
    }

    if (g_dwRetVal_Cnt >= DEBUG_MAX_RETVALS)
    {
       DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE: g_DbgFuncRetVal exceeded "
                      "%d entries ***",DEBUG_MAX_RETVALS));
    }
    
    // Headers of function coverage report
    DISPDBG((ERRLVL,"%25s %12s %4s %6s %6s %8s",
                   "Function","File","Line","#Entry","#Exit","ExitValue"));

    // Go through each function called and report on its results
    for (i = 0; i < g_dwFuncCov_Cnt; i++)
    {
        DISPDBG((ERRLVL,"%25s %12s %4d %6d %6d",
                        g_DbgFuncCoverage[i].pszFuncName,
                        g_DbgFuncCoverage[i].pszFileName,                    
                        g_DbgFuncCoverage[i].dwLine,
                        g_DbgFuncCoverage[i].dwEntryCount,
                        g_DbgFuncCoverage[i].dwExitCount));                            

        // Get result values
        for(j = 0; j < g_dwRetVal_Cnt; j++)
        {
            if(g_DbgFuncRetVal[j].pFuncAddr == 
               g_DbgFuncCoverage[i].pFuncAddr)
            {
                // This entry is a valid exit value report for 
                // our g_DbgFuncCoverage entry, count instances
                dwCount = g_DbgFuncRetVal[j].dwCount;
                          
                // Now get rid of any duplicate records of this 
                // same exit event while counting
                for (k = j + 1; k < g_dwRetVal_Cnt; k++)
                {
                    if ( (g_DbgFuncRetVal[j].pFuncAddr == 
                                    g_DbgFuncRetVal[k].pFuncAddr) &&
                         (g_DbgFuncRetVal[j].dwLine ==  
                                    g_DbgFuncRetVal[k].dwLine) &&       
                         (g_DbgFuncRetVal[j].dwRetVal ==  
                                    g_DbgFuncRetVal[k].dwRetVal))
                    {
                        dwCount += g_DbgFuncRetVal[k].dwCount;
                        
                        g_DbgFuncRetVal[k].pFuncAddr = NULL;
                        g_DbgFuncRetVal[k].dwRetVal   = 0;
                        g_DbgFuncRetVal[k].dwLine     = 0;
                        g_DbgFuncRetVal[k].dwCount    = 0;
                    }
                }
                
                // Display it
                DISPDBG((ERRLVL,"%25s %12s %4d %6d %6s %8d",
                              "\"",
                              g_DbgFuncCoverage[i].pszFileName,
                              g_DbgFuncRetVal[j].dwLine,
                              dwCount,"",
                              g_DbgFuncRetVal[j].dwRetVal));   
                
            }
        }

    }

    DISPDBG((ERRLVL,
              "************************************************************"));

    // Clear structures for next round of statistics gathering

    for (i = 0; i < DEBUG_MAX_RETVALS; i++)
    {
        g_DbgFuncRetVal[i].pFuncAddr = NULL;
        g_DbgFuncRetVal[i].dwRetVal   = 0;
        g_DbgFuncRetVal[i].dwLine     = 0;
        g_DbgFuncRetVal[i].dwCount    = 0;        
    }

    for (i= 0; i < DEBUG_MAX_FUNC_COUNT; i++)
    {
        g_DbgFuncCoverage[i].pFuncAddr = NULL;
        g_DbgFuncCoverage[i].pszFuncName = NULL;
        g_DbgFuncCoverage[i].pszFileName = NULL;
        g_DbgFuncCoverage[i].dwLine = 0;
        g_DbgFuncCoverage[i].dwEntryCount = 0;
        g_DbgFuncCoverage[i].dwExitCount = 0;
        g_DbgFuncCoverage[i].dwIndxLastRetVal = 0;        
        g_DbgFuncCoverage[i].LastStartTime = 0;
        g_DbgFuncCoverage[i].MinTime = 0;        
        g_DbgFuncCoverage[i].MaxTime = 0;
        g_DbgFuncCoverage[i].AvgTime = 0;        
    }

    g_dwRetVal_Cnt = 0;
    g_dwFuncCov_Cnt = 0;    
    g_dwFuncCov_Extra = 0;
    
} // Debug_Func_Report

#endif // DBG_TRACK_FUNCS

#if DBG_TRACK_CODE
//-----------------------------------------------------------------------------
//
// ******************** STATEMENT COVERAGE DEBUGGING SUPPORT ******************
//
//-----------------------------------------------------------------------------


// Maximum of code branches to be tracked. Code will take care of not exceeding
// this, but it should be adjusted upward if necessary.
#define DEBUG_MAX_CODE_COUNT 20000

struct {
    VOID    *pCodeAddr;        //
    char    *pszFileName;      //
    DWORD    dwLine;           //
    DWORD    dwCodeType;       //   
    DWORD    dwCountFALSE;     //
    DWORD    dwCountTRUE;      //
} g_DbgCodeCoverage[DEBUG_MAX_CODE_COUNT];

DWORD g_dwCodeCov_Cnt = 0;

static char* g_cDbgCodeStrings[DBG_FOR_CODE+1] = { "NONE",
                                                     "IF" , 
                                                     "WHILE",
                                                     "SWITCH",
                                                     "FOR"    };
                                               
//-----------------------------------------------------------------------------
// __FindCode
//
// Does a binary search on the g_DbgCodeCoverage array
//
// Since 0 is a valid array element, we return DEBUG_MAX_CODE_COUNT if we
// fail to find a suitable match.
//
//-----------------------------------------------------------------------------
DWORD 
__FindCode(
    VOID *pCodeAddr, 
    DWORD *pdwNearFail)
{
    DWORD dwLower ,dwUpper ,dwNewProbe ;

    *pdwNearFail = 0; // default failure value

    if (g_dwCodeCov_Cnt > 0)
    {       
        dwLower = 0;
        dwUpper = g_dwCodeCov_Cnt - 1; // dwUpper points to a valid element
               
        do 
        {       
            dwNewProbe = (dwUpper + dwLower) / 2;
                       
            if (g_DbgCodeCoverage[dwNewProbe].pCodeAddr == pCodeAddr)
            {
                // Found!!!    
                return dwNewProbe;
            }

            *pdwNearFail = dwNewProbe; // nearest element where we failed.

            // The new values for dwNewProbe make sure that we don't retest
            // the same value again unless dwUpper == dwLower in which case
            // we're done.
            if (g_DbgCodeCoverage[dwNewProbe].pCodeAddr > pCodeAddr)
            {
                if (dwNewProbe > 0)
                {
                    dwUpper = dwNewProbe - 1;
                }
                else
                {   // all elements in the array are larger than pCodeAdrr
                    // so this is just a way to exit from the loop since
                    // our vars are unsigned
                    dwUpper = 0; 
                    dwLower = 1;
                }
            }
            else
            {
                dwLower = dwNewProbe + 1;
            }
        } while(dwUpper >= dwLower);
    }

    return DEBUG_MAX_CODE_COUNT;  // return error - element not found
    
} // __FindCode

//-----------------------------------------------------------------------------
// __FindOrAddCode
//
// Does a binary search on the g_DbgCodeCoverage array, but if the element 
// isn't there, it is added.
//
// If we fail to add the element, we return the DEBUG_MAX_CODE_COUNT value
//
//-----------------------------------------------------------------------------
DWORD 
__FindOrAddCode(
    VOID *pCodeAddr,
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD dwNearFail;
    DWORD iEntry;
    DWORD dwNewElem;
    BOOL bNeedToMoveElems;

    // Do the normal search of the element first

    iEntry = __FindCode(pCodeAddr, &dwNearFail);

    if (iEntry != DEBUG_MAX_CODE_COUNT)
    {
        return iEntry; //we're done!
    }

    // Now we have to add the new element. Do we have enough space?
    if (g_dwCodeCov_Cnt == DEBUG_MAX_CODE_COUNT)
    {
        return DEBUG_MAX_CODE_COUNT; // return error - not enough space left
    }

    // Do we need to move elements to insert the new one ?  
    if ( g_dwCodeCov_Cnt == 0)
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = 0;
    }
    else if ( (dwNearFail == g_dwCodeCov_Cnt - 1) &&
              (g_DbgCodeCoverage[dwNearFail].pCodeAddr < pCodeAddr) )
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = g_dwCodeCov_Cnt;    
    }
    else if (g_DbgCodeCoverage[dwNearFail].pCodeAddr < pCodeAddr)
    {
        bNeedToMoveElems = TRUE;   
        dwNewElem = dwNearFail + 1;
    } 
    else
    {
        bNeedToMoveElems = TRUE;  
        dwNewElem = dwNearFail;        
    }

    // Do the move inside the array if necessary
    if (bNeedToMoveElems)
    {
        // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
        // we use memmove as memcpy doesn't handle overlaps!
        // (remember: first param of memcpy is dst, 2nd is src!)
        memmove(&g_DbgCodeCoverage[dwNewElem+1],
                &g_DbgCodeCoverage[dwNewElem],
                sizeof(g_DbgCodeCoverage[0])*(g_dwCodeCov_Cnt - dwNewElem)); 

        // now cleanup the fields
        memset(&g_DbgCodeCoverage[dwNewElem], 
               0, 
               sizeof(g_DbgCodeCoverage[dwNewElem]));
    }

    // Now init the main fields
    g_DbgCodeCoverage[dwNewElem].pCodeAddr = pCodeAddr;
    g_DbgCodeCoverage[dwNewElem].pszFileName = __ShortFileName(pszFileName);
    g_DbgCodeCoverage[dwNewElem].dwLine = dwLine;    
    g_DbgCodeCoverage[dwNewElem].dwCodeType = 0;    
    g_DbgCodeCoverage[dwNewElem].dwCountFALSE = 0;  
    g_DbgCodeCoverage[dwNewElem].dwCountTRUE = 0;  
    
    // Mark the fact that the array has grown by one element
    g_dwCodeCov_Cnt++;

    // Check if we're about to fail! (in order to report this only once)
    if (g_dwCodeCov_Cnt == DEBUG_MAX_CODE_COUNT)
    {
        DISPDBG((ERRLVL,"*** DEBUG CODE COVERAGE ERROR in Debug_Code_Coverage"));
    }
    
    
    return dwNewElem;
    
} // __FindOrAddCode

//-----------------------------------------------------------------------------
// Debug_Code_Coverage
//-----------------------------------------------------------------------------
BOOL 
Debug_Code_Coverage(
    DWORD dwCodeType, 
    DWORD dwLine , 
    char *pszFileName,
    BOOL bCodeResult)
{
    DWORD iEntry;
    DWORD *pCodeAddr;

    // Get the 32-bit address of our caller from the stack
    __asm mov eax, [ebp+0x4];
    __asm mov pCodeAddr,eax;
    
    // Look for a log element for entry to this code. If not found it
    // is added to the current list of covered code.
    iEntry = __FindOrAddCode(pCodeAddr, dwLine, pszFileName);
    
    // Didn't found one and no more space left in the internal data
    // structures ? Get out and do nothing!
    if (iEntry == DEBUG_MAX_CODE_COUNT)
    {
        return bCodeResult;
    }

    if (dwCodeType == DBG_IF_CODE || dwCodeType == DBG_WHILE_CODE )
    {
        // Update/Add information for this entry
        g_DbgCodeCoverage[iEntry].dwCodeType = dwCodeType;    
        if (bCodeResult)
        {
            g_DbgCodeCoverage[iEntry].dwCountTRUE++;

        }
        else
        {
            g_DbgCodeCoverage[iEntry].dwCountFALSE++; 
        }
    }
    else if (dwCodeType == DBG_SWITCH_CODE)    
    {
        // special case for the switch statement since its multivalued

        // Is the entry new? (uninitalized)
        if(g_DbgCodeCoverage[iEntry].dwCodeType == 0)
        {
            // just init and get out of here
            g_DbgCodeCoverage[iEntry].dwCodeType = DBG_SWITCH_CODE;
            g_DbgCodeCoverage[iEntry].dwCountFALSE = bCodeResult; // switch value
            g_DbgCodeCoverage[iEntry].dwCountTRUE =  1;           // found once
        }
        else
        {
            // need to look for already initialized elememt
            int iLookAt;

            // look at current element and back
            DWORD dwNewElem;
            iLookAt = iEntry;
            
            while ( (iLookAt >= 0 )                                     &&
                    (g_DbgCodeCoverage[iLookAt].pCodeAddr == pCodeAddr)  )
            {
                if (g_DbgCodeCoverage[iLookAt].dwCountFALSE == (DWORD)bCodeResult)
                {
                    // found - so update and get out of here
                    g_DbgCodeCoverage[iLookAt].dwCountTRUE++;                    
                    return bCodeResult;
                }

                // move to previous
                iLookAt--;
            }

            // look forward from current element
            iLookAt = iEntry + 1;
            while ( ((DWORD)iLookAt < g_dwCodeCov_Cnt )                       &&
                    (g_DbgCodeCoverage[iLookAt].pCodeAddr == pCodeAddr)  )
            {
                if (g_DbgCodeCoverage[iLookAt].dwCountFALSE == (DWORD)bCodeResult)
                {
                    // found - so update and get out of here
                    g_DbgCodeCoverage[iLookAt].dwCountTRUE++;                    
                    return bCodeResult;
                }

                // move to next
                iLookAt++;
            }            

            // not found - so we must add it!
            dwNewElem = iEntry;

            // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
            // we use memmove as memcpy doesn't handle overlaps!
            // (remember: first param of memcpy is dst, 2nd is src!)
            memmove(&g_DbgCodeCoverage[dwNewElem+1],
                    &g_DbgCodeCoverage[dwNewElem],
                    sizeof(g_DbgCodeCoverage[0])*(g_dwCodeCov_Cnt - dwNewElem)); 

            // now cleanup the fields
            memset(&g_DbgCodeCoverage[dwNewElem], 
                   0, 
                   sizeof(g_DbgCodeCoverage[dwNewElem]));   

            // now init them
            g_DbgCodeCoverage[dwNewElem].pCodeAddr = pCodeAddr;
            g_DbgCodeCoverage[dwNewElem].pszFileName = 
                                        g_DbgCodeCoverage[dwNewElem+1].pszFileName;
            g_DbgCodeCoverage[dwNewElem].dwLine = dwLine;              
            g_DbgCodeCoverage[dwNewElem].dwCodeType = DBG_SWITCH_CODE;
            g_DbgCodeCoverage[dwNewElem].dwCountFALSE = bCodeResult; // switch value
            g_DbgCodeCoverage[dwNewElem].dwCountTRUE =  1;           // found once            
            
        }
    }
    
    return bCodeResult;
} // Debug_Code_Coverage

//-----------------------------------------------------------------------------
//
// Debug_Code_Report_And_Reset
//
// Report the accumulated stats and then reset them.
//
// This should be called through the DrvEscape mechanism(Win2K) or through some
// easily controllable code path which we can use to trigger it.
//
//-----------------------------------------------------------------------------  
VOID
Debug_Code_Report_And_Reset(void)
{
    DWORD i; // counters

    DISPDBG((ERRLVL,
                "********* DEBUG FUNC COVERAGE (Debug_Code_Report) *********"));
    
    // Report if we have overflowed in any of our internal structures 
    // which would invalidate much of our results.
    if (g_dwCodeCov_Cnt >= DEBUG_MAX_CODE_COUNT)
    {
       DISPDBG((ERRLVL,"*** DEBUG CODE COVERAGE: g_DbgCodeCoverage exceeded "
                      "%d entries ***",DEBUG_MAX_CODE_COUNT));
    }
    
    // Headers of code coverage report
    DISPDBG((ERRLVL,"%12s %4s %8s %6s %6s",
                   "File","Line","Code","FALSE","TRUE"));

    // Go through each code called and report on its results
    for (i = 0; i < g_dwCodeCov_Cnt; i++)
    {
#if DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY    
        // Report only 
        //   - if's that branched only one way
        //   - while's which were evaluated but not entered
        if ( ( (g_DbgCodeCoverage[i].dwCodeType == DBG_IF_CODE) &&
               (g_DbgCodeCoverage[i].dwCountFALSE == 0 ||
                g_DbgCodeCoverage[i].dwCountTRUE  == 0)            )  ||
             ( (g_DbgCodeCoverage[i].dwCodeType == DBG_WHILE_CODE) &&
               (g_DbgCodeCoverage[i].dwCountTRUE  == 0)            )  ||
             ( (g_DbgCodeCoverage[i].dwCodeType == DBG_SWITCH_CODE))  )
#endif
        // We report all the conditionals we've gone through so far
        DISPDBG((ERRLVL,"%12s %4d %8s %6d %6d",
                        g_DbgCodeCoverage[i].pszFileName,     
                        g_DbgCodeCoverage[i].dwLine,                   
                        g_cDbgCodeStrings[g_DbgCodeCoverage[i].dwCodeType],
                        g_DbgCodeCoverage[i].dwCountFALSE,
                        g_DbgCodeCoverage[i].dwCountTRUE  ));          
    }

    DISPDBG((ERRLVL,
                "************************************************************"));

    // Clear structures for next round of statistics gathering
    for (i= 0; i < DEBUG_MAX_CODE_COUNT; i++)
    {
        g_DbgCodeCoverage[i].pCodeAddr = NULL;
        g_DbgCodeCoverage[i].pszFileName = NULL;
        g_DbgCodeCoverage[i].dwLine = 0;
        g_DbgCodeCoverage[i].dwCodeType = 0;
        g_DbgCodeCoverage[i].dwCountFALSE = 0;
        g_DbgCodeCoverage[i].dwCountTRUE = 0;        
    }

    g_dwCodeCov_Cnt = 0;    
    
} // Debug_Code_Report_And_Reset

#endif // DBG_TRACK_CODE

//-----------------------------------------------------------------------------
//
//  ******************** PUBLIC DATA STRUCTURE DUMPING ************************
//
//-----------------------------------------------------------------------------
// 
// These are functions that help to dump the values of common DDI structures
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//
// DumpD3DBlend
//
// Dumps a D3DBLEND value
//
//-----------------------------------------------------------------------------
void DumpD3DBlend(int Level, DWORD i )
{
    switch ((D3DBLEND)i)
    {
        case D3DBLEND_ZERO:
            DISPDBG((Level, "  ZERO"));
            break;
        case D3DBLEND_ONE:
            DISPDBG((Level, "  ONE"));
            break;      
        case D3DBLEND_SRCCOLOR:
            DISPDBG((Level, "  SRCCOLOR"));
            break;
        case D3DBLEND_INVSRCCOLOR:
            DISPDBG((Level, "  INVSRCCOLOR"));
            break;
        case D3DBLEND_SRCALPHA:
            DISPDBG((Level, "  SRCALPHA"));
            break;
        case D3DBLEND_INVSRCALPHA:
            DISPDBG((Level, "  INVSRCALPHA"));
            break;
        case D3DBLEND_DESTALPHA:
            DISPDBG((Level, "  DESTALPHA"));
            break;
        case D3DBLEND_INVDESTALPHA:
            DISPDBG((Level, "  INVDESTALPHA"));
            break;
        case D3DBLEND_DESTCOLOR:
            DISPDBG((Level, "  DESTCOLOR"));
            break;
        case D3DBLEND_INVDESTCOLOR:
            DISPDBG((Level, "  INVDESTCOLOR"));
            break;
        case D3DBLEND_SRCALPHASAT:
            DISPDBG((Level, "  SRCALPHASAT"));
            break;
        case D3DBLEND_BOTHSRCALPHA:
            DISPDBG((Level, "  BOTHSRCALPHA"));
            break;
        case D3DBLEND_BOTHINVSRCALPHA:
            DISPDBG((Level, "  BOTHINVSRCALPHA"));
            break;
    }
} // DumpD3DBlend

//-----------------------------------------------------------------------------
//
// DumpD3DLight
//
// Dumps a D3DLIGHT7 structure
//
//-----------------------------------------------------------------------------
void DumpD3DLight(int DebugLevel, D3DLIGHT7* pLight)
{
    // FIXME
    DISPDBG((DebugLevel, "dltType:        %d", pLight->dltType));
    DISPDBG((DebugLevel, "dcvDiffuse:       (%f,%f,%f)", 
                          pLight->dcvDiffuse.r, 
                          pLight->dcvDiffuse.g, 
                          pLight->dcvDiffuse.b, 
                          pLight->dcvDiffuse.a));
    DISPDBG((DebugLevel, "dvPosition:     (%f,%f,%f)", 
                          pLight->dvPosition.x, 
                          pLight->dvPosition.y, 
                          pLight->dvPosition.z));
    DISPDBG((DebugLevel, "dvDirection:    (%f,%f,%f)", 
                          pLight->dvDirection.x, 
                          pLight->dvDirection.y, 
                          pLight->dvDirection.z));
    DISPDBG((DebugLevel, "dvRange:        %f", pLight->dvRange));
    DISPDBG((DebugLevel, "dvFalloff:      %f", pLight->dvFalloff));
    DISPDBG((DebugLevel, "dvAttenuation0: %f", pLight->dvAttenuation0));
    DISPDBG((DebugLevel, "dvAttenuation1: %f", pLight->dvAttenuation1));
    DISPDBG((DebugLevel, "dvAttenuation2: %f", pLight->dvAttenuation2));
    DISPDBG((DebugLevel, "dvTheta:        %f", pLight->dvTheta));
    DISPDBG((DebugLevel, "dvPhi:          %f", pLight->dvPhi));
    
} // DumpD3DLight

//-----------------------------------------------------------------------------
//
// DumpD3DMaterial
//
// Dumps a D3DMATERIAL7 structure
//
//-----------------------------------------------------------------------------
void DumpD3DMaterial(int DebugLevel, D3DMATERIAL7* pMaterial)
{
    DISPDBG((DebugLevel, "Diffuse  (%f, %f, %f)", 
                         pMaterial->diffuse.r, 
                         pMaterial->diffuse.g, 
                         pMaterial->diffuse.b, 
                         pMaterial->diffuse.a));
    DISPDBG((DebugLevel, "Ambient  (%f, %f, %f)", 
                         pMaterial->ambient.r, 
                         pMaterial->ambient.g, 
                         pMaterial->ambient.b, 
                         pMaterial->ambient.a));
    DISPDBG((DebugLevel, "Specular (%f, %f, %f)", 
                         pMaterial->specular.r, 
                         pMaterial->specular.g, 
                         pMaterial->specular.b, 
                         pMaterial->specular.a));
    DISPDBG((DebugLevel, "Emmisive (%f, %f, %f)", 
                         pMaterial->emissive.r, 
                         pMaterial->emissive.g, 
                         pMaterial->emissive.b, 
                         pMaterial->emissive.a));
    DISPDBG((DebugLevel, "Power    (%f)", pMaterial->power));
    
} // DumpD3DMaterial

//-----------------------------------------------------------------------------
//
// DumpD3DMatrix
//
// Dumps a D3DMATRIX structure
// 
//-----------------------------------------------------------------------------
void DumpD3DMatrix(int DebugLevel, D3DMATRIX* pMatrix)
{
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_11, 
                         pMatrix->_12, 
                         pMatrix->_13, 
                         pMatrix->_14));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_21, 
                         pMatrix->_22, 
                         pMatrix->_23, 
                         pMatrix->_24));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_31, 
                         pMatrix->_32, 
                         pMatrix->_33, 
                         pMatrix->_34));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_41, 
                         pMatrix->_42, 
                         pMatrix->_43, 
                         pMatrix->_44));
} // DumpD3DMatrix

//-----------------------------------------------------------------------------
//
// DumpD3DState
//
// Dumps relevant D3D RS and TSS
// 
//-----------------------------------------------------------------------------
void DumpD3DState(int lvl, DWORD RS[], TexStageState TS[])
{
#define DUMPRS(rs)    DISPDBG((lvl,"%s = 0x%08x",#rs,RS[rs]));

    DWORD i,j;

    DISPDBG((lvl,"RELEVANT DX7 renderstates:"));
    DUMPRS( D3DRENDERSTATE_ZENABLE );
    DUMPRS( D3DRENDERSTATE_FILLMODE );
    DUMPRS( D3DRENDERSTATE_SHADEMODE );
    DUMPRS( D3DRENDERSTATE_LINEPATTERN );
    DUMPRS( D3DRENDERSTATE_ZWRITEENABLE );
    DUMPRS( D3DRENDERSTATE_ALPHATESTENABLE );
    DUMPRS( D3DRENDERSTATE_LASTPIXEL );
    DUMPRS( D3DRENDERSTATE_SRCBLEND );
    DUMPRS( D3DRENDERSTATE_DESTBLEND );
    DUMPRS( D3DRENDERSTATE_CULLMODE );
    DUMPRS( D3DRENDERSTATE_ZFUNC );
    DUMPRS( D3DRENDERSTATE_ALPHAREF );
    DUMPRS( D3DRENDERSTATE_ALPHAFUNC );
    DUMPRS( D3DRENDERSTATE_DITHERENABLE );
    DUMPRS( D3DRENDERSTATE_BLENDENABLE );
    DUMPRS( D3DRENDERSTATE_FOGENABLE );
    DUMPRS( D3DRENDERSTATE_SPECULARENABLE );
    DUMPRS( D3DRENDERSTATE_ZVISIBLE );
    DUMPRS( D3DRENDERSTATE_STIPPLEDALPHA );
    DUMPRS( D3DRENDERSTATE_FOGCOLOR );
    DUMPRS( D3DRENDERSTATE_FOGTABLEMODE );
    DUMPRS( D3DRENDERSTATE_FOGTABLESTART );
    DUMPRS( D3DRENDERSTATE_FOGTABLEEND );
    DUMPRS( D3DRENDERSTATE_FOGTABLEDENSITY );
    DUMPRS( D3DRENDERSTATE_EDGEANTIALIAS );    
    DUMPRS( D3DRENDERSTATE_ZBIAS );    
    DUMPRS( D3DRENDERSTATE_RANGEFOGENABLE );    
    DUMPRS( D3DRENDERSTATE_STENCILENABLE );
    DUMPRS( D3DRENDERSTATE_STENCILFAIL );            
    DUMPRS( D3DRENDERSTATE_STENCILZFAIL );
    DUMPRS( D3DRENDERSTATE_STENCILPASS );
    DUMPRS( D3DRENDERSTATE_STENCILFUNC );
    DUMPRS( D3DRENDERSTATE_STENCILREF );
    DUMPRS( D3DRENDERSTATE_STENCILMASK );
    DUMPRS( D3DRENDERSTATE_STENCILWRITEMASK );
    DUMPRS( D3DRENDERSTATE_TEXTUREFACTOR );
    DUMPRS( D3DRENDERSTATE_WRAP0 );
    DUMPRS( D3DRENDERSTATE_WRAP1 );        
    DUMPRS( D3DRENDERSTATE_WRAP2 );        
    DUMPRS( D3DRENDERSTATE_WRAP3 );
    DUMPRS( D3DRENDERSTATE_WRAP4 );
    DUMPRS( D3DRENDERSTATE_WRAP5 );
    DUMPRS( D3DRENDERSTATE_WRAP6 );
    DUMPRS( D3DRENDERSTATE_WRAP7 );        
    DUMPRS( D3DRENDERSTATE_LOCALVIEWER );
    DUMPRS( D3DRENDERSTATE_CLIPPING );
    DUMPRS( D3DRENDERSTATE_LIGHTING );
    DUMPRS( D3DRENDERSTATE_AMBIENT );
    DUMPRS( D3DRENDERSTATE_SCENECAPTURE );
    DUMPRS( D3DRENDERSTATE_EVICTMANAGEDTEXTURES );        
    DUMPRS( D3DRENDERSTATE_TEXTUREHANDLE );
    DUMPRS( D3DRENDERSTATE_ANTIALIAS );
    DUMPRS( D3DRENDERSTATE_TEXTUREPERSPECTIVE );
    DUMPRS( D3DRENDERSTATE_TEXTUREMAPBLEND );
    DUMPRS( D3DRENDERSTATE_TEXTUREMAG );
    DUMPRS( D3DRENDERSTATE_TEXTUREMIN );
    DUMPRS( D3DRENDERSTATE_WRAPU );
    DUMPRS( D3DRENDERSTATE_WRAPV );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESS );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESSU );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESSV );
    DUMPRS( D3DRENDERSTATE_MIPMAPLODBIAS );
    DUMPRS( D3DRENDERSTATE_BORDERCOLOR );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN00 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN01 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN02 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN03 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN04 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN05 );   
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN06 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN07 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN08 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN09 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN10 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN11 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN12 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN13 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN14 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN15 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN16 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN17 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN18 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN19 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN20 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN21 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN22 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN23 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN24 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN25 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN26 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN27 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN28 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN29 );   
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN30 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN31 );     
    DUMPRS( D3DRENDERSTATE_ROP2 );
    DUMPRS( D3DRENDERSTATE_PLANEMASK );
    DUMPRS( D3DRENDERSTATE_MONOENABLE );
    DUMPRS( D3DRENDERSTATE_SUBPIXEL );
    DUMPRS( D3DRENDERSTATE_SUBPIXELX );
    DUMPRS( D3DRENDERSTATE_STIPPLEENABLE );
    DUMPRS( D3DRENDERSTATE_COLORKEYENABLE );

#if DX8_DDI
    DISPDBG((lvl,"RELEVANT DX8 renderstates:"));
    DUMPRS( D3DRS_POINTSIZE );
    DUMPRS( D3DRS_POINTSPRITEENABLE );
    DUMPRS( D3DRS_POINTSIZE_MIN );
    DUMPRS( D3DRS_POINTSIZE_MAX );
    DUMPRS( D3DRS_POINTSCALEENABLE );
    DUMPRS( D3DRS_POINTSCALE_A );
    DUMPRS( D3DRS_POINTSCALE_B );
    DUMPRS( D3DRS_POINTSCALE_C );
    DUMPRS( D3DRS_SOFTWAREVERTEXPROCESSING );
    DUMPRS( D3DRS_COLORWRITEENABLE );
    DUMPRS( D3DRS_MULTISAMPLEANTIALIAS );
#endif // DX8_DDI

    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++)
    {
        DISPDBG((lvl," TS[%d].",i));
        for (j=0; j<D3DTSS_MAX; j++)
        {
            DISPDBG((lvl, "    .[%d] = 0x%08x",j,TS[i].m_dwVal[j] ));
        }
    }
} // DumpD3DState

//-----------------------------------------------------------------------------
//
// DumpVertices
//
// Dumps vertices from a VB
// 
//-----------------------------------------------------------------------------
void DumpVertices(int lvl,
                  P3_D3DCONTEXT* pContext, 
                  LPBYTE lpVertices, 
                  DWORD dwNumVertices)
{
    DWORD i,j;
    DWORD *lpw = (DWORD *)lpVertices;

    for (i=0 ; i<dwNumVertices; i++)
    {
        DISPDBG((lvl,"Vertex # %d", i));
        for (j=0; j < pContext->FVFData.dwStride; j+=4)
        {
            DISPDBG((lvl,"        0x%08x",*lpw++));
        }
    }
} // DumpVertices

//-----------------------------------------------------------------------------
//
// DumpHexData
//
// Dumps hexadecimal data
// 
//-----------------------------------------------------------------------------
void DumpHexData(int lvl,
                 LPBYTE lpData, 
                 DWORD dwNumBytes)
{
    DWORD i , iRemChars, iSlen;
    DWORD *lpdw = (DWORD *)lpData;
    char  s[80] = "",m[80] = "";

    iRemChars = 80;

    for (i=0 ; i <= (dwNumBytes / sizeof(DWORD)); i++)
    {
        sprintf(s,"0x%08x ",*lpdw++);

        iSlen = strlen(s);

        if (iSlen < iRemChars)
        {
            strncat(m,s,iRemChars);
            iRemChars -= iSlen;       
        }
        
        if ( ((i % 6) == 5) ||
             (i == (dwNumBytes / sizeof(DWORD))) )             
        {
            DISPDBG((lvl,"%s",m));
            s[0] = m[0] = '\0';
        }
    }
 
    
} // DumpVertices

//-----------------------------------------------------------------------------
//
// DumpDDSurface
//
// Dumps a LPDDRAWI_DDRAWSURFACE_LCL ( PDD_SURFACE_LOCAL on Win2K)  structure
// 
//-----------------------------------------------------------------------------
#define CAPS_REPORT(param)                          \
        if (ddsCaps.dwCaps & DDSCAPS_##param)       \
        {                                           \
            DISPDBG((Level, "   " #param));         \
        }

#define CAPS_REPORT2(param)                         \
        if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_##param)     \
        {                                           \
            DISPDBG((Level, "   " #param));         \
        }

void DumpDDSurface(int DebugLevel, LPDDRAWI_DDRAWSURFACE_LCL pSurface)
{
    LPDDPIXELFORMAT pPixFormat;
    P3_SURF_FORMAT* pFormatSurface = _DD_SUR_GetSurfaceFormat(pSurface);
    DDSCAPS ddsCaps;
    int Level = -100;

    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        DISPDBG((Level,"Surface Dump:"));

        DISPDBG((Level,"Format: %s", pFormatSurface->pszStringFormat));
            
        // Get the surface format
        pPixFormat = DDSurf_GetPixelFormat(pSurface);

        ddsCaps = pSurface->ddsCaps;
        DISPDBG((Level, "    Surface Width:          0x%x", pSurface->lpGbl->wWidth));
        DISPDBG((Level, "    Surface Height:         0x%x", pSurface->lpGbl->wHeight));
        DISPDBG((Level, "    Surface Pitch:          0x%x", pSurface->lpGbl->lPitch));
        DISPDBG((Level, "    ddsCaps.dwCaps:         0x%x", pSurface->ddsCaps.dwCaps));
        DISPDBG((Level, "    dwFlags:                0x%x", pSurface->dwFlags));
        DISPDBG((Level, "  Pixel Format:"));
        DISPDBG((Level, "    dwFourCC:               0x%x", pPixFormat->dwFourCC));
        DISPDBG((Level, "    dwRGBBitCount:          0x%x", pPixFormat->dwRGBBitCount));
        DISPDBG((Level, "    dwR/Y BitMask:          0x%x", pPixFormat->dwRBitMask));
        DISPDBG((Level, "    dwG/U BitMask:          0x%x", pPixFormat->dwGBitMask));
        DISPDBG((Level, "    dwB/V BitMask:          0x%x", pPixFormat->dwBBitMask));
        DISPDBG((Level, "    dwRGBAlphaBitMask:      0x%x", pPixFormat->dwRGBAlphaBitMask));
#ifndef WNT_DDRAW
        DISPDBG((Level, "    DestBlt:     dwColorSpaceLowValue:  0x%x", pSurface->ddckCKDestBlt.dwColorSpaceLowValue));
        DISPDBG((Level, "    DestBlt:     dwColorSpaceHighValue: 0x%x", pSurface->ddckCKDestBlt.dwColorSpaceHighValue));
        DISPDBG((Level, "    SrcBlt:      dwColorSpaceLowValue:  0x%x", pSurface->ddckCKSrcBlt.dwColorSpaceLowValue));
        DISPDBG((Level, "    SrcBlt:      dwColorSpaceHighValue: 0x%x", pSurface->ddckCKSrcBlt.dwColorSpaceHighValue));
#endif
        DISPDBG((Level, "  Surface Is:"));

        CAPS_REPORT(TEXTURE);
        CAPS_REPORT(PRIMARYSURFACE);
        CAPS_REPORT(OFFSCREENPLAIN);
        CAPS_REPORT(FRONTBUFFER);
        CAPS_REPORT(BACKBUFFER);
        CAPS_REPORT(COMPLEX);
        CAPS_REPORT(FLIP);
        CAPS_REPORT(OVERLAY);
        CAPS_REPORT(MODEX);
        CAPS_REPORT(ALLOCONLOAD);
        CAPS_REPORT(LIVEVIDEO);
        CAPS_REPORT(PALETTE);
        CAPS_REPORT(SYSTEMMEMORY);
        CAPS_REPORT(3DDEVICE);
        CAPS_REPORT(VIDEOMEMORY);
        CAPS_REPORT(VISIBLE);
        CAPS_REPORT(MIPMAP);
        // not supported in NT until we get NT5 (which will have DX5)
        CAPS_REPORT(VIDEOPORT);
        CAPS_REPORT(LOCALVIDMEM);
        CAPS_REPORT(NONLOCALVIDMEM);
        CAPS_REPORT(WRITEONLY);

        if (pSurface->lpSurfMore)
        {
            CAPS_REPORT2(HARDWAREDEINTERLACE);
            CAPS_REPORT2(HINTDYNAMIC);
            CAPS_REPORT2(HINTSTATIC);
            CAPS_REPORT2(TEXTUREMANAGE);
            CAPS_REPORT2(OPAQUE);
            CAPS_REPORT2(HINTANTIALIASING);
#if W95_DDRAW
            CAPS_REPORT2(VERTEXBUFFER);
            CAPS_REPORT2(COMMANDBUFFER);
#endif
        }

        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DISPDBG((Level,"   Z BUFFER"));
        }
        
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DISPDBG((Level,"   ALPHAPIXELS"));
        }
        
        // not supported in NT until we get NT5
        if (pPixFormat->dwFlags & DDPF_LUMINANCE)
        {
            DISPDBG((Level,"   LUMINANCE"));
        }

        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DISPDBG((Level,"   ALPHA"));
        }
    }
} // DumpDDSurface


char *pcSimpleCapsString(DWORD dwCaps)
{
    static char flags[5];
        
    flags[0] = flags[1] = flags[2] = flags[3] = ' '; flags[4] = 0;
    
    if(dwCaps & DDSCAPS_TEXTURE) flags[1] = 'T';
    if(dwCaps & DDSCAPS_ZBUFFER) flags[2] = 'Z';
    if(dwCaps & DDSCAPS_3DDEVICE) flags[3] = 'R';        

    if(dwCaps & DDSCAPS_VIDEOMEMORY) 
    {
        flags[0] = 'V'; 
    }
    else if(dwCaps & DDSCAPS_NONLOCALVIDMEM) 
    {
        flags[0] = 'A'; 
    }
    else                   
    {
        flags[0] = 'S';
    }

    return flags;
} // cSimpleCapsString


//-----------------------------------------------------------------------------
//
// DumpDDSurfaceDesc
//
// Dumps a DDSURFACEDESC structure
//
//-----------------------------------------------------------------------------
#define CAPS_REPORT_DESC(param)                             \
        if (pDesc->ddsCaps.dwCaps & DDSCAPS_##param)        \
        {                                                   \
            DISPDBG((Level, "   " #param));                 \
        }

#define CAPS_REPORT_DESC2(param)                                          \
        if (((DDSURFACEDESC2*)pDesc)->ddsCaps.dwCaps2 & DDSCAPS2_##param) \
        {                                                                 \
            DISPDBG((Level, "   " #param));                               \
        }

void DumpDDSurfaceDesc(int DebugLevel, DDSURFACEDESC* pDesc)
{
    DDPIXELFORMAT* pPixFormat = &pDesc->ddpfPixelFormat;
    int Level = -100;

    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        DISPDBG((Level,"Surface Dump:"));
        
        DISPDBG((Level, "    Surface Width:          0x%x", pDesc->dwWidth));
        DISPDBG((Level, "    Surface Height:         0x%x", pDesc->dwHeight));
        DISPDBG((Level, "    ddsCaps.dwCaps:         0x%x", pDesc->ddsCaps.dwCaps));
        DISPDBG((Level, "    dwFlags:                0x%x", pDesc->dwFlags));
        DISPDBG((Level, "Pixel Format:"));
        DISPDBG((Level, "    dwFourCC:               0x%x", pPixFormat->dwFourCC));
        DISPDBG((Level, "    dwRGBBitCount:          0x%x", pPixFormat->dwRGBBitCount));
        DISPDBG((Level, "    dwR/Y BitMask:          0x%x", pPixFormat->dwRBitMask));
        DISPDBG((Level, "    dwG/U BitMask:          0x%x", pPixFormat->dwGBitMask));
        DISPDBG((Level, "    dwB/V BitMask:          0x%x", pPixFormat->dwBBitMask));
        DISPDBG((Level, "    dwRGBAlphaBitMask:      0x%x", pPixFormat->dwRGBAlphaBitMask));
        DISPDBG((Level, "Surface Is:"));

        CAPS_REPORT_DESC(TEXTURE);
        CAPS_REPORT_DESC(PRIMARYSURFACE);
        CAPS_REPORT_DESC(OFFSCREENPLAIN);
        CAPS_REPORT_DESC(FRONTBUFFER);
        CAPS_REPORT_DESC(BACKBUFFER);
        CAPS_REPORT_DESC(COMPLEX);
        CAPS_REPORT_DESC(FLIP);
        CAPS_REPORT_DESC(OVERLAY);
        CAPS_REPORT_DESC(MODEX);
        CAPS_REPORT_DESC(ALLOCONLOAD);
        CAPS_REPORT_DESC(LIVEVIDEO);
        CAPS_REPORT_DESC(PALETTE);
        CAPS_REPORT_DESC(SYSTEMMEMORY);
        CAPS_REPORT_DESC(3DDEVICE);
        CAPS_REPORT_DESC(VIDEOMEMORY);
        CAPS_REPORT_DESC(VISIBLE);
        CAPS_REPORT_DESC(MIPMAP);
        CAPS_REPORT_DESC(VIDEOPORT);
        CAPS_REPORT_DESC(LOCALVIDMEM);
        CAPS_REPORT_DESC(NONLOCALVIDMEM);
        CAPS_REPORT_DESC(STANDARDVGAMODE);
        CAPS_REPORT_DESC(OPTIMIZED);
        CAPS_REPORT_DESC(EXECUTEBUFFER);
        CAPS_REPORT_DESC(WRITEONLY);

        if (pDesc->dwSize == sizeof(DDSURFACEDESC2))
        {
            CAPS_REPORT_DESC2(HARDWAREDEINTERLACE);
            CAPS_REPORT_DESC2(HINTDYNAMIC);
            CAPS_REPORT_DESC2(HINTSTATIC);
            CAPS_REPORT_DESC2(TEXTUREMANAGE);
            CAPS_REPORT_DESC2(OPAQUE);
            CAPS_REPORT_DESC2(HINTANTIALIASING);
#if W95_DDRAW
            CAPS_REPORT_DESC2(VERTEXBUFFER);
            CAPS_REPORT_DESC2(COMMANDBUFFER);
#endif
        }

        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DISPDBG((Level,"   Z BUFFER"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DISPDBG((Level,"   ALPHAPIXELS"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DISPDBG((Level,"   ALPHA"));
        }
    }
}

//-----------------------------------------------------------------------------
//
// DumpDP2Flags
//
// Dumps the meaning of the D3D DrawPrimitives2 flags
//
//-----------------------------------------------------------------------------
void
DumpDP2Flags( DWORD lvl, DWORD flags )
{
    if( flags & D3DHALDP2_USERMEMVERTICES )
        DISPDBG((lvl, "    USERMEMVERTICES" ));

    if( flags & D3DHALDP2_EXECUTEBUFFER )
        DISPDBG((lvl, "    EXECUTEBUFFER" ));

    if( flags & D3DHALDP2_SWAPVERTEXBUFFER )
        DISPDBG((lvl, "    SWAPVERTEXBUFFER" ));

    if( flags & D3DHALDP2_SWAPCOMMANDBUFFER )
        DISPDBG((lvl, "    SWAPCOMMANDBUFFER" ));

    if( flags & D3DHALDP2_REQVERTEXBUFSIZE )
        DISPDBG((lvl, "    REQVERTEXBUFSIZE" ));

    if( flags & D3DHALDP2_REQCOMMANDBUFSIZE )
        DISPDBG((lvl, "    REQCOMMANDBUFSIZE" ));
        
} // DumpDP2Flags

//-----------------------------------------------------------------------------
//
//  ********************** LOW LEVEL DEBUGGING SUPPORT ************************
//
//-----------------------------------------------------------------------------

LONG P3R3DX_DebugLevel = 0;

#if W95_DDRAW

void DebugRIP()       
{
    _asm int 1;
}
#endif  //  W95_DDRAW

static char *BIG    = "<+/-large_float>";

#if defined(_X86_)
void
expandFloats(char *flts, char *format, va_list argp)
{
    int ch;
    double f;
    unsigned int ip, fp;
    int *ap = (int *)argp;
    int *dp = ap;

    while (ch = *format++) {
        if (ch == '%') {
            ch = *format++;     // Get the f, s, c, i, d, x etc...
            if (!ch)
                return;         // If someone foolishly gave me "hello %"
            switch (ch) {
            case 'f':
            case 'g':
            case 'e':
                // Here we have a double that needs 
                // replacing with a string equivalent.
                f = *(double *)ap;
                *(format - 1) = 's';    // Tell it to get a string next time!
                *((char **)dp) = flts;  // This is where I'll put the string
                ap += 2;                // Skip the double in the source
                dp++;                   // Skip the new string pointer
                
                if (f < 0) 
                {
                    *flts++ = '-';
                    f = -f;
                }
                
                if (f > LONG_MAX) 
                {
                    *((char **)ap - 2) = BIG;
                    break;
                }
                myFtoi((int*)&ip, (float)f);
                // The state of the floating point flags is indeterminate here.  
                // You may get truncation which you want, you may get rounding,
                // which you don't want.
                if (ip > f)
                {
                    // rounding will have made (ip = f+1) sometimes
                    ip -= 1;
                }
                
                {
                    double fTemp = ((f * 1e6) - (ip * 1e6));
                    myFtoi((int*)&fp, (float)fTemp);
                }
#if W95_DDRAW
                wsprintf(flts, "%u.%06u", ip, fp);
#endif

                flts += 1 + strlen(flts);       // advance the pointer to where 
                                                // the next float will be expanded
                break;

            case '%':
                break;

            default:
                *dp++ = *ap++;      // copy the argument (down) the list
                break;
            }
        }
    }
} // expandFloats()
#else
void
expandFloats(char *flts, char *format, va_list argp)
{
    // do nothing if it's not _X86_
}
#endif // defined(_X86_)

#ifdef WNT_DDRAW
void Drv_strcpy(char *szDest, char *szSrc)
{
    do
    {
        *szDest++ = *szSrc++;
    } while (*szSrc != 0);
    
    *szDest = '\0';
}

void __cdecl DebugPrintNT(LONG  DebugPrintLevel, PCHAR DebugMessage, ...)
{
    char    floatstr[256];
    char    szFormat[256];

    va_list ap;

    va_start(ap, DebugMessage);

    CheckChipErrorFlags();

    if (DebugPrintLevel <= P3R3DX_DebugLevel)
    {
        Drv_strcpy(szFormat, DebugMessage);
        expandFloats(floatstr, szFormat, ap);
        EngDebugPrint("PERM3DD: ", szFormat, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

} // DebugPrint()
#else

#define START_STR   "DX"
#define END_STR     ""

//
// DebugPrint
//
// display a debug message
//     
void __cdecl DebugPrint(LONG DebugLevelPrint, LPSTR format, ... )
{
    char    str[256];
    char    floatstr[256];
    char    szFormat[256];
    
    va_list ap;

    va_start(ap, format);

    // If you set the debug level negative then you don't check the error
    // flags - this lets an optimised debug build run quicker

    if( P3R3DX_DebugLevel >= 0 )
    {
        CheckChipErrorFlags();
    }

    if (DebugLevelPrint <= P3R3DX_DebugLevel)
    {
        // Take a copy of the format string so that I can change "%f" to "%s".
        lstrcpy(szFormat, format);

        expandFloats(floatstr, szFormat, ap);
        if (g_pThisTemp)
        {
         wsprintf((LPSTR)str, "%s(%d):    ", 
                              START_STR, 
                              (int)g_pThisTemp->pGLInfo->dwCurrentContext);
        }
        else
        {
         wsprintf((LPSTR)str, "%s: 0      ", START_STR);
        }
        
        wvsprintf(str + strlen(START_STR) + 7, szFormat, ap);

        wsprintf( str + strlen( str ), "%s", "\r\n" );

        OutputDebugString( str );
    }

    va_end(ap);
} // DebugPrint 

#endif // WNT_DDRAW

//-----------------------------------------------------------------------------
//
//  ****************** HARDWARE DEPENDENT DEBUGGING SUPPORT *******************
//
//-----------------------------------------------------------------------------

P3_THUNKEDDATA* g_pThisTemp = NULL;

BOOL g_bDetectedFIFOError = FALSE;

BOOL CheckFIFOEntries(DWORD Count)
{
    if (g_pThisTemp)
    {
        if (!g_bDetectedFIFOError)
        {
            g_pThisTemp->EntriesLeft -= Count;
            g_pThisTemp->DMAEntriesLeft -= Count;
    
            // TURN_ON_DISCONNECT will set Entries left to -20000
            if ( ( (signed)g_pThisTemp->EntriesLeft < 0 ) && 
                 ( (signed)g_pThisTemp->EntriesLeft > -10000 ) ) 
            {
                g_bDetectedFIFOError = TRUE;
                return TRUE;
            }
            
            // Disconnects are irrelevant to DMA buffers.
            if ( ( (signed)g_pThisTemp->DMAEntriesLeft < 0 ) && 
                 ( (signed)g_pThisTemp->DMAEntriesLeft > -10000 ) ) 
            {
                g_bDetectedFIFOError = TRUE;
                return TRUE;
            }
        }
    }
    return FALSE;
} // CheckFIFOEntries

#ifdef WNT_DDRAW
void
CheckChipErrorFlags()
{
    char Buff[100];

    if (g_pThisTemp != NULL)
    {
        P3_THUNKEDDATA* pThisDisplay = g_pThisTemp;
        DWORD _temp_ul;
        DWORD _temp_ul2;
        
        _temp_ul = READ_GLINT_CTRL_REG(ErrorFlags); 
        _temp_ul2 = READ_GLINT_CTRL_REG(DeltaErrorFlags); 
        
        _temp_ul |= _temp_ul2; 
        _temp_ul &= ~0x2;       // we're not interested in output fifo errors 
        _temp_ul &= ~0x10;      // ignore any Video FIFO underrun errors on P2
        _temp_ul &= ~0x2000;    // ignore any host-in DMA errors 
        if (_temp_ul != 0) 
        { 
            // DISPDBG((-1000, "PERM3DD: %s", Buff));
            //EngDebugBreak();
            LOAD_GLINT_CTRL_REG(ErrorFlags, _temp_ul); 
            LOAD_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul);
        } 
    }
} // CheckChipErrorFlags()
#else
void
CheckChipErrorFlags()
{
    DWORD dw;
    char buff[64];

    if (!g_pThisTemp) return;
    if (!g_pThisTemp->pGLInfo) return;

    // Only check the error flags if we aren't DMA'ing.
    if (!(g_pThisTemp->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE)) return;

    if (g_pThisTemp->pGlint) {
        dw = g_pThisTemp->pGlint->ErrorFlags & ~0x10;
        if (dw & (dw != 2)) {
            wsprintf(buff, "** Render Chip Error ** [0x%X]!\r\n", dw);
            OutputDebugString(buff);
            g_pThisTemp->pGlint->ErrorFlags = dw;
            OutputDebugString("** Cleared... **\r\n");
            DebugRIP();
        }
        dw = g_pThisTemp->pGlint->DeltaErrorFlags & ~0x10;
        if (dw & (dw != 2)) {
            wsprintf(buff, "** Delta Error ** [0x%X]!\r\n", dw);
            OutputDebugString(buff);
            g_pThisTemp->pGlint->DeltaErrorFlags = dw;
            OutputDebugString("** Cleared... **\r\n");
            DebugRIP();
        }
    }
} // CheckChipErrorFlags()
#endif // WNT_DDRAW

void 
ColorArea(
    ULONG_PTR pBuffer, 
    DWORD dwWidth, 
    DWORD dwHeight, 
    DWORD dwPitch, 
    int iBitDepth, 
    DWORD dwValue)
{
    DWORD CountY;
    DWORD CountX;
    switch (iBitDepth)
    {
        case __GLINT_8BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                BYTE* pCurrentPixel = (BYTE*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (BYTE)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
        case __GLINT_16BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                WORD* pCurrentPixel = (WORD*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (WORD)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
        case __GLINT_32BITPIXEL:
        case __GLINT_24BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                DWORD* pCurrentPixel = (DWORD*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (DWORD)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
    }
} // ColorArea

//@@BEGIN_DDKSPLIT   
static int unitsBits[] = {
    13, 12, 11, 10,
    3, 2, 8, 7,
    18, 15, 14, 6,
    5, 1, 0
};

static char *unitNames[] = {
    "HostOut", "FBWrite", "LogicOp", "Dither",
    "Texture/Fog/Blend", "ColourDDA", "FBRead", "LBWrite",
    "YUV", "TextureRead", "TextureAddress", "StencilDepth",
    "LBRead", "Scissor/Stipple", "Rasterizer"
};

#define NUM_UNITS (sizeof(unitsBits) / sizeof(unitsBits[0]))

void
DisableChipUnits()
{
    int     i, count;
    DWORD   inSpace = g_pThisTemp->pGlint->InFIFOSpace;
    BOOL    helped = FALSE;
    volatile DWORD *testReg;
    volatile DWORD *addrMode = &g_pThisTemp->pGlint->TextureAddressMode;

    DISPDBG((ERRLVL, "TextureAddressMode = 0x%08X", *addrMode));

    i = 0;
    testReg = &g_pThisTemp->pGlint->TestRegister;
    for (count = 0; count < NUM_UNITS; count++) {
        i = 1L << unitsBits[count];
        *testReg = i;
        *testReg = 0;
        *testReg = i;
        *testReg = 0;
        if (inSpace != g_pThisTemp->pGlint->InFIFOSpace) {
            DISPDBG((ERRLVL, "Chip unlocked by disabling unit \"%s\"", unitNames[count]));
            helped = TRUE;
            inSpace = g_pThisTemp->pGlint->InFIFOSpace;
        }
    }

    if (helped) {
        DISPDBG((ERRLVL, "Which helped..."));
    } else {
        DISPDBG((ERRLVL, "Chip still locked"));
        *testReg = ~0UL;
        *testReg = 0;
        *testReg = ~0UL;
        *testReg = 0;
        if (inSpace == g_pThisTemp->pGlint->InFIFOSpace) {
            DISPDBG((ERRLVL, "Writing -1 didn't help"));
        } else {
            DISPDBG((ERRLVL, "BUT! Writing -1 frees some space..."));
        }
    }

    DISPDBG((ERRLVL, "TextureAddressMode = 0x%08X", *addrMode));

} // DisableChipUnits()


#if 0
StatRecord stats[LAST_STAT + 2] = {
    {"Locks         ", 0, 0},
    {"TextureChanges", 0, 0},
    {"D3DSynchs     ", 0, 0},
    {"StateChanges  ", 0, 0},
    {"...no change  ", 0, 0},
    {"Blits         ", 0, 0},
    {"DMA Buffers   ", 0, 0},
    {"DMA DWORDS    ", 0, 0},
    {"DMA time > CPU", 0, 0},
    {"CPU time > DMA", 0, 0},
    {"Wait on DMA   ", 0, 0},
    {"Execute       ", 0, 0},
    {"Tris          ", 0, 0},
    {"FF Tris       ", 0, 0},
    {"Vanilla Render", 0, 0},
    {"Points        ", 0, 0},
    {"Lines         ", 0, 0},
    {"DPrm TFans    ", 0, 0},
    {"DPrm TStrps   ", 0, 0},
    {"DPrm TLists   ", 0, 0},
    {"DPrm TFansIdx ", 0, 0},
    {"DPrm TStrpsIdx", 0, 0},
    {"DPrm TListsIdx", 0, 0},
    {"Total vertices", 0, 0},
    {"...cached     ", 0, 0},
    {"Alpha strips  ", 0, 0},
    {"Mip strips    ", 0, 0},
    {"VALIDATEDEVICE", 0, 0},
    // Add any extras just in front of this comment
    {"**scene no**  ", 0, 0},
    {"**flip count**", 0, 0}
};
#endif
//@@END_DDKSPLIT

const char *getTagString( GlintDataPtr glintInfo, ULONG tag ) {
        return p3r3TagString( tag & ((1 << 12) - 1) );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\linalloc.c ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: linalloc.c
*
* Content: Videomemory linear allocator
*
* Copyright (c) 1995-2001 Microsoft Corporation
\**************************************************************************/

#include "glint.h"

//-----------------------------------------------------------------------------
//
// This module implements video memory allocation. It isn't a great
// allocator (though it IS robust), but mainly it shows how to hook
// up your own if you need/wish to.
//
//-----------------------------------------------------------------------------

// In linalloc.h we define MEMORY_MAP_SIZE and LinearAllocatorInfo
// which are key for our implementation

// This define allows allocations to search more efficiently for free
// memory. If you want to keep things simple you can turn it off
// and things will still work fine.
#define ALLOC_OPTIMIZE 1

// Total number of chunks per element of our memory map array 
// (which is of DWORD type , therefore we use sizeof(DWORD) )
#define CHUNKS_PER_ELEM   (sizeof(DWORD)*8)

// Memory to be managed will be subdivided in "memory chunks". Each memory
// chunk status will be signaled by a bit in the memory map by being turned
// on or off.
#define TOTAL_MEM_CHUNKS  (MEMORY_MAP_SIZE * CHUNKS_PER_ELEM)

// Macros to set, clear and test the value of a given chunk bit without
// worrying about the structure internals.
#define CHUNKNUM_BIT(chunk_num)                                                 \
    (1 << ((chunk_num) % CHUNKS_PER_ELEM))
    
#define CHUNKNUM_ELEM(mmap, chunk_num)                                          \
    mmap[ (chunk_num) / CHUNKS_PER_ELEM ]
    
#define SET_MEM_CHUNK(mmap, chunk_num)                                    \
    CHUNKNUM_ELEM(mmap, chunk_num) |= CHUNKNUM_BIT(chunk_num)
    
#define CLR_MEM_CHUNK(mmap, chunk_num)                                    \
    CHUNKNUM_ELEM(mmap, chunk_num) &= ~CHUNKNUM_BIT(chunk_num)
    
#define MEM_CHUNK_VAL(mmap, chunk_num)                                    \
  ((CHUNKNUM_ELEM(mmap, chunk_num) & CHUNKNUM_BIT(chunk_num)) > 0 ? 1 : 0)

// Macros that do the mapping between real (heap) memory pointers and the
// chunking indices.
#define MEM_BYTES_TO_CHUNKS(pAlloc, dwBytes)                          \
    ( (dwBytes) / pAlloc->dwMemPerChunk +                             \
      ( ((dwBytes) %  pAlloc->dwMemPerChunk)? 1 : 0 )                 \
    )
    
#define CHUNK_NUM_TO_PTR(pAlloc, num)                                 \
    ( (num) * pAlloc->dwMemPerChunk + pAlloc->dwMemStart )
    
#define MEM_PTR_TO_CHUNK_NUM(pAlloc, ptr)                             \
    MEM_BYTES_TO_CHUNKS(pAlloc, ((ptr) - pAlloc->dwMemStart) )

//-----------------------------------------------------------------------------
//
// __LIN_AlignPtr
//
// Return an aligned pointer 
//
//-----------------------------------------------------------------------------
DWORD
__LIN_AlignPtr(DWORD pointer, DWORD alignment)
{
    ULONG ulExtraBytes;

    ulExtraBytes = pointer % alignment;
    
    if (ulExtraBytes == 0)
    {
        ulExtraBytes = alignment;
    }

    // add enough to pointer so that its new value % alignment is == 0
    return (pointer + alignment - ulExtraBytes);
} // __LIN_AlignPtr

//-----------------------------------------------------------------------------
//
// __LIN_CalcMaxChunks
//
//  Calculate the number of chunks in the heap
//
//-----------------------------------------------------------------------------
void
__LIN_CalcMaxChunks(LinearAllocatorInfo* pAlloc)
{
    DWORD n, dwSizeHeap;

    // Compute how many chunks we'll need and what size of heap each 
    // chunk will control for this linear allocator.
    dwSizeHeap = pAlloc->dwMemEnd - pAlloc->dwMemStart;

    // We will need dwMemPerChunk * dwMaxChunks to be >= dwSizeHeap. 
    // We also want dwMaxChunks to be as close to TOTAL_MEM_CHUNKS and
    // we would like (though its not necessary) dwMemPerChunk to be as 2^N.
    // (and making them at least 16 bytes makes life easier for 
    // the alignment requirements we have in this driver).

    for(n = 4; n < 32; n++)
    {
        // our current choice of heap size each chunk will control
        pAlloc->dwMemPerChunk = 1 << n; // 2^N  

        // how many chunks do we need for such case?
        pAlloc->dwMaxChunks = dwSizeHeap / pAlloc->dwMemPerChunk;
        if (dwSizeHeap % pAlloc->dwMemPerChunk != 0) 
        {
            pAlloc->dwMaxChunks++;        
        }

        // can we accept this result to fit in our data structure?
        if (pAlloc->dwMaxChunks <= TOTAL_MEM_CHUNKS)
        {
            // We have as finely grained chunks as we can without
            // exceeding our self imposed limits.
            break;
        }
    }

    // 1 << n is the size of 1 chunk which is 1k on P3 with 256MB video memory
    ASSERTDD((n < 32), "__LIN_CalcMaxChunks : Wrong heap size");
}

//-----------------------------------------------------------------------------
//
// __LIN_ReInitWhenNeeded
//
//  Reinitialize heap allocater if needed. This is important only for
// the Win9x driver which can signal us from the 16bit side in a mode 
// change that it needs the heap to be reinitialized completely. (It will
// do this by simple setting bResetLinAllocator to TRUE).
//
//-----------------------------------------------------------------------------
void 
__LIN_ReInitWhenNeeded(LinearAllocatorInfo* pAlloc)
{
#ifdef W95_DDRAW
    if (pAlloc)
    {
        if (pAlloc->bResetLinAllocator)
        {
            // Clean all previous allocation data in the memory map
            if (pAlloc->pMMap)
            {
                memset(pAlloc->pMMap, 0, sizeof(MemoryMap));            
            }

            // Clean all previous lenght data in the memory map
            if (pAlloc->pLenMap)
            {
                memset(pAlloc->pLenMap, 0, sizeof(MemoryMap));            
            }
       
            // Recalculate max chunks due to change of heap's size
            __LIN_CalcMaxChunks(pAlloc);
        }

        // reinitialization completed
        pAlloc->bResetLinAllocator = FALSE;
    }
#endif  // W95_DDRAW    
} // __LIN_ReInitWhenNeeded

//-----------------------------------------------------------------------------
//
// _DX_LIN_InitialiseHeapManager
//
// Creates the heap manager.  This code is fairly common to this 
// sample app and the dd allocator as it will stand.  The operations
// it performs will be in perm3dd and/or mini, though the shared heap
// memory can be allocated from 16 and 32 bit land.
//
//-----------------------------------------------------------------------------
BOOL 
_DX_LIN_InitialiseHeapManager(LinearAllocatorInfo* pAlloc,
                              DWORD dwMemStart, 
                              DWORD dwMemEnd)
{
    DWORD n;

    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    pAlloc->dwMemStart = dwMemStart;
    pAlloc->dwMemEnd = dwMemEnd;
    pAlloc->bResetLinAllocator = FALSE;

    // Get memory for the allocator's memory map
    pAlloc->pMMap = (MemoryMap*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           sizeof(MemoryMap),
                                           ALLOC_TAG_DX(G));
    if(pAlloc->pMMap == NULL)
    {
        // Out of memory
        return FALSE;
    }

    // Clear the memory map
    memset(pAlloc->pMMap, 0, sizeof(MemoryMap));    

    // Calculate the maximum number of chunks
    __LIN_CalcMaxChunks(pAlloc);

    // Get memory for the allocator's lenght memory map. We'll keep here
    // a map of 0's and 1's where 1 will indicate where the current
    // allocated block ends. That way we won't need to keep any binding 
    // between the allocated addresses and the size of each one in order 
    // to do the right thing when we are asked to free the memory
    pAlloc->pLenMap = (MemoryMap*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           sizeof(MemoryMap),
                                           ALLOC_TAG_DX(H));
    if(pAlloc->pLenMap == NULL)
    {
        // Couln't allocate the lenght map, deallocate the memory map
        HEAP_FREE(pAlloc->pMMap);
        pAlloc->pMMap = NULL;
        
        // Out of memory       
        return FALSE;
    }

    // Clear the lenghts memory map
    memset(pAlloc->pLenMap, 0xFF, sizeof(MemoryMap));       
            
    return TRUE;
    
} // _DX_LIN_InitialiseHeapManager

//-----------------------------------------------------------------------------
//
// _DX_LIN_UnInitialiseHeapManager(pLinearAllocatorInfo pAlloc)
//
// Frees the heap manager.  This code is fairly common to this 
// sample app and the dd allocator as it will stand.  The operations
// it performs will be in p3r3dx and/or mini, though the shared heap
// memory can be allocated from 16 and 32 bit land.
// 
//-----------------------------------------------------------------------------
void _DX_LIN_UnInitialiseHeapManager(LinearAllocatorInfo* pAlloc)
{
    __LIN_ReInitWhenNeeded(pAlloc);

    // Destroy/Clean all previous allocation data
    if (pAlloc)
    {
        if(pAlloc->pMMap)
        {
            HEAP_FREE(pAlloc->pMMap);
            pAlloc->pMMap = NULL;
        }        

        if(pAlloc->pLenMap)
        {
            HEAP_FREE(pAlloc->pLenMap);
            pAlloc->pLenMap = NULL;
        }           
    }

} // _DX_LIN_UnInitialiseHeapManager


//-----------------------------------------------------------------------------
//
// _DX_LIN_AllocateLinearMemory
//
// This is the allocation interface to the allocator.  It gives an
// application the opportunity to allocate a linear chunk of memory
//
//-----------------------------------------------------------------------------
DWORD 
_DX_LIN_AllocateLinearMemory(
    pLinearAllocatorInfo pAlloc, 
    LPMEMREQUEST lpMemReq)
{
    INT i;
    DWORD dwBytes,
          dwCurrStartChunk, 
          dwCurrEndChunk, 
          dwNumContChunksFound, 
          dwContChunksNeeded;
#if ALLOC_OPTIMIZE
    // Each block is CHUNKS_PER_ELE chuncks
    DWORD dwStartLastBlock;
#endif

    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    // Validate the passed data
    if ((lpMemReq == NULL) ||
        (lpMemReq->dwSize != sizeof(P3_MEMREQUEST)))
    {
        DISPDBG((ERRLVL,"ERROR: NULL lpMemReq passed!"));
        return GLDD_INVALIDARGS;
    }

    if ((!pAlloc) || 
        (pAlloc->pMMap == NULL) ||
        (pAlloc->pLenMap == NULL) )
    {
        DISPDBG((ERRLVL,"ERROR: invalid pAlloc passed!"));
        return GLDD_INVALIDARGS;
    }       

    // Always ensure that alignment is a DWORD (or DWORD multiple)
    if (lpMemReq->dwAlign < 4) 
    {
        lpMemReq->dwAlign = 4;
    }
    
    while ((lpMemReq->dwAlign % 4) != 0) 
    {
        lpMemReq->dwAlign++;
    }

    // Always align memory requests to a minimum of a 4 byte boundary
    dwBytes = __LIN_AlignPtr(lpMemReq->dwBytes, lpMemReq->dwAlign);
    if (dwBytes == 0)
    {
        DISPDBG((WRNLVL,"ERROR: Requested 0 Bytes!"));
        return GLDD_INVALIDARGS;
    }

    // Determine how many chunks of memory we'll need to allocate
    dwContChunksNeeded = MEM_BYTES_TO_CHUNKS(pAlloc, dwBytes);
    
    // We don't check if we were called with MEM3DL_FIRST_FIT since 
    // that's the only thing we know how to do right now. We decide
    // whether we'll search from back to front or viceversa. We will
    // scan the memory map in the chosen direction looking for a "hole"
    // large enough for the current request.
    if (lpMemReq->dwFlags & MEM3DL_BACK)
    {
        // We will examine the MemoryMap from the end towards the front
        // looking out for a suitable space with the required number of
        // chunks we need
        dwCurrEndChunk = 0;
        dwNumContChunksFound = 0;
        for ( i = pAlloc->dwMaxChunks - 1; i >= 0 ; i--)
        {
#if ALLOC_OPTIMIZE
            // we are about to start testing a specific  DWORD in 
            // the memory map (going from the end to the start)
            if (( i % 32) == 31)
            {
                // If the whole DWORD is 0xFFFFFFFF (meaning all chunks are
                // already allocated) then we can & should skip it altogheter
                while ((i >= 0) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0xFFFFFFFF))
                {
                    // Search needs to be restarted
                    dwNumContChunksFound = 0;

                    i -= 32;
                }

                // If the whole DWORD is 0x00000000 (meaning none of the
                // chunks is yet allocated) then we could grab all
                while ((i >= 0) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0x00000000) &&
                       !(dwNumContChunksFound >= dwContChunksNeeded))
                {
                    if (dwNumContChunksFound == 0)
                    {
                        dwCurrEndChunk = i;
                    }
                    i -= 32;                    
                    dwNumContChunksFound += 32;
                }

                if (dwNumContChunksFound >= dwContChunksNeeded)
                {
                    // We've found a suitable place! Figure out where it starts
                    dwCurrStartChunk = dwCurrEndChunk - dwContChunksNeeded + 1;
                    break;
                }                 
                else if(!(i >= 0))
                {                    
                    break; // finished examining all memory, break loop here
                }                 
            }            
#endif // ALLOC_OPTIMIZE
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i ) == 0)
            {
                if (dwNumContChunksFound == 0)
                {
                    // our count so far of contigous chunks is zero, 
                    // meaning that were just starting to find free
                    // chunks. We need to remember where this block
                    // is ending
                    dwCurrEndChunk = i;
                }
                dwNumContChunksFound++;            
            }
            else
            {
                // This chunk is being used and we haven't found a suitable
                // set of chunks, so reset our count of contigous chunks 
                // found so far
                dwNumContChunksFound = 0;        
            }

            if (dwNumContChunksFound >= dwContChunksNeeded)
            {
                // We've found a suitable place! Figure out where it starts.
                dwCurrStartChunk = dwCurrEndChunk - dwContChunksNeeded + 1;
                break; // break loop here
            }            
        }    
    }
    else // even if no flags are set lets allocate at the heaps front
    {
        // We will examine the MemoryMap from the front towards the end
        // looking out for a suitable space with the required number of
        // chunks we need
        dwCurrStartChunk = 0;
        dwNumContChunksFound = 0;

#if ALLOC_OPTIMIZE
        // At the end of the heap there might be a region smaller than 
        // CHUNKS_PER_ELEM(32) of chunks, and optimized search of 32
        // chunk free blocks should be disabled in that region.
        dwStartLastBlock = (pAlloc->dwMaxChunks / CHUNKS_PER_ELEM) * 
                           CHUNKS_PER_ELEM;
#endif

        for ( i = 0 ; i < (INT)pAlloc->dwMaxChunks ; i++)
        {
#if ALLOC_OPTIMIZE

            // we are about to start testing a specific 
            // DWORD in the memory map. 
            if (( i % 32) == 0)
            {
                // If the whole DWORD is 0xFFFFFFFF (meaning all chunks are
                // already allocated) then we can & should skip it altogheter
                while ((i < (INT)dwStartLastBlock) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0xFFFFFFFF))
                {
                    // Search needs to be restarted
                    dwNumContChunksFound = 0;

                    i += 32;
                }

                // If the whole DWORD is 0x00000000 (meaning none of the
                // chunks is yet allocated) then we could grab all
                while ((i < (INT)dwStartLastBlock) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0x00000000) &&
                       !(dwNumContChunksFound >= dwContChunksNeeded))
                {
                    if (dwNumContChunksFound == 0)
                    {
                        dwCurrStartChunk = i;
                    }
                    i += 32;                    
                    dwNumContChunksFound += 32;
                }

                if (dwNumContChunksFound >= dwContChunksNeeded)
                {
                    break; // We've found a suitable place! Break loop here
                }  
                else if(!(i < (INT)pAlloc->dwMaxChunks))
                {
                    break; // finished examining all memory, break loop here
                }             
                
            }
#endif // ALLOC_OPTIMIZE
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i) == 0)
            {
                if (dwNumContChunksFound == 0)
                {
                    // our count so far of contigous chunks is zero, 
                    // meaning that were just starting to find free
                    // chunks. We need to remember where this block
                    // is starting
                    dwCurrStartChunk = i;
                }
                dwNumContChunksFound++;            
            }
            else
            {
                // This chunk is being used and we haven't found a suitable
                // set of chunks, so reset our count of contigous chunks 
                // found so far
                dwNumContChunksFound = 0;        
            }

            if (dwNumContChunksFound >= dwContChunksNeeded)
            {
                // We've found a suitable place!
                break; // break loop here
            }            
        }
    }

    // If we found a suitable place lets allocate in it
    if (dwNumContChunksFound >= dwContChunksNeeded)
    {
        // Fill in the return pointer (properly aligned)
        lpMemReq->pMem = __LIN_AlignPtr(CHUNK_NUM_TO_PTR(pAlloc,
                                                         dwCurrStartChunk),
                                        lpMemReq->dwAlign);
        
        for (i = dwCurrStartChunk ; 
             i < (INT)(dwCurrStartChunk + dwContChunksNeeded); 
             i++)
        {
            // Set up the bits in the memory map to indicate those
            // addresses are being used.
            SET_MEM_CHUNK((*pAlloc->pMMap), i);        
            
            // Clear the bits in the lenght memory map to indicate that
            // the alloacted block doesn't end here.
            CLR_MEM_CHUNK((*pAlloc->pLenMap), i);                        
        }

        // Now set the last bit of the lenght map in order to indicate
        // end-of-allocated-block
        SET_MEM_CHUNK((*pAlloc->pLenMap), 
                      dwCurrStartChunk + dwContChunksNeeded - 1);                                

        return GLDD_SUCCESS;
    }    

    return GLDD_NOMEM;

} // _DX_LIN_AllocateLinearMemory


//-----------------------------------------------------------------------------
//
// _DX_LIN_FreeLinearMemory
//
// This is the interface to memory freeing.
// 
//-----------------------------------------------------------------------------
DWORD 
_DX_LIN_FreeLinearMemory(
    pLinearAllocatorInfo pAlloc, 
    DWORD VidPointer)
{
    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    if (pAlloc && pAlloc->pMMap && pAlloc->pLenMap)
    {
        DWORD i, dwFirstChunk;
        BOOL bLast = FALSE;
        
        // Now compute the starting chunk for this VidMem ptr
        dwFirstChunk = MEM_PTR_TO_CHUNK_NUM(pAlloc, VidPointer);

        // Clear the relevant bits in the memory map until the 
        // lenght map indicates we've reached the end of the allocated
        // block 

        i = dwFirstChunk;
        
        while ((!bLast) && (i <= pAlloc->dwMaxChunks))
        {
            // First check if this is the end of the block
            bLast = MEM_CHUNK_VAL((*pAlloc->pLenMap), i );

            // Now "delete" it (even if its the end of the block)
            CLR_MEM_CHUNK((*pAlloc->pMMap), i);
            
            // Set the bits in the lenght memory map for future
            // allocations. 
            SET_MEM_CHUNK((*pAlloc->pLenMap), i);            

            i++;
        } 
        
        return GLDD_SUCCESS;                           
    }

    return GLDD_NOMEM;
    
} // _DX_LIN_FreeLinearMemory


//-----------------------------------------------------------------------------
//
// _DX_LIN_GetFreeMemInHeap
//
// Scans the memory map and reports the memory that is available in it.
// 
//-----------------------------------------------------------------------------
DWORD
_DX_LIN_GetFreeMemInHeap(
    pLinearAllocatorInfo pAlloc)
{
    DWORD dwTotalFreeMem = 0;
    DWORD dwLargestBlock = 0;
    DWORD dwTempSize = 0;
    DWORD i;
    
    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    // Make sure the linear allocator & memory map are valid
    if (pAlloc && pAlloc->pMMap)
    {
        for (i = 0; i < pAlloc->dwMaxChunks ; i++)
        {
            // Check if chunk is free or in use
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i) == 0)
            {
                // Keep track of total free memory
                dwTotalFreeMem++;

                // Keep track of largest single memory area
                dwTempSize++;
                if (dwTempSize > dwLargestBlock)
                {
                    dwLargestBlock = dwTempSize;
                }
            }
            else
            {
                dwTempSize = 0;
            }
        }

        // There is a minimum amount for an allocation to succeed since we have
        // to pad these/ surfaces out to 32x32, so a 32bpp surface requires at 
        // least 4K free.
//@@BEGIN_DDKSPLIT
        // If we say that we have 1.5K free, then we'll fail TDDRAW WHQL test.  Ouch!
//@@END_DDKSPLIT    
        if (dwLargestBlock * pAlloc->dwMemPerChunk >= 4096)
        {
            return dwTotalFreeMem * pAlloc->dwMemPerChunk;
        }        
    }

    return 0;    
    
} // _DX_LIN_GetFreeMemInHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dltamacr.h ===
/******************************Module*Header**********************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: dltamacr.h
*
* Content: Hardware specific macro definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DLTAMACR_H
#define __DLTAMACR_H

#define AS_ULONG(val)    *((volatile DWORD *) &(val))

// Macros defining the different Vertex types.

#define VTX_FOG     (0x1 << 25)        
#define VTX_RGB     (0x7 << 21)
#define VTX_R       (0x1 << 21)
#define VTX_RGBA    (0xF << 21)
#define VTX_COLOR   (0x1 << 30)
#define VTX_SPECULAR (0x1 << 31)
#define VTX_STQ     (0x7 << 16)
#define VTX_KSKD    (0x3 << 19)
#define VTX_KS      (0x1 << 19)
#define VTX_XYZ     (0x7 << 26)
#define VTX_XY      (0x3 << 26)
#define VTX_GRP     (0x2 << 14)

#define GAMBIT_XYZ_VTX              (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_COLOR_VTX        (VTX_GRP | VTX_XYZ | VTX_COLOR)
#define GAMBIT_STQ_VTX              (VTX_GRP | VTX_STQ)
#define GAMBIT_XYZ_STQ_VTX          (VTX_GRP | VTX_XYZ | VTX_STQ)

#ifdef ANTIALIAS
// Scale the screen coordinates by 2 for antialising renderers and bilinear filter down afterwards
#define Y_ADJUST(y)        (((y)) * (float)(2.0f))
#else
#define Y_ADJUST(y)        ((y))
#endif

//
// This loses one bit of accuracy, but adds and clamps without ifs.
// We first mask all channels with 0xfe.  This leaves the lsb of
// each channel clear, so when the terms are added, any carry goes
// into the new highest bit.  Now all we have to do is generate a
// mask for any channels that have overflowed.  So we shift is right
// and eliminate everything but the overflow bits, so each channel
// contains either 0x00 or 0x01.  Subtracting each channel from 0x80
// produces 0x7f or 0x80.  We just shift this left once and mask to
// give 0xfe or 0x00.  (We could eliminate the final mask here, but
// it would introduce noise into the low-bit of every channel..)
//                             

#define CLAMP8888(result, color, specular) \
     result = (color & 0xfefefefe) + (specular & 0xfefefe); \
     result |= ((0x808080 - ((result >> 8) & 0x010101)) & 0x7f7f7f) << 1;


//
// The full mip-level calculation is (log2( texArea/pixArea )) / 2.
// We approximate this by subtracting the exponent of pixArea from
// the exponent of texArea, having converted the floats into their
// bit-wise form. As the exponents start at bit 23, we need to shift
// this difference right by 23 and then once more for the divide by 2.
// We include a bias constant before the final shift to allow matching
// with the true sum-of-squares-of-derivatives calculation ( BIAS_SHIFT
// == 1 ) or whatever other reference image you have.
//

#define MIPSHIFT (23 + 1)

// A bias shift of zero matches 3DWB98's reference mipmap images

#ifndef BIAS_SHIFT
#define BIAS_SHIFT 0
#endif

#define BIAS_CONSTANT (1 << (MIPSHIFT - BIAS_SHIFT))

#define FIND_PERMEDIA_MIPLEVEL()                                     \
{                                                                    \
    int aTex = (int)*(DWORD *)&TextureArea;                          \
    int aPix = (int)*(DWORD *)&PixelArea;                            \
    iNewMipLevel = ((aTex - aPix + BIAS_CONSTANT) >> MIPSHIFT);      \
    if( iNewMipLevel > maxLevel )                                    \
        iNewMipLevel = maxLevel;                                     \
    else                                                             \
    {                                                                \
        if( iNewMipLevel < 0 )                                       \
            iNewMipLevel = 0;                                        \
    }                                                                \
}

#define FLUSH_DUE_TO_WRAP(par,vs)       { if( vs ) pContext->flushWrap_##par = TRUE; }
#define DONT_FLUSH_DUE_TO_WRAP(par,vs)  { if( vs ) pContext->flushWrap_##par = FALSE; }

#define RENDER_AREA_STIPPLE_ENABLE(a) a |= 1;
#define RENDER_AREA_STIPPLE_DISABLE(a) a &= ~1;

#define RENDER_LINE_STIPPLE_ENABLE(a) a |= (1 << 1);
#define RENDER_LINE_STIPPLE_DISABLE(a) a &= ~(1 << 1);

#define RENDER_TEXTURE_ENABLE(a) a |= (1 << 13);
#define RENDER_TEXTURE_DISABLE(a) a &= ~(1 << 13);

#define RENDER_FOG_ENABLE(a) a |= (1 << 14);
#define RENDER_FOG_DISABLE(a) a &= ~(1 << 14);

#define RENDER_SUB_PIXEL_CORRECTION_ENABLE(a) a |= (1 << 16);
#define RENDER_SUB_PIXEL_CORRECTION_DISABLE(a) a &= ~(1 << 16);

#define RENDER_LINE(a) a &= ~(1 << 6);

// Disable line stipple when rendering trapezoid
#define RENDER_TRAPEZOID(a) a = (a & ~(1 << 1)) | (1 << 6);

#define RENDER_POINT(a) a = (a & ~(3 << 6)) | (2 << 6);

#define RENDER_NEGATIVE_CULL_P3(a) a |= (1 << 17);
#define RENDER_POSITIVE_CULL_P3(a) a &= ~(1 << 17);

//*****************************************************
// PERMEDIA3 HW DEFINITIONS WE NEED 
//*****************************************************
#ifdef WNT_DDRAW
// NT needs this for the functions it places in DDEnable, which
// live in the mini directory for W95
typedef struct {
    union {
        struct GlintReg     Glint;
    };
}    *PREGISTERS;

#define DEFAULT_SUBBUFFERS 8

#else

#define DEFAULT_SUBBUFFERS 128

#endif // WNT_DDRAW

// Macros to identify the Permedia3 chip type
#define RENDERCHIP_P3RXFAMILY                                                \
                (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
                
#define RENDERCHIP_PERMEDIAP3                                                \
                ((pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA3_ID) ||  \
                 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR3_ID ))
                 
#define TLCHIP_GAMMA ( pThisDisplay->pGLInfo->dwGammaRev != 0)  

//@@BEGIN_DDKSPLIT
//#define RENDERCHIP_PERMEDIAP2 ((pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA2_ID) || (pThisDisplay->pGLInfo->dwRenderChipID == TIPERMEDIA2_ID))
//#define RENDERCHIP_PERMEDIAFAMILY (pThisDisplay->pGLInfo->dwRenderFamily == PERMEDIA_ID)
//#define RENDERCHIP_PERMEDIAP4 (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA4_ID)
//#define RENDERCHIP_PERMEDIAPLUS (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIAPLUS_ID)
//#define RENDERCHIP_PERMEDIAP2_ST_REV0 (pThisDisplay->pGLInfo->dwRenderChipRev == PERMEDIA2_REV0)
//#define RENDERCHIP_PERMEDIAP2_ST_REV1 (pThisDisplay->pGLInfo->dwRenderChipRev == PERMEDIA2_REV1)
//#define RENDERCHIP_PERMEDIAP2_ST (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA2_ID)
//#define RENDERCHIP_GLINTR3 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR3_ID)
//#define RENDERCHIP_GLINTR4 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR4_ID)
//#define TLCHIP_GAMMA1 (pThisDisplay->pGLInfo->dwRenderChipID == GAMMA_ID)
//#define TLCHIP_GAMMA3 (pThisDisplay->pGLInfo->dwTLChipID == GAMMA3_ID)
//#define TLCHIP_GAMMAFAMILY (pThisDisplay->pGLInfo->dwTLFamily == GAMMA_ID)
//@@END_DDKSPLIT 


// Depth of FB in pixel size
#define GLINTDEPTH8             0
#define GLINTDEPTH16            1
#define GLINTDEPTH32            2
#define GLINTDEPTH24            4

// Bits in the Render command
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__GLINT_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__GLINT_LINE_PRIMITIVE << 6)

#define __RENDER_POINT_PRIMITIVE        (__GLINT_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)
#define __RENDER_TEXTURED_PRIMITIVE     (1 << 13)

// Some constants
#define ONE                     0x00010000

// Macro to take a GLINT logical op and return the enabled LogcialOpMode bits
#define GLINT_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#if WNT_DDRAW


// NT Calls to switch hardware contexts
typedef enum COntextType_Tag {
    ContextType_None,
    ContextType_Fixed,
    ContetxType_RegisterList,
    ContextType_Dump
} ContextType;


extern VOID vGlintFreeContext(
        PPDEV   ppdev,
        LONG    ctxtId);
extern LONG GlintAllocateNewContext(
        PPDEV   ppdev,
        DWORD   *pTag,
        LONG    ntags,
        ULONG   NumSubBuffers,
        PVOID   priv,
        ContextType ctxtType);
extern VOID vGlintSwitchContext(
        PPDEV   ppdev,
        LONG    ctxtId);
                

// On NT Registry variables are stored as DWORDS.
extern BOOL bGlintQueryRegistryValueUlong(PPDEV, LPWSTR, PULONG);
#endif //WNT_DDRAW

#endif //__DLTAMACR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dma.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: dma.h
*
* Content: DMA transport definitons and macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DMA_H
#define __DMA_H


//-----------------------------------------------------------------------------
//
// DMA/Fifo utility function declarations
//
//-----------------------------------------------------------------------------
// Enables a driver to switch between FIFO/DMA operations
void HWC_SwitchToFIFO( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo );
void HWC_SwitchToDMA( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo );
void HWC_AllocDMABuffer(P3_THUNKEDDATA* pThisDisplay);
DWORD WINAPI HWC_StartDMA(P3_THUNKEDDATA* pThisDisplay, 
                          DWORD dwContext, 
                          DWORD dwSize, 
                          DWORD dwPhys, 
                          ULONG_PTR dwVirt, 
                          DWORD dwEvent);
void HWC_GetDXBuffer( P3_THUNKEDDATA*, char*, int );
void HWC_SetDXBuffer( P3_THUNKEDDATA*, char*, int );
void HWC_FlushDXBuffer( P3_THUNKEDDATA* );

//-----------------------------------------------------------------------------
//
// DMA & Fifo common definitions & macros
//
//-----------------------------------------------------------------------------


// Compute the depth of the FIFO depending on if we are a simple 
// Permedia3 or if we are going through the Gamma chip of the GVX1
#define FIFO_DEPTH      ((ULONG)((TLCHIP_GAMMA) ? 32 : 120))

// Always check the FIFO. Remember that the DMA just loads the FIFO, and even
// if the DMA is empty, there can be tons left in the FIFO.
#define DRAW_ENGINE_BUSY(pThisDisplay)                  \
        ( pThisDisplay->pGlint->InFIFOSpace < FIFO_DEPTH )

// We track the fifo space so that we never wait for entries that we don't 
// need to.  We wait for nEntries + 1 instead of nEntries because of an issue
// in the Gamma chip
#define __WAIT_GLINT_FIFO_SPACE(nEntries)               \
{                                                       \
    DWORD dwEntries;                                    \
    do                                                  \
    {                                                   \
        dwEntries = *inFIFOptr;                         \
        if (dwEntries > 120) dwEntries = 120;           \
    } while (dwEntries < nEntries + 1);                 \
}

// Local variables needed on all DX functions that try to use DMA/FIFO
#define P3_DMA_DEFS()                                   \
    ULONG * volatile dmaPtr;                            \
    ULONG * volatile inFIFOptr =                        \
        (ULONG *)(&pThisDisplay->pGlint->InFIFOSpace)


// Debug & free versions to get / commit / flush a buffer
#if DBG

#define P3_DMA_GET_BUFFER()                                \
    {                                                      \
        HWC_GetDXBuffer( pThisDisplay, __FILE__, __LINE__ );   \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;     \
    }

#define P3_DMA_COMMIT_BUFFER()                             \
    {                                                      \
        pThisDisplay->pGLInfo->CurrentBuffer = dmaPtr;     \
        HWC_SetDXBuffer( pThisDisplay, __FILE__, __LINE__ );   \
    }
    
#else
    
#define P3_DMA_GET_BUFFER()                                \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;

#define P3_DMA_COMMIT_BUFFER()                             \
    {                                                      \
        pThisDisplay->pGLInfo->CurrentBuffer =  dmaPtr;    \
    }
      
#endif // DBG


#define P3_DMA_FLUSH_BUFFER()                              \
    {                                                      \
        P3_DMA_COMMIT_BUFFER();                            \
        HWC_FlushDXBuffer( pThisDisplay );                     \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;     \
    }

#if DBG

#define __SET_FIFO_ENTRIES_LEFT(a)      \
do {                                    \
    g_pThisTemp = pThisDisplay;         \
    pThisDisplay->EntriesLeft = (a);    \
} while (0)

#define __SET_DMA_ENTRIES_LEFT(a)       \
do {                                    \
    g_pThisTemp = pThisDisplay;         \
    pThisDisplay->DMAEntriesLeft = (a); \
} while (0)

#define __RESET_FIFO_ERROR_CHECK g_bDetectedFIFOError = FALSE

#else

#define __SET_FIFO_ENTRIES_LEFT(a)
#define __SET_DMA_ENTRIES_LEFT(a)
#define __RESET_FIFO_ERROR_CHECK


#endif // DBG

#if DBG

// Note the DMAEntriesLeft+=2 compensates for the fact that this macro
// doesn't load a DMA Buffer - it writes to the FIFO directly.  That
// means it does need to wait for FIFO space
#define LOAD_GLINT_REG(r, v)                                   \
{                                                              \
    DISPDBG(( DBGLVL, "LoadGlintReg: %s 0x%x", #r, v ));        \
    __SET_DMA_ENTRIES_LEFT(pThisDisplay->DMAEntriesLeft + 2);  \
    CHECK_FIFO(2);                                             \
    MEMORY_BARRIER();                                          \
    pThisDisplay->pGlint->r = v;                               \
    MEMORY_BARRIER();                                          \
}

// Control registers do not require fifo entries
#define LOAD_GLINT_CTRL_REG(r, v)                 \
{                                                 \
    MEMORY_BARRIER();                             \
    pThisDisplay->pGlint->r = v;                  \
    MEMORY_BARRIER();                             \
}

#else

#define LOAD_GLINT_REG(r, v)         \
{                                    \
    MEMORY_BARRIER();                \
    pThisDisplay->pGlint->r = v;     \
    MEMORY_BARRIER();                \
}

#define LOAD_GLINT_CTRL_REG(r, v)    \
{                                    \
    MEMORY_BARRIER();                \
    pThisDisplay->pGlint->r = v;     \
    MEMORY_BARRIER();                \
}
#endif

#define READ_GLINT_CTRL_REG(r)      (pThisDisplay->pGlint->r)

// We wait for nEntries + 1 instead of nEntries because of a bug in Gamma chip

#define WAIT_GLINT_FIFO(nEntries)                        \
    while((READ_GLINT_CTRL_REG (InFIFOSpace)) < nEntries + 1);

#define READ_OUTPUT_FIFO(d) d = READ_GLINT_CTRL_REG(GPFifo[0])
#define GET_DMA_COUNT(c)    c = READ_GLINT_CTRL_REG(DMACount)

#if DBG
#define SET_MAX_ERROR_CHECK_FIFO_SPACE   pThisDisplay->EntriesLeft = 120;
#define SET_ERROR_CHECK_FIFO_SPACES(a)   pThisDisplay->EntriesLeft = (a);
#else
#define SET_MAX_ERROR_CHECK_FIFO_SPACE
#define SET_ERROR_CHECK_FIFO_SPACES(a)
#endif


//-----------------------------------------------------------------------------
//
// DMA EXCLUSIVE definitions & macros
//
// Below macros are used if we have defined that we want a DMA capable build
//-----------------------------------------------------------------------------
#ifdef WANT_DMA

#define WAIT_FIFO(a)                                          \
do { if(pThisDisplay->pGLInfo->InterfaceType != GLINT_DMA)    \
        __WAIT_GLINT_FIFO_SPACE(a);                           \
        __SET_FIFO_ENTRIES_LEFT(a);                           \
        __RESET_FIFO_ERROR_CHECK;                             \
    } while (0)

#define __ENSURE_DMA_SPACE(entries)    \
{                                    \
    if (pThisDisplay->pGLInfo->InterfaceType != GLINT_NON_DMA)                        \
    {                                                                                \
        if(((ULONG_PTR)dmaPtr + entries) >=                                                    \
                (ULONG_PTR)(pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].MaxAddress))    \
        {                            \
            P3_DMA_FLUSH_BUFFER();        \
        }                            \
    }                                \
    else                            \
    {                                \
        pThisDisplay->pGLInfo->CurrentBuffer = (ULONG*)&pThisDisplay->pGlint->GPFifo;        \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;                            \
    }    \
    __SET_DMA_ENTRIES_LEFT(entries);                                                \
    __RESET_FIFO_ERROR_CHECK;                                                        \
}


#define P3_ENSURE_DX_SPACE(entries)        \
{                                          \
    __ENSURE_DMA_SPACE(entries)        \
    __SET_DMA_ENTRIES_LEFT(entries);         \
    __RESET_FIFO_ERROR_CHECK;                \
}

#if WNT_DDRAW
#define WAIT_DMA_COMPLETE   DDWaitDMAComplete(pThisDisplay->ppdev);
#else

extern void Wait_2D_DMA_Complete(P3_THUNKEDDATA* pThisDisplay);

#define PATIENTLY_WAIT_DMA()                \
{                                           \
    volatile DWORD count;                   \
    while (GET_DMA_COUNT(count) > 0)        \
    {                                       \
        if (count < 32)                     \
            count = 1;                      \
        else                                \
            count <<= 1;                    \
        while (--count > 0) NULL;           \
    }                                       \
}

#define WAIT_DMA_COMPLETE \
{                                                                                    \
    CHECK_ERROR();                                                                  \
    if (!(pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE)) {            \
        if (pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_INTR_CONTEXT) {            \
            static int retry = 0;                                                    \
            while (!(pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE))    \
            {                                                                        \
                LOCKUP();                                                            \
            }                                                                        \
        } else {                                                                    \
            if (pThisDisplay->pGLInfo->dwCurrentContext == CONTEXT_DISPLAY_HANDLE) {\
                Wait_2D_DMA_Complete(pThisDisplay);                                 \
            }                                                                       \
            else {                                                                  \
                PATIENTLY_WAIT_DMA();                                               \
                pThisDisplay->pGLInfo->GlintBoardStatus |= GLINT_DMA_COMPLETE;        \
            }                                                                       \
        }                                                                            \
        ASSERTDD( READ_GLINT_CTRL_REG(DMACount) == 0, "DMACount not zero after WAIT_DMA_COMPLETE" );\
        ASSERTDD((READ_GLINT_CTRL_REG(ByDMAControl) & 3 ) == 0, "Bypass DMA not complete after WAIT_DMA_COMPLETE" );\
    }                                                                               \
    else {                                                                          \
        ASSERTDD( READ_GLINT_CTRL_REG(DMACount) == 0, "DMACount not zero despite GLINT_DMA_COMPLETE" );\
        ASSERTDD((READ_GLINT_CTRL_REG(ByDMAControl) & 3 ) == 0, "Bypass DMA not complete despite GLINT_DMA_COMPLETE" );\
    }                                                                               \
    CHECK_ERROR();                                                                  \
}
#endif // WNT_DDRAW

#if WNT_DDRAW
#define SYNC_WITH_GLINT                                                 \
    vNTSyncWith2DDriver(pThisDisplay->ppdev);                           \
    SET_MAX_ERROR_CHECK_FIFO_SPACE                                      
#else

#define SYNC_WITH_GLINT                                                 \
    DISPDBG(( DBGLVL, "SYNC_WITH_GLINT" ));                             \
    WAIT_DMA_COMPLETE                                                   \
    while( pThisDisplay->pGlint->InFIFOSpace < 6 ) /* void */ ;         \
    SET_ERROR_CHECK_FIFO_SPACES(6);                                     \
    LOAD_GLINT_REG(FilterMode, 0x400);                                  \
    LOAD_GLINT_REG(Sync, 0);                                            \
    LOAD_GLINT_REG(FilterMode, 0x0);                                    \
    do {                                                                \
        while (pThisDisplay->pGlint->OutFIFOWords == 0) /* void */ ;    \
    } while (pThisDisplay->pGlint->GPFifo[0] != 0x188);                 \
    DISPDBG((DBGLVL,"Sync at line %d in %s", __LINE__, __FILE__));      \
    SET_MAX_ERROR_CHECK_FIFO_SPACE                                      
#endif // WNT_DDRAW


//-----------------------------------------------------------------------------
//
// FIFO EXCLUSIVE definitions & macros
//
//-----------------------------------------------------------------------------
#else   //!WANT_DMA

#define WAIT_FIFO(a)                                                \
do {                                                                \
    __WAIT_GLINT_FIFO_SPACE(a);                                     \
    __SET_FIFO_ENTRIES_LEFT(a);                                     \
    __RESET_FIFO_ERROR_CHECK;                                       \
} while(0)

#define P3_ENSURE_DX_SPACE(entries)                                 \
{                                                                   \
    dmaPtr = (unsigned long *) (DWORD)pThisDisplay->pGlint->GPFifo; \
    P3_DMA_COMMIT_BUFFER();                                         \
    __SET_DMA_ENTRIES_LEFT(entries);                                \
    __RESET_FIFO_ERROR_CHECK;                                       \
}

#define P3_DMA_FLUSH_BUFFER()                                        \
{                                                                    \
    dmaPtr = (unsigned long *)  pThisDisplay->pGlint->GPFifo;        \
    P3_DMA_COMMIT_BUFFER();                                          \
}

#define WAIT_DMA_COMPLETE

#define SYNC_WITH_GLINT                                              \
    vNTSyncWith2DDriver(pThisDisplay->ppdev);                        \
    SET_MAX_ERROR_CHECK_FIFO_SPACE

#endif // !WANT_DMA

//-----------------------------------------------------------------------------
//
// Win9x specific definitons & macros
//
//-----------------------------------------------------------------------------
#if W95_DDRAW

// wait for DMA to complete (DMACount becomes zero). So as not to kill the
// PCI bus bandwidth for the DMA put in a backoff based on the amount of data
// still left to DMA. Also set the timer going if at any time, the count we
// read is the same as the previous count.
//

#if DBG

#define LOCKUP()                                                  \
    if(( ++retry & 0xfffff ) == 0 )                               \
    {                                                             \
            DISPDBG(( WRNLVL, "Locked up in WAIT_DMA_COMPLETE"    \
                              " - %d retries", retry ));          \
    }

#else

#define LOCKUP()

#endif
#endif // W95_DDRAW

                                                                                                
//-----------------------------------------------------------------------------
//
// Macros used to send data to the Permedia 3 hardware
//
//-----------------------------------------------------------------------------

#define SEND_P3_DATA(tag,data)       \
    {                                \
    MEMORY_BARRIER();                \
    dmaPtr[0] = tag##_Tag;           \
    MEMORY_BARRIER();                \
    dmaPtr[1] = data;                \
    MEMORY_BARRIER();                \
    dmaPtr+=2;                       \
    CHECK_FIFO(2);                   \
    }

#define SEND_P3_DATA_OFFSET(tag,data, i)    \
    {                                       \
    MEMORY_BARRIER();                       \
    dmaPtr[0] = (tag##_Tag + i);            \
    MEMORY_BARRIER();                       \
    dmaPtr[1] = data;                       \
    MEMORY_BARRIER();                       \
    dmaPtr += 2; CHECK_FIFO(2);             \
    }
    
#define COPY_P3_DATA(tag,data)                \
    {                                         \
    MEMORY_BARRIER();                         \
    dmaPtr[0] = tag##_Tag;                    \
    MEMORY_BARRIER();                         \
    dmaPtr[1] = *((unsigned long*) &(data));  \
    MEMORY_BARRIER();                         \
    dmaPtr += 2;                              \
    CHECK_FIFO(2);                            \
    }

#define COPY_P3_DATA_OFFSET(tag,data,i)        \
    {                                          \
    MEMORY_BARRIER();                          \
    dmaPtr[0] = tag##_Tag + i;                 \
    MEMORY_BARRIER();                          \
    dmaPtr[1] = *((unsigned long*) &(data));   \
    MEMORY_BARRIER();                          \
    dmaPtr += 2;                               \
    CHECK_FIFO(2);                             \
    }

#define P3RX_HOLD_CMD(tag, count)                    \
    {                                                \
    MEMORY_BARRIER();                                \
    dmaPtr[0] = ( tag##_Tag | ((count-1) << 16));    \
    dmaPtr++;                                        \
    CHECK_FIFO(1);                                   \
    }

#define P3_DMA_GET_BUFFER_ENTRIES( fifo_count )    \
    {                                              \
    P3_DMA_GET_BUFFER();                           \
    WAIT_FIFO( fifo_count );                       \
    P3_ENSURE_DX_SPACE((fifo_count));              \
    }

#define ADD_FUNNY_DWORD(a)   \
{                            \
    MEMORY_BARRIER();        \
    *dmaPtr++ = a;           \
    MEMORY_BARRIER();        \
    CHECK_FIFO(1);           \
}   

//-----------------------------------------------------------------------------
//
// Setup/Clear discconnect signals
//
// Setting the FIFODiscon register to 1 forces host write retries until 
// the data is accepted (might affect other time-critical processes though)
//
//-----------------------------------------------------------------------------

#if DBG
#define NO_FIFO_CHECK     pThisDisplay->EntriesLeft = -20000;
#define END_NO_FIFO_CHECK pThisDisplay->EntriesLeft = 0;
#else
#define NO_FIFO_CHECK
#define END_NO_FIFO_CHECK
#endif

#define SET_DISCONNECT_CONTROL(val)                            \
if(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA)      \
{                                                              \
    WAIT_FIFO(1);                                              \
    if(pThisDisplay->pGLInfo->dwFlags & GMVF_DELTA)            \
    {                                                          \
        LOAD_GLINT_REG(DeltaDisconnectControl,val);            \
    }                                                          \
    else                                                       \
    {                                                          \
        LOAD_GLINT_REG(FIFODiscon,val);                        \
    }                                                          \
}

#define TURN_ON_DISCONNECT      \
    SET_DISCONNECT_CONTROL(0x1) \
    NO_FIFO_CHECK
    
#define TURN_OFF_DISCONNECT     \
    SET_DISCONNECT_CONTROL(0x0) \
    END_NO_FIFO_CHECK

#define SET_D3D_DISCONNECT_CONTROL(val)                        \
if(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA)      \
{                                                              \
    WAIT_FIFO(1);                                              \
    if(pThisDisplay->pGLInfo->dwFlags & GMVF_DELTA)            \
    {                                                          \
        LOAD_GLINT_REG(DeltaDisconnectControl,val);            \
    }                                                          \
    else                                                       \
    {                                                          \
        LOAD_GLINT_REG(FIFODiscon,val);                        \
    }                                                          \
} 

#define TURN_ON_D3D_DISCONNECT         \
      SET_D3D_DISCONNECT_CONTROL(0x1)  \
      NO_FIFO_CHECK
      

#define TURN_OFF_D3D_DISCONNECT        \
      SET_D3D_DISCONNECT_CONTROL(0x0)  \
      END_NO_FIFO_CHECK



//-----------------------------------------------------------------------------
//
// Macros used to switch the chips hardware context between DDRAW/D3D ops
//
//-----------------------------------------------------------------------------

#define DDRAW_OPERATION(pContext, pThisDisplay)                               \
{                                                                             \
    ASSERTDD(pThisDisplay, "Error: pThisDisplay invalid in DDRAW_OPERATION!");\
    if (!IS_DXCONTEXT_CURRENT(pThisDisplay))                                  \
    {                                                                         \
        DXCONTEXT_IMMEDIATE(pThisDisplay);                                    \
        if (pThisDisplay->b2D_FIFOS == TRUE)                                  \
        {                                                                     \
            HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);            \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);             \
        }                                                                     \
        HWC_SwitchToDDRAW(pThisDisplay, TRUE);                                \
        pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_2D;            \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        if (pThisDisplay->pGLInfo->dwDirectXState != DIRECTX_LASTOP_2D)       \
        {                                                                     \
            if (pThisDisplay->b2D_FIFOS == TRUE)                              \
            {                                                                 \
                HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);        \
            }                                                                 \
            else                                                              \
            {                                                                 \
                HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);         \
            }                                                                 \
            HWC_SwitchToDDRAW(pThisDisplay, FALSE);                           \
            pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_2D;        \
        }                                                                     \
    }                                                                         \
}

#define D3D_OPERATION(pContext, pThisDisplay)                                 \
{                                                                             \
    ASSERTDD(pThisDisplay, "Error: pThisDisplay invalid in D3D_OPERATION!");  \
    ASSERTDD(pContext, "Error: pContext invalid in D3D_OPERATION!");          \
    if (!IS_DXCONTEXT_CURRENT(pThisDisplay))                                  \
    {                                                                         \
        DXCONTEXT_IMMEDIATE(pThisDisplay);                                    \
        if (pContext->b3D_FIFOS == TRUE)                                      \
        {                                                                     \
            HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);            \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);             \
        }                                                                     \
        HWC_SwitchToD3D(pContext, pThisDisplay, TRUE);                        \
        pThisDisplay->pGLInfo->dwDirectXState = (ULONG_PTR)pContext;          \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        if ((pThisDisplay->pGLInfo->dwDirectXState != (ULONG_PTR)pContext) || \
            (pContext->dwDirtyFlags & CONTEXT_DIRTY_RENDER_OFFSETS))          \
        {                                                                     \
            if (pContext->b3D_FIFOS == TRUE)                                  \
            {                                                                 \
                HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);        \
            }                                                                 \
            else                                                              \
            {                                                                 \
                HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);         \
            }                                                                 \
            HWC_SwitchToD3D(pContext, pThisDisplay, FALSE);                   \
            pThisDisplay->pGLInfo->dwDirectXState = (ULONG_PTR)pContext;      \
        }                                                                     \
    }                                                                         \
}


// Function to update the DDDRAW & D3D Software copy
void HWC_SwitchToDDRAW( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry );
void HWC_SwitchToD3D(struct _p3_d3dcontext* pContext, 
                     struct tagThunkedData* pThisDisplay, BOOL bDXEntry);

#endif __DMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\glint.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: glint.h
*
* Content: DX Driver high level definitions and includes
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __GLINT_H
#define __GLINT_H

//*****************************************************
// DRIVER FEATURES CONTROLLED BY DEFINED SYMBOLS
//*****************************************************

#define COMPILE_AS_DX8_DRIVER 1

#if COMPILE_AS_DX8_DRIVER

#define DIRECT3D_VERSION  0x0800 

// DX8_DDI is 1 if the driver is going to advertise itself as a DX8 driver to
// the runtime. Notice that if we are a DX8 driver, we HAVE TO support the
// multisteraming command tokens and a limited semantic of the vertex shader
// tokens to interpret correctly the VertexType being processed
#define DX8_DDI           1
#define DX8_MULTSTREAMS   1
#define DX8_VERTEXSHADERS 1
// These other #defines enable and disable specific DX8 features
// they are included mainly in order to help driver writers locate most of the
// the code specific to the named features. Pixel shaders can't be supported on
// this hardware, only stub functions are offered.
#define DX8_POINTSPRITES  1
#define DX8_PIXELSHADERS  1
#define DX8_3DTEXTURES    1

#if WNT_DDRAW
#define DX8_MULTISAMPLING 1
#else
// On Win9x, AA buffers must be released during Alt-tab switch. Since 
// Perm3 driver doesn't share the D3D context with the 16bit side, this
// feature is disabled to prevent corrupted rendering.
#endif

#else

#define DIRECT3D_VERSION  0x0700 
#define DX8_DDI           0
#define DX8_MULTSTREAMS   0
#define DX8_VERTEXSHADERS 0
#define DX8_POINTSPRITES  0
#define DX8_PIXELSHADERS  0
#define DX8_3DTEXTURES    0
#define DX8_MULTISAMPLING 0
#endif // COMPILE_AS_DX8_DRIVER

// DX7 features which have been highlighted in order to 
// ease their implementation for other hardware parts.
#if WNT_DDRAW
#define DX7_ANTIALIAS      1
#else
// On Win9x, AA buffers must be released during Alt-tab switch. Since 
// Perm3 driver doesn't share the D3D context with the 16bit side, this
// feature is disabled to prevent corrupted rendering.
#endif

#define DX7_D3DSTATEBLOCKS 1
#define DX7_PALETTETEXTURE 1
#define DX7_STEREO         1

// Texture management enables DX8 resource management features
#define DX7_TEXMANAGEMENT  0

//@@BEGIN_DDKSPLIT
//azn W-Buffer disabled because of DCT problems
#define DX7_WBUFFER        0
#define DX7_VERTEXBUFFERS  0
//@@END_DDKSPLIT

// The below symbol is used only to ifdef code which is demonstrative for 
// other DX drivers but which for specific reasons is not part of the 
// current sample driver
#define DX_NOT_SUPPORTED_FEATURE 0

#if DX7_D3DSTATEBLOCKS 
// These #defines bracket code or comments which would be important for 
// TnL capable / pixel shader capable / vertex shader capable parts 
// when processing state blocks commands. 
#define DX7_SB_TNL            0
#define DX8_SB_SHADERS        0
#endif // DX7_D3DSTATEBLOCKS 

//*****************************************************
// PORTING WIN9X-WINNT 
//*****************************************************

// On IA64 , the following Macro sorts out the PCI bus caching problem.
// X86 doesn't need this, but it is handled by the same macro defined in
// ioaccess.h on Win2K/XP. For Win9x we need to define it ourselves as 
// doing nothing.

#if W95_DDRAW
#define MEMORY_BARRIER()
#endif


#if WNT_DDRAW
#define WANT_DMA 1
#endif // WNT_DDRAW

//*****************************************************
// INCLUDE FILES FOR ALL
//*****************************************************

//@@BEGIN_DDKSPLIT
// For internal Win2K build, we can include d3d{8}.h without problem, but
// we have troubles to do so for internal Win9x build, so a couple of error
// codes are patched below. For external DDK builds, both platforms can use
// d3d{8}.h which is what we want to encourage IHVs to do.
#if WNT_DDRAW
//@@END_DDKSPLIT

#if DX8_DDI
#include <d3d8.h>
#else
#include <d3d.h>
#endif

//@@BEGIN_DDKSPLIT
#else
#ifndef D3DERR_WRONGTEXTUREFORMAT

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_DDHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_DDHRESULT(2082)
#define D3DERR_TOOMANYPRIMITIVES                MAKE_DDHRESULT(2083)
#define D3DERR_INVALIDMATRIX                    MAKE_DDHRESULT(2084)
#define D3DERR_TOOMANYVERTICES                  MAKE_DDHRESULT(2085)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_DDHRESULT(2086)
#define D3DERR_DRIVERINVALIDCALL                MAKE_DDHRESULT(2157)

#endif
#endif
//@@END_DDKSPLIT

#if WNT_DDRAW
#include <stddef.h>
#include <windows.h>

#include <winddi.h>      // This includes d3dnthal.h and ddrawint.h
#include <devioctl.h>
#include <ntddvdeo.h>

#include <ioaccess.h>

#define DX8DDK_DX7HAL_DEFINES
#include <dx95type.h>    // For Win 2000 include dx95type which allows 
                         // us to work almost as if we were on Win9x
#include "driver.h"

#else   //  WNT_DDRAW

// These need to be included in Win9x

#include <windows.h>
#include <ddraw.h>

#ifndef __cplusplus
#include <dciman.h>
#endif

#include <ddrawi.h>

#ifdef __cplusplus
#include <dciman.h> // dciman.h must be included before ddrawi.h, 
#endif              // and it needs windows.h

#include <d3dhal.h>

typedef struct tagLinearAllocatorInfo LinearAllocatorInfo, *pLinearAllocatorInfo;

#endif  //  WNT_DDRAW

#if DX8_DDI
// This include file has some utility macros to process
// the new GetDriverInfo2 GUID calls
#include <d3dhalex.h>
#endif

// Our drivers include files 
#include "debug.h"
#include "softcopy.h"
#include "glglobal.h"
#include "glintreg.h"
#include "d3dstrct.h"
#include "linalloc.h"
#include "glddtk.h"
#include "directx.h"
#include "bitmac2.h"
#include "direct3d.h"
#include "dcontext.h"
#include "d3dsurf.h"
#include "dltamacr.h"

//*****************************************************
// TEXTURE MANAGEMENT DEFINITIONS
//*****************************************************
#if DX7_TEXMANAGEMENT
#if COMPILE_AS_DX8_DRIVER
// We will only collect stats in the DX7 driver
#define DX7_TEXMANAGEMENT_STATS 0
#else
#define DX7_TEXMANAGEMENT_STATS 1
#endif // COMPILE_AS_DX8_DRIVER

#include "d3dtxman.h"

#endif // DX7_TEXMANAGEMENT

#endif __GLINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\brush.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Brush.c
*
* Content: Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

/////////////////////////////////////////////////////////////////////////////
//
//  bDeviceBrush[SurfaceBpp][PatternBpp]
//
//  0   1       2       3       4       5       6       7       8
//  0   1BPP    4BPP    8BPP    16BPP   24BPP   32BPP   4RLE    8RLE (brush)
//
BOOL bDeviceBrush[BMF_8RLE + 1][BMF_8RLE + 1] = 
{
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 0
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 1bpp
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 4bpp
    {0, 1,      0,      1,      1,      0,      0,      0,      0   }, // 8bpp
    {0, 1,      0,      1,      1,      0,      0,      0,      0   }, // 16bpp
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 24bpp (screen)
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 32bpp
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 4RLE
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }  // 8RLE
};

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
* in some other function like DrvBitBlt, and GDI doesn't happen have a cached
* realization lying around.
*
* Input:
*
*   ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
*                              realized for transparency.  If this hint is
*                              wrong, there will be no error, but the brush
*                              will have to be unnecessarily re-realized.
*
* Note: You should always set 'ppdev->bRealizeTransparent' before calling
*       BRUSHOBJ_pvGetRbrush!
*
\**************************************************************************/

BOOL
DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    static ULONG iBrushUniq = 0;
    PDEV*   ppdev = (PDEV*) psoDst->dhpdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    USHORT* pusDst;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;
    GLINT_DECL;

    DISPDBG((DBGLVL, "DrvRealizeBrush called for pbo 0x%08X", pbo));

    if( iHatch & RB_DITHERCOLOR )
    {
        // Let GDI to handle this brush.
        goto ReturnFalse;
    }

    iPatternFormat = psoPattern->iBitmapFormat;

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
    {
        goto ReturnFalse;
    }

    if (bDeviceBrush[ppdev->iBitmapFormat][iPatternFormat])
    {
        prb = BRUSHOBJ_pvAllocRbrush(pbo,
                                     sizeof(RBRUSH) +
                                     (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if( prb == NULL )
        {
            goto ReturnFalse;
        }

        // Initialize the fields we need:

        prb->ptlBrushOrg.x = LONG_MIN;
        prb->iUniq         = ++iBrushUniq;
        prb->fl            = 0;
        prb->apbe          = NULL;

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((DBGLVL, "Realizing un-translated brush"));

                // The pattern is the same colour depth as the screen, and
                // there's no translation to be done:

                cj = (8 << ppdev->cPelSize);    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);
                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((DBGLVL, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                goto ReturnFalse;
            }
        }
        else if (iPatternFormat == BMF_1BPP)
        {
            DWORD   Data;

            DISPDBG((DBGLVL, "Realizing 1bpp brush"));

            // We dword align the monochrome bitmap so that every row starts
            // on a new long (so that we can do long writes later to transfer
            // the bitmap to the area stipple unit).

            for (i = 8; i != 0; i--)
            {
                // Replicate the brush to 32 bits wide, as the TX cannot
                // span fill 8 bit wide brushes

                Data = (*pjSrc) & 0xff;
                Data |= Data << 8;
                Data |= Data << 16;
                *(DWORD *)pjDst = Data;

                // area stipple is loaded with DWORDS

                pjDst += sizeof(DWORD);
                pjSrc += lSrcDelta;
            }

            pulXlate         = pxlo->pulXlate;
            prb->fl         |= RBRUSH_2COLOR;
            prb->ulForeColor = pulXlate[1];
            prb->ulBackColor = pulXlate[0];
        }
        else if ((iPatternFormat == BMF_4BPP) &&
                 (ppdev->iBitmapFormat == BMF_8BPP))
        {
            DISPDBG((DBGLVL, "Realizing 4bpp brush"));

            // The screen is 8bpp and the pattern is 4bpp:

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                // Inner loop is repeated only 4 times because each iteration
                // handles 2 pixels:

                for (j = 4; j != 0; j--)
                {
                    *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                    *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                    pjSrc++;
                }

                pjSrc += lSrcDelta - 4;
            }
        }
        else if ((iPatternFormat == BMF_8BPP) &&
                 (ppdev->iBitmapFormat == BMF_16BPP))
        {
            DISPDBG((DBGLVL, "Realizing 8bpp translated brush"));

            // The screen is 16bpp, and there's translation to be done:

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                for (j = 8; j != 0; j--)
                {
                    *((USHORT *) pjDst) = (USHORT)pulXlate[*pjSrc++];
                    pjDst += 2;
                }

                pjSrc += lSrcDelta - 8;
            }
        }
        else
        {
            goto ReturnFalse;
        }

        DISPDBG((DBGLVL, "DrvRealizeBrush returning true"));
        return TRUE;
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((WRNLVL, "Failed realization -- "
                         "Type: %li Format: %li cx: %li cy: %li",
                          psoPattern->iType, 
                          psoPattern->iBitmapFormat,
                          psoPattern->sizlBitmap.cx, 
                          psoPattern->sizlBitmap.cy));
    }

    DISPDBG((DBGLVL, "DrvRealizeBrush returning false"));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\color.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\dma.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: dma.c
*
* Content: Handling of DMA buffers.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

//
// Normally, we should not use global variables but the DMA buffers provided
// by the miniport are global across all PDEVs and need be initialized only
// once.
//

typedef struct _DMA_INFORMATION {
    ULONG             NumDMABuffers;
    QUERY_DMA_BUFFERS DMABuffer[1];
} DMAInformation, *LPDMAInformation;

LPDMAInformation gpDMABufferInfo = (LPDMAInformation)0;

/******************************Public*Routine******************************\
* VOID bGlintInitializeDMA
*
* Interrogate the miniport to see if DMA is supported. If it is, map in the
* DMA buffers ready for use by the 3D extension.
*
\**************************************************************************/

VOID vGlintInitializeDMA(PPDEV ppdev)
{
    DMA_NUM_BUFFERS queryDMA;
    ULONG   enableFlags;
    LONG    Length;
    LONG    ExtraLength;
    ULONG   i;

    GLINT_DECL;

    glintInfo->pxrxDMA = &glintInfo->pxrxDMAnonInterrupt;

    return; //azntst for multimon 

    // check the miniport has initialised DMA
    //
    glintInfo->MaxDMASubBuffers = 0;
    if (!(ppdev->flCaps & CAPS_DMA_AVAILABLE))
    {
        return;
    }


    // in the multi-board case we only want one set of DMA buffers which
    // are global across all boards. But we have an interrupt per board.
    // So if the DMA buffers are sorted out try setting up the interrupt.
    //
    if (gpDMABufferInfo != NULL)
    {
        goto TryInterrupts;
    }

    // query the number of DMA buffers. If this fails we have no DMA
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS,
                         NULL,
                         0,
                         &queryDMA,
                         sizeof(DMA_NUM_BUFFERS),
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_NUM_DMA_BUFFERS failed: "
                         "No GLINT DMA available"));
        return;
    }
    
    Length = queryDMA.NumBuffers * queryDMA.BufferInformationLength;
    ExtraLength = sizeof(DMAInformation) - sizeof(QUERY_DMA_BUFFERS);

    DISPDBG((ERRLVL, "%d DMA buffers available. Total info size = 0x%x",
                     queryDMA.NumBuffers, Length));

    // allocate space for the DMA information
    //

    gpDMABufferInfo = (LPDMAInformation)ENGALLOCMEM(
                              FL_ZERO_MEMORY,
                              ExtraLength + Length,
                              ALLOC_TAG_GDI(1));

    if (gpDMABufferInfo == NULL)
    {
        DISPDBG((ERRLVL, "vGlintInitializeDMA: Out of memory"));
        return;
    }

    gpDMABufferInfo->NumDMABuffers = queryDMA.NumBuffers;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_DMA_BUFFERS,
                         NULL,
                         0,
                         (PVOID)(&gpDMABufferInfo->DMABuffer[0]),
                         Length,
                         &Length))
    {
        ENGFREEMEM(gpDMABufferInfo);
        gpDMABufferInfo = NULL;
        DISPDBG((ERRLVL, "QUERY_DMA_BUFFERS failed: No GLINT DMA available"));
        return;
    }

    DISPDBG((ERRLVL, "IOCTL returned length %d", Length));

    // zero the flags for each record
    //
    for (i = 0; i < queryDMA.NumBuffers; ++i)
    {
        gpDMABufferInfo->DMABuffer[i].flags = 0;
    }

#if DBG
    {
        ULONG j;
        PUCHAR pAddr;
        for (i = 0; i < queryDMA.NumBuffers; ++i)
        {
            DISPDBG((ERRLVL,"DMA buffer %d: phys 0x%x, virt 0x%x"
                            ", size 0x%x, flags 0x%x", i,
                            gpDMABufferInfo->DMABuffer[i].physAddr.LowPart,
                            gpDMABufferInfo->DMABuffer[i].virtAddr,
                            gpDMABufferInfo->DMABuffer[i].size,
                            gpDMABufferInfo->DMABuffer[i].flags));
            pAddr = gpDMABufferInfo->DMABuffer[i].virtAddr;
            for (j = 0; j < gpDMABufferInfo->DMABuffer[i].size; ++j)
                *pAddr++ = (UCHAR)(j & 0xff);
        }
    }
#endif

TryInterrupts:

    if (!INTERRUPTS_ENABLED)
    {
        return;
    }

    // map in the interrupt command control block. This is a piece of memory
    // shared with the intrerrupt controller which allows us to send control
    // what happens on VBLANK and DMA interrupts.
    //
    Length = sizeof(PVOID);

    DISPDBG((WRNLVL, "calling IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF"));

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF,
                         NULL,
                         0,
                         (PVOID)&(glintInfo->pInterruptCommandBlock),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF failed."));
        return;
    }
#if DBG
    else
    {
        DISPDBG((WRNLVL, "got command buffer at 0x%x", 
                         glintInfo->pInterruptCommandBlock));
        DISPDBG((WRNLVL, "front, back, end indexes = %d, %d, %d",
                         glintInfo->pInterruptCommandBlock->frontIndex,
                         glintInfo->pInterruptCommandBlock->backIndex,
                         glintInfo->pInterruptCommandBlock->endIndex));
    }
#endif

    // if we get here we have both DMA and interrupts so set for interrupt
    // driven DMA. Don't turn on interrupts yet. That has to be done on a
    // per context basis.
    //
    DISPDBG((WRNLVL, "Using interrupt driven DMA"));
    glintInfo->flags |= GLICAP_INTERRUPT_DMA;

    glintInfo->MaxDMASubBuffers = glintInfo->pInterruptCommandBlock->maximumIndex;
    glintInfo->pxrxDMA = &glintInfo->pInterruptCommandBlock->pxrxDMA;

    return;
}

/******************************Public*Routine******************************\
* ULONG anyFreeDMABuffers
*
* Return number of unused DMA buffers available
*
\**************************************************************************/

ULONG anyFreeDMABuffers(void)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG              i;
    ULONG numAvailable = 0;

    if (!gpDMABufferInfo)
    {
        return 0;
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (!(pDma->flags & DMA_BUFFER_INUSE))
        {
            numAvailable++;
        }
        ++pDma;
    }

    return numAvailable;
}

/******************************Public*Routine******************************\
* ULONG GetFreeDMABuffer
*
* Return info about a DMA buffer and mark it as in use.
* -1 is returned if no buffer is available.
*
\**************************************************************************/

LONG GetFreeDMABuffer(PQUERY_DMA_BUFFERS dmaBuf)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG    i;

    if (!gpDMABufferInfo)
    {
        return(-1);
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (!(pDma->flags & DMA_BUFFER_INUSE))
        {
            pDma->flags |= DMA_BUFFER_INUSE;
            *dmaBuf = *pDma;
            DISPDBG((WRNLVL, "Allocated DMA buffer %d", i));
            return(i);
        }
        ++pDma;
    }

    // all are in use
    DISPDBG((ERRLVL, "No more DMA buffers available"));

    return(-1);
}

/******************************Public*Routine******************************\
* VOID FreeDMABuffer
*
* Mark the given DMA buffer as free. The caller passes in the physical
* address of the buffer.
*
\**************************************************************************/

VOID FreeDMABuffer(PVOID physAddr)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG    i;

    if (!gpDMABufferInfo)
    {
        return;
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (pDma->physAddr.LowPart == (UINT_PTR)physAddr)
        {
            pDma->flags &= ~DMA_BUFFER_INUSE;
            break;
        }
        ++pDma;
    }             

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\dx\stateset.c ===
/******************************Module*Header**********************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: hwcontxt.c
*
* Content: Manages hardware context switching between GDI/DD/D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// Driver Version
//
// This helps us find out from the debugger what driver is loaded on a given 
// remote system
//
//-----------------------------------------------------------------------------

char gc_DriverVersion[] = 
#if DX8_DDI 
                         " DX8"
#else
                         " DX7"
#endif
                         
#if DBG
                         " CHECKED DRIVER"
#else
                         " FREE DRIVER"
#endif
                         " In Path: "  __FILE__ 
                         " Compiled on Date: "   __DATE__  
                         " Time: "  __TIME__  
                         " With #defines: "                          
                         "  DX8_MULTSTREAMS: "      
#if DX8_MULTSTREAMS
                                "1"
#else
                                "0"
#endif
                         "  DX8_VERTEXSHADERS: "    
#if DX8_VERTEXSHADERS
                                "1"
#else
                                "0"
#endif                       
                         "  DX8_POINTSPRITES: "      
#if DX8_POINTSPRITES
                                "1"
#else
                                "0"
#endif                      
                         "  DX8_PIXELSHADERS: "     
#if DX8_PIXELSHADERS
                                "1"
#else
                                "0"
#endif                         
                         "  DX8_3DTEXTURES: "     
#if DX8_3DTEXTURES
                                "1"
#else
                                "0"
#endif                           
                         "  DX8_MULTISAMPLING: "     
#if DX8_MULTISAMPLING
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_ANTIALIAS: "         
#if DX7_ANTIALIAS
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_D3DSTATEBLOCKS: "    
#if DX7_D3DSTATEBLOCKS
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_PALETTETEXTURE: "    
#if DX7_PALETTETEXTURE
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_STEREO: "            
#if DX7_STEREO
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_TEXMANAGEMENT: "     
#if DX7_TEXMANAGEMENT
                                "1"
#else
                                "0"
#endif                           
                            ;

//-----------------------------------------------------------------------------
//
// __HWC_SwitchToDX
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate to both DirectDraw and Direct3D.
//
//-----------------------------------------------------------------------------
void __HWC_SwitchToDX( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry)
{
    P3_DMA_DEFS();

    P3_DMA_GET_BUFFER_ENTRIES(4);

    SEND_P3_DATA(SizeOfFramebuffer, pThisDisplay->pGLInfo->ddFBSize >> 4);

    // We have entered the DirectX driver from a
    // foreign context (such as the display driver)
    if (bDXEntry)
    {
//@@BEGIN_DDKSPLIT    
#if DX7_VERTEXBUFFERS    
        // First cause a flush of all buffers
        // We know this is safe because the contex switch 
        // from the other driver to here will have caused a sync
        // and the buffers must therefore have been consumed
        // therefore we call with bWait == FALSE
        _D3D_EB_FlushAllBuffers(pThisDisplay, FALSE);
#endif //DX7_VERTEXBUFFERS        
//@@END_DDKSPLIT

        // Reset the hostin ID
        SEND_P3_DATA(HostInID, 0);
        pThisDisplay->dwCurrentSequenceID = 0;
    }

    P3_DMA_COMMIT_BUFFER();

    if (bDXEntry)
    {
        P3_DMA_GET_BUFFER_ENTRIES( 4 );

        // Reset the RenderID to the last-used one.
        SEND_HOST_RENDER_ID ( GET_HOST_RENDER_ID() );
        P3_DMA_FLUSH_BUFFER();

        // Need to push the render ID to the end of the pipe...
        SYNC_WITH_GLINT;

        // ...and now it's valid.
        pThisDisplay->bRenderIDValid = (DWORD)TRUE;

    }
} // __HWC_SwitchToDX

//-----------------------------------------------------------------------------
//
// HWC_SwitchToDDRAW
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate specifically to DirectDraw
//
//-----------------------------------------------------------------------------
void HWC_SwitchToDDRAW( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry)
{
    P3_DMA_DEFS();

    __HWC_SwitchToDX(pThisDisplay, bDXEntry);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Disable various units
    SEND_P3_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LineStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(ScissorMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(FogMode,              __PERMEDIA_DISABLE);
    SEND_P3_DATA(AntialiasMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaTestMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(DepthMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FilterMode,           __PERMEDIA_DISABLE);

    P3_ENSURE_DX_SPACE(30);
    WAIT_FIFO(30);

    // Frame buffer
    SEND_P3_DATA(FBSourceData,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBWriteMode,         __PERMEDIA_ENABLE);

    // We sometimes use the scissor in DDRAW to scissor out unnecessary pixels.
    SEND_P3_DATA(ScissorMinXY, 0);
    SEND_P3_DATA(ScissorMaxXY, (pThisDisplay->cyMemory << 16) | 
                               (pThisDisplay->cxMemory)         );
    SEND_P3_DATA(ScreenSize, (pThisDisplay->cyMemory << 16) | 
                             (pThisDisplay->cxMemory)           );
    
    SEND_P3_DATA(WindowOrigin, 0x0);

    // DirectDraw might not need to set these up
    SEND_P3_DATA(dXDom, 0x0);
    SEND_P3_DATA(dXSub, 0x0);
    SEND_P3_DATA(dY, 1 << 16);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    SEND_P3_DATA(GIDMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE);

    // Delta Unit
    SEND_P3_DATA(DeltaControl, 0);
    SEND_P3_DATA(DeltaMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(FBSourceReadMode,  __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadEnables, __PERMEDIA_DISABLE);

    // DDraw driver code doesn't want offsets
    SEND_P3_DATA(LBSourceReadBufferOffset, 0);
    SEND_P3_DATA(LBDestReadBufferOffset,   0);
    SEND_P3_DATA(LBWriteBufferOffset,      0);
    SEND_P3_DATA(FBWriteBufferOffset0,     0);
    SEND_P3_DATA(FBDestReadBufferOffset0,  0);
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);

    P3_ENSURE_DX_SPACE(12);
    WAIT_FIFO(12);
    
    // Local buffer
    SEND_P3_DATA(LBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBDestReadMode,   __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteFormat,    __PERMEDIA_DISABLE);

    // Blending
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    // Texturing (disable)
    SEND_P3_DATA(TextureReadMode0,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureReadMode1,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureIndexMode0,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureIndexMode1,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCoordMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(ChromaTestMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureFilterMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTTransfer,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTIndex,                  __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTAddress,                __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTMode,                   __PERMEDIA_DISABLE);

    SEND_P3_DATA(RasterizerMode,            __PERMEDIA_DISABLE);

    // Router setup.  DDRAW doesn't care about Z Writes
    SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);

    P3_DMA_COMMIT_BUFFER();

} //HWC_SwitchToDDRAW

//-----------------------------------------------------------------------------
//
// HWC_SwitchToD3D
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate specifically to Direct3D
//
//-----------------------------------------------------------------------------
void 
HWC_SwitchToD3D( 
    P3_D3DCONTEXT *pContext, 
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL bDXEntry)
{
    P3_SOFTWARECOPY* pSoftPermedia = &pContext->SoftCopyGlint;
    int i;
    P3_DMA_DEFS();

    // Switch first to the common DX/DDraw/D3D setup
    __HWC_SwitchToDX(pThisDisplay, bDXEntry);

    P3_DMA_GET_BUFFER();

#if DBG
    ASSERTDD(IS_DXCONTEXT_CURRENT(pThisDisplay), 
                    "ERROR: DX Context not current in HWC_SwitchToDDRAW!");
    if ( ((ULONG_PTR)dmaPtr >= (ULONG_PTR)pThisDisplay->pGlint->GPFifo) &&
         ((ULONG_PTR)dmaPtr <= (ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000) )
    {
        ASSERTDD(pThisDisplay->pGLInfo->InterfaceType != GLINT_DMA,
                 "Error: In FIFO space and setup for DMA");
    }
    else
    {
        ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                 "Error: In DMA space and setup for FIFO's");
    }
#endif

    // Now we restore default values and restore D3D context dependent settings
    // directly from what we stored in our context structure.

    // Common registers
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(16);
    SEND_P3_DATA(WindowOrigin, 0);
    SEND_P3_DATA(AreaStippleMode, 1);
    COPY_P3_DATA(DitherMode, pSoftPermedia->DitherMode);

    WAIT_FIFO(16);
    COPY_P3_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
    COPY_P3_DATA(Window, pSoftPermedia->PermediaWindow);
#if DX8_DDI   
    SEND_P3_DATA(FBHardwareWriteMask, pContext->dwColorWriteHWMask);      
    SEND_P3_DATA(FBSoftwareWriteMask, pContext->dwColorWriteSWMask);
#else
    SEND_P3_DATA(FBHardwareWriteMask, 
                            pContext->RenderStates[D3DRENDERSTATE_PLANEMASK]);
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);    
#endif
    SEND_P3_DATA(FilterMode,           __PERMEDIA_DISABLE);


    // Force the flat stippled alpha renderers to reload 
    // the stipple pattern if needed.
    P3_ENSURE_DX_SPACE(32);    // First 16 Stipple registers
    WAIT_FIFO(32);
    for( i = 0; i < 16; i++ )
    {
        SEND_P3_DATA_OFFSET( AreaStipplePattern0, 
                            (DWORD)pContext->CurrentStipple[i], i );
    }
    
    P3_ENSURE_DX_SPACE(32);    // Second set of 16 Stipple registers 
    WAIT_FIFO(32);          // (loaded separately to have GVX1 compatibilty)
    for( i = 16; i < 32; i++ )
    {
        SEND_P3_DATA_OFFSET( AreaStipplePattern0, 
                            (DWORD)pContext->CurrentStipple[i], i );
    }

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(GIDMode, 0);

    // Don't want offsets
    SEND_P3_DATA(LBSourceReadBufferOffset, 0);
    SEND_P3_DATA(LBDestReadBufferOffset,   0);
    SEND_P3_DATA(LBWriteBufferOffset,      0);
    SEND_P3_DATA(FBWriteBufferOffset0,     0);
    SEND_P3_DATA(FBDestReadBufferOffset0,  0);
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);

    // Frame buffer
    SEND_P3_DATA(FBSourceReadMode,  __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadEnables, __PERMEDIA_DISABLE);

    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(GIDMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE);

    // Frame buffer 
    COPY_P3_DATA(FBWriteMode, pSoftPermedia->P3RXFBWriteMode);

    // Delta
    COPY_P3_DATA(DeltaMode,    pSoftPermedia->P3RX_P3DeltaMode);
    COPY_P3_DATA(DeltaControl, pSoftPermedia->P3RX_P3DeltaControl);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(XBias, *(DWORD*)&pContext->XBias);
    SEND_P3_DATA(YBias, *(DWORD*)&pContext->YBias);

    // Disable chroma tests
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE);

    // Router setup
    SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);

    SEND_P3_DATA( VertexTagList0, V0FloatX_Tag );
    SEND_P3_DATA( VertexTagList1, V0FloatY_Tag );
    SEND_P3_DATA( VertexTagList2, V0FloatZ_Tag );
    SEND_P3_DATA( VertexTagList3, V0FloatQ_Tag );
    SEND_P3_DATA( VertexTagList4, V0FloatPackedColour_Tag );
    SEND_P3_DATA( VertexTagList5, V0FloatPackedSpecularFog_Tag );
    SEND_P3_DATA( VertexTagList6, V0FloatS_Tag );
    SEND_P3_DATA( VertexTagList7, V0FloatT_Tag );
    SEND_P3_DATA( VertexTagList8, V0FloatS1_Tag );
    SEND_P3_DATA( VertexTagList9, V0FloatT1_Tag );

    // Restore the texturecachereplacement mode.
    COPY_P3_DATA(TextureCacheReplacementMode, 
                        pSoftPermedia->P3RXTextureCacheReplacementMode);

    SEND_P3_DATA( ProvokingVertexMask, 0xfff );    

    P3_ENSURE_DX_SPACE(8);
    WAIT_FIFO(8);

    COPY_P3_DATA( LineStippleMode, pSoftPermedia->PXRXLineStippleMode);    

    P3_DMA_COMMIT_BUFFER();

//@@BEGIN_DDKSPLIT
// azn - is this really necessary???
//@@END_DDKSPLIT

    // This will cause the FVF state to be recalculated
    ZeroMemory(&pContext->FVFData, sizeof(FVFOFFSETS));

    // Force everything to be set up again before rendering
    DIRTY_EVERYTHING(pContext);

} // HWC_SwitchToD3D

//-----------------------------------------------------------------------------
//
// HWC_SwitchToFIFO
//
// Allows us to switch from DMA mode to FIFO transfers 
//
//-----------------------------------------------------------------------------
void HWC_SwitchToFIFO( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo )
{
    P3_DMA_DEFS();

    if (pGLInfo->InterfaceType != GLINT_NON_DMA)
    {
        DISPDBG((WRNLVL,"Switching to 4K Funny FIFO Memory"));
        
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();
        SYNC_WITH_GLINT;
        
        pGLInfo->InterfaceType = GLINT_NON_DMA;
        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo; 
    }
    else
    {
        // This means we already are in FIFO mode
        DISPDBG((DBGLVL,"NOT Switching to 4K Funny FIFO Memory"));
    }
} // HWC_SwitchToFIFO

//-----------------------------------------------------------------------------
//
// HWC_SwitchToDMA
//
// Allows us to switch from FIFO transfers to DMA mode
//
//-----------------------------------------------------------------------------
void HWC_SwitchToDMA( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo )
{

    if (pGLInfo->InterfaceType != GLINT_DMA)
    {
        DISPDBG((WRNLVL,"Switching to DMA buffers"));
        SYNC_WITH_GLINT;

        pGLInfo->InterfaceType = GLINT_DMA;
        pGLInfo->CurrentBuffer = 
                    pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    }
    else
    {
        DISPDBG((WRNLVL,"NOT Switching to DMA buffers"));
    }
} // HWC_SwitchToDMA


//-----------------------------------------------------------------------------
//
// __HWC_RecalculateDXDMABuffers
//
// Run through the OpanGL buffer mask to determine which remaining piece of
// buffer is the biggest and setup DirectX to use this buffer.
//
//-----------------------------------------------------------------------------
void 
__HWC_RecalculateDXDMABuffers(
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSize, i;
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    if (pGLInfo->InterfaceType != GLINT_DMA) 
    {
        // exit if we are not using DMA
        return;
    }

    // Just use the entire DMA Buffer.
    pThisDisplay->DMAInfo.dwBuffSize = 
                    pThisDisplay->pGLInfo->dw3DDMABufferSize;
    pThisDisplay->DMAInfo.dwBuffPhys = 
                    pThisDisplay->pGLInfo->dw3DDMABufferPhys;
    pThisDisplay->DMAInfo.dwBuffVirt = 
                    pThisDisplay->pGLInfo->dw3DDMABufferVirt;
    
    DISPDBG((DBGLVL,"__HWC_RecalculateDXDMABuffers V:0x%p P:0x%x S:0x%x", 
                    pThisDisplay->DMAInfo.dwBuffVirt, 
                    pThisDisplay->DMAInfo.dwBuffPhys, 
                    pThisDisplay->DMAInfo.dwBuffSize));

    dwSize = ((DWORD)(pThisDisplay->DMAInfo.dwBuffSize) / 
                        (DWORD)pGLInfo->NumberOfSubBuffers);
                        
    dwSize = ((dwSize + 3) & ~3);

    pThisDisplay->PartitionSize = dwSize / sizeof(DWORD);

    DISPDBG((DBGLVL,"Got Buffer with 0x%x Sub Buffers", 
                    pGLInfo->NumberOfSubBuffers));

    for (i = 0; i < pGLInfo->NumberOfSubBuffers; i++)
    {
        pGLInfo->DMAPartition[i].VirtAddr =
                        (ULONG *)((char*)(pThisDisplay->DMAInfo.dwBuffVirt) + 
                                  (i * dwSize));
                                
        pGLInfo->DMAPartition[i].PhysAddr =
                        (DWORD)((pThisDisplay->DMAInfo.dwBuffPhys) + 
                                    (i * dwSize));
                                
        pGLInfo->DMAPartition[i].MaxAddress =
                                (ULONG_PTR)pGLInfo->DMAPartition[i].VirtAddr + dwSize;
                        
        pGLInfo->DMAPartition[i].Locked = FALSE;

        DISPDBG((DBGLVL,"   Partition%d: VirtAddr = 0x%x, "
                        "   PhysAddr = 0x%x, MaxAddres = 0x%x",
                        i, 
                        pGLInfo->DMAPartition[i].VirtAddr,
                        pGLInfo->DMAPartition[i].PhysAddr,
                        pGLInfo->DMAPartition[i].MaxAddress));

#if DBG
        pGLInfo->DMAPartition[i].bStampedDMA = TRUE;
//@@BEGIN_DDKSPLIT        
#if 0
//azn hard to say in 64 bits!
        memset((void*)pGLInfo->DMAPartition[i].VirtAddr, 
               0x4D,
               (pGLInfo->DMAPartition[i].MaxAddress - 
                                pGLInfo->DMAPartition[i].VirtAddr));
#endif            
//@@END_DDKSPLIT
#endif

    }

    pGLInfo->CurrentBuffer = 
                pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    
} // __HWC_RecalculateDXDMABuffers

//-----------------------------------------------------------------------------
//
// HWC_StartDMA
//
//-----------------------------------------------------------------------------
DWORD WINAPI
HWC_StartDMA(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD     dwContext,
    DWORD     dwSize, 
    DWORD     dwPhys, 
    ULONG_PTR dwVirt, 
    DWORD     dwEvent)
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD( (int)dwSize > 0, "DMA buffer size non-positive" );

    ASSERTDD((IS_DXCONTEXT_CURRENT(pThisDisplay) && 
              (pGLInfo->InterfaceType == GLINT_DMA)), 
             "Error, Trying DMA when not setup for it!" );

#if W95_DDRAW
    ASSERTDD( pGLInfo->endIndex != 0, "Trying DMA with zero sub-buffers" );
#endif

#if DBG
    pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA = FALSE;
#endif

#ifdef W95_DDRAW
    ASSERTDD(pThisDisplay->pGLInfo->dwCurrentContext != CONTEXT_DISPLAY_HANDLE,
             "HWC_StartDMA: In display driver context" )

    ASSERTDD( pThisDisplay->pGlint->FilterMode == 0,
             "FilterMode non-zero" );
#endif

#if WNT_DDRAW
    DDSendDMAData(pThisDisplay->ppdev, dwPhys, dwVirt, dwSize);
#else
    StartDMAProper(pThisDisplay, pGLInfo, dwPhys, dwVirt, dwSize);
#endif

    DISPDBG((DBGLVL, "HWC_StartDMA sent %d dwords", dwSize));

    return GLDD_SUCCESS;
} // HWC_StartDMA

//-----------------------------------------------------------------------------
//
// HWC_AllocDMABuffer
//
//-----------------------------------------------------------------------------
void 
HWC_AllocDMABuffer( 
    P3_THUNKEDDATA* pThisDisplay)
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;
    int i;
    DWORD bDMA = TRUE;
    BOOL bRet;
    DWORD Result;

    // Empty the DMA partition slots
    for (i = 0; i < MAX_SUBBUFFERS; i++)
    {
        pGLInfo->DMAPartition[i].PhysAddr = 0;
        pGLInfo->DMAPartition[i].VirtAddr = 0;
        pGLInfo->DMAPartition[i].MaxAddress = 0;
    }

#if WNT_DDRAW
    // DMA turned off
    bDMA = FALSE;
#else
    // Are we allowed to DMA?
    bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.NoDMA", &Result);
    if ((bRet && (Result != 0)) ||
        (pThisDisplay->pGLInfo->dw3DDMABufferSize == 0))
    {
        bDMA = FALSE;
    }
#endif
 
    // Find out how many sub buffers the user wants.
    bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.SubBuffers", &Result);
    if ((Result == 0) || (bRet == FALSE))
    {
        // Default
        pGLInfo->NumberOfSubBuffers = DEFAULT_SUBBUFFERS;
    }
    else 
    {
        if (Result > MAX_SUBBUFFERS)
        {
            pGLInfo->NumberOfSubBuffers = MAX_SUBBUFFERS;
        }
        else
        {
            pGLInfo->NumberOfSubBuffers = Result; 
        }
        
        if (pGLInfo->NumberOfSubBuffers < 2)
        {
            pGLInfo->NumberOfSubBuffers = 2;
        }
    }

    // if no interrupt driven DMA or asked for less than 3 buffers then
    // configure no Q for this context 
    if ((pGLInfo->dwFlags & GMVF_NOIRQ) || (pGLInfo->NumberOfSubBuffers < 2))
    {
        pGLInfo->NumberOfSubBuffers = 2;
    }

    DISPDBG((DBGLVL,"Setting 0x%x Sub Buffers", pGLInfo->NumberOfSubBuffers));

    // Initialise for no DMA if DMA has been turned off for whatever reason
    if (!bDMA)
    {
        DISPDBG((WRNLVL,"Using 4K Funny FIFO Memory"));
        
        pGLInfo->InterfaceType = GLINT_NON_DMA;
        pThisDisplay->StartDMA = 0;
        
        pGLInfo->NumberOfSubBuffers = 0;

        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo;

        pThisDisplay->b2D_FIFOS = TRUE;
    }
    else
    {
        // DMA Setup
        pGLInfo->InterfaceType = GLINT_DMA;
        pThisDisplay->StartDMA = HWC_StartDMA;

        // This call will actually setup the partitions
        __HWC_RecalculateDXDMABuffers(pThisDisplay);

        // Is DirectDraw DMA disabled?
        bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.No2DDMA", &Result);
        if (bRet && (Result == 1))
        {
            pThisDisplay->b2D_FIFOS = TRUE;
        }
        else
        {
            pThisDisplay->b2D_FIFOS = FALSE;
        }
    }
#if W95_DDRAW
    // Store the end index in the context.
    SetEndIndex(pGLInfo, 
                CONTEXT_DIRECTX_HANDLE, 
                (unsigned short)pGLInfo->NumberOfSubBuffers);
                
#endif // W95_DDRAW

    if (pGLInfo->InterfaceType == GLINT_NON_DMA) 
    {
        DISPDBG((WRNLVL,"DDRAW: Using FIFO's"));
    }
    else
    {
        DISPDBG((WRNLVL,"DDRAW: Using DMA"));
    }
} // HWC_AllocDMABuffer



//-----------------------------------------------------------------------------
//
// HWC_FlushDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_FlushDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    if( pGLInfo->InterfaceType == GLINT_DMA )
    {
        DWORD Send;
        P3_DMAPartition *pCurrDMAPartition;

        pCurrDMAPartition = &(pGLInfo->DMAPartition[pGLInfo->CurrentPartition]);

//@@BEGIN_DDKSPLIT
        // azn - we might lose 64 bit precision here!
//@@END_DDKSPLIT        
        Send = (DWORD)(pGLInfo->CurrentBuffer - pCurrDMAPartition->VirtAddr) 
                / sizeof(DWORD);

        if( Send )
        {
            ASSERTDD( Send < 0x10000, "Wacky DMA size" );

            ((__StartDMA)pThisDisplay->StartDMA)
                    (pThisDisplay, 
                     CONTEXT_DIRECTX_HANDLE, 
                     Send, 
                     (DWORD)(pCurrDMAPartition->PhysAddr),
                     (ULONG_PTR)(pCurrDMAPartition->VirtAddr), 
                     0);
                     
            pGLInfo->CurrentPartition++;

            if (pGLInfo->CurrentPartition == pGLInfo->NumberOfSubBuffers)
            {
                pGLInfo->CurrentPartition = 0;
            }

            ASSERTDD(!pGLInfo->DMAPartition[pGLInfo->CurrentPartition].Locked,
                     "Partition already locked" );
        }

        pGLInfo->CurrentBuffer = 
            pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    }
    else
    {
        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo; 
    }
} // HWC_FlushDXBuffer


#if DBG
//-----------------------------------------------------------------------------
//
// HWC_GetDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_GetDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay, 
    char *file, 
    int line )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;
 
    ASSERTDD( pGLInfo->dwFlags & GMVF_GCOP, "VDD not locked out" );

    ASSERTDD( !pThisDisplay->BufferLocked, "Buffer already locked" );

    pThisDisplay->BufferLocked = TRUE;

#ifdef WANT_DMA
    if(( pGLInfo->endIndex > 2 ) && !IS_DXCONTEXT_CURRENT(pThisDisplay))
    {
        ASSERTDD( pGLInfo->CurrentBuffer == 
                  pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr,
                 "Trying to DMA in display driver context" );
    }
#endif

    DISPDBG(( DBGLVL, "HWC_GetDXBuffer: %s %d: Curr part %d, dmaPtr 0x%08x",
                      file, line,
                      pGLInfo->CurrentPartition, pGLInfo->CurrentBuffer ));

    if (pGLInfo->InterfaceType == GLINT_DMA)
    {
        DISPDBG(( DBGLVL, "HWC_GetDXBuffer: %d dwords to flush", 
                          ( pGLInfo->CurrentBuffer - 
                            pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr ) / 4 ));
    }
    else
    {
        DISPDBG(( DBGLVL, "HWC_GetDXBuffer: Using FIFOs"));
    }

#ifdef WANT_DMA
    // Ensure nobody has scribbled on the DMA Buffer
    if(( pGLInfo->InterfaceType == GLINT_DMA ) && 
       (pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA) )
    {
        ASSERTDD( *(DWORD*)pThisDisplay->pGLInfo->CurrentBuffer == 0x4D4D4D4D,
                 "ERROR: DMA Buffer signature invalid!" );
    }


    // Ensure we aren't writing to the wrong region
    if(IS_DXCONTEXT_CURRENT(pThisDisplay) &&
       ( pThisDisplay->pGLInfo->InterfaceType != GLINT_UNKNOWN_INTERFACE ))
    {
        if ((((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer >= 
              (ULONG_PTR)pThisDisplay->pGlint->GPFifo))           &&
            ((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer <= 
             ((ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000)) )
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA,
                     "Error: In FIFO space and setup for DMA");
        }
        else
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                     "Error: In DMA space and setup for FIFO's");
        }
    }
#endif
} // HWC_GetDXBuffer

//-----------------------------------------------------------------------------
//
// HWC_SetDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_SetDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay, 
    char *file, 
    int line )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD( pGLInfo->dwFlags & GMVF_GCOP, "VDD not locked out" );

    pThisDisplay->BufferLocked = FALSE;

    DISPDBG(( DBGLVL, "HWC_SetDXBuffer: %s %d: Curr part %d, dmaPtr 0x%08x",
                        file, line,
                        pGLInfo->CurrentPartition, pGLInfo->CurrentBuffer ));
    if (pGLInfo->InterfaceType == GLINT_DMA)
    {
        DISPDBG(( DBGLVL, "HWC_SetDXBuffer: %d dwords to flush", 
                      ( pGLInfo->CurrentBuffer - 
                       pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr ) / 4 ));
    }
    else
    {
        DISPDBG(( DBGLVL, "HWC_SetDXBuffer: Using FIFOs"));
    }

#ifdef WANT_DMA
    // Ensure nobody has scribbled on the DMA Buffer
    if(( pGLInfo->InterfaceType == GLINT_DMA ) && 
       (pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA) )
    {
        ASSERTDD( *(DWORD*)pThisDisplay->pGLInfo->CurrentBuffer == 0x4D4D4D4D,
                 "ERROR: DMA Buffer signature invalid!" );
    }

    // Ensure we aren't writing to the wrong region
    if(IS_DXCONTEXT_CURRENT(pThisDisplay) &&
       ( pThisDisplay->pGLInfo->InterfaceType != GLINT_UNKNOWN_INTERFACE ))
    {
        if ((((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer >= 
              (ULONG_PTR)pThisDisplay->pGlint->GPFifo))            &&
            ((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer <= 
             ((ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000))   )
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA,
                     "Error: In FIFO space and setup for DMA");
        }
        else
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                     "Error: In DMA space and setup for FIFO's");
        }
    }

#endif // WANT_DMA
} // HWC_SetDXBuffer


//-----------------------------------------------------------------------------
//
// HWC_bRenderIDHasCompleted
//
// This is simply the paranoid version of the macro
// declared in directx.h. It is present only in checked (debug)
// builds, since the non-debug version is just a
// one-line #define.
//-----------------------------------------------------------------------------
BOOL 
HWC_bRenderIDHasCompleted ( 
    DWORD dwID, 
    P3_THUNKEDDATA* pThisDisplay )
{
    DWORD dwCurID, dwCurHostID;
    int iTemp;

    ASSERTDD (CHIP_RENDER_ID_IS_VALID(), 
              "** RENDER_ID_HAS_COMPLETED: Chip's RenderID is not valid." );

    dwCurID = GET_CURRENT_CHIP_RENDER_ID();
    // Make sure the invalid bits have been zapped.
    ASSERTDD ( ( dwCurID | RENDER_ID_KNACKERED_BITS ) == dwCurID, 
              "** RENDER_ID_HAS_COMPLETED: Current chip ID is invalid" );
    ASSERTDD ( ( dwID | RENDER_ID_KNACKERED_BITS ) == dwID, 
              "** RENDER_ID_HAS_COMPLETED: Checked ID is invalid" );

    // We need to cope with the fact that the MinRegion register sign-extends
    // some bits in the middle, irritatingly. It's not a problem for simple
    // >=< tests, but this wants to know _how much_ we are out.
    // Bits 0xf000f000 are rubbish, so we need to chop them out.
    // This is not a problem on P3, and the RENDER_ID_VALID macros are set up
    // so this code will basically be compiled out of existence.
    dwCurID = ( dwCurID & RENDER_ID_VALID_BITS_LOWER ) | 
              ( ( dwCurID & RENDER_ID_VALID_BITS_UPPER ) >> 
                         RENDER_ID_VALID_BITS_UPPER_SHIFT  );
                         
    dwID    = ( dwID    & RENDER_ID_VALID_BITS_LOWER ) | 
              ( ( dwID    & RENDER_ID_VALID_BITS_UPPER ) >> 
                         RENDER_ID_VALID_BITS_UPPER_SHIFT );

    iTemp = (signed)( dwCurID - dwID );
    
    // Cope with the dodgy sign bits - sign extend the top n bits.
    iTemp <<= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    iTemp >>= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    
    // Some fairly arbitrary boundaries. If they are too small
    // for common use, just enlarge them a bit.
    // Generally, dwCurId can be well ahead of my_id (if the surface
    // hasn't been used for ages), but should not be too far behind,
    // because the pipe isn't _that_ big.
    if ( ( iTemp < RENDER_ID_LOWER_LIMIT ) || 
         ( iTemp > RENDER_ID_UPPER_LIMIT ) )
    {
        DISPDBG (( ERRLVL,"  ** Current chip ID 0x%x, surface ID, 0x%x", 
                     dwCurID, dwID ));
        DISPDBG ((ERRLVL,"** RENDER_ID_HAS_COMPLETED: Current render"
                    " ID is a long way out from surface's." ));
    }

    // We should never have a render ID newer 
    // than the current host render ID.
    dwCurHostID = GET_HOST_RENDER_ID();
    
    // Make sure the invalid bits have been zapped.
    ASSERTDD ( ( dwCurHostID | RENDER_ID_KNACKERED_BITS ) == dwCurHostID, 
              "** RENDER_ID_HAS_COMPLETED: Current host ID is invalid" );
              
    // Get a real contiguous number.
    dwCurHostID = ( dwCurHostID & RENDER_ID_VALID_BITS_LOWER ) | 
                  ( ( dwCurHostID & RENDER_ID_VALID_BITS_UPPER ) >> 
                                     RENDER_ID_VALID_BITS_UPPER_SHIFT );
                                     
    iTemp = (signed)( dwCurHostID - dwID );
    
    // Cope with the dodgy sign bits - sign extend the top n bits.
    iTemp <<= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    iTemp >>= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    
    if ( iTemp < 0 )
    {
        DISPDBG ((ERRLVL,"  ** Current host ID 0x%x, surface ID, 0x%x", 
                      dwCurHostID, dwID ));
                      
        // This may be caused by wrapping, of course.
        DISPDBG ((ERRLVL, "** RENDER_ID_HAS_COMPLETED: Surface's ID is "
                      "more recent than current host render ID." ));
    }

    return ( !RENDER_ID_LESS_THAN ( dwCurID, dwID ) );
    
} // HWC_bRenderIDHasCompleted

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\bitblt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bitblt.c
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

/************************************************************************\
*
* decompose all rops into GLINT logic ops if the dest is the screen.
* Sometimes we do this in a few stages. The following defines mimic
* the definitions found in the ROP3 table in the books. The idea
* is to minimize errors in constructing the ropTable array below by
* allowing me to copy the reverse Polish notation more or less in
* tact.
*
\**************************************************************************/

#define unset   __GLINT_LOGICOP_CLEAR
#define P       __GLINT_LOGICOP_COPY
#define S       P
#define DPna    __GLINT_LOGICOP_AND_INVERTED
#define DSna    DPna
#define DPa     __GLINT_LOGICOP_AND
#define DSa     DPa
#define PDa     DPa
#define SDa     DPa
#define PDna    __GLINT_LOGICOP_AND_REVERSE
#define SDna    PDna
#define DPno    __GLINT_LOGICOP_OR_INVERT
#define DSno    DPno
#define DPo     __GLINT_LOGICOP_OR
#define DSo     DPo
#define PDo     DPo
#define SDo     DPo
#define PDno    __GLINT_LOGICOP_OR_REVERSE
#define SDno    PDno
#define D       __GLINT_LOGICOP_NOOP
#define Dn      __GLINT_LOGICOP_INVERT
#define Pn      __GLINT_LOGICOP_COPY_INVERT
#define Sn      Pn
#define DPan    __GLINT_LOGICOP_NAND
#define DSan    DPan
#define PDan    DPan
#define SDan    DPan
#define DPon    __GLINT_LOGICOP_NOR
#define DSon    DPon
#define PDon    DPon
#define SDon    DPon
#define DPxn    __GLINT_LOGICOP_EQUIV
#define DSxn    DPxn
#define PDxn    DPxn
#define SDxn    DPxn
#define DPx     __GLINT_LOGICOP_XOR
#define DSx     DPx
#define PDx     DPx
#define SDx     DPx
#define set     __GLINT_LOGICOP_SET

/************************************************************************\
*
* if we have to first combine the source and pattern before downloading
* to GLINT we use the engine to do it using EngBitBlt. So these are the
* chosen rop3s which combine the source with the pattern. We blt into
* a temporary bitmap and use this to download.
*
\**************************************************************************/

#define SPa     0x30
#define PSa     SPa
#define SPan    0x3F
#define PSan    SPan
#define SPna    0x0C
#define PSna    0x30

#define SPo     0xFC
#define PSo     SPo
#define SPon    0x03
#define PSon    SPon
#define SPno    0xCF
#define PSno    0xF3

#define SPx     0x3C
#define PSx     SPx
#define SPxn    0xC3
#define PSxn    SPxn
#define SPnx    SPxn
#define PSnx    SPxn

/************************************************************************\
*
* we set up a junp table for the different rop3's. Each entry contains
* a category and a set of 1, 2 or 3 GLINT logic ops. In the main blt
* routine we switch on the category to figure out what routine to call.
* We pass the GLINT logic op straight in without having to do any further
* conversion. By keeping each entry in the table down to 4 bytes it
* takes up 1K of data. That's not too much. The benefit is that in each
* routine we call we don't have to do any checking to see whether the
* rop really needs pattern or source. I've done some pre-processing on
* some of the rops to decompose them into forms which allow us to use
* the hardware in a series of steps. e.g. pattern fill followed by
* source download. If anything doesn't fit into a defined category then
* we go back to the engine.
*
\**************************************************************************/

// categories

#define SOLID_FILL_1_BLT    0       // must be 0
#define PAT_FILL_1_BLT      1       // must be 1

#define SRC_FILL_1_BLT      2       // must be 2

#define PAT_SRC_2_BLT       3       // PatSrcPatBlt
#define PAT_SRC_PAT_3_BLT   4       // PatSrcPatBlt

#define SRC_PAT_2_BLT       5       // SrcPatSrcBlt
#define SRC_PAT_SRC_3_BLT   6       // SrcPatSrcBlt

#define ENG_DOWNLOAD_2_BLT  7       // EngBitBlt for now
#define ENGINE_BITBLT       8       // EngBitBlt always

// adding new entries here may double the table size.

typedef struct _rop_table {
    UCHAR   func_index;
    UCHAR   logicop[3];
} RopTableRec, *RopTablePtr;

RopTableRec ropTable[] = {
/* 00 */    { SOLID_FILL_1_BLT, unset },
/* 01 */    { SRC_PAT_2_BLT, SDo, DPon, },                                 
/* 02 */    { SRC_PAT_2_BLT, DSna, DPna },
/* 03 */    { SRC_PAT_2_BLT, S, PDon, },
/* 04 */    { SRC_PAT_2_BLT, SDna, DPna, }, 
/* 05 */    { PAT_FILL_1_BLT, DPon, },
/* 06 */    { SRC_PAT_2_BLT, DSxn, PDon, },
/* 07 */    { SRC_PAT_2_BLT, DSa, PDon, },
/* 08 */    { SRC_PAT_2_BLT, DSa, DPna, },
/* 09 */    { SRC_PAT_2_BLT, DSx, PDon, },
/* 0A */    { PAT_FILL_1_BLT, DPna, },
/* 0B */    { SRC_PAT_2_BLT, SDna, PDon, },
/* 0C */    { SRC_PAT_2_BLT, S, DPna, },
/* 0D */    { SRC_PAT_2_BLT, DSna, PDon, },
/* 0E */    { SRC_PAT_2_BLT, DSon, PDon, },
/* 0F */    { PAT_FILL_1_BLT, Pn, },
/* 10 */    { SRC_PAT_2_BLT, DSon, PDa, },
/* 11 */    { SRC_FILL_1_BLT, DSon, },
/* 12 */    { PAT_SRC_2_BLT, DPxn, SDon, },
/* 13 */    { PAT_SRC_2_BLT, DPa, SDon, },
/* 14 */    { ENG_DOWNLOAD_2_BLT, PSx, SDno, },
/* 15 */    { ENG_DOWNLOAD_2_BLT, PSa, DSon, },
/* 16 */    { ENGINE_BITBLT, },
/* 17 */    { ENGINE_BITBLT, },
/* 18 */    { ENGINE_BITBLT, },
/* 19 */    { ENGINE_BITBLT, },
/* 1A */    { ENGINE_BITBLT, },
/* 1B */    { ENGINE_BITBLT, },
/* 1C */    { PAT_SRC_PAT_3_BLT, DPa, SDo, PDx,  },
/* 1D */    { ENGINE_BITBLT, },
/* 1E */    { SRC_PAT_2_BLT, DSo, PDx, },
/* 1F */    { SRC_PAT_2_BLT, DSo, PDan, },
/* 20 */    { SRC_PAT_2_BLT, DSna, PDa, },
/* 21 */    { PAT_SRC_2_BLT, DPx, SDon, },
/* 22 */    { SRC_FILL_1_BLT, DSna, },
/* 23 */    { PAT_SRC_2_BLT, PDna, SDon, },
/* 24 */    { ENGINE_BITBLT, },
/* 25 */    { ENGINE_BITBLT, },
/* 26 */    { ENGINE_BITBLT, },
/* 27 */    { ENGINE_BITBLT, },
/* 28 */    { ENG_DOWNLOAD_2_BLT, PSx, DSa, },
/* 29 */    { ENGINE_BITBLT, },
/* 2A */    { ENG_DOWNLOAD_2_BLT, PSa, DSna, },
/* 2B */    { ENGINE_BITBLT, },
/* 2C */    { SRC_PAT_SRC_3_BLT, DSo, PDa, SDx, },
/* 2D */    { SRC_PAT_2_BLT, SDno, PDx, },
/* 2E */    { PAT_SRC_PAT_3_BLT, DPx, SDo, PDx, },
/* 2F */    { SRC_PAT_2_BLT, SDno, PDan, },
/* 30 */    { SRC_PAT_2_BLT, S, PDna, },
/* 31 */    { PAT_SRC_2_BLT, DPna, SDon, },
/* 32 */    { SRC_PAT_SRC_3_BLT, SDo, PDo, SDx },
/* 33 */    { SRC_FILL_1_BLT, Sn, },
/* 34 */    { SRC_PAT_SRC_3_BLT, DSa, PDo, SDx, },
/* 35 */    { SRC_PAT_SRC_3_BLT, DSxn, PDo, SDx, },
/* 36 */    { PAT_SRC_2_BLT, DPo, SDx, },
/* 37 */    { PAT_SRC_2_BLT, DPo, SDan, },
/* 38 */    { PAT_SRC_PAT_3_BLT, DPo, SDa, PDx, },
/* 39 */    { PAT_SRC_2_BLT, PDno, SDx, },
/* 3A */    { SRC_PAT_SRC_3_BLT, DSx, PDo, SDx, },
/* 3B */    { PAT_SRC_2_BLT, PDno, SDan, },
/* 3C */    { SRC_PAT_2_BLT, S, PDx, },
/* 3D */    { SRC_PAT_SRC_3_BLT, DSon, PDo, SDx, },
/* 3E */    { SRC_PAT_SRC_3_BLT, DSna, PDo, SDx, },
/* 3F */    { SRC_PAT_2_BLT, S, PDan, },
/* 40 */    { SRC_PAT_2_BLT, SDna, PDa, },
/* 41 */    { ENG_DOWNLOAD_2_BLT, PSx, DSon, },
/* 42 */    { ENGINE_BITBLT, },
/* 43 */    { SRC_PAT_SRC_3_BLT, DSan, PDa, SDxn, },
/* 44 */    { SRC_FILL_1_BLT, SDna, },
/* 45 */    { ENG_DOWNLOAD_2_BLT, PSna, DSon, },
/* 46 */    { ENGINE_BITBLT, },
/* 47 */    { PAT_SRC_PAT_3_BLT, DPx, SDa, PDxn, },
/* 48 */    { PAT_SRC_2_BLT, DPx, SDa, },
/* 49 */    { ENGINE_BITBLT, },
/* 4A */    { ENGINE_BITBLT, },
/* 4B */    { SRC_PAT_2_BLT, DSno, PDx, },
/* 4C */    { PAT_SRC_2_BLT, DPan, SDa, },
/* 4D */    { ENGINE_BITBLT, },
/* 4E */    { ENGINE_BITBLT, },
/* 4F */    { SRC_PAT_2_BLT, DSno, PDan, },
/* 50 */    { PAT_FILL_1_BLT, PDna, },
/* 51 */    { ENG_DOWNLOAD_2_BLT, SPna, DSon, },
/* 52 */    { ENGINE_BITBLT, },
/* 53 */    { SRC_PAT_SRC_3_BLT, DSx, PDa, SDxn, },
/* 54 */    { ENG_DOWNLOAD_2_BLT, PSo, SDna, },
/* 55 */    { SOLID_FILL_1_BLT, Dn, },
/* 56 */    { ENG_DOWNLOAD_2_BLT, PSo, DSx, },
/* 57 */    { ENG_DOWNLOAD_2_BLT, PSo, DSan, },
/* 58 */    { ENGINE_BITBLT, },
/* 59 */    { ENG_DOWNLOAD_2_BLT, PSno, DSx, },
/* 5A */    { PAT_FILL_1_BLT, DPx, },
/* 5B */    { ENGINE_BITBLT, },
/* 5C */    { ENGINE_BITBLT, },
/* 5D */    { ENG_DOWNLOAD_2_BLT, PSno, DSan, },
/* 5E */    { ENGINE_BITBLT, },
/* 5F */    { PAT_FILL_1_BLT, DPan, },
/* 60 */    { SRC_PAT_2_BLT, DSx, PDa, },
/* 61 */    { ENGINE_BITBLT, },
/* 62 */    { ENGINE_BITBLT, },
/* 63 */    { PAT_SRC_2_BLT, DPno, SDx, },
/* 64 */    { ENGINE_BITBLT, },
/* 65 */    { ENG_DOWNLOAD_2_BLT, SPno, DSx, },
/* 66 */    { SRC_FILL_1_BLT, DSx, },
/* 67 */    { ENGINE_BITBLT, },
/* 68 */    { ENGINE_BITBLT, },
/* 69 */    { SRC_PAT_2_BLT, DSx, PDxn, },
/* 6A */    { ENG_DOWNLOAD_2_BLT, PSa, DSx, },
/* 6B */    { ENGINE_BITBLT, },
/* 6C */    { PAT_SRC_2_BLT, DPa, SDx, },
/* 6D */    { ENGINE_BITBLT, },
/* 6E */    { ENGINE_BITBLT, },
/* 6F */    { SRC_PAT_2_BLT, DSxn, PDan, },
/* 70 */    { SRC_PAT_2_BLT, DSan, PDa, },
/* 71 */    { ENGINE_BITBLT, },
/* 72 */    { ENGINE_BITBLT, },
/* 73 */    { PAT_SRC_2_BLT, DPno, SDan, },
/* 74 */    { ENGINE_BITBLT, },
/* 75 */    { ENG_DOWNLOAD_2_BLT, SPno, DSan, },
/* 76 */    { ENGINE_BITBLT, },
/* 77 */    { SRC_FILL_1_BLT, DSan, },
/* 78 */    { SRC_PAT_2_BLT, DSa, PDx, },
/* 79 */    { ENGINE_BITBLT, },
/* 7A */    { ENGINE_BITBLT, },
/* 7B */    { PAT_SRC_2_BLT, DPxn, SDan, },
/* 7C */    { SRC_PAT_SRC_3_BLT, DSno, PDa, SDx, },
/* 7D */    { ENG_DOWNLOAD_2_BLT, PSxn, DSan, },
/* 7E */    { ENGINE_BITBLT, },
/* 7F */    { ENG_DOWNLOAD_2_BLT, PSa, DSan, },
/* 80 */    { ENG_DOWNLOAD_2_BLT, PSa, DSa, },
/* 81 */    { ENGINE_BITBLT, },
/* 82 */    { ENG_DOWNLOAD_2_BLT, PSx, DSna, },
/* 83 */    { SRC_PAT_SRC_3_BLT, DSno, PDa, SDxn, },
/* 84 */    { PAT_SRC_2_BLT, DPxn, SDa, },
/* 85 */    { ENGINE_BITBLT, },
/* 86 */    { ENGINE_BITBLT, },
/* 87 */    { SRC_PAT_2_BLT, DSa, PDxn, },
/* 88 */    { SRC_FILL_1_BLT, DSa, },
/* 89 */    { ENGINE_BITBLT, },
/* 8A */    { ENG_DOWNLOAD_2_BLT, SPno, DSa, },
/* 8B */    { ENGINE_BITBLT, },
/* 8C */    { PAT_SRC_2_BLT, DPno, SDa, },
/* 8D */    { ENGINE_BITBLT, },
/* 8E */    { ENGINE_BITBLT, },
/* 8F */    { SRC_PAT_2_BLT, DSan, PDan, },
/* 90 */    { SRC_PAT_2_BLT, DSxn, PDa, },
/* 91 */    { ENGINE_BITBLT, },
/* 92 */    { ENGINE_BITBLT, },
/* 93 */    { PAT_SRC_2_BLT, PDa, SDxn, },
/* 94 */    { ENGINE_BITBLT, },
/* 95 */    { ENG_DOWNLOAD_2_BLT, PSa, DSxn, },
/* 96 */    { SRC_PAT_2_BLT, DSx, PDx, },       /* DPSxx == PDSxx */
/* 97 */    { ENGINE_BITBLT, },
/* 98 */    { ENGINE_BITBLT, },
/* 99 */    { SRC_FILL_1_BLT, DSxn, },
/* 9A */    { ENG_DOWNLOAD_2_BLT, PSna, DSx, },
/* 9B */    { ENGINE_BITBLT, },
/* 9C */    { PAT_SRC_2_BLT, PDna, SDx, },
/* 9D */    { ENGINE_BITBLT, },
/* 9E */    { ENGINE_BITBLT, },
/* 9F */    { SRC_PAT_2_BLT, DSx, PDan, },
/* A0 */    { PAT_FILL_1_BLT, DPa, },
/* A1 */    { ENGINE_BITBLT, },
/* A2 */    { ENG_DOWNLOAD_2_BLT, PSno, DSa, },
/* A3 */    { ENGINE_BITBLT, },
/* A4 */    { ENGINE_BITBLT, },
/* A5 */    { PAT_FILL_1_BLT, PDxn, },
/* A6 */    { ENG_DOWNLOAD_2_BLT, SPna, DSx, },
/* A7 */    { ENGINE_BITBLT, },
/* A8 */    { ENG_DOWNLOAD_2_BLT, PSo, DSa, },
/* A9 */    { ENG_DOWNLOAD_2_BLT, PSo, DSxn, },
/* AA */    { SOLID_FILL_1_BLT, D },
/* AB */    { ENG_DOWNLOAD_2_BLT, PSo, DSno, },
/* AC */    { SRC_PAT_SRC_3_BLT, DSx, PDa, SDx, },
/* AD */    { ENGINE_BITBLT, },
/* AE */    { ENG_DOWNLOAD_2_BLT, SPna, DSo, },
/* AF */    { PAT_FILL_1_BLT, DPno, },
/* B0 */    { SRC_PAT_2_BLT, DSno, PDa, },
/* B1 */    { ENGINE_BITBLT, },
/* B2 */    { ENGINE_BITBLT, },
/* B3 */    { PAT_SRC_2_BLT, DPan, SDan, },
/* B4 */    { SRC_PAT_2_BLT, SDna, PDx, },
/* B5 */    { ENGINE_BITBLT, },
/* B6 */    { ENGINE_BITBLT, },
/* B7 */    { PAT_SRC_2_BLT, DPx, SDan, },
/* B8 */    { PAT_SRC_PAT_3_BLT, DPx, SDa, PDx, },
/* B9 */    { ENGINE_BITBLT, },
/* BA */    { ENG_DOWNLOAD_2_BLT, PSna, DSo, },
/* BB */    { SRC_FILL_1_BLT, DSno, },
/* BC */    { SRC_PAT_SRC_3_BLT, DSan, PDa, SDx, },
/* BD */    { ENGINE_BITBLT, },
/* BE */    { ENG_DOWNLOAD_2_BLT, PSx, DSo, },
/* BF */    { ENG_DOWNLOAD_2_BLT, PSa, DSno, },
/* C0 */    { SRC_PAT_2_BLT, S, PDa, },
/* C1 */    { ENGINE_BITBLT, },
/* C2 */    { ENGINE_BITBLT, },
/* C3 */    { SRC_PAT_2_BLT, S, PDxn, },
/* C4 */    { PAT_SRC_2_BLT, PDno, SDa, },
/* C5 */    { SRC_PAT_SRC_3_BLT, DSx, PDo, SDxn, },
/* C6 */    { PAT_SRC_2_BLT, DPna, SDx, },
/* C7 */    { PAT_SRC_PAT_3_BLT, DPo, SDa, PDxn, },
/* C8 */    { PAT_SRC_2_BLT, DPo, SDa, },
/* C9 */    { PAT_SRC_2_BLT, PDo, SDxn, },
/* CA */    { ENGINE_BITBLT, },
/* CB */    { SRC_PAT_SRC_3_BLT, DSa, PDo, SDxn, },
/* CC */    { SRC_FILL_1_BLT, S, },
/* CD */    { PAT_SRC_2_BLT, DPon, SDo, },
/* CE */    { PAT_SRC_2_BLT, DPna, SDo, },
/* CF */    { SRC_PAT_2_BLT, S, DPno, },
/* D0 */    { SRC_PAT_2_BLT, SDno, PDa, },
/* D1 */    { PAT_SRC_PAT_3_BLT, DPx, SDo, PDxn, },
/* D2 */    { SRC_PAT_2_BLT, DSna, PDx, },
/* D3 */    { SRC_PAT_SRC_3_BLT, DSo, PDa, SDxn, },
/* D4 */    { ENGINE_BITBLT, },
/* D5 */    { ENG_DOWNLOAD_2_BLT, PSan, DSan, },
/* D6 */    { ENGINE_BITBLT, },
/* D7 */    { ENG_DOWNLOAD_2_BLT, PSx, DSan, },
/* D8 */    { ENGINE_BITBLT, },
/* D9 */    { ENGINE_BITBLT, },
/* DA */    { ENGINE_BITBLT, },
/* DB */    { ENGINE_BITBLT, },
/* DC */    { PAT_SRC_2_BLT, PDna, SDo, },
/* DD */    { SRC_FILL_1_BLT, SDno, },
/* DE */    { PAT_SRC_2_BLT, DPx, SDo, },
/* DF */    { ENG_DOWNLOAD_2_BLT, DPan, SDo, },
/* E0 */    { SRC_PAT_2_BLT, DSo, PDa, },
/* E1 */    { SRC_PAT_2_BLT, DSo, PDxn, },
/* E2 */    { ENGINE_BITBLT, },     /* DSPDxax : XXX S3 special cases this */
/* E3 */    { PAT_SRC_PAT_3_BLT, DPa, SDo, PDxn, },
/* E4 */    { ENGINE_BITBLT, },
/* E5 */    { ENGINE_BITBLT, },
/* E6 */    { ENGINE_BITBLT, },
/* E7 */    { ENGINE_BITBLT, },
/* E8 */    { ENGINE_BITBLT, },
/* E9 */    { ENGINE_BITBLT, },
/* EA */    { ENG_DOWNLOAD_2_BLT, PSa, DSo, },
/* EB */    { ENG_DOWNLOAD_2_BLT, PSx, DSno, },
/* EC */    { PAT_SRC_2_BLT, DPa, SDo, },
/* ED */    { PAT_SRC_2_BLT, DPxn, SDo, },
/* EE */    { SRC_FILL_1_BLT, DSo, },
/* EF */    { SRC_PAT_2_BLT, SDo, DPno },
/* F0 */    { PAT_FILL_1_BLT, P, },
/* F1 */    { SRC_PAT_2_BLT, DSon, PDo, },
/* F2 */    { SRC_PAT_2_BLT, DSna, PDo, },
/* F3 */    { SRC_PAT_2_BLT, S, PDno, },
/* F4 */    { SRC_PAT_2_BLT, SDna, PDo, },
/* F5 */    { PAT_FILL_1_BLT, PDno, },
/* F6 */    { SRC_PAT_2_BLT, DSx, PDo, },
/* F7 */    { SRC_PAT_2_BLT, DSan, PDo, },
/* F8 */    { SRC_PAT_2_BLT, DSa, PDo, },
/* F9 */    { SRC_PAT_2_BLT, DSxn, PDo, },
/* FA */    { PAT_FILL_1_BLT, DPo, },
/* FB */    { SRC_PAT_2_BLT, DSno, PDo, },
/* FC */    { SRC_PAT_2_BLT, S, PDo, },
/* FD */    { SRC_PAT_2_BLT, SDno, PDo, },
/* FE */    { ENG_DOWNLOAD_2_BLT, PSo, DSo, },
/* FF */    { SOLID_FILL_1_BLT, set, },
};

// table to determine which logicops need read dest turned on in FBReadMode

DWORD   LogicopReadDest[] = {
    0,                                                  /* 00 */
    __FB_READ_DESTINATION,                              /* 01 */
    __FB_READ_DESTINATION,                              /* 02 */
    0,                                                  /* 03 */
    __FB_READ_DESTINATION,                              /* 04 */
    __FB_READ_DESTINATION,                              /* 05 */
    __FB_READ_DESTINATION,                              /* 06 */
    __FB_READ_DESTINATION,                              /* 07 */
    __FB_READ_DESTINATION,                              /* 08 */
    __FB_READ_DESTINATION,                              /* 09 */
    __FB_READ_DESTINATION,                              /* 10 */
    __FB_READ_DESTINATION,                              /* 11 */
    0,                                                  /* 12 */
    __FB_READ_DESTINATION,                              /* 13 */
    __FB_READ_DESTINATION,                              /* 14 */
    0,                                                  /* 15 */
};

// translate a ROP2 into a GLINT logicop. Note, ROP2's start at 1 so
// entry 0 is not used.

DWORD GlintLogicOpsFromR2[] = {
    0,                                  /* rop2's start at 1 */
    __GLINT_LOGICOP_CLEAR,              /*  0      1 */
    __GLINT_LOGICOP_NOR,                /* DPon    2 */
    __GLINT_LOGICOP_AND_INVERTED,       /* DPna    3 */
    __GLINT_LOGICOP_COPY_INVERT,        /* Pn      4 */
    __GLINT_LOGICOP_AND_REVERSE,        /* PDna    5 */
    __GLINT_LOGICOP_INVERT,             /* Dn      6 */
    __GLINT_LOGICOP_XOR,                /* DPx     7 */
    __GLINT_LOGICOP_NAND,               /* DPan    8 */
    __GLINT_LOGICOP_AND,                /* DPa     9 */
    __GLINT_LOGICOP_EQUIV,              /* DPxn    10 */
    __GLINT_LOGICOP_NOOP,               /* D       11 */
    __GLINT_LOGICOP_OR_INVERT,          /* DPno    12 */
    __GLINT_LOGICOP_COPY,               /* P       13 */
    __GLINT_LOGICOP_OR_REVERSE,         /* PDno    14 */
    __GLINT_LOGICOP_OR,                 /* DPo     15 */
    __GLINT_LOGICOP_SET,                /*  1      16 */
};

BOOL
PatternFillRect(PPDEV, RECTL *, CLIPOBJ *, BRUSHOBJ *,
                POINTL *, ULONG, ULONG);

BOOL
SourceFillRect(PPDEV, RECTL *, CLIPOBJ *, SURFOBJ *, XLATEOBJ *,
               POINTL *, ULONG, ULONG);

BOOL
PatSrcPatBlt(PPDEV, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
             POINTL*, BRUSHOBJ*, POINTL*, RopTablePtr);

BOOL
SrcPatSrcBlt(PPDEV, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
             POINTL*, BRUSHOBJ*, POINTL*, RopTablePtr);

BOOL
MaskCopyBlt(PPDEV, RECTL*, CLIPOBJ*, SURFOBJ*, SURFOBJ*, POINTL*,
            POINTL*, ULONG, ULONG);

BOOL
bUploadRect(PPDEV, CLIPOBJ *, SURFOBJ *, SURFOBJ *, POINTL *, RECTL *);

BOOL bUploadBlt(
    PPDEV,
    SURFOBJ *,
    SURFOBJ *,
    SURFOBJ *,
    CLIPOBJ  *,
    XLATEOBJ *,
    RECTL *,
    POINTL *,
    POINTL *,
    BRUSHOBJ *,
    POINTL *,
    ROP4);

#if defined(_X86_) 
// Mono upload functions
BOOL DoScreenToMono(
    PDEV*       ppdev, 
    RECTL       *prclDst,
    CLIPOBJ     *pco,
    SURFOBJ*    psoSrc,             // Source surface 
    SURFOBJ*    psoDst,             // Destination surface 
    POINTL*     pptlSrc,            // Original unclipped source point 
    XLATEOBJ*   pxlo);               // Provides colour-compressions information 

VOID vXferScreenTo1bpp(
    PDEV*       ppdev, 
    LONG        c,                  // Count of rectangles, can't be zero 
    RECTL*      prcl,               // List of destination rectangles, in 
                                    //   relative coordinates 
    ULONG       ulHwMix,            // Not used 
    SURFOBJ*    psoSrc,             // Source surface 
    SURFOBJ*    psoDst,             // Destination surface 
    POINTL*     pptlSrc,            // Original unclipped source point 
    RECTL*      prclDst,            // Original unclipped destination rectangle 
    XLATEOBJ*   pxlo);               // Provides colour-compressions information 
#endif  // defined(_X86_) 

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vGlintChangeFBDepth
*
* Change the GLINT packing mode for different depths. We use this to speed
* up rendering for 8 and 16 bpp where we can process up to 4 pixels at a
* time.
*
\**************************************************************************/

VOID vGlintChangeFBDepth(
PPDEV   ppdev,
ULONG   cPelSize)
{
    ULONG cFlags;
    GLINT_DECL;

    DISPDBG((DBGLVL, "setting current pixel depth to %d",
            (cPelSize == 0) ? 8 : (cPelSize == 1) ? 16 : 32));
            
    glintInfo->FBReadMode = glintInfo->packing[cPelSize].readMode;
    glintInfo->currentPelSize = cPelSize;
    
    // Toggle the FBReadMode cache flag
    DISPDBG((DBGLVL, "setting FBReadMode to 0x%08x", glintInfo->FBReadMode));
    cFlags = CHECK_CACHEFLAGS (ppdev, 0xFFFFFFFF);
    SET_CACHEFLAGS (ppdev, (cFlags & ~cFlagFBReadDefault));

    // set FX pixel depth 
    // 0 - 8 bits, 1 - 16 bits and 2 - 32 bits.
    DISPDBG((DBGLVL, "Changing FBDepth for PERMEDIA"));
    WAIT_GLINT_FIFO(1);
    LD_GLINT_FIFO(__PermediaTagFBReadPixel, cPelSize);
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMsk,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMsk,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4     rop4)

{
    BOOL        bRet;
    PPDEV       ppdev;
    DSURF       *pdsurfDst;
    DSURF       *pdsurfSrc;
    UCHAR       funcIndexFore;
    UCHAR       funcIndexBack;
    XLATECOLORS xlc;
    XLATEOBJ    xlo;
    RopTablePtr pTableFore;
    RopTablePtr pTableBack;
    HSURF       hsurfSrcBitmap, hsurfDstBitmap;
    SURFOBJ     *psoSrcBitmap, *psoDstBitmap;
    SURFOBJ     *psoSrcOrig = psoSrc, *psoDstOrig = psoDst;
    GLINT_DECL_VARS;

    // We need to remove the pointer, but we dont know which surface is valid
    // (if either). 

    if ((psoDst->iType != STYPE_BITMAP) && 
        (((DSURF *)(psoDst->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoDst->dhpdev;
        REMOVE_SWPOINTER(psoDst);
    }
    else if (psoSrc && 
             (psoSrc->iType != STYPE_BITMAP) && 
             (((DSURF *)(psoSrc->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoSrc->dhpdev;
        REMOVE_SWPOINTER(psoSrc);
    }

    // GDI will never give us a Rop4 with the bits in the high-word set
    // (so that we can check if it's actually a Rop3 via the expression
    // (rop4 >> 8) == (rop4 & 0xff))

    ASSERTDD((rop4 >> 16) == 0, "Didn't expect a rop4 with high bits set");

#if !defined(_WIN64) && WNT_DDRAW
    // Touch the source surface 1st and then the destination surface

    vSurfUsed(psoSrc);
    vSurfUsed(psoDst);
#endif

    pdsurfDst = (DSURF *)psoDst->dhsurf;

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt & DT_SCREEN)
        {
            OH*             poh;
            BOOL            bMore;
            CLIPENUM        ce;
            LONG            c;
            RECTL           rcl;
            BYTE            rop3;
            GFNFILL*        pfnFill;
            RBRUSH_COLOR    rbc;        // Realized brush or solid colour
            DWORD           fgLogicop;
            DWORD           bgLogicop;

            ppdev = (PDEV*) psoDst->dhpdev;
            GLINT_DECL_INIT;

            poh = pdsurfDst->poh;

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

            VALIDATE_DD_CONTEXT;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

                pfnFill = ppdev->pgfnFillSolid;   // Default to solid fill

                pTableFore = &ropTable[rop4 & 0xff];
                pTableBack = &ropTable[rop4 >> 8];
                fgLogicop = pTableFore->logicop[0];

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                DISPDBG((WRNLVL, "DrvBitBlt: BRUSHOBJ_pvGetRbrush"
                                                 "failed.calling engine_blt"));
                                GLINT_DECL_INIT;
                                goto engine_blt;
                            }
                        }

                        if (rbc.prb->fl & RBRUSH_2COLOR)
                        {
                            DISPDBG((DBGLVL, "monochrome brush"));
                            pfnFill = ppdev->pgfnFillPatMono;
                        }
                        else
                        {
                            DISPDBG((DBGLVL, "colored brush"));
                            pfnFill = ppdev->pgfnFillPatColor;
                        }

                        bgLogicop = pTableBack->logicop[0];
                    }
                }
                else
                {
                    // Turn some logicops into solid block fills. We get here
                    // only for rops 0, 55, AA and FF.

                    if ((fgLogicop == __GLINT_LOGICOP_SET) ||
                        (fgLogicop == __GLINT_LOGICOP_CLEAR))
                    {
                        rbc.iSolidColor = 0xffffff;    // does any depth
                        if (fgLogicop == __GLINT_LOGICOP_CLEAR)
                        {
                            rbc.iSolidColor = 0;
                        }
                        fgLogicop = __GLINT_LOGICOP_COPY;
                    }
                    else if (fgLogicop == __GLINT_LOGICOP_NOOP)
                    {
                        return(TRUE);   // DST logicop is a noop
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, fgLogicop, bgLogicop, 
                                rbc, pptlBrush);
                    return TRUE;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        pfnFill(ppdev, 1, &rcl, fgLogicop, bgLogicop, 
                                    rbc, pptlBrush);
                    }
                    return TRUE;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                        {
                            pfnFill(ppdev, c, ce.arcl, fgLogicop, bgLogicop, 
                                        rbc, pptlBrush);
                        }
                    } while (bMore);
                    return TRUE;
                }
            }
        }
    }
    
#if defined(_X86_) 
    if ((pxlo != NULL) &&
        (pxlo->flXlate & XO_TO_MONO) &&
        (psoSrc != NULL) && (pptlSrc != NULL) &&
        (psoDst != NULL) && (psoDst->dhsurf == NULL) &&
        (psoDst->iBitmapFormat == BMF_1BPP))
    {
        BYTE rop3 = (BYTE) rop4;     // Make rop4 into a Rop3 

        ppdev     = (PDEV*)  psoSrc->dhpdev; 
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;

        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        if ((ppdev->iBitmapFormat != BMF_24BPP) &&
            (((rop4 >> 8) & 0xff) == (rop4 & 0xff)) &&
            (psoSrc->iType != STYPE_BITMAP) &&
            (pdsurfSrc->dt & DT_SCREEN) &&
            (rop3 == 0xcc))
        { 
            // We special case screen to monochrome blts because they 
            // happen fairly often.  We only handle SRCCOPY rops and 
            // monochrome destinations (to handle a true 1bpp DIB 
            // destination, we would have to do near-colour searches 
            // on every colour; as it is, the foreground colour gets 
            // mapped to '1', and everything else gets mapped to '0'): 

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

            ASSERTDD (pdsurfSrc->poh->cy >= psoSrc->sizlBitmap.cy || 
                       pdsurfSrc->poh->cx >= psoSrc->sizlBitmap.cx, 
                       "DrvBitBlt: Got a BAD screen-to-mono size");

            DISPDBG((DBGLVL, "DrvBitBlt: Screen-to-mono, size poh(%d,%d)",
                            pdsurfSrc->poh->cx, pdsurfSrc->poh->cy));
                            
            if (DoScreenToMono (ppdev, prclDst, pco, psoSrc, 
                                    psoDst, pptlSrc, pxlo))
                return (TRUE); 
        } 
    }
#endif //   defined(_X86_) 

    // pdsurfDst is valid only if iType != BITMAP so be careful with the ordering
    //
    if ((psoDst->iType == STYPE_BITMAP) || ((pdsurfDst->dt & DT_SCREEN) == 0))
    {
        // Destination is either a bitmap or an ex offscreen bitmap
        DISPDBG((DBGLVL, "dst is a bitmap or a DIB"));
        if (psoSrc)
        {
            DISPDBG((DBGLVL, "we have a src"));
            pdsurfSrc = (DSURF *)psoSrc->dhsurf;
            if ((psoSrc->iType != STYPE_BITMAP) && 
                (pdsurfSrc->dt & DT_SCREEN))
            {
                ppdev = (PPDEV)psoSrc->dhpdev;
                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

                // if we are ex offscreen, get the DIB pointer.
                if (psoDst->iType != STYPE_BITMAP)
                {
                    psoDst = pdsurfDst->pso;
                }
            
                VALIDATE_DD_CONTEXT;

                DISPDBG((DBGLVL, "uploading from the screen"));

                if (bUploadBlt(ppdev, psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                                pptlSrc, pptlMsk, pbo, pptlBrush, rop4))
                {
                    return (TRUE);
                }

                // If for some reason the upload failed go and do it.    

                DISPDBG((WRNLVL, "DrvBitBlt: bUploadBlt "
                                 "failed.calling engine_blt"));
                goto engine_blt;
            }
        }

        DISPDBG((DBGLVL, "falling through to engine_blt"));

        if (psoDst->iType != STYPE_BITMAP)
        {
            // Destination is an Ex Offscreen Bitmap
            ppdev = (PPDEV)psoDst->dhpdev;
            GLINT_DECL_INIT;
            DISPDBG((DBGLVL, "DrvBitBlt: ex offscreen "
                             "bitmap.calling engine_blt"));
            goto engine_blt;
        }
        else
        {
            // Destination is a Memory Bitmap. We shouldnt ever get here.
            DISPDBG((DBGLVL, "DrvBitBlt: memory bitmap!!."
                             "calling simple_engine_blt"));
            goto simple_engine_blt;
        }
    }

    ppdev = (PPDEV)psoDst->dhpdev;
    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

    // pick out the rop table entries for the foreground and background mixes.
    // if we get the same entry for both then we have a rop3.
    //
    pTableFore = &ropTable[rop4 & 0xff];
    pTableBack = &ropTable[rop4 >> 8];
    funcIndexFore = pTableFore->func_index;
    
    // handle rop3 pattern fills where no source is needed
    //
    if ((psoSrc == NULL) && (pTableFore == pTableBack))
    {
        // really a rop3. no mask required

        // solid or pattern fills
        if (funcIndexFore <= PAT_FILL_1_BLT)
        {
            BRUSHOBJ    tmpBrush;
            BRUSHOBJ    *pboTmp;
            ULONG       logicop;

            pboTmp  = pbo;
            logicop = pTableFore->logicop[0];

            // handle the 4 logicops that don't use src or pattern by turning
            // them into optimized solid fills.
            //
            if (funcIndexFore == SOLID_FILL_1_BLT)
            {                
                if ((logicop == __GLINT_LOGICOP_SET) ||
                    (logicop == __GLINT_LOGICOP_CLEAR))
                {
                    // as solid fills we can make use of hardware block fills
                    tmpBrush.iSolidColor = 0xffffff;    // does any depth
                    if (logicop == __GLINT_LOGICOP_CLEAR)
                    {
                        tmpBrush.iSolidColor = 0;
                    }
                    logicop = __GLINT_LOGICOP_COPY;
                    pboTmp  = &tmpBrush;
                }
                else if (logicop == __GLINT_LOGICOP_INVERT)
                {
                    pboTmp = NULL;  // forces a solid fill
                }
                else
                {
                    return(TRUE);   // DST logicop is a noop
                }
            }

            // as fills are performance critical it may be wise to make this
            // code inline as in the sample driver. But for the moment, I'll
            // leave it as a function call.
            //
            if (PatternFillRect(ppdev, prclDst, pco, pboTmp, pptlBrush,
                                                        logicop, logicop))
            {
                return(TRUE);
            }
            
            DISPDBG((DBGLVL, "DrvBitBlt: PatternFillRect "
                             "failed.calling engine_blt"));
            goto engine_blt;
        }
    }

    // this code is important in that it resets psoSrc to be a real DIB surface
    // if src is a DFB converted to a DIB. SourceFillRect() depends on this
    // having been done.
    //
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        if (pdsurfSrc->dt & DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))                            
                        {
                            goto Continue_It;
                        }
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            // pick out the DIB surface that we defined for the DFB when it
            // was created (as our VRAM is linear we always have this).
            //
            psoSrc = pdsurfSrc->pso;
        }
    }

Continue_It:

    // we are now interested in rop3s involving a source
    //
    if (pTableFore == pTableBack)
    {
        if (funcIndexFore == SRC_FILL_1_BLT)
        {
            if (SourceFillRect(ppdev, prclDst, pco, psoSrc, pxlo,
                    pptlSrc, pTableFore->logicop[0], pTableFore->logicop[0]))
            {
                return(TRUE);
            }

            DISPDBG((DBGLVL, "DrvBitBlt: SourceFillRect"
                             " failed.calling engine_blt"));
            goto engine_blt;
        }

        // handle miscellaneous other rop3s. Most of these are done in
        // multiple passes of the hardware.
        //
        switch (funcIndexFore)
        {
            case PAT_SRC_2_BLT:
            case PAT_SRC_PAT_3_BLT:

                DISPDBG((DBGLVL, "PAT_SRC_PAT_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                                 
                if (PatSrcPatBlt(ppdev, psoSrc, pco, pxlo, prclDst,pptlSrc,
                                                  pbo, pptlBrush, pTableFore))
                {
                    return(TRUE);
                }
                break;

            case SRC_PAT_2_BLT:
            case SRC_PAT_SRC_3_BLT:

                DISPDBG((DBGLVL, "SRC_PAT_SRC_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                            
                if (SrcPatSrcBlt(ppdev, psoSrc, pco, pxlo, prclDst,pptlSrc,
                                                  pbo, pptlBrush, pTableFore))
                {
                    return(TRUE);
                }
                break;

            case ENG_DOWNLOAD_2_BLT:

                DISPDBG((DBGLVL, "ENG_DOWNLOAD_2_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                break;

            case ENGINE_BITBLT:

                DISPDBG((DBGLVL, "ENGINE_BITBLT, rop 0x%x", 
                                 pTableFore - ropTable));
                break;

            default:
                break;

        }
        DISPDBG((WRNLVL, "DrvBitBlt: Unhandled rop3.calling engine_blt"));
        goto engine_blt;
    }

    // ROP4
    // we get here if the mix is a true rop4.
    // unlike the above we only handle a few well chosen rop4s.
    // do later.

    DISPDBG((DBGLVL, "got a true rop4 0x%x", rop4));

    funcIndexBack = pTableBack->func_index;
    if (psoMsk != NULL)
    {
        // At this point, we've made sure that we have a true ROP4.
        // This is important because we're about to dereference the
        // mask.  I'll assert to make sure that I haven't inadvertently
        // broken the logic for this:

        ASSERTDD((rop4 & 0xff) != (rop4 >> 8), "This handles true ROP4's only");

        ///////////////////////////////////////////////////////////////////
        // True ROP4's
        ///////////////////////////////////////////////////////////////////

        // Handle ROP4 where no source is required for either Rop3:
        // In this case we handle it by using the mask as a 1bpp
        // source image and we download it. The foreground and
        // background colors are taken from a solid brush.

        if ((funcIndexFore | funcIndexBack) <= PAT_FILL_1_BLT)
        {
            if ((funcIndexFore | funcIndexBack) == PAT_FILL_1_BLT)
            {
                // Fake up a 1bpp XLATEOBJ (note that we should only
                // dereference 'pbo' when it's required by the mix):

                xlc.iForeColor = pbo->iSolidColor;
                xlc.iBackColor = xlc.iForeColor;

                if (xlc.iForeColor == -1)
                {
                    DISPDBG((WRNLVL, "1bpp fake xlate rejected"
                                     " as brush not solid"));
                    goto engine_blt;       // We don't handle non-solid brushes
                }
            }

            // Note that when neither the foreground nor the background mix
            // requires a source, the colours in 'xlc' are allowed to be
            // garbage.

            xlo.pulXlate = (ULONG*) &xlc;
            pxlo         = &xlo;
            psoSrc       = psoMsk;
            pptlSrc      = pptlMsk;

            DISPDBG((DBGLVL, "calling SourceFillRect for rop4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
                            
            if (SourceFillRect(ppdev, prclDst, pco, psoSrc, pxlo,
                    pptlSrc, pTableFore->logicop[0], pTableBack->logicop[0]))
            {
                return(TRUE);
            }

            DISPDBG((WRNLVL, "DrvBitBlt: SourceFillRect (2) "
                             "failed.calling engine_blt"));
            goto engine_blt;
        }                                    // No pattern required
        else if ((funcIndexFore | funcIndexBack) == SRC_FILL_1_BLT) 
        {
            // We're about to dereference 'psoSrc' and 'pptlSrc' --
            // since we already handled the case where neither ROP3
            // required the source, the ROP4 must require a source,
            // so we're safe.

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                     "No source case should already have been handled!");

            // The operation has to be screen-to-screen, and the rectangles
            // cannot overlap:

            if ((psoSrc->iType != STYPE_BITMAP)                  &&
                (psoDst->iType != STYPE_BITMAP)                  &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                !OVERLAP(prclDst, pptlSrc))
            {
                DISPDBG((DBGLVL, "calling MskCopyBlt for rop 4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
//@@BEGIN_DDKSPLIT
                // TMM: 060897: Removed this for WHQL tests
                //if (MaskCopyBlt(ppdev, prclDst, pco, psoSrc, psoMsk,
                //            pptlSrc, pptlMsk,
                //            pTableFore->logicop[0],
                //            pTableBack->logicop[0]))
                //    return(TRUE);
//@@END_DDKSPLIT

                DISPDBG((WRNLVL, "DrvBitBlt: MaskCopyBlt "
                                 "failed.calling engine_blt"));
                goto engine_blt;
            }
        }
        DISPDBG((DBGLVL, "rejected rop4 0x%x with mask", rop4));
    }
    else if ((pTableBack->logicop[0] == __GLINT_LOGICOP_NOOP) &&
             (funcIndexFore <= PAT_FILL_1_BLT))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP).

        DISPDBG((DBGLVL, "calling PatternFillRect for rop4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
        if (PatternFillRect(ppdev, prclDst, pco, pbo, pptlBrush,
                            pTableFore->logicop[0], pTableBack->logicop[0]))
        {
            return(TRUE);
        }

        // fall through to engine_blt ...
    }

    DISPDBG((DBGLVL, "fell through to engine_blt"));

engine_blt:

    if (glintInfo->GdiCantAccessFramebuffer)
    {
        // We require the original pointers to decide if we are talking to
        // the screen or not.

        psoSrc = psoSrcOrig;
        psoDst = psoDstOrig;
        hsurfSrcBitmap = (HSURF)NULL;
        hsurfDstBitmap = (HSURF)NULL;
        psoSrcBitmap = (SURFOBJ*)NULL;
        psoDstBitmap = (SURFOBJ*)NULL;

        // if source is the screen then pick out the bitmap surface
        if (psoSrc && (psoSrc->iType != STYPE_BITMAP))
        {    
            ppdev = (PPDEV)psoSrc->dhpdev;
            pdsurfSrc = (DSURF *)psoSrc->dhsurf;
            psoSrc = pdsurfSrc->pso;

            if (pdsurfSrc->dt & DT_SCREEN)
            {
                RECTL    rclTmp;

                DISPDBG((DBGLVL, "Replacing src screen with bitmap Uploading"));

                // We need to upload the area from the screen and use bitmaps
                // to perform the operation

                hsurfSrcBitmap = (HSURF) EngCreateBitmap(psoSrc->sizlBitmap, 0, 
                                                psoSrc->iBitmapFormat, 0, NULL);
                if (hsurfSrcBitmap == NULL)
                {
                    goto drvBitBltFailed;
                }

                if ((psoSrcBitmap = EngLockSurface(hsurfSrcBitmap)) == NULL)
                {
                    goto drvBitBltFailed;
                }

                rclTmp.left   = pptlSrc->x;
                rclTmp.right  = pptlSrc->x + prclDst->right  - prclDst->left;
                rclTmp.top    = pptlSrc->y;
                rclTmp.bottom = pptlSrc->y + prclDst->bottom - prclDst->top;

                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

                VALIDATE_DD_CONTEXT;

                // Call our function to perform image upload to tmp surface
                if (!bUploadRect(ppdev, NULL, psoSrc, psoSrcBitmap, 
                                    pptlSrc, &rclTmp))
                {
                    goto drvBitBltFailed;
                }

                psoSrc = psoSrcBitmap;
            }
        }

        // if target is on screen then pick out the screen DIB surface

        if (psoDst->iType != STYPE_BITMAP)
        {
            ppdev = (PPDEV)psoDst->dhpdev;
            pdsurfDst = (DSURF *)psoDst->dhsurf;
            psoDst = pdsurfDst->pso;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                POINTL   ptlTmp;

                DISPDBG((DBGLVL, "Replacing dst screen with bitmap Uploading"));

                // We need to upload the area from the screen and use bitmaps
                // to perform the operation

                hsurfDstBitmap = (HSURF) EngCreateBitmap(psoDst->sizlBitmap, 0, 
                                                psoDst->iBitmapFormat, 0, NULL);
                if (hsurfDstBitmap == NULL)
                {
                    goto drvBitBltFailed;
                }

                if ((psoDstBitmap = EngLockSurface(hsurfDstBitmap)) == NULL)
                {
                    goto drvBitBltFailed;
                }

                ptlTmp.x = prclDst->left;
                ptlTmp.y = prclDst->top;

                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                VALIDATE_DD_CONTEXT;

                // Call our function to perform image upload to tmp surface

                if (!bUploadRect(ppdev, pco, psoDst, psoDstBitmap, 
                                    &ptlTmp, prclDst))
                {
                    goto drvBitBltFailed;
                }

                psoDst = psoDstBitmap;
            }
        }

    #if DBG
        if (psoDstBitmap)
        {
            DISPDBG((DBGLVL, "DrvBitBlt dest DIB, psoDst = 0x%08x:", psoDst));
            DISPDBG((DBGLVL,  "\tsize: %d x %d", 
                              psoDst->sizlBitmap.cx, 
                              psoDst->sizlBitmap.cy));
            DISPDBG((DBGLVL,  "\tcjBits = %d", psoDst->cjBits));
            DISPDBG((DBGLVL,  "\tpvBits = 0x%08x", psoDst->pvBits));
            DISPDBG((DBGLVL,  "\tpvScan0 = 0x%08x", psoDst->pvScan0));
            DISPDBG((DBGLVL,  "\tlDelta = %d", psoDst->lDelta));
            DISPDBG((DBGLVL,  "\tiBitmapFormat = %d", psoDst->iBitmapFormat));
            DISPDBG((DBGLVL,  "\tfjBitmap = %d", psoDst->fjBitmap));
         }

         if (psoSrcBitmap)
         {
            DISPDBG((DBGLVL, "DrvBitBlt source DIB, psoSrc = 0x%08x:", psoSrc));
            DISPDBG((DBGLVL, "psoSrc != NULL"));
            DISPDBG((DBGLVL,  "\tsize: %d x %d", 
                              psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
            DISPDBG((DBGLVL,  "\tcjBits = %d", psoSrc->cjBits));
            DISPDBG((DBGLVL,  "\tpvBits = 0x%08x", psoSrc->pvBits));
            DISPDBG((DBGLVL,  "\tpvScan0 = 0x%08x", psoSrc->pvScan0));
            DISPDBG((DBGLVL,  "\tlDelta = %d", psoSrc->lDelta));
            DISPDBG((DBGLVL,  "\tiBitmapFormat = %d", psoSrc->iBitmapFormat));
            DISPDBG((DBGLVL,  "\tfjBitmap = %d", psoSrc->fjBitmap));
        }
    #endif

        DISPDBG((DBGLVL, "About to pass to GDI"));

        if (pco && (pco->iDComplexity == DC_COMPLEX))
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        }

        // get GDI to do the blt

        bRet = EngBitBlt(psoDst,
                         psoSrc,
                         psoMsk,
                         pco,
                         pxlo,
                         prclDst,
                         pptlSrc,
                         pptlMsk,
                         pbo,
                         pptlBrush,
                         rop4);

        // if we need the nibbles replicated within each color component we must
        // do it now since GDI will have destroyed one half of each byte.

        if (psoDstBitmap)
        {
            POINTL   ptlTmp;
    
            // We need to upload the destination to the screen now.

            ptlTmp.x = prclDst->left;
            ptlTmp.y = prclDst->top;

            DISPDBG((DBGLVL, "downloading Now"));

            // We assume the dest upload was performed last, 
            // so the offsets will still be correct.

            if (!SourceFillRect(ppdev, prclDst, pco, psoDstBitmap, NULL, &ptlTmp,
                                __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY))
            {
                goto drvBitBltFailed;
            }

            DISPDBG((DBGLVL, "downloading Done 0x%x 0x%x", 
                             psoDstBitmap, hsurfDstBitmap));

            // Now we can discard the destination bitmap too.

            EngUnlockSurface(psoDstBitmap);
            EngDeleteSurface(hsurfDstBitmap);

            DISPDBG((DBGLVL, "Surface deleted"));
        }

        if (psoSrcBitmap)
        {
            // We can just discard the src bitmap if it was created.

            EngUnlockSurface(psoSrcBitmap);
            EngDeleteSurface(hsurfSrcBitmap);
        }

        DISPDBG((DBGLVL, "returning %d", bRet));
        return(bRet);

drvBitBltFailed:

        DISPDBG((WRNLVL, "drvBitBltFailed"));    
        if (psoSrcBitmap)
        {
            EngUnlockSurface(psoSrcBitmap);
        }
        if (hsurfSrcBitmap) 
        {
            EngDeleteSurface(hsurfSrcBitmap);
        }
        if (psoDstBitmap)
        {
            EngUnlockSurface(psoDstBitmap);
        }
        if (hsurfDstBitmap)
        {
            EngDeleteSurface(hsurfDstBitmap);
        }
        return(FALSE);
    } 

simple_engine_blt:

    // if target is on screen then pick out the screen DIB surface

    if (psoDst->iType != STYPE_BITMAP)
    {
        ppdev = (PPDEV)psoDst->dhpdev;
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        psoDst = pdsurfDst->pso;
    }

    // if source is the screen then pick out the bitmap surface

    if (psoSrc && (psoSrc->iType != STYPE_BITMAP))
    {    
        ppdev = (PPDEV)psoSrc->dhpdev;
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        psoSrc = pdsurfSrc->pso;
    }

    // get GDI to do the blt

    bRet = EngBitBlt(psoDst,
                     psoSrc,
                     psoMsk,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMsk,
                     pbo,
                     pptlBrush,
                     rop4);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL PatternFillRect
*
* Fill a set of rectangles with either a solid color or a pattern. The pattern
* can be either monochrome or colored. If pbo is null then we are using a
* logicop which doesn't require a source. In this case we can set color to
* be anything we want in the low level routine. If pbo is not null then it
* can indicate either a solid color or a mono or colored pattern.
*
* Returns:
*
* True if we handled the fill, False if we want GDI to do it.
*
\**************************************************************************/

BOOL PatternFillRect(
PPDEV       ppdev,
RECTL       *prclDst,
CLIPOBJ     *pco,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
DWORD       fgLogicop,
DWORD       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    RBRUSH      *prb;
    RBRUSH_COLOR rbc;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    GFNFILL     *fillFn;

    // if pbo is null then the caller will have ensured that the logic op
    // doesn't need a source so we can do a solid fill. In that case rbc
    // is irrelevant.
    //
    if ((pbo == NULL) || ((rbc.iSolidColor = pbo->iSolidColor) != -1))
    {
        DISPDBG((DBGLVL, "got a solid brush with color 0x%x "
                         "(fgrop %d, bgrop %d)",
                         rbc.iSolidColor, fgLogicop, bgLogicop));
        fillFn = ppdev->pgfnFillSolid;
    }
    else
    {
        DISPDBG((DBGLVL, "Got a real patterned brush. pbo = 0x%x", pbo));

        // got ourselves a real pattern so check it's realized

        if ((prb = pbo->pvRbrush) == NULL)
        {
            DISPDBG((DBGLVL, "calling BRUSHOBJ_pvGetRbrush"));
            prb = BRUSHOBJ_pvGetRbrush(pbo);
            DISPDBG((DBGLVL, "BRUSHOBJ_pvGetRbrush returned 0x%x", prb));
            if (prb == NULL)
            {
                return FALSE;   // let the engine do it
            }
        }

        if (prb->fl & RBRUSH_2COLOR)
        {
            DISPDBG((DBGLVL, "monochrome brush"));
            fillFn = ppdev->pgfnFillPatMono;
        }
        else
        {
            DISPDBG((DBGLVL, "colored brush"));
            fillFn = ppdev->pgfnFillPatColor;
        }

        rbc.prb = prb;   
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        (*fillFn)(ppdev, 1, prclDst, fgLogicop, bgLogicop, rbc, pptlBrush);
    }
    else if (jClip == DC_RECT)
    {
        DISPDBG((DBGLVL, "rect clip"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            (*fillFn)(ppdev, 1, &rcl, fgLogicop, bgLogicop, rbc, pptlBrush);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                (*fillFn)(ppdev, c, ce.arcl, fgLogicop,
                          bgLogicop, rbc, pptlBrush);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SourceFillRect
*
* Fill a set of rectangles by downloading data from the source bitmap. This
* handles both memory-to-screen and screen-to-screen.
*
* Returns:
*
* True if we handled the fill, False if we want GDI to do it.
*
\**************************************************************************/

BOOL SourceFillRect(
PPDEV       ppdev,
RECTL       *prclDst,
CLIPOBJ     *pco,
SURFOBJ     *psoSrc,
XLATEOBJ    *pxlo,
POINTL      *pptlSrc,
ULONG       fgLogicop,
ULONG       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    GFNXFER     *fillFn;
    ULONG       iSrcBitmapFormat;
    DSURF       *pdsurfSrc;
    POINTL      ptlSrc;
    ULONG       iDir;
    GlintDataPtr glintInfo = (GlintDataPtr)(ppdev->glintInfo);

    DISPDBG((DBGLVL, "SourceFillRect called"));

    // we don't get into this routine unless dst is the screen
    // if psoSrc was originally a DFB converted to a DIB, it must have been
    // re-assigned to the DIV surface before calling this function.

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (psoSrc->iType != STYPE_BITMAP)
    {
        // screen to screen
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

        ASSERTDD(pdsurfSrc->dt & DT_SCREEN, "Expected screen source");

        SETUP_PPDEV_SRC_OFFSETS(ppdev, pdsurfSrc);

        ptlSrc.x = pptlSrc->x - (ppdev->xOffset - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y;

        pptlSrc  = &ptlSrc;

        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
        {
            //////////////////////////////////////////////////
            // Screen-to-screen blt with no translate

            if (jClip == DC_TRIVIAL)
            {
                DISPDBG((DBGLVL, "trivial clip calling ppdev->pgfnCopyBlt"));
                (*ppdev->pgfnCopyBlt)(ppdev, prclDst, 1, fgLogicop, pptlSrc,
                                                                prclDst);
            }
            else if (jClip == DC_RECT)
            {
                if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                {
                    DISPDBG((DBGLVL, "rect clip calling ppdev->pgfnCopyBlt"));
                    (*ppdev->pgfnCopyBlt)(ppdev, &rcl, 1, fgLogicop, pptlSrc,
                                                                prclDst);
                }
            }
            else
            {
                // Don't forget that we'll have to draw the
                // rectangles in the correct direction:

                if (pptlSrc->y >= prclDst->top)
                {
                    if (pptlSrc->x >= prclDst->left)
                        iDir = CD_RIGHTDOWN;
                    else
                        iDir = CD_LEFTDOWN;
                }
                else
                {
                    if (pptlSrc->x >= prclDst->left)
                        iDir = CD_RIGHTUP;
                    else
                        iDir = CD_LEFTUP;
                }

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   iDir, 0);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                          (ULONG*) &ce);

                    c = cIntersect(prclDst, ce.arcl, ce.c);

                    if (c != 0)
                    {
                        DISPDBG((DBGLVL, "complex clip calling "
                                         "ppdev->pgfnCopyBlt"));
                                         
                        (*ppdev->pgfnCopyBlt)(ppdev, 
                                              ce.arcl, 
                                              c, 
                                              fgLogicop, 
                                              pptlSrc, 
                                              prclDst);
                    }

                } while (bMore);
            }

            return TRUE;
        }
    }
    else // (psoSrc->iType == STYPE_BITMAP)
    {
        // Image download
        // here we can use a set of function pointers to handle the 
        // different cases. At the end loop through the cliprects 
        // calling the given function.

        iSrcBitmapFormat = psoSrc->iBitmapFormat;
        if (iSrcBitmapFormat == BMF_1BPP)
        {
            // do 1bpp download
            fillFn = ppdev->pgfnXfer1bpp;       
        }
        else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
            // native depth image download
            fillFn = ppdev->pgfnXferImage;
        }
        else if (iSrcBitmapFormat == BMF_4BPP)
        {
            // 4 to 8,16,32 image download
            DISPDBG((DBGLVL, "4bpp source download."));
            fillFn = ppdev->pgfnXfer4bpp;       
        }
        else if (iSrcBitmapFormat == BMF_8BPP)
        {
            // 8 to 8,16,32 image download
            DISPDBG((DBGLVL, "8bpp source download."));
            fillFn = ppdev->pgfnXfer8bpp;   
        }
        else
        {
            DISPDBG((DBGLVL, "source has format %d,  Punting to GDI", 
                             iSrcBitmapFormat));
            goto ReturnFalse;
        }

        if (jClip == DC_TRIVIAL)
        {
            DISPDBG((DBGLVL, "trivial clip image download"));
            (*fillFn)(ppdev, prclDst, 1, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
        }
        else if (jClip == DC_RECT)
        {
            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            {
                DISPDBG((DBGLVL, "rect clip image download"));
                (*fillFn)(ppdev, &rcl, 1, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
            }
        }
        else
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
            do {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
                c = cIntersect(prclDst, ce.arcl, ce.c);
                if (c != 0)
                {
                    DISPDBG((DBGLVL, "complex clip image download"));
                    (*fillFn)(ppdev, ce.arcl, c, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
                }
            } while (bMore);
        }
        return TRUE;
    }

ReturnFalse:

#if DBG
    DISPDBG((WRNLVL, "SourceFillRect returning false"));
    if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
        DISPDBG((WRNLVL, "due to non-trivial xlate"));
#endif

    return FALSE;
}

/******************************Public*Routine******************************\
* BOOL MaskCopyBlt
*
* We do a screen-to-screen blt through a mask. The source surface must not
* be a bitmap.
*
* Returns:
*
* True if we handled the copy, False if we want GDI to do it.
*
\**************************************************************************/

BOOL MaskCopyBlt(
PPDEV       ppdev,
RECTL*      prclDst,
CLIPOBJ*    pco,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
ULONG       fgLogicop,
ULONG       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    DSURF       *pdsurfSrc;
    POINTL      ptlSrc;
 
    DISPDBG((DBGLVL, "MaskCopyBlt called"));

    if (psoSrc != NULL)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

        ASSERTDD(pdsurfSrc->dt & DT_SCREEN, "Expected screen source");

        ptlSrc.x = pptlSrc->x - (ppdev->xOffset - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y + pdsurfSrc->poh->y;

        pptlSrc  = &ptlSrc;
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        (*ppdev->pgfnMaskCopyBlt)(ppdev, prclDst, 1, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
    }
    else if (jClip == DC_RECT)
    {
        DISPDBG((DBGLVL, "rect clip"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            (*ppdev->pgfnMaskCopyBlt)(ppdev, &rcl, 1, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                (*ppdev->pgfnMaskCopyBlt)(ppdev, ce.arcl, c, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL PatSrcPatBlt
*
* Function to perform a rop3 by combining pattern and source fills. Does a
* pattern fill followed by a source fill. Optionally, it does a further
* pattern fill. Each fill has a separate logicop given in pLogicop.
*
* Returns:
*
* True if we handled the blt, False if we want GDI to do it.
*
\**************************************************************************/

BOOL PatSrcPatBlt(
PPDEV       ppdev,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
POINTL      *pptlSrc,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
RopTablePtr pTable)
{
    ULONG   iSrcBitmapFormat;
    BOOL    bRet;

    DISPDBG((DBGLVL, "PatSrcPatBlt called"));

    // ensure that all calls will pass before we do any rendering. The pattern
    // fills will only fail if we can't realize the brush and that will be
    // detected on the first call. So we only have to ensure that the source
    // download will work since by the time we call the function we will
    // already have done the first pattern fill and it's too late to back out.

    DISPDBG((DBGLVL, "source is of type %s, depth %s",
            (psoSrc->iType == STYPE_DEVBITMAP) ? "DEVBITMAP" :
            (psoSrc->iType == STYPE_BITMAP) ? "BITMAP" : "SCREEN",
            (psoSrc->iBitmapFormat == BMF_1BPP) ? "1" :
            (psoSrc->iBitmapFormat == ppdev->iBitmapFormat) ? "native" : 
                                                              "not supported"
           ));

    // if both source and destination are the screen, we cannot handle this
    // if they overlap since we may destroy the source when we do the first
    // pattern fill.
    //
    if ((psoSrc->iType != STYPE_BITMAP) && (OVERLAP(prclDst, pptlSrc)))
    {
        DISPDBG((DBGLVL, "screen src and dst overlap"));
        return(FALSE);
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        iSrcBitmapFormat = psoSrc->iBitmapFormat;
        if ((iSrcBitmapFormat == BMF_1BPP) ||
             ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
              ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))))
        {
            goto Continue_It;
        }
        DISPDBG((DBGLVL, "failed due to bad source bitmap format"));
        return(FALSE);
    }
//@@BEGIN_DDKSPLIT
    // else (psoSrc->iType != STYPE_BITMAP)
//@@END_DDKSPLIT
    if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "failed due to xlate with non-DIB source"));
        return(FALSE);
    }

Continue_It:

    // as part of the B8 rop3 we are sometimes asked to xor with 0. As this is
    // a noop I'll trap it.
    //
    if ((pbo->iSolidColor != 0) || (pTable->logicop[0] != __GLINT_LOGICOP_XOR))
    {    
        // do the first pattern fill. It can only fail if a brush realize fails
        //
        DISPDBG((DBGLVL, "calling pattern fill function, rop %d",
                         pTable->logicop[0]));
                         
        if (!PatternFillRect(ppdev,
                             prclDst,
                             pco,
                             pbo,
                             pptlBrush,
                             pTable->logicop[0],
                             pTable->logicop[0]))
        {
            return(FALSE);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "ignoring xor with solid color 0"));
    }

    // download the source. We've already ensured that the call won't fail

    DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                     pTable->logicop[1]));

    bRet = SourceFillRect(ppdev,
                          prclDst,
                          pco,
                          psoSrc,
                          pxlo,
                          pptlSrc,
                          pTable->logicop[1],
                          pTable->logicop[1]);
    ASSERTDD(bRet == TRUE, "PatSrcPatBlt: SourceFillRect returned FALSE");

    if ((pTable->func_index == PAT_SRC_PAT_3_BLT) &&
        ((pbo->iSolidColor != 0) || (pTable->logicop[2] != __GLINT_LOGICOP_XOR)))
    {    

        // fill with the pattern again. This won't fail because the first 
        // pattern fill succeeded.

        DISPDBG((DBGLVL, "calling pattern fill function, rop %d",
                         pTable->logicop[2]));
        bRet = PatternFillRect(ppdev,
                               prclDst,
                               pco,
                               pbo,
                               pptlBrush,
                               pTable->logicop[2],
                               pTable->logicop[2]);
                               
        ASSERTDD(bRet == TRUE, 
                 "PatSrcPatBlt: second PatterFillRect returned FALSE");
    }
#if DBG
    else if (pTable->func_index == PAT_SRC_PAT_3_BLT)
    {
        DISPDBG((DBGLVL, "ignoring xor with solid color 0"));
    }
#endif

    DISPDBG((DBGLVL, "PatSrcPatBlt returning true"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SrcPatSrcBlt
*
* Function to perform a rop3 by combining pattern and source fills. Does a
* source fill followed by a pattern fill. Optionally, it does a further
* source fill. Each fill has a separate logicop given in pLogicop.
*
* Returns:
*
* True if we handled the blt, False if we want GDI to do it.
*
\**************************************************************************/

BOOL SrcPatSrcBlt(
PPDEV       ppdev,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
POINTL      *pptlSrc,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
RopTablePtr pTable)
{
    RBRUSH  *prb;
    BOOL    bRet;

    DISPDBG((DBGLVL, "SrcPatSrc called"));

    // if both source and destination are the screen, we cannot handle it
    // if they overlap since we may destroy the source with the first two
    // operations before we get to the third one. If we're only a
    // SRC_PAT_2_BLT then we're OK; SourceFillRect will handle
    // the copy direction of the source fill properly.
    //
    if ((psoSrc->iType != STYPE_BITMAP) &&
        (pTable->func_index == SRC_PAT_SRC_3_BLT) &&
        (OVERLAP(prclDst, pptlSrc)))
    {
        return(FALSE);
    }

    // we must ensure that the pattern fill will succeed. It can only fail if
    // we can't realize the brush so do it now.
    //
    if ((pbo != NULL) && (pbo->iSolidColor == -1))
    {
        if ((prb = pbo->pvRbrush) == NULL)
        {
            prb = BRUSHOBJ_pvGetRbrush(pbo);
            if (prb == NULL)
            {
                return FALSE;   // let the engine do it
            }
        }
    }

    // do the first source download. If it succeeds we know the second one
    // will also work. If it fails we simply let the engine do it and we
    // haven't upset anything (except we may have realized the brush without
    // needing to).
    //

    DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                     pTable->logicop[0]));
                     
    if (!SourceFillRect(ppdev,
                        prclDst,
                        pco,
                        psoSrc,
                        pxlo,
                        pptlSrc,
                        pTable->logicop[0],
                        pTable->logicop[0]))
    {
        return(FALSE);
    }

    // fill with the pattern again. We've already ensured this will work.

    DISPDBG((DBGLVL, "calling pattern fill function, rop %d", 
                     pTable->logicop[1]));
                     
    bRet = PatternFillRect(ppdev,
                           prclDst,
                           pco,
                           pbo,
                           pptlBrush,
                           pTable->logicop[1],
                           pTable->logicop[1]);
    ASSERTDD(bRet == TRUE, "SrcPatSrcBlt: PatternFillRect returned FALSE");

    if (pTable->func_index == SRC_PAT_SRC_3_BLT)
    {
        // download the source again with the final logic op

        DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                         pTable->logicop[2]));
                         
        bRet = SourceFillRect(ppdev,
                              prclDst,
                              pco,
                              psoSrc,
                              pxlo,
                              pptlSrc,
                              pTable->logicop[2],
                              pTable->logicop[2]);

        ASSERTDD(bRet == TRUE, 
                 "SrcPatSrcBlt: second SourceFillRect returned FALSE");
    }

    DISPDBG((DBGLVL, "SrcPatSrcBlt returning true"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bUploadRect
*
* upload a rectangular area. clip to a given CLIPOBJ
*
* Returns:
*
* True if we handled the blt, otherwise False.
*
\**************************************************************************/

BOOL bUploadRect(
PPDEV   ppdev,
CLIPOBJ *pco,
SURFOBJ *psoSrc,
SURFOBJ *psoDst,
POINTL  *pptlSrc,
RECTL   *prclDst)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;

    // Perform the clipping and pass to a 
    // function to upload a list of rectangles.

    DISPDBG((DBGLVL, "UploadRect called. Src %d %d To "
                     "dst (%d %d) --> (%d %d)", 
                     pptlSrc->x, pptlSrc->y,
                     prclDst->left, prclDst->top, 
                     prclDst->right, prclDst->bottom));

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
     
    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        ppdev->pgfnUpload(ppdev, 1, prclDst, psoDst, pptlSrc, prclDst);
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            DISPDBG((DBGLVL, "rect clip"));
            ppdev->pgfnUpload(ppdev, 1, &rcl, psoDst, pptlSrc, prclDst);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                ppdev->pgfnUpload(ppdev, c, ce.arcl, psoDst, pptlSrc, prclDst);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bUploadBlt
*
* Returns:
*
* True if we handled the blt, otherwise False.
*
\**************************************************************************/

BOOL bUploadBlt(
PPDEV    ppdev,
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMsk,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL       *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMsk,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4     rop4)
{
    BOOL        bRet;

    DISPDBG((DBGLVL, "bUploadBlt called"));
    if ((rop4 == 0xCCCC) &&
        ((pxlo == NULL) || pxlo->flXlate & XO_TRIVIAL) &&
        (psoDst->iBitmapFormat == ppdev->iBitmapFormat))
    {
        // We have no raster op to worry about, and no translations to perform.
        // All we need to do is upload the data from GLINT and put it in the
        // destination. Practically, most image uploads should be of this type.
        return(bUploadRect(ppdev, pco, psoSrc, psoDst, pptlSrc, prclDst));
    }
    else
    {
        HSURF       hsurfTmp;
        SURFOBJ*    psoTmp;
        SIZEL       sizl;
        POINTL      ptlTmp;
        RECTL       rclTmp;

        // We cant upload directly to the destination, so we create a 
        // temporary bitmap, upload to this bitmap, then call EngBitBlt 
        // to do the hard work of the translation or raster op.

        // Source point in tmp:
        ptlTmp.x      = 0;
        ptlTmp.y      = 0;

        // Dest Area in tmp
        rclTmp.left   = 0; 
        rclTmp.top   = 0;
        rclTmp.right  = prclDst->right  - prclDst->left;
        rclTmp.bottom = prclDst->bottom - prclDst->top; 

        // Work out size of tmp bitmap. We know left and top are zero.
        sizl.cx = rclTmp.right;
        sizl.cy = rclTmp.bottom;

        // Create the bitmap
        hsurfTmp = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                           0, NULL);
        if (hsurfTmp == NULL)
        {
            return(FALSE);
        }

        if ((psoTmp = EngLockSurface(hsurfTmp)) == NULL)
        {
            EngDeleteSurface(hsurfTmp);
            return(FALSE);
        }

        // Call our function to perform image upload to tmp surface
        bRet = bUploadRect(ppdev, NULL, psoSrc, psoTmp, pptlSrc, &rclTmp);

        // Call GDI to blt from tmp surface to destination, 
        // doing all the work for us
        if (bRet)
        {
            bRet = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo, prclDst, 
                                &ptlTmp, pptlMsk, pbo, pptlBrush, rop4);
        }

        // Remove tmp surface
        EngUnlockSurface(psoTmp);
        EngDeleteSurface(hsurfTmp);

        return(bRet);
    }
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* On the S3 it's faster to do straight SRCCOPY bitblt's through the
* memory aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    POINTL  ptl;
    RECTL   rcl;
    OH*     pohSrc;
    OH*     pohDst;
    CLIPENUM    ce;
    int         cClipRects;
    BOOL        bMore, bRet, bCopyDone = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvCopyBits called"));

    // We need to remove the pointer, but we dont know which surface is valid
    // (if either). 
    if ((psoDst->iType != STYPE_BITMAP) && 
        (((DSURF *)(psoDst->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoDst->dhpdev;
        REMOVE_SWPOINTER(psoDst);
    }
    else if ((psoSrc->iType != STYPE_BITMAP) && 
             (((DSURF *)(psoSrc->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoSrc->dhpdev;
        REMOVE_SWPOINTER(psoSrc);
    } 
#if 0    
    else
    {
        // we shouldn't ever fall here, but we have this just as safeguard code
        return EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);    
    }
#endif    

#if !defined(_WIN64) && WNT_DDRAW
    // Touch the source surface 1st and then the destination surface

    vSurfUsed(psoSrc);
    vSurfUsed(psoDst);
#endif
 
    // Faster route to calling screen-to-screen BLT. The order in the if() is
    // very important to avoid null pointers.

    pdsurfDst = (DSURF*)psoDst->dhsurf;
    pdsurfSrc = (DSURF*)psoSrc->dhsurf;

    if ((psoDst->iType != STYPE_BITMAP) && 
        (pdsurfDst->dt & DT_SCREEN) &&
        psoSrc && 
        (psoSrc->iType != STYPE_BITMAP) && 
        (pdsurfSrc->dt & DT_SCREEN) &&
        ((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        pohSrc = pdsurfSrc->poh;
        pohDst = pdsurfDst->poh;

        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
        ptl.y = pptlSrc->y;

        ppdev = (PDEV*)  psoDst->dhpdev;
        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

        (*ppdev->pgfnCopyBltCopyROP)(ppdev, prclDst, 1, __GLINT_LOGICOP_COPY, 
                                        &ptl, prclDst);
        
        return(TRUE);
    }

    if ((psoDst->iType != STYPE_BITMAP) && 
        psoSrc && 
        (psoSrc->iType == STYPE_BITMAP))
    {
        // straight DIB->screen download with translate: see if 
        // we special-case it

        ppdev = (PDEV*)psoDst->dhpdev; 

        if (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            (psoSrc->iBitmapFormat == psoDst->iBitmapFormat) && 
            ppdev->pgfnCopyXferImage)
        {    
            // native depth download
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            // only accelerate when downloading to the framebuffer
            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if(pco == NULL || pco->iDComplexity == DC_TRIVIAL)
                {
                    ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, prclDst, 
                                                prclDst, 1);
                }
                else if(pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl)) 
                    {
                        ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, &rcl, 1);
                    }
                }
                else //(pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do 
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, 
                                                            prclDst, ce.arcl, 
                                                                cClipRects);
                        }
                    }
                    while(bMore);
                }
                return(TRUE);
            }
        }
        else if (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                 (psoSrc->iBitmapFormat == BMF_24BPP) &&
                 ppdev->pgfnCopyXfer24bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            // only accelerate when downloading to the framebuffer

            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if(pco == NULL || pco->iDComplexity == DC_TRIVIAL)
                {
                    ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, prclDst, 
                                                prclDst, 1);
                }
                else if(pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, &rcl, 1);
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, 
                                                            prclDst, ce.arcl, 
                                                                 cClipRects);
                        }
                    } while(bMore);
                }
                return(TRUE);
            }
        }
        else if (pxlo && (pxlo->flXlate & XO_TABLE) &&
                 (psoSrc->iBitmapFormat == BMF_8BPP) &&
                 (pxlo->cEntries == 256) && ppdev->pgfnCopyXfer8bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                BOOL bRenderLargeBitmap;

                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                bRenderLargeBitmap = (ppdev->pgfnCopyXfer8bppLge != NULL);

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    if(bRenderLargeBitmap)
                    {
                        ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, prclDst, 1, pxlo);
                    }
                    else
                    {
                        ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, prclDst,
                                                            prclDst, 1, pxlo);
                    }                        
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl)) 
                    {
                        if(bRenderLargeBitmap)
                        {
                            ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, &rcl, 1, pxlo);
                        }
                        else
                        {
                            ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, &rcl, 1, pxlo);
                        }
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            if(bRenderLargeBitmap)
                            {
                                ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, 
                                                           pptlSrc, prclDst, 
                                                           ce.arcl, cClipRects, 
                                                           pxlo);
                            }
                            else
                            {
                                ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, ce.arcl, 
                                                        cClipRects, pxlo);
                            }
                        }
                    } while(bMore);
                }
                return(TRUE);
            }
        }
        else if (pxlo && (pxlo->flXlate & XO_TABLE) && 
                 (psoSrc->iBitmapFormat == BMF_4BPP) && 
                 (pxlo->cEntries == 16) && ppdev->pgfnCopyXfer4bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, prclDst, 
                                            prclDst, 1, pxlo);
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, 
                                                prclDst, &rcl, 1, pxlo);
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, ce.arcl, 
                                                    cClipRects, pxlo);
                        }
                    }
                    while(bMore);
                }
                return(TRUE);
            }
        }
//@@BEGIN_DDKSPLIT
#if DBG && 0
        else if (psoSrc->iBitmapFormat != BMF_1BPP)
        {
            SIZEL sizl;
            int   cEntries = pxlo == 0 ? 0 : pxlo->cEntries;
            int   flXlate =  pxlo == 0 ? 0 : pxlo->flXlate;
            int   iDComplexity = pco == 0 ? 0 : pco->iDComplexity;

            sizl.cx = prclDst->right - prclDst->left;
            sizl.cy = prclDst->bottom - prclDst->top;
            DISPDBG((ERRLVL, "DrvCopyBits() unhandled copy download "
                             "bmf(%xh) pxlo(%p, cEntries=%03xh flXlate=%xh) "
                             "pco(%p, iDComplexity=%02xh), cxcy(%03xh,%03xh)",
                             psoSrc->iBitmapFormat, pxlo, cEntries, flXlate, 
                             pco, iDComplexity, sizl.cx, sizl.cy));

        }
#endif
//@@END_DDKSPLIT
    }

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco) && (pco->iDComplexity != DC_TRIVIAL)) ||
        ((pxlo) && (! (pxlo->flXlate & XO_TRIVIAL))))
    {
        /////////////////////////////////////////////////////////////////
        // A DrvCopyBits is after all just a simplified DrvBitBlt:

        DISPDBG((DBGLVL, "DrvCopyBits fell through to DrvBitBlt"));
        return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, 
                         NULL, NULL, NULL, 0x0000CCCC));

    }

//@@BEGIN_DDKSPLIT
    // Screen to screen case has already been handled at the very beginning.
//@@END_DDKSPLIT
    
    DISPDBG((DBGLVL, "trivial clip and xlate"));

    if ((psoDst->iType != STYPE_BITMAP) && (pdsurfDst->dt & DT_SCREEN))
    {
        // We know the destination is either a DFB or the screen:

        DISPDBG((DBGLVL, "Destination is not a bitmap"));
        
        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        // See if the source is a plain DIB:

        ASSERTDD(((psoSrc->iType == STYPE_BITMAP) || (pdsurfSrc->dt & DT_DIB)),
                 "Screen-to-screen case should have been handled");

//@@BEGIN_DDKSPLIT
        // Ah ha, the source is a DFB that's really a DIB.
//@@END_DDKSPLIT

        if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
        {
            if (pdsurfSrc) {
                
                DISPDBG((DBGLVL, "source is DFB that's really a DIB"));
                psoSrc = pdsurfSrc->pso;
                ppdev = pdsurfSrc->ppdev;
            }

            //////////////////////////////////////////////////////
            // DIB-to-screen

            ASSERTDD((psoDst->iType != STYPE_BITMAP) &&
                     (pdsurfDst->dt & DT_SCREEN)     &&
                     (psoSrc->iType == STYPE_BITMAP) &&
                     (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                     "Should be a DIB-to-screen case");

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

            DISPDBG((DBGLVL, "doing DIB-to-screen transfer"));
            (*ppdev->pgfnXferImage)(ppdev,
                                    prclDst,
                                    1,
                                    __GLINT_LOGICOP_COPY,
                                    __GLINT_LOGICOP_COPY,
                                    psoSrc,
                                    pptlSrc,
                                    prclDst,
                                    NULL);
            bRet = TRUE;
            bCopyDone = TRUE;
        }
    }
    else // The destination is a DIB
    {
        DISPDBG((DBGLVL, "Destination is a bitmap"));

        if (pdsurfDst)
        {
            psoDst = pdsurfDst->pso;
        }
        if (pdsurfSrc)
        {
            ppdev = pdsurfSrc->ppdev;
        }

        if ((ppdev != NULL) &&
            (psoDst->iBitmapFormat == ppdev->iBitmapFormat) &&
            (psoSrc->iType != STYPE_BITMAP) &&
            (pdsurfSrc->dt & DT_SCREEN))
        {
            VOID pxrxMemUpload  (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
        
            GLINT_DECL_INIT;

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

            // Perform the upload.
            VALIDATE_DD_CONTEXT;
            DISPDBG((DBGLVL, "doing Screen-to-DIB image upload"));
            
            //(*ppdev->pgfnUpload)
            pxrxMemUpload
                (ppdev, 1, prclDst, psoDst, 
                                 pptlSrc, prclDst);
                                 
            bRet = TRUE;
            bCopyDone = TRUE;

        }
    }


//@@BEGIN_DDKSPLIT
    // NB: we must never get here if the dest is actually the screen (ie. if
    // pdsurfDst->dt & DT_SCREEN and we've changed psoDst to the bypass
    // bitmap). This is because we don't handle nibble replication here which
    // we must do if GDI ever draws directly to the framebuffer. We don't SYNC
    // here because we may be doing a true DIB-to-DIB. We do a SYNC if
    // necessary before jumping here. Currently this happens only if the src
    // is a DFB.
    // 
//@@END_DDKSPLIT

    if (! bCopyDone)
    {
        if (pdsurfDst)
        {
            psoDst = pdsurfDst->pso;
        }
        if (pdsurfSrc)        
        {
            psoSrc = pdsurfSrc->pso;
        }

        ASSERTDD((psoDst->iType == STYPE_BITMAP) &&
                 (psoSrc->iType == STYPE_BITMAP),
                 "Both surfaces should be DIBs to call EngCopyBits");

        DISPDBG((DBGLVL, "DrvCopyBits fell through to EngCopyBits"));

        bRet = EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }

    /////////////////////////////////////////////////////
    // Put It Back Into Off-screen?
    //
    // We take this opportunity to decide if we want to
    // put the DIB back into off-screen memory.  This is
    // a pretty good place to do it because we have to
    // copy the bits to some portion of the screen,
    // anyway.  So we would incur only an extra screen-to-
    // screen blt at this time, much of which will be
    // over-lapped with the CPU.
    //
    // The simple approach we have taken is to move a DIB
    // back into off-screen memory only if there's already
    // room -- we won't throw stuff out to make space
    // (because it's tough to know what ones to throw out,
    // and it's easy to get into thrashing scenarios).
    //
    // Because it takes some time to see if there's room
    // in off-screen memory, we only check one in
    // HEAP_COUNT_DOWN times if there's room.  To bias
    // in favour of bitmaps that are often blt, the
    // counters are reset every time any space is freed
    // up in off-screen memory.  We also don't bother
    // checking if no space has been freed since the
    // last time we checked for this DIB.

    if ((! pdsurfSrc) || (pdsurfSrc->dt & DT_SCREEN))
    {
        return (bRet);
    }


    if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
    {
        if (--pdsurfSrc->cBlt == 0)
        {
            DISPDBG((DBGLVL, "putting src back "
                             "into off-screen"));

            // Failure is safe here
            bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc);
        }
    }
    else
    {
        // Some space was freed up in off-screen memory,
        // so reset the counter for this DFB:

        pdsurfSrc->iUniq = ppdev->iHeapUniq;
        pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
    }

    return (bRet);
}

#if defined(_X86_) 

/******************************Public*Table********************************\ 
* BYTE gajLeftMask[] and BYTE gajRightMask[] 
* 
* Edge tables for vXferScreenTo1bpp. 
\**************************************************************************/ 
 
BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 }; 
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe }; 
 
/******************************Public*Routine******************************\ 
* VOID DoScreenToMono 
* 
* This function works out the clip list and then calls vXferScreenTo1bpp()
* to do ye hard work. 
* 
\**************************************************************************/ 

BOOL DoScreenToMono(
PDEV*       ppdev, 
RECTL       *prclDst,
CLIPOBJ     *pco,
SURFOBJ*    psoSrc,             // Source surface 
SURFOBJ*    psoDst,             // Destination surface 
POINTL*     pptlSrc,            // Original unclipped source point 
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    RECTL       rcl;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DoScreenToMono: Trivial clipping"));
        vXferScreenTo1bpp(ppdev, 1, prclDst, 0, psoSrc, 
                            psoDst, pptlSrc, prclDst, pxlo);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        DISPDBG((DBGLVL, "DoScreenToMono: rect clipping"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            vXferScreenTo1bpp(ppdev, 1, &rcl, 0, psoSrc, 
                                psoDst, pptlSrc, prclDst, pxlo); 
        }
    }
    else // (pco->iDComplexity == DC_COMPLEX)
    {
        CLIPENUM ce;
        int cClipRects;
        BOOL bMore;

        DISPDBG((DBGLVL, "DoScreenToMono: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
            if(cClipRects)
            {
                vXferScreenTo1bpp (ppdev, cClipRects, ce.arcl, 0, psoSrc, 
                                    psoDst, pptlSrc, prclDst, pxlo); 
            }
        } while(bMore);
    }

    return(TRUE);
} 

/******************************Public*Routine******************************\ 
* VOID vXferScreenTo1bpp 
* 
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp 
* bitmap. 
* 
\**************************************************************************/ 

VOID vXferScreenTo1bpp(         // Type FNXFER 
PDEV*       ppdev, 
LONG        c,                  // Count of rectangles, can't be zero 
RECTL*      prcl,               // List of destination rectangles, in relative 
                                //   coordinates 
ULONG       ulHwMix,            // Not used 
SURFOBJ*    psoSrc,             // Source surface 
SURFOBJ*    psoDst,             // Destination surface 
POINTL*     pptlSrc,            // Original unclipped source point 
RECTL*      prclDst,            // Original unclipped destination rectangle 
XLATEOBJ*   pxlo)               // Provides colour-compressions information 
{ 
    LONG    cjPelSize; 
    VOID*   pfnCompute; 
    SURFOBJ soTmp; 
    ULONG*  pulXlate; 
    ULONG   ulForeColor; 
    RECTL   rclTmp; 
    BYTE*   pjDst; 
    BYTE    jLeftMask; 
    BYTE    jRightMask; 
    BYTE    jNotLeftMask; 
    BYTE    jNotRightMask; 
    LONG    cjMiddle; 
    LONG    lDstDelta; 
    LONG    lSrcDelta; 
    LONG    cyTmpScans; 
    LONG    cyThis; 
    LONG    cyToGo; 
 
    ASSERTDD(c > 0, "Can't handle zero rectangles"); 
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations"); 
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize), 
                "Temp buffer has to be larger than widest possible scan"); 

    soTmp = *psoSrc;
    
    // When the destination is a 1bpp bitmap, the foreground colour 
    // maps to '1', and any other colour maps to '0'. 
 
    if (ppdev->iBitmapFormat == BMF_8BPP) 
    { 
        // When the source is 8bpp or less, we find the forground colour 
        // by searching the translate table for the only '1': 
 
        pulXlate = pxlo->pulXlate; 
        while (*pulXlate != 1) 
        {
            pulXlate++; 
        }
        ulForeColor = pulXlate - pxlo->pulXlate; 
    } 
    else 
    { 
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) || 
                 (ppdev->iBitmapFormat == BMF_32BPP), 
                 "This routine only supports 8, 16 or 32bpp"); 
 
        // When the source has a depth greater than 8bpp, the foreground 
        // colour will be the first entry in the translate table we get 
        // from calling 'piVector': 
 
        pulXlate = XLATEOBJ_piVector(pxlo); 
 
        ulForeColor = 0; 
        if (pulXlate != NULL)           // This check isn't really needed... 
        {
            ulForeColor = pulXlate[0]; 
        }
    } 
 
    // We use the temporary buffer to keep a copy of the source 
    // rectangle: 
 
    soTmp.pvScan0 = ppdev->pvTmpBuffer; 
 
    do { 
        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta) 
                                        + (prcl->left >> 3); 
 
        cjPelSize = ppdev->cjPelSize; 
 
        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L)) 
                       * cjPelSize; 
 
        // Our temporary buffer, into which we read a copy of the source, 
        // may be smaller than the source rectangle.  In that case, we 
        // process the source rectangle in batches. 
        // 
        // cyTmpScans is the number of scans we can do in each batch. 
        // cyToGo is the total number of scans we have to do for this 
        // rectangle. 
        // 
        // We take the buffer size less four so that the right edge case 
        // can safely read one dword past the end: 
 
        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta; 
        cyToGo     = prcl->bottom - prcl->top; 
 
        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan"); 
 
        // Initialize variables that don't change within the batch loop: 
 
        rclTmp.top    = 0; 
        rclTmp.left   = prcl->left & 7L; 
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left; 
 
        // Note that we have to be careful with the right mask so that it 
        // isn't zero.  A right mask of zero would mean that we'd always be 
        // touching one byte past the end of the scan (even though we 
        // wouldn't actually be modifying that byte), and we must never 
        // access memory past the end of the bitmap (because we can access 
        // violate if the bitmap end is exactly page-aligned). 
 
        jLeftMask     = gajLeftMask[rclTmp.left & 7]; 
        jRightMask    = gajRightMask[rclTmp.right & 7]; 
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1; 
 
        if (cjMiddle < 0) 
        { 
            // The blt starts and ends in the same byte: 
 
            jLeftMask &= jRightMask; 
            jRightMask = 0; 
            cjMiddle   = 0; 
        } 
 
        jNotLeftMask  = ~jLeftMask; 
        jNotRightMask = ~jRightMask; 
        lDstDelta     = psoDst->lDelta - cjMiddle - 2; 
                                // Delta from the end of the destination 
                                //  to the start on the next scan, accounting 
                                //  for 'left' and 'right' bytes 
 
        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize); 
                                // Compute source delta for special cases 
                                //  like when cjMiddle gets bumped up to '0', 
                                //  and to correct aligned cases 
 
        do { 
            // This is the loop that breaks the source rectangle into 
            // manageable batches. 
 
            cyThis  = cyTmpScans;
            if( cyToGo < cyThis )
            {
                cyThis = cyToGo; 
            }
            cyToGo -= cyThis; 
 
            rclTmp.bottom = cyThis; 
 
            ppdev->pgfnUpload( ppdev, 1, &rclTmp, &soTmp, pptlSrc, &rclTmp );
            pptlSrc->y += cyThis;
 
            _asm { 
                mov     eax,ulForeColor     ;eax = foreground colour 
                                            ;ebx = temporary storage 
                                            ;ecx = count of middle dst bytes 
                                            ;dl  = destination byte accumulator 
                                            ;dh  = temporary storage 
                mov     esi,soTmp.pvScan0   ;esi = source pointer 
                mov     edi,pjDst           ;edi = destination pointer 
 
                ; Figure out the appropriate compute routine: 
 
                mov     ebx,cjPelSize 
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp 
                dec     ebx 
                jz      short Do_Left_Byte 
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp 
                dec     ebx 
                jz      short Do_Left_Byte 
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp 
 
            Do_Left_Byte: 
                call    pfnCompute 
                and     dl,jLeftMask 
                mov     dh,jNotLeftMask 
                and     dh,[edi] 
                or      dh,dl 
                mov     [edi],dh 
                inc     edi 
                mov     ecx,cjMiddle 
                dec     ecx 
                jl      short Do_Right_Byte 
 
            Do_Middle_Bytes: 
                call    pfnCompute 
                mov     [edi],dl 
                inc     edi 
                dec     ecx 
                jge     short Do_Middle_Bytes 
 
            Do_Right_Byte: 
                call    pfnCompute 
                and     dl,jRightMask 
                mov     dh,jNotRightMask 
                and     dh,[edi] 
                or      dh,dl 
                mov     [edi],dh 
                inc     edi 
 
                add     edi,lDstDelta 
                add     esi,lSrcDelta 
                dec     cyThis 
                jnz     short Do_Left_Byte 
 
                mov     pjDst,edi               ;save for next batch 
 
                jmp     All_Done 
 
            Compute_Destination_Byte_From_8bpp: 
                mov     bl,[esi] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 0 
 
                mov     bl,[esi+1] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 1 
 
                mov     bl,[esi+2] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 2 
 
                mov     bl,[esi+3] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 3 
 
                mov     bl,[esi+4] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 4 
 
                mov     bl,[esi+5] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 5 
 
                mov     bl,[esi+6] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 6 
 
                mov     bl,[esi+7] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,8                   ;advance the source 
                ret 
 
            Compute_Destination_Byte_From_16bpp: 
                mov     bx,[esi] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 0 
 
                mov     bx,[esi+2] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 1 
 
                mov     bx,[esi+4] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 2 
 
                mov     bx,[esi+6] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 3 
 
                mov     bx,[esi+8] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 4 
 
                mov     bx,[esi+10] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 5 
 
                mov     bx,[esi+12] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 6 
 
                mov     bx,[esi+14] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,16                  ;advance the source 
                ret 
 
            Compute_Destination_Byte_From_32bpp: 
                mov     ebx,[esi] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 0 
 
                mov     ebx,[esi+4] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 1 
 
                mov     ebx,[esi+8] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 2 
 
                mov     ebx,[esi+12] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 3 
 
                mov     ebx,[esi+16] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 4 
 
                mov     ebx,[esi+20] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 5 
 
                mov     ebx,[esi+24] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 6 
 
                mov     ebx,[esi+28] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,32                  ;advance the source 
                ret 
 
            All_Done: 
            } 
        } while (cyToGo > 0); 
 
        prcl++; 
    } while (--c != 0); 
} 

#endif // defined(_X86_) 

#if (_WIN32_WINNT >= 0x500)

//*****************************************************************************
// FUNC: DrvGradientFill
// ARGS: psoDst (I) - destination surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation for pVertex 
//       pVertex (I) - array of trivertex (x,y,color) coordinates
//       nVertex (I) - size of pVertex
//       pMesh (I) - array of GRADIENT_RECT or GRADIENT_TRIANGLE structures
//                   that define the connectivity of pVertex points
//       nMesh (I) - size of pMesh
//       prclExtents (I) - the bounding rectangle
//       pptlDitherOrg (I) - unused
//       ulMode (I) - specifies the fill type (rectangular or triangular)and 
//                    direction
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a Gouraud-shaded fill for an array of rectangles or triangles.
// Rectangles can be horizontally or vertically shaded (i.e. we only step the
// color DDA in one direction).
//*****************************************************************************

BOOL DrvGradientFill(
SURFOBJ   *psoDst,
CLIPOBJ   *pco,
XLATEOBJ  *pxlo,
TRIVERTEX *pVertex,
ULONG     nVertex,
PVOID     pMesh,
ULONG     nMesh,
RECTL    *prclExtents,
POINTL   *pptlDitherOrg,
ULONG     ulMode)
{
    SURFOBJ *psoDstOrig = psoDst; // destination surface DIB 
    PDEV    *ppdev;
    DSURF   *pdsurf;
    OH      *poh;
    SURFOBJ *psoDIBDst;
    BOOL bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvGradientFill entered"));

    ppdev = (PDEV *)psoDst->dhpdev;
    pdsurf = (DSURF *)psoDst->dhsurf;
    GLINT_DECL_INIT;

    if(ppdev->pgfnGradientFillRect == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if(psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((4, "DrvGradientFill: destination is a DIB - "
                    "punt back to GDI"));
        goto punt;
    }

    if((pdsurf->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvGradientFill: destination is a DFB "
                         "now in host memory - punt back to GDI"));
        goto punt;
    }

    if(ulMode == GRADIENT_FILL_TRIANGLE)
    {
        DISPDBG((DBGLVL, "DrvGradientFill: don't support triangular fills"));
        goto punt;
    }

//@@BEGIN_DDKSPLIT
    /* ignore pxlo: source is always in 16:16:16:16 format
    if(pxlo->iDstType)
    {
        // xlate object is valid
        if((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
        {
            DISPDBG((DBGLVL, "DrvGradientFill: "
                             "don't support color translation"));
            goto punt;
        }
    }
    */
//@@END_DDKSPLIT

    VALIDATE_DD_CONTEXT;
    poh = pdsurf->poh;

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvGradientFill: trivial clipping"));
        bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                               pVertex, 
                                               nVertex, 
                                               (GRADIENT_RECT *)pMesh, 
                                               nMesh, 
                                               ulMode, 
                                               prclExtents, 
                                               1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvGradientFill: rectangular clipping"));
        bSuccess = !bIntersect(prclExtents, &pco->rclBounds, &rcl);
        if(!bSuccess)
        {
            bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                                   pVertex, 
                                                   nVertex, 
                                                   (GRADIENT_RECT *)pMesh, 
                                                   nMesh, 
                                                   ulMode, 
                                                   &rcl, 
                                                   1);
        }
    }
    else
    {
        CLIPENUM    ce;
        LONG        crcl;
        BOOL        bMore;

        DISPDBG((DBGLVL, "DrvGradientFill: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclExtents, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                                       pVertex, 
                                                       nVertex, 
                                                       (GRADIENT_RECT *)pMesh, 
                                                       nMesh, 
                                                       ulMode, 
                                                       ce.arcl, 
                                                       crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvGradientFill done, bSuccess = %d", bSuccess));
    if(bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvGradientFill: calling EngGradientFill"));

    if(psoDstOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
        {
            psoDstOrig = pdsurf->pso;
        }
    }

    bSuccess = EngGradientFill(psoDstOrig,
                               pco,
                               pxlo,
                               pVertex,
                               nVertex,
                               pMesh,
                               nMesh,
                               prclExtents, 
                               pptlDitherOrg,
                               ulMode);
    return(bSuccess);
}

//*****************************************************************************
// FUNC: DrvTransparentBlt
// ARGS: psoDst (I) - destination surface
//       psoSrc (I) - sources surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation from source to destination
//       prclDst (I) - destination rectangle
//       prclSrc (I) - source rectangle
//       iTransColor (I) - transparent color
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a chroma-keyed COPY blt. Source and Destination are guaranteed not
// to overlap.
//*****************************************************************************

BOOL DrvTransparentBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
RECTL    *prclSrc,
ULONG     iTransColor,
ULONG     ulReserved)
{
    SURFOBJ *psoDstOrig = psoDst;
    SURFOBJ *psoSrcOrig = psoSrc;
    PDEV    *ppdev;
    DSURF   *pdsurfSrc, *pdsurfDst;
    OH      *pohSrc, *pohDst;
    ULONG   cxSrc, cySrc, cxDst, cyDst;
    POINTL  ptlSrc;
    BOOL    bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvTransparentBlt entered"));

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoDst->iType == STYPE_BITMAP))
    {
        // we can't obtain any valid ppdev from this
        goto punt_error;
    }

    if (psoSrc->iType != STYPE_BITMAP)
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        ppdev = (PDEV *)psoSrc->dhpdev;
    }
    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        ppdev = (PDEV *)psoDst->dhpdev;
    }

    GLINT_DECL_INIT;

    if (ppdev->pgfnTransparentBlt == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support downloads"));
        goto punt;
    }

    if (psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support uploads"));
        goto punt;
    }

    if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support xlates"));
        goto punt;
    }

    // screen-to-screen blt
    // ensure both surfaces are in the framebuffer

    if((pdsurfSrc->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: source is a DFB now "
                         "in host memory - punt back to GDI"));
        goto punt;
    }

    if((pdsurfDst->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: destination is a DFB "
                         "now in host memory - punt back to GDI"));
        goto punt;
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;
    cxDst = prclDst->right - prclDst->left;
    cyDst = prclDst->bottom - prclDst->top;

    if ((cxSrc != cxDst) || (cySrc != cyDst))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: only support 1:1 blts "
                         "cxySrc(%d,%d) cxyDst(%d,%d)", 
                         cxSrc, cySrc, cxDst, cyDst));
        goto punt;
    }

    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    // destination surface base offset plus x offset from that
    pohDst = pdsurfDst->poh;
    pohSrc = pdsurfSrc->poh;

    SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

    ptlSrc.x = prclSrc->left + pohSrc->x;
    ptlSrc.y = prclSrc->top;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: trivial clipping"));
        bSuccess = ppdev->pgfnTransparentBlt(ppdev, prclDst, &ptlSrc, 
                                                iTransColor, prclDst, 1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvTransparentBlt: rectangular clipping"));
        bSuccess = !bIntersect(prclDst, &pco->rclBounds, &rcl);
        if (!bSuccess)
        {
            bSuccess = ppdev->pgfnTransparentBlt(ppdev, prclDst, &ptlSrc, 
                                                    iTransColor, &rcl, 1);
        }
    }
    else
    {
        CLIPENUM    ce;
        LONG        crcl;
        BOOL        bMore;

        DISPDBG((DBGLVL, "DrvTransparentBlt: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclDst, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnTransparentBlt(ppdev,prclDst, &ptlSrc, 
                                                        iTransColor, ce.arcl, 
                                                                        crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvTransparentBlt done, bSuccess = %d", bSuccess));

    if(bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvTransparentBlt: calling EngTransparentBlt"));

    if(psoDstOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
            psoDstOrig = pdsurfDst->pso;
    }

    if(psoSrcOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
            psoSrcOrig = pdsurfSrc->pso;
    }

punt_error:
    bSuccess = EngTransparentBlt(psoDstOrig,
                                 psoSrcOrig,
                                 pco,
                                 pxlo,
                                 prclDst,
                                 prclSrc,
                                 iTransColor,
                                 ulReserved);

    return(bSuccess);
}

//*****************************************************************************
// FUNC: DrvAlphaBlend
// ARGS: psoDst (I) - destination surface
//       psoSrc (I) - sources surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation from source to destination
//       prclDst (I) - destination rectangle
//       prclSrc (I) - source rectangle
//       pBlendObj (I) - specifies the type of alpha blending
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a blt with alpha blending. There are three types of blend 
// operation:-
// 1.) Source has constant alpha. Each destination color component is 
//     calculated using the common blend function:-
//     dC = sC.cA + dC(1 - cA)
// 2.) Source has per pixel alpha. The source is guaranteed to be 32 bits and
//     to have been premultiplied with its alpha. Each destination color 
//     component is calculated using the premult blend function:-
//     dC = sC + dC(1 - sA)
// 3.) Source has per pixel alpha and constant alpha. The source is guaranteed
//     to be 32 bits and to have been premultiplied with its alpha. The 
//     calculation is in two stages, first we calculate the transient value of
//     each component by multiplying the source with the constant alpha:-
//     tC = sC * cA
//     Next, we blend the destination with the premultiplied transient value:-
//     dC = tC + dC(1 - tA)
// 
// dC = destination component, sC = source component, tC = transient component
// cA = constant alpha, sA = source alpha, tA = transient alpha
//*****************************************************************************

BOOL DrvAlphaBlend(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo, 
RECTL    *prclDst,
RECTL    *prclSrc,
BLENDOBJ *pBlendObj)
{  
    SURFOBJ *psoDstOrig = psoDst;
    SURFOBJ *psoSrcOrig = psoSrc;
    PDEV    *ppdev;
    DSURF   *pdsurfDst, *pdsurfSrc;
    OH      *pohDst, *pohSrc;
    ULONG   cxSrc, cySrc, cxDst, cyDst;
    POINTL  ptlSrc;
    CLIPENUM ce;
    BOOL     bMore;
    LONG     crcl;
    BOOL     bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvAlphaBlend entered"));

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoDst->iType == STYPE_BITMAP))
    {
        // we can't obtain any valid ppdev from this
        goto punt_error;
    }

    if (psoSrc->iType != STYPE_BITMAP)
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        ppdev = (PDEV *)psoSrc->dhpdev;
    }

    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        ppdev = (PDEV *)psoDst->dhpdev;
    }

    GLINT_DECL_INIT;

    if (ppdev->pgfnAlphaBlend == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support downloads"));
        goto punt;
    }

    if (psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support uploads"));
        goto punt;
    }

    if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support xlates"));
        goto punt;
    }

    // screen-to-screen blt
    // ensure both surfaces are in the framebuffer

    if((pdsurfSrc->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: source is a DFB now in host memory "
                         "- punt back to GDI"));
        goto punt;
    }

    if((pdsurfDst->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: destination is a DFB now in host "
                         "memory - punt back to GDI"));
        goto punt;
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;
    cxDst = prclDst->right - prclDst->left;
    cyDst = prclDst->bottom - prclDst->top;

    if((cxSrc != cxDst) || (cySrc != cyDst))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: only support 1:1 blts "
                         "cxySrc(%d,%d) cxyDst(%d,%d)", 
                         cxSrc, cySrc, cxDst, cyDst));
        goto punt;
    }

    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    // destination surface base offset plus x offset from that
    pohDst = pdsurfDst->poh;
    pohSrc = pdsurfSrc->poh;

    SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

    ptlSrc.x = prclSrc->left + pohSrc->x;
    ptlSrc.y = prclSrc->top;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: trivial clipping"));
        bSuccess = ppdev->pgfnAlphaBlend(ppdev, prclDst, &ptlSrc, pBlendObj, 
                                                                   prclDst, 1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvAlphaBlend: rectangular clipping"));
        bSuccess = !bIntersect(prclDst, &pco->rclBounds, &rcl);
        if (!bSuccess)
        {
            bSuccess = ppdev->pgfnAlphaBlend(ppdev, prclDst, &ptlSrc, 
                                                    pBlendObj, &rcl, 1);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclDst, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnAlphaBlend(ppdev,prclDst, &ptlSrc, 
                                                    pBlendObj, ce.arcl, crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvAlphaBlend done, bSuccess = %d", bSuccess));

    if (bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvAlphaBlend: calling EngAlphaBlend"));

    if (psoDstOrig->iType != STYPE_BITMAP)
    {
        if (!glintInfo->GdiCantAccessFramebuffer)
            psoDstOrig = pdsurfDst->pso;
    }

    if (psoSrcOrig->iType != STYPE_BITMAP)
    {
        if (!glintInfo->GdiCantAccessFramebuffer)
            psoSrcOrig = pdsurfSrc->pso;
    }

punt_error:

    bSuccess = EngAlphaBlend(psoDstOrig,
                             psoSrcOrig,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             pBlendObj);

    return(bSuccess);
}

#endif //(_WIN32_WINNT >= 0x500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\dbgtags.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Dbgtags.c
*
* Content: Debugging support code
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
*****************************************************************************/

#include <precomp.h>

const char *p3r3TagString( ULONG tag ) {
    switch( tag ) {
        case 0x000: return "StartXDom                      ";
        case 0x001: return "dXDom                          ";
        case 0x002: return "StartXSub                      ";
        case 0x003: return "dXSub                          ";
        case 0x004: return "StartY                         ";
        case 0x005: return "dY                             ";
        case 0x006: return "Count                          ";
        case 0x007: return "Render                         ";
        case 0x008: return "ContinueNewLine                ";
        case 0x009: return "ContinueNewDom                 ";
        case 0x00A: return "ContinueNewSub                 ";
        case 0x00B: return "Continue                       ";
        case 0x00C: return "FlushSpan                      ";
        case 0x00D: return "BitMaskPattern                 ";
        case 0x010: return "PointTable0                    ";
        case 0x011: return "PointTable1                    ";
        case 0x012: return "PointTable2                    ";
        case 0x013: return "PointTable3                    ";
        case 0x014: return "RasterizerMode                 ";
        case 0x015: return "YLimits                        ";
        case 0x016: return "ScanlineOwnership              ";
        case 0x017: return "WaitForCompletion              ";
        case 0x018: return "PixelSize                      ";
        case 0x019: return "StripeOffsetY                  ";
        case 0x026: return "FastBlockLimits                ";
        case 0x030: return "ScissorMode                    ";
        case 0x031: return "ScissorMinXY                   ";
        case 0x032: return "ScissorMaxXY                   ";
        case 0x033: return "ScreenSize                     ";
        case 0x034: return "AreaStippleMode                ";
        case 0x035: return "LineStippleMode                ";
        case 0x036: return "LoadLineStippleCounters        ";
        case 0x037: return "UpdateLineStippleCounters      ";
        case 0x038: return "SaveLineStippleState           ";
        case 0x039: return "WindowOrigin                   ";
        case 0x040: return "AreaStipplePattern0            ";
        case 0x041: return "AreaStipplePattern1            ";
        case 0x042: return "AreaStipplePattern2            ";
        case 0x043: return "AreaStipplePattern3            ";
        case 0x044: return "AreaStipplePattern4            ";
        case 0x045: return "AreaStipplePattern5            ";
        case 0x046: return "AreaStipplePattern6            ";
        case 0x047: return "AreaStipplePattern7            ";
        case 0x048: return "AreaStipplePattern8            ";
        case 0x049: return "AreaStipplePattern9            ";
        case 0x04A: return "AreaStipplePattern10           ";
        case 0x04B: return "AreaStipplePattern11           ";
        case 0x04C: return "AreaStipplePattern12           ";
        case 0x04D: return "AreaStipplePattern13           ";
        case 0x04E: return "AreaStipplePattern14           ";
        case 0x04F: return "AreaStipplePattern15           ";
        case 0x050: return "AreaStipplePattern16           ";
        case 0x051: return "AreaStipplePattern17           ";
        case 0x052: return "AreaStipplePattern18           ";
        case 0x053: return "AreaStipplePattern19           ";
        case 0x054: return "AreaStipplePattern20           ";
        case 0x055: return "AreaStipplePattern21           ";
        case 0x056: return "AreaStipplePattern22           ";
        case 0x057: return "AreaStipplePattern23           ";
        case 0x058: return "AreaStipplePattern24           ";
        case 0x059: return "AreaStipplePattern25           ";
        case 0x05A: return "AreaStipplePattern26           ";
        case 0x05B: return "AreaStipplePattern27           ";
        case 0x05C: return "AreaStipplePattern28           ";
        case 0x05D: return "AreaStipplePattern29           ";
        case 0x05E: return "AreaStipplePattern30           ";
        case 0x05F: return "AreaStipplePattern31           ";
        case 0x060: return "FillFBWriteBufferAddr0         ";
        case 0x061: return "FillFBSourceReadBufferAddr     ";
        case 0x062: return "FillFBDestReadBufferAddr0      ";
        case 0x063: return "FillScissorMinXY               ";
        case 0x064: return "FillScissorMaxXY               ";
        case 0x065: return "FillForegroundColor0           ";
        case 0x066: return "FillBackgroundColor            ";
        case 0x067: return "FillConfig2D0                  ";
        case 0x068: return "FillFBSourceReadBufferOffset   ";
        case 0x069: return "FillRectanglePosition          ";
        case 0x06A: return "FillRender2D                   ";
        case 0x06B: return "FillForegroundColor1           ";
        case 0x06C: return "FillConfig2D1                  ";
        case 0x06D: return "FillGlyphPosition              ";
        case 0x070: return "TextureCoordMode               ";
        case 0x071: return "SStart                         ";
        case 0x072: return "dSdx                           ";
        case 0x073: return "dSdyDom                        ";
        case 0x074: return "TStart                         ";
        case 0x075: return "dTdx                           ";
        case 0x076: return "dTdyDom                        ";
        case 0x077: return "QStart                         ";
        case 0x078: return "dQdx                           ";
        case 0x079: return "dQdyDom                        ";
        case 0x07A: return "LOD                            ";
        case 0x07B: return "dSdy                           ";
        case 0x07C: return "dTdy                           ";
        case 0x07D: return "dQdy                           ";
        case 0x080: return "S1Start                        ";
        case 0x081: return "dS1dx                          ";
        case 0x082: return "dS1dyDom                       ";
        case 0x083: return "T1Start                        ";
        case 0x084: return "dT1dx                          ";
        case 0x085: return "dT1dyDom                       ";
        case 0x086: return "Q1Start                        ";
        case 0x087: return "dQ1dx                          ";
        case 0x088: return "dQ1dyDom                       ";
        case 0x089: return "LOD1                           ";
        case 0x08A: return "TextureLODBiasS                ";
        case 0x08B: return "TextureLODBiasT                ";
        case 0x090: return "TextureReadMode                ";
        case 0x091: return "TextureFormat                  ";
        case 0x092: return "TextureCacheControl            ";
        case 0x095: return "BorderColor0                   ";
        case 0x098: return "LUTIndex                       ";
        case 0x099: return "LUTData                        ";
        case 0x09A: return "LUTAddress                     ";
        case 0x09B: return "LUTTransfer                    ";
        case 0x09C: return "TextureFilterMode              ";
        case 0x09D: return "TextureChromaUpper0            ";
        case 0x09E: return "TextureChromaLower0            ";
        case 0x09F: return "BorderColor1                   ";
        case 0x0A0: return "TextureBaseAddr0               ";
        case 0x0A1: return "TextureBaseAddr1               ";
        case 0x0A2: return "TextureBaseAddr2               ";
        case 0x0A3: return "TextureBaseAddr3               ";
        case 0x0A4: return "TextureBaseAddr4               ";
        case 0x0A5: return "TextureBaseAddr5               ";
        case 0x0A6: return "TextureBaseAddr6               ";
        case 0x0A7: return "TextureBaseAddr7               ";
        case 0x0A8: return "TextureBaseAddr8               ";
        case 0x0A9: return "TextureBaseAddr9               ";
        case 0x0AA: return "TextureBaseAddr10              ";
        case 0x0AB: return "TextureBaseAddr11              ";
        case 0x0AC: return "TextureBaseAddr12              ";
        case 0x0AD: return "TextureBaseAddr13              ";
        case 0x0AE: return "TextureBaseAddr14              ";
        case 0x0AF: return "TextureBaseAddr15              ";
        case 0x0B0: return "TextureMapWidth0               ";
        case 0x0B1: return "TextureMapWidth1               ";
        case 0x0B2: return "TextureMapWidth2               ";
        case 0x0B3: return "TextureMapWidth3               ";
        case 0x0B4: return "TextureMapWidth4               ";
        case 0x0B5: return "TextureMapWidth5               ";
        case 0x0B6: return "TextureMapWidth6               ";
        case 0x0B7: return "TextureMapWidth7               ";
        case 0x0B8: return "TextureMapWidth8               ";
        case 0x0B9: return "TextureMapWidth9               ";
        case 0x0BA: return "TextureMapWidth10              ";
        case 0x0BB: return "TextureMapWidth11              ";
        case 0x0BC: return "TextureMapWidth12              ";
        case 0x0BD: return "TextureMapWidth13              ";
        case 0x0BE: return "TextureMapWidth14              ";
        case 0x0BF: return "TextureMapWidth15              ";
        case 0x0C0: return "TextureChromaUpper1            ";
        case 0x0C1: return "TextureChromaLower1            ";
        case 0x0D0: return "TextureApplicationMode         ";
        case 0x0D1: return "TextureEnvColor                ";
        case 0x0D2: return "FogMode                        ";
        case 0x0D3: return "FogColor                       ";
        case 0x0D4: return "FStart                         ";
        case 0x0D5: return "dFdx                           ";
        case 0x0D6: return "dFdyDom                        ";
        case 0x0D7: return "ZFogBias                       ";
        case 0x0E0: return "TextTGlyphAddr0                ";
        case 0x0E1: return "TextRender2DGlyph0             ";
        case 0x0E2: return "TextTGlyphAddr1                ";
        case 0x0E3: return "TextRender2DGlyph1             ";
        case 0x0E4: return "TextTGlyphAddr2                ";
        case 0x0E5: return "TextRender2DGlyph2             ";
        case 0x0E6: return "TextTGlyphAddr3                ";
        case 0x0E7: return "TextRender2DGlyph3             ";
        case 0x0E8: return "TextTGlyphAddr4                ";
        case 0x0E9: return "TextRender2DGlyph4             ";
        case 0x0EA: return "TextTGlyphAddr5                ";
        case 0x0EB: return "TextRender2DGlyph5             ";
        case 0x0EC: return "TextTGlyphAddr6                ";
        case 0x0ED: return "TextRender2DGlyph6             ";
        case 0x0EE: return "TextTGlyphAddr7                ";
        case 0x0EF: return "TextRender2DGlyph7             ";
        case 0x0F0: return "RStart                         ";
        case 0x0F1: return "dRdx                           ";
        case 0x0F2: return "dRdyDom                        ";
        case 0x0F3: return "GStart                         ";
        case 0x0F4: return "dGdx                           ";
        case 0x0F5: return "dGdyDom                        ";
        case 0x0F6: return "BStart                         ";
        case 0x0F7: return "dBdx                           ";
        case 0x0F8: return "dBdyDom                        ";
        case 0x0F9: return "AStart                         ";
        case 0x0FA: return "dAdx                           ";
        case 0x0FB: return "dAdyDom                        ";
        case 0x0FC: return "ColorDDAMode                   ";
        case 0x0FD: return "ConstantColor                  ";
        case 0x0FE: return "Color                          ";
        case 0x100: return "AlphaTestMode                  ";
        case 0x101: return "AntialiasMode                  ";
        case 0x103: return "DitherMode                     ";
        case 0x104: return "FBSoftwareWriteMask            ";
        case 0x105: return "LogicalOpMode                  ";
        case 0x108: return "RouterMode                     ";
        case 0x110: return "LBReadMode                     ";
        case 0x111: return "LBReadFormat                   ";
        case 0x112: return "LBSourceOffset                 ";
        case 0x114: return "LBSourceData                   ";
        case 0x115: return "LBStencil                      ";
        case 0x116: return "LBDepth                        ";
        case 0x117: return "LBWindowBase                   ";
        case 0x118: return "LBWriteMode                    ";
        case 0x119: return "LBWriteFormat                  ";
        case 0x11D: return "TextureData                    ";
        case 0x11E: return "TextureDownloadOffset          ";
        case 0x11F: return "LBWindowOffset                 ";
        case 0x120: return "HostInID                       ";
        case 0x121: return "Security                       ";
        case 0x122: return "FlushWriteCombining            ";
        case 0x123: return "HostInState                    ";
        case 0x127: return "HostInDMAAddress               ";
        case 0x128: return "HostInState2                   ";
        case 0x12F: return "VertexRename                   ";
        case 0x130: return "Window                         ";
        case 0x131: return "StencilMode                    ";
        case 0x132: return "StencilData                    ";
        case 0x133: return "Stencil                        ";
        case 0x134: return "DepthMode                      ";
        case 0x135: return "Depth                          ";
        case 0x136: return "ZStartU                        ";
        case 0x137: return "ZStartL                        ";
        case 0x138: return "dZdxU                          ";
        case 0x139: return "dZdxL                          ";
        case 0x13A: return "dZdyDomU                       ";
        case 0x13B: return "dZdyDomL                       ";
        case 0x13C: return "FastClearDepth                 ";
        case 0x13D: return "LBCancelWrite                  ";
        case 0x153: return "FBColor                        ";
        case 0x154: return "FBData                         ";
        case 0x155: return "FBSourceData                   ";
        case 0x157: return "FBWriteMode                    ";
        case 0x158: return "FBHardwareWriteMask            ";
        case 0x159: return "FBBlockColor                   ";
        case 0x180: return "FilterMode                     ";
        case 0x181: return "StatisticMode                  ";
        case 0x182: return "MinRegion                      ";
        case 0x183: return "MaxRegion                      ";
        case 0x184: return "ResetPickResult                ";
        case 0x185: return "MinHitRegion                   ";
        case 0x186: return "MaxHitRegion                   ";
        case 0x187: return "PickResult                     ";
        case 0x188: return "Sync                           ";
        case 0x189: return "RLEMask                        ";
        case 0x18B: return "FBBlockColorBackU              ";
        case 0x18C: return "FBBlockColorBackL              ";
        case 0x18D: return "FBBlockColorU                  ";
        case 0x18E: return "FBBlockColorL                  ";
        case 0x18F: return "SuspendUntilFrameBlank         ";
        case 0x190: return "KsRStart                       ";
        case 0x191: return "dKsRdx                         ";
        case 0x192: return "dKsRdyDom                      ";
        case 0x193: return "KsGStart                       ";
        case 0x194: return "dKsGdx                         ";
        case 0x195: return "dKsGdyDom                      ";
        case 0x196: return "KsBStart                       ";
        case 0x197: return "dKsBdx                         ";
        case 0x198: return "dKsBdyDom                      ";
        case 0x1A0: return "KdRStart                       ";
        case 0x1A1: return "dKdRdx                         ";
        case 0x1A2: return "dKdRdyDom                      ";
        case 0x1A3: return "KdGStart                       ";
        case 0x1A4: return "dKdGdx                         ";
        case 0x1A5: return "dKdGdyDom                      ";
        case 0x1A6: return "KdBStart                       ";
        case 0x1A7: return "dKdBdx                         ";
        case 0x1A8: return "dKdBdyDom                      ";
        case 0x1B8: return "ContextDump                    ";
        case 0x1B9: return "ContextRestore                 ";
        case 0x1BA: return "ContextData                    ";
        case 0x1D0: return "LUT0                           ";
        case 0x1D1: return "LUT1                           ";
        case 0x1D2: return "LUT2                           ";
        case 0x1D3: return "LUT3                           ";
        case 0x1D4: return "LUT4                           ";
        case 0x1D5: return "LUT5                           ";
        case 0x1D6: return "LUT6                           ";
        case 0x1D7: return "LUT7                           ";
        case 0x1D8: return "LUT8                           ";
        case 0x1D9: return "LUT9                           ";
        case 0x1DA: return "LUT10                          ";
        case 0x1DB: return "LUT11                          ";
        case 0x1DC: return "LUT12                          ";
        case 0x1DD: return "LUT13                          ";
        case 0x1DE: return "LUT14                          ";
        case 0x1DF: return "LUT15                          ";
        case 0x1E0: return "YUVMode                        ";
        case 0x1E1: return "ChromaUpper                    ";
        case 0x1E2: return "ChromaLower                    ";
        case 0x1E3: return "AlphaMapUpperBound             ";
        case 0x1F1: return "FeedbackX                      ";
        case 0x1F2: return "FeedbackY                      ";
        case 0x1FF: return "EndOfFeedback                  ";
        case 0x200: return "V0FloatS1                      ";
        case 0x201: return "V0FloatT1                      ";
        case 0x202: return "V0FloatQ1                      ";
        case 0x203: return "V0Reserved0                    ";
        case 0x204: return "V0Reserved1                    ";
        case 0x205: return "V0Reserved2                    ";
        case 0x206: return "V0Reserved3                    ";
        case 0x207: return "V0Reserved4                    ";
        case 0x208: return "V0Reserved5                    ";
        case 0x209: return "V0FloatPackedDiffuse           ";
        case 0x20A: return "V0FloatKsR                     ";
        case 0x20B: return "V0FloatKsG                     ";
        case 0x20C: return "V0FloatKsB                     ";
        case 0x20D: return "V0FloatKdR                     ";
        case 0x20E: return "V0FloatKdG                     ";
        case 0x20F: return "V0FloatKdB                     ";
        case 0x210: return "V1FloatS1                      ";
        case 0x211: return "V1FloatT1                      ";
        case 0x212: return "V1FloatQ1                      ";
        case 0x213: return "V1Reserved0                    ";
        case 0x214: return "V1Reserved1                    ";
        case 0x215: return "V1Reserved2                    ";
        case 0x216: return "V1Reserved3                    ";
        case 0x217: return "V1Reserved4                    ";
        case 0x218: return "V1Reserved5                    ";
        case 0x219: return "V1FloatPackedDiffuse           ";
        case 0x21A: return "V1FloatKsR                     ";
        case 0x21B: return "V1FloatKsG                     ";
        case 0x21C: return "V1FloatKsB                     ";
        case 0x21D: return "V1FloatKdR                     ";
        case 0x21E: return "V1FloatKdG                     ";
        case 0x21F: return "V1FloatKdB                     ";
        case 0x220: return "V2FloatS1                      ";
        case 0x221: return "V2FloatT1                      ";
        case 0x222: return "V2FloatQ1                      ";
        case 0x223: return "V2Reserved0                    ";
        case 0x224: return "V2Reserved1                    ";
        case 0x225: return "V2Reserved2                    ";
        case 0x226: return "V2Reserved3                    ";
        case 0x227: return "V2Reserved4                    ";
        case 0x228: return "V2Reserved5                    ";
        case 0x229: return "V2FloatPackedDiffuse           ";
        case 0x22A: return "V2FloatKsR                     ";
        case 0x22B: return "V2FloatKsG                     ";
        case 0x22C: return "V2FloatKsB                     ";
        case 0x22D: return "V2FloatKdR                     ";
        case 0x22E: return "V2FloatKdG                     ";
        case 0x22F: return "V2FloatKdB                     ";
        case 0x230: return "V0FloatS                       ";
        case 0x231: return "V0FloatT                       ";
        case 0x232: return "V0FloatQ                       ";
        case 0x233: return "V0Reserved7                    ";
        case 0x234: return "V0Reserved8                    ";
        case 0x235: return "V0FloatR                       ";
        case 0x236: return "V0FloatG                       ";
        case 0x237: return "V0FloatB                       ";
        case 0x238: return "V0FloatA                       ";
        case 0x239: return "V0FloatF                       ";
        case 0x23A: return "V0FloatX                       ";
        case 0x23B: return "V0FloatY                       ";
        case 0x23C: return "V0FloatZ                       ";
        case 0x23D: return "V0FloatW                       ";
        case 0x23E: return "V0FloatPackedColour            ";
        case 0x23F: return "V0FloatPackedSpecularFog       ";
        case 0x240: return "V1FloatS                       ";
        case 0x241: return "V1FloatT                       ";
        case 0x242: return "V1FloatQ                       ";
        case 0x243: return "V1Reserved7                    ";
        case 0x244: return "V1Reserved8                    ";
        case 0x245: return "V1FloatR                       ";
        case 0x246: return "V1FloatG                       ";
        case 0x247: return "V1FloatB                       ";
        case 0x248: return "V1FloatA                       ";
        case 0x249: return "V1FloatF                       ";
        case 0x24A: return "V1FloatX                       ";
        case 0x24B: return "V1FloatY                       ";
        case 0x24C: return "V1FloatZ                       ";
        case 0x24D: return "V1FloatW                       ";
        case 0x24E: return "V1FloatPackedColour            ";
        case 0x24F: return "V1FloatPackedSpecularFog       ";
        case 0x250: return "V2FloatS                       ";
        case 0x251: return "V2FloatT                       ";
        case 0x252: return "V2FloatQ                       ";
        case 0x253: return "V2Reserved7                    ";
        case 0x254: return "V2Reserved8                    ";
        case 0x255: return "V2FloatR                       ";
        case 0x256: return "V2FloatG                       ";
        case 0x257: return "V2FloatB                       ";
        case 0x258: return "V2FloatA                       ";
        case 0x259: return "V2FloatF                       ";
        case 0x25A: return "V2FloatX                       ";
        case 0x25B: return "V2FloatY                       ";
        case 0x25C: return "V2FloatZ                       ";
        case 0x25D: return "V2FloatW                       ";
        case 0x25E: return "V2FloatPackedColour            ";
        case 0x25F: return "V2FloatPackedSpecularFog       ";
        case 0x260: return "DeltaMode                      ";
        case 0x261: return "DrawTriangle                   ";
        case 0x262: return "RepeatTriangle                 ";
        case 0x263: return "DrawLine01                     ";
        case 0x264: return "DrawLine10                     ";
        case 0x265: return "RepeatLine                     ";
        case 0x266: return "DrawPoint                      ";
        case 0x267: return "ProvokingVertex                ";
        case 0x268: return "TextureLODScale                ";
        case 0x269: return "TextureLODScale1               ";
        case 0x26A: return "DeltaControl                   ";
        case 0x26B: return "ProvokingVertexMask            ";
        case 0x26F: return "BroadcastMask                  ";
        case 0x28B: return "DeltaTexture01                 ";
        case 0x28C: return "DeltaTexture11                 ";
        case 0x28D: return "DeltaTexture21                 ";
        case 0x28E: return "DeltaTexture31                 ";
        case 0x290: return "XBias                          ";
        case 0x291: return "YBias                          ";
        case 0x2EC: return "LineCoord0                     ";
        case 0x2ED: return "DrawLine2D10                   ";
        case 0x2EE: return "LineCoord1                     ";
        case 0x2EF: return "DrawLine2D01                   ";
        case 0x530: return "DMAAddr                        ";
        case 0x531: return "DMACount                       ";
        case 0x532: return "CommandInterrupt               ";
        case 0x535: return "DMARectangleRead               ";
        case 0x536: return "DMARectangleReadAddress        ";
        case 0x537: return "DMARectangleReadLinePitch      ";
        case 0x538: return "DMARectangleReadTarget         ";
        case 0x539: return "DMARectangleWrite              ";
        case 0x53A: return "DMARectangleWriteAddress       ";
        case 0x53B: return "DMARectangleWriteLinePitch     ";
        case 0x53C: return "DMAOutputAddress               ";
        case 0x53D: return "DMAOutputCount                 ";
        case 0x53F: return "DMAContinue                    ";
        case 0x542: return "DMAFeedback                    ";
        case 0x55A: return "DeltaModeAnd                   ";
        case 0x55B: return "DeltaModeOr                    ";
        case 0x564: return "DeltaControlAnd                ";
        case 0x565: return "DeltaControlOr                 ";
        case 0x570: return "WindowAnd                      ";
        case 0x571: return "WindowOr                       ";
        case 0x572: return "LBReadModeAnd                  ";
        case 0x573: return "LBReadModeOr                   ";
        case 0x574: return "RasterizerModeAnd              ";
        case 0x575: return "RasterizerModeOr               ";
        case 0x576: return "ScissorModeAnd                 ";
        case 0x577: return "ScissorModeOr                  ";
        case 0x578: return "LineStippleModeAnd             ";
        case 0x579: return "LineStippleModeOr              ";
        case 0x57A: return "AreaStippleModeAnd             ";
        case 0x57B: return "AreaStippleModeOr              ";
        case 0x57C: return "ColorDDAModeAnd                ";
        case 0x57D: return "ColorDDAModeOr                 ";
        case 0x57E: return "AlphaTestModeAnd               ";
        case 0x57F: return "AlphaTestModeOr                ";
        case 0x580: return "AntialiasModeAnd               ";
        case 0x581: return "AntialiasModeOr                ";
        case 0x582: return "FogModeAnd                     ";
        case 0x583: return "FogModeOr                      ";
        case 0x584: return "TextureCoordModeAnd            ";
        case 0x585: return "TextureCoordModeOr             ";
        case 0x586: return "TextureReadMode0And            ";
        case 0x587: return "TextureReadMode0Or             ";
        case 0x588: return "TextureFormatAnd               ";
        case 0x589: return "TextureFormatOr                ";
        case 0x58A: return "TextureApplicationModeAnd      ";
        case 0x58B: return "TextureApplicationModeOr       ";
        case 0x58C: return "StencilModeAnd                 ";
        case 0x58D: return "StencilModeOr                  ";
        case 0x58E: return "DepthModeAnd                   ";
        case 0x58F: return "DepthModeOr                    ";
        case 0x590: return "LBWriteModeAnd                 ";
        case 0x591: return "LBWriteModeOr                  ";
        case 0x592: return "FBDestReadModeAnd              ";
        case 0x593: return "FBDestReadModeOr               ";
        case 0x594: return "FBSourceReadModeAnd            ";
        case 0x595: return "FBSourceReadModeOr             ";
        case 0x596: return "AlphaBlendColorModeAnd         ";
        case 0x597: return "AlphaBlendColorModeOr          ";
        case 0x598: return "ChromaTestModeAnd              ";
        case 0x599: return "ChromaTestModeOr               ";
        case 0x59A: return "DitherModeAnd                  ";
        case 0x59B: return "DitherModeOr                   ";
        case 0x59C: return "LogicalOpModeAnd               ";
        case 0x59D: return "LogicalOpModeOr                ";
        case 0x59E: return "FBWriteModeAnd                 ";
        case 0x59F: return "FBWriteModeOr                  ";
        case 0x5A0: return "FilterModeAnd                  ";
        case 0x5A1: return "FilterModeOr                   ";
        case 0x5A2: return "StatisticModeAnd               ";
        case 0x5A3: return "StatisticModeOr                ";
        case 0x5A4: return "FBDestReadEnablesAnd           ";
        case 0x5A5: return "FBDestReadEnablesOr            ";
        case 0x5A6: return "AlphaBlendAlphaModeAnd         ";
        case 0x5A7: return "AlphaBlendAlphaModeOr          ";
        case 0x5A8: return "TextureReadMode1And            ";
        case 0x5A9: return "TextureReadMode1Or             ";
        case 0x5AA: return "TextureFilterModeAnd           ";
        case 0x5AB: return "TextureFilterModeOr            ";
        case 0x5AE: return "LUTModeAnd                     ";
        case 0x5AF: return "LUTModeOr                      ";
        case 0x5D0: return "FBDestReadBufferAddr0          ";
        case 0x5D1: return "FBDestReadBufferAddr1          ";
        case 0x5D2: return "FBDestReadBufferAddr2          ";
        case 0x5D3: return "FBDestReadBufferAddr3          ";
        case 0x5D4: return "FBDestReadBufferOffset0        ";
        case 0x5D5: return "FBDestReadBufferOffset1        ";
        case 0x5D6: return "FBDestReadBufferOffset2        ";
        case 0x5D7: return "FBDestReadBufferOffset3        ";
        case 0x5D8: return "FBDestReadBufferWidth0         ";
        case 0x5D9: return "FBDestReadBufferWidth1         ";
        case 0x5DA: return "FBDestReadBufferWidth2         ";
        case 0x5DB: return "FBDestReadBufferWidth3         ";
        case 0x5DC: return "FBDestReadMode                 ";
        case 0x5DD: return "FBDestReadEnables              ";
        case 0x5E0: return "FBSourceReadMode               ";
        case 0x5E1: return "FBSourceReadBufferAddr         ";
        case 0x5E2: return "FBSourceReadBufferOffset       ";
        case 0x5E3: return "FBSourceReadBufferWidth        ";
        case 0x5E7: return "MergeSpanData                  ";
        case 0x5E8: return "PCIWindowBase0                 ";
        case 0x5E9: return "PCIWindowBase1                 ";
        case 0x5EA: return "PCIWindowBase2                 ";
        case 0x5EB: return "PCIWindowBase3                 ";
        case 0x5EC: return "PCIWindowBase4                 ";
        case 0x5ED: return "PCIWindowBase5                 ";
        case 0x5EE: return "PCIWindowBase6                 ";
        case 0x5EF: return "PCIWindowBase7                 ";
        case 0x5F0: return "AlphaSourceColor               ";
        case 0x5F1: return "AlphaDestColor                 ";
        case 0x5F2: return "ChromaPassColor                ";
        case 0x5F3: return "ChromaFailColor                ";
        case 0x5F4: return "AlphaBlendColorMode            ";
        case 0x5F5: return "AlphaBlendAlphaMode            ";
        case 0x5F6: return "ConstantColorDDA               ";
        case 0x5F8: return "D3DAlphaTestMode               ";
        case 0x600: return "FBWriteBufferAddr0             ";
        case 0x601: return "FBWriteBufferAddr1             ";
        case 0x602: return "FBWriteBufferAddr2             ";
        case 0x603: return "FBWriteBufferAddr3             ";
        case 0x604: return "FBWriteBufferOffset0           ";
        case 0x605: return "FBWriteBufferOffset1           ";
        case 0x606: return "FBWriteBufferOffset2           ";
        case 0x607: return "FBWriteBufferOffset3           ";
        case 0x608: return "FBWriteBufferWidth0            ";
        case 0x609: return "FBWriteBufferWidth1            ";
        case 0x60A: return "FBWriteBufferWidth2            ";
        case 0x60B: return "FBWriteBufferWidth3            ";
        case 0x60C: return "FBBlockColor0                  ";
        case 0x60D: return "FBBlockColor1                  ";
        case 0x60E: return "FBBlockColor2                  ";
        case 0x60F: return "FBBlockColor3                  ";
        case 0x610: return "FBBlockColorBack0              ";
        case 0x611: return "FBBlockColorBack1              ";
        case 0x612: return "FBBlockColorBack2              ";
        case 0x613: return "FBBlockColorBack3              ";
        case 0x614: return "FBBlockColorBack               ";
        case 0x615: return "SizeOfFramebuffer              ";
        case 0x616: return "VTGAddress                     ";
        case 0x617: return "VTGData                        ";
        case 0x618: return "ForegroundColor                ";
        case 0x619: return "BackgroundColor                ";
        case 0x61A: return "DownloadAddress                ";
        case 0x61B: return "DownloadData                   ";
        case 0x61C: return "FBBlockColorExt                ";
        case 0x61D: return "FBBlockColorBackExt            ";
        case 0x61E: return "FBWriteMaskExt                 ";
        case 0x620: return "FogTable0                      ";
        case 0x621: return "FogTable1                      ";
        case 0x622: return "FogTable2                      ";
        case 0x623: return "FogTable3                      ";
        case 0x624: return "FogTable4                      ";
        case 0x625: return "FogTable5                      ";
        case 0x626: return "FogTable6                      ";
        case 0x627: return "FogTable7                      ";
        case 0x628: return "FogTable8                      ";
        case 0x629: return "FogTable9                      ";
        case 0x62A: return "FogTable10                     ";
        case 0x62B: return "FogTable11                     ";
        case 0x62C: return "FogTable12                     ";
        case 0x62D: return "FogTable13                     ";
        case 0x62E: return "FogTable14                     ";
        case 0x62F: return "FogTable15                     ";
        case 0x630: return "FogTable16                     ";
        case 0x631: return "FogTable17                     ";
        case 0x632: return "FogTable18                     ";
        case 0x633: return "FogTable19                     ";
        case 0x634: return "FogTable20                     ";
        case 0x635: return "FogTable21                     ";
        case 0x636: return "FogTable22                     ";
        case 0x637: return "FogTable23                     ";
        case 0x638: return "FogTable24                     ";
        case 0x639: return "FogTable25                     ";
        case 0x63A: return "FogTable26                     ";
        case 0x63B: return "FogTable27                     ";
        case 0x63C: return "FogTable28                     ";
        case 0x63D: return "FogTable29                     ";
        case 0x63E: return "FogTable30                     ";
        case 0x63F: return "FogTable31                     ";
        case 0x640: return "FogTable32                     ";
        case 0x641: return "FogTable33                     ";
        case 0x642: return "FogTable34                     ";
        case 0x643: return "FogTable35                     ";
        case 0x644: return "FogTable36                     ";
        case 0x645: return "FogTable37                     ";
        case 0x646: return "FogTable38                     ";
        case 0x647: return "FogTable39                     ";
        case 0x648: return "FogTable40                     ";
        case 0x649: return "FogTable41                     ";
        case 0x64A: return "FogTable42                     ";
        case 0x64B: return "FogTable43                     ";
        case 0x64C: return "FogTable44                     ";
        case 0x64D: return "FogTable45                     ";
        case 0x64E: return "FogTable46                     ";
        case 0x64F: return "FogTable47                     ";
        case 0x650: return "FogTable48                     ";
        case 0x651: return "FogTable49                     ";
        case 0x652: return "FogTable50                     ";
        case 0x653: return "FogTable51                     ";
        case 0x654: return "FogTable52                     ";
        case 0x655: return "FogTable53                     ";
        case 0x656: return "FogTable54                     ";
        case 0x657: return "FogTable55                     ";
        case 0x658: return "FogTable56                     ";
        case 0x659: return "FogTable57                     ";
        case 0x65A: return "FogTable58                     ";
        case 0x65B: return "FogTable59                     ";
        case 0x65C: return "FogTable60                     ";
        case 0x65D: return "FogTable61                     ";
        case 0x65E: return "FogTable62                     ";
        case 0x65F: return "FogTable63                     ";
        case 0x660: return "TextureCompositeMode           ";
        case 0x661: return "TextureCompositeColorMode0     ";
        case 0x662: return "TextureCompositeAlphaMode0     ";
        case 0x663: return "TextureCompositeColorMode1     ";
        case 0x664: return "TextureCompositeAlphaMode1     ";
        case 0x665: return "TextureCompositeFactor0        ";
        case 0x666: return "TextureCompositeFactor1        ";
        case 0x667: return "TextureIndexMode0              ";
        case 0x668: return "TextureIndexMode1              ";
        case 0x669: return "LodRange0                      ";
        case 0x66A: return "LodRange1                      ";
        case 0x66B: return "InvalidateCache                ";
        case 0x66C: return "SetLogicalTexturePage          ";
        case 0x66D: return "UpdateLogicalTextureInfo       ";
        case 0x66E: return "TouchLogicalPage               ";
        case 0x66F: return "LUTMode                        ";
        case 0x670: return "TextureCompositeColorMode0And  ";
        case 0x671: return "TextureCompositeColorMode0Or   ";
        case 0x672: return "TextureCompositeAlphaMode0And  ";
        case 0x673: return "TextureCompositeAlphaMode0Or   ";
        case 0x674: return "TextureCompositeColorMode1And  ";
        case 0x675: return "TextureCompositeColorMode1Or   ";
        case 0x676: return "TextureCompositeAlphaMode1And  ";
        case 0x677: return "TextureCompositeAlphaMode1Or   ";
        case 0x678: return "TextureIndexMode0And           ";
        case 0x679: return "TextureIndexMode0Or            ";
        case 0x67A: return "TextureIndexMode1And           ";
        case 0x67B: return "TextureIndexMode1Or            ";
        case 0x67C: return "StencilDataAnd                 ";
        case 0x680: return "TextureReadMode0               ";
        case 0x681: return "TextureReadMode1               ";
        case 0x685: return "TextureMapSize                 ";
        case 0x686: return "TextureCacheReplacementMode    ";
        case 0x68D: return "StencilDataOr                  ";
        case 0x690: return "HeadPhysicalPageAllocation0    ";
        case 0x691: return "HeadPhysicalPageAllocation1    ";
        case 0x692: return "HeadPhysicalPageAllocation2    ";
        case 0x693: return "HeadPhysicalPageAllocation3    ";
        case 0x694: return "TailPhysicalPageAllocation0    ";
        case 0x695: return "TailPhysicalPageAllocation1    ";
        case 0x696: return "TailPhysicalPageAllocation2    ";
        case 0x697: return "TailPhysicalPageAllocation3    ";
        case 0x698: return "PhysicalPageAllocationTableAddr";
        case 0x699: return "BasePageOfWorkingSet           ";
        case 0x69A: return "LogicalTexturePageTableAddr    ";
        case 0x69B: return "LogicalTexturePageTableLength  ";
        case 0x69C: return "BasePageOfWorkingSetHost       ";
        case 0x6A0: return "LBDestReadMode                 ";
        case 0x6A1: return "LBDestReadEnables              ";
        case 0x6A2: return "LBDestReadBufferAddr           ";
        case 0x6A3: return "LBDestReadBufferOffset         ";
        case 0x6A4: return "LBSourceReadMode               ";
        case 0x6A5: return "LBSourceReadBufferAddr         ";
        case 0x6A6: return "LBSourceReadBufferOffset       ";
        case 0x6A7: return "GIDMode                        ";
        case 0x6A8: return "LBWriteBufferAddr              ";
        case 0x6A9: return "LBWriteBufferOffset            ";
        case 0x6AA: return "LBClearDataL                   ";
        case 0x6AB: return "LBClearDataU                   ";
        case 0x6B0: return "LBDestReadModeAnd              ";
        case 0x6B1: return "LBDestReadModeOr               ";
        case 0x6B2: return "LBDestReadEnablesAnd           ";
        case 0x6B3: return "LBDestReadEnablesOr            ";
        case 0x6B4: return "LBSourceReadModeAnd            ";
        case 0x6B5: return "LBSourceReadModeOr             ";
        case 0x6B6: return "GIDModeAnd                     ";
        case 0x6B7: return "GIDModeOr                      ";
        case 0x6C0: return "RectanglePosition              ";
        case 0x6C1: return "GlyphPosition                  ";
        case 0x6C2: return "RenderPatchOffset              ";
        case 0x6C3: return "Config2D                       ";
        case 0x6C6: return "Packed8Pixels                  ";
        case 0x6C7: return "Packed16Pixels                 ";
        case 0x6C8: return "Render2D                       ";
        case 0x6C9: return "Render2DGlyph                  ";
        case 0x6CA: return "DownloadTarget                 ";
        case 0x6CB: return "DownloadGlyphWidth             ";
        case 0x6CC: return "GlyphData                      ";
        case 0x6CD: return "Packed4Pixels                  ";
        case 0x6CE: return "RLData                         ";
        case 0x6CF: return "RLCount                        ";
        case 0x6D0: return "SClkProfileMask0               ";
        case 0x6D1: return "SClkProfileMask1               ";
        case 0x6D2: return "SClkProfileCount0              ";
        case 0x6D3: return "SClkProfileCount1              ";
        case 0x6D4: return "KClkProfileMask0               ";
        case 0x6D5: return "KClkProfileMask1               ";
        case 0x6D6: return "KClkProfileMask2               ";
        case 0x6D7: return "KClkProfileMask3               ";
        case 0x6D8: return "KClkProfileCount0              ";
        case 0x6D9: return "KClkProfileCount1              ";
        case 0x6DA: return "KClkProfileCount2              ";
        case 0x6DB: return "KClkProfileCount3              ";
        case 0x6E0: return "IndexBaseAddress               ";
        case 0x6E1: return "VertexBaseAddress              ";
        case 0x6E2: return "IndexedTriangleList            ";
        case 0x6E3: return "IndexedTriangleFan             ";
        case 0x6E4: return "IndexedTriangleStrip           ";
        case 0x6E5: return "IndexedLineList                ";
        case 0x6E6: return "IndexedLineStrip               ";
        case 0x6E7: return "IndexedPointList               ";
        case 0x6E8: return "IndexedPolygon                 ";
        case 0x6E9: return "VertexTriangleList             ";
        case 0x6EA: return "VertexTriangleFan              ";
        case 0x6EB: return "VertexTriangleStrip            ";
        case 0x6EC: return "VertexLineList                 ";
        case 0x6ED: return "VertexLineStrip                ";
        case 0x6EE: return "VertexPointList                ";
        case 0x6EF: return "VertexPolygon                  ";
        case 0x6F0: return "DMAMemoryControl               ";
        case 0x6F1: return "VertexValid                    ";
        case 0x6F2: return "VertexFormat                   ";
        case 0x6F3: return "VertexControl                  ";
        case 0x6F4: return "RetainedRender                 ";
        case 0x6F5: return "IndexedVertex                  ";
        case 0x6F6: return "IndexedDoubleVertex            ";
        case 0x6F7: return "Vertex0                        ";
        case 0x6F8: return "Vertex1                        ";
        case 0x6F9: return "Vertex2                        ";
        case 0x6FA: return "VertexData0                    ";
        case 0x6FB: return "VertexData1                    ";
        case 0x6FC: return "VertexData2                    ";
        case 0x6FD: return "VertexData                     ";
        case 0x700: return "VertexTagList0                 ";
        case 0x701: return "VertexTagList1                 ";
        case 0x702: return "VertexTagList2                 ";
        case 0x703: return "VertexTagList3                 ";
        case 0x704: return "VertexTagList4                 ";
        case 0x705: return "VertexTagList5                 ";
        case 0x706: return "VertexTagList6                 ";
        case 0x707: return "VertexTagList7                 ";
        case 0x708: return "VertexTagList8                 ";
        case 0x709: return "VertexTagList9                 ";
        case 0x70A: return "VertexTagList10                ";
        case 0x70B: return "VertexTagList11                ";
        case 0x70C: return "VertexTagList12                ";
        case 0x70D: return "VertexTagList13                ";
        case 0x70E: return "VertexTagList14                ";
        case 0x70F: return "VertexTagList15                ";
        case 0x710: return "VertexTagList16                ";
        case 0x711: return "VertexTagList17                ";
        case 0x712: return "VertexTagList18                ";
        case 0x713: return "VertexTagList19                ";
        case 0x714: return "VertexTagList20                ";
        case 0x715: return "VertexTagList21                ";
        case 0x716: return "VertexTagList22                ";
        case 0x717: return "VertexTagList23                ";
        case 0x718: return "VertexTagList24                ";
        case 0x719: return "VertexTagList25                ";
        case 0x71A: return "VertexTagList26                ";
        case 0x71B: return "VertexTagList27                ";
        case 0x71C: return "VertexTagList28                ";
        case 0x71D: return "VertexTagList29                ";
        case 0x71E: return "VertexTagList30                ";
        case 0x71F: return "VertexTagList31                ";

        default: {
            static char str[] = "P3R3:Reserved_XXX                ";
            char        digit;

            digit = (char) ((tag & 0xF00) >> 8);
            str[14] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
            digit = (char) ((tag & 0xF0) >> 4);
            str[15] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
            digit = (char) ( tag & 0xF);
            str[16] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
        return str; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\ddraw.c ===
/******************************Module*Header**********************************\
*
*                           *************************
*                           * GDI/DDRAW SAMPLE CODE *
*                           *************************
*
* Module Name: ddraw.c
*
* Content: Provides interfaces back from the DDRAW .lib file into the main NT driver
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if WNT_DDRAW

// The code inside this WNT_DDRAW ifdef is code that interfaces between the DirectDraw
// core (as ported from Win 95) and the Win NT display driver.

/*
 *  vNTSyncWith2DDriver ()
 *    --------------------------
 *
 *      Sync DirectDraw with every other subsystem: 2D driver . We
 *      put it in a function to get at the correct data structures.
 */

VOID vNTSyncWith2DDriver(PPDEV ppdev)
{
    GLINT_DECL;
    SYNC_WITH_GLINT;
}

// if we're expecting to use the vblank interrupt but the adapter hasn't been allocated an 
// interrupt, we'll need to provide temporary storage for values that would otherwise have been
// stored within the interrupt block

ULONG gulOverlayEnabled;
ULONG gulVBLANKUpdateOverlay;
ULONG gulVBLANKUpdateOverlayWidth;
ULONG gulVBLANKUpdateOverlayHeight;    

/*
 *  bSetupOffscreenForDDraw ()
 *    --------------------------
 *
 *      This function enables and disables the Display Driver's off-screen video memory.
 *      This allows DirectDraw to take control of the off-screen memory and to
 *      create it's linear heap in the memory.
 *
 *      Note: only implemented for Permedia.
 */

BOOL bSetupOffscreenForDDraw(
BOOL             enableFlag,
PPDEV            ppdev,
volatile DWORD **VBlankAddress,
volatile DWORD **bOverlayEnabled,
volatile DWORD **VBLANKUpdateOverlay,
volatile DWORD **VBLANKUpdateOverlayWidth, 
volatile DWORD **VBLANKUpdateOverlayHeight)
{
    BOOL retVal = TRUE;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: in addr 0x%x", VBlankAddress));

    if (enableFlag)
    {
        if((ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
        {
            // disabling DDraw, reenabling 2D offscreeen
            vEnable2DOffscreenMemory(ppdev);
        }

        // Get pointer to interrupt command block

        pBlock = glintInfo->pInterruptCommandBlock;

        // Reset the interrupt flags

        if (INTERRUPTS_ENABLED && (pBlock->Control & DIRECTDRAW_VBLANK_ENABLED))
        {
            // Clear the flag to stop the interrupt routine setting the 
            // flag in the shared structure
            pBlock->Control &= ~DIRECTDRAW_VBLANK_ENABLED;

            // clear VBLANK flag or we'll get an immediate interrupt
            WRITE_GLINT_CTRL_REG(IntFlags,  INTR_CLEAR_VBLANK);

            // Re-instate the original flags
            WRITE_GLINT_CTRL_REG(IntEnable, ppdev->oldIntEnableFlags);
        }
    }
    else
    {
        // enabling DDraw, disabling 2D offscreen
        // We zap off-screen memory chunks on Permedia, only if there
        // aren't any OGL apps running.
        {
            // There aren't any OGL apps running, so grab all the
            // memory for DDraw
            if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
            {
                // DX managed linear heap - we don't need to do anything
                // NB. check against whether we have the capability to use the linear heap, rather than
                //     whether it's currently enabled as it's only enabled much later, in DrvNotify
                retVal = TRUE;
            }
            else
                retVal = bDisable2DOffscreenMemory(ppdev);

            if (retVal == TRUE)
            {
                // We return a pointer to a 'long' which DirectDraw can
                // poll to see if it is zero or not.
                if (VBlankAddress != NULL)
                {
                    DWORD   enableFlags;

                    *VBlankAddress = NULL;

                    if (INTERRUPTS_ENABLED)
                    {
                        // Get pointer to interrupt command block
                        pBlock = glintInfo->pInterruptCommandBlock;

                        // Indicate that we require the miniport to
                        // set a flag for us
                        pBlock->Control |= DIRECTDRAW_VBLANK_ENABLED;

                        // clear VBLANK flag or we'll get an immediate interrupt
                        WRITE_GLINT_CTRL_REG(IntFlags,  INTR_CLEAR_VBLANK);
  
                        // enable the VBLANK interrupt
                        READ_GLINT_CTRL_REG (IntEnable, enableFlags);
                        WRITE_GLINT_CTRL_REG(IntEnable, enableFlags | INTR_ENABLE_VBLANK);

                        // Save the old interrupt flags so that we can restore them
                        ppdev->oldIntEnableFlags = enableFlags;

                        // Set up pointers into the shared memory
                        *VBlankAddress = &pBlock->DDRAW_VBLANK;
                        *bOverlayEnabled = &pBlock->bOverlayEnabled;
                        *VBLANKUpdateOverlay = &pBlock->bVBLANKUpdateOverlay;
                        *VBLANKUpdateOverlayWidth = &pBlock->VBLANKUpdateOverlayWidth;
                        *VBLANKUpdateOverlayHeight = &pBlock->VBLANKUpdateOverlayHeight;
                    }
                    else
                    {
                        *bOverlayEnabled = &gulOverlayEnabled;
                        *VBLANKUpdateOverlay = &gulVBLANKUpdateOverlay;
                        *VBLANKUpdateOverlayWidth = &gulVBLANKUpdateOverlayWidth;
                        *VBLANKUpdateOverlayHeight = &gulVBLANKUpdateOverlayHeight;
                    }

                    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: configured ptr 0x%x", *VBlankAddress));
                }
            }
        }
    }

    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: exit %d", retVal));

    return (retVal);
}

/*
 *  GetChipInfoForDDraw ()
 *    ----------------------
 *
 *      A simple helper function to return chip information to DirectDraw
 */

VOID GetChipInfoForDDraw(
PPDEV    ppdev,
DWORD*   pdwChipID,
DWORD*   pdwChipRev,
DWORD*   pdwChipFamily,
DWORD*   pdwGammaRev)
{
    GLINT_DECL;
    
    DISPDBG((DBGLVL,"*** In GetChipInfoForDDraw"));
    DISPDBG((DBGLVL," Chip is PXRX Family"));

    *pdwChipFamily = PERMEDIA3_ID;
    *pdwChipID     = glintInfo->deviceInfo.DeviceId;
    *pdwChipRev    = glintInfo->deviceInfo.RevisionId;
    *pdwGammaRev   = glintInfo->deviceInfo.GammaRevId;
}

/*
 *  GetFBLBInfoForDDraw ()
 *    ----------------------
 *
 *      Return some basic framnebuffer/localbuffer info to DirectDraw.
 */

VOID GetFBLBInfoForDDraw(
PPDEV    ppdev, 
void   **fbPtr,            // Framebuffer pointer
void   **lbPtr,            // Localbuffer pointer
DWORD   *fbSizeInBytes,    // Size of framebuffer
DWORD   *lbSizeInBytes,    // Size of localbuffer
DWORD   *fbOffsetInBytes,  // Offset to 1st 'free' byte in framebuffer
BOOL    *bSDRAM)           // TRUE if SDRAM (i.e. no h/w write mask)
{
    GLINT_DECL;

    *fbPtr = ppdev->pjScreen;                            
    *lbPtr = NULL;                            // We don't know this one
    *fbSizeInBytes = ppdev->FrameBufferLength;
    *lbSizeInBytes = TEXTURE_MEMORY_SIZE;
    *fbOffsetInBytes = ppdev->heap.DDrawOffscreenStart * ppdev->cjPelSize;

    *bSDRAM = (GLINT_HW_WRITE_MASK == FALSE);

    DISPDBG((DBGLVL, "GetFBLBInfoForDDraw: offstart 0x%x, buf[1] 0x%lx, pelsz %d",
                            ppdev->heap.DDrawOffscreenStart, 
                            GLINT_BUFFER_OFFSET(1), 
                            ppdev->cjPelSize));
}


// DDSendDMAData
// Uses DMA to transfer one complete buffer of DDRAW data
// under NT5.
// Before initiating DMA transfer, a check is made to ensure
// that any previous DMA transfer has completed.
// Then the DMA is initiated and the routine returns, so that
// the DMA transfer proceeds in parallel with the processor's
// proceeding execution.

LONG DDSendDMAData(
PDEV*       ppdev,
ULONG       PhysAddr,
ULONG_PTR   VirtAddr,
LONG        nDataEntries)
{
    ULONG   frontIndex, nextIndex;
    volatile ULONG ulValue;

    GLINT_DECL ;

    // PhysAddr += DataOffset;
    // VirtAddr += DataOffset;

    DISPDBG((DBGLVL, "DMASendData: DMA at 0x%x for %d", PhysAddr, nDataEntries));

    ppdev->g_GlintBoardStatus &= ~GLINT_DMA_COMPLETE;

    if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT)
    {
        PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock;

        DISPDBG((DBGLVL, "Processing buffer at 0x%x for %d", PhysAddr, nDataEntries));
        DISPDBG((DBGLVL, "Adding buffer to Q"));
        frontIndex = pBlock->frontIndex;
        if ((nextIndex = frontIndex+1) == pBlock->endIndex)
            nextIndex = 0;

        // wait for a free queue entry. We should really do a backoff here.
        while (nextIndex == pBlock->backIndex);

        DISPDBG((DBGLVL, "Add to DMA Q backindex %d frontindex %d",frontIndex, pBlock->backIndex));

        // add the DMA address and count to the new entry.
        pBlock->dmaQueue[frontIndex].address = PhysAddr;
        pBlock->dmaQueue[frontIndex].count = nDataEntries;
        pBlock->frontIndex = nextIndex;

        // wakeup the interrupt handler using an error interrupt. To save on
        // interrupt processing, only do this if a DMA interrupt is not
        // pending.
        //
        //if (!pBlock->InterruptPending)
        {
            DISPDBG((DBGLVL, "Generating error interrupt"));
            WRITE_GLINT_CTRL_REG(ErrorFlags, 0x7);  // clear error flags
            READ_OUTPUT_FIFO(ulValue);              // generate interrupt
        }
    }
    else
    {
        WAIT_IMMEDIATE_DMA_COMPLETE;
        SET_DMA_ADDRESS(PhysAddr, VirtAddr) ;
        SET_DMA_COUNT(nDataEntries);
    }

    DISPDBG((DBGLVL,"DMA count=%d\n", nDataEntries )) ;
    
    return 1 ;
}

// Wrapper function used for requesting a DMA memory buffer 
// from NT for use by D3D. NT 5 only.

LONG DDGetFreeDMABuffer(
DWORD     *physAddr,
ULONG_PTR *virtAddr,
DWORD     *bufferSize)
{
    LONG BuffNum;
    QUERY_DMA_BUFFERS dmaBuffer;
    
    BuffNum = GetFreeDMABuffer(&dmaBuffer);

    if (BuffNum >= 0)
    {
        *physAddr = (DWORD)dmaBuffer.physAddr.LowPart;
        *virtAddr = (ULONG_PTR)dmaBuffer.virtAddr;
        *bufferSize = (DWORD)dmaBuffer.size;
    }
    else
    {
        // Failed to get a free DMA buffer
        *physAddr = 0;
        *virtAddr = 0;
        *bufferSize = 0;
    }
    return BuffNum;
}

// Frees the given DMA buffer.

VOID DDFreeDMABuffer(void* pPhysAddress)
{
    FreeDMABuffer(pPhysAddress);
    return;
}

LONG DDWaitDMAComplete(PDEV *ppdev)
{
    GLINT_DECL ;
    WAIT_DMA_COMPLETE;
    return 0;
}

#endif  WNT_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\debug.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* Content: Debug helper routines.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if DBG

//@@BEGIN_DDKSPLIT
#if 0

LONG gcFifo = 0;                // Number of currently free FIFO entries

BOOL gbCrtcCriticalSection = FALSE;
                                // Have we acquired the CRTC register
                                //   critical section?

// single-shot list output (checked in DebugPrint)
BOOL bPrintList = FALSE;

// single-shot memory viewer (checked in DebugPrint)
int bSetViewableScanline = 0;
int nViewableScanline = 0;

#define LARGE_LOOP_COUNT  10000000
  
/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataReady(
PDEV*   ppdev)
{
    ASSERTDD((IO_GP_STAT(ppdev) & HARDWARE_BUSY),
             "Not ready for data transfer.");
}

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataComplete(
PDEV*   ppdev)
{
    LONG i;

    // We loop because it may take a while for the hardware to finish
    // digesting all the data we transferred:

    for (i = LARGE_LOOP_COUNT; i > 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;
    }

    RIP("Data transfer not complete.");
}

/******************************Public*Routine******************************\
* VOID vOutFifoW
\**************************************************************************/

VOID vOutFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_PORT_USHORT(p, v);
}

/******************************Public*Routine******************************\
* VOID vOutFifoPseudoD
\**************************************************************************/

VOID vOutFifoPseudoD(
PDEV*   ppdev,
VOID*   p,
ULONG   v)
{
    ULONG ulMiscState;

    ASSERTDD(!(ppdev->flCaps & CAPS_MM_IO),
        "No pseudo 32-bit writes when using memory-mapped I/O");
    ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
        "We're trying to do 32bpp output while not in 32bpp mode");

    IO_GP_WAIT(ppdev);                  // Wait so we don't interfere with any
                                        //   pending commands waiting on the
                                        //   FIFO
    IO_READ_SEL(ppdev, 6);              // We'll be reading index 0xE
    IO_GP_WAIT(ppdev);                  // Wait until that's processed
    IO_RD_REG_DT(ppdev, ulMiscState);   // Read ulMiscState

    ASSERTDD((ulMiscState & 0x10) == 0,
            "Register select flag is out of sync");

    gcFifo -= 2;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    OUT_PSEUDO_DWORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoW
\**************************************************************************/

VOID vWriteFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_USHORT(p, (USHORT) v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoD
\**************************************************************************/

VOID vWriteFifoD(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_ULONG(p, v);
}

/******************************Public*Routine******************************\
* VOID vIoFifoWait
\**************************************************************************/

VOID vIoFifoWait(
PDEV*   ppdev,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 8), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
#ifdef _PPC_

        if( level == 8 )
            if( IO_GP_STAT(ppdev) & GP_ALL_EMPTY )
                return;         // all fifo slots are empty
            else;
        else
            if( !(IO_GP_STAT(ppdev) & (FIFO_1_EMPTY >> (level))) )
                return;         // There are 'level + 1' entries free

#else
        if (!(IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level))))
            return;         // There are 'level' entries free
#endif
    }

    RIP("vIoFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwFifoWait
\**************************************************************************/

VOID vNwFifoWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 13), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (level <= 8)
        {
            if (!(READ_REGISTER_USHORT(pjMmBase + CMD)
                                & (0x0080 >> (level - 1))))
                return;
        }
        else
        {
            if (!(READ_REGISTER_USHORT(pjMmBase + CMD)
                                & (0x8000 >> (level - 9))))
                return;
        }
    }

    RIP("vNwFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vDbgFakeWait
\**************************************************************************/

VOID vDbgFakeWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    gcFifo = level;
}

/******************************Public*Routine******************************\
* VOID vIoGpWait
\**************************************************************************/

VOID vIoGpWait(
PDEV*   ppdev)
{
    LONG    i;

    gcFifo = (ppdev->flCaps & CAPS_16_ENTRY_FIFO) ? 16 : 8;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("vIoGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwGpWait
\**************************************************************************/

VOID vNwGpWait(
PDEV*   ppdev,
BYTE*   pjMmBase)
{
    LONG    i;

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(READ_REGISTER_USHORT(pjMmBase + CMD) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("vNwGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vIoAllEmpty
\**************************************************************************/

VOID vIoAllEmpty(
PDEV*   ppdev)
{
    LONG    i;

    ASSERTDD(ppdev->flCaps & CAPS_16_ENTRY_FIFO,
             "Can't call ALL_EMPTY on chips with 8-deep FIFOs");

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (IO_GP_STAT(ppdev) & GP_ALL_EMPTY)   // Not implemented on 911/924s
            return;
    }

    RIP("ALL_EMPTY timeout -- The hardware is in a funky state.");
}

/******************************Public*Routines*****************************\
* UCHAR  jInp()     - INP()
* USHORT wInpW()    - INPW()
* VOID   vOutp()    - OUTP()
* VOID   vOutpW()   - OUTPW()
*
* Debug thunks for general I/O routines.  This is used primarily to verify
* that any code accessing the CRTC register has grabbed the CRTC critical
* section (necessary because with GCAPS_ASYNCMOVE, DrvMovePointer calls
* may happen at any time, and they need to access the CRTC register).
*
\**************************************************************************/

UCHAR jInp(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return(READ_PORT_UCHAR(pjIoBase + (p)));
}

USHORT wInpW(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return(READ_PORT_USHORT(pjIoBase + (p)));
}

VOID vOutp(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_UCHAR(pjIoBase + (p), (v));
    CP_EIEIO();
}

VOID vOutpW(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_USHORT(pjIoBase + (p), (v));
    CP_EIEIO();
}

/******************************Public*Routine******************************\
* VOID vAcquireCrtc()
* VOID vReleaseCrtc()
*
* Debug thunks for grabbing the CRTC register critical section.
*
\**************************************************************************/

VOID vAcquireCrtc(PDEV* ppdev)
{
    EngAcquireSemaphore(ppdev->csCrtc);

    if (gbCrtcCriticalSection)
        RIP("Had already acquired Critical Section");
    gbCrtcCriticalSection = TRUE;
}

VOID vReleaseCrtc(PDEV* ppdev)
{
    // 80x/805i/928 and 928PCI chips have a bug where if I/O registers
    // are left unlocked after accessing them, writes to memory with
    // similar addresses can cause writes to I/O registers.  The problem
    // registers are 0x40, 0x58, 0x59 and 0x5c.  We will simply always
    // leave the index set to an innocuous register (namely, the text
    // mode cursor start scan line):

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0xa);

    if (!gbCrtcCriticalSection)
        RIP("Hadn't yet acquired Critical Section");
    gbCrtcCriticalSection = FALSE;
    EngReleaseSemaphore(ppdev->csCrtc);
}

#if VERIFY_CHECKFLAGS
     void __CheckFlags(PDEV *ppdev, ULONG x)
    {
        ULONG lop, fbr, cFlags = ppdev->cFlags;
        GLINT_DECL;

        SYNC_WITH_GLINT;

        READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);
        READ_GLINT_FIFO_REG (__GlintTagFBReadMode, fbr);
        READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);

        ASSERTDD ((cFlags & cFlagFBReadDefault) == 0 || ((cFlags & cFlagFBReadDefault) && fbr == glintInfo->FBReadMode), "SCF: Bad check fbread cache flag");
        ASSERTDD ((cFlags & cFlagLogicalOpDisabled) == 0 || ((cFlags & cFlagLogicalOpDisabled) && (lop & 0x1) == 0x0), "SCF: Bad check logicop cache flag");
        ASSERTDD ((cFlags & cFlagConstantFBWrite) == 0 || ((cFlags & cFlagConstantFBWrite) && (lop & (1<<5))), "SCF: Bad check const fbwrite cache flag");
    }
#endif //VERIFY_CHECKFLAGS

#endif // if 0
//@@END_DDKSPLIT

////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntctxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntctxt.c
*
* Content: 
*
*     Context switching for GLINT. Used to create and swap contexts in and out.
*    The display driver has a context, the 3D extension has another 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "glntctxt.h"

DWORD readableRegistersP3[] = {
    __GlintTagStartXDom,                         // [0x000]
    __GlintTagdXDom,                             // [0x001]
    __GlintTagStartXSub,                         // [0x002]
    __GlintTagdXSub,                             // [0x003]
    __GlintTagStartY,                            // [0x004]
    __GlintTagdY,                                // [0x005]
    __GlintTagCount,                             // [0x006]
    __GlintTagPointTable0,                       // [0x010]
    __GlintTagPointTable1,                       // [0x011]
    __GlintTagPointTable2,                       // [0x012]
    __GlintTagPointTable3,                       // [0x013]
    __GlintTagRasterizerMode,                    // [0x014]
    __GlintTagYLimits,                           // [0x015]
    //__GlintTagScanlineOwnership,               // [0x016]
    __GlintTagPixelSize,                         // [0x018]
    //__GlintTagFastBlockLimits,                 // [0x026]
    __GlintTagScissorMode,                       // [0x030]
    __GlintTagScissorMinXY,                      // [0x031]
    __GlintTagScissorMaxXY,                      // [0x032]
    //__GlintTagScreenSize,                      // [0x033]
    __GlintTagAreaStippleMode,                   // [0x034]
    __GlintTagLineStippleMode,                   // [0x035]
    __GlintTagLoadLineStippleCounters,           // [0x036]
    __GlintTagWindowOrigin,                      // [0x039]
    __GlintTagAreaStipplePattern0,               // [0x040]
    __GlintTagAreaStipplePattern1,               // [0x041]
    __GlintTagAreaStipplePattern2,               // [0x042]
    __GlintTagAreaStipplePattern3,               // [0x043]
    __GlintTagAreaStipplePattern4,               // [0x044]
    __GlintTagAreaStipplePattern5,               // [0x045]
    __GlintTagAreaStipplePattern6,               // [0x046]
    __GlintTagAreaStipplePattern7,               // [0x047]
    __GlintTagAreaStipplePattern8,               // [0x048]
    __GlintTagAreaStipplePattern9,               // [0x049]
    __GlintTagAreaStipplePattern10,              // [0x04A]
    __GlintTagAreaStipplePattern11,              // [0x04B]
    __GlintTagAreaStipplePattern12,              // [0x04C]
    __GlintTagAreaStipplePattern13,              // [0x04D]
    __GlintTagAreaStipplePattern14,              // [0x04E]
    __GlintTagAreaStipplePattern15,              // [0x04F]
    __GlintTagAreaStipplePattern16,              // [0x050]
    __GlintTagAreaStipplePattern17,              // [0x051]
    __GlintTagAreaStipplePattern18,              // [0x052]
    __GlintTagAreaStipplePattern19,              // [0x053]
    __GlintTagAreaStipplePattern20,              // [0x054]
    __GlintTagAreaStipplePattern21,              // [0x055]
    __GlintTagAreaStipplePattern22,              // [0x056]
    __GlintTagAreaStipplePattern23,              // [0x057]
    __GlintTagAreaStipplePattern24,              // [0x058]
    __GlintTagAreaStipplePattern25,              // [0x059]
    __GlintTagAreaStipplePattern26,              // [0x05A]
    __GlintTagAreaStipplePattern27,              // [0x05B]
    __GlintTagAreaStipplePattern28,              // [0x05C]
    __GlintTagAreaStipplePattern29,              // [0x05D]
    __GlintTagAreaStipplePattern30,              // [0x05E]
    __GlintTagAreaStipplePattern31,              // [0x05F]
    __PXRXTagTextureCoordMode,                   // [0x070]
    __GlintTagSStart,                            // [0x071]
    __GlintTagdSdx,                              // [0x072]
    __GlintTagdSdyDom,                           // [0x073]
    __GlintTagTStart,                            // [0x074]
    __GlintTagdTdx,                              // [0x075]
    __GlintTagdTdyDom,                           // [0x076]
    __GlintTagQStart,                            // [0x077]
    __GlintTagdQdx,                              // [0x078]
    __GlintTagdQdyDom,                           // [0x079]
    __GlintTagLOD,                               // [0x07A]
    __GlintTagdSdy,                              // [0x07B]
    __GlintTagdTdy,                              // [0x07C]
    __GlintTagdQdy,                              // [0x07D]
    __PXRXTagS1Start,                            // [0x080]
    __PXRXTagdS1dx,                              // [0x081]
    __PXRXTagdS1dyDom,                           // [0x082]
    __PXRXTagT1Start,                            // [0x083]
    __PXRXTagdT1dx,                              // [0x084]
    __PXRXTagdT1dyDom,                           // [0x085]
    __PXRXTagQ1Start,                            // [0x086]
    __PXRXTagdQ1dx,                              // [0x087]
    __PXRXTagdQ1dyDom,                           // [0x088]
    __GlintTagLOD1,                              // [0x089]
    __GlintTagTextureLODBiasS,                   // [0x08A]
    __GlintTagTextureLODBiasT,                   // [0x08B]
    __GlintTagTextureReadMode,                   // [0x090]
    __GlintTagTextureFormat,                     // [0x091]
    __GlintTagTextureCacheControl,               // [0x092]
    __GlintTagBorderColor,                       // [0x095]
    //__GlintTagLUTIndex,                        // [0x098]
    //__GlintTagLUTData,                         // [0x099]
    //__GlintTagLUTAddress,                      // [0x09A]
    //__GlintTagLUTTransfer,                     // [0x09B]
    __GlintTagTextureFilterMode,                 // [0x09C]
    __GlintTagTextureChromaUpper,                // [0x09D]
    __GlintTagTextureChromaLower,                // [0x09E]
    __GlintTagBorderColor1,                      // [0x09F]
    __GlintTagTextureBaseAddress,                // [0x0A0]
    __GlintTagTextureBaseAddressLR,              // [0x0A1]
    __GlintTagTextureBaseAddress2,               // [0x0A2]
    __GlintTagTextureBaseAddress3,               // [0x0A3]
    __GlintTagTextureBaseAddress4,               // [0x0A4]
    __GlintTagTextureBaseAddress5,               // [0x0A5]
    __GlintTagTextureBaseAddress6,               // [0x0A6]
    __GlintTagTextureBaseAddress7,               // [0x0A7]
    __GlintTagTextureBaseAddress8,               // [0x0A8]
    __GlintTagTextureBaseAddress9,               // [0x0A9]
    __GlintTagTextureBaseAddress10,              // [0x0AA]
    __GlintTagTextureBaseAddress11,              // [0x0AB]
    __GlintTagTextureBaseAddress12,              // [0x0AC]
    __GlintTagTextureBaseAddress13,              // [0x0AD]
    __GlintTagTextureBaseAddress14,              // [0x0AE]
    __GlintTagTextureBaseAddress15,              // [0x0AF]
    __PXRXTagTextureMapWidth0,                   // [0x0B0]
    __PXRXTagTextureMapWidth1,                   // [0x0B1]
    __PXRXTagTextureMapWidth2,                   // [0x0B2]
    __PXRXTagTextureMapWidth3,                   // [0x0B3]
    __PXRXTagTextureMapWidth4,                   // [0x0B4]
    __PXRXTagTextureMapWidth5,                   // [0x0B5]
    __PXRXTagTextureMapWidth6,                   // [0x0B6]
    __PXRXTagTextureMapWidth7,                   // [0x0B7]
    __PXRXTagTextureMapWidth8,                   // [0x0B8]
    __PXRXTagTextureMapWidth9,                   // [0x0B9]
    __PXRXTagTextureMapWidth10,                  // [0x0BA]
    __PXRXTagTextureMapWidth11,                  // [0x0BB]
    __PXRXTagTextureMapWidth12,                  // [0x0BC]
    __PXRXTagTextureMapWidth13,                  // [0x0BD]
    __PXRXTagTextureMapWidth14,                  // [0x0BE]
    __PXRXTagTextureMapWidth15,                  // [0x0BF]
    __PXRXTagTextureChromaUpper1,                // [0x0C0]
    __PXRXTagTextureChromaLower1,                // [0x0C1]
    __PXRXTagTextureApplicationMode,             // [0x0D0]
    __GlintTagTextureEnvColor,                   // [0x0D1]
    __GlintTagFogMode,                           // [0x0D2]
    __GlintTagFogColor,                          // [0x0D3]
    __GlintTagFStart,                            // [0x0D4]
    __GlintTagdFdx,                              // [0x0D5]
    __GlintTagdFdyDom,                           // [0x0D6]
    __GlintTagZFogBias,                          // [0x0D7]
    __GlintTagRStart,                            // [0x0F0]
    __GlintTagdRdx,                              // [0x0F1]
    __GlintTagdRdyDom,                           // [0x0F2]
    __GlintTagGStart,                            // [0x0F3]
    __GlintTagdGdx,                              // [0x0F4]
    __GlintTagdGdyDom,                           // [0x0F5]
    __GlintTagBStart,                            // [0x0F6]
    __GlintTagdBdx,                              // [0x0F7]
    __GlintTagdBdyDom,                           // [0x0F8]
    __GlintTagAStart,                            // [0x0F9]
    __GlintTagdAdx,                              // [0x0FA]
    __GlintTagdAdyDom,                           // [0x0FB]
    __GlintTagColorDDAMode,                      // [0x0FC]
    __GlintTagConstantColor,                     // [0x0FD]
    __GlintTagColor,                             // [0x0FE]
    __GlintTagAlphaTestMode,                     // [0x100]
    __GlintTagAntialiasMode,                     // [0x101]
    __GlintTagDitherMode,                        // [0x103]
    __GlintTagFBSoftwareWriteMask,               // [0x104]
    __GlintTagLogicalOpMode,                     // [0x105]
    __GlintTagRouterMode,                        // [0x108]
    __GlintTagLBReadFormat,                      // [0x111]
    __GlintTagLBSourceOffset,                    // [0x112]
    __GlintTagLBWriteMode,                       // [0x118]
    __GlintTagLBWriteFormat,                     // [0x119]
    //__GlintTagTextureDownloadOffset,           // [0x11E]
    __GlintTagWindow,                            // [0x130]
    __GlintTagStencilMode,                       // [0x131]
    __GlintTagStencilData,                       // [0x132]
    __GlintTagStencil,                           // [0x133]
    __GlintTagDepthMode,                         // [0x134]
    __GlintTagDepth,                             // [0x135]
    __GlintTagZStartU,                           // [0x136]
    __GlintTagZStartL,                           // [0x137]
    __GlintTagdZdxU,                             // [0x138]
    __GlintTagdZdxL,                             // [0x139]
    __GlintTagdZdyDomU,                          // [0x13A]
    __GlintTagdZdyDomL,                          // [0x13B]
    __GlintTagFastClearDepth,                    // [0x13C]
    __GlintTagFBWriteMode,                       // [0x157]
    __GlintTagFBHardwareWriteMask,               // [0x158]
    __GlintTagFBBlockColor,                      // [0x159]
    //__GlintTagFilterMode,                      // [0x180]
    __GlintTagStatisticMode,                     // [0x181]
    __GlintTagMinRegion,                         // [0x182]
    __GlintTagMaxRegion,                         // [0x183]
    __GlintTagRLEMask,                           // [0x189]
    __GlintTagFBBlockColorBackU,                 // [0x18B]
    __GlintTagFBBlockColorBackL,                 // [0x18C]
    //__GlintTagFBBlockColorU,                   // [0x18D]
    //__GlintTagFBBlockColorL,                   // [0x18E]
    __GlintTagKsRStart,                          // [0x190]
    __GlintTagdKsRdx,                            // [0x191]
    __GlintTagdKsRdyDom,                         // [0x192]
    __GlintTagKsGStart,                          // [0x193]
    __GlintTagdKsGdx,                            // [0x194]
    __GlintTagdKsGdyDom,                         // [0x195]
    __GlintTagKsBStart,                          // [0x196]
    __GlintTagdKsBdx,                            // [0x197]
    __GlintTagdKsBdyDom,                         // [0x198]
    __GlintTagKdRStart,                          // [0x1A0]
    __GlintTagdKdRdx,                            // [0x1A1]
    __GlintTagdKdRdyDom,                         // [0x1A2]
    __GlintTagKdGStart,                          // [0x1A3]
    __GlintTagdKdGdx,                            // [0x1A4]
    __GlintTagdKdGdyDom,                         // [0x1A5]
    __GlintTagKdBStart,                          // [0x1A6]
    __GlintTagdKdBdx,                            // [0x1A7]
    __GlintTagdKdBdyDom,                         // [0x1A8]
    //LUT0,                                      // [0x1D0]
    //LUT1,                                      // [0x1D1]
    //LUT2,                                      // [0x1D2]
    //LUT3,                                      // [0x1D3]
    //LUT4,                                      // [0x1D4]
    //LUT5,                                      // [0x1D5]
    //LUT6,                                      // [0x1D6]
    //LUT7,                                      // [0x1D7]
    //LUT8,                                      // [0x1D8]
    //LUT9,                                      // [0x1D9]
    //LUT10,                                     // [0x1DA]
    //LUT11,                                     // [0x1DB]
    //LUT12,                                     // [0x1DC]
    //LUT13,                                     // [0x1DD]
    //LUT14,                                     // [0x1DE]
    //LUT15,                                     // [0x1DF]
    __PXRXTagYUVMode,                            // [0x1E0]
    __PXRXTagChromaUpper,                        // [0x1E1]
    __PXRXTagChromaLower,                        // [0x1E2]
    __GlintTagChromaTestMode,                    // [0x1E3]
    __PXRXTagV0FloatS1,                          // [0x200]
    __PXRXTagV0FloatT1,                          // [0x201]
    __PXRXTagV0FloatQ1,                          // [0x202]
    __PXRXTagV0FloatKsR,                         // [0x20A]
    __PXRXTagV0FloatKsG,                         // [0x20B]
    __PXRXTagV0FloatKsB,                         // [0x20C]
    __PXRXTagV0FloatKdR,                         // [0x20D]
    __PXRXTagV0FloatKdG,                         // [0x20E]
    __PXRXTagV0FloatKdB,                         // [0x20F]
    __PXRXTagV1FloatS1,                          // [0x210]
    __PXRXTagV1FloatT1,                          // [0x211]
    __PXRXTagV1FloatQ1,                          // [0x212]
    __PXRXTagV1FloatKsR,                         // [0x21A]
    __PXRXTagV1FloatKsG,                         // [0x21B]
    __PXRXTagV1FloatKsB,                         // [0x21C]
    __PXRXTagV1FloatKdR,                         // [0x21D]
    __PXRXTagV1FloatKdG,                         // [0x21E]
    __PXRXTagV1FloatKdB,                         // [0x21F]
    __PXRXTagV2FloatS1,                          // [0x220]
    __PXRXTagV2FloatT1,                          // [0x221]
    __PXRXTagV2FloatQ1,                          // [0x222]
    __PXRXTagV2FloatKsR,                         // [0x22A]
    __PXRXTagV2FloatKsG,                         // [0x22B]
    __PXRXTagV2FloatKsB,                         // [0x22C]
    __PXRXTagV2FloatKdR,                         // [0x22D]
    __PXRXTagV2FloatKdG,                         // [0x22E]
    __PXRXTagV2FloatKdB,                         // [0x22F]
    __PXRXTagV0FloatS,                           // [0x230]
    __PXRXTagV0FloatT,                           // [0x231]
    __PXRXTagV0FloatQ,                           // [0x232]
    __PXRXTagV0FloatR,                           // [0x235]
    __PXRXTagV0FloatG,                           // [0x236]
    __PXRXTagV0FloatB,                           // [0x237]
    __PXRXTagV0FloatA,                           // [0x238]
    __PXRXTagV0FloatF,                           // [0x239]
    __PXRXTagV0FloatX,                           // [0x23A]
    __PXRXTagV0FloatY,                           // [0x23B]
    __PXRXTagV0FloatZ,                           // [0x23C]
    __PXRXTagV0FloatW,                           // [0x23D]
    __PXRXTagV0FloatPackedColour,                // [0x23E]
    __PXRXTagV0FloatPackedSpecularFog,           // [0x23F]
    __RXRXTagV1FloatS,                           // [0x240]
    __RXRXTagV1FloatT,                           // [0x241]
    __RXRXTagV1FloatQ,                           // [0x242]
    __RXRXTagV1FloatR,                           // [0x245]
    __RXRXTagV1FloatG,                           // [0x246]
    __RXRXTagV1FloatB,                           // [0x247]
    __RXRXTagV1FloatA,                           // [0x248]
    __RXRXTagV1FloatF,                           // [0x249]
    __RXRXTagV1FloatX,                           // [0x24A]
    __RXRXTagV1FloatY,                           // [0x24B]
    __RXRXTagV1FloatZ,                           // [0x24C]
    __RXRXTagV1FloatW,                           // [0x24D]
    __RXRXTagV1FloatPackedColour,                // [0x24E]
    __RXRXTagV1FloatPackedSpecularFog,           // [0x24F]
    __RXRXTagV2FloatS,                           // [0x250]
    __RXRXTagV2FloatT,                           // [0x251]
    __RXRXTagV2FloatQ,                           // [0x252]
    __RXRXTagV2FloatR,                           // [0x255]
    __RXRXTagV2FloatG,                           // [0x256]
    __RXRXTagV2FloatB,                           // [0x257]
    __RXRXTagV2FloatA,                           // [0x258]
    __RXRXTagV2FloatF,                           // [0x259]
    __RXRXTagV2FloatX,                           // [0x25A]
    __RXRXTagV2FloatY,                           // [0x25B]
    __RXRXTagV2FloatZ,                           // [0x25C]
    __RXRXTagV2FloatW,                           // [0x25D]
    __RXRXTagV2FloatPackedColour,                // [0x25E]
    __RXRXTagV2FloatPackedSpecularFog,           // [0x25F]
    __DeltaTagDeltaMode,                         // [0x260]
    __DeltaTagProvokingVertex,                   // [0x267]
    __DeltaTagTextureLODScale,                   // [0x268]
    __DeltaTagTextureLODScale1,                  // [0x269]
    __DeltaTagDeltaControl,                      // [0x26A]
    __DeltaTagProvokingVertexMask,               // [0x26B]
    //__DeltaTagBroadcastMask,                   // [0x26F]
    //__DeltaTagDeltaTexture01,                  // [0x28B]
    //__DeltaTagDeltaTexture11,                  // [0x28C]
    //__DeltaTagDeltaTexture21,                  // [0x28D]
    //__DeltaTagDeltaTexture31,                  // [0x28E]
    __DeltaTagXBias,                             // [0x290]
    __DeltaTagYBias,                             // [0x291]
    __DeltaTagZBias,                             // [0x29F]
    //__GlintTagDMAAddr,                         // [0x530]
    //__GlintTagDMACount,                        // [0x531]
    //__GlintTagCommandInterrupt,                // [0x532]
    //__GlintTagDMARectangleRead,                // [0x535]
    //__GlintTagDMARectangleReadAddress,         // [0x536]
    //__GlintTagDMARectangleReadLinePitch,       // [0x537]
    //__GlintTagDMARectangleReadTarget,          // [0x538]
    //__GlintTagDMARectangleWrite,               // [0x539]
    //__GlintTagDMARectangleWriteAddress,        // [0x53A]
    //__GlintTagDMARectangleWriteLinePitch,      // [0x53B]
    //__GlintTagDMAOutputAddress,                // [0x53C]
    //__GlintTagDMAOutputCount,                  // [0x53D]
    //__GlintTagDMAFeedback,                     // [0x542]
    __GlintTagFBDestReadBufferAddr0,             // [0x5D0]
    __GlintTagFBDestReadBufferAddr1,             // [0x5D1]
    __GlintTagFBDestReadBufferAddr2,             // [0x5D2]
    __GlintTagFBDestReadBufferAddr3,             // [0x5D3]
    __GlintTagFBDestReadBufferOffset0,           // [0x5D4]
    __GlintTagFBDestReadBufferOffset1,           // [0x5D5]
    __GlintTagFBDestReadBufferOffset2,           // [0x5D6]
    __GlintTagFBDestReadBufferOffset3,           // [0x5D7]
    __GlintTagFBDestReadBufferWidth0,            // [0x5D8]
    __GlintTagFBDestReadBufferWidth1,            // [0x5D9]
    __GlintTagFBDestReadBufferWidth2,            // [0x5DA]
    __GlintTagFBDestReadBufferWidth3,            // [0x5DB]
    __GlintTagFBDestReadMode,                    // [0x5DC]
    __GlintTagFBDestReadEnables,                 // [0x5DD]
    __GlintTagFBSourceReadMode,                  // [0x5E0]
    __GlintTagFBSourceReadBufferAddr,            // [0x5E1]
    __GlintTagFBSourceReadBufferOffset,          // [0x5E2]
    __GlintTagFBSourceReadBufferWidth,           // [0x5E3]
    __GlintTagPCIWindowBase0,                    // [0x5E8]
    __GlintTagPCIWindowBase1,                    // [0x5E9]
    __GlintTagPCIWindowBase2,                    // [0x5EA]
    __GlintTagPCIWindowBase3,                    // [0x5EB]
    __GlintTagPCIWindowBase4,                    // [0x5EC]
    __GlintTagPCIWindowBase5,                    // [0x5ED]
    __GlintTagPCIWindowBase6,                    // [0x5EE]
    __GlintTagPCIWindowBase7,                    // [0x5EF]
    __GlintTagAlphaSourceColor,                  // [0x5F0]
    __GlintTagAlphaDestColor,                    // [0x5F1]
    __GlintTagChromaPassColor,                   // [0x5F2]
    __GlintTagChromaFailColor,                   // [0x5F3]
    __GlintTagAlphaBlendColorMode,               // [0x5F4]
    __GlintTagAlphaBlendAlphaMode,               // [0x5F5]
    //__GlintTagConstantColorDDA,                // [0x5F6]
    //__GlintTagD3DAlphaTestMode,                // [0x5F8]
    __GlintTagFBWriteBufferAddr0,                // [0x600]
    __GlintTagFBWriteBufferAddr1,                // [0x601]
    __GlintTagFBWriteBufferAddr2,                // [0x602]
    __GlintTagFBWriteBufferAddr3,                // [0x603]
    __GlintTagFBWriteBufferOffset0,              // [0x604]
    __GlintTagFBWriteBufferOffset1,              // [0x605]
    __GlintTagFBWriteBufferOffset2,              // [0x606]
    __GlintTagFBWriteBufferOffset3,              // [0x607]
    __GlintTagFBWriteBufferWidth0,               // [0x608]
    __GlintTagFBWriteBufferWidth1,               // [0x609]
    __GlintTagFBWriteBufferWidth2,               // [0x60A]
    __GlintTagFBWriteBufferWidth3,               // [0x60B]
    //__GlintTagFBBlockColor0,                   // [0x60C]
    //__GlintTagFBBlockColor1,                   // [0x60D]
    //__GlintTagFBBlockColor2,                   // [0x60E]
    //__GlintTagFBBlockColor3,                   // [0x60F]
    //__GlintTagFBBlockColorBack0,               // [0x610]
    //__GlintTagFBBlockColorBack1,               // [0x611]
    //__GlintTagFBBlockColorBack2,               // [0x612]
    //__GlintTagFBBlockColorBack3,               // [0x613]
    __GlintTagFBBlockColorBack,                  // [0x614]
    //__GlintTagSizeOfFramebuffer,               // [0x615]
    //__GlintTagVTGAddress,                      // [0x616]
    //__GlintTagVTGData,                         // [0x617]
    //__GlintTagForegroundColor,                 // [0x618]
    //__GlintTagBackgroundColor,                 // [0x619]
    //__GlintTagDownloadAddress,                 // [0x61A]
    //__GlintTagFBBlockColorExt,                 // [0x61C]
    //__GlintTagFBBlockColorBackExt,             // [0x61D]
    //__GlintTagFBWriteMaskExt,                  // [0x61E]
//@@BEGIN_DDKSPLIT
#if 0
    FogTable0,                         // [0x620]
    FogTable1,                         // [0x621]
    FogTable2,                         // [0x622]
    FogTable3,                         // [0x623]
    FogTable4,                         // [0x624]
    FogTable5,                         // [0x625]
    FogTable6,                         // [0x626]
    FogTable7,                         // [0x627]
    FogTable8,                         // [0x628]
    FogTable9,                         // [0x629]
    FogTable10,                        // [0x62A]
    FogTable11                     // [0x62B]
    FogTable12,                        // [0x62C]
    FogTable13,                        // [0x62D]
    FogTable14,                        // [0x62E]
    FogTable15,                        // [0x62F]
    FogTable16,                        // [0x630]
    FogTable17,                        // [0x631]
    FogTable18,                        // [0x632]
    FogTable19,                        // [0x633]
    FogTable20,                        // [0x634]
    FogTable21,                        // [0x635]
    FogTable22,                        // [0x636]
    FogTable23,                        // [0x637]
    FogTable24,                        // [0x638]
    FogTable25,                        // [0x639]
    FogTable26,                        // [0x63A]
    FogTable27,                        // [0x63B]
    FogTable28,                        // [0x63C]
    FogTable29,                        // [0x63D]
    FogTable30,                        // [0x63E]
    FogTable31,                        // [0x63F]
    FogTable32,                        // [0x640]
    FogTable33,                        // [0x641]
    FogTable34,                        // [0x642]
    FogTable35,                        // [0x643]
    FogTable36,                        // [0x644]
    FogTable37,                        // [0x645]
    FogTable38,                        // [0x646]
    FogTable39,                        // [0x647]
    FogTable40,                        // [0x648]
    FogTable41,                        // [0x649]
    FogTable42,                        // [0x64A]
    FogTable43,                        // [0x64B]
    FogTable44,                        // [0x64C]
    FogTable45,                        // [0x64D]
    FogTable46,                        // [0x64E]
    FogTable47,                        // [0x64F]
    FogTable48,                        // [0x650]
    FogTable49,                        // [0x651]
    FogTable50,                        // [0x652]
    FogTable51,                        // [0x653]
    FogTable52,                        // [0x654]
    FogTable53,                        // [0x655]
    FogTable54,                        // [0x656]
    FogTable55,                        // [0x657]
    FogTable56,                        // [0x658]
    FogTable57,                        // [0x659]
    FogTable58,                        // [0x65A]
    FogTable59,                        // [0x65B]
    FogTable60,                        // [0x65C]
    FogTable61,                        // [0x65D]
    FogTable62,                        // [0x65E]
    FogTable63,                        // [0x65F]
#endif
//@@END_DDKSPLIT
    __GlintTagTextureCompositeMode,    // [0x660]
    __GlintTagTextureCompositeColorMode0,        // [0x661]
    __GlintTagTextureCompositeAlphaMode0,        // [0x662]
    __GlintTagTextureCompositeColorMode1,        // [0x663]
    __GlintTagTextureCompositeAlphaMode1,        // [0x664]
    __GlintTagTextureCompositeFactor0,           // [0x665]
    __GlintTagTextureCompositeFactor1,           // [0x666]
    __GlintTagTextureIndexMode0,                 // [0x667]
    __GlintTagTextureIndexMode1,                 // [0x668]
    __GlintTagLodRange0,                         // [0x669]
    __GlintTagLodRange1,                         // [0x66A]
    //__GlintTagSetLogicalTexturePage,           // [0x66C]
    __GlintTagLUTMode,                           // [0x66F]
    __GlintTagTextureReadMode0,                  // [0x680]
    __GlintTagTextureReadMode1,                  // [0x681]
    __GlintTagTextureMapSize,                    // [0x685]
    //HeadPhysicalPageAllocation0,     // [0x690]
    //HeadPhysicalPageAllocation1,     // [0x691]
    //HeadPhysicalPageAllocation2,     // [0x692]
    //HeadPhysicalPageAllocation3,     // [0x693]
    //TailPhysicalPageAllocation0,     // [0x694]
    //TailPhysicalPageAllocation1,     // [0x695]
    //TailPhysicalPageAllocation2,     // [0x696]
    //TailPhysicalPageAllocation3,     // [0x697]
    //PhysicalPageAllocationTableAddr, // [0x698]
    //BasePageOfWorkingSet,            // [0x699]
    //LogicalTexturePageTableAddr,     // [0x69A]
    //LogicalTexturePageTableLength,   // [0x69B]
    __GlintTagLBDestReadMode,                    // [0x6A0]
    __GlintTagLBDestReadEnables,                 // [0x6A1]
    __GlintTagLBDestReadBufferAddr,              // [0x6A2]
    __GlintTagLBDestReadBufferOffset,            // [0x6A3]
    __GlintTagLBSourceReadMode,                  // [0x6A4]
    __GlintTagLBSourceReadBufferAddr,            // [0x6A5]
    __GlintTagLBSourceReadBufferOffset,          // [0x6A6]
    __GlintTagGIDMode,                           // [0x6A7]
    __GlintTagLBWriteBufferAddr,                 // [0x6A8]
    __GlintTagLBWriteBufferOffset,               // [0x6A9]
    __GlintTagLBClearDataL,                      // [0x6AA]
    __GlintTagLBClearDataU,                      // [0x6AB]
    __GlintTagRectanglePosition,                 // [0x6C0]
    //__GlintTagGlyphPosition,                   // [0x6C1]
    __GlintTagRenderPatchOffset,                 // [0x6C2]
    //__GlintTagConfig2D,                        // [0x6C3]
    //__GlintTagRender2D,                        // [0x6C8]
    //__GlintTagRender2DGlyph,                   // [0x6C9]
    __GlintTagDownloadTarget,                    // [0x6CA]
    //__GlintTagDownloadGlyphWidth,              // [0x6CB]
    //__GlintTagGlyphData,                       // [0x6CC]
    //__GlintTagPacked4Pixels,                   // [0x6CD]
    //__GlintTagRLData,                          // [0x6CE]
    //__GlintTagRLCount,                         // [0x6CF]
    //__GlintTagKClkProfileMask0,                // [0x6D4]
    //__GlintTagKClkProfileMask1,                // [0x6D5]
    //__GlintTagKClkProfileMask2,                // [0x6D6]
    //__GlintTagKClkProfileMask3,                // [0x6D7]
    //__GlintTagKClkProfileCount0,               // [0x6D8]
    //__GlintTagKClkProfileCount1,               // [0x6D9]
    //__GlintTagKClkProfileCount2,               // [0x6DA]
    //__GlintTagKClkProfileCount3,               // [0x6DB]
};

#define N_READABLE_TAGSP3                                         \
    (sizeof(readableRegistersP3) / sizeof(readableRegistersP3[0]))

//@@BEGIN_DDKSPLIT
//
// the status flags are used to indicate whether DMA has completed, the
// GLINT is synced etc. This has to be global for each board. The whole
// idea is that we can do a quick check without having to read a chip
// register. So for speed of access we'll make it visible everywhere
//
// !!! azn - we had to reintroduce this g_CC in order to fix the 
//           regular recurrence of bug #158713 (pxrxFifoUpload stall)
//           we have to chk later how to rewrite it
//@@END_DDKSPLIT

/******************************************************************************
 * GlintAllocateNewContext:
 *
 *  Allocate a new context. If all registers are to be saved in the context 
 *  then pTag is passed as null. The priv field is an opaque handle which the 
 *  caller passes in. It is saved as part of the context and used to disable 
 *  any context which causes the chip to lockup.
 *
 ******************************************************************************/
LONG GlintAllocateNewContext(
PPDEV   ppdev,
DWORD   *pTag,
LONG    ntags,
ULONG   NumSubBuffers,
PVOID   priv,
ContextType ctxtType)
{
    GlintCtxtTable      *pCtxtTable, *pNewCtxtTable;
    GlintCtxtRec        **ppEntry;
    GlintCtxtRec        *pEntry;
    CtxtData            *pData;
    LONG                nEntries, size, ctxtId;
    ULONG               *pul;
    GLINT_DECL;

    // first time round allocate the context table of pointers. We will
    // grow this table as required.
    if (ppdev->pGContextTable == NULL)
    {
        DISPDBG((DBGLVL, "creating context table"));
        size = sizeof(GlintCtxtTable);
        pCtxtTable = (GlintCtxtTable*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                                   size, 
                                                   ALLOC_TAG_GDI(7));
        if (pCtxtTable == NULL)
        {
            DISPDBG((ERRLVL, "Failed to allocate GLINT context table. "
                             "Out of memory"));
            return(-1);
        }
        pCtxtTable->nEntries = CTXT_CHUNK;
        pCtxtTable->size = size;
        ppdev->pGContextTable = pCtxtTable;
    }

    // Always update this. If a new PDEV comes along for this board we need
    // to initialize its current context. One way to do this would be to
    // provide an explicit function to do the job but why do that to update
    // one variable. Anyway context allocation is pretty rare so this extra
    // assign isn't too much of a overhead.
    //
    ppdev->currentCtxt = -1;

    // Find an empty entry in the table
    // I suppose if we have hundreds of contexts this could be a bit slow but
    // allocating the context isn't time critical, swapping in and out is.
    //
    pCtxtTable = ppdev->pGContextTable;
    nEntries = pCtxtTable->nEntries;
    ppEntry = &pCtxtTable->pEntry[0];
    for (ctxtId = 0; ctxtId < nEntries; ++ctxtId)
    {
        if (*ppEntry == 0)
        {
            DISPDBG((DBGLVL, "found free context id %d", ctxtId));
            break;
        }
        ++ppEntry;
    }
    DISPDBG((DBGLVL, "Got ppEntry = 0x%x", ppEntry));
    DISPDBG((DBGLVL, "Got *ppEntry = 0x%x", *ppEntry));

    // if we found no free entries try to grow the table
    if (ctxtId == nEntries)
    {
        DISPDBG((WRNLVL, "context table full so enlarging"));
        size = pCtxtTable->size + (CTXT_CHUNK * sizeof(GlintCtxtRec*));
        pNewCtxtTable = (GlintCtxtTable*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                                      size, 
                                                      ALLOC_TAG_GDI(8));
        if (pNewCtxtTable == NULL)
        {
            DISPDBG((ERRLVL, "failed to increase GLINT context table. "
                             "Out of memory"));
            return(-1);
        }
        // copy the old table to the new one
        RtlCopyMemory(pNewCtxtTable, pCtxtTable, pCtxtTable->size);
        pNewCtxtTable->size = size;
        pNewCtxtTable->nEntries = nEntries + CTXT_CHUNK;
        ppdev->pGContextTable = pNewCtxtTable;
        
        // first of the newly allocated entries is next free one
        ctxtId = nEntries;
        ppEntry = &pNewCtxtTable->pEntry[ctxtId];

        // free the old context table and reassign some variables
        ENGFREEMEM(pCtxtTable);
        pCtxtTable = pNewCtxtTable;
        nEntries = pCtxtTable->nEntries;
    }

    size = sizeof(GlintCtxtRec) - sizeof(CtxtData);
    if( ctxtType == ContextType_RegisterList )
    {
        // if pTag is passed as null then we are to add all 
        // readable registers to the context.
        if( pTag == NULL )
        {
            DISPDBG((DBGLVL, "adding all readable P3 registers to the context"));
            
            pTag = readableRegistersP3;
            ntags = N_READABLE_TAGSP3;
        }

        // now allocate space for the new entry. We are given the number of 
        // tags to save when context switching. Allocate twice this much 
        // memory as we have to hold the data values as well.
        DISPDBG((DBGLVL, "Allocating space for context. ntags = %d", ntags));
        size += ntags * sizeof(CtxtData);
    }

    *ppEntry = (GlintCtxtRec*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                         size, 
                                         ALLOC_TAG_GDI(9));
    if (*ppEntry == NULL)
    {
        DISPDBG((ERRLVL, "Out of memory "
                         "trying to allocate space for new context"));
        return(-1);
    }
    
    pEntry = *ppEntry;
    DISPDBG((DBGLVL, "Got pEntry 0x%x", pEntry));
    pEntry->type = ctxtType;

    pEntry->ntags = ntags;
    pEntry->priv = priv;
    pData = pEntry->pData;

    DISPDBG((DBGLVL, "pEntry setup"));

    switch (pEntry->type)
    {
    case ContextType_None:
        DISPDBG((DBGLVL, "context is of type 'None'"));   
        // doing nothing
        break;

    case ContextType_RegisterList:
        DISPDBG((DBGLVL, "context is of type 'RegisterList'"));
        while (--ntags >= 0)
        {
            pData->tag = *pTag++;
            READ_GLINT_FIFO_REG(pData->tag, pData->data);
            ++pData;
        }
        break;

    case ContextType_Fixed:
        DISPDBG((DBGLVL, "context is of type 'Fixed'"));
        pEntry->dumpFunc = (ContextFixedFunc) pTag;
        break;
    default:
        DISPDBG((DBGLVL, "context is of unknown type: %d", ctxtType));    
        break;
    }

    // init the control registers that we save in the context.
    //
    pEntry->DoubleWrite = 0;

//@@BEGIN_DDKSPLIT
    // TMM: Find out the current setting of DISCONNECT and use that one
    // this might seem a bit strange but we want to inherit the crrent
    // setting of Disconnect.
//@@END_DDKSPLIT
    READ_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
    READ_GLINT_CTRL_REG (VideoControl, pEntry->VideoControl);
    READ_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl); 
    
    // if no interrupt driven DMA or asked for less than 3 buffers then
    // configure no Q for this context 
    if (!GLINT_INTERRUPT_DMA || (NumSubBuffers <= 2))
    {
        NumSubBuffers = 0;
    }

    // initialize the size of the Q for interrupt driven DMA. We must always
    // set the Q length to 2 less than the number of sub-buffers. This is so
    // that we block before allowing the application to write to a buffer that
    // has no yet been DMA'ed. Since the Q always has  a blank entry to make
    // it circular the endIndex of the Q is one beyond the end
    // (i.e. the number of entries in the Q is endIndex-1) so subtract one
    // from the number of sub-buffers to get the endIndex.
    // If NumSubBuffers is zero then we are not using interrupt driven DMA
    // for this context.

    if (NumSubBuffers > 0)
    {
        pEntry->endIndex = NumSubBuffers-1;
    }
    else
    {
        pEntry->endIndex = 0;
    }

    DISPDBG((DBGLVL, "Allocated context %d", ctxtId));
    return(ctxtId);
    
} //GlintAllocateNewContext

/******************************************************************************
 * vGlintFreeContext:
 *
 *  Free a previously allocated context
 *
 ******************************************************************************/
VOID vGlintFreeContext(
PPDEV   ppdev,
LONG    ctxtId)
{
    GlintCtxtTable *pCtxtTable;
    GlintCtxtRec   **ppEntry;
    BOOL           bAllCtxtsFreed;
    LONG           i;
    
    pCtxtTable = ppdev->pGContextTable;

    if (pCtxtTable == NULL)
    {
        DISPDBG((ERRLVL,"vGlintFreeContext: no contexts have been created!"));
        return;
    }

    if ((ctxtId < 0) || (ctxtId >= pCtxtTable->nEntries))
    {
        DISPDBG((ERRLVL,
                 "vGlintFreeContext: Trying to free out of range context"));
        return;
    }

    ppEntry = &pCtxtTable->pEntry[ctxtId];

    // If the entry is not yet free (it shouldn't) free it
    if (NULL != *ppEntry)
    {
        ENGFREEMEM(*ppEntry);
        *ppEntry = 0;   // marks it as free
    }
    else
    {
        DISPDBG((WRNLVL, "vGlintFreeContext: ppEntry already freed "
                         "ctxtId = %d", ctxtId));
    }

    // If there are no more valid contexts in the context table, lets
    // destroy it, otherwise it will leak memory. Whenever we get called
    // to allocate a new context, it will be created if necessary
    bAllCtxtsFreed = TRUE;
    for (i = 0; i < pCtxtTable->nEntries; i++)
    {
        bAllCtxtsFreed = bAllCtxtsFreed && (pCtxtTable->pEntry[i] == NULL);
    }
    
    if(bAllCtxtsFreed)
    {
        ENGFREEMEM(ppdev->pGContextTable);
        ppdev->pGContextTable = NULL;
    }

    // if this was the current context, mark the current context as invalid so 
    // we force a reload next time. Guard against null pointers when exiting 
    // from DrvEnableSurface with some error condition
    
    if (ppdev->currentCtxt == ctxtId)
    { 
        if (ppdev->bEnabled)
        {
            // only sync if PDEV is enabled as we can be called from 
            // DrvDisableSUrface after the PDEV was disabled by 
            // DrvAssertMode(,FALSE)
            GLINT_DECL;
            SYNC_WITH_GLINT;
        }
        ppdev->currentCtxt = -1;
        ppdev->g_GlintBoardStatus &= ~(GLINT_INTR_CONTEXT | GLINT_DUAL_CONTEXT);
    }
    
    DISPDBG((DBGLVL, "Released context %d", ctxtId));
    
} // vGlintFreeContext

/******************************************************************************
 * vGlintSwitchContext
 *
 *  Load a new context into the hardware. We assume that this call is protected 
 *  by a test that the given context is not the current one - hence the 
 *  assertion. The code would work but the driver should never try to load an 
 *  already loaded context so we trap it as an error.
 *
 * The NON_GLINT_CONTEXT_ID is used by 2D accelerators on combo boards. Effectively,
 * we use it to extend the context switching to allow syncing between the 2D and
 * the GLINT chips. As they are both talking to the same framebuffer, we cannot
 * allow both to be active at the same time. Of course, in the future we could
 * come up with some mutual exclusion scheme based on the bounding boxes of the
 * areas into which each chip is rendering, but that would require major surgery
 * to both the 2D driver and the 3D extension.
 *
 ******************************************************************************/
VOID vGlintSwitchContext(
PPDEV   ppdev,
LONG    ctxtId)
{
    GlintCtxtTable *pCtxtTable;
    GlintCtxtRec   *pEntry;
    CtxtData       *pData;
    LONG           oldCtxtId;
    ULONG          enableFlags;
    LONG           ntags, n;
    LONG           i;
    ULONG          *pul;
    GLINT_DECL;

    pCtxtTable = ppdev->pGContextTable;


    if (pCtxtTable == NULL)
    {
        DISPDBG((ERRLVL,"vGlintSwitchContext: no contexts have been created!"));
        return;
    }
    
    oldCtxtId = ppdev->currentCtxt;

    DISPDBG((DBGLVL, "swapping from context %d to context %d", 
                     oldCtxtId, ctxtId));

    if ((ctxtId < -1) || (ctxtId >= pCtxtTable->nEntries))
    {
        DISPDBG((ERRLVL,
                 "vGlintSwitchContext: Trying to free out of range context"));
        return;
    }

    // sync with the chip before reading back the current state. The flag
    // is used to control context manipulation on lockup recovery.
    //
    DISPDBG((DBGLVL, "SYNC_WITH_GLINT for context switch"));
    SYNC_WITH_GLINT;

    ASSERTDD(!(ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) ||
                ((ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) &&
                    (glintInfo->pInterruptCommandBlock->frontIndex ==
                     glintInfo->pInterruptCommandBlock->backIndex)),
            "Trying to context switch with outstanding DMA queue entries");

    if (oldCtxtId != -1) 
    {
        pEntry = pCtxtTable->pEntry[oldCtxtId];

        if (pEntry != NULL)
        {
            pData  = pEntry->pData;
            ntags  = pEntry->ntags;

            switch (pEntry->type)
            {
            case ContextType_None:
                // nothing doing
                DISPDBG((DBGLVL, "Context is of type none - doing nothing"));
                break;

            case ContextType_Fixed:
                DISPDBG((DBGLVL, "Context is of type fixed, calling dumpFunc "
                                 "0x%08X with FALSE", pEntry->dumpFunc));
                pEntry->dumpFunc(ppdev, FALSE);
                break;

            case ContextType_RegisterList:
                while( --ntags >= 0 )
                {
                    READ_GLINT_FIFO_REG(pData->tag, pData->data);
                    DISPDBG((DBGLVL, "readback tag 0x%x, data 0x%x", 
                                     pData->tag, pData->data));
                    ++pData;
                }
                break;

            default:
                DISPDBG((ERRLVL, "Context is of unknown type!!!"));
            }

            // Save disconnect
            READ_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
            READ_GLINT_CTRL_REG (VideoControl, pEntry->VideoControl);
            READ_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl);

            // disable interrupt driven DMA. New context may re-enable it. 
            // Clear dual TX status while we're at it.
            ppdev->g_GlintBoardStatus &= ~(GLINT_INTR_CONTEXT | GLINT_DUAL_CONTEXT);

            READ_GLINT_CTRL_REG (IntEnable, enableFlags);
            WRITE_GLINT_CTRL_REG(IntEnable, enableFlags & ~(INTR_ENABLE_DMA));
            if (GLINT_DELTA_PRESENT)
            {
                READ_GLINT_CTRL_REG (DeltaIntEnable, enableFlags);
                WRITE_GLINT_CTRL_REG(DeltaIntEnable, 
                                     enableFlags & ~(INTR_ENABLE_DMA));
            }
            
            DISPDBG((DBGLVL, "DMA Interrupt disabled"));             

            // record whether double writes are enabled or not
            if (glintInfo->flags & GLICAP_RACER_DOUBLE_WRITE)
            {
                GET_RACER_DOUBLEWRITE (pEntry->DoubleWrite);
            }
        }
        else
        {
            // nothing doing
            DISPDBG((ERRLVL, "Context pEntry is unexpectedly NULL! (2)"));        
        }
    }


    // load the new context. We allow -1 to be passed so that we can force a
    // save of the current context and force the current context to be
    // undefined.
    //
    if (ctxtId != -1)
    {   
//@@BEGIN_DDKSPLIT    
        // AZN Assert taken out since we now check below for (pEntry != NULL)
        //ASSERTDD(pCtxtTable->pEntry[ctxtId] != 0, 
        //         "Trying to load a freed context");
//@@END_DDKSPLIT        

        pEntry = pCtxtTable->pEntry[ctxtId];

        if (pEntry != NULL)
        {
            switch (pEntry->type)
            {
            case ContextType_None:
                // nothing doing
                DISPDBG((DBGLVL, "Context is of type none, doing nothing"));
                break;

            case ContextType_Fixed:
                DISPDBG((DBGLVL,"Context is of type fixed, "
                                "calling dumpFunc 0x%08X with TRUE", 
                                pEntry->dumpFunc));
                pEntry->dumpFunc(ppdev, TRUE);
                break;

            case ContextType_RegisterList:
                ntags = pEntry->ntags;
                pData = pEntry->pData;

                while (ntags > 0)
                {
                    n = 16;
                    WAIT_GLINT_FIFO(n);
                    ntags -= n;
                    
                    if (ntags < 0)
                    {
                        n += ntags;
                    }
                    
                    while (--n >= 0) 
                    {
                        LD_GLINT_FIFO(pData->tag, pData->data);
                        DISPDBG((DBGLVL, "loading tag 0x%x, data 0x%x", 
                                         pData->tag, pData->data));
                        ++pData;
                    }
                }
                break;

            default:
                DISPDBG((ERRLVL, "Context is of unknown type!!!"));
            }

            // load up the control registers
            //
            if (glintInfo->flags & GLICAP_RACER_DOUBLE_WRITE)
            {
                SET_RACER_DOUBLEWRITE (pEntry->DoubleWrite);            
            }

            // Restore disconnect
            WRITE_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
            WRITE_GLINT_CTRL_REG (VideoControl, 
                                  ((pEntry->VideoControl & 0xFFFFFF87) | 0x29));
            WRITE_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl); 

            // if using interrupt driven DMA for this context (endIndex > 0) then
            // restore the size of the interrupt driven DMA queue for this context
            // and reset the queue.
            //
            if (pEntry->endIndex > 0)
            {
                ASSERTDD(GLINT_INTERRUPT_DMA,
                         "trying to set up DMA Q "
                         "but no interrupt driven DMA available");
                         
                ASSERTDD(glintInfo->pInterruptCommandBlock->frontIndex == 
                         glintInfo->pInterruptCommandBlock->backIndex,
                        "Trying to context switch "
                        "with outstanding DMA queue entries");
                        
                glintInfo->pInterruptCommandBlock->frontIndex = 0;
                glintInfo->pInterruptCommandBlock->backIndex  = 0;
                glintInfo->pInterruptCommandBlock->endIndex = pEntry->endIndex;
                ppdev->g_GlintBoardStatus |= GLINT_INTR_CONTEXT;
                
                READ_GLINT_CTRL_REG (IntEnable, enableFlags);
                DISPDBG((DBGLVL, "DMA Interrupt enabled. flags = 0x%x", 
                                    enableFlags | 
                                    (INTR_ENABLE_DMA|INTR_ENABLE_ERROR)));             

                WRITE_GLINT_CTRL_REG(IntEnable, enableFlags      | 
                                                INTR_ENABLE_DMA  |
                                                INTR_ENABLE_ERROR );
                if (GLINT_DELTA_PRESENT)
                {
                    READ_GLINT_CTRL_REG (DeltaIntEnable, enableFlags);
                    WRITE_GLINT_CTRL_REG(DeltaIntEnable, enableFlags      | 
                                                         INTR_ENABLE_DMA  |
                                                         INTR_ENABLE_ERROR );
                }
            }
        }
        else
        {
            // nothing doing
            DISPDBG((ERRLVL, "Context pEntry is unexpectedly NULL! (1)"));        
        }
    }

    DISPDBG((DBGLVL, "vGlintSwitchContext: context %d now current", ctxtId));
    ppdev->currentCtxt = ctxtId;
    
} // vGlintSwitchContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glint.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glint.h
*
* Content: Defines and macros for interfacing to the GLINT hardware.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef _GLINT_H_
#define _GLINT_H_

#include <gtag.h>
//#include "glintmsg.h"
#include <glintdef.h>

// USE_SYNC_FUNCTION must be set at the moment for error free builds. The macro
// version requires #including <pxrx.h> which would make re-builds a nightmare.
// On more important issues, there is nomeasurable loss of speed but the driver
// is a fair bit smaller.
#define USE_SYNC_FUNCTION   1

// when enabled, most of the DDI entrypoints in THUNK.C check whether the base viewable scanline 
// variables in DEBUG4.C have been modified, allowing the scanline view to be updated
#define SET_VIEW_MEMORY_ENABLED 0

#if DBG && SET_VIEW_MEMORY_ENABLED
extern void DebugCheckMemoryView(PPDEV ppdev);
#define CHECK_MEMORY_VIEW(ppdev)
#else
#define CHECK_MEMORY_VIEW(ppdev)
#endif

#define COLLECT_TEXT_STATS 0
#if COLLECT_TEXT_STATS
struct TextStats
{
    ULONG aGlyphWidthBytesCached[9]; // [0] = 1 byte, [1] = 2 bytes, ... [7] = 8 bytes, [8] > 8 bytes
    ULONG cCacheableStrings;
    ULONG cUncacheableStrings;
    ULONG cGlyphsCached;

    ULONG cGlyphTotalBytesCached;
    ULONG meanGlyphBytesCached;
    ULONG cProportionalGlyphs;
    ULONG cProportionalStrings;
    
    ULONG meanProportionalGlyphsPerString;
    ULONG cFixedGlyphs;
    ULONG cFixedStrings;
    ULONG meanFixedGlyphsPerString;

    ULONG cClippedGlyphs;
    ULONG cClippedStrings;
    ULONG meanClippedGlyphsPerString;
    ULONG cAllocedFonts;

    ULONG cFreedFonts;
    ULONG cBlownCaches;
};

extern struct TextStats gts;

#define STAT_CACHEABLE_STRING  ++gts.cCacheableStrings
#define STAT_UNCACHEABLE_STRING ++gts.cUncacheableStrings
#define STAT_CACHING_GLYPH(cxGlyphAligned, cyGlyph) \
    do \
    { \
        ++gts.cGlyphsCached; \
        gts.cGlyphTotalBytesCached += (cxGlyphAligned >> 3) * cyGlyph; \
        gts.meanGlyphBytesCached = gts.cGlyphTotalBytesCached / gts.cGlyphsCached; \
        ++gts.aGlyphWidthBytesCached[(cxGlyphAligned >> 3) > 8 ? 8 : (cxGlyphAligned >> 3) - 1]; \
    } \
    while(0) 
#define STAT_PROPORTIONAL_TEXT(cGlyph) \
    do \
    { \
        gts.cProportionalGlyphs += cGlyph; \
        ++gts.cProportionalStrings; \
        gts.meanProportionalGlyphsPerString = gts.cProportionalGlyphs / gts.cProportionalStrings; \
    } \
    while(0)

#define STAT_FIXED_TEXT(cGlyph)    \
    do \
    { \
        gts.cFixedGlyphs += cGlyph; \
        ++gts.cFixedStrings; \
        gts.meanFixedGlyphsPerString = gts.cFixedGlyphs / gts.cFixedStrings; \
    } \
    while(0)
#define STAT_CLIPPED_TEXT(cGlyph) \
    do \
    { \
        gts.cClippedGlyphs += cGlyph; \
        ++gts.cClippedStrings; \
        gts.meanClippedGlyphsPerString = gts.cClippedGlyphs / gts.cClippedStrings; \
    } \
    while(0)
#define STAT_ALLOC_FONT ++gts.cAllocedFonts
#define STAT_FREE_FONT ++gts.cFreedFonts
#define STAT_BLOW_CACHE ++gts.cBlownCaches
#else
#define STAT_CACHEABLE_STRING
#define STAT_UNCACHEABLE_STRING
#define STAT_CACHING_GLYPH(cxGlyphAligned, cyGlyph)
#define STAT_PROPORTIONAL_TEXT(cGlyph)
#define STAT_FIXED_TEXT(cGlyph)
#define STAT_CLIPPED_TEXT(cGlyph)
#define STAT_ALLOC_FONT
#define STAT_FREE_FONT
#define STAT_BLOW_CACHE
#endif

#define DMA_DRIVEN_2D   0

#define GLINT_LOCKUP_TIMEOUT    0
#define GAMMA_CORRECTION        1
#define COLORIFIC_GAMMA_CORRECTION   1              

/*
 *  USE_PCI_DISC_PERM
 *    -----------------
 *
 *  Set USE_PCI_DISC_PERM to 1 for PCI disconnect on permanently or set to 0 for
 *  disconnect off permanently. ( Set to 1 to try and speed things up , set to 0
 *  on Alphas which are sensitive ).
 */
#if defined(_X86_)
    #define USE_PCI_DISC_PERM       1 
#else   // _X86_
    #define USE_PCI_DISC_PERM       0       
#endif  // _X86_

// DMA text rendering gives me a 1 winmark improvement on my P6 200 at 8 & 15bpp, but gives
// no improvement at these depths on a Pentium II 300 and might actually be 1 winmark slower
// at 32bpp
#define ENABLE_DMA_TEXT_RENDERING 0

/********************************************************************************/
// Texture memory allocation macros and structures are in 3DPrivTx.h

// definition of handle to a memory region
typedef  LONG HMEMREGION;
typedef  LONG HMEMCACHE;
typedef enum {RESIDENCY_NOTLOADED, RESIDENCY_PERMANENT, RESIDENCY_TRANSIENT, RESIDENCY_HOST, RESIDENCY_PERMANENT2} MEM_MGR_RESIDENCY;

/********************************************************************************/

/*** DrvEscape commands ***/
#define GLINT_SET_SCANLINE   6000   // Temporary define for setting the displayed scanline (Permedia specific)
#define GLINT_GET_RAMDAC_LUT 6001   // Temporary define for getting the RAMDACs LUT
#define GLINT_SET_RAMDAC_LUT 6002   // Temporary define for getting the RAMDACs LUT
#define GLINT_SET_SAME_VIDEO_MODE 6003  // Temporary define for getting the RAMDACs LUT
// Monitor DDC support:
#define GLINT_QUERY_MONITOR_INFO    6004
#define GLINT_MULTIMON_CMD          6007

#define GLINT_GET_SOFT_ENGINE_INFO  6009

// Debug only escapes:
#define GLINT_DBG_GET_FRAMEBUFFER   6008
#define GLINT_DBG_TEST_PXRX_DMA     6010

/*** DrvDrawEscape commands ***/
#define GLINT_DBG_SEND_TAGS         10238
#define GLINT_DBG_SET_DEBUG         10239

//
// various GLINT devices and revisions
//
#define VENDOR_ID_3DLABS        0x3D3D
#define VENDOR_ID_TI            0x104C
#define GLINT_300SX_ID          0x0001
#define GLINT_500TX_ID          0x0002
#define GLINT_DELTA_ID          0x0003
#define PERMEDIA_ID             0x0004
#define PERMEDIA_P1_ID          0x3D04
#define GLINT_MX_ID             0x0006
#define PERMEDIA2_ID            0x0007          // 3Dlabs Permedia 2
#define PERMEDIA_P2_ID          0x3D07          // TI Permedia 2
#define GLINT_GAMMA_ID          0x0008
#define PERMEDIA_P2S_ID         0x0009          // 3Dlabs Permedia 2ST
#define PERMEDIA3_ID            0x000A
#define GLINT_R3_ID             0x000B
#define PERMEDIA4_ID            0x000C
#define GLINT_R4_ID             0x000D

#define DEVICE_FAMILY_ID(id)    ((id) & 0xff)

#define GLINT_DEVICE_SX         GLINT_300SX_ID
#define GLINT_DEVICE_TX         GLINT_500TX_ID
#define GLINT_DEVICE_MX         GLINT_MX_ID
#define GLINT_DEVICE_FX         PERMEDIA_ID
#define GLINT_DEVICE_P2         PERMEDIA2_ID
#define GLINT_DEVICE_P2S        PERMEDIA_P2S_ID
#define GLINT_DEVICE_P3         PERMEDIA3_ID
#define GLINT_DEVICE_P4         PERMEDIA4_ID
#define GLINT_DEVICE_R3         GLINT_R3_ID
#define GLINT_DEVICE_R4         GLINT_R4_ID

#define GLINT_300SX_REV_1       0x0000
#define GLINT_300SX_REV_2       0x0002
#define GLINT_500TX_REV_1       0x0001
#define GLINT_DELTA_REV_1       0x0001
#define GLINT_PERMEDIA_REV_1    0x0001

#define GLINT_REVISION_SX_1     GLINT_300SX_REV_1
#define GLINT_REVISION_SX_2     GLINT_300SX_REV_2

#define GLINT_REVISION_TX_1     GLINT_500TX_REV_1

#define GLINT_REVISION_1 GLINT_REVISION_SX_1
#define GLINT_REVISION_2 GLINT_REVISION_SX_2

//
// Supported board definitions. Must be the same as in the miniport
//
typedef enum _GLINT_BOARDS {
    GLINT_MONTSERRAT = 0,
    GLINT_RACER,
    DENSAN_300SX,
    ACCELR8_BOARD,
    ACCELPRO_BOARD,
    OMNICOMP_SX88,
    PERMEDIA_BOARD,
    PERMEDIA_NT_BOARD,
    PERMEDIA_LC_BOARD,
    DUALTX_MENTOR_BOARD,
    DUALTX_SYMMETRIC_BOARD,
    ELSA_GLORIA,
    PERMEDIA2_BOARD,
    OMNICOMP_3DEMONPRO,
    GEO_TWIN_BOARD,
    GLINT_RACER_PRO,
    ELSA_GLORIA_XL,
    PERMEDIA3_BOARD,
    MAX_GLINT_BOARD
} GLINT_BOARDS;


//
// Supported RAMDAC definitions. Must be the same as in the miniport
//

typedef enum _GLINT_RAMDACS {
    RGB525_RAMDAC = 0,
    RGB526_RAMDAC,
    RGB526DB_RAMDAC,
    RGB528_RAMDAC,
    RGB528A_RAMDAC,
    RGB624_RAMDAC,
    RGB624DB_RAMDAC,
    RGB640_RAMDAC,
    TVP3026_RAMDAC,
    TVP3030_RAMDAC,
    RGB524_RAMDAC,
    RGB524A_RAMDAC,
    TVP4020_RAMDAC,
    P2RD_RAMDAC,
    P3RD_RAMDAC,
    MAX_GLINT_RAMDAC
} GLINT_RAMDACS;

// extern declarations
extern DWORD    GlintLogicOpsFromR2[];  // translates GDI rop2 to GLINT logic op mode word
extern DWORD    LogicopReadDest[];      // indicates which logic ops need dest read turned on


// values for flags in GlintDataRec
//
typedef enum {
    GLICAP_NT_CONFORMANT_LINES      = 0x00000001,        // draw NT conformant lines
    GLICAP_HW_WRITE_MASK            = 0x00000002,        // hardware planemasking
    GLICAP_COLOR_SPACE_DBL_BUF      = 0x00000004,        // interleaved nibbles
    GLICAP_BITBLT_DBL_BUF           = 0x00000008,        // dbl buf by bitblt
    GLICAP_FULL_SCREEN_DBL_BUF      = 0x00000010,        // hardware can dbl buf
    GLICAP_FIX_FAST_FILLS           = 0x00000020,        // workaround fast fill bug
    GLICAP_INTERRUPT_DMA            = 0x00000080,        // interrupt driven DMA
    GLICAP_RACER_BANK_SELECT        = 0x00000100,        // FS dbl buf uses Racer h/w
    GLICAP_FIX_4MB_FAST_FILLS       = 0x00000200,        // fix blk fill above 4MB
    GLICAP_RACER_DOUBLE_WRITE       = 0x00000400,        // Can double write
    GLICAP_ENHANCED_TX_BANK_SELECT  = 0x00000800,        // Enhanced TX FS dbl buf
    GLICAP_HW_WRITE_MASK_BYTES      = 0x00001000,        // hardware planemasking is bytewise only
    GLICAP_STEREO_BUFFERS           = 0x00002000,        // stereo buffers allocated
} GLINT_CAPS;

//@@BEGIN_DDKSPLIT
// TMM: In the good old days we used to leave the screen scissor enabled
// as a safety-net, however, the screen scissor doesn't work when uploading
// data at 1280 or 1170 screen widths, so I've disabled it.
//@@END_DDKSPLIT

#define SCREEN_SCISSOR_DEFAULT  (0 << 1)

// Currently we support the main display and up to 3 off-screen buffers.
//
#define GLINT_NUM_SCREEN_BUFFERS    4

// currently we support software cursors up to this width and height. This is
// to ensure that we have enough off-screen memory to save the shapes and save
// unders.
//
#define SOFTWARE_POINTER_SIZE   32

// this structure contains the addresses of all the GLINT registers that we
// want to write to. It is used by any macro/functions which needs to talk to
// the GLINT chip. We precompute these addresses so that we get faster access
// on DEC Alpha machines.
//
typedef struct _glint_reg_addrs {

    // Most commonly used non-FIFO registers

    ULONG *   InFIFOSpace;
    ULONG *   OutFIFOWords;
    ULONG *   OutFIFOWordsOdd;
    ULONG *   DMAControl;
    ULONG *   OutDMAAddress;            // P2 only
    ULONG *   OutDMACount;            // P2 only
    ULONG *   ByDMAAddress;            // P2 only
    ULONG *   ByDMAStride;            // P2 only
    ULONG *   ByDMAMemAddr;            // P2 only
    ULONG *   ByDMASize;                // P2 only
    ULONG *   ByDMAByteMask;            // P2 only
    ULONG *   ByDMAControl;            // P2 only
    ULONG *   ByDMAComplete;            // P2 only
    ULONG *   DMAAddress;
    ULONG *   DMACount;
    ULONG *   InFIFOInterface;
    ULONG *   OutFIFOInterface;
    ULONG *   OutFIFOInterfaceOdd;
    ULONG *   FBModeSel;
    ULONG *   FBModeSelOdd;
    ULONG *   IntFlags;
    ULONG *   DeltaIntFlags;

    // PERMEDIA
    ULONG *   ScreenBase;
    ULONG *   ScreenBaseRight;
    ULONG *   LineCount;
    ULONG *   VbEnd;
    ULONG * VideoControl;
    ULONG * MemControl;

    // GAMMA
    ULONG * GammaChipConfig;
    ULONG * GammaCommandMode;
    ULONG * GammaCommandIntEnable;
    ULONG * GammaCommandIntFlags;
    ULONG * GammaCommandErrorFlags;
    ULONG * GammaCommandStatus;
    ULONG * GammaFeedbackSelectCount;
    ULONG * GammaProcessorMode;
    ULONG * GammaMultiGLINTAperture;

    // Core FIFO registers

    ULONG *   tagwr[__MaximumGlintTagValue+1];  
    ULONG *   tagrd[__MaximumGlintTagValue+1];  

    // Other control registers

    ULONG *   VTGHLimit;
    ULONG *   VTGHSyncStart;
    ULONG *   VTGHSyncEnd;
    ULONG *   VTGHBlankEnd;
    ULONG *   VTGHGateStart;
    ULONG *   VTGHGateEnd;
    ULONG *   VTGVLimit;
    ULONG *   VTGVSyncStart;
    ULONG *   VTGVSyncEnd;
    ULONG *   VTGVBlankEnd;
    ULONG *   VTGVGateStart;
    ULONG *   VTGVGateEnd;
    ULONG *   VTGPolarity;
    ULONG *   VTGVLineNumber;
    ULONG *   VTGFrameRowAddr;
    ULONG *   VTGFrameRowAddrOdd;

    ULONG *   LBMemoryCtl;
    ULONG *   LBMemoryEDO;
    ULONG *   FBMemoryCtl;
    ULONG *   IntEnable;
    ULONG *   DeltaIntEnable;
    ULONG *   ResetStatus;
    ULONG *   DisconnectControl;
    ULONG *   ErrorFlags;
    ULONG *   DeltaErrorFlags;

    ULONG *   VTGSerialClk;
    ULONG *   VTGSerialClkOdd;
    ULONG *   VClkCtl;

    // Racer board has these extra registers external to GLINT
    ULONG *   RacerDoubleWrite;
    ULONG *   RacerBankSelect;

    ULONG *   VSConfiguration;    // P2 only

    // Omnicomp 3demonPro16 board has these extra registers external to GLINT
    ULONG *   DemonProDWAndStatus;     // Pro   5000
    ULONG *   DemonProUBufB;           // Pro   7000

    // split framebuffer needs scanline ownership, FBWindowBase and LBWindowBase
    // to be context switched.
    ULONG *   OddGlintScanlineOwnRd;
    ULONG *   OddGlintFBWindowBaseRd;
    ULONG *   OddGlintLBWindowBaseRd;

    // Dual-TX needs area stipple to be different on both chips
    ULONG *   OddTXAreaStippleRd[32];

    // PXRX
    ULONG *      TextureDownloadControl;
    ULONG *      AGPControl;

    ULONG   *LocalMemCaps;
    ULONG   *MemScratch;

    ULONG   *LocalMemProfileMask0;
    ULONG   *LocalMemProfileMask1;
    ULONG   *LocalMemProfileCount0;
    ULONG   *LocalMemProfileCount1;

    ULONG   *PXRXByAperture1Mode;            // 0300h
    ULONG   *PXRXByAperture1Stride;            // 0308h
//  ULONG   *PXRXByAperture1YStart;            // 0310h
//  ULONG   *PXRXByAperture1UStart;            // 0318h
//  ULONG   *PXRXByAperture1VStart;            // 0320h
    ULONG   *PXRXByAperture2Mode;            // 0328h
    ULONG   *PXRXByAperture2Stride;            // 0330h
//  ULONG   *PXRXByAperture2YStart;            // 0338h
//  ULONG   *PXRXByAperture2UStart;            // 0340h
//  ULONG   *PXRXByAperture2VStart;            // 0348h
    ULONG   *PXRXByDMAReadMode;                // 0350h
    ULONG   *PXRXByDMAReadStride;            // 0358h
//  ULONG   *PXRXByDMAReadYStart;            // 0360h
//  ULONG   *PXRXByDMAReadUStart;            // 0368h
//  ULONG   *PXRXByDMAReadVStart;            // 0370h
    ULONG   *PXRXByDMAReadCommandBase;        // 0378h
    ULONG   *PXRXByDMAReadCommandCount;        // 0380h
//  ULONG   *PXRXByDMAWriteMode;            // 0388h
//  ULONG   *PXRXByDMAWriteStride;            // 0390h
//  ULONG   *PXRXByDMAWriteYStart;            // 0398h
//  ULONG   *PXRXByDMAWriteUStart;            // 03A0h
//  ULONG   *PXRXByDMAWriteVStart;            // 03A8h
//  ULONG   *PXRXByDMAWriteCommandBase;        // 03B0h
//  ULONG   *PXRXByDMAWriteCommandCount;    // 03B8h

    // Used for P3 for debug purposes, to examine fifo stages.
    ULONG   *TestOutputRdy;
    ULONG   *TestInputRdy;

} GlintRegAddrRec;


typedef struct _glint_packing_str {
    DWORD   readMode;
    DWORD   modeSel;
    DWORD   dxOffset;
} GlintPackingRec;

// Framebuffer Aperture Information: currently only of interest to GeoTwin
// boards to allow for upload DMA directly from FB0 to FB1 and vice versa
typedef struct FrameBuffer_Aperture_Info
{
    LARGE_INTEGER   pphysBaseAddr;
    ULONG           cjLength;
}
FBAPI;

// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the miniport drivers glint.h
typedef struct _Glint_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    LONG  LocalbufferWidth;
    ULONG ActualDacId;
    FBAPI FBAperture[2];            // Physical addresses for geo twin framebuffers
    PVOID FBApertureVirtual [2];    // Virtual addresses for geo twin framebuffers
    PVOID FBApertureMapped [2];        // Mapped physical/logical addresses for geo twin framebuffers
    PUCHAR pCNB20;
    LARGE_INTEGER pphysFrameBuffer; // physical address of the framebuffer (use FBAperture instead for geo twins)
}   Glint_Device_Info;

#define GLINT_DELTA_PRESENT     (glintInfo->deviceInfo.DeltaRevId != 0)
#define GLINT_GAMMA_PRESENT     (glintInfo->deviceInfo.GammaRevId != 0)

// before we get Gamma we won't be able to test all the fancy new features,
// after Gamma arrives we'll enable them one at a time; this define allows us
// to do just that
#define USE_MINIMAL_GAMMA_FEATURES 1

typedef struct _Glint_SwPointer_Info {
    LONG    xOff[5], yOff[5];            // offsets into screen of the caches.
    LONG    PixelOffset;                   // pixel offsets into screen of the caches.
    LONG    x, y;                        // x, y position
    LONG    xHot, yHot;                    // Hotspot position
    LONG    width, height;

    BOOL    onScreen;                    // True if pointer is on screen
    LONG    saveCache;                    // The current saveunder cache
    BOOL    duplicateSaveCache;            // Flag to indicate that save cache should be duplicated.
    ULONG   writeMask;                    // The write mask to use when saving and restoring.
    DWORD   *pDMA;                        // Pointer to a DMA buffer
    ULONG   windowBase;                    // Window base

    DSURF*  pdsurf;                        // Surface descriptors for caches                
    HSURF   hsurf;


    // Cached position of the pointer on the screen
    ULONG   scrXDom, scrXSub, scrY, scrCnt;

    // Cached position of the save under cache
    LONG    cacheXDom[5], cacheXSub[5], cacheY[5], cacheCnt[5];

    // Cached position of the visible pars of the save caches
    LONG    scrToCacheXDom[2], scrToCacheXSub[2], scrToCacheY[2], scrToCacheCnt[2];

    // Cached offsets from the various caches.
    LONG    saveOffset[2], constructOffset, maskOffset, shapeOffset;
} Glint_SwPointer_Info;

// Definition of the IOCTL_VIDEO_QUERY_DMA_BUFFER

#define MAX_LINE_SIZE 8192          // No of bytes required to hold 1 complete scanline (i.e., 
                                    // 6400 for 1600x1200x32).
#define DMA_LINEBUF_SIZE (MAX_LINE_SIZE * 2)    // Size in bytes of 'pvTmpBuffer'. 
                                    // This has to be big enough to store 2 entire
                                    // scan lines. I have increased the size from 1 line
                                    // to 2 lines so that P2 can double buffer
                                    // it's line uploads.

typedef struct GENERAL_DMA_BUFFER {
    LARGE_INTEGER       physAddr;        // physical address of DMA buffer
    PVOID               virtAddr;        // mapped virtual address
    ULONG               size;            // size in bytes
    BOOL                cacheEnabled;    // Whether buffer is cached
} GENERAL_DMA_BUFFER, *PGENERAL_DMA_BUFFER;

/*** NB: The PXRXdmaInfo structure is shared with the Miniport ***/
typedef struct PXRXdmaInfo_Tag {
    ULONG           scheme;        // Used by the interrupt handler only

    volatile ULONG  hostInId;    // Current internal HostIn id, used by the HIid DMA scheme
    volatile ULONG  fifoCount;    // Current internal FIFO count, used by various DMA schemes

    ULONG           NTbuff;        // Current buffer number (0 or 1)
    ULONG           *NTptr;        // 32/64 bit ptr Last address written to by NT (but not necesserily the end of a completed buffer)
    ULONG           *NTdone;    // 32/64 bit ptr    Last address NT has finished with (end of a buffer, but not necessarily sent to P3 yet)
    volatile ULONG  *P3at;        // 32/64 bit ptr  Last address sent to the P3

    volatile BOOL   bFlushRequired;        // Is a flush required to empty the FBwrite unit's cache?

    ULONG           *DMAaddrL[2];        // 32/64 bit ptr       Linear address of the start of each DMA buffer
    ULONG           *DMAaddrEndL[2];    // 32/64 bit ptr        Linear address of the end of each DMA buffer
    ULONG           DMAaddrP[2];        // 32 bit ptr           Physical address of the start of each DMA buffer
    ULONG           DMAaddrEndP[2];        // 32 bit ptr            Physical address of the end of each DMA buffer
} PXRXdmaInfo;
/*** NB: The PXRXdmaInfo structure is shared with the Miniport ***/

typedef struct _glint_data {
    DWORD           renderBits;            // saved render bits set by setup routines
    DWORD           FBReadMode;            // software copy of FBReadMode register
    DWORD           FBWriteMode;        // software copy of FBWriteMode register
    DWORD           RasterizerMode;        // software copy of the rasterizer mode
    DWORD           FBPacking;            // software copy of FBModeSel
    DWORD           FBBlockColor;        // software copy of FBBlockColor (P1 only)
    DWORD           TextureAddressMode; // software copy of TextureAddressMode (P2 only)
    DWORD           TextureReadMode;    // software copy of TextureReadMode (P2 & MX only)
    DWORD           dSdx;                // software copy of dSdx (MX only)
    DWORD           dTdyDom;            // software copy of dTdyDom (MX only)
    BOOL            bGlintCoreBusy;        // 2D flag: TRUE if core not synced
    LONG            currentPelSize; // Currently loaded frame store depth
    ULONG           currentCSbuffer;// color space buffer being displayed
    GLINT_CAPS      flags;          // various flags
    GlintRegAddrRec regs;           // precomputed register addresses
    GlintPackingRec packing[5];     // values to load for 4 packing formats (plus one unused)
    LONG            ddCtxtId;       // id of the display drivers context
    LONG            fastFillBlockSz;// number of pixels per fast fill block
    DWORD           fastFillSupport;// render bits for rev 1 fast fill
    DWORD           renderFastFill; // render bits for rev 2+ fast fill
    LONG            PixelOffset;    // last DFB pixel offset
    ULONG           MaxInFifoEntries;// maximum reported free entries FIFO download
    ULONG           CheckFIFO;        // Non-zero if the FIFO has to be checked before loading it
    ULONG           PCIDiscEnabled;    // Non-zero if PCI disconnect is enabled
    ULONG           BroadcastMask2D;// Primary chip broadcast mask
    ULONG           BroadcastMask3D;// broadcast mask to use for 3D contexts
    LONG            vtgvLimit;      // copy of VTGVLimit register
    LONG            scanFudge;      // how much to add onto VTGVLineNumber to
                                    //  get the current video scanline

    OH *            backBufferPoh;    // heap handle for allocated back-buffer
    OH *            savedPoh;        // handle to saved off-screen heap
    ULONG           GMX2KLastLine;    // Last+1 line to be allocated
    BOOLEAN         offscreenEnabledOK;        // Set to TRUE if off-screen enabled

    ULONG           bufferOffset[GLINT_NUM_SCREEN_BUFFERS];
                                    // offset in pixels to the supported bufs
    ULONG           bufferRow[GLINT_NUM_SCREEN_BUFFERS];
                                    // VTGFrameRowAddr for supported buffers
    ULONG           PerfScaleShift;

    //ContextDumpData   GammaContextMask;
    ULONG           HostOutBroadcastMask; // for Gamma output DMA
    ULONG           HostOutChipNumber;      // for Gamma output DMA

#if GAMMA_CORRECTION
    union {
        UCHAR       _clutBuffer[MAX_CLUT_SIZE];
        VIDEO_CLUT  gammaLUT;       // saved gamma LUT contents
    };
#endif

    // interrupt command block.
    struct _glint_interrupt_control *pInterruptCommandBlock;

    // maximum number of sub buffers per DMA buffer.
    ULONG MaxDMASubBuffers;

    // Overlay support: WriteMask can be set around primitives so that
    // they temporarily render thru this mask. Normally it must be set to -1.
    // DefaultWriteMask is the write mask that should be used by the DD
    // context by default, it takes into account overlay planes.
    //
    ULONG OverlayMode;
    ULONG WriteMask;
    ULONG TransparentColor; // pre-shifted so color is in top 8 bits
    ULONG DefaultWriteMask;
    
    // Indicates whether GDI is allowed to access the frame buffer. Always true 
    // on MIPS and ALPHA and true on all architectures in overlay mode.
    ULONG GdiCantAccessFramebuffer;
    ULONG OGLOverlaySavedGCAF;

    // Configuration for texture and Z buffers

    ULONG ZBufferWidth;             // bits per pel
    ULONG ZBufferOffset;            // offset in pels
    ULONG ZBufferSize;              // size in pels
    ULONG FontMemoryOffset;            // offset in dwords
    ULONG FontMemorySize;            // size in dwords
    ULONG TextureMemoryOffset;      // offset in dwords
    ULONG TextureMemorySize;        // size in dwords

    // On P3 due to patching restrictions the Z width
    // may not match the framebuffer screen width.
    ULONG P3RXLocalBufferWidth;

    // PCI configuration id information
    Glint_Device_Info deviceInfo;

    // Software cursor information
    Glint_SwPointer_Info swPointer;

    // Line DMA buffer information
    GENERAL_DMA_BUFFER  LineDMABuffer;
    GENERAL_DMA_BUFFER  PXRXDMABuffer;

    // Current input FIFO count from 0 to 1023
    ULONG   FifoCnt;

    // PXRX specific stuff:
    ULONG   foregroundColour;            // Software copies of various registers
    ULONG   backgroundColour;            // Ditto
    ULONG   config2D;                    // Ditto
    ULONG   fbDestMode;                    // Ditto
    ULONG   fbDestAddr[4];                // Ditto
    ULONG   fbDestOffset[4];            // Ditto
    ULONG   fbDestWidth[4];                // Ditto
    ULONG   fbWriteMode;                // Ditto
    ULONG   fbWriteAddr[4];                // Ditto
    ULONG   fbWriteWidth[4];            // ottiD
    ULONG   fbWriteOffset[4];            // Ditto
    ULONG   fbSourceAddr;                // Ditto
    ULONG   fbSourceWidth;                // ottiD
    ULONG   fbSourceOffset;                // Ditto
    ULONG   lutMode;                    // Ditto
    ULONG   pxrxByDMAReadMode;            // Ditto
    ULONG   lastLine;                    // Delta LineCoord0/1
    ULONG   savedConfig2D;                // Config2D value that we use for integer lines
    ULONG   savedLOP;                    // LogicOp value that we use for lines
    ULONG   savedCol;                    // Colour value that we use for lines
    RECTL * savedClip;                    // Clip rectangle that we use for lines
    ULONG   pxrxFlags;                    // General flags, see below
    ULONG   backBufferXY;                // Offset to add to front buffer to get to the back buffer (for FBWriteBufferOffsetX)
    ULONG   frontRightBufferXY;            // Offset to the stereo front buffer
    ULONG   backRightBufferXY;            // Offset to the stereo back buffer
    ULONG   fbWriteModeDualWrite;        // FBWriteMode for single writes
    ULONG   fbWriteModeSingleWrite;        // FBWriteMode for dual writes
    ULONG   fbWriteModeDualWriteStereo;    // FBWriteMode for stereo mode single writes
    ULONG   fbWriteModeSingleWriteStereo;// FBWriteMode for stereo mode dual writes
    ULONG   render2Dpatching;            // Value to stuff into Render2D to set the required patch mode

    ULONG       usePXRXdma;
    PXRXdmaInfo *pxrxDMA;
    PXRXdmaInfo pxrxDMAnonInterrupt;
//#if PXRX_DMA_BUFFER_CHECK
    // These should be '#if PXRX_DMA_BUFFER_CHECK' really but the
    // hassle with include dependancies and such like means it ain't
    // worth it.
    ULONG   *pxrxDMA_bufferBase;        // Start of the allocated DMA buffer (inc. guard bands)
    ULONG   *pxrxDMA_bufferTop;            // End of the allocated DMA buffer (inc. guard bands)
    ULONG   *NTwait;                    // Last address up to which NT did a wait for space
//#endif
} GlintDataRec, *GlintDataPtr;

#define PXRX_FLAGS_DUAL_WRITE           (1 << 0)        /* Are we in dual write mode                    */
#define PXRX_FLAGS_DUAL_WRITING         (1 << 1)        /* Are dual writes currently active             */
#define PXRX_FLAGS_PATCHING_FRONT       (1 << 2)        /* Is the front buffer running patched          */
#define PXRX_FLAGS_PATCHING_BACK        (1 << 3)        /* Is the back buffer running patched           */
#define PXRX_FLAGS_READ_BACK_BUFFER     (1 << 4)        /* Do we want to read from the back buffer      */
#define PXRX_FLAGS_STEREO_WRITE         (1 << 5)        /* Are we in OpenGL stereo mode                 */
#define PXRX_FLAGS_STEREO_WRITING       (1 << 6)        /* Are stereo writes currently active           */

#if defined(_PPC_)
// on PPC need this even if not using PERFMON
ULONG GetCycleCount(VOID);
#endif

// bit definitions for the status words in ppdev->g_GlintBoardStatus[]:
// Currently used to indicate sync and DMA status. We have the following rules:
// synced means no outstanding DMA as well as synced. DMA_COMPLETE means n
// outstanding DMA but not necessarily synced. Thus when we do a wait on DMA
// complete we turn off the synced bit.
// XXX for the moment we don't use the synced bit as it's awkward to see where
// to unset it - doing so for every access to the chip is too expensive. We
// probably need a "I'm about to start downloading to the FIFO" macro which
// gets put at the start of any routine which writes to the FIFO.
//
#define GLINT_SYNCED                0x01
#define GLINT_DMA_COMPLETE          0x02     // set when there is no outstanding DMA
#define GLINT_INTR_COMPLETE         0x04
#define GLINT_INTR_CONTEXT          0x08     // set if the current context is interrupt enabled
#define GLINT_DUAL_CONTEXT          0x10     // set if the current context uses both TXs

// these macros were taken out on NT 4 so define them

#define READ_FAST_ULONG(a)      READ_REGISTER_ULONG((PULONG)(a))
#define WRITE_FAST_ULONG(a, d)  WRITE_REGISTER_ULONG((PULONG)(a), (d))
#define TRANSLATE_ADDR(a) ((ULONG *)a)
//azn #define INVALID_HANDLE_VALUE    NULL
#define DebugBreak              EngDebugBreak
typedef PVOID                   PGLINT_COUNTER_DATA;

// This will pause the processor whilst using as little
// system bandwidth (either memory or DMA) as possible
#if defined(_X86_)
#   define BUSY_WAIT(c)                            \
    do {                                        \
        __asm nop                               \
    } while( c-- >= 0 )
#else
#   define BUSY_WAIT(c)                            \
    do {                                        \
        _temp_volatile_i = c;                    \
        do {                                    \
            ;                                    \
        } while( _temp_volatile_i-- >= 0 );        \
    } while(0)
#endif

// If we have a sparsely mapped framebuffer then we use the xx_REGISTER_ULONG()
// macros, otherwise we just access the framebuffer.
#define READ_SCREEN_ULONG(a)    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ? (READ_REGISTER_ULONG(a)) : *((volatile PULONG)(a)))
#define WRITE_SCREEN_ULONG(a,d)           \
{                                         \
    if(ppdev->flCaps & CAPS_SPARSE_SPACE) \
    {                                     \
         WRITE_REGISTER_ULONG((a),d);     \
    }                                     \
    else                                  \
    {                                     \
        *(volatile PULONG)(a) = d;        \
    }                                     \
}

// generic macros to access GLINT FIFO and non-FIFO control registers.
// We do nothing sophisticated for the Alpha (yet). We just MEMORY_BARRIER
// everything.
//
#define READ_GLINT_CTRL_REG(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs. r))
            
#define WRITE_GLINT_CTRL_REG(r, v) \
{ \
    MEMORY_BARRIER(); \
    WRITE_FAST_ULONG(glintInfo->regs. r, (ULONG)(v)); \
    DISPDBG((150, "WRITE_GLINT_CTRL_REG(%-20s:0x%08X) <-- 0x%08X", #r, glintInfo->regs.r, v)); \
    MEMORY_BARRIER(); \
}

#define READ_GLINT_FIFO_REG_CHIP(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.tagrd[r]))

#define READ_GLINT_FIFO_REG(r, d) READ_GLINT_FIFO_REG_CHIP(r, d)
   
#define WRITE_GLINT_FIFO_REG(r, v) \
{ \
    MEMORY_BARRIER(); \
    WRITE_FAST_ULONG(glintInfo->regs.tagwr[r], (ULONG)(v)); \
    MEMORY_BARRIER(); \
}

#define READ_ODD_TX_AREA_STIPPLE(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddTXAreaStippleRd[r]))
            
#define READ_ODD_GLINT_SCANLINE_OWNERSHIP(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintScanlineOwnRd))

#define READ_ODD_GLINT_FBWINDOWBASE(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintFBWindowBaseRd))

#define READ_ODD_GLINT_LBWINDOWBASE(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintLBWindowBaseRd))

//
// macros to access the output FIFO
//
#define READ_OUTPUT_FIFO(d) \
            READ_GLINT_CTRL_REG(OutFIFOInterface, d)
#define READ_OUTPUT_FIFO_ODD(d) \
            READ_GLINT_CTRL_REG(OutFIFOInterfaceOdd, d)

#define OUTPUT_FIFO_COUNT(n) \
            READ_GLINT_CTRL_REG(OutFIFOWords, n)
#define OUTPUT_FIFO_COUNT_ODD(n) \
            READ_GLINT_CTRL_REG(OutFIFOWordsOdd, n)
#define WAIT_OUTPUT_FIFO_COUNT(n) \
{ \
    int i; \
    do \
    { \
       OUTPUT_FIFO_COUNT(i); \
    } \
    while(i < (int)n); \
}

#define DUAL_GLINT_WAIT_OUTPUT_FIFO_NOT_EMPTY(nGlint, cWordsOutFifo) \
{ \
    if(nGlint) \
    { \
        WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(cWordsOutFifo); \
    } \
    else \
    { \
        WAIT_OUTPUT_FIFO_NOT_EMPTY(cWordsOutFifo); \
    } \
}

#define DUAL_GLINT_READ_OUTPUT_FIFO(nGlint, ul) \
{ \
    if(nGlint) \
    { \
        READ_OUTPUT_FIFO_ODD(ul); \
    } \
    else \
    { \
        READ_OUTPUT_FIFO(ul); \
    } \
}

#define DUAL_GLINT_OUTPUT_FIFO_COUNT(nGlint, ul) \
{ \
    if(nGlint) \
    { \
        OUTPUT_FIFO_COUNT_ODD(ul); \
    } \
    else \
    { \
        OUTPUT_FIFO_COUNT(ul); \
    } \
}

//
// macros to access specific GLINT control registers
//

// We decrease the value of InFIFOSpace by 1 because of a bug in Gamma chip
#define GET_INPUT_FIFO_SPACE(n) ( READ_GLINT_CTRL_REG(InFIFOSpace, n) > 120 ? (n=120) : (n>0? n=n-1:n) )


#define GET_DMA_COUNT(c)        READ_GLINT_CTRL_REG(DMACount, c)
#define GET_OUTDMA_COUNT(c)     READ_GLINT_CTRL_REG(OutDMACount, c)

#define SET_DMA_ADDRESS(aPhys, aVirt) { \
    WRITE_GLINT_CTRL_REG(DMAAddress, aPhys); \
}
#define SET_DMA_COUNT(c) { \
    WRITE_GLINT_CTRL_REG(DMACount, c); \
}
#define SET_OUTDMA_ADDRESS(aPhys, aVirt) { \
    WAIT_GLINT_FIFO(2); \
    LD_GLINT_FIFO(GammaTagDMAOutputAddress, aPhys);

#define SET_OUTDMA_COUNT(c) { \
    LD_GLINT_FIFO(GammaTagDMAOutputCount, c);

// Macros to perform logical DMA on a Gamma
//
#define START_QUEUED_DMA(P, C) { \
    WAIT_GLINT_FIFO(2); \
    LD_GLINT_FIFO(GammaTagDMAAddr, P); \
    LD_GLINT_FIFO(GammaTagDMACount, C); \
}

#define WAIT_QUEUED_DMA_COMPLETE { \
    READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_volatile_ul); \
    READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_volatile_ul); \
    if (_temp_volatile_ul & GAMMA_STATUS_COMMAND_DMA_BUSY) { \
    do { \
            for (_temp_volatile_ul = 10; _temp_volatile_ul > 0; --_temp_volatile_ul); \
            READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_volatile_ul); \
        } while (_temp_volatile_ul & GAMMA_STATUS_COMMAND_DMA_BUSY); \
    } \
}

#define VERT_RETRACE_FLAG       (0x10)
#define P2_BYPASS_FLAG          (1 << 7)
#define P2_BUFSWAPCTL_FLAG      (3 << 9)
#define RESET_VERT_RETRACE      WRITE_GLINT_CTRL_REG(IntFlags, VERT_RETRACE_FLAG) 

#define LD_GLINT_FIFO_DBG(tag, d) \
{ \
    DISPDBG((100, "tag 0x%03x <-- 0x%08x [%s]", tag, d, GET_TAG_STR(tag))); \
                                        \
    WRITE_GLINT_FIFO_REG(tag, d); \
    READ_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
    if (GLINT_DELTA_PRESENT) { \
        READ_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul2); \
        _temp_ul |= _temp_ul2; \
    } \
    _temp_ul &= ~0x2; /* we're not interested in output fifo errors */ \
    _temp_ul &= ~0x10; /* ingore any Video FIFO underrun errors on P2 */ \
    _temp_ul &= ~0x2000; /* ingore any HostIn DMA errors on P3 */ \
    if (_temp_ul != 0) { \
        DISPDBG((-1000, "LD_GLINT_FIFO(%s, 0x%X) error 0x%X", GET_TAG_STR(tag), d, _temp_ul)); \
        /*if( _temp_ul & ~0x2000 ) /* ignore, but report, HostIn DMA errors */ \
            /*DebugBreak();*/ \
        WRITE_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
        if (GLINT_DELTA_PRESENT) \
            WRITE_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul); \
    } \
}


#define LD_GLINT_FIFO_FREE(tag, d)   WRITE_GLINT_FIFO_REG(tag, d)

#if DBG
#define LD_GLINT_FIFO(tag, d) LD_GLINT_FIFO_DBG(tag,d)
#else //DBG
#define LD_GLINT_FIFO(tag, d) LD_GLINT_FIFO_FREE(tag,d)
#endif //DBG

#define LD_FIFO_INTERFACE_DBG(d) \
{ \
    WRITE_GLINT_CTRL_REG(InFIFOInterface, d); \
    READ_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
    if (GLINT_DELTA_PRESENT) { \
        READ_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul2); \
        _temp_ul |= _temp_ul2; \
    } \
    _temp_ul &= ~0x2; /* we're not interested in output fifo errors */ \
    _temp_ul &= ~0x10; /* ingore any Video FIFO underrun errors on P2 */ \
    if (_temp_ul != 0) { \
        DISPDBG((-1000, "LD_FIFO_INTERFACE(0x%x) error 0x%x", d, _temp_ul)); \
        DebugBreak(); \
        WRITE_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
        if (GLINT_DELTA_PRESENT) \
            WRITE_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul); \
    } \
}

#define LD_FIFO_INTERFACE_FREE(d)    WRITE_GLINT_CTRL_REG(InFIFOInterface, d)

#if DBG
#define LD_FIFO_INTERFACE(d) LD_FIFO_INTERFACE_DBG(d)
#else //DBG
#define LD_FIFO_INTERFACE(d) LD_FIFO_INTERFACE_FREE(d)
#endif //DBG

// local variables for all functions that access GLINT. Generally we use GLINT_DECL. Sometimes we have to split it 
// up if ppdev isn't passed into the routine.
// NB. Temporary variables:-
//    These are necessary because VC5 doesn't account for the scope of variables within macros, i.e. each 
//    time a macro with (a variable declaration within it's statement block) is used, the stack of the function
//    referencing the macro grows
#define TEMP_MACRO_VARS                 \
    ULONG           _temp_ul;           \
    ULONG           _temp_ul2;          \
    LONG            _temp_i;            \
    volatile int    _temp_volatile_i;   \
    volatile ULONG  _temp_volatile_ul;  \
    volatile PULONG _temp_volatile_pul

#define GLINT_DECL_VARS                 \
    TEMP_MACRO_VARS;                    \
    GlintDataPtr glintInfo

#define GLINT_DECL_INIT \
    glintInfo = (GlintDataPtr)(ppdev->glintInfo)

#define GLINT_DECL \
    GLINT_DECL_VARS; \
    GLINT_DECL_INIT

//@@BEGIN_DDKSPLIT
// Macro that determines whether the chipset supports RAMDAC overlays
//#define RAMDAC_OVERLAYS_AVAILABLE (ppdev->pgfnRamdacSetOverlayMode != NULL)
//@@END_DDKSPLIT

#if(_X86_)
#define SYNCHRONOUS_WRITE_ULONG(var, value) \
{ \
    ULONG *pul = (ULONG *)&var;                \
    ULONG ul = (ULONG)value;                \
    __asm push  ecx                         \
    __asm mov   ecx, ul                     \
    __asm mov   edx, pul                    \
    __asm xchg  ecx, [edx]                    \
    __asm pop   ecx                         \
}
#define SYNCHRONOUS_WRITE_INDIRECT_ULONG(pvar, value) \
{ \
    ULONG *pul = (ULONG *)pvar;                \
    ULONG ul = (ULONG)value;                \
    __asm push  ecx                         \
    __asm mov   ecx, ul                     \
    __asm mov   edx, pul                    \
    __asm xchg  ecx, [edx]                    \
    __asm pop   ecx                         \
}
#else
// to be defined properly
#define SYNCHRONOUS_WRITE_ULONG(memory, value) {(*(PULONG) &memory) = value;}
#endif

#define GET_INTR_CMD_BLOCK_MUTEX(pBlock)\
do { \
    if(glintInfo->pInterruptCommandBlock) \
    { \
        DISPDBG((20, "display driver waiting for interrupt command block mutex")); \
        ASSERTDD(!(pBlock)->bDisplayDriverHasAccess, "Aquiring mutex when it is already aquired!");    \
        SYNCHRONOUS_WRITE_ULONG((pBlock)->bDisplayDriverHasAccess, TRUE); \
        while((pBlock)->bMiniportHasAccess); \
    } \
} while(0)

#define RELEASE_INTR_CMD_BLOCK_MUTEX(pBlock) \
do { \
    if(glintInfo->pInterruptCommandBlock) \
    { \
        DISPDBG((20, "display driver releasing interrupt command block mutex")); \
        SYNCHRONOUS_WRITE_ULONG((pBlock)->bDisplayDriverHasAccess, FALSE); \
    } \
} while(0)

//
// FIFO functions
//

#define MAX_GLINT_FIFO_ENTRIES      16
#define MAX_PERMEDIA_FIFO_ENTRIES   32
#define MAX_P2_FIFO_ENTRIES         258
#define MAX_GAMMA_FIFO_ENTRIES      32
#define MAX_P3_FIFO_ENTRIES         120

#if DBG
// wait for n entries to become free in the input FIFO
#define WAIT_GLINT_FIFO(n) \
{ \
    if (glintInfo->CheckFIFO)    \
    {    \
        GET_DMA_COUNT(_temp_volatile_ul); \
        if (_temp_volatile_ul != 0) { \
            DISPDBG((-999, "WAIT_GLINT_FIFO: DMACount = %d, glintInfo = 0x%x", _temp_volatile_ul, glintInfo)); \
            ASSERTDD(_temp_volatile_ul == 0, "Break."); \
        } \
        while ((GET_INPUT_FIFO_SPACE(_temp_volatile_ul)) < (ULONG)(n)); \
    }    \
}

#else

// WAIT_GLINT_FIFO() - wait for n entries to become free in the input FIFO.
// If PCI disconnect is on permanently then this function is a no-op.

#define WAIT_GLINT_FIFO(n)            /* Do the wait */ \
{ \
    if (glintInfo->CheckFIFO)    \
    {    \
        while ((GET_INPUT_FIFO_SPACE(_temp_volatile_ul)) < (ULONG)(n)); \
    }    \
}

#endif

// WAIT_FIFO_NOT_FULL() waits for any entries to become free in
// the input FIFO and returns this number. If PCI disconnect is switched
// on then we simply return 16 free entries (an empty FIFO).


#define WAIT_FIFO_NOT_FULL(nFifo)                     /* Return FIFO state  */ \
{ \
    ASSERTDD(GET_DMA_COUNT(nFifo) == 0, "WAIT_FIFO_NOT_FULL: DMACount != 0"); \
    nFifo = glintInfo->MaxInFifoEntries;    \
    if (glintInfo->CheckFIFO)    \
    {    \
        while ((GET_INPUT_FIFO_SPACE(nFifo)) == 0); \
    }    \
}


// Wait for DMA to complete (DMACount becomes zero). So as not to kill the
// PCI bus bandwidth for the DMA put in a backoff based on the amount of data
// still left to DMA. Also set the timer going if at any time, the count we
// read is the same as the previous count.
// New for Gamma: if queued DMA is configured then wait till the CommandStatus
// indicates DMA is not busy and the FIFO empty. We do this test twice
// because there is a possibility that the input FIFO will become empty one
// clock before the DMA busy flag is set.
//
#define WAIT_DMA_COMPLETE \
{ \
    if (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE)) { \
        { \
            if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) { \
                /* do any VBLANK wait, wait Q to empty and last DMA to complete */ \
                PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock; \
                while (pBlock->Control & SUSPEND_DMA_TILL_VBLANK); \
                while (pBlock->frontIndex != pBlock->backIndex); \
            } \
            if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) { \
                do { \
                    while (--_temp_volatile_i > 0); \
                } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0); \
            } \
        } \
        ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE; \
    } \
    if (ppdev->currentCtxt == glintInfo->ddCtxtId)    \
        SEND_PXRX_DMA;    \
}


// Simple version which explicitly waits for the DMA to finish ignoring
// interrupt driven DMA and overriding the DMA_COMPLETE flag. This is used
// where code kicks off a DMA but wants to immediately wait for it to
// finish.
//
#define WAIT_IMMEDIATE_DMA_COMPLETE \
{ \
    if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) { \
        do { \
            while (--_temp_volatile_i > 0); \
        } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0); \
    } \
}


#define WAIT_OUTDMA_COMPLETE \
{ \
    if ((GET_OUTDMA_COUNT(_temp_volatile_i)) > 0) { \
        do { \
            while (--_temp_volatile_i > 0); \
        } while ((GET_OUTDMA_COUNT(_temp_volatile_i)) > 0); \
    } \
}

// IS_FIFO_EMPTY() XX

#define IS_FIFO_EMPTY(c) ((glintInfo->CheckFIFO) ? TRUE :    \
            (GET_INPUT_FIFO_SPACE(c) == glintInfo->MaxInFifoEntries))

// wait for the input FIFO to become empty
#define WAIT_INPUT_FIFO_EMPTY \
{ \
    WAIT_GLINT_FIFO(glintInfo->MaxInFifoEntries); \
}

#define WAIT_GLINT_FIFO_AND_DMA(n) \
{ \
    WAIT_DMA_COMPLETE; \
    WAIT_GLINT_FIFO(n); \
}

// wait till the ouput FIFO has some data to be read and return the count
#define WAIT_OUTPUT_FIFO_NOT_EMPTY(n) \
{ \
    do \
    { \
        OUTPUT_FIFO_COUNT(n); \
    } \
    while (n == 0); \
}
#define WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(n) \
{ \
    do \
    { \
        OUTPUT_FIFO_COUNT_ODD(n); \
    } \
    while (n == 0); \
}

// wait for any data to appear in the output FIFO
#define WAIT_OUTPUT_FIFO_READY                \
{                                             \
    WAIT_OUTPUT_FIFO_NOT_EMPTY(_temp_ul);     \
}
#define WAIT_OUTPUT_FIFO_READY_ODD            \
{                                             \
    WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(_temp_ul); \
}

#define SYNC_WITH_GLINT         SYNC_WITH_GLINT_CHIP
#define CTXT_SYNC_WITH_GLINT    SYNC_WITH_GLINT

#define GLINT_CORE_BUSY glintInfo->bGlintCoreBusy = TRUE
#define GLINT_CORE_IDLE glintInfo->bGlintCoreBusy = FALSE
#define TEST_GLINT_CORE_BUSY (glintInfo->bGlintCoreBusy)

#define SYNC_IF_CORE_BUSY \
{ \
    if(glintInfo->bGlintCoreBusy) \
    { \
        SYNC_WITH_GLINT; \
    } \
}

//
// PCI Disconnect enable, disable and sync macros
//

// PCI_DISCONNECT_FASTSYNC()
// turn on disconnect for the input FIFO. We could do a SYNC here but it's quite
// expensive. Instead, add RasterizerMode(0) into the FIFO and when the register
// is set we know the FIFO is empty so turn on disconnect and reset RasterizerMode
// to a sensible value. PCI disconnect means we don't wait for FIFO space.
#define P2_BUSY (1 << 31)

#define PCI_DISCONNECT_FASTSYNC()    \
{    \
    WAIT_GLINT_FIFO(1);    \
    LD_GLINT_FIFO(__GlintTagRasterizerMode, 0);    \
    /* when we see RasterizerMode set to zero */    \
    /*we know we've flushed the FIFO and can enable disconnect */    \
    do {    \
        READ_GLINT_FIFO_REG(__GlintTagRasterizerMode, _temp_volatile_ul);    \
    } while(_temp_volatile_ul);    \
    LD_GLINT_FIFO(__GlintTagRasterizerMode, glintInfo->RasterizerMode);    \

// PCI_DISCONNECT_ENABLE()
// If disconnect is not already enabled then enable it and optionally do a fast
// sync.
#define PCI_DISCONNECT_ENABLE(prevDiscState,quickEnable)    \
{    \
    prevDiscState = glintInfo->PCIDiscEnabled;    \
    if (!glintInfo->PCIDiscEnabled)    \
    {    \
        DISPDBG((7, "PCI_DISCONNECT_ENABLE()"));    \
        if (!quickEnable)    \
        {    \
            PCI_DISCONNECT_FASTSYNC();    \
        }    \
        WRITE_GLINT_CTRL_REG(DisconnectControl, DISCONNECT_INPUT_FIFO_ENABLE);    \
        glintInfo->CheckFIFO = FALSE;    \
        glintInfo->PCIDiscEnabled = TRUE;    \
    }    \
}

// PCI_DISCONNECT_DISABLE()
// If disconnect is not already disabled then disable it and optionally do a fast
// sync.

#define PCI_DISCONNECT_DISABLE(prevDiscState, quickDisable)    \
{    \
    prevDiscState = glintInfo->PCIDiscEnabled;    \
    if (glintInfo->PCIDiscEnabled)    \
    {    \
        DISPDBG((7, "PCI_DISCONNECT_DISABLE()"));    \
        if (!quickDisable)    \
        {    \
            PCI_DISCONNECT_FASTSYNC();    \
        }    \
        WRITE_GLINT_CTRL_REG(DisconnectControl, DISCONNECT_INOUT_DISABLE);    \
        glintInfo->CheckFIFO = TRUE;    \
        glintInfo->PCIDiscEnabled = FALSE;    \
    }    \
}

// macros to set and get the framebuffer packing mode
//
#define GLINT_GET_PACKING_MODE(mode) \
    READ_GLINT_CTRL_REG (FBModeSel, mode)

#define GLINT_SET_PACKING_MODE(mode) { \
    DISPDBG((7, "setting FBModeSel to 0x%x", mode)); \
    WRITE_GLINT_CTRL_REG(FBModeSel, mode); \
    /* READ_GLINT_CTRL_REG (FBModeSel, mode); */ \
}


//
// macro to change the framebuffer packing.
//
#define GLINT_SET_FB_DEPTH(cps) \
{ \
    if (glintInfo->currentPelSize != cps) \
        vGlintChangeFBDepth(ppdev, cps); \
}

#define GLINT_DEFAULT_FB_DEPTH  GLINT_SET_FB_DEPTH(ppdev->cPelSize)
#define GLINTDEPTH8             0
#define GLINTDEPTH16            1
#define GLINTDEPTH32            2
#define GLINTDEPTH24            4

// macro to check and reload FBWindowBase if the target DFB changes
//
#define CHECK_PIXEL_ORIGIN(PixOrg) \
{ \
    if ((LONG)(PixOrg) != glintInfo->PixelOffset) \
    { \
        glintInfo->PixelOffset = (PixOrg); \
        WAIT_GLINT_FIFO(1); \
        LD_GLINT_FIFO(__GlintTagFBWindowBase, glintInfo->PixelOffset); \
        DISPDBG((7, "New bitmap origin at offset %d", glintInfo->PixelOffset)); \
    } \
}

#define GET_GAMMA_FEEDBACK_COMPLETED_COUNT(cEntriesWritten) \
{ \
    READ_GLINT_CTRL_REG(GammaFeedbackSelectCount, cEntriesWritten); \
}

#define PREPARE_GAMMA_OUTPUT_DMA \
{ \
    WRITE_GLINT_CTRL_REG(GammaCommandIntFlags, INTR_CLEAR_GAMMA_OUTPUT_DMA); \
}

#define WAIT_GAMMA_OUTPUT_DMA_COMPLETED \
{ \
    READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_ul); \
    if (!(_temp_ul & INTR_GAMMA_OUTPUT_DMA_SET)) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_ul); \
        } \
        while(!(_temp_ul & INTR_GAMMA_OUTPUT_DMA_SET)); \
    } \
}

// Bitfield definition for IntFlags register
#define PXRX_HOSTIN_COMMAND_DMA_BIT     0x4000

#define PREPARE_PXRX_OUTPUT_DMA     \
{ \
    WRITE_GLINT_CTRL_REG(IntFlags, PXRX_HOSTIN_COMMAND_DMA_BIT); \
}

#define SEND_PXRX_COMMAND_INTERRUPT     \
{ \
    WAIT_GLINT_FIFO(1);        \
    LD_GLINT_FIFO( CommandInterrupt_Tag, 1);    \
}


#define WAIT_PXRX_OUTPUT_DMA_COMPLETED \
{ \
    READ_GLINT_CTRL_REG(IntFlags, _temp_ul); \
    if (!(_temp_ul & PXRX_HOSTIN_COMMAND_DMA_BIT)) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(IntFlags, _temp_ul); \
        } \
        while(!(_temp_ul & PXRX_HOSTIN_COMMAND_DMA_BIT)); \
    } \
}



#define WAIT_GAMMA_INPUT_DMA_COMPLETED \
{ \
    CommandStatusData   CmdSts; \
    READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_ul); \
    CmdSts = *(CommandStatusData *)&_temp_ul; \
    if(CmdSts.CommandDMABusy) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(GammaCommandStatus,  _temp_ul); \
            CmdSts = *(CommandStatusData *)&_temp_ul; \
        } \
        while(CmdSts.CommandDMABusy); \
    } \
}

// Macro to set the delta unit broadcast mask.
// We sync when changing the mask to a anything other than both chips
// in order to avoid hitting a problem on some Gamma boards.
#define SET_BROADCAST_MASK(m) \
{ \
    WAIT_GLINT_FIFO(1); \
    LD_GLINT_FIFO(__DeltaTagBroadcastMask, m); \
}


// Macros for the different types of double buffering supported and buffer
// offsets (in pixels). These are mostly required by 3D extension.
//
#define GLINT_CS_DBL_BUF            (glintInfo->flags & GLICAP_COLOR_SPACE_DBL_BUF)
#define GLINT_FS_DBL_BUF            (glintInfo->flags & GLICAP_FULL_SCREEN_DBL_BUF)
#define GLINT_BLT_DBL_BUF           (glintInfo->flags & GLICAP_BITBLT_DBL_BUF)
#define GLINT_FIX_FAST_FILL         (glintInfo->flags & GLICAP_FIX_FAST_FILLS)
#define GLINT_HW_WRITE_MASK         (glintInfo->flags & GLICAP_HW_WRITE_MASK)
#define GLINT_HW_WRITE_MASK_BYTES   (glintInfo->flags & GLICAP_HW_WRITE_MASK_BYTES)
#define GLINT_INTERRUPT_DMA         (glintInfo->flags & GLICAP_INTERRUPT_DMA)
#define GLINT_FAST_FILL_SIZE        (glintInfo->fastFillBlockSz)
#define GLINT_BUFFER_OFFSET(n)      (glintInfo->bufferOffset[n])

// these are generic for both GLINT and PERMEDIA
#define LOCALBUFFER_PIXEL_WIDTH     (glintInfo->ZBufferWidth)  
#define LOCALBUFFER_PIXEL_OFFSET    (glintInfo->ZBufferOffset)  
#define LOCALBUFFER_PIXEL_COUNT     (glintInfo->ZBufferSize)
#define FONT_MEMORY_OFFSET          (glintInfo->FontMemoryOffset)
#define FONT_MEMORY_SIZE            (glintInfo->FontMemorySize)
#define TEXTURE_MEMORY_OFFSET       (glintInfo->TextureMemoryOffset)  
#define TEXTURE_MEMORY_SIZE         (glintInfo->TextureMemorySize)

// Minimum height of off-screen surface we need to allocate for texture map.
// Use this to work out whether we have enough room to allocate permanent
// things like the brush cache and software cursor caches.
//
#define TEXTURE_OH_MIN_HEIGHT \
    ((((2*4*64*64) >> ppdev->cPelSize) + (ppdev->cxMemory-1)) / ppdev->cxMemory)

// macro to poll for VBLANK. Can be called by any routine which defines
// glintInfo (i.e. use GLINT_DECL at the start of a routine if ppdev
// is available). Technically, VBLANK starts at line 1, but we consider
// any line <= VBLANK_LINE_NUMBER as a valid start.
//
#define VBLANK_LINE_NUMBER      2
#define GLINT_WAIT_FOR_VBLANK                         \
{                                                     \
    ULONG lineNo;                                     \
    do {                                              \
        READ_GLINT_CTRL_REG (VTGVLineNumber, lineNo); \
    } while (lineNo > VBLANK_LINE_NUMBER);            \
}

// macro to return the current video scanline. This can be used to better time
// when to perform bitblt'ed double buffering.
//
#define GLINT_GET_VIDEO_SCANLINE(lineNo) \
{ \
    READ_GLINT_CTRL_REG (VTGVLineNumber, lineNo); \
    if (((lineNo) -= glintInfo->scanFudge) < 0) \
        (lineNo) += glintInfo->vtgvLimit; \
}

//
// external interface to the context switching code. The caller can allocate and
// free a context or ask for a switch to a new context. vGlintSwitchContext
// should not be called except through the given macro. The macro assumes
// that ppdev has been defined.
//

typedef enum ContextType_Tag {
    ContextType_None,            // No context information to save for this context
    ContextType_Fixed,            // Restore sets the chip into a fixed state
    ContextType_RegisterList,    // Save/restore a given set of registers
} ContextType;
typedef void (* ContextFixedFunc)(PPDEV ppdev, BOOL switchingIn);

/*
    To create a new context:
    id = GlintAllocateNewContext(ppdev, pTags, nTags, NumSubBuffs, Private, ContextType_RegisterList );
    id = GlintAllocateNewContext(ppdev, (ULONG *) ContextRestoreFunction, 0, 0, NULL, ContextType_Fixed );
*/

extern LONG GlintAllocateNewContext(PPDEV, DWORD *, LONG, ULONG, PVOID, ContextType);
extern VOID vGlintFreeContext(PPDEV, LONG);
extern VOID vGlintSwitchContext(PPDEV, LONG);

#define NON_GLINT_CONTEXT_ID 0x7fffffff

#define GLINT_VALIDATE_CONTEXT(id) \
    if (((ppdev)->currentCtxt) != (id)) \
        vGlintSwitchContext(ppdev, (id))

#define GLINT_VALIDATE_CONTEXT_AND_SYNC(id) { \
    if (((ppdev)->currentCtxt) != (id)) \
        vGlintSwitchContext(ppdev, (id)); \
    else \
        SYNC_WITH_GLINT; \
}

#define USE_INTERRUPTS_FOR_2D_DMA   1
#if USE_INTERRUPTS_FOR_2D_DMA
#define INTERRUPTS_ENABLED  ((ppdev->flCaps & CAPS_INTERRUPTS) && glintInfo->pInterruptCommandBlock)
#else   // USE_INTERRUPTS_FOR_2D_DMA
#define INTERRUPTS_ENABLED  (FALSE)
#endif  //  USE_INTERRUPTS_FOR_2D_DMA

// macro used by display driver to validate its context
#if ENABLE_DMA_TEXT_RENDERING

#define VALIDATE_DD_CONTEXT \
{ \
    if(DD_DMA_XFER_IN_PROGRESS) \
    { \
        DISPDBG((9, "######## Waiting for DMA to complete ########")); \
        WAIT_DD_DMA_COMPLETE; \
    } \
    else \
    { \
        DISPDBG((9, "######## No DMA in progress ########")); \
    } \
    GLINT_VALIDATE_CONTEXT(glintInfo->ddCtxtId); \
}

#else //ENABLE_DMA_TEXT_RENDERING

#define VALIDATE_DD_CONTEXT \
{ \
    GLINT_VALIDATE_CONTEXT(glintInfo->ddCtxtId); \
}

#endif //ENABLE_DMA_TEXT_RENDERING

//
// useful macros not defined in standard GLINT header files. Generally, for
// speed we don't want to use the bitfield structures so we define the bit
// shifts to get at the various fields.
//
#define INTtoFIXED(i)               ((i) << 16)         // int to 16.16 fixed format
#define FIXEDtoINT(i)               ((i) >> 16)         // 16.16 fixed format to int
#define INTofFIXED(i)               ((i) & 0xffff0000)  // int part of 16.16
#define FRACTofFIXED(i)             ((i) & 0xffff)      // fractional part of 16.16

#define FIXtoFIXED(i)               ((i) << 12)         // 12.4 to 16.16
#define FIXtoINT(i)                 ((i) >> 4)          // 28.4 to 28

#define INT16(i)                    ((i) & 0xFFFF)

#define __GLINT_CONSTANT_FB_WRITE   (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE      (__PERMEDIA_ENABLE | \
                                     (__GLINT_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE   (__PERMEDIA_ENABLE | \
                                     (__GLINT_GOURAUD_SHADE_MODE << 1))

#define MIRROR_BITMASK              (1 << 0)
#define INVERT_BITMASK_BITS         (1 << 1)
#define BYTESWAP_BITMASK            (3 << 7)
#define FORCE_BACKGROUND_COLOR      (1 << 6)    // Permedia only
#define MULTI_GLINT                 (1 << 17)

// bits in the Render command
#define __RENDER_INCREASE_Y             (1 << 22)
#define __RENDER_INCREASE_X             (1 << 21)
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_REUSE_BIT_MASK         (1 << 17)
#define __RENDER_TEXTURE_ENABLE         (1 << 13)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__GLINT_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__GLINT_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__GLINT_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)

// bits in the ScissorMode register
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

// bits in the FBReadMode register
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_PACKED_DATA                (1 << 19)
#define __FB_SCAN_INTERVAL_2            (1 << 23)
// extra bits in PERMEDIA FBReadMode
#define __FB_RELATIVE_OFFSET            20

// P2 also provides a version of Relative Offset in the PackedDataLimits register
#define __PDL_RELATIVE_OFFSET           29


// bits in the LBReadMode register
#define __LB_READ_SOURCE                 (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)
#define __LB_READMODE_PATCH             (1 << 19)
#define __LB_SCAN_INTERVAL_2            (1 << 20)

// bits in the DepthMode register
#define __DEPTH_ENABLE              1
#define __DEPTH_WRITE_ENABLE    (1<<1)
#define __DEPTH_REGISTER_SOURCE     (2<<2)
#define __DEPTH_MSG_SOURCE          (3<<2)
#define __DEPTH_ALWAYS              (7<<4)

// bits in the LBReadFormat/LBWriteFormat registers 
#define __LB_FORMAT_DEPTH32     2

// macros to load indexed tags more efficiently than using __GlintDMATag struct
#define GLINT_TAG_MAJOR(x)        ((x) & 0xff0)
#define GLINT_TAG_MINOR(x)        ((x) & 0x00f)

           
// macro to take a GLINT logical op and return the enabled LogcialOpMode bits
#define GLINT_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#define RECTORIGIN_YX(y,x)                (((y) << 16) | ((x) & 0xFFFF))

#define MAKEDWORD_XY(x, y)                (INT16(x) | (INT16(y) << 16))

// area stipple shifts and bit defines

#define AREA_STIPPLE_XSEL(x)        ((x) << 1)
#define AREA_STIPPLE_YSEL(y)        ((y) << 4)
#define AREA_STIPPLE_XOFF(x)        ((x) << 7)
#define AREA_STIPPLE_YOFF(y)        ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT     (1 << 17)
#define AREA_STIPPLE_MIRROR_X       (1 << 18)
#define AREA_STIPPLE_MIRROR_Y       (1 << 19)

// Some constants
#define ONE                     0x00010000
#define MINUS_ONE               0xFFFF0000
#define PLUS_ONE                ONE
#define NEARLY_ONE              0x0000FFFF
#define HALF                    0x00008000
#define NEARLY_HALF             0x00007FFF

// max length of GIQ conformant lines that GLINT can draw
//
#if 0
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  16
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     194
#else
// Permedia has only 15 bits of fraction so reduce the lengths.
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  (16/2)
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     (194/2)
#endif

#define MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P    194
#define MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N    175
#define P3_LINES_BIAS_P                             0x3EFFFFFF
#define P3_LINES_BIAS_N                             0x3EFEB600


//
// GLINT DMA definitions
//

#define IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

// structure definitions passed in by the application for mapping and
// unmapping DMA buffers.
//

typedef struct _DMA_NUM_BUFFERS {
    ULONG NumBuffers;
    ULONG BufferInformationLength;
} DMA_NUM_BUFFERS, *PDMA_NUM_BUFFERS;

typedef struct _QUERY_DMA_BUFFERS {
    LARGE_INTEGER physAddr;   // physical address of DMA buffer
    PVOID         virtAddr;   // mapped virtual address
    ULONG         size;       // size in bytes
    ULONG         flags;
} QUERY_DMA_BUFFERS, *PQUERY_DMA_BUFFERS;

// values for flags word
#define DMA_BUFFER_INUSE    0x1

// functions to get and free DMA buffers
VOID FreeDMABuffer(PVOID physAddr);
LONG GetFreeDMABuffer(PQUERY_DMA_BUFFERS dmaBuf);

// Generic locling structure/interface that enables arbitrary buffers
// to be locked/unlocked for accessing.
typedef struct _glint_lockedmem_ {
    struct  _MDL *pMdl;
    ULONG   sizeBytes;
    PVOID   bufferPtr;
    ULONG   accessType;
    ULONG   physicalAddress;
    ULONG   result;
} GLINT_LOCKMEM_REC, *PGLINT_LOCKMEM_PTR;

// Routine to support the obtaining of a physical address from a virtual
// address
typedef struct _glint_physaddr_ {
    PVOID   virtualAddress;
    ULONG   physicalAddress;
} GLINT_PHYSADDR_REC, *PGLINT_PHYSADDR_PTR;

// definitions for DMA transfers

#define INPUT_DMA  0
#define OUTPUT_DMA 1

typedef struct DMA_Transfer_Buffer
{
    VOID    *pv;
    ULONG   cb;
    ULONG   DmaDirection;
}
DMAXFERBFRINFO;

// structure definitions for the file handle mapping ioctl
//
typedef struct _GLINT_MAP_FILE_HANDLE {
    ULONG   Size;
    HANDLE  fHandle;
} GLINT_MAP_FILE_HANDLE, *PGLINT_MAP_FILE_HANDLE;

typedef struct _GLINT_UNMAP_FILE_HANDLE {
    HANDLE  fHandle;
    PVOID   pv;
} GLINT_UNMAP_FILE_HANDLE, *PGLINT_UNMAP_FILE_HANDLE;

// structure for the user memory locking ioctls
typedef struct
{
    void    *pvBfr;
    ULONG   cbBfr;
    ULONG   hMem;
}
LOCKEDUSERMEM;

//
// registry variable names
//
#define REG_NUMBER_OF_SCREEN_BUFFERS    L"DoubleBuffer.NumberOfBuffers"

extern GFNXCOPYD vGlintCopyBltBypassDownloadXlate8bpp;

// function declarations
//
extern BOOL bInitializeGlint(PPDEV);
extern BOOL bAllocateGlintInfo(PPDEV ppdev);
extern VOID vDisableGlint(PPDEV);
extern VOID vAssertModeGlint(PPDEV, BOOL);
extern BOOL bGlintQueryRegistryValueUlong(PPDEV, LPWSTR, PULONG);
extern VOID vGlintChangeFBDepth(PPDEV, ULONG);
extern VOID vGlintInitializeDMA(PPDEV);
extern VOID vSetNewGammaValue(PPDEV ppdev, ULONG ulgvFIX16_16, BOOL waitVBlank);
extern BOOL bInstallGammaLUT(PPDEV ppdev, PVIDEO_CLUT pScreenClut, BOOL waitVBlank);

#define GLINT_ENABLE_OVERLAY    1
#define GLINT_DISABLE_OVERLAY   0

//
// Externs/Defines from Pointer.c
// ==============================
//
// Hardware pointer caching functions/macros.
//
extern VOID HWPointerCacheInit (HWPointerCache * ptrCache);
extern VOID HWPointerCacheInvalidate (HWPointerCache * ptrCache);
#define HWPointerCacheInvalidate(ptrCache) (ptrCache)->ptrCacheInUseCount = 0

extern LONG HWPointerCacheCheckAndAdd (HWPointerCache * ptrCache, ULONG cx, 
                                ULONG cy, LONG lDelta, BYTE * scan0, BOOL * isCached);
extern BYTE gajMask[];

//
// The following structures and macros define the memory map for the GLINT
// control registers. We don't use this memory map to access GLINT registers
// since on Alpha machines we want to precompute the addresses. So we do
// a TRANSLATE_ADDR_ULONG on all the addresses here and save them into a
// GlintRegAddrRec. We use that to obtain the addresses for the different
// registers.

typedef struct {
    ULONG   reg;
    ULONG   pad;
} RAMDAC_REG;

// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The id
// is irrelevant as long as it's different from every other id used in the same
// struct. It's a pity pad##__LINE__ doesn't work.
//
#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(GLINT_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

// GLINT registers are 32 bits wide and live on 64-bit boundaries.
typedef struct {
    ULONG   reg;
    ULONG   pad;
} GLINT_REG;

//
// Map of the Core FIFO registers.
//
typedef struct _glint_core_regs {

    // Major Group 0
    GLINT_REG       tag[__MaximumGlintTagValue+1];

} GlintCoreRegMap, *pGlintCoreRegMap;



//
// GLINT PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the coments are offsets from the start
// of the PCI region.
//
typedef struct _glint_region0_map {

    // Control Status Registers:
    GLINT_REG       ResetStatus;                // 0000h
    GLINT_REG       IntEnable;                  // 0008h
    GLINT_REG       IntFlags;                   // 0010h
    GLINT_REG       InFIFOSpace;                // 0018h
    GLINT_REG       OutFIFOWords;               // 0020h
    GLINT_REG       DMAAddress;                 // 0028h
    GLINT_REG       DMACount;                   // 0030h
    GLINT_REG       ErrorFlags;                 // 0038h
    GLINT_REG       VClkCtl;                    // 0040h
    GLINT_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            GLINT_REG       Aperture0;          // 0050h
            GLINT_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            GLINT_REG       ApertureOne;        // 0050h
            GLINT_REG       ApertureTwo;        // 0058h
        };
    };
    GLINT_REG       DMAControl;                 // 0060h
    GLINT_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    GLINT_REG       ChipConfig;                 // 0070h

    // P2 only
    GLINT_REG       AGPControl;                 // 0078h
    GLINT_REG       OutDMAAddress;              // 0080h
    GLINT_REG       OutDMACount;                // 0088h  // P3: FeedbackCount
    PADRANGE(2, 0xA0-0x88);
 
    GLINT_REG       ByDMAAddress;               // 00A0h
    PADRANGE(201, 0xB8-0xA0);

    GLINT_REG       ByDMAStride;                // 00B8h
    GLINT_REG       ByDMAMemAddr;                // 00C0h
    GLINT_REG       ByDMASize;                    // 00C8h
    GLINT_REG       ByDMAByteMask;                // 00D0h
    GLINT_REG       ByDMAControl;                // 00D8h
    PADRANGE(202, 0xE8-0xD8);

    GLINT_REG       ByDMAComplete;                // 00E8h
    PADRANGE(203, 0x108-0xE8);

    GLINT_REG       TextureDownloadControl;        // 0108h 
    PADRANGE(204, 0x200-0x108);

    GLINT_REG       TestInputControl;            // 0200h
    GLINT_REG       TestInputRdy;                // 0208h
    GLINT_REG       TestOutputControl;            // 0210h
    GLINT_REG       TestOutputRdy;                // 0218h
    PADRANGE(205, 0x300-0x218);

    GLINT_REG       PXRXByAperture1Mode;        // 0300h
    GLINT_REG       PXRXByAperture1Stride;        // 0308h
    GLINT_REG       PXRXByAperture1YStart;        // 0310h
    GLINT_REG       PXRXByAperture1UStart;        // 0318h
    GLINT_REG       PXRXByAperture1VStart;        // 0320h
    GLINT_REG       PXRXByAperture2Mode;        // 0328h
    GLINT_REG       PXRXByAperture2Stride;        // 0330h
    GLINT_REG       PXRXByAperture2YStart;        // 0338h
    GLINT_REG       PXRXByAperture2UStart;        // 0340h
    GLINT_REG       PXRXByAperture2VStart;        // 0348h
    GLINT_REG       PXRXByDMAReadMode;            // 0350h
    GLINT_REG       PXRXByDMAReadStride;        // 0358h
    GLINT_REG       PXRXByDMAReadYStart;        // 0360h
    GLINT_REG       PXRXByDMAReadUStart;        // 0368h
    GLINT_REG       PXRXByDMAReadVStart;        // 0370h
    GLINT_REG       PXRXByDMAReadCommandBase;    // 0378h
    GLINT_REG       PXRXByDMAReadCommandCount;    // 0380h
    GLINT_REG       PXRXByDMAWriteMode;            // 0388h
    GLINT_REG       PXRXByDMAWriteStride;        // 0390h
    GLINT_REG       PXRXByDMAWriteYStart;        // 0398h
    GLINT_REG       PXRXByDMAWriteUStart;        // 03A0h
    GLINT_REG       PXRXByDMAWriteVStart;        // 03A8h
    GLINT_REG       PXRXByDMAWriteCommandBase;    // 03B0h
    GLINT_REG       PXRXByDMAWriteCommandCount;    // 03B8h
    PADRANGE(206, 0x800-0x3B8);

    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    // NB. all non-XXX registers are also Gamma registers
    //
    GLINT_REG       DeltaReset;                 // 0800h
    GLINT_REG       DeltaIntEnable;             // 0808h
    GLINT_REG       DeltaIntFlags;              // 0810h
    GLINT_REG       DeltaInFIFOSpaceXXX;        // 0818h
    GLINT_REG       DeltaOutFIFOWordsXXX;       // 0820h
    GLINT_REG       DeltaDMAAddressXXX;         // 0828h
    GLINT_REG       DeltaDMACountXXX;           // 0830h
    GLINT_REG       DeltaErrorFlags;            // 0838h
    GLINT_REG       DeltaVClkCtlXXX;            // 0840h
    GLINT_REG       DeltaTestRegister;          // 0848h
    GLINT_REG       DeltaAperture0XXX;          // 0850h
    GLINT_REG       DeltaAperture1XXX;          // 0858h
    GLINT_REG       DeltaDMAControlXXX;         // 0860h
    GLINT_REG       DeltaDisconnectControl;     // 0868h

    // GLINTgamma registers
    //
    GLINT_REG       GammaChipConfig;            // 0870h
    GLINT_REG       GammaCSRAperture;            // 0878h
    PADRANGE(3, 0x0c00-0x878);
    GLINT_REG       GammaPageTableAddr;            // 0c00h
    GLINT_REG       GammaPageTableLength;        // 0c08h
    PADRANGE(301, 0x0c38-0x0c08);
    GLINT_REG       GammaDelayTimer;            // 0c38h
    GLINT_REG       GammaCommandMode;            // 0c40h
    GLINT_REG       GammaCommandIntEnable;        // 0c48h
    GLINT_REG       GammaCommandIntFlags;        // 0c50h
    GLINT_REG       GammaCommandErrorFlags;        // 0c58h
    GLINT_REG       GammaCommandStatus;            // 0c60h
    GLINT_REG       GammaCommandFaultingAddr;    // 0c68h
    GLINT_REG       GammaVertexFaultingAddr;    // 0c70h
    PADRANGE(302, 0x0c88-0x0c70);
    GLINT_REG       GammaWriteFaultingAddr;        // 0c88h
    PADRANGE(303, 0x0c98-0x0c88);
    GLINT_REG       GammaFeedbackSelectCount;    // 0c98h
    PADRANGE(304, 0x0cb8-0x0c98);
    GLINT_REG       GammaProcessorMode;            // 0cb8h
    PADRANGE(305, 0x0d00-0x0cb8);
    GLINT_REG       GammaVGAShadow;                // 0d00h
    GLINT_REG       GammaMultiGLINTAperture;    // 0d08h    
    GLINT_REG       GammaMultiGLINT1;            // 0d10h
    GLINT_REG       GammaMultiGLINT2;            // 0d18h
    PADRANGE(306, 0x0f00-0x0d18);
    GLINT_REG       GammaSerialAccess;            // 0f00h
    PADRANGE(307, 0x1000-0x0f00);


    // Localbuffer Registers
    union x0 {                                  // 1000h
        GLINT_REG   LBMemoryCtl;                //   GLINT
        GLINT_REG   Reboot;                     //   PERMEDIA
    };
    GLINT_REG       LBMemoryEDO;                // 1008h

    // PXRX Memory control registers
    GLINT_REG       MemScratch;                    // 1010h
    GLINT_REG       LocalMemCaps;                // 1018h
    GLINT_REG       LocalMemTiming;                // 1020h
    GLINT_REG       LocalMemControl;            // 1028h
    GLINT_REG       LocalMemRefresh;            // 1030h
    GLINT_REG       LocalMemPowerDown;            // 1038h

    // PERMEDIA only
    GLINT_REG       MemControl;                 // 1040h
    PADRANGE(5, 0x1068-0x1040);
    GLINT_REG       LocalMemProfileMask0;        // 1068h
    GLINT_REG       LocalMemProfileCount0;        // 1070h
    GLINT_REG       LocalMemProfileMask1;        // 1078h
    GLINT_REG       BootAddress;                // 1080h        // [= LocalMemProfileCount1 on PxRx]
    PADRANGE(6, 0x10C0-0x1080);
    GLINT_REG       MemConfig;                  // 10C0h
    PADRANGE(7, 0x1100-0x10C0);
    GLINT_REG       BypassWriteMask;            // 1100h
    PADRANGE(8, 0x1140-0x1100);
    GLINT_REG       FramebufferWriteMask;       // 1140h
    PADRANGE(9, 0x1180-0x1140);
    GLINT_REG       Count;                      // 1180h
    PADRANGE(10, 0x1800-0x1180);

    // Framebuffer Registers
    GLINT_REG       FBMemoryCtl;                // 1800h
    GLINT_REG       FBModeSel;                  // 1808h
    GLINT_REG       FBGCWrMask;                 // 1810h
    GLINT_REG       FBGCColorMask;              // 1818h
    PADRANGE(11, 0x2000-0x1818);
               
    // Graphics Core FIFO Interface
    GLINT_REG       FIFOInterface;              // 2000h
    PADRANGE(12, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            GLINT_REG   VTGHLimit;              // 3000h
            GLINT_REG   VTGHSyncStart;          // 3008h
            GLINT_REG   VTGHSyncEnd;            // 3010h
            GLINT_REG   VTGHBlankEnd;           // 3018h
            GLINT_REG   VTGVLimit;              // 3020h
            GLINT_REG   VTGVSyncStart;          // 3028h
            GLINT_REG   VTGVSyncEnd;            // 3030h
            GLINT_REG   VTGVBlankEnd;           // 3038h
            GLINT_REG   VTGHGateStart;          // 3040h
            GLINT_REG   VTGHGateEnd;            // 3048h
            GLINT_REG   VTGVGateStart;          // 3050h
            GLINT_REG   VTGVGateEnd;            // 3058h
            GLINT_REG   VTGPolarity;            // 3060h
            GLINT_REG   VTGFrameRowAddr;        // 3068h
            GLINT_REG   VTGVLineNumber;         // 3070h
            GLINT_REG   VTGSerialClk;           // 3078h
            GLINT_REG   VTGModeCtl;               // 3080h
        };
        // PERMEDIA
        struct s2 {
            GLINT_REG   ScreenBase;             // 3000h
            GLINT_REG   ScreenStride;           // 3008h
            GLINT_REG   HTotal;                 // 3010h
            GLINT_REG   HgEnd;                  // 3018h
            GLINT_REG   HbEnd;                  // 3020h
            GLINT_REG   HsStart;                // 3028h
            GLINT_REG   HsEnd;                  // 3030h
            GLINT_REG   VTotal;                 // 3038h
            GLINT_REG   VbEnd;                  // 3040h
            GLINT_REG   VsStart;                // 3048h
            GLINT_REG   VsEnd;                  // 3050h
            GLINT_REG   VideoControl;           // 3058h
            GLINT_REG   InterruptLine;          // 3060h
            GLINT_REG   DDCData;                // 3068h
            GLINT_REG   LineCount;              // 3070h
            GLINT_REG   FifoControl ;           // 3078h
            GLINT_REG   ScreenBaseRight;          // 3080h
        };
    };

    PADRANGE(13, 0x4000-0x3080);

    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    GLINT_REG       ExternalVideo;              // 4000h
    PADRANGE(14, 0x5000-0x4000);

    // P2 specific registers
    union x11 {
        GLINT_REG       ExternalP2Ramdac;           // 5000h
        GLINT_REG       DemonProDWAndStatus;        // 5000h - Pro
    };
    PADRANGE(15, 0x5800-0x5000);
    GLINT_REG       VSConfiguration;            // 5800h
    PADRANGE(16, 0x6000-0x5800);

    union x2 {
        struct s3 {
            GLINT_REG   RacerDoubleWrite;        // 6000h
            GLINT_REG   RacerBankSelect;        // 6008h
        };
        struct s4 {
            // the following array is actually 1024 bytes long
            UCHAR       PermediaVgaCtrl[2*sizeof(GLINT_REG)];
        };
    };

    PADRANGE(17, 0x7000-0x6008);
    GLINT_REG       DemonProUBufB;              // 7000h - Pro
    PADRANGE(18, 0x8000-0x7000);

    // Graphics Core Registers
    GlintCoreRegMap coreRegs;                   // 8000h

} GlintControlRegMap, *pGlintControlRegMap;


//
// DisconnectControl bits
//
#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
#define DISCONNECT_INOUT_DISABLE        0x0

//
// Delta bit definitions
//

#define DELTA_BROADCAST_TO_CHIP(n)        (1 << (n))
#define DELTA_BROADCAST_TO_BOTH_CHIPS     (DELTA_BROADCAST_TO_CHIP(0) | \
                                           DELTA_BROADCAST_TO_CHIP(1))

//
// Multi TX
//

#define GLINT_OWN_SCANLINE_0                (0 << 2)
#define GLINT_OWN_SCANLINE_1                (1 << 2)
#define GLINT_OWN_SCANLINE_2                (2 << 2)
#define GLINT_OWN_SCANLINE_3                (3 << 2)

#define GLINT_SCANLINE_INTERVAL_1           (0 << 0)
#define GLINT_SCANLINE_INTERVAL_2           (1 << 0)
#define GLINT_SCANLINE_INTERVAL_4           (2 << 0)
#define GLINT_SCANLINE_INTERVAL_8           (3 << 0)

#define SCANLINE_OWNERSHIP_EVEN_SCANLINES   (GLINT_OWN_SCANLINE_0 | GLINT_SCANLINE_INTERVAL_2)
#define SCANLINE_OWNERSHIP_ODD_SCANLINES    (GLINT_OWN_SCANLINE_1 | GLINT_SCANLINE_INTERVAL_2)

// Glint Interrupt Control Bits
//
    // InterruptEnable register
#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10
#define INTR_ENABLE_TEXTURE_FAULT       (1 << 6)


    // InterruptFlags register
#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10
#define INTR_TEXTURE_FAULT_SET          (1 << 6)

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10                    

// Gamma Interrupt Control Bits
//
    // CommandIntEnable register
#define GAMMA_INTR_DISABLE_ALL  0x0000
#define GAMMA_INTR_QUEUED_DMA   0x0001
#define GAMMA_INTR_OUTPUT_DMA   0x0002
#define GAMMA_INTR_COMMAND      0x0004
#define GAMMA_INTR_TIMER        0x0008
#define GAMMA_INTR_ERROR        0x0010
#define GAMMA_INTR_CBFR_TIMEOUT 0x0020
#define GAMMA_INTR_CBFR_SUSPEND 0x0040
#define GAMMA_INTR_TEXDOWNLD    0x0080
#define GAMMA_INTR_PF_COMMAND   0x0100
#define GAMMA_INTR_PF_VERTEX    0x0200
#define GAMMA_INTR_PF_FACENORM  0x0400
#define GAMMA_INTR_PF_INDEX     0x0800
#define GAMMA_INTR_PF_WRITE     0x1000
#define GAMMA_INTR_PF_TEXTURE   0x2000

    // CommandIntFlags register - uses the same defines as CommandIntEnable
#define GAMMA_INTR_CLEAR_ALL            0x3fff

    // Gamma Command Interrupts
#define INTR_DISABLE_GAMMA_ALL          0
#define INTR_ENABLE_GAMMA_QUEUED_DMA    (1 << 0)
#define INTR_ENABLE_GAMMA_OUTPUT_DMA    (1 << 1)
#define INTR_ENABLE_GAMMA_COMMAND       (1 << 2)
#define INTR_ENABLE_GAMMA_TIMER         (1 << 3)
#define INTR_ENABLE_GAMMA_COMMAND_ERROR (1 << 4)
#define INTR_ENABLE_GAMMA_PAGE_FAULT    (1 << 8)
#define INTR_ENABLE_GAMMA_VERTEX_FAULT  (1 << 9)
#define INTR_ENABLE_GAMMA_WRITE_FAULT   (1 << 12)

#define INTR_GAMMA_QUEUED_DMA_SET       (1 << 0)
#define INTR_GAMMA_OUTPUT_DMA_SET       (1 << 1)
#define INTR_GAMMA_COMMAND_SET          (1 << 2)
#define INTR_GAMMA_TIMER_SET            (1 << 3)
#define INTR_GAMMA_COMMAND_ERROR_SET    (1 << 4)
#define INTR_GAMMA_PAGE_FAULT_SET       (1 << 8)
#define INTR_GAMMA_VERTEX_FAULT_SET     (1 << 9)
#define INTR_GAMMA_WRITE_FAULT_SET      (1 << 12)

#define INTR_CLEAR_GAMMA_QUEUED_DMA     (1 << 0)
#define INTR_CLEAR_GAMMA_OUTPUT_DMA     (1 << 1)
#define INTR_CLEAR_GAMMA_COMMAND        (1 << 2)
#define INTR_CLEAR_GAMMA_TIMER          (1 << 3)
#define INTR_CLEAR_GAMMA_COMMAND_ERROR  (1 << 4)
#define INTR_CLEAR_GAMMA_PAGE_FAULT     (1 << 8)
#define INTR_CLEAR_GAMMA_VERTEX_FAULT   (1 << 9)
#define INTR_CLEAR_GAMMA_WRITE_FAULT    (1 << 12)

    // Gamma Command Status
#define GAMMA_STATUS_COMMAND_DMA_BUSY   (1 << 0)
#define GAMMA_STATUS_OUTPUT_DMA_BUSY    (1 << 1)
#define GAMMA_STATUS_INPUT_FIFO_EMPTY   (1 << 2)

    // Gamma Command Mode
#define GAMMA_COMMAND_MODE_QUEUED_DMA           (1 << 0)
#define GAMMA_COMMAND_MODE_LOGICAL_ADDRESSING   (1 << 2)
#define GAMMA_COMMAND_MODE_ABORT_OUTPUT_DMA     (1 << 3)
#define GAMMA_COMMAND_MODE_ABORT_INPUT_DMA      (1 << 6)


// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
    DIRECTDRAW_VBLANK_ENABLED   = 0x08,    // Set flag for DirectDraw on VBLANK
    PXRX_SEND_ON_VBLANK_ENABLED = 0x10,    // Set flag for PXRX DMA on VBLANK
    PXRX_CHECK_VFIFO_IN_VBLANK  = 0x20, // Set flag to check VFIFO underruns in VBLANK (vblanks must be permanently enabled)
} INTERRUPT_CONTROL;

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
    GLINT_RACER_BUFFER_0,
    GLINT_RACER_BUFFER_1
} VBLANK_CONTROL_COMMAND;

// we manage a queue of DMA buffers that are to be loaded under interrupt control
// each entry has a physical address and a count to be loaded into GLINT.
//
typedef struct _glint_dma_queue {
    ULONG   command;
    ULONG   address;
    ULONG   count;
} DMABufferQueue;

// Display driver structure for 'general use'.
typedef struct _pointer_interrupt_control
{
    volatile ULONG  bDisplayDriverHasAccess;
    volatile ULONG  bMiniportHasAccess;
    volatile ULONG  bInterruptPending;
    volatile ULONG  bHidden;
    volatile ULONG  CursorMode;
    volatile ULONG  x, y;
} PTR_INTR_CTL;

// Display driver structure for 'pointer use'.
typedef struct _general_interrupt_control
{
    volatile ULONG  bDisplayDriverHasAccess;
    volatile ULONG  bMiniportHasAccess;
} GEN_INTR_CTL;

//
// The volatile fields are the ones that the interrupt handler can change
// under our feet. But, for example, note that the frontIndex is not
// volatile since the ISR can only read this.
//
typedef struct _glint_interrupt_control {

    // contains various status bits. ** MUST BE THE FIRST FIELD **
    volatile INTERRUPT_CONTROL   Control;

    // profiling counters for GLINT busy time
    ULONG   PerfCounterShift;
    ULONG   BusyTime;   // at DMA interrupt add (TimeNow-StartTime) to this
    ULONG   StartTime;  // set this when DMACount is loaded
    ULONG   IdleTime;
    ULONG   IdleStart;

    // commands to perform on the next VBLANK
    volatile VBLANK_CONTROL_COMMAND   VBCommand;

    // flag to indicate whether we expect another DMA interrupt
    volatile ULONG InterruptPending;

    volatile ULONG  DDRAW_VBLANK;                    // flag for DirectDraw to indicate that a VBLANK occured.
    volatile ULONG  bOverlayEnabled;                // TRUE if the overlay is on at all
    volatile ULONG  bVBLANKUpdateOverlay;            // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG  VBLANKUpdateOverlayWidth;        // overlay width (updated in vblank)
    volatile ULONG  VBLANKUpdateOverlayHeight;        // overlay height (updated in vblank)

    // Volatile structures are required to enforce single-threading
    // We need 1 for general display use and 1 for pointer use, because
    // the pointer is synchronous.
    volatile PTR_INTR_CTL   Pointer;
    volatile GEN_INTR_CTL   General;

    // dummy DMA buffer to cause an interrupt but transfer no data
    ULONG   dummyDMAAddress;
    ULONG   dummyDMACount;
    
    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    ULONG   frontIndex;
    volatile ULONG   backIndex;
    ULONG   endIndex;
    ULONG   maximumIndex;

    // For PXRX 2D DMA:
    volatile ULONG  lastAddr;
    PXRXdmaInfo     pxrxDMA;

    // array to contain the DMA queue
    DMABufferQueue  dmaQueue[1];

    // DO NOT PUT ANYTHING AFTER THIS

} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

/***** RACER FULL SCREEN DOUBLE BUFFERING MACROS ***********
 *
 * These macros were invented because some boards, such as 
 * Omnicomp ones, have their bank-switch registers in different places.
 *
 * The macros are:
 *
 *      SET_RACER_BANKSELECT()   - Sets the bank select register to be bank 0 or 1.
 *      GET_RACER_DOUBLEWRITE()  - Returns 1 if double writes are enabled, else returns 0.
 *      SET_RACER_DOUBLEWRITE()  - Sets the double write register to 0 or 1.
 *      IS_RACER_VARIANT_PRO16() - Returns TRUE if the board is an Omnicomp 3DemonPro16, RevC board.
 */

// We define an Omnicomp 3Demon Pro 16 to be a card that has a 16MB framebuffer.
#define SIXTEEN_MEG (16*1024*1024)
#define IS_RACER_VARIANT_PRO16(ppdev)   (glintInfo->deviceInfo.BoardId == OMNICOMP_3DEMONPRO)

//
// the following defines the offset to the External Video register which allows
// switching of the memory banks on a Glint Racer card.
//
#ifndef FIELD_OFFSET
#define FIELD_OFFSET(a, b)    ((LONG)&(((a *)0)->b))
#endif

// The Omnicomp 3Demon Pro 16 board uses different registers to do it's bank switching.

#define DEMON_BANK_SELECT_OFFSET                        \
((FIELD_OFFSET (GlintControlRegMap, DemonProUBufB)) -    \
(FIELD_OFFSET (GlintControlRegMap, ExternalVideo)))

#define REAL_RACER_BANK_SELECT_OFFSET                   \
((FIELD_OFFSET (GlintControlRegMap, RacerBankSelect)) - \
(FIELD_OFFSET (GlintControlRegMap, ExternalVideo)))

#define RACER_BANK_SELECT_OFFSET                        \
(IS_RACER_VARIANT_PRO16(ppdev) ? (DEMON_BANK_SELECT_OFFSET) : (REAL_RACER_BANK_SELECT_OFFSET))

#define SET_RACER_BANKSELECT(bufNo) {                    \
    if (IS_RACER_VARIANT_PRO16(ppdev))                    \
        {WRITE_GLINT_CTRL_REG (DemonProUBufB, bufNo);}    \
    else                                                \
        {WRITE_GLINT_CTRL_REG (RacerBankSelect, bufNo);}\
}

#define GET_RACER_DOUBLEWRITE(onOffVal) {                \
    if (IS_RACER_VARIANT_PRO16(ppdev)) {                \
        READ_GLINT_CTRL_REG (DemonProDWAndStatus, onOffVal);    \
    }                                                    \
    else                                                \
        {READ_GLINT_CTRL_REG (RacerDoubleWrite, onOffVal);}        \
    onOffVal &= 1 ;                                    \
}

#define SET_RACER_DOUBLEWRITE(onOffVal) {                \
    if (IS_RACER_VARIANT_PRO16(ppdev))                    \
        {WRITE_GLINT_CTRL_REG (DemonProDWAndStatus, (onOffVal & 1));}    \
    else                                                \
        {WRITE_GLINT_CTRL_REG (RacerDoubleWrite, (onOffVal & 1));}    \
}

/***** END OF RACER MACROS ***********/
#define MX_EXTRA_WAIT   1
#define GLINT_MX_SYNC \
{ \
    if (GLINT_MX) \
        /*LD_GLINT_FIFO(__GlintTagFBBlockColor, glintInfo->FBBlockColor); */\
        LD_GLINT_FIFO(__GlintTagSync, 0); \
}
  
// DMAControl register setup, when using AGP DMA (p32 of Gamma HRM).
#define DMA_CONTROL_USE_AGP 0xE 
#define DMA_CONTROL_USE_PCI 0x0 

#if USE_LD_GLINT_FIFO_FUNCTION
#   undef LD_GLINT_FIFO
#   define LD_GLINT_FIFO(t, d)  do { loadGlintFIFO( glintInfo, (ULONG) t, (ULONG) d ); } while(0)

    typedef void (* LoadGlintFIFO)( GlintDataPtr, ULONG, ULONG );
    extern LoadGlintFIFO    loadGlintFIFO;
#endif

#if USE_SYNC_FUNCTION
#   undef SYNC_WITH_GLINT_CHIP
#   undef WAIT_DMA_COMPLETE
#   define SYNC_WITH_GLINT_CHIP     do { syncWithGlint(ppdev, glintInfo); } while(0)
#   define WAIT_DMA_COMPLETE        do { waitDMAcomplete(ppdev, glintInfo); } while(0)

    void syncWithGlint( PPDEV ppdev, GlintDataPtr glintInfo );
    void waitDMAcomplete( PPDEV ppdev, GlintDataPtr glintInfo );
#endif

#define SETUP_PPDEV_OFFSETS(ppdev, pdsurf)                                                    \
do                                                                                          \
{                                                                                            \
    ppdev->DstPixelOrigin = pdsurf->poh->pixOffset;                                            \
    ppdev->DstPixelDelta = pdsurf->poh->lPixDelta;                                            \
    ppdev->xyOffsetDst = MAKEDWORD_XY(pdsurf->poh->x, pdsurf->poh->y);                        \
    ppdev->xOffset = (pdsurf->poh->bDXManaged) ? 0 : pdsurf->poh->x;                        \
    ppdev->bDstOffScreen = pdsurf->bOffScreen;                                                \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->DstPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->xOffset += xAdjust;                                                            \
    }                                                                                        \
} while(0);

#define SETUP_PPDEV_SRC_OFFSETS(ppdev, pdsurfSrc)                                            \
do                                                                                          \
{                                                                                            \
    ppdev->SrcPixelOrigin = pdsurfSrc->poh->pixOffset;                                        \
    ppdev->SrcPixelDelta = pdsurfSrc->poh->lPixDelta;                                        \
    ppdev->xyOffsetSrc = MAKEDWORD_XY(pdsurfSrc->poh->x, pdsurfSrc->poh->y);                \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->SrcPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
    }                                                                                        \
} while(0)

#define SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst)                        \
do                                                                                          \
{                                                                                            \
    ppdev->SrcPixelOrigin = pdsurfSrc->poh->pixOffset;                                        \
    ppdev->SrcPixelDelta = pdsurfSrc->poh->lPixDelta;                                        \
    ppdev->xyOffsetSrc = MAKEDWORD_XY(pdsurfSrc->poh->x, pdsurfSrc->poh->y);                \
                                                                                            \
    ppdev->DstPixelOrigin = pdsurfDst->poh->pixOffset;                                        \
    ppdev->DstPixelDelta = pdsurfDst->poh->lPixDelta;                                        \
    ppdev->xyOffsetDst = MAKEDWORD_XY(pdsurfDst->poh->x, pdsurfDst->poh->y);                \
    ppdev->xOffset = (pdsurfDst->poh->bDXManaged) ? 0 : pdsurfDst->poh->x;                    \
    ppdev->bDstOffScreen = pdsurfDst->bOffScreen;                                            \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->DstPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->SrcPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->xOffset += xAdjust;                                                            \
    }                                                                                        \
} while(0)

#define GET_PPDEV_DST_OFFSETS(ppdev, PixOrigin, PixDelta, xyOffset, xOff, bOffScreen)        \
do                                                                                          \
{                                                                                            \
    PixOrigin = ppdev->DstPixelOrigin;                                                        \
    PixDelta = ppdev->DstPixelDelta;                                                        \
    xyOffset = ppdev->xyOffsetDst;                                                            \
    xOff = ppdev->xOffset;                                                                    \
    bOffScreen = ppdev->bDstOffScreen;                                                        \
} while(0)

#define SET_PPDEV_DST_OFFSETS(ppdev, PixOrigin, PixDelta, xyOffset, xOff, bOffScreen)        \
do                                                                                          \
{                                                                                            \
    ppdev->DstPixelOrigin = PixOrigin;                                                        \
    ppdev->DstPixelDelta = PixDelta;                                                        \
    ppdev->xyOffsetDst = xyOffset;                                                            \
    ppdev->xOffset = xOff;                                                                    \
    ppdev->bDstOffScreen = bOffScreen;                                                        \
} while(0)


#endif  // _GLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\enable.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* Content: 
*
*    This module contains the functions that enable and disable the
*   driver, the pdev, and the surface.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

HSEMAPHORE g_cs = (HSEMAPHORE)0;

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,     // ulVersion
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
#if WNT_DDRAW
     GCAPS_DIRECTDRAW       |
#endif  // WNT_DDRAW
     GCAPS_COLOR_DITHER     |
     GCAPS_ASYNCMOVE),          // NOTE: Only enable ASYNCMOVE if your code
                                //   and hardware can handle DrvMovePointer
                                //   calls at any time, even while another
                                //   thread is in the middle of a drawing
                                //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0,                                          // hpalDefault (filled in later)
#if(_WIN32_WINNT >= 0x500)
    GCAPS2_CHANGEGAMMARAMP,                     // flGraphicsCaps2
#endif // (_WIN32_WINNT >= 0x500)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if DBG || !SYNCHRONIZEACCESS_WORKS

// gadrvfn [] - these entries must be in ascending index order, bad things
//              will happen if they aren't.
//              In this debug version we always thunk because we have to explicitly
//              lock between 2D and 3D operations. DrvEscape doesn't lock.

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },    //  0
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },    //  1
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },    //  2
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },    //  3
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },    //  4
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },    //  5
    {   INDEX_DrvResetPDEV,             (PFN) DbgResetPDEV,         },    //  7
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },    // 10
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },    // 11
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },    // 12
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },    // 13
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },    // 14
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },    // 15
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },    // 17
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },    // 18
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },    // 19
//  {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt,        },    // 20
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },    // 22 (SetPalette)
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },    // 23 (TextOut)
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },    // 24
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },    // 29
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },    // 30
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },    // 31
    {   INDEX_DrvSynchronize,           (PFN) DbgSynchronize        },    // 38
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },    // 41
#if WNT_DDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DbgGetDirectDrawInfo  },    // 59
    {   INDEX_DrvEnableDirectDraw,      (PFN) DbgEnableDirectDraw   },    // 60
    {   INDEX_DrvDisableDirectDraw,     (PFN) DbgDisableDirectDraw  },    // 61
#endif // WNT_DDRAW
#if(_WIN32_WINNT >= 0x500)
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DbgIcmSetDeviceGammaRamp }, // 67
//@@BEGIN_DDKSPLIT
// Currently we don't actually have any code to accelerate the following 3 new
// NT5 GDI features, and because P3 driver uses the NT4 driver's way to support
// device bitmap, hooking the entries here will cause failure if strectching is
// involved.
//@@END_DDKSPLIT
#if defined(_NT5GDI)
    {   INDEX_DrvGradientFill,          (PFN) DbgGradientFill       },    // 68
    {   INDEX_DrvAlphaBlend,            (PFN) DbgAlphaBlend         },    // 71
    {   INDEX_DrvTransparentBlt,        (PFN) DbgTransparentBlt     },    // 74
#endif
    {   INDEX_DrvNotify,                (PFN) DbgNotify             },    // 87
//azn    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
#endif  //    (_WIN32_WINNT >= 0x500)
};

#else   // DBG || !SYNCHRONIZEACCESS_WORKS

// gadrvfn [] - these entries must be in ascending index order, bad things
//              will happen if they aren't.
//              On Free builds, directly call the appropriate functions...
// 

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },    //  0
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },    //  1
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },    //  2
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },    //  3
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },    //  4
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },    //  5
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV,         },    //  7
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },    // 10
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },    // 11
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },    // 12
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },    // 13
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },    // 14
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },    // 15
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },    // 17
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },    // 18
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },    // 19
//  {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt,        },    // 20
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },    // 22 (SetPalette)
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },    // 23 (TextOut)
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },    // 24       
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },    // 29
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },    // 30
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },    // 31
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },    // 38
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },    // 41
#if WNT_DDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },    // 59
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },    // 60
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },    // 61
#endif // WNT_DDRAW
#if(_WIN32_WINNT >= 0x500)
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp }, // 67
#if defined(_NT5GDI)
    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill       },    // 68
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend         },    // 71
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt     },    // 74
#endif
    {   INDEX_DrvNotify,                (PFN) DrvNotify             },    // 87
//azn    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
#endif  //    (_WIN32_WINNT >= 0x500)
};

#endif  // DBG || !SYNCHRONIZEACCESS_WORKS
                         
ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvResetPDEV
*
* Notifies the driver of a dynamic mode change.
*
\**************************************************************************/

BOOL DrvResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    PDEV* ppdevNew = (PDEV*) dhpdevNew;
    PDEV* ppdevOld = (PDEV*) dhpdevOld;
    BOOL bRet = TRUE;

    DISPDBG((DBGLVL, "DrvResetPDEV called: oldPDEV = 0x%x, newPDEV = 0x%x", 
                     ppdevOld, ppdevNew));

#if WNT_DDRAW
    _DD_DDE_ResetPPDEV(ppdevOld, ppdevNew);
#endif
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

// We define here DDI_DRIVER_VERSION_NT5_01 in order to be able to compile
// inside the DX DDK. In the Whistler DDK this shouldn't be necessary
#ifndef DDI_DRIVER_VERSION_NT5_01   
#define DDI_DRIVER_VERSION_NT5_01   0x00030100
#endif

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Set up the indirect information, a multi-boardsystem will call
    // the mul functions a single board system will use the one functions

    DISPDBG((DBGLVL, "DrvEnableDriver called: gc %d, ga 0x%x", 
                     gcdrvfn, gadrvfn));

    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= (sizeof(ULONG) * 3))
    {
        pded->pdrvfn = gadrvfn;
    }

    if (cj >= (sizeof(ULONG) * 2))
    {
        pded->c = gcdrvfn;
    }

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
    {
        // Ordered list of supported DDI versions
        ULONG SupportedVersions[] = {
                                        DDI_DRIVER_VERSION_NT5,
                                        DDI_DRIVER_VERSION_NT5_01,
        };
        
        int i = sizeof(SupportedVersions)/sizeof(SupportedVersions[0]);

        // Look for highest version also supported by engine    
        while (--i >= 0)
        {
            if (SupportedVersions[i] <= iEngineVersion) 
            {
                break;
            }
        }

        // Fail if there is no common DDI support
        if (i < 0) 
        {
            return FALSE;
        }

        pded->iDriverVersion = SupportedVersions[i];
    
    }

    // Initialize sync semaphore.

    g_cs = EngCreateSemaphore();

    if (g_cs)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    DISPDBG((DBGLVL, "DrvDisableDriver called:"));
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;
    ULONG   cjOut;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG_GDI(2));
    if (ppdev == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed memory allocation"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    if (!bAllocateGlintInfo(ppdev))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bAllocateGlintInfo"));
        goto ReturnFailure1;
    }

    // initially assume we are allowed to create our off-screen resources.
    // If we decide not to create them, unset the appropriate bit. After,
    // initialization, we can temporarily disable a resource by unsetting
    // its ENABLE bit.

    ppdev->flStatus = ENABLE_DEV_BITMAPS;

#if (_WIN32_WINNT >= 0x500 && WNT_DDRAW)

    // Any DX capable card can support linear heaps. Assume we can support 
    // linear heaps here, this value may be updated in bEnableOffscreenHeap()

    ppdev->flStatus |= ENABLE_LINEAR_HEAP;

#endif //(_WIN32_WINNT >= 0x500)

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    // initialize the image download scratch area and the TexelLUT palette

    ppdev->pohImageDownloadArea = NULL;
    ppdev->cbImageDownloadArea = 0;
    ppdev->iPalUniq = (ULONG)-1;
    ppdev->cPalLUTInvalidEntries = 0;

#if WNT_DDRAW
    // Create the DirectDraw structures associated with this new pdev
    if (!_DD_DDE_CreatePPDEV(ppdev))
    {
        goto ReturnFailure1;
    }
#endif
    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((ERRLVL, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

#if WNT_DDRAW
    // Free the DirectDraw info associated with the pdev

    _DD_DDE_DestroyPPDEV(ppdev);
#endif

    vUninitializePalette(ppdev);

    ENGFREEMEM(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface and initializes the hardware.  This is called
* after DrvEnablePDEV, and performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // First, create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(3));
    if (pdsurf == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed pdsurf memory allocation"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh         = ppdev->pohScreen; // The screen is a surface, too
    pdsurf->poh->pdsurf = pdsurf;
    pdsurf->dt          = DT_SCREEN;        // Not to be confused with a DIB DFB
    pdsurf->bOffScreen  = FALSE;            // it's the screen, not offscreen
    pdsurf->sizl.cx     = ppdev->cxScreen;
    pdsurf->sizl.cy     = ppdev->cyScreen;
    pdsurf->ppdev       = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.  Because this may get swapped out of memory any time
    // the driver is not active, we want to minimize the number of pages
    // it takes up.  We use 'VirtualAlloc' to get an exactly page-aligned
    // allocation (which 'LocalAlloc' will not do):

    pvTmpBuffer = ENGALLOCMEM(FL_ZERO_MEMORY, TMP_BUFFER_SIZE, ALLOC_TAG_GDI(4));
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed TmpBuffer allocation"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;
 
    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bInitializeGlint(ppdev))
        goto ReturnFailure;

    // We could simply let GDI synchronize every time it draws on the screen
    // but this would be even slower. So unset the sync hook if the rendering
    // is done in software.
    //
    if (!bCreateScreenDIBForOH(ppdev, pdsurf->poh, HOOK_SYNCHRONIZE))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

//@@BEGIN_DDKSPLIT
#if 0
    if (!bEnablePointerCache(ppdev))
    {
        DISPDBG((ERRLVL, "Pointer cache failed to initialise"));
    }
#endif
//@@END_DDKSPLIT

#if WNT_DDRAW
    if (!_DD_DDE_bEnableDirectDraw(ppdev))
    {
        goto ReturnFailure;
    }
#endif // WNT_DDRAW

    DISPDBG((DBGLVL, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((ERRLVL, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;

    ppdev = (PDEV*) dhpdev;
    pdsurf = ppdev->pdsurfScreen;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

#if WNT_DDRAW

    _DD_DDE_vDisableDirectDraw(ppdev);

#endif // WNT_DDRAW

//@@BEGIN_DDKSPLIT
#if 0
    vDisablePointerCache(ppdev);
#endif
//@@END_DDKSPLIT
    vDisablePalette(ppdev);
    vDisablePointer(ppdev);
    if (pdsurf != NULL)
        vDeleteScreenDIBFromOH(pdsurf->poh);
    vDisableGlint(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    ENGFREEMEM(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    ENGFREEMEM(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL/VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

#if WNT_DDRAW
        _DD_DDE_vAssertModeDirectDraw(ppdev, FALSE);
#endif WNT_DDRAW

        vAssertModePalette(ppdev, FALSE);
        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeGlint(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeGlint(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);
        vAssertModePalette(ppdev, TRUE);
#if WNT_DDRAW
        _DD_DDE_vAssertModeDirectDraw(ppdev, TRUE);
#endif WNT_DDRAW

    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModeGlint(ppdev, TRUE);
            bAssertModeOffscreenHeap(ppdev, TRUE);
            vAssertModePointer(ppdev, TRUE);
            vAssertModePalette(ppdev, TRUE);
#if WNT_DDRAW
            _DD_DDE_vAssertModeDirectDraw(ppdev, TRUE);
#endif // WNT_DDRAW

        #if (_WIN32_WINNT >= 0x500 && FALSE)
            // There is probably a neater way to do this, but: currently the display driver isn't notified
            // about entering / exiting hibernation so it can't save away those GC registers that it has
            // initialized at the start of day and hasn't bothered to context switch. DrvAssertMode(TRUE)
            // is the first display driver call made upon return from hibernation so we take the 
            // opportunity to re-initialize these registers now. Reinitializing these registers at other
            // times when DrvAssertMode(TRUE) is called (e.g. mode change) should do no harm. Non-GC 
            // registers are dealt with in the miniport's PowerOnReset() and HibernationMode() functions
            { 
                extern void ReinitialiseGlintExtContext(PDEV *ppdev);

                // currently, only the extension context initializes but doesn't context switch certain registers
                ReinitialiseGlintExtContext(ppdev);
            }
        #endif //(_WIN32_WINNT >= 0x500)

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((ERRLVL, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion = DM_SPECVERSION;
                pdm->dmDriverVersion = DM_SPECVERSION;

                //
                // We currently do not support Extra information in the driver
                //

                pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;
                pdm->dmPanningWidth     = pdm->dmPelsWidth;
                pdm->dmPanningHeight    = pdm->dmPelsHeight;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS;
                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((UINT_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((UINT_PTR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    ENGFREEMEM(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    GLINT_DECL;

    if (bEnable)
    {
        DISPDBG((DBGLVL, "enabling hardware"));

        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_QUERY_CURRENT_MODE,
                             NULL,
                             0,
                             &VideoModeInfo,
                             sizeof(VideoModeInfo),
                             &ReturnedDataLength) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto ReturnFalse;
        }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            DISPDBG((ERRLVL, "Video Memory Bitmap width and height set to %d x %d",
                            VideoModeInfo.VideoMemoryBitmapWidth,
                            VideoModeInfo.VideoMemoryBitmapHeight));
        #endif

        // The following variables are determined only after the initial
        // modeset:

        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lDelta   = VideoModeInfo.ScreenStride;
        ppdev->Vrefresh = VideoModeInfo.Frequency;
        ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;

        DISPDBG((DBGLVL, "Got flCaps 0x%x", ppdev->flCaps));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        DISPDBG((DBGLVL, "IOCTL_VIDEO_RESET_DEVICE"));

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    DISPDBG((DBGLVL, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bAssertModeHardware"));

    return(FALSE);
}


/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;
    LONG                     i;
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[3];
    
    DISPDBG((DBGLVL, "bEnableHardware Reached"));

    // Map control registers into virtual memory:

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         &VideoMemory,              // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoAccessRange[0],      // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength) != NO_ERROR)
    {
        RIP("bEnableHardware - Initialization error mapping control registers");
        goto ReturnFalse;
    }

    ppdev->pulCtrlBase[0] = (ULONG*) VideoAccessRange[0].VirtualAddress;
    ppdev->pulCtrlBase[1] = (ULONG*) VideoAccessRange[1].VirtualAddress;
    ppdev->pulCtrlBase[2] = (ULONG*) VideoAccessRange[2].VirtualAddress;

    DISPDBG((DBGLVL, "Mapped GLINT control registers[0] at 0x%x", ppdev->pulCtrlBase[0]));
    DISPDBG((DBGLVL, "Mapped GLINT control registers[1] at 0x%x", ppdev->pulCtrlBase[1]));
    DISPDBG((DBGLVL, "Mapped GLINT control registers[2] at 0x%x", ppdev->pulCtrlBase[2]));
    DISPDBG((DBGLVL, "bEnableHardware: ppdev 0x%x", ppdev));

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;
    
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((DBGLVL, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->FrameBufferLength = VideoMemoryInfo.FrameBufferLength;

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    DISPDBG((DBGLVL, "Width: %li Height: %li Stride: %li Flags: 0x%lx",
            ppdev->cxMemory, ppdev->cyMemory,
            ppdev->lDelta, ppdev->flCaps));

    DISPDBG((DBGLVL, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[3];

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                         &VideoMemory[0],
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pulCtrlBase[0];
    VideoMemory[1].RequestedVirtualAddress = ppdev->pulCtrlBase[1];
    VideoMemory[2].RequestedVirtualAddress = ppdev->pulCtrlBase[2];

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         &VideoMemory[0],
                         sizeof(VideoMemory),
                         NULL,
                         0,
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Determine if we are looking for a default mode:

    if ( ((pdm->dmPelsWidth)    ||
          (pdm->dmPelsHeight)   ||
          (pdm->dmBitsPerPel)   ||
          (pdm->dmDisplayFlags) ||
          (pdm->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((DBGLVL, "Default mode requested"));
    }
    else
    {
        DISPDBG((DBGLVL, "Requested mode..."));
        DISPDBG((DBGLVL, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((DBGLVL, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((DBGLVL, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((DBGLVL, "   Frequency     -- %li", pdm->dmDisplayFrequency));
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((DBGLVL, "   Checking against miniport mode:"));
            DISPDBG((DBGLVL, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((DBGLVL, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((DBGLVL, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                           pVideoTemp->NumberOfPlanes));
            DISPDBG((DBGLVL, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel)) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((DBGLVL, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((DBGLVL, "...Couldn't find a mode match!"));
        ENGFREEMEM(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    ENGFREEMEM(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    DISPDBG((DBGLVL, "ScreenStride: %li", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_FILLPATH   |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_LINETO     |
                               HOOK_PAINT      |
                            // HOOK_STRETCHBLT |
#if (_WIN32_WINNT >= 0x500)
#if defined(_NT5GDI)
                               HOOK_GRADIENTFILL |
                               HOOK_TRANSPARENTBLT |
                               HOOK_ALPHABLEND |
#endif
#endif // (_WIN32_WINNT >= 0x500)
                               0);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;
    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cjPelSize       = 1;
        ppdev->cPelSize        = 0;
        ppdev->iBitmapFormat   = BMF_8BPP;

        if (VideoModeInformation.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)
        {
            ppdev->ulWhite         = 0xff;
        }
        else
        {
            ppdev->flRed           = VideoModeInformation.RedMask;
            ppdev->flGreen         = VideoModeInformation.GreenMask;
            ppdev->flBlue          = VideoModeInformation.BlueMask;
            ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                     VideoModeInformation.GreenMask |
                                     VideoModeInformation.BlueMask;

            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pgdi->ulNumColors      = (ULONG) 256;
            pgdi->ulNumPalReg      = (ULONG) 256;
            pgdi->ulHTOutputFormat = HT_FORMAT_8BPP;
        }
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cjPelSize       = 2;
        ppdev->cPelSize        = 1;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;

    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {
        ppdev->cjPelSize       = 3;
        ppdev->cPelSize        = 4;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->iBitmapFormat   = BMF_24BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;
    }
    else
    {
        ASSERTDD((VideoModeInformation.BitsPerPlane == 32) ||
                 (VideoModeInformation.BitsPerPlane == 12),
                 "This driver supports only 8, 16 and 32bpp");

        ppdev->cjPelSize       = 4;
        ppdev->cPelSize        = 2;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->iBitmapFormat   = BMF_32BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;
    }

    DISPDBG((DBGLVL, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        ENGALLOCMEM(FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength,
                                   ALLOC_TAG_GDI(5));

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((ERRLVL, "getAvailableModes - Failed memory allocation"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp) != NO_ERROR)
    {

        DISPDBG((ERRLVL, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        ENGFREEMEM(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 12) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((WRNLVL, "Rejecting miniport mode:"));
            DISPDBG((WRNLVL, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((WRNLVL, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((WRNLVL, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                        pVideoTemp->NumberOfPlanes));
            DISPDBG((WRNLVL, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}

//*****************************************************************************
// FUNC: DrvEscape
// ARGS: pso (I) - the surface affected by this notification
//
//*****************************************************************************
ULONG APIENTRY DrvEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
   )
{
    PDEV   *ppdev = (PDEV *) pso->dhpdev;
    ULONG   ulResult;
    INT     iQuery;

    DISPDBG((DBGLVL,"In DrvEscape"));

    switch(iEsc)
    {
    case QUERYESCSUPPORT:
        iQuery = *(int *)pvIn;

        switch(iQuery)
        {
        case ESCAPE_TRACK_FUNCTION_COVERAGE:
        case ESCAPE_TRACK_CODE_COVERAGE:
        case ESCAPE_TRACK_MEMORY_ALLOCATION:
            DISPDBG((DBGLVL,"In DrvEscape QUERYESCSUPPORT"));        
            return TRUE;
        default:
            return FALSE;
        }
        break;

    case ESCAPE_TRACK_FUNCTION_COVERAGE:
        ulResult = 0;
#if DBG
        Debug_Func_Report_And_Reset();
        ulResult = 1;
#endif // DBG
        break;
        
    case ESCAPE_TRACK_CODE_COVERAGE:
        ulResult = 0;   
#if DBG
        Debug_Code_Report_And_Reset();
        ulResult = 1;        
#endif // DBG        
        break;
        
    case ESCAPE_TRACK_MEMORY_ALLOCATION:
        ulResult = 0;    
#if DBG
#endif // DBG        
        break;
        
    default:
        DISPDBG((WRNLVL, "DrvEscape: unknown escape %d", iEsc));
        ulResult = 0;
    }

    return ulResult;
}


#if(_WIN32_WINNT >= 0x500)

//*****************************************************************************
// FUNC: DrvNotify
// ARGS: pso (I) - the surface affected by this notification
//       iType (I) - notification type
//       pvData (I) - notification data: format depends on iType
// RETN: void
//-----------------------------------------------------------------------------
//*****************************************************************************

VOID DrvNotify(IN SURFOBJ *pso, IN ULONG iType, IN PVOID pvData)
{
    PDEV *ppdev;

    ASSERTDD(pso->iType != STYPE_BITMAP, "ERROR - DrvNotify called for DIB surface!");

    ppdev = (PDEV *)pso->dhpdev;

    switch(iType)
    {
    case DN_ACCELERATION_LEVEL:
        {
            ULONG ul = *(ULONG *)pvData;

            DISPDBG((DBGLVL, "DrvNotify: DN_ACCELERATION_LEVEL = %d", ul));
        }
        break;

    case DN_DEVICE_ORIGIN:
        {
            POINTL ptl = *(POINTL *)pvData;

            DISPDBG((DBGLVL, "DrvNotify: DN_DEVICE_ORIGIN xy == (%xh,%xh)", ptl.x, ptl.y));
        }
        break;

    case DN_SLEEP_MODE:
        DISPDBG((DBGLVL, "DrvNotify: DN_SLEEP_MODE"));
        break;

    case DN_DRAWING_BEGIN:
        DISPDBG((DBGLVL, "DrvNotify: DN_DRAWING_BEGIN"));

#if ENABLE_DXMANAGED_LINEAR_HEAP
        if((ppdev->flStatus & (ENABLE_LINEAR_HEAP | STAT_DEV_BITMAPS)) == (ENABLE_LINEAR_HEAP | STAT_DEV_BITMAPS))
        {
            if(ppdev->heap.cLinearHeaps)
            {
                // finally free to use the DX heap manager
                DISPDBG((DBGLVL, "DrvNotify: enabling DX heap manager"));
                ppdev->flStatus |= STAT_LINEAR_HEAP;
            }
            else
            {
                DISPDBG((ERRLVL, "DrvNotify: DX heap manager not enabled - there are no DX heaps! Remain using the 2D heap manager"));
            }
        }
#endif //ENABLE_DXMANAGED_LINEAR_HEAP
        break;

    default:
        DISPDBG((WRNLVL, "DrvNotify: unknown notification type %d", iType));
    }
}

#endif //(_WIN32_WINNT >= 0x500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntctxt.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntctxt.h
*
* Content: Defines for context switching code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// each time round allocate this many entries
#define CTXT_CHUNK  8

// each context consists of a set of tags and the corresponding data. so after
// ntags we have 2*ntags*sizeof(DWORD) bytes of memory.
typedef struct _glint_ctxt_data {
    DWORD   tag;
    DWORD   data;
} CtxtData;

typedef struct _glint_ctxt {
    LONG        ntags;
    PVOID       priv;                // opaque handle passed by caller
    DWORD       DoubleWrite;         // Racer double write control
    DWORD       DMAControl;          // AGP or PCI on P2 and Gamma
    ULONG       endIndex;            // endIndex for the interrupt driven DMA Q
    ULONG       inFifoDisc;          // disconnect
    ULONG       VideoControl;        // Video Control
    ContextType type;                // To support reduced size context switching
    ContextFixedFunc    dumpFunc;    // Function for dumping a fixed context
    CtxtData    pData[1];
    // more follows in memory
} GlintCtxtRec;

typedef struct _glint_ctxt_table {
    LONG    size;       // in bytes of the table
    LONG    nEntries;
    GlintCtxtRec*    pEntry[CTXT_CHUNK];
    // more to be allocated in memory if needed
} GlintCtxtTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\fillpath.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: fillpath.c
*
* Content: DrvFillPath support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//@@BEGIN_DDKSPLIT
// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles
//@@END_DDKSPLIT

#include "precomp.h"
#include "glint.h"

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill
    EDGE *pFreeEdges = NULL;   // pointer to memory free for use to store edges                        

    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    GFNFILL     *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev = (PDEV*) pso->dhpdev;
    DSURF       *pdsurf;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];
    ULONG        logicop;
    ULONG        bgLogicop;
    GLINT_DECL;

    DISPDBG((DBGLVL, "Entering Fill Path"));

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL)
    {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    }
    else
    {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2)
    {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt & DT_DIB)
    { 
        DISPDBG((DBGLVL, "Passing to GDI"));
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    REMOVE_SWPOINTER(pso);

    VALIDATE_DD_CONTEXT;

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:
//@@BEGIN_DDKSPLIT
#if 1
//@@END_DDKSPLIT
    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);
//@@BEGIN_DDKSPLIT
#else
    ppdev->DstPixelOrigin = pdsurf->poh->pixOffset;
    ppdev->xyOffsetDst = MAKEDWORD_XY( pdsurf->poh->x, pdsurf->poh->y );
    ppdev->xOffset = pdsurf->poh->x;
#endif
//@@END_DDKSPLIT

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    pfnFill = ppdev->pgfnFillSolid;
    logicop = GlintLogicOpsFromR2[mix & 0xFF];
    bgLogicop = GlintLogicOpsFromR2[mix >> 8];
    iSolidColor     = pbo->iSolidColor;
    rbc.iSolidColor = iSolidColor;
    if (rbc.iSolidColor == -1)
    {
        rbc.prb = pbo->pvRbrush;
        if (rbc.prb == NULL)
        {
            DISPDBG((DBGLVL, "Realizing brush"));
            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
            if (rbc.prb == NULL)
            {
                return(FALSE);
            }
            
            DISPDBG((DBGLVL, "Realized brush"));
        }
        if (rbc.prb->fl & RBRUSH_2COLOR)
        {
            pfnFill = ppdev->pgfnFillPatMono;
        }
        else
        {
            pfnFill = ppdev->pgfnFillPatColor;
        }
    }

    if (bMore)
    {
        // FastFill only knows how to take a single contiguous buffer
        // of points.  Unfortunately, GDI sometimes hands us paths
        // that are split over multiple path data records.  Convex
        // figures such as Ellipses, Pies and RoundRects are almost
        // always given in multiple records.  Since probably 90% of
        // multiple record paths could still be done by FastFill, for
        // those cases we simply copy the points into a contiguous
        // buffer...

        // First make sure that the entire path would fit in the
        // temporary buffer, and make sure the path isn't comprised
        // of more than one subpath:

        if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
            (pd.flags & PD_ENDSUBPATH))
        {
            goto SkipFastFill;
        }

        pptfxTmp = &aptfxBuf[0];

        RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

        pptfxTmp     += pd.count;
        cptfxTmp      = pd.count;
        flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
            cptfxTmp += pd.count;
            pptfxTmp += pd.count;
        } while (!(pd.flags & PD_ENDSUBPATH));

        // Fake up the path data record:
        pd.pptfx  = &aptfxBuf[0];
        pd.count  = cptfxTmp;
        pd.flags |= flFirstRecord;

        // If there's more than one subpath, we can't call FastFill:
        DISPDBG((DBGLVL, "More than one subpath!"));
        if (bMore)
            goto SkipFastFill;
    }

    if ((*ppdev->pgfnFillPolygon)(ppdev, pd.count, pd.pptfx, iSolidColor,
                                logicop, bgLogicop, pco, rbc.prb, pptlBrush))
    {
        DISPDBG((DBGLVL, "Fast Fill Succeeded"));
        return(TRUE);
    }

SkipFastFill:

    DISPDBG((DBGLVL, "Fast Fill Skipped"));

    if (jClipping != DC_TRIVIAL)
    {
        if (jClipping != DC_RECT)
        {
            DISPDBG((DBGLVL, "Complex Clipping"));
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    }
    else
    {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }
    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore)
    {
        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

        // We have to start somewhere so assume that most
        // applications specify the top left point  first
        //
        // we want to check that the first two points are
        // either vertically or horizontally aligned.  if
        // they are then we check that the last point [3]
        // is either horizontally or  vertically  aligned,
        // and finally that the 3rd point [2] is  aligned
        // with both the first point and the last point.

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right)
         {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else
         {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

         // if the left is greater than the right then
         // swap them so the blt code doesn't wig out

         if (rectangle->left > rectangle->right)
         {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else
         {
            // if left == right there's nothing to draw

            if (rectangle->left == rectangle->right)
            {
               DISPDBG((DBGLVL, "Nothing to draw"));
               goto ReturnTrue;
            }
         }

         // shift the values to get pixel coordinates

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom)
         {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else
         {
            if (rectangle->top == rectangle->bottom)
            {
               DISPDBG((DBGLVL, "Nothing to draw"));
               goto ReturnTrue;
            }
         }

         // shift the values to get pixel coordinates

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping

         if (jClipping == DC_RECT)
         {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle))
            {
                // Totally clipped, nothing to do
                DISPDBG((DBGLVL, "Nothing to draw"));
                goto ReturnTrue;
            }
         }

         // if we get here then the polygon is a rectangle,
         // set count to 1 and goto bottom to draw it 

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;
    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES)
    {
#if TAKING_ALLOC_STATS
        BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) ENGALLOCMEM(FL_ZERO_MEMORY, 
                                          (ppo->cCurves * sizeof(EDGE)), 
                                          ALLOC_TAG_GDI(6));
        if (pFreeEdges == NULL)
        {
            DISPDBG((DBGLVL, "Too many edges"));
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else
    {
#if TAKING_ALLOC_STATS
        BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
        // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect))
    {
        DISPDBG((DBGLVL, "Outside Range"));
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead)
        {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead)
        {
            if (GETHead.pNext == pGETHead)
            {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        }
        else
        {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
            {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY)
        {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {
            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0)
            {
                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            }
            else
            {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X)
            {
                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS)
                {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty
                   (*pfnFill)(ppdev, ulNumRects, prclRects, logicop, bgLogicop,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT)
                {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right)
                    {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

// Draw the remaining rectangles, if there are any.

draw_remaining_rectangles:

    if (ulNumRects > 0)
    {
        (*pfnFill)(ppdev, ulNumRects, prclRects, logicop, bgLogicop,
                   rbc, pptlBrush);
    }

ReturnTrue:
    DISPDBG((DBGLVL, "Drawn"));
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        ENGFREEMEM(pFreeEdges);
    }

    DISPDBG((DBGLVL, "Returning %s", bRetVal ? "True" : "False"));
    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.

VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0)
        {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        }
        else
        {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0)
            {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.

VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X)
            {
                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.

VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) 
        {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}

// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
    EDGE     *pGETHead,
    EDGE     *pFreeEdges,
    PATHOBJ  *ppo,
    PATHDATA *pd,
    BOOL      bMore,
    RECTL    *pClipRect)
{
    POINTFIX pfxPathStart;    // point that started the current subpath
    POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

    // Create an empty GET with the head node also a tail sentinel

    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

    // PATHOBJ_vEnumStart is implicitly performed by engine
    // already and first path is enumerated by the caller.

next_subpath:

    // Make sure the PATHDATA is not empty (is this necessary)

    if (pd->count != 0)
    {
       // If first point starts a subpath, remember it as such
       // and go on to the next point, so we can get an edge

       if (pd->flags & PD_BEGINSUBPATH)
       {
           // the first point starts the subpath; remember it
  
           pfxPathStart    = *pd->pptfx; // the subpath starts here
           pfxPathPrevious = *pd->pptfx; // this points starts the next edge
           pd->pptfx++;                  // advance to the next point
           pd->count--;                  // count off this point
       }

       // Add edges in PATHDATA to GET, in Y-X sorted order 

       while (pd->count--)
       {
           if ((pFreeEdges =
                 AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                              pClipRect)) == NULL)
           {
               goto ReturnFalse;
           }

           pfxPathPrevious = *pd->pptfx; // current point becomes previous
           pd->pptfx++;                  // advance to the next point
       }

       // If last point ends the subpath, insert the edge that
       // connects to first point (is this built in already?)

       if (pd->flags & PD_ENDSUBPATH)
       {
           if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                          &pfxPathStart, pClipRect)) == NULL)
           {
               goto ReturnFalse;
           }
       }
   }

   // The initial loop conditions preclude a do, while or for

   if (bMore)
   {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:

    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.

EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order

    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0)
    {
        return(pFreeEdge);  // zero height; ignore this edge
    }
    else if (iYHeight >= 0)
    {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    }
    else
    {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000)
    {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now

    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0)
    {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    }
    else
    {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000)
    {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight)
    {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1)
        {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    }
    else
    {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0)
    {
        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop)
    {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }

    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive

    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

//@@BEGIN_DDKSPLIT
    // LATER adjust only if needed (if prestepped above)?
//@@END_DDKSPLIT
    if (pFreeEdge->iXDirection == 1)
    {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    }
    else
    {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X)))
    {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    // if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    // LONGLONGS are 64 bit integers (We hope!) as the multiply could
    // overflow 32 bit integers. If 64 bit ints are unsupported, the
    // LONGLONG will end up as a double. Hopefully there will be no
    // noticable difference in accuracy.
    LONGLONG NumAdjustDowns;
    LONGLONG tmpError = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    tmpError += (LONGLONG)iErrorAdjustUp * (LONGLONG)yJump;

    // See if the error term turned over even once while skipping
    if (tmpError >= 0)
    {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (tmpError / (LONGLONG)iErrorAdjustDown) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1)
        {
            *pXStart += (LONG) NumAdjustDowns;
        }
        else
        {
            *pXStart -= (LONG) NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        tmpError -= (LONGLONG)iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (LONG)tmpError;

#endif  // X86
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\heap.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.c
*
* Content:
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if WNT_DDRAW
#include "linalloc.h"
#endif

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      4           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

const ULONG HEAP_X_ALIGNMENT_P3[5] = {
    4,    // GLINTDEPTH8
    4,    // GLINTDEPTH16
    32,    // GLINTDEPTH32      = 32 pixels
    0,    // ---
    4,    // GLINTDEPTH24
};


/******************************Public*Routine******************************\
* void UploadDFBToDIB
\**************************************************************************/
void UploadDFBToDIB(PDEV *ppdev, SURFOBJ *pso, DSURF *pdsurf)
{
    OH       *poh = pdsurf->poh;
    RECTL    rclDst;
    POINTL   ptlSrc;
    LONG     xOff;
    LONG     pixOffset;
    LONG     pixDelta;
    ULONG    xyOffsetDst;
    BOOL     bOff;
    GLINT_DECL;

    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    GET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, xyOffsetDst, xOff, bOff);
    SET_PPDEV_DST_OFFSETS(ppdev, poh->pixOffset, poh->lPixDelta, 
                          MAKEDWORD_XY(poh->x, poh->y), 
                          poh->bDXManaged ? 0 : poh->x, pdsurf->bOffScreen);
    VALIDATE_DD_CONTEXT;
    ppdev->pgfnUpload(ppdev, 1, &rclDst, pso, &ptlSrc, &rclDst);

    SET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, xyOffsetDst, xOff, bOff);
}

/******************************Public*Routine******************************\
* void DownloadDIBToDFB
\**************************************************************************/
void DownloadDIBToDFB(PDEV *ppdev, SURFOBJ *pso, DSURF *pdsurf)
{
    OH       *poh = pdsurf->poh;
    RECTL    rclDst;
    POINTL   ptlSrc;
    LONG     xOffset;
    LONG     pixOffset;
    LONG     pixDelta;
    ULONG    xyOffsetDst;
    BOOL     bOff;
    GLINT_DECL;

    // call low level download routine to download the DIB data to the
    // new off-screen DFB. Save and restore the ppdev offsets in case
    // we were called from the middle of some blt routine which has
    // already set them up.
    //
    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    GET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, 
                          xyOffsetDst, xOffset, bOff);
    SET_PPDEV_DST_OFFSETS(ppdev, poh->pixOffset, poh->lPixDelta, 
                          MAKEDWORD_XY(poh->x, poh->y), 
                          poh->bDXManaged ? 0 : poh->x, pdsurf->bOffScreen);

    DISPDBG((DBGLVL,"Converting a DIB back to a DFB. calling image download"));
    VALIDATE_DD_CONTEXT;
    ppdev->pgfnXferImage(ppdev, &rclDst, 1, __GLINT_LOGICOP_COPY, 
                         __GLINT_LOGICOP_COPY, pso, &ptlSrc, &rclDst, NULL);

    SET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, 
                          xyOffsetDst, xOffset, bOff);
}

/******************************Private*Routine******************************\
* OH* GlintVidMemAlloc
*
* Use the DX heap manager to allocate linear memory from off-screen
*
\**************************************************************************/

OH *GlintVidMemAlloc(PDEV *ppdev, OH *pohThis, LONG cxThis, LONG cyThis)
{
    FLATPTR             fp = 0;

#if WNT_DDRAW

    P3_MEMREQUEST       mmrq;
    LinearAllocatorInfo *pvmHeap = NULL;
    LONG                iHeap;
    LONG                lDelta;
    ULONG               Mask32bit;
    GLINT_DECL;

    ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP), 
              "GlintVidMemAlloc: ERROR - "
              "linear allocator called when linear heap not enabled!");

    DISPDBG((DBGLVL, "GlintVidMemAlloc: want cxy(%xh,%xh), cHeaps(%d)", 
                  cxThis, cyThis, ppdev->heap.cLinearHeaps));

    if(ppdev->heap.cLinearHeaps)
    {
        // align to dword boundaries
        Mask32bit = (1 << (2 - ppdev->cPelSize)) - 1;
        lDelta = cxThis + Mask32bit;
        lDelta &= ~Mask32bit;
        lDelta <<= ppdev->cPelSize;

        memset(&mmrq, 0, sizeof mmrq);
        mmrq.dwSize = sizeof mmrq;
        mmrq.dwBytes = lDelta * cyThis;
        mmrq.dwAlign = 16;    // 16 Byte alignment will work for everything
        mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;

retry:
        for (iHeap = 0, fp = 0; 
             iHeap < (LONG)ppdev->heap.cLinearHeaps && fp == 0; 
             ++iHeap)
        {
            pvmHeap = &ppdev->heap.pvmLinearHeap[iHeap];

            // we don't allocate from the AGP heap at present
            if(pvmHeap)
            {
                if(_DX_LIN_AllocateLinearMemory(pvmHeap, &mmrq) == GLDD_SUCCESS)
                {
                    fp = mmrq.pMem;
                }
                else
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: allocation failed"));
                }
            }
        }
        
        if(fp == 0)
        {
            OH *poh;
            LONG cxcyThis = cxThis * cyThis;
            LONG cxcy;

            do
            {
               poh = ppdev->heap.ohDiscardable.pohPrev;
                if (poh == &ppdev->heap.ohDiscardable)
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: FAILED :"
                                  "No discardable bitmaps remaining in "
                                  "offscreen and still not enough room"));
                    return(NULL);
                }
                
                ASSERTDD(poh != &ppdev->heap.ohDiscardable, 
                         "Ran out of discardable entries");
                ASSERTDD(poh->ohState == OH_DISCARDABLE, 
                         "Non-discardable node in discardable list");

                poh = pohMoveOffscreenDfbToDib(ppdev, poh);
                if (poh == NULL)
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: "
                                  "failed to kick DFB into system memory"));
                    return(NULL);
                }
                
                cxcy = poh->cx * poh->cy;
                cxcyThis -= cxcy;
            } 
            while (cxcyThis > 0);

            goto retry;
        }
    }

    if(fp)
    {
        ULONG pixOffset, x, y, xAligned;
                    
        DISPDBG((DBGLVL, "GlintVidMemAlloc: got some memory"
                      " - fp(%08xh) lDelta(%xh)", (ULONG)fp, lDelta));


        pixOffset = (DWORD)(fp >> ppdev->cPelSize);
        y = pixOffset / ppdev->cxMemory;
        x = pixOffset % ppdev->cxMemory;
        
        DISPDBG((DBGLVL, "GlintVidMemAlloc: rectangular values are: "
                      "pixOffset %08xh = xy(%xh,%xh)", pixOffset, x, y));

        xAligned = x & ~((1 << (2 - ppdev->cPelSize)) - 1);
        pixOffset = y * ppdev->cxMemory + xAligned;
        y = 0;
        x -= xAligned;

        pohThis->x = x;
        pohThis->y = y;
        pohThis->cx = cxThis;
        pohThis->cy = cyThis;
        pohThis->lPixDelta = lDelta >> ppdev->cPelSize;
        pohThis->pixOffset = pixOffset;
        pohThis->cxReserved = 0;
        pohThis->cyReserved = 0;
        pohThis->cxcy = CXCY(cxThis, cyThis);
        pohThis->pdsurf = NULL;
        pohThis->pvScan0 = ppdev->pjScreen + fp;
        pohThis->bDXManaged = TRUE;
        pohThis->pvmHeap = pvmHeap;
        pohThis->fpMem = fp;

        DISPDBG((DBGLVL, "GlintVidMemAlloc: linear values are: "
                      "pixOffset(%08xh), xy(%xh,%xh), cxy(%xh,%xh) Delta(%xh)",
                      pohThis->pixOffset = pixOffset, pohThis->x, pohThis->y, 
                      pohThis->cx, pohThis->cy, pohThis->lPixDelta));
    }
    else
    {
        // didn't get any memory - point at the free list 
        // sentinel to register our disappointment
        DISPDBG((DBGLVL, "GlintVidMemAlloc: "
                         "failed to get any offscreen memory"));
         
        for(pohThis = &ppdev->heap.ohFree; 
            pohThis->cxcy != CXCY_SENTINEL; 
            pohThis = pohThis->pohNext)
        {
            NULL;
        }
    }

#endif // WNT_DDRAW

    return(fp ? pohThis : NULL);
}

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        DISPDBG((DBGLVL, "pohNewNode(): allocating new poha block"));

        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = ENGALLOCMEM(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG_GDI(D));
        if (poha == NULL)
        {
            DISPDBG((DBGLVL, "pohNewNode: failed to alloc node array, "
                             "returning NULL"));
            return(NULL);
        }
        
        // Insert this OHALLOC at the begining of the OHALLOC chain:
        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:
        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:
        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    DISPDBG((DBGLVL, "pohNewNode(): returning poh %ph", poh));

    return(poh);
}

/******************************Private*Routine******************************\
* OH* GetFreeNode
*
* returns a node from the free list. If nothing free, returns the sentinel
*
\**************************************************************************/

OH *GetFreeNode(PDEV *ppdev, LONG cxThis, LONG cyThis)
{
    ULONG   cxcyThis = CXCY(cxThis, cyThis);
    OH      *pohThis;

    if((ppdev->flStatus & STAT_LINEAR_HEAP))
    {
        // We don't used the free list - DX does all the heap management
        // just create a node structure and try to alloc from the DX heap. 
        pohThis = pohNewNode(ppdev);
        
        if(pohThis)
        {
            // pohNewNode unlinks the node from the free list - link it 
            // back in as the caller to GetFreeNode will expect it there
            pohThis->pohNext = ppdev->heap.ohFree.pohNext;
            pohThis->pohPrev = ppdev->heap.ohFree.pohNext->pohPrev;
        
            pohThis->pohNext->pohPrev = pohThis;
            pohThis->pohPrev->pohNext = pohThis;

            pohThis = GlintVidMemAlloc(ppdev, pohThis, cxThis, cyThis);
        }
    }
    else
    {
        pohThis  = ppdev->heap.ohFree.pohNext;
    
        // The free list shows holds all the unused (rectangular) regions 
        // on the heap. These are ordered by size. Search through the 
        // list to find the best fit
        while (pohThis->cxcy < cxcyThis)
        {
            ASSERTDD(pohThis->ohState == OH_FREE, 
                     "Non-free node in free list(1)");

            pohThis = pohThis->pohNext;
        }

        while (pohThis->cy < cyThis)
        {
            ASSERTDD(pohThis->ohState == OH_FREE, 
                     "Non-free node in free list(2)");

            pohThis = pohThis->pohNext;
        }
    }
    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
    {
        return;
    }

    DISPDBG((DBGLVL, "vOhFreeNode(): freeing poh %ph", poh));

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ohState            = OH_FREE; //azn was -1
}

/******************************Public*Routine******************************\
* VOID vCalculateMaximumNonPermanent
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximumNonPermanent(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    cxBounds;
    LONG    cyBounds;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;
    cxBounds = 0;
    cyBounds = 0;

    // First time through, loop through the list of free available
    // rectangles:

    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");

            if (poh->cx > cxBounds)
            {
                cxBounds = poh->cx;
            }
            
            if (poh->cy > cyBounds)
            {
                cyBounds = poh->cy;
            }

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of discardable
        // rectangles:

        pohSentinel = &ppdev->heap.ohDiscardable;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
    ppdev->heap.cxBounds = cxBounds;
    ppdev->heap.cyBounds = cyBounds;
}

/******************************Public*Routine******************************\
* BOOL bDiscardEverythingInRectangle
*
* Throws out of the heap any discardable bitmaps that intersect with the
* specified rectangle.
*
\**************************************************************************/

BOOL bDiscardEverythingInRectangle(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    cx,
LONG    cy)
{
    BOOL bRet;
    OH*  poh;
    OH*  pohNext;

    bRet = TRUE;        // Assume success

    poh = ppdev->heap.ohDiscardable.pohNext;
    while (poh != &ppdev->heap.ohDiscardable)
    {
        ASSERTDD(poh->ohState == OH_DISCARDABLE,
                 "Non-discardable node in discardable list");

        pohNext = poh->pohNext;

        if ((poh->x < x + cx) &&
            (poh->y < y + cy) &&
            (poh->x + poh->cx > x) &&
            (poh->y + poh->cy > y))
        {
            // The two rectangles intersect.  Give the boot to the
            // discardable bitmap:

            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
            {
                bRet = FALSE;
            }
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bFreeRightAndBottomSpace
*
* Given a free off-screen rectangle, allocates the upper-left part of
* the rectangle to hold the allocation request, and puts the two rectangles
* comprising the unused right and bottom portions on the free list.
*
\**************************************************************************/

BOOL bFreeRightAndBottomSpace(
PDEV*   ppdev,
OH*     pohThis,
LONG    cxThis,
LONG    cyThis,
BOOL    bQuantum)           // Set if inifitely small allocations should be
                            //   allowed
{
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;
    LONG  cxRem;
    LONG  cyRem;
    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;
    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;
    LONG  cQuantum;
    GLINT_DECL;

    ASSERTDD(glintInfo != NULL, 
             "bFreeRightAndBottomSpace: ppdev->glintInfo is NULL");

    ASSERTDD(pohThis->bDXManaged == FALSE, 
             "bFreeRightAndBottomSpace: ERROR - called for linear DFB");

    // We're going to use the upper-left corner of our given rectangle,
    // and divide the unused remainder into two rectangles which will
    // go on the free list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

#if 1
    // We may get better performance by keeping screen wide rectangles intact.
    if(cyRem < OH_QUANTUM || 
       cxRem < OH_QUANTUM || 
       pohThis->cx != ppdev->cxScreen)
    {
        if (cxRem <= cyRem)
        {
            cxBelow  = cxThis + cxRem;
            cyBeside = cyThis;
        }
        else
        {
            cxBelow  = cxThis;
            cyBeside = cyThis + cyRem;
        }
    }
    else
    {
        // we're allocating a block as wide as the screen: force a 
        // horizontal slice to be taken
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
#else
    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }
#endif

    // If 'bQuantum' is set, we only make new available rectangles of
    // the unused right and bottom portions if they're greater in
    // dimension than OH_QUANTUM (it hardly makes sense to do the
    // book-work to keep around a 2-pixel wide available space, for
    // example):

    cQuantum = (bQuantum) ? 1 : OH_QUANTUM;

    pohBeside = NULL;
    if (cxBeside >= cQuantum)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(FALSE);
    }

    pohBelow = NULL;
    if (cyBelow >= cQuantum)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(FALSE);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxReserved = 0;
        pohBelow->cyReserved = 0;
        pohBelow->cxcy       = cxcy;
        pohBelow->ohState    = OH_FREE;
        pohBelow->x          = pohThis->x;
        pohBelow->y          = pohThis->y + cyThis;
        pohBelow->cx         = cxBelow;
        pohBelow->cy         = cyBelow;
        pohBelow->lPixDelta  = ppdev->cxMemory;
        POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, pohBelow);

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= cQuantum)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxReserved = 0;
        pohBeside->cyReserved = 0;
        pohBeside->cxcy       = cxcy;
        pohBeside->ohState    = OH_FREE;
        pohBeside->x          = pohThis->x + cxThis;
        pohBeside->y          = pohThis->y;
        pohBeside->cx         = cxBeside;
        pohBeside->cy         = cyBeside;
        pohBeside->lPixDelta  = ppdev->cxMemory;
        POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, pohBeside);

        // Modify the current node to reflect the changes we've made:
        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->cxcy = CXCY(pohThis->cx, pohThis->cy);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAtLocation
*
* Attempts to allocate a rectangle at a specific position.
*
\**************************************************************************/

OH* pohMakeRoomAtLocation(
PDEV*   ppdev,
POINTL* pptl,               // Requested position for the rectangle
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // Allocation flags
{
    OH*     poh;
    OH*     pohTop;
    OH*     pohLeft;
    LONG    cxLeft;
    LONG    cyTop;
    OH*     pohRight;


    ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP) == FALSE, 
              "pohMakeRoomAtLocation: ERROR - called for linear DFB");

    if (!(floh & FLOH_ONLY_IF_ROOM))
    {
        // First off, discard any bitmaps that overlap the requested
        // rectangle, assuming we're allowed to:

        if (!bDiscardEverythingInRectangle(ppdev, 
                                           pptl->x, 
                                           pptl->y, 
                                           cxThis, 
                                           cyThis))
        {
            return(NULL);
        }
    }

    // Now see if there is a free rectangle that entirely contains the
    // requested rectangle.

    for (poh = ppdev->heap.ohFree.pohNext;
         poh != &ppdev->heap.ohFree;
         poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState == OH_FREE, "Non-free node in free list(3)");

        // See if the current free rectangle completely contains the
        // requested rectangle:

        if ((poh->x <= pptl->x) &&
            (poh->y <= pptl->y) &&
            (poh->x + poh->cx >= pptl->x + cxThis) &&
            (poh->y + poh->cy >= pptl->y + cyThis))
        {
            // We can't reserve this rectangle, or make it permanent, if it's
            // already been reserved:

            if ((!poh->cxReserved) ||
                ((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0))
            {
                // The 'poh' rectangle entirely contains the requested
                // rectangle.  We may have a situation like this, where
                // the smaller rectangle is the requested rectangle, and
                // the larger rectangle is the available rectangle:
                //
                //     +-------------------+
                //     |                   |
                //     |    +---------+    |
                //     |    |Requested|    |
                //     |    |         |    |
                //     |    +---------+    |
                //     |                   |
                //     +-------------------+
                //
                // We want to make the space to the left and to the top of
                // the requested rectangle available to the heap.  Our
                // free-space routine only knows how to free space to the
                // right and bottom of an allocation, though.  So we will
                // temporarily allocate temporary rectangles to subdivide
                // our rectangle like the following:
                //
                //     +-------------------+
                //     |Top                |
                //     +----+--------------+
                //     |Left|Free          |
                //     |    |              |
                //     |    |              |
                //     |    |              |
                //     +----+--------------+
                //
                // Then, in the resulting 'Free' space, we will allocate the
                // upper-left corner for our requested rectangle, after which
                // we will go back and free the 'Top' and 'Left' temporary
                // rectangles.

                pohTop  = NULL;
                pohLeft = NULL;
                cxLeft  = pptl->x - poh->x;
                cyTop   = pptl->y - poh->y;

                if (cyTop > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, poh->cx, cyTop,
                                                  TRUE))
                    {
                        return(NULL);
                    }

                    pohTop = poh;
                    poh    = pohTop->pohDown;
                }

                if (cxLeft > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, cxLeft, poh->cy,
                                                  TRUE))
                    {
                        pohFree(ppdev, pohTop);
                        return(NULL);
                    }

                    pohLeft = poh;
                    poh     = pohLeft->pohRight;
                }

                ASSERTDD((poh->x == pptl->x) &&
                         (poh->y == pptl->y) &&
                         (poh->x + poh->cx >= poh->x + cxThis) &&
                         (poh->y + poh->cy >= poh->y + cyThis),
                        "poh must properly fit requested rectangle");

                // Finally, we can subdivide to get our requested rectangle:

                if (!bFreeRightAndBottomSpace(ppdev, poh, cxThis, cyThis, FALSE))
                {
                    poh = NULL;         // Fail this call
                }

                // Free our temporary rectangles, if there are any:

                pohFree(ppdev, pohTop);
                pohFree(ppdev, pohLeft);

                return(poh);
            }
        }
    }

    // There was no free rectangle that completely contains the requested
    // rectangle:

    return(NULL);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAnywhere
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohMakeRoomAnywhere(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // May have FLOH_ONLY_IF_ROOM set
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    GLINT_DECL;

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):
    cxThis = (cxThis + (HEAP_X_ALIGNMENT_P3[ppdev->cPelSize] - 1)) & 
               ~(HEAP_X_ALIGNMENT_P3[ppdev->cPelSize] - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxBounds) || (cyThis > ppdev->heap.cyBounds)) 
    {
        DISPDBG((WRNLVL, "Can't allocate (%d x %d) from (%d x %d)!",
                 cxThis, cyThis, ppdev->heap.cxBounds, ppdev->heap.cyBounds));
        return(NULL);
    }

    // Find the first available rectangle the same size 
    // or larger than the requested one:
    cxcyThis = CXCY(cxThis, cyThis);

    pohThis = GetFreeNode(ppdev, cxThis, cyThis);
    if(pohThis == NULL)
    {
        DISPDBG((WRNLVL, "pohMakeRoomAnywhere: "
                         "error, GetFreeNode() returned NULL"));
        return(NULL);
    }

    ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list(9)");

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
        {
            return(NULL);
        }

        DISPDBG((DBGLVL, "> Making room for %li x %li allocation...", 
                         cxThis, cyThis));

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room, oldest allocations first:

        do {
            // (Least-recently created)
            pohThis = ppdev->heap.ohDiscardable.pohPrev;  
            if (pohThis == &ppdev->heap.ohDiscardable)
            {
                return(NULL);
            }

            ASSERTDD(pohThis != &ppdev->heap.ohDiscardable,
                     "Ran out of discardable entries -- Max not set correctly");
            ASSERTDD(pohThis->ohState == OH_DISCARDABLE,
                     "Non-discardable node in discardable list");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
            {
                return(NULL);
            }

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    if ((pohThis->cxReserved) && (floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)))
    {
        // We can't reserve this rectangle, or make it permanent, if it's
        // already been reserved.  So throw absolutely everything out and
        // search the free list.
        //
        // NOTE: This is extremely painful!  A better approach would be to
        //       keep separate 'cxMax' and 'cyMax' variables kept for free
        //       rectangles that are not reserved (cxMax and cyMax
        //       currently include reserved free rectangles).

        if (!bDiscardEverythingInRectangle(ppdev, 0, 0,
                                           ppdev->cxMemory, ppdev->cyMemory))
        {
            return(NULL);
        }

        pohThis = &ppdev->heap.ohFree;
        do {
            pohThis = pohThis->pohNext;

            if (pohThis == &ppdev->heap.ohFree)
            {
                return(NULL);
            }

        } // the free list isn't ordered if the heap is DX managed
          while ((ppdev->flStatus & STAT_LINEAR_HEAP) == 0 && 
                 ((pohThis->cxReserved)  ||
                  (pohThis->cx < cxThis) ||
                  (pohThis->cy < cyThis)));
    }

    if((ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
    {
        if (!bFreeRightAndBottomSpace(ppdev, pohThis, cxThis, cyThis, FALSE))
        {
            return(NULL);
        }
    }

    return(pohThis);
}

/******************************Public*Routine******************************\
* BOOL bOhCommit
*
* If 'bCommit' is TRUE, converts a 'reserved' allocation to 'permanent,'
* moving from off-screen memory any discardable allocations that may have
* been using the space.
*
* If 'bCommit' is FALSE, converts a 'permanent' allocation to 'reserved,'
* allowing the space to be used by discardable allocations.
*
\**************************************************************************/

BOOL bOhCommit(
PDEV*   ppdev,
OH*     poh,
BOOL    bCommit)
{
    BOOL    bRet;
    LONG    cx;
    LONG    cy;
    ULONG   cxcy;
    OH*     pohRoot;
    OH*     pohNext;
    OH*     pohPrev;

    bRet = FALSE;       // Assume failure

    if (poh == NULL)
    {
        return(bRet);
    }

    if ((bCommit) && (poh->cxReserved))
    {
        if (bDiscardEverythingInRectangle(ppdev, poh->x, poh->y,
                                          poh->cxReserved, poh->cyReserved))
        {
            DISPDBG((DBGLVL, "Commited %li x %li at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

            poh->ohState = OH_PERMANENT;

            // Remove this node from the free list:

            poh->pohPrev->pohNext = poh->pohNext;
            poh->pohNext->pohPrev = poh->pohPrev;

            // Now insert the node at the head of the permanent list:

            pohRoot = &ppdev->heap.ohPermanent;

            poh->pohNext = pohRoot->pohNext;
            poh->pohPrev = pohRoot;

            pohRoot->pohNext->pohPrev = poh;
            pohRoot->pohNext          = poh;

            bRet = TRUE;
        }
    }
    else if ((!bCommit) && (poh->ohState == OH_PERMANENT))
    {
        DISPDBG((DBGLVL, "Decommited %li x %li at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

        poh->ohState    = OH_FREE;
        poh->cxReserved = poh->cx;
        poh->cyReserved = poh->cy;

        // Remove this node from the permanent list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;

        // Now insert the node, in order, into the free list:

        cxcy = poh->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = poh;
        pohNext->pohPrev    = poh;
        poh->pohPrev        = pohPrev;
        poh->pohNext        = pohNext;

        bRet = TRUE;
    }

    // Recalculate the biggest rectangle available for allocation:
    vCalculateMaximumNonPermanent(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF   *pdsurf;
    HBITMAP hbmDib;
    SURFOBJ *pso;
    GLINT_DECL;

    DISPDBG((DBGLVL, "Throwing out poh %p -- %li x %li at (%li, %li)!",
                  poh, poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0 || poh->bDXManaged),
            "Can't make the visible screen into a DIB");
    ASSERTDD((pdsurf->dt & DT_DIB) == 0,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                UploadDFBToDIB(ppdev, pso, pdsurf);

                // delete the screen DIB. Recreate it when 
                // we change the DIB back to a DFB
                vDeleteScreenDIBFromOH(poh);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;
                pdsurf->poh   = NULL;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}


/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    // Throw out any discardable bitmaps over the entire surface:

    return(bDiscardEverythingInRectangle(ppdev, 0, 0,
                                         ppdev->cxMemory, ppdev->cyMemory));
}


/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates a rectangle in off-screen memory.
*
* Types:
*
*   FLOH_RESERVE
*
*     Reserves an off-screen rectangle.  The space may still be used by
*     discardable bitmaps until the rectangle is committed via 'bOhCommit'.
*
*   FLOH_MAKE_PERMANENT
*
*     Allocates an off-screen rectangle that can never be booted
*     of the heap.   It's the caller's responsibility to manage
*     the rectangle, which includes what to do with the memory in
*     DrvAssertMode when the display is changed to full-screen
*     mode.
*
*   Default
*
*     Allocates a 'discardable' off-screen rectangle for a DFB that may
*     be  kicked out of off-screen if the space is needed.
*
* Options:
*
*   FLOH_ONLY_IF_ROOM
*
*     Allocates an off-screen rectangle only if there is free space
*     available -- i.e., no discardable rectangles will be moved out of
*     off-screen to make room.
*
*   Default
*
*     May move discardable rectangles out of off-screen to make room.
*
* Arguments:
*
*   pptl
*
*     If NULL, the rectangle will be allocated anywhere in un-used offscreen
*     memory.
*
*     If non-NULL, is a requested position for the rectangle.
*
*     NOTE: The heap will quickly fragment if arbitrary positions are
*           requested.  This position option works best if there is only
*           one specific rectangle ever requested, or if the allocations
*           are always wider than they are high.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
POINTL* pptl,           // Optional requested position of rectangle
LONG    cxThis,         // Width of rectangle to be allocated
LONG    cyThis,         // Height of rectangle to be allocated
FLOH    floh)           // Allocation flags
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;    // Point to root of list where we'll insert node
    ULONG   cxcy;
    OH*     pohNext;
    OH*     pohPrev;

    ASSERTDD((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT))
                  != (FLOH_RESERVE | FLOH_MAKE_PERMANENT),
             "Illegal flags -- can't set both "
             "FLOH_RESERVE and FLOH_MAKE_PERMANENT");

    DISPDBG((DBGLVL, "pohAllocate: size  %d %d", cxThis, cyThis));

    if (pptl == NULL)
    {
        pohThis = pohMakeRoomAnywhere(ppdev, cxThis, cyThis, floh);
        if (pohThis == NULL)
        {
            DISPDBG((DBGLVL, "Can't allocate %li x %li with flags %li",
                             cxThis, cyThis, floh));
        }
    }
    else
    {
        pohThis = pohMakeRoomAtLocation(ppdev, pptl, cxThis, cyThis, floh);
        if (pohThis == NULL)
        {
            DISPDBG((DBGLVL, "Can't allocate %li x %li at %li, "
                             "%li with flags %li",
                             cxThis, cyThis, pptl->x, pptl->y, floh));
        }
    }

    if (pohThis == NULL)
    {
        return(NULL);
    }

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    if(pohThis->bDXManaged)
    {
        // in the linear coordinate system: 
        // pixOffset == offset of DFB from the start of the FB
        // y == scanline offset from pixOffset (always 0)
        // x == pixel offset from pixOffset+y*lDelta 
        // (always the pixel offset from the nearest dword aligned pixel)
        pohThis->pvScan0 = ppdev->pjScreen + 
                           ( ( pohThis->pixOffset              + 
                               pohThis->y * pohThis->lPixDelta + 
                               pohThis->x) 
                             << ppdev->cPelSize );
    }
    else
    {
        // in the rectangular coordinate system, for non-PX/RX chips: 
        // pixOffset == value of y expressed in pixels from the start of FB
        // y == pixOffset / lDelta (lDelta is always cxMemory)
        // x == pixel offset to DFB from the beginning of its scanline.
        // For PX/RX chips pixOffset is always 0, y is the number of scanlines 
        // to the DFB from the start of the FB
        pohThis->pvScan0 = ppdev->pjScreen + 
                           ( ( pohThis->y * pohThis->lPixDelta + 
                               pohThis->x) 
                             << ppdev->cPelSize );
    }

    // The caller is responsible for setting this field:

    pohThis->pdsurf = NULL;

    // Our 'reserve' logic expects the node to have 'free' status:

    ASSERTDD(pohThis->ohState == OH_FREE, "Node not free after making room");
    ASSERTDD(((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0) ||
             (pohThis->cxReserved == 0),
             "Can't reserve a rectangle that's already reserved");

    if (floh & FLOH_RESERVE)
    {

        ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP) == FALSE, 
                  "pohAllocate() - can't reserve when the heap is DX managed");

        // A non-zero value for 'cxReserved' means it's reserved:

        pohThis->cxReserved = pohThis->cx;
        pohThis->cyReserved = pohThis->cy;

        // Remove this node from its place in the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        // Now insert the node, in order, back into the free list:

        cxcy = pohThis->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext = pohThis;
        pohNext->pohPrev = pohThis;
        pohThis->pohPrev = pohPrev;
        pohThis->pohNext = pohNext;
    }
    else
    {
        // Remove this node from the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        if (floh & FLOH_MAKE_PERMANENT)
        {
            // Change status of node and insert into permanent list:

            pohThis->ohState = OH_PERMANENT;
            pohRoot = &ppdev->heap.ohPermanent;

            // Calculate the new maximum size rectangle available
            // for allocation:

            vCalculateMaximumNonPermanent(ppdev);
        }
        else
        {
            // Change status of node and insert into discardable list:

            pohThis->ohState = OH_DISCARDABLE;
            pohRoot = &ppdev->heap.ohDiscardable;
        }

        // Now insert the node at the head of the appropriate list:

        pohThis->pohNext = pohRoot->pohNext;
        pohThis->pohPrev = pohRoot;

        pohRoot->pohNext->pohPrev = pohThis;
        pohRoot->pohNext          = pohThis;
    }

    DISPDBG((DBGLVL, "   Allocated (%li x %li) at (%li, %li) with flags %li",
                cxThis, cyThis, pohThis->x, pohThis->y, floh));

    return(pohThis);
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG   cxcy;
    OH*     pohBeside;
    OH*     pohNext;
    OH*     pohPrev;
    OHSTATE oldState;

    if (poh == NULL)
    {
        DISPDBG((WRNLVL, "pohFree: passed in NULL poh"));
        return(NULL);
    }

    DISPDBG((DBGLVL, "Freeing poh %p -- %li x %li at (%li, %li)", 
                     poh, poh->cx, poh->cy, poh->x, poh->y));

    oldState = poh->ohState;
    if (oldState != OH_DISCARDABLE)
    {
        // We can remove the 'reserved' status unless we are merely
        // deleting a discardable rectangle that was temporarily
        // placed in a reserve rectangle:

        poh->cxReserved = 0;
        poh->cyReserved = 0;
    }

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

    if(poh->bDXManaged)
    {
#if WNT_DDRAW
        
        DISPDBG((DBGLVL, "pohFree: calling DX free for item %p on heap %p", 
                (VOID *)poh->fpMem, poh->pvmHeap));
                
        if(poh->pvmHeap == NULL)
        {
            DISPDBG((ERRLVL,"pohFree: poh %p -- linear DFB is invalid!", poh));
        }
        else
        {
            _DX_LIN_FreeLinearMemory(poh->pvmHeap, (ULONG)(poh->fpMem) );
            poh->pvmHeap = NULL;
            poh->fpMem = 0;
            
#if 1 //azntst for MP leak      
            // Remove this node from whatever list it's in:
            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            // Add the node the the list of free nodes
            vOhFreeNode(ppdev, poh);      

            // Set the current state as FREE
            poh->ohState     = OH_FREE;
            
            return(poh);             // with DX managing it, we can return now.
#endif               
        }
#endif // WNT_DDRAW

     
        goto MergeComplete; //azntst Now a NOP
    }


MergeLoop:

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((poh->cxReserved    != poh->cx)         &&
        (pohBeside->ohState == OH_FREE)         &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the free list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((poh->cyReserved     != poh->cy)        &&
        (pohBeside->ohState  == OH_FREE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Don't do any more merge this rectangle into anything to the
    // top or to the left if it's reserved:

    if (!poh->cxReserved)
    {
        // Try merging with the left sibling:

        pohBeside = poh->pohLeft;
        if ((pohBeside->cxReserved != pohBeside->cx) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cy         == poh->cy)       &&
            (pohBeside->pohUp      == poh->pohUp)    &&
            (pohBeside->pohDown    == poh->pohDown)  &&
            (pohBeside->pohRight   == poh)           &&
            (poh->pohRight->pohLeft != poh))
        {
            // We add our rectangle to the one to the left:

            pohBeside->cx      += poh->cx;
            pohBeside->pohRight = poh->pohRight;

            // Remove 'poh' from whatever list it was in (if we were
            // asked to free a 'permanent' node, it will have been in
            // the permanent list) and free it:

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }

        // Try merging with the upper sibling:

        pohBeside = poh->pohUp;
        if ((pohBeside->cyReserved != pohBeside->cy) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cx         == poh->cx)       &&
            (pohBeside->pohLeft    == poh->pohLeft)  &&
            (pohBeside->pohRight   == poh->pohRight) &&
            (pohBeside->pohDown    == poh)           &&
            (poh->pohDown->pohUp != poh))
        {
            pohBeside->cy      += poh->cy;
            pohBeside->pohDown  = poh->pohDown;

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }
    }

MergeComplete:

    // Remove this node from whatever list it's in:

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node, in order, into the free list:
    // NB. DX managed DFBs don't need to go in any order - 
    // they are organised by DirectX instead

    pohNext = ppdev->heap.ohFree.pohNext;
    if(!poh->bDXManaged)
    {
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->cxcy        = cxcy;
    poh->ohState     = OH_FREE;

    if (oldState == OH_PERMANENT)
    {
        // Removing the permanent entry means that we may be able to
        // enlarge the maximum possible rectangle we can allow:

        vCalculateMaximumNonPermanent(ppdev);
    }

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bCreateScreenDIBForOH
*
* Given an OH create a surface for the bitmap which is accessible by GDI.
* So if we can't handle any drawing using GLINT we can get GDI to draw
* driectly to the screen. This is possible because we map the screen in
* fully and linearly. We can use this for the screen and off-screen bitmaps.
*
* Returns: FALSE if we didn't create the surface, TRUE if we did.
*
\**************************************************************************/

BOOL
bCreateScreenDIBForOH(PPDEV ppdev, OH *poh, ULONG hooks)
{
    DSURF   *pdsurf = poh->pdsurf;
    UCHAR   *pvBits = poh->pvScan0;
    LONG    lDelta = poh->lPixDelta << ppdev->cPelSize;
    HBITMAP hbmDib;
    SURFOBJ *pso;    

    DISPDBG((DBGLVL, "bCreateScreenDIBForOH: poh at 0x%x, pdsurf at 0x%x, "
                     "pvBits 0x%x", poh, pdsurf, pvBits));

    hbmDib = EngCreateBitmap(pdsurf->sizl,
                            (ULONG)lDelta,
                            (ULONG)(ppdev->iBitmapFormat),
                            (FLONG)(((lDelta > 0) ? BMF_TOPDOWN : 0)),
                            (PVOID)pvBits);
    if (hbmDib) 
    {
        
        // set HOOK_SYNCHRONIZE so that GDI will call DrvSynchronize before
        // drawing on this surface. This means we can call Eng anytime safe
        // in the knowledge that DrvSynchronize will sync for us.
        //
        if (EngAssociateSurface((HSURF)hbmDib, ppdev->hdevEng, hooks))
        {            
            // NB: use the temporary pso so we don't overwrite pdsurf->pso 
            // if we fail
            if (pso = EngLockSurface((HSURF)hbmDib)) 
            {
                pdsurf->pso = pso;
                DISPDBG((DBGLVL, "created surface 0x%x", pso));
                return(TRUE);
            }
        }

        EngDeleteSurface((HSURF)hbmDib);
    }

    DISPDBG((DBGLVL, "bCreateScreenDIBForOH failed"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL vDeleteScreenDIBFromOH
*
* Given an OH delete any screen DIB surface associated with it. We choose to
* do a lazy creation of GDI accessible bitmaps for DFBs. So there may not be
* any surface to delete. 
*
* Returns:
*
\**************************************************************************/

VOID
vDeleteScreenDIBFromOH(OH *poh)
{
    DSURF   *pdsurf = poh->pdsurf;
    SURFOBJ *pso;
    HSURF   hsurf;

    DISPDBG((DBGLVL, "vDeleteScreenDIBFromOH called"));
    if (!(pso = pdsurf->pso)) 
    {
        DISPDBG((DBGLVL, "no surface to delete"));       
        return;
    }

    hsurf = pso->hsurf;         // can't dereference pso when unlocked
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);    // pdsurf->pso can now be reassigned 
                                // to a memory DIB
    DISPDBG((DBGLVL, "surface 0x%x deleted", pso));
}


/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    HSURF       hsurf;
    LONG        cy;

    ASSERTDD(pdsurf->dt & DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:
    if (!ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS))
    {
        return(FALSE);
    }

    // XXX
    // 
    // for the GeoTwin all off-screen bitmaps must start on an even scanline.
    // This is so that even coordinates always map to the same chip.
    cy = pdsurf->sizl.cy;
    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        cy = (cy + 1) & ~1;
        DISPDBG((DBGLVL, "move: sizl.cy evened up to %d for GeoTwin", cy));
    }

    poh = pohAllocate(ppdev, NULL, pdsurf->sizl.cx, cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    poh->pdsurf   = pdsurf;
    pdsurf->poh   = poh;

    // recreate the screen DIB. Do it here so that if we fail we can zap poh and
    // leave the bitmap as a memory DIB.

    if (!bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE)) 
    {
        DISPDBG((DBGLVL, "bCreateScreenDIBForOH failed"));
        goto ReturnFail;
    }
    
    pdsurf->dt         = DT_SCREEN;
    pdsurf->bOffScreen = TRUE;
    DownloadDIBToDFB(ppdev, pso, pdsurf);

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):
    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);

ReturnFail:
    pohFree(ppdev, poh);
    DISPDBG((DBGLVL, "bMoveDibToOffscreenDfbIfRoom failed"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev = (PDEV*) dhpdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;
    LONG    cy = sizl.cy;
    LONG    cx = sizl.cx;
    GLINT_DECL;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.
    // Also check that off-screen DFBs are configured.

    if (!ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS))
    {
        return(0);
    }

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
    {
        DISPDBG((DBGLVL, "DrvCreateDeviceBitmap(): can't create bitmap of "
                         "format %d size(%d,%d), only bitmaps of format %d "
                         "supported!", iFormat, cx, cy, ppdev->iBitmapFormat));
        return(0);
    }

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((cx <= 8) && (cy <= 8))
    {
        return(0);
    }

    // XXX
    // 
    // for the GeoTwin all off-screen bitmaps must start on an even scanline.
    // This is so that even coordinates always map to the same chip.
    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        cy = (cy + 1) & ~1;
        DISPDBG((DBGLVL, "create: sizl.cy evened up to %d for GeoTwin", cy));
    }

    if(ppdev->pohImageDownloadArea)
    {
        DISPDBG((DBGLVL, "DrvCreateDeviceBitmap: discarding image download "
                         "scratch area"));
        pohFree(ppdev, ppdev->pohImageDownloadArea);
        ppdev->pohImageDownloadArea = NULL;
        ppdev->cbImageDownloadArea = 0;
    }

    poh = pohAllocate(ppdev, NULL, cx, cy, 0);
    if (poh != NULL)
    {
        pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(E));
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                #if SYNCHRONIZEACCESS_WORKS && (_WIN32_WINNT < 0x500)
                {
                // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                // want all drawing to the bitmaps to be synchronized (GDI
                // is multi-threaded and by default does not synchronize
                // device bitmap drawing -- it would be a Bad Thing for us
                // to have multiple threads using the accelerator at the
                // same time):

                flHooks |= HOOK_SYNCHRONIZEACCESS;
                }
                #endif // SYNCHRONIZEACCESS_WORKS && (_WIN32_WINNT < 0x500)

                // It's a device-managed surface; make sure we don't set
                // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:

                flHooks &= ~HOOK_SYNCHRONIZE;

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->bOffScreen = TRUE;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    // create the GDI accessible screen bitmap
                    if (bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE)) 
                    {
                        DISPDBG((DBGLVL, "DFB created at (%d,%d), w %d, h %d",
                            poh->x, poh->y, poh->cx, poh->cy));

                        return(hbmDevice);
                    }

                    EngDeleteSurface((HSURF) hbmDevice);

                    // Once association is done, EngDeleteSurface
                    // callback driver's DrvDeleteDeviceBitmap,
                    // then pdsurf and poh are freed there, so that
                    // we don't need to free it here.
                }
                else
                {
                    EngDeleteSurface((HSURF) hbmDevice);
                    ENGFREEMEM(pdsurf);
                    pohFree(ppdev, poh);
                }
            }
            else
            {
                ENGFREEMEM(pdsurf);
                pohFree(ppdev, poh);
            }
        }
        else
        {
            pohFree(ppdev, poh);
        }
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if ((pdsurf->dt & DT_DIB) ||
        (pdsurf->dt & DT_DIRECTDRAW))
    {
        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }
    else if (pdsurf->dt & DT_SCREEN)
    {
        vDeleteScreenDIBFromOH(pdsurf->poh);
        pohFree(ppdev, pdsurf->poh);
    }

    ENGFREEMEM(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        ENGFREEMEM(poha);
        poha = pohaNext;
    }

    // the linear heap, if enabled, must be disabled now
    ppdev->flStatus &= ~STAT_LINEAR_HEAP;

}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    POINTL      ptlScreen;
    LONG        virtualcxMemory;
    GLINT_DECL;

    virtualcxMemory = ppdev->cxMemory;

    DISPDBG((DBGLVL, "Screen: %li x %li  Memory: %li x %li, "
                     "virtualcxMem %li x %li", ppdev->cxScreen, 
                     ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory, 
                     virtualcxMemory));

    ASSERTDD((ppdev->cxScreen <= virtualcxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
    {
        goto ReturnFalse;
    }

    // The first node describes the entire video memory size:

    poh->pohNext      = &ppdev->heap.ohFree;
    poh->pohPrev      = &ppdev->heap.ohFree;
    poh->ohState      = OH_FREE;
    poh->x            = 0;
    poh->y            = 0;
    poh->lPixDelta    = ppdev->cxMemory;
    poh->cx           = virtualcxMemory;
    poh->cy           = ppdev->cyMemory;
    poh->cxcy         = CXCY(virtualcxMemory, ppdev->cyMemory);
    poh->pohLeft      = &ppdev->heap.ohFree;
    poh->pohUp        = &ppdev->heap.ohFree;
    poh->pohRight     = &ppdev->heap.ohFree;
    poh->pohDown      = &ppdev->heap.ohFree;
    poh->pvScan0      = ppdev->pjScreen;
    poh->pixOffset    = 0;

    // The second node is our free list sentinel:

    ppdev->heap.ohFree.pohNext         = poh;
    ppdev->heap.ohFree.pohPrev         = poh;
    ppdev->heap.ohFree.cxcy            = CXCY_SENTINEL;
    ppdev->heap.ohFree.cx              = 0x7fffffff;
    ppdev->heap.ohFree.cy              = 0x7fffffff;
    ppdev->heap.ohFree.ohState         = OH_FREE;

    // Initialize the discardable list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.
    // This node is also used for the screen-surface, for its offset:

    ppdev->heap.ohDiscardable.pohNext = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.pohPrev = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.ohState = OH_DISCARDABLE;

    // Initialize the permanent list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.

    ppdev->heap.ohPermanent.pohNext = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.pohPrev = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.ohState = OH_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

#if (_WIN32_WINNT >= 0x500)

    if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
    {
        // in Windows 2000 we use the DX linear heap for DFBs. 
        // NB. the DX heaps aren't initialized until after the display 
        //     driver has initialized, therefore
        //     we use the old rectangular heap for 2D cache allocation.
        ppdev->heap.pvmLinearHeap = NULL;
        ppdev->heap.cLinearHeaps = 0;
    }

#endif //(_WIN32_WINNT >= 0x500)

    ptlScreen.x = 0;
    ptlScreen.y = 0;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocate(ppdev, &ptlScreen, ppdev->cxScreen, ppdev->cyScreen,
                      FLOH_MAKE_PERMANENT);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0) &&
             (poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen),
             "Screen allocation messed up");

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = virtualcxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    // We do NOT want to hook any of the drawing functions.  Once we
    // send this surf